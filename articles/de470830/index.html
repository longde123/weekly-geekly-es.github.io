<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♾ 🤽🏼 👩‍👦‍👦 Async / warte in C #: Konzept, internes Design, nützliche Tricks 🕯️ 🤴🏼 👩🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. Lassen Sie uns diesmal über ein Thema sprechen, das jeder selbstbewusste Anhänger der C # -Sprache zu verstehen begann - asynchrone Program...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Async / warte in C #: Konzept, internes Design, nützliche Tricks</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470830/">  Guten Tag.  Lassen Sie uns diesmal über ein Thema sprechen, das jeder selbstbewusste Anhänger der C # -Sprache zu verstehen begann - asynchrone Programmierung mit Task oder, bei gewöhnlichen Menschen, asynchron / warten.  Microsoft hat gute Arbeit geleistet - um Asynchronität zu verwenden, müssen Sie in den meisten Fällen nur die Syntax und keine weiteren Details kennen.  Aber wenn Sie tief gehen, ist das Thema ziemlich umfangreich und komplex.  Es wurde von vielen gesagt, jeder in seinem eigenen Stil.  Es gibt viele coole Artikel zu diesem Thema, aber es gibt immer noch viele Missverständnisse.  Wir werden versuchen, die Situation zu korrigieren und das Material so weit wie möglich zu kauen, ohne dabei die Tiefe oder das Verständnis zu beeinträchtigen. <br><br><img src="https://habrastorage.org/webt/zn/or/r1/znorr1o7rsk1tzudgdrmgchrss4.jpeg"><br><a name="habracut"></a><br>  Behandelte Themen / Kapitel: <br><br><ol><li> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Konzept der Asynchronität</a></b> - die Vorteile von Asynchronität und Mythen über einen "blockierten" Thread </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TAP.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Syntax- und Kompilierungsbedingungen</a></b> - Voraussetzungen für das Schreiben einer Kompilierungsmethode </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeiten Sie mit TAP</a></b> - der Mechanik und dem Verhalten des Programms in asynchronem Code (Freigeben von Threads, Starten von Aufgaben und Warten auf deren Abschluss) </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinter den Kulissen: die Zustandsmaschine</a></b> - eine Übersicht über die Compiler-Transformationen und die von ihr generierten Klassen </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Ursprünge der Asynchronität.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Gerät der asynchronen Standardmethoden</a></b> - asynchrone Methoden für die Arbeit mit Dateien und dem Netzwerk von innen </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TAP-Klassen und -Tricks</a></b> sind nützliche Tricks, mit denen Sie ein Programm mithilfe von TAP verwalten und beschleunigen können </li></ol><a name="conception"></a><br><h2>  Asynchrones Konzept </h2><br>  Asynchronität an sich ist alles andere als neu.  Asynchronität impliziert normalerweise das Ausführen einer Operation in einem Stil, der nicht das Blockieren des aufrufenden Threads bedeutet, dh das Starten der Operation, ohne auf deren Abschluss zu warten.  Blockieren ist nicht so böse wie beschrieben.  Man kann auf Behauptungen stoßen, dass blockierte Threads CPU-Zeit verschwenden, langsamer arbeiten und Regen verursachen.  Scheint letzteres unwahrscheinlich?  Tatsächlich sind die vorherigen 2 Punkte gleich. <br><br>  Wenn sich ein Thread auf der Ebene des Betriebssystem-Schedulers in einem "blockierten" Zustand befindet, wird ihm keine wertvolle Prozessorzeit zugewiesen.  Scheduler-Aufrufe fallen in der Regel auf Vorgänge, die Blockierungen, Timer-Interrupts und andere Interrupts verursachen.  Das heißt, wenn beispielsweise der Plattencontroller den Lesevorgang abschließt und einen geeigneten Interrupt initiiert, startet der Scheduler.  Er entscheidet, ob ein Thread gestartet werden soll, der durch diesen Vorgang blockiert wurde, oder ein anderer mit einer höheren Priorität. <br><br>  Langsame Arbeit scheint noch absurder.  In der Tat ist die Arbeit ein und dieselbe.  Nur die asynchrone Operation erhöht den Overhead etwas. <br><br>  Die Herausforderung des Regens ist in der Regel nicht etwas aus diesem Bereich. <br><br>  Das Hauptblockierungsproblem ist der unangemessene Verbrauch von Computerressourcen.  Selbst wenn wir die Zeit vergessen, einen Thread zu erstellen und mit einem Pool von Threads zu arbeiten, benötigt jeder blockierte Thread zusätzlichen Speicherplatz.  Nun, es gibt Szenarien, in denen nur ein Thread bestimmte Arbeiten ausführen kann (z. B. ein UI-Thread).  Dementsprechend möchte ich nicht, dass er mit einer Aufgabe beschäftigt ist, die ein anderer Thread ausführen kann, und die Leistung von Operationen opfert, die ausschließlich für ihn gelten. <br><br>  Asynchronität ist ein sehr weit gefasstes Konzept und kann auf viele Arten erreicht werden. <br>  <b>In der Geschichte von .NET kann Folgendes unterschieden werden</b> : <br><br><ol><li>  EAP (Event-based Asynchronous Pattern) - Wie der Name schon sagt, basiert die Wanderung auf Ereignissen, die nach Abschluss der Operation ausgelöst werden, und der üblichen Methode, die diese Operation aufruft </li><li>  APM (Asynchronous Programming Model) - basierend auf 2 Methoden.  Die BeginSmth-Methode gibt die IAsyncResult-Schnittstelle zurück.  Die EndSmth-Methode akzeptiert IAsyncResult (wenn der Vorgang zum Zeitpunkt des Aufrufs von EndSmth nicht abgeschlossen ist, wird der Thread blockiert). </li><li>  TAP (Task-based Asynchronous Pattern) ist das gleiche asynchrone / warten (genau genommen erschienen diese Wörter nach dem Ansatz und die Arten von Task und Task &lt;TResult&gt; erschienen, aber async / await hat dieses Konzept erheblich verbessert). </li></ol><br>  Der letztere Ansatz war so erfolgreich, dass jeder die vorherigen erfolgreich vergaß.  Es wird also um ihn gehen. <br><a name="tap_syntax"></a><br><h2>  Aufgabenbasiertes asynchrones Muster.  Syntax- und Kompilierungsbedingungen </h2><br>  Die asynchrone Standardmethode im TAP-Stil ist sehr einfach zu schreiben. <br><br>  <b>Dazu benötigen Sie</b> : <br><br><ol><li>  Damit der Rückgabewert Task, Task &lt;T&gt; oder void ist (nicht empfohlen, wird später erläutert).  In C # 7 kamen aufgabenähnliche Typen (im letzten Kapitel besprochen).  In C # 8 werden IAsyncEnumerable &lt;T&gt; und IAsyncEnumerator &lt;T&gt; zu dieser Liste hinzugefügt. </li><li>  Damit ist die Methode mit dem Schlüsselwort async markiert und enthält wait in.  Diese Schlüsselwörter sind gepaart.  Wenn die Methode "Warten" enthält, müssen Sie sie außerdem als asynchron markieren. Das Gegenteil ist nicht der Fall, aber sinnlos </li><li>  Halten Sie sich aus Anstand an die Async-Suffix-Konvention.  Natürlich wird der Compiler dies nicht als Fehler betrachten.  Wenn Sie ein sehr anständiger Entwickler sind, können Sie mit einem CancellationToken (im letzten Kapitel beschrieben) Überladungen hinzufügen. </li></ol><br>  Für solche Methoden leistet der Compiler ernsthafte Arbeit.  Und sie werden hinter den Kulissen völlig unkenntlich, aber dazu später mehr. <br><br>  Es wurde erwähnt, dass die Methode das Schlüsselwort await enthalten sollte.  Es (das Wort) zeigt an, dass asynchron auf die Ausführung der Aufgabe gewartet werden muss. Dies ist das Aufgabenobjekt, auf das es angewendet wird. <br><br>  <b>Das Task-Objekt hat auch bestimmte Bedingungen, so dass das Warten auf es angewendet werden kann:</b> <br><br><ol><li>  Der erwartete Typ muss eine öffentliche (oder interne) GetAwaiter () -Methode haben. Er kann auch eine Erweiterungsmethode sein.  Diese Methode gibt ein Warteobjekt zurück. </li><li>  Das Warteobjekt muss die INotifyCompletion-Schnittstelle implementieren, für die die void OnCompleted-Methode (Action Continuation) implementiert werden muss.  Es sollte auch die Instanzeigenschaft bool IsCompleted haben, die void GetResult () -Methode.  Es kann entweder eine Struktur oder eine Klasse sein. </li></ol><br>  Das folgende Beispiel zeigt, wie ein int erwartet und sogar nie ausgeführt wird. <br><br><div class="spoiler">  <b class="spoiler_title">Erweiterung int</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WeirdExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AnyTypeAwaiter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAwaiter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnyTypeAwaiter(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AnyTypeAwaiter</span></span> : <span class="hljs-title"><span class="hljs-title">INotifyCompletion</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCompleted =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCompleted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action continuation</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } }</code> </pre> <br></div></div><br><a name="tap_progr"></a><br><h2>  Arbeiten Sie mit TAP </h2><br>  Es ist schwierig, in den Dschungel zu gehen, ohne zu verstehen, wie etwas funktionieren soll.  Berücksichtigen Sie TAP im Hinblick auf das Programmverhalten. <br><br>  In der Terminologie: Die fragliche asynchrone Methode, deren Code berücksichtigt wird, ich werde die <b>asynchrone Methode</b> aufrufen, und die aufgerufenen asynchronen Methoden darin werde ich die <b>asynchrone Operation</b> aufrufen. <br><br>  Nehmen wir das einfachste Beispiel: Als asynchrone Operation verwenden wir Task.Delay, das um die angegebene Zeit verzögert, ohne den Stream zu blockieren. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DelayOperationAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//   { BeforeCall(); Task task = Task.Delay(1000); //  AfterCall(); await task; AfterAwait(); }</span></span></span></span></code> </pre><br>  Die Ausführung der Methode in Bezug auf das Verhalten ist wie folgt. <br><br><ol><li>  Der gesamte Code, der dem Aufruf der asynchronen Operation vorausgeht, wird ausgeführt.  In diesem Fall ist dies die <i>BeforeCall-</i> Methode </li><li>  Ein asynchroner Operationsaufruf wird ausgeführt.  Zu diesem Zeitpunkt wird der Thread nicht freigegeben oder blockiert.  Diese Operation gibt das Ergebnis zurück - das erwähnte Task-Objekt (normalerweise Task), das in einer lokalen Variablen gespeichert ist </li><li>  Der Code wird nach dem Aufrufen der asynchronen Operation, jedoch vor dem Warten (Warten) ausgeführt.  Im Beispiel - <i>AfterCall</i> </li><li>  Warten auf den Abschluss des Aufgabenobjekts (das in einer lokalen Variablen gespeichert ist) - Warten Sie auf die Aufgabe. <br><br>  Wenn der asynchrone Vorgang zu diesem Zeitpunkt abgeschlossen ist, wird die Ausführung synchron im selben Thread fortgesetzt. <br><br>  Wenn die asynchrone Operation nicht abgeschlossen ist, wird der Code gespeichert, der nach Abschluss der asynchronen Operation (der sogenannten Fortsetzung) aufgerufen werden muss, und der Stream kehrt zum Thread-Pool zurück und steht zur Verwendung zur Verfügung. </li><li>  Die Ausführung von Operationen nach dem Warten - <i>AfterAwait</i> - wird entweder sofort im selben Thread ausgeführt, wenn die Operation zum Zeitpunkt des Wartens abgeschlossen wurde, oder nach Abschluss der Operation wird ein neuer Thread erstellt, der fortgesetzt wird (im vorherigen Schritt gespeichert). </li></ol><br><a name="internals"></a><br><h2>  Hinter den Kulissen.  Zustandsmaschine </h2><br>  Tatsächlich wird unsere Methode vom Compiler in eine Stub-Methode umgewandelt, in der die generierte Klasse - die Zustandsmaschine - initialisiert wird.  Dann startet es (die Maschine) und das in Schritt 2 verwendete Task-Objekt wird von der Methode zurückgegeben. <br><br>  Von besonderem Interesse ist die <i>MoveNext-</i> Methode der <i>Zustandsmaschine</i> .  Diese Methode macht das, was es vor der Konvertierung in der asynchronen Methode war.  Es bricht den Code zwischen jedem wartenden Anruf.  Jedes Teil wird in einem bestimmten Zustand der Maschine ausgeführt.  Die <i>MoveNext-</i> Methode selbst wird als Fortsetzung an das <i>Warteobjekt</i> angehängt.  Die Erhaltung des Staates garantiert die Ausführung genau des Teils, der logischerweise der Erwartung entsprach. <br><br>  Wie sie sagen, ist es besser, 1 Mal zu sehen, als 100 Mal zu hören. Ich empfehle Ihnen daher dringend, sich mit dem folgenden Beispiel vertraut zu machen.  Ich habe den Code ein wenig umgeschrieben, die Benennung von Variablen verbessert und großzügig kommentiert. <br><br><div class="spoiler">  <b class="spoiler_title">Quellcode</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delays</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Stub-Methode</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AsyncStateMachine(typeof(DelaysStateMachine))</span></span>] [DebuggerStepThrough] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delays</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DelaysStateMachine stateMachine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DelaysStateMachine(); stateMachine.taskMethodBuilder = AsyncTaskMethodBuilder.Create(); stateMachine.currentState = <span class="hljs-number"><span class="hljs-number">-1</span></span>; AsyncTaskMethodBuilder builder = stateMachine.taskMethodBuilder; taskMethodBuilder.Start(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> stateMachine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stateMachine.taskMethodBuilder.Task; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Zustandsmaschine</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DelaysStateMachine</span></span> : <span class="hljs-title"><span class="hljs-title">IAsyncStateMachine</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     await   //       await'a public int currentState; public AsyncTaskMethodBuilder taskMethodBuilder; //   private TaskAwaiter taskAwaiter; //  ,             ""  public int paramInt; private int localInt; private void MoveNext() { int num = currentState; try { TaskAwaiter awaiter5; TaskAwaiter awaiter4; TaskAwaiter awaiter3; TaskAwaiter awaiter2; TaskAwaiter awaiter; switch (num) { default: localInt = paramInt; //  await Console.WriteLine(1); //  await awaiter5 = Task.Delay(1000).GetAwaiter(); //  await if (!awaiter5.IsCompleted) //  await. ,    { num = (currentState = 0); // ,      taskAwaiter = awaiter5; //    ,        DelaysStateMachine stateMachine = this; //    taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter5, ref stateMachine); //                 return; } goto Il_AfterFirstAwait; //  ,   ,    case 0: //            ,        .   ,          awaiter5 = taskAwaiter; //   taskAwaiter = default(TaskAwaiter); //   num = (currentState = -1); //  goto Il_AfterFirstAwait; //       case 1: //  ,      ,    ,     . awaiter4 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterSecondAwait; case 2: // ,     . awaiter3 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterThirdAwait; case 3: //    awaiter2 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterFourthAwait; case 4: //    { awaiter = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); break; } Il_AfterFourthAwait: awaiter2.GetResult(); Console.WriteLine(5); //     awaiter = Task.Delay(1000).GetAwaiter(); //   if (!awaiter.IsCompleted) { num = (currentState = 4); taskAwaiter = awaiter; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine); return; } break; Il_AfterFirstAwait: //  ,        awaiter5.GetResult(); //       Console.WriteLine(2); //  ,     await awaiter4 = Task.Delay(1000).GetAwaiter(); //    if (!awaiter4.IsCompleted) { num = (currentState = 1); taskAwaiter = awaiter4; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter4, ref stateMachine); return; } goto Il_AfterSecondAwait; Il_AfterThirdAwait: awaiter3.GetResult(); Console.WriteLine(4); //     awaiter2 = Task.Delay(1000).GetAwaiter(); //   if (!awaiter2.IsCompleted) { num = (currentState = 3); taskAwaiter = awaiter2; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter2, ref stateMachine); return; } goto Il_AfterFourthAwait; Il_AfterSecondAwait: awaiter4.GetResult(); Console.WriteLine(3); //     awaiter3 = Task.Delay(1000).GetAwaiter(); //   if (!awaiter3.IsCompleted) { num = (currentState = 2); taskAwaiter = awaiter3; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter3, ref stateMachine); return; } goto Il_AfterThirdAwait; } awaiter.GetResult(); } catch (Exception exception) { currentState = -2; taskMethodBuilder.SetException(exception); return; } currentState = -2; taskMethodBuilder.SetResult(); //    ,   ,       } void IAsyncStateMachine.MoveNext() {...} [DebuggerHidden] private void SetStateMachine(IAsyncStateMachine stateMachine) {...} void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine) {...} }</span></span></code> </pre><br></div></div><br>  Ich konzentriere mich auf den Satz "zu diesem Zeitpunkt wurde nicht synchron ausgeführt."  Eine asynchrone Operation kann auch einem synchronen Ausführungspfad folgen.  Die Hauptbedingung für die synchrone Ausführung der aktuellen asynchronen Methode, <i>dh</i> ohne Änderung des Threads, ist die Vollständigkeit der asynchronen Operation zum Zeitpunkt der <i>IsCompleted-</i> Überprüfung. <br><br><div class="spoiler">  <b class="spoiler_title">Dieses Beispiel zeigt dieses Verhalten deutlich.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-comment"><span class="hljs-comment">//1 Task task = Task.Delay(1000); Thread.Sleep(1700); await task; Console.WriteLine(Thread.CurrentThread.ManagedThreadId); //1 }</span></span></code> </pre><br></div></div><br>  Informationen zum Synchronisierungskontext.  Die auf dem <i>Computer verwendete</i> Methode <i>AwaitUnsafeOnCompleted führt</i> letztendlich zu einem Aufruf der <i>Task.SetContinuationForAwait-</i> Methode.  Bei dieser Methode wird der aktuelle Synchronisationskontext <i>SynchronizationContext.Current</i> abgerufen.  Der Synchronisationskontext kann als eine Art Stream interpretiert werden.  Falls es vorhanden und spezifisch ist (z. B. der Kontext des UI-Threads), wird die Fortsetzung mithilfe der <i>SynchronizationContextAwaitTaskContinuation-</i> Klasse erstellt.  Diese Klasse zum Starten der Fortsetzung ruft die Post-Methode für den gespeicherten Kontext auf, wodurch sichergestellt wird, dass die Fortsetzung genau in dem Kontext ausgeführt wird, in dem die Methode ausgeführt wurde.  Die spezifische Logik zum Ausführen der Fortsetzung hängt von der <i>Post-</i> Methode in einem Kontext ab, der, gelinde gesagt, nicht für die Geschwindigkeit bekannt ist.  Wenn kein Synchronisationskontext vorhanden war (oder angegeben wurde, dass es für uns nicht wichtig ist, in welchem ​​Kontext die Ausführung mit ConfigureAwait (false) fortgesetzt wird, was im letzten Kapitel erläutert wird), wird die Fortsetzung vom Thread aus dem Pool ausgeführt. <br><a name="libs"></a><br><h2>  Die Ursprünge der Asynchronität.  Die asynchronen Standardmethoden des Geräts </h2><br>  Wir haben uns angesehen, wie eine Methode mit Async und Warten aussieht und was hinter den Kulissen passiert.  Diese Informationen sind nicht ungewöhnlich.  Es ist jedoch wichtig, die Art der asynchronen Operationen zu verstehen.  Denn wie wir in der Zustandsmaschine gesehen haben, werden asynchrone Operationen im Code aufgerufen, es sei denn, ihr Ergebnis wird schlauer verarbeitet.  Was passiert jedoch innerhalb der asynchronen Operationen selbst?  Wahrscheinlich das gleiche, aber das kann nicht unendlich passieren. <br><br>  Eine wichtige Aufgabe ist es, die Natur der Asynchronität zu verstehen.  Beim Versuch, Asynchronität zu verstehen, gibt es einen Wechsel der Zustände "jetzt klar" und "jetzt wieder unverständlich".  Und diese Abwechslung wird sein, bis die Quelle der Asynchronität verstanden ist. <br><br>  Wenn wir mit Asynchronität arbeiten, bearbeiten wir Aufgaben.  Dies ist überhaupt nicht dasselbe wie ein Stream.  Eine Aufgabe kann von vielen Threads ausgeführt werden, und ein Thread kann viele Aufgaben ausführen. <br><br>  Asynchronität beginnt normalerweise mit einer Methode, die beispielsweise Task zurückgibt, jedoch nicht mit Async gekennzeichnet ist und dementsprechend kein Warten im Inneren verwendet.  Diese Methode toleriert keine Compileränderungen und wird unverändert ausgeführt. <br><br>  <b>Schauen wir uns also einige der Wurzeln der Asynchronität an.</b> <br><br><ol><li>  Task.Run, neue Task (..). Start (), Factory.StartNew und dergleichen.  Der einfachste Weg, um die asynchrone Ausführung zu starten.  Diese Methoden erstellen einfach ein neues Aufgabenobjekt und übergeben einen Delegaten als einen der Parameter.  Die Aufgabe wird an den Scheduler übertragen, der sie von einem der Threads im Pool ausführen lässt.  Die zu erwartende fertige Aufgabe wird zurückgegeben.  In der Regel wird dieser Ansatz verwendet, um die Berechnung (CPU-gebunden) in einem separaten Thread zu starten. </li><li>  TaskCompletionSource.  Eine Hilfsklasse, mit der das Aufgabenobjekt gesteuert werden kann.  Entwickelt für diejenigen, die keinen Delegaten für die Implementierung zuweisen können und komplexere Mechanismen zur Steuerung der Fertigstellung verwenden.  Es hat eine sehr einfache API - SetResult, SetError usw., die die Aufgabe entsprechend aktualisiert.  Diese Aufgabe ist über die Eigenschaft Aufgabe verfügbar.  Vielleicht erstellen Sie in Ihrem Inneren Threads, haben eine komplexe Logik für deren Interaktion oder Vervollständigung nach Ereignis.  Ein wenig mehr Details zu dieser Klasse finden Sie im letzten Abschnitt. </li></ol><br>  In einem zusätzlichen Absatz können Sie die Methoden von Standardbibliotheken festlegen.  Dazu gehören das Lesen / Schreiben von Dateien, das Arbeiten mit einem Netzwerk und dergleichen.  In der Regel verwenden solche gängigen und gebräuchlichen Methoden Systemaufrufe, die auf verschiedenen Plattformen variieren, und ihr Gerät ist äußerst unterhaltsam.  Arbeiten Sie mit Dateien und dem Netzwerk. <br><br><h3>  Dateien </h3><br>  Ein wichtiger Hinweis: Wenn Sie mit Dateien arbeiten möchten, müssen Sie beim Erstellen von FileStream useAsync = true angeben. <br><br>  Alles ist nicht trivial und verwirrend in Akten angeordnet.  Die FileStream-Klasse wird als partiell deklariert.  Außerdem gibt es 6 weitere plattformspezifische Add-Ons.  Unter Unix verwendet der asynchrone Zugriff auf eine beliebige Datei in der Regel eine synchrone Operation in einem separaten Thread.  In Windows gibt es Systemaufrufe für den asynchronen Betrieb, die natürlich verwendet werden.  Dies führt zu Unterschieden in der Arbeit auf verschiedenen Plattformen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen</a> . <br><br>  <b>Unix</b> <br><br>  Das Standardverhalten beim Schreiben oder Lesen besteht darin, die Operation synchron auszuführen, wenn der Puffer dies zulässt und der Stream nicht mit einer anderen Operation beschäftigt ist: <br><br>  1. Stream ist nicht mit einem anderen Vorgang beschäftigt <br><br>  Die Filestream-Klasse verfügt über ein von SemaphoreSlim geerbtes Objekt mit den Parametern (1, 1), dh einem kritischen Abschnitt. Ein durch dieses Semaphor geschütztes Codefragment kann jeweils nur von einem Thread ausgeführt werden.  Dieses Semaphor wird sowohl zum Lesen als auch zum Schreiben verwendet.  Das heißt, es ist unmöglich, gleichzeitig Lesen und Schreiben zu erzeugen.  In diesem Fall tritt keine Blockierung des Semaphors auf.  Die Methode this._asyncState.WaitAsync () wird darauf aufgerufen, die das Task-Objekt zurückgibt (es gibt keine Sperre oder Wartezeit, wenn das Schlüsselwort await auf das Ergebnis der Methode angewendet würde).  Wenn das angegebene Aufgabenobjekt nicht abgeschlossen ist, dh das Semaphor erfasst wird, wird die Fortsetzung (Task.ContinueWith), in der die Operation ausgeführt wird, an das zurückgegebene Warteobjekt angehängt.  Wenn das Objekt frei ist, müssen Sie Folgendes überprüfen <br><br>  2. Der Puffer erlaubt <br><br>  Hier hängt das Verhalten bereits von der Art der Operation ab. <br><br>  Für die Aufzeichnung wird überprüft, ob die Größe der Daten zum Schreiben + Position in der Datei geringer ist als die Größe des Puffers, der standardmäßig 4096 Byte beträgt.  Das heißt, wir müssen von Anfang an 4096 Bytes schreiben, 2048 Bytes mit einem Offset von 2048 und so weiter.  Ist dies der Fall, wird die Operation synchron ausgeführt, andernfalls wird die Fortsetzung angehängt (Task.ContinueWith).  Die Fortsetzung verwendet einen regulären synchronen Systemaufruf.  Wenn der Puffer voll ist, wird er synchron auf die Festplatte geschrieben. <br>  Zum Lesen wird geprüft, ob sich genügend Daten im Puffer befinden, um alle erforderlichen Daten zurückzugeben.  Wenn nicht, dann wieder eine Fortsetzung (Task.ContinueWith) mit einem synchronen Systemaufruf. <br><br>  Übrigens gibt es ein interessantes Detail.  Wenn ein Datenelement den gesamten Puffer belegt, werden sie ohne Beteiligung des Puffers direkt in die Datei geschrieben.  Gleichzeitig gibt es eine Situation, in der mehr Daten als die Größe des Puffers vorhanden sind, die jedoch alle durchlaufen werden.  Dies geschieht, wenn sich bereits etwas im Puffer befindet.  Dann werden unsere Daten in zwei Teile geteilt, einer füllt den Puffer bis zum Ende und die Daten werden in die Datei geschrieben, der zweite wird in den Puffer geschrieben, wenn er in ihn gelangt, oder direkt in die Datei, wenn dies nicht der Fall ist.  Wenn wir also einen Stream erstellen und 4097 Bytes in ihn schreiben, werden sie sofort in der Datei angezeigt, ohne Dispose aufzurufen.  Wenn wir 4095 schreiben, ist nichts in der Datei. <br><br>  <b>Windows</b> <br><br>  Unter Windows ist der Algorithmus zum Verwenden des Puffers und zum direkten Schreiben sehr ähnlich.  Ein signifikanter Unterschied wird jedoch direkt bei den Schreib- und Leseaufrufen des asynchronen Systems beobachtet.  Wenn Sie sprechen, ohne tief in Systemaufrufe einzusteigen, gibt es eine solche überlappende Struktur.  Es hat ein wichtiges Feld für uns - HANDLE HEvent.  Dies ist ein manuelles Rücksetzereignis, das nach Abschluss eines Vorgangs in den Alarmzustand wechselt.  Zurück zur Implementierung.  Beim direkten Schreiben sowie beim Schreiben in den Puffer werden asynchrone Systemaufrufe verwendet, die die obige Struktur als Parameter verwenden.  Bei der Aufzeichnung wird ein FileStreamCompletionSource-Objekt erstellt - ein Erbe von TaskCompletionSource, in dem IOCallback angegeben ist.  Es wird von einem freien Thread aus dem Pool aufgerufen, wenn der Vorgang abgeschlossen ist.  Im Rückruf wird die überlappende Struktur analysiert und das Task-Objekt entsprechend aktualisiert.  Das ist alles Magie. <br><br><h3>  Netzwerk </h3><br>  Es ist schwierig, alles zu beschreiben, was ich gesehen habe, um die Quelle zu verstehen.  Mein Pfad lag von HttpClient zu Socket und zu SocketAsyncContext für Unix.  Das allgemeine Schema ist das gleiche wie bei Dateien.  Für Windows wird die erwähnte überlappende Struktur verwendet und der Vorgang wird asynchron ausgeführt.  Unter Unix verwenden Netzwerkvorgänge auch Rückruffunktionen. <br><br>  Und eine kleine Erklärung.  Ein aufmerksamer Leser wird feststellen, dass bei der Verwendung von asynchronen Anrufen zwischen einem Anruf und einem Rückruf eine gewisse Leere vorliegt, die irgendwie mit Daten funktioniert.  Hier lohnt es sich, der Vollständigkeit halber zu klären.  Am Beispiel von Dateien führt der Plattencontroller direkte Operationen mit der Platte durch den Plattencontroller aus. Er gibt die Signale zum Bewegen der Köpfe in den gewünschten Sektor usw.  Der Prozessor ist zu diesem Zeitpunkt frei.  Die Kommunikation mit der Festplatte erfolgt über die Eingabe- / Ausgabeports.  Sie geben die Art des Vorgangs, den Speicherort der Daten auf der Festplatte usw. an.  Als nächstes werden die Steuerung und die Festplatte in diesen Vorgang einbezogen und erzeugen nach Abschluss der Arbeit einen Interrupt.  Dementsprechend trägt ein asynchroner Systemaufruf nur Informationen zu den Eingabe- / Ausgabeports bei, während der synchrone ebenfalls auf die Ergebnisse wartet und den Stream in einen blockierenden Zustand versetzt.  Dieses Schema gibt nicht vor, absolut genau zu sein (nicht zu diesem Artikel), sondern vermittelt ein konzeptionelles Verständnis der Arbeit. <br><br>  Jetzt ist die Art des Prozesses klar.  Aber jemand könnte fragen, was mit Asynchronität zu tun ist.  Es ist unmöglich, für immer asynchron über eine Methode zu schreiben. <br><br>  Erstens.  Ein Antrag kann als Dienst gestellt werden.  In diesem Fall wird der Einstiegspunkt - Main - von Ihnen von Grund auf neu geschrieben.  Bis vor kurzem konnte Main nicht asynchron sein. In Version 7 der Sprache wurde diese Funktion hinzugefügt.  Aber es ändert nichts grundlegend, der Compiler generiert einfach das übliche Main und aus dem asynchronen wird nur eine statische Methode erstellt, die in Main aufgerufen wird und deren Abschluss synchron erwartet wird.  Wahrscheinlich haben Sie also einige langlebige Aktionen.  Aus irgendeinem Grund beginnen in diesem Moment viele Leute darüber nachzudenken, wie Threads für dieses Unternehmen erstellt werden können: über Task, ThreadPool oder Thread im Allgemeinen manuell, da es in etwas einen Unterschied geben sollte.  Die Antwort ist einfach - natürlich Aufgabe.  Wenn Sie den TAP-Ansatz verwenden, stören Sie die manuelle Thread-Erstellung nicht.  Dies entspricht der Verwendung von HttpClient für fast alle Anforderungen, und POST erfolgt unabhängig über Socket. <br><br>  Zweitens.  Webanwendungen.  Bei jeder eingehenden Anforderung wird ein neuer Thread zur Verarbeitung aus ThreadPool abgerufen.  Der Pool ist natürlich groß, aber nicht unendlich.  In dem Fall, dass viele Anforderungen vorhanden sind, sind möglicherweise überhaupt nicht genügend Threads vorhanden, und alle neuen Anforderungen werden zur Verarbeitung in die Warteschlange gestellt.  Diese Situation nennt man Hunger.  Bei Verwendung von asynchronen Controllern, wie bereits erläutert, kehrt der Stream jedoch in den Pool zurück und kann zur Verarbeitung neuer Anforderungen verwendet werden.  Dadurch wird der Durchsatz des Servers deutlich erhöht. <br><br>  Wir haben den asynchronen Prozess von Anfang bis Ende betrachtet.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mit dem Verständnis all dieser Asynchronität, die der menschlichen Natur widerspricht, werden wir einige nützliche Tricks in Betracht ziehen, wenn wir mit asynchronem Code arbeiten. </font></font><br><a name="api"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nützliche Klassen und Tricks bei der Arbeit mit TAP </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die statische Vielfalt der Task-Klasse. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Task-Klasse verfügt über mehrere nützliche statische Methoden. </font><font style="vertical-align: inherit;">Unten sind die wichtigsten.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.WhenAny (..) ist ein Kombinator, der IEnumerable / params von Aufgabenobjekten verwendet und ein Aufgabenobjekt zurückgibt, das abgeschlossen wird, wenn die erste abgeschlossene Aufgabe abgeschlossen ist. </font><font style="vertical-align: inherit;">Das heißt, Sie können auf eine von mehreren laufenden Aufgaben warten</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task.WhenAll (..) - Kombinator, akzeptiert IEnumerable / params von Aufgabenobjekten und gibt ein Aufgabenobjekt zurück, das abgeschlossen wird, wenn alle übertragenen Aufgaben abgeschlossen sind </font></font></li><li> Task.FromResult&lt;T&gt;(T value) —    ,    .          </li><li> Task.Delay(..) —     </li><li> Task.Yield() —  .   ,      .  ,    ,      </li></ol><br><h3> ConfigureAwait </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich die beliebteste "erweiterte" Funktion. Diese Methode gehört zur Task-Klasse und ermöglicht es Ihnen anzugeben, ob wir in demselben Kontext fortfahren müssen, in dem die asynchrone Operation aufgerufen wurde. Ohne diese Methode wird der Kontext standardmäßig gespeichert und mit der genannten Post-Methode fortgesetzt. Wie gesagt, Post ist ein sehr teures Vergnügen. Wenn die Leistung an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erster</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stelle steht und wir sehen, dass die Fortsetzung beispielsweise die Benutzeroberfläche nicht aktualisiert, können Sie sie im wartenden Objekt </font><i><font style="vertical-align: inherit;">.ConfigureAwait (false)</font></i><font style="vertical-align: inherit;"> angeben </font><font style="vertical-align: inherit;">. Dies bedeutet, dass es uns egal ist, wo die Fortsetzung durchgeführt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun zum Problem. Wie sie sagen, ist beängstigend keine Unwissenheit, sondern falsches Wissen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Irgendwie habe ich zufällig den Code einer Webanwendung beobachtet, bei der jeder asynchrone Aufruf mit diesem Beschleuniger dekoriert wurde. </font><font style="vertical-align: inherit;">Dies hat keine andere Wirkung als visuellen Ekel. </font><font style="vertical-align: inherit;">Die Standard-ASP.NET Core-Webanwendung hat keine eindeutigen Kontexte (es sei denn, Sie schreiben sie natürlich selbst). </font><font style="vertical-align: inherit;">Daher wird die Post-Methode dort sowieso nicht aufgerufen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TaskCompletionSource &lt;T&gt; </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Klasse, die das Verwalten eines Task-Objekts vereinfacht. </font><font style="vertical-align: inherit;">Eine Klasse bietet zahlreiche Möglichkeiten, ist jedoch am nützlichsten, wenn wir eine Aufgabe mit einer Aktion abschließen möchten, deren Ende bei einem Ereignis auftritt. </font><font style="vertical-align: inherit;">Im Allgemeinen wurde die Klasse erstellt, um alte asynchrone Methoden an TAP anzupassen, aber wie wir gesehen haben, wird sie nicht nur dafür verwendet. </font><font style="vertical-align: inherit;">Ein kleines Beispiel für die Arbeit mit dieser Klasse:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); FileSystemWatcher watcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileSystemWatcher { Path = Directory.GetCurrentDirectory(), NotifyFilter = NotifyFilters.LastAccess, EnableRaisingEvents = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; watcher.Changed += (o, e) =&gt; tcs.SetResult(e.FullPath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tcs.Task; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Klasse erstellt einen asynchronen Wrapper, um den Namen der Datei abzurufen, auf die im aktuellen Ordner zugegriffen wurde. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CancellationTokenSource </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ermöglicht das Abbrechen eines asynchronen Vorgangs. </font><font style="vertical-align: inherit;">Die allgemeine Gliederung ähnelt der Verwendung einer TaskCompletionSource. </font><font style="vertical-align: inherit;">Zuerst wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var cts = new CancellationTokenSource () erstellt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das übrigens IDisposable ist, und dann wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cts.Token</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an asynchrone Operationen übergeben </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nach einer bestimmten Logik von Ihnen wird unter bestimmten Bedingungen die Methode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cts.Cancel () aufgerufen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es kann auch ein Ereignis oder etwas anderes abonnieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung eines </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine gute Vorgehensweise. </font><font style="vertical-align: inherit;">Wenn Sie Ihre asynchrone Methode schreiben, die beispielsweise im Hintergrund arbeitet, können Sie einfach eine Zeile in den Hauptteil der Schleife einfügen: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cancellationToken.ThrowIfCancellationRequested ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wodurch eine Ausnahme ausgelöst wird</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Diese Ausnahme wird als Abbruch des Vorgangs behandelt und nicht als Ausnahme im Aufgabenobjekt gespeichert. </font><font style="vertical-align: inherit;">Außerdem wird die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsCanceled-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eigenschaft </font><font style="vertical-align: inherit;">für das Task-Objekt wahr.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Longrunning </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oft gibt es Situationen, insbesondere beim Schreiben von Diensten, in denen Sie mehrere Aufgaben erstellen, die während der gesamten Lebensdauer des Dienstes oder nur für eine sehr lange Zeit funktionieren. </font><font style="vertical-align: inherit;">Wie wir uns erinnern, ist die Verwendung eines Thread-Pools zu Recht der Aufwand für die Erstellung eines Threads. </font><font style="vertical-align: inherit;">Wenn jedoch selten ein Stream erstellt wird (auch nicht einmal pro Stunde), werden diese Kosten ausgeglichen und Sie können sicher separate Streams erstellen. </font><font style="vertical-align: inherit;">Zu diesem </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweck</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können Sie beim Erstellen einer Aufgabe eine spezielle Option angeben: </font><i><font style="vertical-align: inherit;">Task.Factory.StartNew (Aktion, </font></i><i><b><font style="vertical-align: inherit;">TaskCreationOptions.LongRunning</font></b></i><i><font style="vertical-align: inherit;"> )</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich empfehle Ihnen jedoch, alle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgaben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu betrachten. </font><i><font style="vertical-align: inherit;">Factory.StartNew-</font></i><font style="vertical-align: inherit;"> Überladungen </font><font style="vertical-align: inherit;">gibt es viele Möglichkeiten, die Aufgabe flexibel zu konfigurieren, um bestimmte Anforderungen zu erfüllen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausnahmen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund des nicht deterministischen Charakters der asynchronen Codeausführung ist die Frage der Ausnahmen sehr relevant. Es wäre eine Schande, wenn Sie die Ausnahme nicht abfangen könnten und sie in den linken Thread geworfen wurde, wodurch der Prozess beendet wurde. Eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse wurde erstellt, um eine Ausnahme in einem Thread abzufangen und darin zu werfen </font><font style="vertical-align: inherit;">. Um die Ausnahme abzufangen, wird die statische Methode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo.Capture (ex) verwendet, die </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">ExceptionDispatchInfo</font></i><font style="vertical-align: inherit;"> zurückgibt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Link zu diesem Objekt kann an einen beliebigen Thread übergeben werden, der dann die Throw () -Methode aufruft, um ihn wegzuwerfen. </font><font style="vertical-align: inherit;">Der Wurf selbst erfolgt NICHT am Ort des asynchronen Operationsaufrufs, sondern am Ort der Verwendung des Operators await. </font><font style="vertical-align: inherit;">Und wie Sie wissen, kann Warten nicht auf Leere angewendet werden. </font><font style="vertical-align: inherit;">Wenn der Kontext vorhanden war, wird er von der Post-Methode an ihn übergeben. </font><font style="vertical-align: inherit;">Andernfalls wird es im Strom aus dem Pool angeregt. </font><font style="vertical-align: inherit;">Und dies ist fast 100% Hallo zum Zusammenbruch der Anwendung. </font><font style="vertical-align: inherit;">Und hier kommen wir zur Praxis der Tatsache, dass wir Task oder Task &lt;T&gt; verwenden sollten, aber nicht ungültig. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und noch etwas. </font><font style="vertical-align: inherit;">Der Scheduler verfügt über ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskScheduler.UnobservedTaskException-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ereignis </font><font style="vertical-align: inherit;">, das </font><i><font style="vertical-align: inherit;">ausgelöst wird</font></i><font style="vertical-align: inherit;"> , wenn eine </font><i><font style="vertical-align: inherit;">UnobservedTaskException</font></i><font style="vertical-align: inherit;"> ausgelöst wird</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Ausnahme wird während der Speicherbereinigung ausgelöst, wenn der GC versucht, ein Taskobjekt mit einer nicht behandelten Ausnahme zu erfassen.</font></font><br><br><h3> IAsyncEnumerable </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor C # 8 und .NET Core 3.0 war es nicht möglich, einen Ertragsiterator in einer asynchronen Methode zu verwenden, was die Lebensdauer komplizierte und dazu führte, dass Task &lt;IEnumerable &lt;T&gt;&gt; von dieser Methode zurückgegeben wurde, d. H. Es gab keine Möglichkeit, die Sammlung zu durchlaufen, bis sie vollständig empfangen wurde. Jetzt gibt es eine solche Gelegenheit. Erfahren Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mehr darüber </font><font style="vertical-align: inherit;">. Dazu muss der Rückgabetyp </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerable &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (oder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerator &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sein. Um eine solche Sammlung zu durchlaufen, sollten Sie die foreach-Schleife mit dem Schlüsselwort await verwenden. Außerdem können die Methoden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WithCancellation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für das Ergebnis der Operation </font><font style="vertical-align: inherit;">aufgerufen werden, wobei das verwendete CancelationToken und die Notwendigkeit angegeben werden, im selben Kontext fortzufahren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie erwartet wird alles so faul wie möglich gemacht. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unten ist ein Beispiel und die Schlussfolgerung, die er gibt.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); sw.Start(); IAsyncEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; enumerable = AsyncYielding(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time after calling: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerable.WithCancellation(..).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"element: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{element}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds}</span></span></span><span class="hljs-string">"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> IAsyncEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncYielding</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uselessElement <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) { Task task = Task.Delay(TimeSpan.FromSeconds(uselessElement)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Task run: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{uselessElement}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> task; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uselessElement; } } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit nach dem Aufruf: 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgabenlauf: 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Element: 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit: 1033 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgabenlauf: 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Element: 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit: 3034 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgabenlauf: 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Element: 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit: 6035</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Threadpool </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Klasse wird beim Programmieren mit TAP aktiv verwendet. Daher werde ich die minimalen Details seiner Implementierung angeben. Im Inneren verfügt ThreadPool über ein Array von Warteschlangen: eine für jeden Thread + eine globale. Beim Hinzufügen eines neuen Jobs zum Pool wird der Thread berücksichtigt, der das Hinzufügen initiiert hat. Wenn es sich um einen Thread aus dem Pool handelt, wird die Arbeit in eine eigene Warteschlange für diesen Thread gestellt, wenn es sich um einen anderen Thread handelt - in den globalen. Wenn ein Thread für die Arbeit ausgewählt wird, wird zuerst seine lokale Warteschlange angezeigt. Wenn es leer ist, nimmt der Thread Jobs von der globalen. Wenn es leer ist, beginnt es, von den anderen zu stehlen. Außerdem sollten Sie sich niemals auf die Reihenfolge der Arbeit verlassen, da es tatsächlich keine Reihenfolge gibt. Die Standardanzahl der Threads in einem Pool hängt von vielen Faktoren ab, einschließlich der Größe des Adressraums. Wenn weitere Ausführungsanforderungen vorliegen,Als die Anzahl der verfügbaren Threads werden Anforderungen in die Warteschlange gestellt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Threads in einem Thread-Pool sind Hintergrund-Threads (Eigenschaft isBackground = true). </font><font style="vertical-align: inherit;">Dieser Thread-Typ unterstützt nicht die Lebensdauer des Prozesses, wenn alle Vordergrund-Threads abgeschlossen sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Systemthread überwacht den Status des Wartehandles. </font><font style="vertical-align: inherit;">Wenn der Wartevorgang endet, wird der übertragene Rückruf vom Thread aus dem Pool ausgeführt (beachten Sie die Dateien in Windows).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgabenartiger Typ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser zuvor erwähnte Typ (Struktur oder Klasse) kann als Rückgabewert der asynchronen Methode verwendet werden. </font><font style="vertical-align: inherit;">Ein Builder-Typ muss diesem Typ mithilfe des Attributs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[AsyncMethodBuilder (..)] zugeordnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dieser Typ muss die oben genannten Merkmale aufweisen, um das Schlüsselwort await auf ihn anwenden zu können. </font><font style="vertical-align: inherit;">Es kann für Methoden parametrisiert werden, die keinen Wert zurückgeben, und für Methoden, die einen Wert zurückgeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Builder selbst ist eine Klasse oder Struktur, deren Framework im folgenden Beispiel dargestellt ist. </font><font style="vertical-align: inherit;">Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetResult-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">verfügt über einen Parameter vom Typ T für einen von T parametrisierten aufgabenähnlichen Typ. Für nicht parametrisierte Typen verfügt die Methode über keine Parameter.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erforderliche Builder-Schnittstelle</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyTaskMethodBuilder</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MyTaskMethodBuilder&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start&lt;TStateMachine&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetStateMachine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAsyncStateMachine stateMachine</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception exception</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T result</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : INotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : ICriticalNotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyTask&lt;T&gt; Task { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Prinzip der Arbeit unter dem Gesichtspunkt des Schreibens Ihres aufgabenähnlichen Typs wird nachstehend beschrieben. Das meiste davon wurde bereits beim Parsen des vom Compiler generierten Codes beschrieben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Compiler verwendet alle diese Typen, um eine Zustandsmaschine zu generieren. Der Compiler weiß, welche Builder für die ihm bekannten Typen verwendet werden sollen. Hier geben wir an, was während der Codegenerierung verwendet wird. Wenn die Zustandsmaschine eine Struktur ist, wird sie beim Aufrufen von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetStateMachine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gepackt </font><font style="vertical-align: inherit;">. Der Builder kann die gepackte Kopie bei Bedarf zwischenspeichern. Der Builder muss </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateMachine.MoveNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">oder nach dem </font><font style="vertical-align: inherit;">Aufruf </font><i><font style="vertical-align: inherit;">aufrufen</font></i><font style="vertical-align: inherit;"> , um die Ausführung zu starten und die Zustandsmaschine voranzutreiben. Nach dem Aufruf von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird die Task-Eigenschaft von der Methode zurückgegeben. Ich empfehle, dass Sie zur Stub-Methode zurückkehren und diese Schritte anzeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Zustandsmaschine erfolgreich abgeschlossen wurde, wird die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetResult-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><i><font style="vertical-align: inherit;">aufgerufen</font></i><font style="vertical-align: inherit;"> , andernfalls </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn die Zustandsmaschine " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wait"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erreicht, wird die </font><i><font style="vertical-align: inherit;">GetAwaiter ()</font></i><font style="vertical-align: inherit;"> -Methode vom </font><font style="vertical-align: inherit;">aufgabenähnlichen Typ </font><font style="vertical-align: inherit;">ausgeführt </font><font style="vertical-align: inherit;">. Wenn das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warteobjekt die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnittstelle </font><i><font style="vertical-align: inherit;">ICriticalNotifyCompletion</font></i><font style="vertical-align: inherit;"> und IsCompleted = false </font><font style="vertical-align: inherit;">implementiert </font><font style="vertical-align: inherit;">, verwendet die Zustandsmaschine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitUnsafeOnCompleted (ref awaiter, ref stateMachine)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AwaitUnsafeOnCompleted-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">sollte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awaiter.OnCompleted (Aktion)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufrufen. </font><font style="vertical-align: inherit;">In Aktion sollte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateMachine.MoveNext aufgerufen werden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn das Warteobjekt abgeschlossen ist. </font><font style="vertical-align: inherit;">Ähnliches gilt für die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INotifyCompletion-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnittstelle </font><font style="vertical-align: inherit;">und die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitOnCompleted-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie dies nutzen, liegt bei Ihnen. </font><font style="vertical-align: inherit;">Aber ich rate Ihnen, über 514 Mal nachzudenken, bevor Sie dies in der Produktion anwenden, und nicht zum Verwöhnen. </font><font style="vertical-align: inherit;">Unten finden Sie ein Anwendungsbeispiel. </font><font style="vertical-align: inherit;">Ich habe nur einen Proxy für einen Standard-Builder entworfen, der der Konsole anzeigt, welche Methode zu welcher Zeit aufgerufen wurde. </font><font style="vertical-align: inherit;">Übrigens möchte das asynchrone Main () keine benutzerdefinierten Erwartungen unterstützen (ich glaube, dass mehr als ein Produktionsprojekt aufgrund dieses Fehlschlags von Microsoft hoffnungslos beschädigt wurde). </font><font style="vertical-align: inherit;">Wenn Sie möchten, können Sie den Proxy-Logger mit einem normalen Logger ändern und weitere Informationen protokollieren.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proxy-Aufgabe protokollieren</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Start"</span></span>); JustMethod().Task.Wait(); <span class="hljs-comment"><span class="hljs-comment">//   Console.WriteLine("Stop"); } public static async LogTask JustMethod() { await DelayWrapper(1000); } public static LogTask DelayWrapper(int milliseconds) =&gt; new LogTask { Task = Task.Delay(milliseconds)}; } [AsyncMethodBuilder(typeof(LogMethodBuilder))] public class LogTask { public Task Task { get; set; } public TaskAwaiter GetAwaiter() =&gt; Task.GetAwaiter(); } public class LogMethodBuilder { private AsyncTaskMethodBuilder _methodBuilder = AsyncTaskMethodBuilder.Create(); private LogTask _task; public static LogMethodBuilder Create() { Console.WriteLine($"Method: Create; {DateTime.Now :O}"); return new LogMethodBuilder(); } public void Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: Start; {DateTime.Now :O}"); _methodBuilder.Start(ref stateMachine); } public void SetStateMachine(IAsyncStateMachine stateMachine) { Console.WriteLine($"Method: SetStateMachine; {DateTime.Now :O}"); _methodBuilder.SetStateMachine(stateMachine); } public void SetException(Exception exception) { Console.WriteLine($"Method: SetException; {DateTime.Now :O}"); _methodBuilder.SetException(exception); } public void SetResult() { Console.WriteLine($"Method: SetResult; {DateTime.Now :O}"); _methodBuilder.SetResult(); } public void AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: AwaitOnCompleted; {DateTime.Now :O}"); _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine); } public void AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: AwaitUnsafeOnCompleted; {DateTime.Now :O}"); _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine); } public LogTask Task { get { Console.WriteLine($"Property: Task; {DateTime.Now :O}"); return _task ??= new LogTask {Task = _methodBuilder.Task}; } set =&gt; _task = value; } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startmethode </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Erstellen; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7152733 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode: Start; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7262226 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode: AwaitUnsafeOnCompleted; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7275206 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft: Aufgabe; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7292005 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode: SetResult; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 14.7297967 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stop</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das ist alles, danke euch allen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470830/">https://habr.com/ru/post/de470830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470820/index.html">Ein kurzer Test von Dutzenden von Hypothesen: Wie wir aus der Routine ausbrechen und in einer anderen Stadt diskutieren</a></li>
<li><a href="../de470822/index.html">Temperaturüberwachung im Unternehmen</a></li>
<li><a href="../de470824/index.html">Dialoge über Versprechen</a></li>
<li><a href="../de470826/index.html">Bergleute, Taucher und Kobalt: Wie wir Kunden einen sicheren Internetzugang bieten</a></li>
<li><a href="../de470828/index.html">Python verknüpfte Liste: Katzen in Kisten</a></li>
<li><a href="../de470834/index.html">Superinfektions-, Antibiotika- und Zombie-Apokalypse-Modelle</a></li>
<li><a href="../de470838/index.html">Containersicherheit in CI / CD</a></li>
<li><a href="../de470844/index.html">Das neue Projekt der Brüder Durov: Telegram Open Network</a></li>
<li><a href="../de470852/index.html">Verarbeitung von 40 TB Code aus 10 Millionen Projekten auf einem dedizierten Server mit Go für 100 US-Dollar</a></li>
<li><a href="../de470856/index.html">Telegramm GRAM Wallet: Nutzungsbedingungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>