<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôæ ü§Ωüèº üë©‚Äçüë¶‚Äçüë¶ Async / warte in C #: Konzept, internes Design, n√ºtzliche Tricks üïØÔ∏è ü§¥üèº üë©üèø‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. Lassen Sie uns diesmal √ºber ein Thema sprechen, das jeder selbstbewusste Anh√§nger der C # -Sprache zu verstehen begann - asynchrone Program...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Async / warte in C #: Konzept, internes Design, n√ºtzliche Tricks</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470830/">  Guten Tag.  Lassen Sie uns diesmal √ºber ein Thema sprechen, das jeder selbstbewusste Anh√§nger der C # -Sprache zu verstehen begann - asynchrone Programmierung mit Task oder, bei gew√∂hnlichen Menschen, asynchron / warten.  Microsoft hat gute Arbeit geleistet - um Asynchronit√§t zu verwenden, m√ºssen Sie in den meisten F√§llen nur die Syntax und keine weiteren Details kennen.  Aber wenn Sie tief gehen, ist das Thema ziemlich umfangreich und komplex.  Es wurde von vielen gesagt, jeder in seinem eigenen Stil.  Es gibt viele coole Artikel zu diesem Thema, aber es gibt immer noch viele Missverst√§ndnisse.  Wir werden versuchen, die Situation zu korrigieren und das Material so weit wie m√∂glich zu kauen, ohne dabei die Tiefe oder das Verst√§ndnis zu beeintr√§chtigen. <br><br><img src="https://habrastorage.org/webt/zn/or/r1/znorr1o7rsk1tzudgdrmgchrss4.jpeg"><br><a name="habracut"></a><br>  Behandelte Themen / Kapitel: <br><br><ol><li> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Konzept der Asynchronit√§t</a></b> - die Vorteile von Asynchronit√§t und Mythen √ºber einen "blockierten" Thread </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TAP.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Syntax- und Kompilierungsbedingungen</a></b> - Voraussetzungen f√ºr das Schreiben einer Kompilierungsmethode </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeiten Sie mit TAP</a></b> - der Mechanik und dem Verhalten des Programms in asynchronem Code (Freigeben von Threads, Starten von Aufgaben und Warten auf deren Abschluss) </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinter den Kulissen: die Zustandsmaschine</a></b> - eine √úbersicht √ºber die Compiler-Transformationen und die von ihr generierten Klassen </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Urspr√ºnge der Asynchronit√§t.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Ger√§t der asynchronen Standardmethoden</a></b> - asynchrone Methoden f√ºr die Arbeit mit Dateien und dem Netzwerk von innen </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TAP-Klassen und -Tricks</a></b> sind n√ºtzliche Tricks, mit denen Sie ein Programm mithilfe von TAP verwalten und beschleunigen k√∂nnen </li></ol><a name="conception"></a><br><h2>  Asynchrones Konzept </h2><br>  Asynchronit√§t an sich ist alles andere als neu.  Asynchronit√§t impliziert normalerweise das Ausf√ºhren einer Operation in einem Stil, der nicht das Blockieren des aufrufenden Threads bedeutet, dh das Starten der Operation, ohne auf deren Abschluss zu warten.  Blockieren ist nicht so b√∂se wie beschrieben.  Man kann auf Behauptungen sto√üen, dass blockierte Threads CPU-Zeit verschwenden, langsamer arbeiten und Regen verursachen.  Scheint letzteres unwahrscheinlich?  Tats√§chlich sind die vorherigen 2 Punkte gleich. <br><br>  Wenn sich ein Thread auf der Ebene des Betriebssystem-Schedulers in einem "blockierten" Zustand befindet, wird ihm keine wertvolle Prozessorzeit zugewiesen.  Scheduler-Aufrufe fallen in der Regel auf Vorg√§nge, die Blockierungen, Timer-Interrupts und andere Interrupts verursachen.  Das hei√üt, wenn beispielsweise der Plattencontroller den Lesevorgang abschlie√üt und einen geeigneten Interrupt initiiert, startet der Scheduler.  Er entscheidet, ob ein Thread gestartet werden soll, der durch diesen Vorgang blockiert wurde, oder ein anderer mit einer h√∂heren Priorit√§t. <br><br>  Langsame Arbeit scheint noch absurder.  In der Tat ist die Arbeit ein und dieselbe.  Nur die asynchrone Operation erh√∂ht den Overhead etwas. <br><br>  Die Herausforderung des Regens ist in der Regel nicht etwas aus diesem Bereich. <br><br>  Das Hauptblockierungsproblem ist der unangemessene Verbrauch von Computerressourcen.  Selbst wenn wir die Zeit vergessen, einen Thread zu erstellen und mit einem Pool von Threads zu arbeiten, ben√∂tigt jeder blockierte Thread zus√§tzlichen Speicherplatz.  Nun, es gibt Szenarien, in denen nur ein Thread bestimmte Arbeiten ausf√ºhren kann (z. B. ein UI-Thread).  Dementsprechend m√∂chte ich nicht, dass er mit einer Aufgabe besch√§ftigt ist, die ein anderer Thread ausf√ºhren kann, und die Leistung von Operationen opfert, die ausschlie√ülich f√ºr ihn gelten. <br><br>  Asynchronit√§t ist ein sehr weit gefasstes Konzept und kann auf viele Arten erreicht werden. <br>  <b>In der Geschichte von .NET kann Folgendes unterschieden werden</b> : <br><br><ol><li>  EAP (Event-based Asynchronous Pattern) - Wie der Name schon sagt, basiert die Wanderung auf Ereignissen, die nach Abschluss der Operation ausgel√∂st werden, und der √ºblichen Methode, die diese Operation aufruft </li><li>  APM (Asynchronous Programming Model) - basierend auf 2 Methoden.  Die BeginSmth-Methode gibt die IAsyncResult-Schnittstelle zur√ºck.  Die EndSmth-Methode akzeptiert IAsyncResult (wenn der Vorgang zum Zeitpunkt des Aufrufs von EndSmth nicht abgeschlossen ist, wird der Thread blockiert). </li><li>  TAP (Task-based Asynchronous Pattern) ist das gleiche asynchrone / warten (genau genommen erschienen diese W√∂rter nach dem Ansatz und die Arten von Task und Task &lt;TResult&gt; erschienen, aber async / await hat dieses Konzept erheblich verbessert). </li></ol><br>  Der letztere Ansatz war so erfolgreich, dass jeder die vorherigen erfolgreich verga√ü.  Es wird also um ihn gehen. <br><a name="tap_syntax"></a><br><h2>  Aufgabenbasiertes asynchrones Muster.  Syntax- und Kompilierungsbedingungen </h2><br>  Die asynchrone Standardmethode im TAP-Stil ist sehr einfach zu schreiben. <br><br>  <b>Dazu ben√∂tigen Sie</b> : <br><br><ol><li>  Damit der R√ºckgabewert Task, Task &lt;T&gt; oder void ist (nicht empfohlen, wird sp√§ter erl√§utert).  In C # 7 kamen aufgaben√§hnliche Typen (im letzten Kapitel besprochen).  In C # 8 werden IAsyncEnumerable &lt;T&gt; und IAsyncEnumerator &lt;T&gt; zu dieser Liste hinzugef√ºgt. </li><li>  Damit ist die Methode mit dem Schl√ºsselwort async markiert und enth√§lt wait in.  Diese Schl√ºsselw√∂rter sind gepaart.  Wenn die Methode "Warten" enth√§lt, m√ºssen Sie sie au√üerdem als asynchron markieren. Das Gegenteil ist nicht der Fall, aber sinnlos </li><li>  Halten Sie sich aus Anstand an die Async-Suffix-Konvention.  Nat√ºrlich wird der Compiler dies nicht als Fehler betrachten.  Wenn Sie ein sehr anst√§ndiger Entwickler sind, k√∂nnen Sie mit einem CancellationToken (im letzten Kapitel beschrieben) √úberladungen hinzuf√ºgen. </li></ol><br>  F√ºr solche Methoden leistet der Compiler ernsthafte Arbeit.  Und sie werden hinter den Kulissen v√∂llig unkenntlich, aber dazu sp√§ter mehr. <br><br>  Es wurde erw√§hnt, dass die Methode das Schl√ºsselwort await enthalten sollte.  Es (das Wort) zeigt an, dass asynchron auf die Ausf√ºhrung der Aufgabe gewartet werden muss. Dies ist das Aufgabenobjekt, auf das es angewendet wird. <br><br>  <b>Das Task-Objekt hat auch bestimmte Bedingungen, so dass das Warten auf es angewendet werden kann:</b> <br><br><ol><li>  Der erwartete Typ muss eine √∂ffentliche (oder interne) GetAwaiter () -Methode haben. Er kann auch eine Erweiterungsmethode sein.  Diese Methode gibt ein Warteobjekt zur√ºck. </li><li>  Das Warteobjekt muss die INotifyCompletion-Schnittstelle implementieren, f√ºr die die void OnCompleted-Methode (Action Continuation) implementiert werden muss.  Es sollte auch die Instanzeigenschaft bool IsCompleted haben, die void GetResult () -Methode.  Es kann entweder eine Struktur oder eine Klasse sein. </li></ol><br>  Das folgende Beispiel zeigt, wie ein int erwartet und sogar nie ausgef√ºhrt wird. <br><br><div class="spoiler">  <b class="spoiler_title">Erweiterung int</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WeirdExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AnyTypeAwaiter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAwaiter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnyTypeAwaiter(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AnyTypeAwaiter</span></span> : <span class="hljs-title"><span class="hljs-title">INotifyCompletion</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCompleted =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCompleted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action continuation</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } }</code> </pre> <br></div></div><br><a name="tap_progr"></a><br><h2>  Arbeiten Sie mit TAP </h2><br>  Es ist schwierig, in den Dschungel zu gehen, ohne zu verstehen, wie etwas funktionieren soll.  Ber√ºcksichtigen Sie TAP im Hinblick auf das Programmverhalten. <br><br>  In der Terminologie: Die fragliche asynchrone Methode, deren Code ber√ºcksichtigt wird, ich werde die <b>asynchrone Methode</b> aufrufen, und die aufgerufenen asynchronen Methoden darin werde ich die <b>asynchrone Operation</b> aufrufen. <br><br>  Nehmen wir das einfachste Beispiel: Als asynchrone Operation verwenden wir Task.Delay, das um die angegebene Zeit verz√∂gert, ohne den Stream zu blockieren. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DelayOperationAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//   { BeforeCall(); Task task = Task.Delay(1000); //  AfterCall(); await task; AfterAwait(); }</span></span></span></span></code> </pre><br>  Die Ausf√ºhrung der Methode in Bezug auf das Verhalten ist wie folgt. <br><br><ol><li>  Der gesamte Code, der dem Aufruf der asynchronen Operation vorausgeht, wird ausgef√ºhrt.  In diesem Fall ist dies die <i>BeforeCall-</i> Methode </li><li>  Ein asynchroner Operationsaufruf wird ausgef√ºhrt.  Zu diesem Zeitpunkt wird der Thread nicht freigegeben oder blockiert.  Diese Operation gibt das Ergebnis zur√ºck - das erw√§hnte Task-Objekt (normalerweise Task), das in einer lokalen Variablen gespeichert ist </li><li>  Der Code wird nach dem Aufrufen der asynchronen Operation, jedoch vor dem Warten (Warten) ausgef√ºhrt.  Im Beispiel - <i>AfterCall</i> </li><li>  Warten auf den Abschluss des Aufgabenobjekts (das in einer lokalen Variablen gespeichert ist) - Warten Sie auf die Aufgabe. <br><br>  Wenn der asynchrone Vorgang zu diesem Zeitpunkt abgeschlossen ist, wird die Ausf√ºhrung synchron im selben Thread fortgesetzt. <br><br>  Wenn die asynchrone Operation nicht abgeschlossen ist, wird der Code gespeichert, der nach Abschluss der asynchronen Operation (der sogenannten Fortsetzung) aufgerufen werden muss, und der Stream kehrt zum Thread-Pool zur√ºck und steht zur Verwendung zur Verf√ºgung. </li><li>  Die Ausf√ºhrung von Operationen nach dem Warten - <i>AfterAwait</i> - wird entweder sofort im selben Thread ausgef√ºhrt, wenn die Operation zum Zeitpunkt des Wartens abgeschlossen wurde, oder nach Abschluss der Operation wird ein neuer Thread erstellt, der fortgesetzt wird (im vorherigen Schritt gespeichert). </li></ol><br><a name="internals"></a><br><h2>  Hinter den Kulissen.  Zustandsmaschine </h2><br>  Tats√§chlich wird unsere Methode vom Compiler in eine Stub-Methode umgewandelt, in der die generierte Klasse - die Zustandsmaschine - initialisiert wird.  Dann startet es (die Maschine) und das in Schritt 2 verwendete Task-Objekt wird von der Methode zur√ºckgegeben. <br><br>  Von besonderem Interesse ist die <i>MoveNext-</i> Methode der <i>Zustandsmaschine</i> .  Diese Methode macht das, was es vor der Konvertierung in der asynchronen Methode war.  Es bricht den Code zwischen jedem wartenden Anruf.  Jedes Teil wird in einem bestimmten Zustand der Maschine ausgef√ºhrt.  Die <i>MoveNext-</i> Methode selbst wird als Fortsetzung an das <i>Warteobjekt</i> angeh√§ngt.  Die Erhaltung des Staates garantiert die Ausf√ºhrung genau des Teils, der logischerweise der Erwartung entsprach. <br><br>  Wie sie sagen, ist es besser, 1 Mal zu sehen, als 100 Mal zu h√∂ren. Ich empfehle Ihnen daher dringend, sich mit dem folgenden Beispiel vertraut zu machen.  Ich habe den Code ein wenig umgeschrieben, die Benennung von Variablen verbessert und gro√üz√ºgig kommentiert. <br><br><div class="spoiler">  <b class="spoiler_title">Quellcode</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delays</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Stub-Methode</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AsyncStateMachine(typeof(DelaysStateMachine))</span></span>] [DebuggerStepThrough] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delays</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DelaysStateMachine stateMachine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DelaysStateMachine(); stateMachine.taskMethodBuilder = AsyncTaskMethodBuilder.Create(); stateMachine.currentState = <span class="hljs-number"><span class="hljs-number">-1</span></span>; AsyncTaskMethodBuilder builder = stateMachine.taskMethodBuilder; taskMethodBuilder.Start(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> stateMachine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stateMachine.taskMethodBuilder.Task; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Zustandsmaschine</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DelaysStateMachine</span></span> : <span class="hljs-title"><span class="hljs-title">IAsyncStateMachine</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     await   //       await'a public int currentState; public AsyncTaskMethodBuilder taskMethodBuilder; //   private TaskAwaiter taskAwaiter; //  ,             ""  public int paramInt; private int localInt; private void MoveNext() { int num = currentState; try { TaskAwaiter awaiter5; TaskAwaiter awaiter4; TaskAwaiter awaiter3; TaskAwaiter awaiter2; TaskAwaiter awaiter; switch (num) { default: localInt = paramInt; //  await Console.WriteLine(1); //  await awaiter5 = Task.Delay(1000).GetAwaiter(); //  await if (!awaiter5.IsCompleted) //  await. ,    { num = (currentState = 0); // ,      taskAwaiter = awaiter5; //    ,        DelaysStateMachine stateMachine = this; //    taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter5, ref stateMachine); //                 return; } goto Il_AfterFirstAwait; //  ,   ,    case 0: //            ,        .   ,          awaiter5 = taskAwaiter; //   taskAwaiter = default(TaskAwaiter); //   num = (currentState = -1); //  goto Il_AfterFirstAwait; //       case 1: //  ,      ,    ,     . awaiter4 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterSecondAwait; case 2: // ,     . awaiter3 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterThirdAwait; case 3: //    awaiter2 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterFourthAwait; case 4: //    { awaiter = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); break; } Il_AfterFourthAwait: awaiter2.GetResult(); Console.WriteLine(5); //     awaiter = Task.Delay(1000).GetAwaiter(); //   if (!awaiter.IsCompleted) { num = (currentState = 4); taskAwaiter = awaiter; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine); return; } break; Il_AfterFirstAwait: //  ,        awaiter5.GetResult(); //       Console.WriteLine(2); //  ,     await awaiter4 = Task.Delay(1000).GetAwaiter(); //    if (!awaiter4.IsCompleted) { num = (currentState = 1); taskAwaiter = awaiter4; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter4, ref stateMachine); return; } goto Il_AfterSecondAwait; Il_AfterThirdAwait: awaiter3.GetResult(); Console.WriteLine(4); //     awaiter2 = Task.Delay(1000).GetAwaiter(); //   if (!awaiter2.IsCompleted) { num = (currentState = 3); taskAwaiter = awaiter2; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter2, ref stateMachine); return; } goto Il_AfterFourthAwait; Il_AfterSecondAwait: awaiter4.GetResult(); Console.WriteLine(3); //     awaiter3 = Task.Delay(1000).GetAwaiter(); //   if (!awaiter3.IsCompleted) { num = (currentState = 2); taskAwaiter = awaiter3; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter3, ref stateMachine); return; } goto Il_AfterThirdAwait; } awaiter.GetResult(); } catch (Exception exception) { currentState = -2; taskMethodBuilder.SetException(exception); return; } currentState = -2; taskMethodBuilder.SetResult(); //    ,   ,       } void IAsyncStateMachine.MoveNext() {...} [DebuggerHidden] private void SetStateMachine(IAsyncStateMachine stateMachine) {...} void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine) {...} }</span></span></code> </pre><br></div></div><br>  Ich konzentriere mich auf den Satz "zu diesem Zeitpunkt wurde nicht synchron ausgef√ºhrt."  Eine asynchrone Operation kann auch einem synchronen Ausf√ºhrungspfad folgen.  Die Hauptbedingung f√ºr die synchrone Ausf√ºhrung der aktuellen asynchronen Methode, <i>dh</i> ohne √Ñnderung des Threads, ist die Vollst√§ndigkeit der asynchronen Operation zum Zeitpunkt der <i>IsCompleted-</i> √úberpr√ºfung. <br><br><div class="spoiler">  <b class="spoiler_title">Dieses Beispiel zeigt dieses Verhalten deutlich.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-comment"><span class="hljs-comment">//1 Task task = Task.Delay(1000); Thread.Sleep(1700); await task; Console.WriteLine(Thread.CurrentThread.ManagedThreadId); //1 }</span></span></code> </pre><br></div></div><br>  Informationen zum Synchronisierungskontext.  Die auf dem <i>Computer verwendete</i> Methode <i>AwaitUnsafeOnCompleted f√ºhrt</i> letztendlich zu einem Aufruf der <i>Task.SetContinuationForAwait-</i> Methode.  Bei dieser Methode wird der aktuelle Synchronisationskontext <i>SynchronizationContext.Current</i> abgerufen.  Der Synchronisationskontext kann als eine Art Stream interpretiert werden.  Falls es vorhanden und spezifisch ist (z. B. der Kontext des UI-Threads), wird die Fortsetzung mithilfe der <i>SynchronizationContextAwaitTaskContinuation-</i> Klasse erstellt.  Diese Klasse zum Starten der Fortsetzung ruft die Post-Methode f√ºr den gespeicherten Kontext auf, wodurch sichergestellt wird, dass die Fortsetzung genau in dem Kontext ausgef√ºhrt wird, in dem die Methode ausgef√ºhrt wurde.  Die spezifische Logik zum Ausf√ºhren der Fortsetzung h√§ngt von der <i>Post-</i> Methode in einem Kontext ab, der, gelinde gesagt, nicht f√ºr die Geschwindigkeit bekannt ist.  Wenn kein Synchronisationskontext vorhanden war (oder angegeben wurde, dass es f√ºr uns nicht wichtig ist, in welchem ‚Äã‚ÄãKontext die Ausf√ºhrung mit ConfigureAwait (false) fortgesetzt wird, was im letzten Kapitel erl√§utert wird), wird die Fortsetzung vom Thread aus dem Pool ausgef√ºhrt. <br><a name="libs"></a><br><h2>  Die Urspr√ºnge der Asynchronit√§t.  Die asynchronen Standardmethoden des Ger√§ts </h2><br>  Wir haben uns angesehen, wie eine Methode mit Async und Warten aussieht und was hinter den Kulissen passiert.  Diese Informationen sind nicht ungew√∂hnlich.  Es ist jedoch wichtig, die Art der asynchronen Operationen zu verstehen.  Denn wie wir in der Zustandsmaschine gesehen haben, werden asynchrone Operationen im Code aufgerufen, es sei denn, ihr Ergebnis wird schlauer verarbeitet.  Was passiert jedoch innerhalb der asynchronen Operationen selbst?  Wahrscheinlich das gleiche, aber das kann nicht unendlich passieren. <br><br>  Eine wichtige Aufgabe ist es, die Natur der Asynchronit√§t zu verstehen.  Beim Versuch, Asynchronit√§t zu verstehen, gibt es einen Wechsel der Zust√§nde "jetzt klar" und "jetzt wieder unverst√§ndlich".  Und diese Abwechslung wird sein, bis die Quelle der Asynchronit√§t verstanden ist. <br><br>  Wenn wir mit Asynchronit√§t arbeiten, bearbeiten wir Aufgaben.  Dies ist √ºberhaupt nicht dasselbe wie ein Stream.  Eine Aufgabe kann von vielen Threads ausgef√ºhrt werden, und ein Thread kann viele Aufgaben ausf√ºhren. <br><br>  Asynchronit√§t beginnt normalerweise mit einer Methode, die beispielsweise Task zur√ºckgibt, jedoch nicht mit Async gekennzeichnet ist und dementsprechend kein Warten im Inneren verwendet.  Diese Methode toleriert keine Compiler√§nderungen und wird unver√§ndert ausgef√ºhrt. <br><br>  <b>Schauen wir uns also einige der Wurzeln der Asynchronit√§t an.</b> <br><br><ol><li>  Task.Run, neue Task (..). Start (), Factory.StartNew und dergleichen.  Der einfachste Weg, um die asynchrone Ausf√ºhrung zu starten.  Diese Methoden erstellen einfach ein neues Aufgabenobjekt und √ºbergeben einen Delegaten als einen der Parameter.  Die Aufgabe wird an den Scheduler √ºbertragen, der sie von einem der Threads im Pool ausf√ºhren l√§sst.  Die zu erwartende fertige Aufgabe wird zur√ºckgegeben.  In der Regel wird dieser Ansatz verwendet, um die Berechnung (CPU-gebunden) in einem separaten Thread zu starten. </li><li>  TaskCompletionSource.  Eine Hilfsklasse, mit der das Aufgabenobjekt gesteuert werden kann.  Entwickelt f√ºr diejenigen, die keinen Delegaten f√ºr die Implementierung zuweisen k√∂nnen und komplexere Mechanismen zur Steuerung der Fertigstellung verwenden.  Es hat eine sehr einfache API - SetResult, SetError usw., die die Aufgabe entsprechend aktualisiert.  Diese Aufgabe ist √ºber die Eigenschaft Aufgabe verf√ºgbar.  Vielleicht erstellen Sie in Ihrem Inneren Threads, haben eine komplexe Logik f√ºr deren Interaktion oder Vervollst√§ndigung nach Ereignis.  Ein wenig mehr Details zu dieser Klasse finden Sie im letzten Abschnitt. </li></ol><br>  In einem zus√§tzlichen Absatz k√∂nnen Sie die Methoden von Standardbibliotheken festlegen.  Dazu geh√∂ren das Lesen / Schreiben von Dateien, das Arbeiten mit einem Netzwerk und dergleichen.  In der Regel verwenden solche g√§ngigen und gebr√§uchlichen Methoden Systemaufrufe, die auf verschiedenen Plattformen variieren, und ihr Ger√§t ist √§u√üerst unterhaltsam.  Arbeiten Sie mit Dateien und dem Netzwerk. <br><br><h3>  Dateien </h3><br>  Ein wichtiger Hinweis: Wenn Sie mit Dateien arbeiten m√∂chten, m√ºssen Sie beim Erstellen von FileStream useAsync = true angeben. <br><br>  Alles ist nicht trivial und verwirrend in Akten angeordnet.  Die FileStream-Klasse wird als partiell deklariert.  Au√üerdem gibt es 6 weitere plattformspezifische Add-Ons.  Unter Unix verwendet der asynchrone Zugriff auf eine beliebige Datei in der Regel eine synchrone Operation in einem separaten Thread.  In Windows gibt es Systemaufrufe f√ºr den asynchronen Betrieb, die nat√ºrlich verwendet werden.  Dies f√ºhrt zu Unterschieden in der Arbeit auf verschiedenen Plattformen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen</a> . <br><br>  <b>Unix</b> <br><br>  Das Standardverhalten beim Schreiben oder Lesen besteht darin, die Operation synchron auszuf√ºhren, wenn der Puffer dies zul√§sst und der Stream nicht mit einer anderen Operation besch√§ftigt ist: <br><br>  1. Stream ist nicht mit einem anderen Vorgang besch√§ftigt <br><br>  Die Filestream-Klasse verf√ºgt √ºber ein von SemaphoreSlim geerbtes Objekt mit den Parametern (1, 1), dh einem kritischen Abschnitt. Ein durch dieses Semaphor gesch√ºtztes Codefragment kann jeweils nur von einem Thread ausgef√ºhrt werden.  Dieses Semaphor wird sowohl zum Lesen als auch zum Schreiben verwendet.  Das hei√üt, es ist unm√∂glich, gleichzeitig Lesen und Schreiben zu erzeugen.  In diesem Fall tritt keine Blockierung des Semaphors auf.  Die Methode this._asyncState.WaitAsync () wird darauf aufgerufen, die das Task-Objekt zur√ºckgibt (es gibt keine Sperre oder Wartezeit, wenn das Schl√ºsselwort await auf das Ergebnis der Methode angewendet w√ºrde).  Wenn das angegebene Aufgabenobjekt nicht abgeschlossen ist, dh das Semaphor erfasst wird, wird die Fortsetzung (Task.ContinueWith), in der die Operation ausgef√ºhrt wird, an das zur√ºckgegebene Warteobjekt angeh√§ngt.  Wenn das Objekt frei ist, m√ºssen Sie Folgendes √ºberpr√ºfen <br><br>  2. Der Puffer erlaubt <br><br>  Hier h√§ngt das Verhalten bereits von der Art der Operation ab. <br><br>  F√ºr die Aufzeichnung wird √ºberpr√ºft, ob die Gr√∂√üe der Daten zum Schreiben + Position in der Datei geringer ist als die Gr√∂√üe des Puffers, der standardm√§√üig 4096 Byte betr√§gt.  Das hei√üt, wir m√ºssen von Anfang an 4096 Bytes schreiben, 2048 Bytes mit einem Offset von 2048 und so weiter.  Ist dies der Fall, wird die Operation synchron ausgef√ºhrt, andernfalls wird die Fortsetzung angeh√§ngt (Task.ContinueWith).  Die Fortsetzung verwendet einen regul√§ren synchronen Systemaufruf.  Wenn der Puffer voll ist, wird er synchron auf die Festplatte geschrieben. <br>  Zum Lesen wird gepr√ºft, ob sich gen√ºgend Daten im Puffer befinden, um alle erforderlichen Daten zur√ºckzugeben.  Wenn nicht, dann wieder eine Fortsetzung (Task.ContinueWith) mit einem synchronen Systemaufruf. <br><br>  √úbrigens gibt es ein interessantes Detail.  Wenn ein Datenelement den gesamten Puffer belegt, werden sie ohne Beteiligung des Puffers direkt in die Datei geschrieben.  Gleichzeitig gibt es eine Situation, in der mehr Daten als die Gr√∂√üe des Puffers vorhanden sind, die jedoch alle durchlaufen werden.  Dies geschieht, wenn sich bereits etwas im Puffer befindet.  Dann werden unsere Daten in zwei Teile geteilt, einer f√ºllt den Puffer bis zum Ende und die Daten werden in die Datei geschrieben, der zweite wird in den Puffer geschrieben, wenn er in ihn gelangt, oder direkt in die Datei, wenn dies nicht der Fall ist.  Wenn wir also einen Stream erstellen und 4097 Bytes in ihn schreiben, werden sie sofort in der Datei angezeigt, ohne Dispose aufzurufen.  Wenn wir 4095 schreiben, ist nichts in der Datei. <br><br>  <b>Windows</b> <br><br>  Unter Windows ist der Algorithmus zum Verwenden des Puffers und zum direkten Schreiben sehr √§hnlich.  Ein signifikanter Unterschied wird jedoch direkt bei den Schreib- und Leseaufrufen des asynchronen Systems beobachtet.  Wenn Sie sprechen, ohne tief in Systemaufrufe einzusteigen, gibt es eine solche √ºberlappende Struktur.  Es hat ein wichtiges Feld f√ºr uns - HANDLE HEvent.  Dies ist ein manuelles R√ºcksetzereignis, das nach Abschluss eines Vorgangs in den Alarmzustand wechselt.  Zur√ºck zur Implementierung.  Beim direkten Schreiben sowie beim Schreiben in den Puffer werden asynchrone Systemaufrufe verwendet, die die obige Struktur als Parameter verwenden.  Bei der Aufzeichnung wird ein FileStreamCompletionSource-Objekt erstellt - ein Erbe von TaskCompletionSource, in dem IOCallback angegeben ist.  Es wird von einem freien Thread aus dem Pool aufgerufen, wenn der Vorgang abgeschlossen ist.  Im R√ºckruf wird die √ºberlappende Struktur analysiert und das Task-Objekt entsprechend aktualisiert.  Das ist alles Magie. <br><br><h3>  Netzwerk </h3><br>  Es ist schwierig, alles zu beschreiben, was ich gesehen habe, um die Quelle zu verstehen.  Mein Pfad lag von HttpClient zu Socket und zu SocketAsyncContext f√ºr Unix.  Das allgemeine Schema ist das gleiche wie bei Dateien.  F√ºr Windows wird die erw√§hnte √ºberlappende Struktur verwendet und der Vorgang wird asynchron ausgef√ºhrt.  Unter Unix verwenden Netzwerkvorg√§nge auch R√ºckruffunktionen. <br><br>  Und eine kleine Erkl√§rung.  Ein aufmerksamer Leser wird feststellen, dass bei der Verwendung von asynchronen Anrufen zwischen einem Anruf und einem R√ºckruf eine gewisse Leere vorliegt, die irgendwie mit Daten funktioniert.  Hier lohnt es sich, der Vollst√§ndigkeit halber zu kl√§ren.  Am Beispiel von Dateien f√ºhrt der Plattencontroller direkte Operationen mit der Platte durch den Plattencontroller aus. Er gibt die Signale zum Bewegen der K√∂pfe in den gew√ºnschten Sektor usw.  Der Prozessor ist zu diesem Zeitpunkt frei.  Die Kommunikation mit der Festplatte erfolgt √ºber die Eingabe- / Ausgabeports.  Sie geben die Art des Vorgangs, den Speicherort der Daten auf der Festplatte usw. an.  Als n√§chstes werden die Steuerung und die Festplatte in diesen Vorgang einbezogen und erzeugen nach Abschluss der Arbeit einen Interrupt.  Dementsprechend tr√§gt ein asynchroner Systemaufruf nur Informationen zu den Eingabe- / Ausgabeports bei, w√§hrend der synchrone ebenfalls auf die Ergebnisse wartet und den Stream in einen blockierenden Zustand versetzt.  Dieses Schema gibt nicht vor, absolut genau zu sein (nicht zu diesem Artikel), sondern vermittelt ein konzeptionelles Verst√§ndnis der Arbeit. <br><br>  Jetzt ist die Art des Prozesses klar.  Aber jemand k√∂nnte fragen, was mit Asynchronit√§t zu tun ist.  Es ist unm√∂glich, f√ºr immer asynchron √ºber eine Methode zu schreiben. <br><br>  Erstens.  Ein Antrag kann als Dienst gestellt werden.  In diesem Fall wird der Einstiegspunkt - Main - von Ihnen von Grund auf neu geschrieben.  Bis vor kurzem konnte Main nicht asynchron sein. In Version 7 der Sprache wurde diese Funktion hinzugef√ºgt.  Aber es √§ndert nichts grundlegend, der Compiler generiert einfach das √ºbliche Main und aus dem asynchronen wird nur eine statische Methode erstellt, die in Main aufgerufen wird und deren Abschluss synchron erwartet wird.  Wahrscheinlich haben Sie also einige langlebige Aktionen.  Aus irgendeinem Grund beginnen in diesem Moment viele Leute dar√ºber nachzudenken, wie Threads f√ºr dieses Unternehmen erstellt werden k√∂nnen: √ºber Task, ThreadPool oder Thread im Allgemeinen manuell, da es in etwas einen Unterschied geben sollte.  Die Antwort ist einfach - nat√ºrlich Aufgabe.  Wenn Sie den TAP-Ansatz verwenden, st√∂ren Sie die manuelle Thread-Erstellung nicht.  Dies entspricht der Verwendung von HttpClient f√ºr fast alle Anforderungen, und POST erfolgt unabh√§ngig √ºber Socket. <br><br>  Zweitens.  Webanwendungen.  Bei jeder eingehenden Anforderung wird ein neuer Thread zur Verarbeitung aus ThreadPool abgerufen.  Der Pool ist nat√ºrlich gro√ü, aber nicht unendlich.  In dem Fall, dass viele Anforderungen vorhanden sind, sind m√∂glicherweise √ºberhaupt nicht gen√ºgend Threads vorhanden, und alle neuen Anforderungen werden zur Verarbeitung in die Warteschlange gestellt.  Diese Situation nennt man Hunger.  Bei Verwendung von asynchronen Controllern, wie bereits erl√§utert, kehrt der Stream jedoch in den Pool zur√ºck und kann zur Verarbeitung neuer Anforderungen verwendet werden.  Dadurch wird der Durchsatz des Servers deutlich erh√∂ht. <br><br>  Wir haben den asynchronen Prozess von Anfang bis Ende betrachtet.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mit dem Verst√§ndnis all dieser Asynchronit√§t, die der menschlichen Natur widerspricht, werden wir einige n√ºtzliche Tricks in Betracht ziehen, wenn wir mit asynchronem Code arbeiten. </font></font><br><a name="api"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√ºtzliche Klassen und Tricks bei der Arbeit mit TAP </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die statische Vielfalt der Task-Klasse. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Task-Klasse verf√ºgt √ºber mehrere n√ºtzliche statische Methoden. </font><font style="vertical-align: inherit;">Unten sind die wichtigsten.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.WhenAny (..) ist ein Kombinator, der IEnumerable / params von Aufgabenobjekten verwendet und ein Aufgabenobjekt zur√ºckgibt, das abgeschlossen wird, wenn die erste abgeschlossene Aufgabe abgeschlossen ist. </font><font style="vertical-align: inherit;">Das hei√üt, Sie k√∂nnen auf eine von mehreren laufenden Aufgaben warten</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task.WhenAll (..) - Kombinator, akzeptiert IEnumerable / params von Aufgabenobjekten und gibt ein Aufgabenobjekt zur√ºck, das abgeschlossen wird, wenn alle √ºbertragenen Aufgaben abgeschlossen sind </font></font></li><li> Task.FromResult&lt;T&gt;(T value) ‚Äî    ,    .          </li><li> Task.Delay(..) ‚Äî     </li><li> Task.Yield() ‚Äî  .   ,      .  ,    ,      </li></ol><br><h3> ConfigureAwait </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich die beliebteste "erweiterte" Funktion. Diese Methode geh√∂rt zur Task-Klasse und erm√∂glicht es Ihnen anzugeben, ob wir in demselben Kontext fortfahren m√ºssen, in dem die asynchrone Operation aufgerufen wurde. Ohne diese Methode wird der Kontext standardm√§√üig gespeichert und mit der genannten Post-Methode fortgesetzt. Wie gesagt, Post ist ein sehr teures Vergn√ºgen. Wenn die Leistung an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erster</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stelle steht und wir sehen, dass die Fortsetzung beispielsweise die Benutzeroberfl√§che nicht aktualisiert, k√∂nnen Sie sie im wartenden Objekt </font><i><font style="vertical-align: inherit;">.ConfigureAwait (false)</font></i><font style="vertical-align: inherit;"> angeben </font><font style="vertical-align: inherit;">. Dies bedeutet, dass es uns egal ist, wo die Fortsetzung durchgef√ºhrt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun zum Problem. Wie sie sagen, ist be√§ngstigend keine Unwissenheit, sondern falsches Wissen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Irgendwie habe ich zuf√§llig den Code einer Webanwendung beobachtet, bei der jeder asynchrone Aufruf mit diesem Beschleuniger dekoriert wurde. </font><font style="vertical-align: inherit;">Dies hat keine andere Wirkung als visuellen Ekel. </font><font style="vertical-align: inherit;">Die Standard-ASP.NET Core-Webanwendung hat keine eindeutigen Kontexte (es sei denn, Sie schreiben sie nat√ºrlich selbst). </font><font style="vertical-align: inherit;">Daher wird die Post-Methode dort sowieso nicht aufgerufen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TaskCompletionSource &lt;T&gt; </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Klasse, die das Verwalten eines Task-Objekts vereinfacht. </font><font style="vertical-align: inherit;">Eine Klasse bietet zahlreiche M√∂glichkeiten, ist jedoch am n√ºtzlichsten, wenn wir eine Aufgabe mit einer Aktion abschlie√üen m√∂chten, deren Ende bei einem Ereignis auftritt. </font><font style="vertical-align: inherit;">Im Allgemeinen wurde die Klasse erstellt, um alte asynchrone Methoden an TAP anzupassen, aber wie wir gesehen haben, wird sie nicht nur daf√ºr verwendet. </font><font style="vertical-align: inherit;">Ein kleines Beispiel f√ºr die Arbeit mit dieser Klasse:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); FileSystemWatcher watcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileSystemWatcher { Path = Directory.GetCurrentDirectory(), NotifyFilter = NotifyFilters.LastAccess, EnableRaisingEvents = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; watcher.Changed += (o, e) =&gt; tcs.SetResult(e.FullPath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tcs.Task; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Klasse erstellt einen asynchronen Wrapper, um den Namen der Datei abzurufen, auf die im aktuellen Ordner zugegriffen wurde. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CancellationTokenSource </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erm√∂glicht das Abbrechen eines asynchronen Vorgangs. </font><font style="vertical-align: inherit;">Die allgemeine Gliederung √§hnelt der Verwendung einer TaskCompletionSource. </font><font style="vertical-align: inherit;">Zuerst wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var cts = new CancellationTokenSource () erstellt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das √ºbrigens IDisposable ist, und dann wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cts.Token</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an asynchrone Operationen √ºbergeben </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nach einer bestimmten Logik von Ihnen wird unter bestimmten Bedingungen die Methode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cts.Cancel () aufgerufen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es kann auch ein Ereignis oder etwas anderes abonnieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung eines </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine gute Vorgehensweise. </font><font style="vertical-align: inherit;">Wenn Sie Ihre asynchrone Methode schreiben, die beispielsweise im Hintergrund arbeitet, k√∂nnen Sie einfach eine Zeile in den Hauptteil der Schleife einf√ºgen: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cancellationToken.ThrowIfCancellationRequested ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wodurch eine Ausnahme ausgel√∂st wird</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Diese Ausnahme wird als Abbruch des Vorgangs behandelt und nicht als Ausnahme im Aufgabenobjekt gespeichert. </font><font style="vertical-align: inherit;">Au√üerdem wird die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsCanceled-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eigenschaft </font><font style="vertical-align: inherit;">f√ºr das Task-Objekt wahr.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Longrunning </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oft gibt es Situationen, insbesondere beim Schreiben von Diensten, in denen Sie mehrere Aufgaben erstellen, die w√§hrend der gesamten Lebensdauer des Dienstes oder nur f√ºr eine sehr lange Zeit funktionieren. </font><font style="vertical-align: inherit;">Wie wir uns erinnern, ist die Verwendung eines Thread-Pools zu Recht der Aufwand f√ºr die Erstellung eines Threads. </font><font style="vertical-align: inherit;">Wenn jedoch selten ein Stream erstellt wird (auch nicht einmal pro Stunde), werden diese Kosten ausgeglichen und Sie k√∂nnen sicher separate Streams erstellen. </font><font style="vertical-align: inherit;">Zu diesem </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweck</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k√∂nnen Sie beim Erstellen einer Aufgabe eine spezielle Option angeben: </font><i><font style="vertical-align: inherit;">Task.Factory.StartNew (Aktion, </font></i><i><b><font style="vertical-align: inherit;">TaskCreationOptions.LongRunning</font></b></i><i><font style="vertical-align: inherit;"> )</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich empfehle Ihnen jedoch, alle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgaben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu betrachten. </font><i><font style="vertical-align: inherit;">Factory.StartNew-</font></i><font style="vertical-align: inherit;"> √úberladungen </font><font style="vertical-align: inherit;">gibt es viele M√∂glichkeiten, die Aufgabe flexibel zu konfigurieren, um bestimmte Anforderungen zu erf√ºllen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausnahmen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund des nicht deterministischen Charakters der asynchronen Codeausf√ºhrung ist die Frage der Ausnahmen sehr relevant. Es w√§re eine Schande, wenn Sie die Ausnahme nicht abfangen k√∂nnten und sie in den linken Thread geworfen wurde, wodurch der Prozess beendet wurde. Eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse wurde erstellt, um eine Ausnahme in einem Thread abzufangen und darin zu werfen </font><font style="vertical-align: inherit;">. Um die Ausnahme abzufangen, wird die statische Methode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo.Capture (ex) verwendet, die </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">ExceptionDispatchInfo</font></i><font style="vertical-align: inherit;"> zur√ºckgibt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Link zu diesem Objekt kann an einen beliebigen Thread √ºbergeben werden, der dann die Throw () -Methode aufruft, um ihn wegzuwerfen. </font><font style="vertical-align: inherit;">Der Wurf selbst erfolgt NICHT am Ort des asynchronen Operationsaufrufs, sondern am Ort der Verwendung des Operators await. </font><font style="vertical-align: inherit;">Und wie Sie wissen, kann Warten nicht auf Leere angewendet werden. </font><font style="vertical-align: inherit;">Wenn der Kontext vorhanden war, wird er von der Post-Methode an ihn √ºbergeben. </font><font style="vertical-align: inherit;">Andernfalls wird es im Strom aus dem Pool angeregt. </font><font style="vertical-align: inherit;">Und dies ist fast 100% Hallo zum Zusammenbruch der Anwendung. </font><font style="vertical-align: inherit;">Und hier kommen wir zur Praxis der Tatsache, dass wir Task oder Task &lt;T&gt; verwenden sollten, aber nicht ung√ºltig. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und noch etwas. </font><font style="vertical-align: inherit;">Der Scheduler verf√ºgt √ºber ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskScheduler.UnobservedTaskException-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ereignis </font><font style="vertical-align: inherit;">, das </font><i><font style="vertical-align: inherit;">ausgel√∂st wird</font></i><font style="vertical-align: inherit;"> , wenn eine </font><i><font style="vertical-align: inherit;">UnobservedTaskException</font></i><font style="vertical-align: inherit;"> ausgel√∂st wird</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Ausnahme wird w√§hrend der Speicherbereinigung ausgel√∂st, wenn der GC versucht, ein Taskobjekt mit einer nicht behandelten Ausnahme zu erfassen.</font></font><br><br><h3> IAsyncEnumerable </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor C # 8 und .NET Core 3.0 war es nicht m√∂glich, einen Ertragsiterator in einer asynchronen Methode zu verwenden, was die Lebensdauer komplizierte und dazu f√ºhrte, dass Task &lt;IEnumerable &lt;T&gt;&gt; von dieser Methode zur√ºckgegeben wurde, d. H. Es gab keine M√∂glichkeit, die Sammlung zu durchlaufen, bis sie vollst√§ndig empfangen wurde. Jetzt gibt es eine solche Gelegenheit. Erfahren Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mehr dar√ºber </font><font style="vertical-align: inherit;">. Dazu muss der R√ºckgabetyp </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerable &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (oder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerator &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sein. Um eine solche Sammlung zu durchlaufen, sollten Sie die foreach-Schleife mit dem Schl√ºsselwort await verwenden. Au√üerdem k√∂nnen die Methoden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WithCancellation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr das Ergebnis der Operation </font><font style="vertical-align: inherit;">aufgerufen werden, wobei das verwendete CancelationToken und die Notwendigkeit angegeben werden, im selben Kontext fortzufahren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie erwartet wird alles so faul wie m√∂glich gemacht. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unten ist ein Beispiel und die Schlussfolgerung, die er gibt.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); sw.Start(); IAsyncEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; enumerable = AsyncYielding(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time after calling: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerable.WithCancellation(..).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"element: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{element}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds}</span></span></span><span class="hljs-string">"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> IAsyncEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncYielding</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uselessElement <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) { Task task = Task.Delay(TimeSpan.FromSeconds(uselessElement)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Task run: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{uselessElement}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> task; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uselessElement; } } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit nach dem Aufruf: 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgabenlauf: 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Element: 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit: 1033 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgabenlauf: 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Element: 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit: 3034 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgabenlauf: 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Element: 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit: 6035</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Threadpool </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Klasse wird beim Programmieren mit TAP aktiv verwendet. Daher werde ich die minimalen Details seiner Implementierung angeben. Im Inneren verf√ºgt ThreadPool √ºber ein Array von Warteschlangen: eine f√ºr jeden Thread + eine globale. Beim Hinzuf√ºgen eines neuen Jobs zum Pool wird der Thread ber√ºcksichtigt, der das Hinzuf√ºgen initiiert hat. Wenn es sich um einen Thread aus dem Pool handelt, wird die Arbeit in eine eigene Warteschlange f√ºr diesen Thread gestellt, wenn es sich um einen anderen Thread handelt - in den globalen. Wenn ein Thread f√ºr die Arbeit ausgew√§hlt wird, wird zuerst seine lokale Warteschlange angezeigt. Wenn es leer ist, nimmt der Thread Jobs von der globalen. Wenn es leer ist, beginnt es, von den anderen zu stehlen. Au√üerdem sollten Sie sich niemals auf die Reihenfolge der Arbeit verlassen, da es tats√§chlich keine Reihenfolge gibt. Die Standardanzahl der Threads in einem Pool h√§ngt von vielen Faktoren ab, einschlie√ülich der Gr√∂√üe des Adressraums. Wenn weitere Ausf√ºhrungsanforderungen vorliegen,Als die Anzahl der verf√ºgbaren Threads werden Anforderungen in die Warteschlange gestellt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Threads in einem Thread-Pool sind Hintergrund-Threads (Eigenschaft isBackground = true). </font><font style="vertical-align: inherit;">Dieser Thread-Typ unterst√ºtzt nicht die Lebensdauer des Prozesses, wenn alle Vordergrund-Threads abgeschlossen sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Systemthread √ºberwacht den Status des Wartehandles. </font><font style="vertical-align: inherit;">Wenn der Wartevorgang endet, wird der √ºbertragene R√ºckruf vom Thread aus dem Pool ausgef√ºhrt (beachten Sie die Dateien in Windows).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgabenartiger Typ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser zuvor erw√§hnte Typ (Struktur oder Klasse) kann als R√ºckgabewert der asynchronen Methode verwendet werden. </font><font style="vertical-align: inherit;">Ein Builder-Typ muss diesem Typ mithilfe des Attributs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[AsyncMethodBuilder (..)] zugeordnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dieser Typ muss die oben genannten Merkmale aufweisen, um das Schl√ºsselwort await auf ihn anwenden zu k√∂nnen. </font><font style="vertical-align: inherit;">Es kann f√ºr Methoden parametrisiert werden, die keinen Wert zur√ºckgeben, und f√ºr Methoden, die einen Wert zur√ºckgeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Builder selbst ist eine Klasse oder Struktur, deren Framework im folgenden Beispiel dargestellt ist. </font><font style="vertical-align: inherit;">Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetResult-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">verf√ºgt √ºber einen Parameter vom Typ T f√ºr einen von T parametrisierten aufgaben√§hnlichen Typ. F√ºr nicht parametrisierte Typen verf√ºgt die Methode √ºber keine Parameter.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erforderliche Builder-Schnittstelle</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyTaskMethodBuilder</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MyTaskMethodBuilder&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start&lt;TStateMachine&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetStateMachine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAsyncStateMachine stateMachine</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception exception</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T result</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : INotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : ICriticalNotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyTask&lt;T&gt; Task { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Prinzip der Arbeit unter dem Gesichtspunkt des Schreibens Ihres aufgaben√§hnlichen Typs wird nachstehend beschrieben. Das meiste davon wurde bereits beim Parsen des vom Compiler generierten Codes beschrieben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Compiler verwendet alle diese Typen, um eine Zustandsmaschine zu generieren. Der Compiler wei√ü, welche Builder f√ºr die ihm bekannten Typen verwendet werden sollen. Hier geben wir an, was w√§hrend der Codegenerierung verwendet wird. Wenn die Zustandsmaschine eine Struktur ist, wird sie beim Aufrufen von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetStateMachine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gepackt </font><font style="vertical-align: inherit;">. Der Builder kann die gepackte Kopie bei Bedarf zwischenspeichern. Der Builder muss </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateMachine.MoveNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">oder nach dem </font><font style="vertical-align: inherit;">Aufruf </font><i><font style="vertical-align: inherit;">aufrufen</font></i><font style="vertical-align: inherit;"> , um die Ausf√ºhrung zu starten und die Zustandsmaschine voranzutreiben. Nach dem Aufruf von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird die Task-Eigenschaft von der Methode zur√ºckgegeben. Ich empfehle, dass Sie zur Stub-Methode zur√ºckkehren und diese Schritte anzeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Zustandsmaschine erfolgreich abgeschlossen wurde, wird die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetResult-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><i><font style="vertical-align: inherit;">aufgerufen</font></i><font style="vertical-align: inherit;"> , andernfalls </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn die Zustandsmaschine " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wait"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erreicht, wird die </font><i><font style="vertical-align: inherit;">GetAwaiter ()</font></i><font style="vertical-align: inherit;"> -Methode vom </font><font style="vertical-align: inherit;">aufgaben√§hnlichen Typ </font><font style="vertical-align: inherit;">ausgef√ºhrt </font><font style="vertical-align: inherit;">. Wenn das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warteobjekt die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnittstelle </font><i><font style="vertical-align: inherit;">ICriticalNotifyCompletion</font></i><font style="vertical-align: inherit;"> und IsCompleted = false </font><font style="vertical-align: inherit;">implementiert </font><font style="vertical-align: inherit;">, verwendet die Zustandsmaschine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitUnsafeOnCompleted (ref awaiter, ref stateMachine)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AwaitUnsafeOnCompleted-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">sollte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awaiter.OnCompleted (Aktion)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufrufen. </font><font style="vertical-align: inherit;">In Aktion sollte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateMachine.MoveNext aufgerufen werden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn das Warteobjekt abgeschlossen ist. </font><font style="vertical-align: inherit;">√Ñhnliches gilt f√ºr die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INotifyCompletion-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnittstelle </font><font style="vertical-align: inherit;">und die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitOnCompleted-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie dies nutzen, liegt bei Ihnen. </font><font style="vertical-align: inherit;">Aber ich rate Ihnen, √ºber 514 Mal nachzudenken, bevor Sie dies in der Produktion anwenden, und nicht zum Verw√∂hnen. </font><font style="vertical-align: inherit;">Unten finden Sie ein Anwendungsbeispiel. </font><font style="vertical-align: inherit;">Ich habe nur einen Proxy f√ºr einen Standard-Builder entworfen, der der Konsole anzeigt, welche Methode zu welcher Zeit aufgerufen wurde. </font><font style="vertical-align: inherit;">√úbrigens m√∂chte das asynchrone Main () keine benutzerdefinierten Erwartungen unterst√ºtzen (ich glaube, dass mehr als ein Produktionsprojekt aufgrund dieses Fehlschlags von Microsoft hoffnungslos besch√§digt wurde). </font><font style="vertical-align: inherit;">Wenn Sie m√∂chten, k√∂nnen Sie den Proxy-Logger mit einem normalen Logger √§ndern und weitere Informationen protokollieren.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proxy-Aufgabe protokollieren</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Start"</span></span>); JustMethod().Task.Wait(); <span class="hljs-comment"><span class="hljs-comment">//   Console.WriteLine("Stop"); } public static async LogTask JustMethod() { await DelayWrapper(1000); } public static LogTask DelayWrapper(int milliseconds) =&gt; new LogTask { Task = Task.Delay(milliseconds)}; } [AsyncMethodBuilder(typeof(LogMethodBuilder))] public class LogTask { public Task Task { get; set; } public TaskAwaiter GetAwaiter() =&gt; Task.GetAwaiter(); } public class LogMethodBuilder { private AsyncTaskMethodBuilder _methodBuilder = AsyncTaskMethodBuilder.Create(); private LogTask _task; public static LogMethodBuilder Create() { Console.WriteLine($"Method: Create; {DateTime.Now :O}"); return new LogMethodBuilder(); } public void Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: Start; {DateTime.Now :O}"); _methodBuilder.Start(ref stateMachine); } public void SetStateMachine(IAsyncStateMachine stateMachine) { Console.WriteLine($"Method: SetStateMachine; {DateTime.Now :O}"); _methodBuilder.SetStateMachine(stateMachine); } public void SetException(Exception exception) { Console.WriteLine($"Method: SetException; {DateTime.Now :O}"); _methodBuilder.SetException(exception); } public void SetResult() { Console.WriteLine($"Method: SetResult; {DateTime.Now :O}"); _methodBuilder.SetResult(); } public void AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: AwaitOnCompleted; {DateTime.Now :O}"); _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine); } public void AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: AwaitUnsafeOnCompleted; {DateTime.Now :O}"); _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine); } public LogTask Task { get { Console.WriteLine($"Property: Task; {DateTime.Now :O}"); return _task ??= new LogTask {Task = _methodBuilder.Task}; } set =&gt; _task = value; } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startmethode </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Erstellen; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7152733 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode: Start; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7262226 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode: AwaitUnsafeOnCompleted; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7275206 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft: Aufgabe; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7292005 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode: SetResult; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 14.7297967 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stop</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das ist alles, danke euch allen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470830/">https://habr.com/ru/post/de470830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470820/index.html">Ein kurzer Test von Dutzenden von Hypothesen: Wie wir aus der Routine ausbrechen und in einer anderen Stadt diskutieren</a></li>
<li><a href="../de470822/index.html">Temperatur√ºberwachung im Unternehmen</a></li>
<li><a href="../de470824/index.html">Dialoge √ºber Versprechen</a></li>
<li><a href="../de470826/index.html">Bergleute, Taucher und Kobalt: Wie wir Kunden einen sicheren Internetzugang bieten</a></li>
<li><a href="../de470828/index.html">Python verkn√ºpfte Liste: Katzen in Kisten</a></li>
<li><a href="../de470834/index.html">Superinfektions-, Antibiotika- und Zombie-Apokalypse-Modelle</a></li>
<li><a href="../de470838/index.html">Containersicherheit in CI / CD</a></li>
<li><a href="../de470844/index.html">Das neue Projekt der Br√ºder Durov: Telegram Open Network</a></li>
<li><a href="../de470852/index.html">Verarbeitung von 40 TB Code aus 10 Millionen Projekten auf einem dedizierten Server mit Go f√ºr 100 US-Dollar</a></li>
<li><a href="../de470856/index.html">Telegramm GRAM Wallet: Nutzungsbedingungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>