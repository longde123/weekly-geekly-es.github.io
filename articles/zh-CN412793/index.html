<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏽 👩🏾‍🤝‍👨🏻 🎥 MassTransit，Saga和RabbitMQ用于实施流程管理器 👂🏽 🏦 🎥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="曾经，我们面临着使一家大公司的各种工作流程自动化的任务。 对我们来说，这意味着在启动时要组装大约10个系统。 而且，所有组件都必须异步，可扩展，可靠地连接。 


 简化的过程可以描述为不同系统中的一系列动作，由于需要人工参与，因此无法完全自动化。 例如，选择某些动作或基本协调，这对于进入过程的下一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MassTransit，Saga和RabbitMQ用于实施流程管理器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/412793/"><p> 曾经，我们面临着使一家大公司的各种工作流程自动化的任务。 对我们来说，这意味着在启动时要组装大约10个系统。 而且，所有组件都必须异步，可扩展，可靠地连接。 </p><br><p> 简化的过程可以描述为不同系统中的一系列动作，由于需要人工参与，因此无法完全自动化。 例如，选择某些动作或基本协调，这对于进入过程的下一阶段是必需的。 </p><br><p> 为了解决此问题，我们决定通过数据总线使用消息传递体系结构，MassTransit及其Saga与RabbitMQ完美匹配。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8f9/896/b2a/8f9896b2aade49a732cf10b63b8276ec.jpg" alt="图片"><a name="habracut"></a></p><h2> 佐贺是什么样的？ </h2><br>  Saga是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Enterprise Application Integration Templates</a>一书中Process Manager模板的实现，它使您可以将流程描述为状态机。 事件到达入口，Saga执行一系列动作。 同时，在佐贺县的任何阶段，都可能需要做出决定。 然后，她在跟踪器中创建一个任务，并无限期地“入睡”，等待新事件。 <br><p>  Saga基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自动机</a> 。 在从MassTransitStateMachine &lt;&gt;继承的类中声明性地描述了它。 对于Saga，您需要描述所有状态，发生的事件以及发生某些事件时采取的措施。 当前状态存储在数据库中。 </p><br><p> 首先，我们描述佐贺的所有州和事件，并给它们起易于理解的名称。 看起来像这样： </p><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StateMachine</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State AwaitingTaskCreated { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State AwaitingTaskTakedToWork { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State AwaitingDecisionAboutTask { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State Rejected { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Event&lt;IStartWorkflowCommand&gt; StartWorkflowCommandReceived { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Event&lt;TaskCreatedNotification&gt; TaskCreated { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Event&lt;TaskTakedToWorkNotification&gt; TaskTakedToWork { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Event&lt;TaskDeclinedNotification&gt; TaskDeclined { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Event&lt;TaskApprovedNotification&gt; TaskApproved { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildStateMachine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InstanceState(x =&gt; x.CurrentState); Event(() =&gt; StartWorkflowCommandReceived, x =&gt; x.CorrelateById(ctx =&gt; ctx.Message.CorrelationId) .SelectId(context =&gt; context.Message.CorrelationId)); Event(() =&gt; TaskCreated, x =&gt; x.CorrelateById(ctx =&gt; ctx.Message.CorrelationId)); Event(() =&gt; TaskTakedToWork, x =&gt; x.CorrelateById(ctx =&gt; ctx.Message.CorrelationId)); Event(() =&gt; TaskDeclined, x =&gt; x.CorrelateById(ctx =&gt; ctx.Message.CorrelationId)); Event(() =&gt; TaskApproved, x =&gt; x.CorrelateById(ctx =&gt; ctx.Message.CorrelationId)); } }</code> </pre> <br><p> 我们启动了一个局部类，在其中声明了所有状态和事件的列表，以及BuildStateMachine方法，该方法描述了事件与Saga的关联。 为此，在每个事件中传递一个特殊的参数CorrelationId-这是Guid，它在所有连接的系统之间和监视系统中运行。 </p><br><p> 因此，如果出现任何问题，我们可以从所有连接的系统中还原日志所发生情况的全部图景。 我们在来自Saga的消息中发送CorrelationId，系统将其发送回通知中，以便我们可以将消息与特定的Saga相关联。 </p><br><p> 这是状态机类本身的一个示例： </p><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> sealed partial <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> StateMachine : MassTransitStateMachine&lt;WorkflowSaga&gt; { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> StateMachine() { BuildStateMachine(); <span class="hljs-keyword"><span class="hljs-keyword">Initially</span></span>(WhenStartWorkflowCommandReceived()); During(AwaitingTaskCreatedInPlanner, WhenTaskCreated()); During(AwaitingTaskTakedToWork, WhenTaskTakedToWork()); During(AwaitingDecisionAboutTask, WhenTaskApproved(), WhenTaskDeclined()); } private EventActivityBinder&lt;WorkflowSaga, IStartWorkflowCommand&gt; WhenStartWorkflowCommandReceived() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">When</span></span>(StartWorkflowCommandReceived) .<span class="hljs-keyword"><span class="hljs-keyword">Then</span></span>(ctx =&gt; ctx.Instance.SaveConfigurationRequestInfo(ctx.Data)) .Send(TaskManagerQueue, ctx =&gt; <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> CreateTaskCommand(ctx.Instance)) .TransitionTo(AwaitingTaskCreated); } private EventActivityBinder&lt;WorkflowSaga, TaskCreatedNotification&gt; WhenTaskCreated() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">When</span></span>(DPORPApproveTaskCreatedInPlanner) .<span class="hljs-keyword"><span class="hljs-keyword">Then</span></span>(ctx =&gt; ctx.Instance.SaveCreatedTaskInfo(ctx.Data)) .Send(MailServiceQueue, ctx =&gt; <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> NotifyRequestAuthorThatWorkflowStarted(ctx.Instance)) .TransitionTo(AwaitingTaskTakedToWork); } private EventActivityBinder&lt;WorkflowSaga, TaskTakedToWorkNotification&gt; WhenTaskTakedToWork() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">When</span></span>(TaskTakedToWork) .<span class="hljs-keyword"><span class="hljs-keyword">Then</span></span>(ctx =&gt; ctx.Instance.MarkTaskAsTakedToWork(ctx.Data)) .TransitionTo(AwaitingDecisionAboutTask); } private EventActivityBinder&lt;WorkflowSaga, TaskApprovedNotification&gt; WhenTaskApproved() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">When</span></span>(TaskApproved) .<span class="hljs-keyword"><span class="hljs-keyword">Then</span></span>(ctx =&gt; ctx.Instance.MarkTaskAsApproved(ctx.Data)) .Finalize(); } private EventActivityBinder&lt;WorkflowSaga, TaskDeclinedNotification&gt; WhenTaskDeclined() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">When</span></span>(TaskDeclined) .<span class="hljs-keyword"><span class="hljs-keyword">Then</span></span>(ctx =&gt; ctx.Instance.MarkTaskAsDeclined(ctx.Data)) .TransitionTo(Rejected); } }</code> </pre><br><p> 构造函数描述状态。 为了保持可读性，使用单独的方法来接收每个事件。 构造消息的整个逻辑是在消息本身中执行的，否则，随着系统复杂性的提高，Saga迅速膨胀。 </p><br><p> 在制定约定和保持可读性时应格外小心。 由于C＃的必要性，很难在其中声明状态和动作的描述。 即使对于简单的状态机，真正的地狱也开始了。 </p><br><p> 现在谈谈SagaInstance。  SagaInstance是从SagaStateMachineInstance继承的类。 它由表征状态机的对象和字段组成。 粗略地说，这就是佐贺的记忆。 我们存储了她一生所需的所有Saga数据。 此类中还描述了在工作过程中此数据更改的逻辑。 </p><br><p> 这是一个例子： </p><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> WorkflowSaga : SagaStateMachineInstance , ISagaWithState , ICreatedOnOffset , IModifiedOnOffset , ICreatedBy&lt;string&gt; , IModifiedBy&lt;string&gt; { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Guid CorrelationId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> string CurrentState { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> string InitialRequestViewUrl { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> string RequestNumber { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> string RequestAuthor { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> string RequestText { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> byte[] RowVersion { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> string CreatedBy { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> string ModifiedBy { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> DateTimeOffset CreatedOn { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> DateTimeOffset ModifiedOn { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> DateTimeOffset CompletedOn { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual ICollection&lt;RelatedTask&gt; RelatedTasks { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> SaveGabrielConfigurationRequestInfo( ICreateGabrielConfigurationRequestCommand command) { CorrelationId = command.CorrelationId; RequestNumber = command.RequestNumber; RequestAuthor = command.Author; RequestText = command.RequestText; InitialRequestViewUrl = command.InitialRequestViewUrl; CreatedOn = RuntimeContext.<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span>.DateTimeOffset.Now; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> SaveCreatedTaskInfo(ITaskCreationInfo taskCreationInfo) { RelatedPlannerTasks.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RelatedPlannerTask(taskCreationInfo)); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> MarkTaskAsTakedToWork(ITaskUpdatedInfo taskInfo) { UpdateTaskInfo(taskInfo, TaskStatus.TakedToWork); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> MarkTaskAsApproved(TaskApprovedNotification taskInfo) { UpdateTaskInfo(taskInfo, TaskStatus.Completed, taskInfo.<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>); CompletedOn = RuntimeContext.<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span>.DateTimeOffset.Now; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> MarkTaskAsDeclined(TaskDeclinedNotification taskInfo) { UpdateTaskInfo(taskInfo, TaskStatus.Declined, taskInfo.<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>); CompletedOn = RuntimeContext.<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span>.DateTimeOffset.Now; } private <span class="hljs-type"><span class="hljs-type">void</span></span> UpdateTaskInfo(ITaskUpdatedInfo taskInfo, TaskStatus taskStatus, string <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { var task = RelatedTasks.Single(t =&gt; t.Number == taskInfo.Number); task.ModifiedBy = taskInfo.TaskModifiedBy; task.<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>; task.Status = taskStatus; } }</code> </pre><br><p> 一个示例显示，在SagaInstance中存储了CorrelationId以将事件与Saga和CurrentState相关联以存储Saga的当前状态。 </p><br><h2> 错误处理 </h2><br><p> 如果在消息处理过程中发生错误，Saga会如何处理？ 这是一个重要的问题，因为每个人都希望状态机始终保持一致，即使出了问题。 借助MassTransit，Saga的表现不错。 </p><br><p> 正如您已经注意到的，在上面的示例中，没有一个try catch块可以处理异常。 原因很简单：在那里不需要它们。 如果在消息处理期间发生异常，则消息将返回到队列，并且所有更改都将回滚。 由于我们在与Saga相同的事务中进行所有数据操作，因此不会关闭该事务。 </p><br><p> 一般而言，在Saga本身中操纵Saga以外的其他东西是不好的做法。 根据“企业应用程序的集成模板”一书，流程管理器应保持尽可能的精简和笨拙：仅向系统发出命令并监视状态，但他本人不应该做任何事情。 </p><br><p> 当然，当您需要执行一些补偿操作来处理异常时，会有更复杂的场景。 然后，使用“ .Catch”状态机处理程序来捕获某种类型的异常，然后执行补偿逻辑。 </p><br><p> 而且，如果您只需要承诺一个例外，那么最好使用观察者（Observer）。 </p><br><p> 现在想象一下在消息处理期间我们已经执行了Send命令的情况，此后发生了异常。 在此步骤发送的命令将发生什么？ 毕竟，所有已经消失的东西都无法退还吗？ 但是，这里一切都经过深思熟虑。 </p><br><p> 配置总线时，可以启用UseInMemoryOutbox选项。 此选项允许您在当前步骤完成之前不发送消息。 如果发生异常，将完全不发送消息。 以下是文档摘录： </p><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Includes an outbox <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the consume <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span> <span class="hljs-type"><span class="hljs-type">path</span></span>, which delays outgoing messages <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">path</span></span> /// <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the pipeline <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the outbox <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>. At this <span class="hljs-type"><span class="hljs-type">point</span></span>, the message execution pipeline should be /// nearly complete <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> the ack remaining. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> an <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> thrown, the messages are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sent/published. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="configurator"&gt;The pipe configurator&lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> UseInMemoryOutbox(this IConsumePipeConfigurator configurator)</code> </pre> <br><h2> 测验 </h2><br><p> 乍一看，测试异步状态机仍然是一种乐趣。 但是这里一切都很好。  MassTransit提供了一个很好的测试编写框架，可以完全满足我们测试状态机的所有需求。 </p><br><p> 该框架为InMemory提供了数据总线（InMemoryTestHarness）的实现，它使您可以绕过RabbitMQ或其他队列发送和接收消息。 </p><br><p> 好吧，例如： </p><br><pre> <code class="hljs pgsql">[TestFixture] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SagaTests : TestFixtureBase { protected const string HostName = "HostName"; protected InMemoryTestHarness Harness; protected StateMachine StateMachine; protected StateMachineSagaTestHarness&lt;GabrielConfigurationRequestSaga, StateMachine&gt; Saga; [SetUp] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> SetUp() { StateMachine = (StateMachine)Kernel. <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>&lt;MassTransitStateMachine&lt;WorkflowSaga&gt;&gt;(); Harness = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> InMemoryTestHarness(HostName); Saga = Harness .StateMachineSaga&lt;WorkflowSaga, StateMachine&gt;(StateMachine); } [TearDown] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> async Task TearDown() { await Harness.Stop(); } protected async Task&lt;WorkflowSaga&gt; InitializeSaga() { await Harness.<span class="hljs-keyword"><span class="hljs-keyword">Start</span></span>(); var command = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> TestStartWorkflowCommand { CorrelationId = SagaId, Author = RequestAuthor, InitialRequestViewUrl = InitialRequestViewUrl, RequestText = RequestText, RequestNumber = RequestNumber, }; await Harness.InputQueueSendEndpoint .Send&lt;IStartWorkflowCommand&gt;(command); //    ,  consume    , // ,  Saga  ,    <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.IsTrue(Harness.Consumed .<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span>&lt;IStartWorkflowCommand&gt;().<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>()); var currentSaga = Saga.Created.Contains(SagaId); currentSaga.RelatedPlannerTasks = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;RelatedPlannerTask&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSaga; } [Test] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> async Task CheckCurrntStateWhenStartWorkflowCommand() { var saga = await InitializeSaga(); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.IsNotNull(saga); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.AreEqual(StateMachine .AwaitingORDTApproveTaskCreatedInPlanner.Name, saga.CurrentState); } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> WhenTaskCreated : SagaTestsBase { private async Task&lt;WorkflowSaga&gt; InitializeState() { var saga = await InitializeSaga(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); saga.CurrentState = StateMachine.AwaitingTaskCreated.Name; InitializeRelatedTask(saga); await SendTaskCreatedNotification(); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.IsTrue(Harness.Consumed .<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span>&lt;TaskCreatedNotification&gt;().<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saga; } [Test] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> async Task SaveWorkflowDataWhenTaskCreated() { var saga = await InitializeState(); var taskInfo = saga.RelatedPlannerTasks .First(task =&gt; task.PlannerTaskType == PlannerTaskType.DPORPApprove); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.AreEqual(TaskNumber, taskInfo.Number); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.AreEqual(TaskUrl, taskInfo.TaskUrl); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.AreEqual(SagaId, taskInfo.SagaCorrelationId); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.AreEqual(TaskStatus.Created, taskInfo.Status); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.AreEqual(<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, taskInfo.ModifiedBy); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.AreEqual(saga.CurrentState, StateMachine.AwaitingTaskTakedToWork.Name); } [Test] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> async Task SendsMailWhenTaskCreated() { var mailConsumer = Harness .Consumer&lt;MockConsumer&lt;ISendEmailMessageWithTemplateCommand&gt;&gt; (RabbitMqRouting.QueueNames .SendEmailsQueueName); await InitializeState(); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.IsTrue(mailConsumer.Consumed .<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span>&lt;ISendEmailMessageWithTemplateCommand&gt;().<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>()); } private async Task SendTaskCreatedNotification() { await Harness.InputQueueSendEndpoint .Send(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> TaskCreatedNotification { TaskUrl = TaskUrl, Number = TaskNumber, TaskModifiedBy = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, CorrelationId = SagaId }); } }</code> </pre><br><p> 测试运行非常快。 例如，在一台开发人员的计算机上，大约21秒内运行850个测试。 </p><br><h2> 有用的提示 </h2><br><p> 总之，我们根据经验提供了一些有用的提示。 </p><br><ol><li><p> 合同和公交车通信方案最好放在私人空间中。 因此，发送方和接收方的名称不会有差异。 您还可以将带有命名队列和主机的常量放入nuget中。  Nuget每天可定制。 还有一些源代码控制支持nuget，有收费的私人供稿。 </p><br></li><li><p> 了解发送和发布之间的区别。 如果您有一个订阅者，并且确切知道要将命令发送到的队列的名称，请使用“发送”。 发布旨在发送广播警报。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a>上的详细信息。 </p><br></li><li><p> 如果您需要构建请求/响应消息，则最好为合同添加响应的队列名称，而不是使用MassTransit自己建议避免的MassTransit的请求/响应方案。 由于这大大降低了可靠性。 您正在失去异步的所有好处。 但是，如果您仍然需要在有限的时间内获得答案，则最好使用直接呼叫。 这最好写在同一本书《企业应用程序集成模板》中。 </p><br></li><li><p> 传奇应该是瘦的。 尝试将所有繁琐的逻辑传递给其他系统。  Saga必须跳过状态并向左右散布消息。 </p><br></li><li><p> 将所有消息CorrelationId添加到系统之间运行。 因此，分析日志并将所有消息链接成一张图片要容易得多。 大众运输也是如此。 从CorrelatedBy接口继承时，会将CorrelationId添加到消息中。 <br></p><br> 在系统中设置日志和监视，将永远不会造成伤害。 我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文中的</a>经验。 <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN412793/">https://habr.com/ru/post/zh-CN412793/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN412783/index.html">在Centos 7上从源代码安装MTProto Telegram代理</a></li>
<li><a href="../zh-CN412785/index.html">管理硕士和自由职业者。 故事分为三个部分</a></li>
<li><a href="../zh-CN412787/index.html">将Git嵌入企业开发系统中</a></li>
<li><a href="../zh-CN412789/index.html">“工作中的帮助”：如何使聊天机器人更智能</a></li>
<li><a href="../zh-CN412791/index.html">改善视频监控系统的性能并防止崩溃</a></li>
<li><a href="../zh-CN412795/index.html">让我们从文章“极客时代重返哈勃尔到底出了什么问题”的讨论中得出结论。</a></li>
<li><a href="../zh-CN412797/index.html">关于Google的CDN，服务和字体的危害</a></li>
<li><a href="../zh-CN412799/index.html">始终保持联系：Mango Talker-Messenger和软件电话</a></li>
<li><a href="../zh-CN412801/index.html">研究：由于加密货币交易的安全性低，黑客窃取了数百万美元</a></li>
<li><a href="../zh-CN412803/index.html">深入了解各种智能合约平台</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>