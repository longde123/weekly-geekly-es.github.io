<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàöÔ∏è üë®üèæ‚Äçüé§ üëæ Vor- und Nachteile von HugePages üö∂üèæ üóùÔ∏è üë®üèª‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine √úbersetzung des Artikels wurde f√ºr Studenten des Linux Administrator- Kurses vorbereitet. 



 Zuvor habe ich dar√ºber gesprochen, wie man die Ver...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vor- und Nachteile von HugePages</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/460403/"><p><img src="https://habrastorage.org/webt/-w/lp/l5/-wlpl5yurwmjrqrh5ufgru7fejm.png"></p><br><p>  <em>Eine √úbersetzung des Artikels wurde f√ºr Studenten des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux Administrator-</a> Kurses vorbereitet.</em> </p><br><hr><br><p>  Zuvor habe ich dar√ºber gesprochen, wie man die Verwendung von Hugepages unter Linux testet und aktiviert. <br>  Dieser Artikel ist nur n√ºtzlich, wenn Sie wirklich wissen, wo Sie Hugepages verwenden k√∂nnen.  Ich habe viele Leute getroffen, die von der Aussicht get√§uscht werden, dass Hugepages die Produktivit√§t auf magische Weise steigern wird.  Riesiges Paging ist jedoch ein komplexes Thema und kann bei unsachgem√§√üer Verwendung die Leistung beeintr√§chtigen. <a name="habracut"></a></p><br><h1 id="chast-1-proveryaem-chto-hugepages-vklyucheny-v-linux-original-zdeshttpstechoverflownet20130801checking-if-hugepages-are-enabled-in-linux">  Teil 1: Vergewissern Sie sich, dass unter Linux riesige Seiten enthalten sind (Original <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ) </h1><br><p>  <strong>Problem:</strong> <br>  Sie m√ºssen √ºberpr√ºfen, ob HugePages auf Ihrem System aktiviert sind. </p><br><p>  <strong>L√∂sung:</strong> <br>  Es ist ziemlich einfach: </p><br><pre><code class="plaintext hljs">cat /sys/kernel/mm/transparent_hugepage/enabled</code> </pre> <br><p>  Sie werden so etwas bekommen: </p><br><pre> <code class="plaintext hljs">always [madvise] never</code> </pre> <br><p>  Sie sehen eine Liste der verf√ºgbaren Optionen ( <em>immer, madvise, nie</em> ), w√§hrend die aktuell aktive Option in Klammern steht (standardm√§√üig <em>madvise</em> ). </p><br><p>  <em>madvise</em> bedeutet, dass <code>transparent hugepages</code> nur f√ºr Speicherbereiche enthalten sind, die explizit Riesenseiten mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">madvise anfordern (2)</a> . </p><br><p>  bedeutet <em>immer,</em> dass <code>transparent hugepages</code> immer f√ºr alle Prozesse <code>transparent hugepages</code> sind.  Dies verbessert normalerweise die Leistung. Wenn Sie jedoch einen Anwendungsfall haben, in dem viele Prozesse wenig Speicher verbrauchen, kann sich die Gesamtspeicherlast dramatisch erh√∂hen. </p><br><p>  bedeutet <em>niemals,</em> dass <code>transparent hugepages</code> nicht enthalten sind, selbst wenn sie mit madvise angefordert werden.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen finden</a> Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> zum Linux-Kernel. </p><br><h4 id="kak-izmenit-znachenie-po-umolchaniyu">  So √§ndern Sie den Standardwert </h4><br><p>  <strong>Option 1</strong> : √Ñndern Sie <code>sysfs</code> direkt (nach dem Neustart wird der Parameter auf den Standardwert zur√ºckgesetzt): </p><br><pre> <code class="plaintext hljs">echo always &gt;/sys/kernel/mm/transparent_hugepage/enabled echo madvise &gt;/sys/kernel/mm/transparent_hugepage/enabled echo never &gt;/sys/kernel/mm/transparent_hugepage/enabled</code> </pre> <br><p>  <strong>Option 2</strong> : √Ñndern Sie den Systemstandard, indem Sie den Kernel mit der ge√§nderten Konfiguration neu kompilieren (diese Option wird nur empfohlen, wenn Sie Ihren eigenen Kernel verwenden): </p><br><ul><li>  Verwenden Sie Folgendes, um immer die Standardeinstellungen festzulegen: <br><pre> <code class="plaintext hljs">CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS=y # Comment out CONFIG_TRANSPARENT_HUGEPAGE_MADVISE=y</code> </pre> </li><li>  Verwenden Sie Folgendes, um madvise standardm√§√üig festzulegen: <br><pre> <code class="plaintext hljs">CONFIG_TRANSPARENT_HUGEPAGE_MADVISE=y # Comment out CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS=y</code> </pre> </li></ul><br><h1 id="chast-2-preimuschestva-i-nedostatki-hugepages">  Teil 2: Vor- und Nachteile von HugePages </h1><br><p>  Wir werden versuchen, die Vor- und Nachteile und m√∂glichen Fehler bei der Verwendung von Hugepages selektiv zu erkl√§ren.  Da der technologisch anspruchsvolle und pedantische Artikel f√ºr Menschen, die get√§uscht werden, weil sie Hugepages als Allheilmittel betrachten, wahrscheinlich schwierig ist, werde ich der Einfachheit halber auf Genauigkeit verzichten.  Es ist nur zu bedenken, dass viele Themen sehr komplex und daher stark vereinfacht sind. </p><br><p>  Bitte beachten Sie, dass es sich um 64-Bit-x86-Systeme handelt, die unter Linux ausgef√ºhrt werden, und dass ich nur davon ausgehe, dass das System transparente riesige Seiten unterst√ºtzt (da es kein Nachteil ist, dass riesige Seiten nicht ersetzt werden), wie dies bei fast allen modernen Systemen der Fall ist Linux-Umgebung. </p><br><p>  <em>In den unten stehenden Links werde ich eine weitere technische Beschreibung anh√§ngen.</em> </p><br><h4 id="virtualnaya-pamyat">  Virtueller Speicher </h4><br><p>  Wenn Sie ein C ++ - Programmierer sind, wissen Sie, dass Objekte im Speicher bestimmte Adressen (Zeigerwerte) haben. </p><br><p>  Diese Adressen spiegeln jedoch nicht unbedingt die physischen Adressen im Speicher (Adressen im RAM) wider.  Sie sind Adressen im virtuellen Speicher.  Der Prozessor verf√ºgt √ºber ein spezielles MMU-Modul (Memory Management Unit), mit dessen Hilfe der Kernel den virtuellen Speicher einem physischen Standort zuordnen kann. </p><br><p>  Dieser Ansatz hat viele Vorteile, aber die grundlegendsten: </p><br><ul><li>  Leistung (aus verschiedenen Gr√ºnden); </li><li>  Isolierung von Programmen, dh keines der Programme kann aus dem Speicher eines anderen Programms lesen. </li></ul><br><h4 id="chto-takoe-stranicy">  Was sind Seiten? </h4><br><p>  Der virtuelle Speicher ist in Seiten unterteilt.  Jede einzelne Seite verweist auf einen bestimmten physischen Speicher, kann auf einen Bereich im RAM verweisen oder auf eine Adresse, die einem physischen Ger√§t wie einer Grafikkarte zugewiesen ist. </p><br><p>  Die meisten Seiten, mit denen Sie sich befassen, verweisen entweder auf RAM oder Swap, dh sie werden auf Ihrer Festplatte oder SSD gespeichert.  Der Kernel steuert das physische Layout jeder Seite.  Wenn auf eine gef√§lschte Seite zugegriffen wird, stoppt der Kernel den Thread, der versucht, auf den Speicher zuzugreifen, liest die Seite von der Festplatte / SSD in den RAM und f√ºhrt den Thread dann weiter aus. </p><br><p>  Dieser Prozess ist f√ºr den Stream transparent, dh er liest nicht unbedingt direkt von der Festplatte / SSD.  Die Gr√∂√üe normaler Seiten betr√§gt 4096 Byte.  Riesenseiten sind 2 Megabyte gro√ü. </p><br><h4 id="bufer-associativnoy-translyacii-tlb">  Assoziativer √úbersetzungspuffer (TLB) </h4><br><p>  Wenn ein Programm auf eine Speicherseite zugreift, muss der Zentralprozessor wissen, von welcher physischen Seite Daten gelesen werden sollen (d. H. Eine virtuelle Adresszuordnung haben). </p><br><p>  Der Kern hat eine Datenstruktur (Seitentabelle), die alle Informationen zu den verwendeten Seiten enth√§lt.  Mit dieser Datenstruktur k√∂nnen Sie eine virtuelle Adresse einer physischen Adresse zuordnen. </p><br><p>  Die Seitentabelle ist jedoch ziemlich komplex und l√§uft langsam, sodass wir nicht jedes Mal, wenn ein Prozess auf den Speicher zugreift, die gesamte Datenstruktur analysieren k√∂nnen. </p><br><p>  Gl√ºcklicherweise verf√ºgt unser Prozessor √ºber einen TLB, der die Zuordnung von virtuellen und physischen Adressen zwischenspeichert.  Dies bedeutet, dass trotz der Tatsache, dass wir die Seitentabelle beim ersten Versuch, Zugriff zu erhalten, analysieren m√ºssen, alle nachfolgenden Seitenaufrufe im TLB verarbeitet werden k√∂nnen, was einen schnellen Betrieb gew√§hrleistet. </p><br><p>  Da es als physisches Ger√§t implementiert ist (was es haupts√§chlich schnell macht), ist seine Kapazit√§t begrenzt.  Wenn Sie auf mehr Seiten zugreifen m√∂chten, kann TLB die Zuordnung daher nicht f√ºr alle Seiten speichern, wodurch Ihr Programm viel langsamer arbeitet. </p><br><h4 id="hugepages-prihodyat-na-pomosch">  Riesenseiten kommen zur Rettung </h4><br><p>  Was k√∂nnen wir also tun, um einen TLB-√úberlauf zu vermeiden?  (Wir gehen davon aus, dass das Programm immer noch dieselbe Speichermenge ben√∂tigt). </p><br><p>  Hier erscheinen die Hugepages.  Anstelle von 4096 Bytes, f√ºr die nur ein Eintrag im TLB erforderlich ist, kann ein Eintrag im TLB jetzt auf satte 2 Megabyte verweisen.  Wir gehen davon aus, dass der TLB 512 Eintr√§ge hat, hier ohne riesige Seiten k√∂nnen wir √ºbereinstimmen: </p><br><pre> <code class="plaintext hljs">4096 b‚ãÖ512=2 MB</code> </pre> <br><p>  Mit ihnen k√∂nnen wir vergleichen: </p><br><pre> <code class="plaintext hljs">2 MB‚ãÖ512=1 GB</code> </pre> <br><p>  Deshalb ist Hugepages gro√üartig.  Sie k√∂nnen die Produktivit√§t ohne erheblichen Aufwand steigern.  Es gibt jedoch erhebliche Vorbehalte. </p><br><h4 id="podmena-hugepages">  Riesige Spoofing-Seiten </h4><br><p>  Der Kernel verfolgt automatisch die Nutzungsh√§ufigkeit jeder Speicherseite.  Wenn der physische Speicher (RAM) nicht ausreicht, verschiebt der Kernel die weniger wichtigen (weniger h√§ufig verwendeten) Seiten auf die Festplatte, um einen Teil des RAM f√ºr wichtigere Seiten freizugeben. <br>  Grunds√§tzlich gilt das Gleiche f√ºr Hugepages.  Der Kernel kann jedoch nur ganze Seiten austauschen, nicht einzelne Bytes. </p><br><p>  Angenommen, wir haben ein Programm wie dieses: </p><br><pre> <code class="plaintext hljs">char* mymemory = malloc(2*1024*1024); //     Hugepage! //  mymemory -  //    , //      mymemory // ... //       putchar(mymemory[0]);</code> </pre> <br><p>  In diesem Fall muss der Kernel bis zu 2 Megabyte an Informationen von der Festplatte / SSD ersetzen (lesen), damit Sie ein Byte lesen k√∂nnen.  Wie bei normalen Seiten m√ºssen nur 4096 Bytes von der Festplatte / SSD gelesen werden. </p><br><p>  Wenn eine gro√üe Seite ersetzt wird, ist das Lesen daher nur dann schneller, wenn Sie auf die gesamte Seite zugreifen m√ºssen.  Dies bedeutet, dass Sie, wenn Sie versuchen, zuf√§llig auf verschiedene Teile des Speichers zuzugreifen und nur ein paar Kilobyte zu lesen, normale Seiten verwenden und sich um nichts anderes k√ºmmern sollten. </p><br><p>  Wenn Sie jedoch nacheinander auf den gr√∂√üten Teil des Speichers zugreifen m√ºssen, erh√∂hen riesige Seiten Ihre Produktivit√§t.  Sie m√ºssen dies jedoch selbst √ºberpr√ºfen (und nicht am Beispiel einer abstrakten Software) und feststellen, was schneller funktioniert. </p><br><h4 id="allokaciya-v-pamyati">  Speicherzuordnung </h4><br><p>  Wenn Sie in C schreiben, wissen Sie, dass Sie mit <code>malloc()</code> beliebig kleine (oder fast beliebig gro√üe) Speichermengen vom Heap anfordern k√∂nnen.  Angenommen, Sie ben√∂tigen 30 Byte Speicher: </p><br><pre> <code class="plaintext hljs">char* mymemory = malloc(30);</code> </pre> <br><p>  Dem Programmierer scheint es, als w√ºrden Sie 30 Byte Speicher vom Betriebssystem "anfordern" und einen Zeiger auf einen virtuellen Speicher zur√ºckgeben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tats√§chlich</a> ist <code>malloc ()</code> jedoch nur eine C-Funktion, die die Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">brk und sbrk</a> von innen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufruft,</a> um Speicher vom Betriebssystem anzufordern oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">freizugeben</a> . </p><br><p>  Das Anfordern von immer mehr Speicher f√ºr jede Zuordnung ist jedoch ineffizient.  Es ist sehr wahrscheinlich, dass ein Speichersegment bereits freigegeben wurde <code>(free())</code> , und wir k√∂nnen es wiederverwenden.  <code>malloc()</code> implementiert ziemlich komplexe Algorithmen zur Wiederverwendung von freigegebenem Speicher. </p><br><p>  Gleichzeitig passiert f√ºr Sie alles unbemerkt. Warum sollte es Sie also betreffen?  Da der Aufruf von <code>free()</code> jedoch nicht bedeutet, dass der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicher sofort an das Betriebssystem zur√ºckgegeben wird</a> . </p><br><p>  Es gibt so etwas wie Speicherfragmentierung.  In extremen F√§llen gibt es Heap-Segmente, in denen nur wenige Bytes verwendet werden, w√§hrend alles dazwischen freigegeben wurde <code>(free())</code> . </p><br><p>  Beachten Sie, dass die Speicherfragmentierung ein unglaublich komplexes Thema ist und selbst geringf√ºgige √Ñnderungen am Programm erhebliche Auswirkungen haben k√∂nnen.  In den meisten F√§llen verursachen Programme keine signifikante Speicherfragmentierung. Beachten Sie jedoch, dass gro√üe Seiten die Situation nur verschlimmern k√∂nnen, wenn in einem bestimmten Bereich des Heapspeichers eine Fragmentierung auftritt. </p><br><h4 id="vyborochnoe-primenenie-hugepages">  Benutzerdefinierte Anwendung von riesigen Seiten </h4><br><p>  Nach dem Lesen des Artikels haben Sie festgestellt, welche Teile Ihres Programms von der Verwendung gro√üer Seiten profitieren k√∂nnen und welche nicht.  Sollten also √ºberhaupt riesige Seiten enthalten sein? </p><br><p>  Gl√ºcklicherweise k√∂nnen Sie <code>madvise()</code> , um Riesenseiten nur f√ºr Speicherbereiche zu aktivieren, in denen dies n√ºtzlich ist. </p><br><p>  Stellen Sie zun√§chst sicher, dass riesige Seiten im madvise () -Modus funktionieren. Befolgen Sie dazu die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anweisungen</a> am Anfang des Artikels. </p><br><p>  Verwenden Sie dann <code>madvise()</code> , um dem Kernel genau mitzuteilen, wo riesige Seiten verwendet werden sollen. </p><br><pre> <code class="plaintext hljs">#include &lt;sys/mman.h&gt; //    ,    size_t size = 256*1024*1024; char* mymemory = malloc(size); //   hugepages‚Ä¶ madvise(mymemory, size, MADV_HUGEPAGE); // ‚Ä¶    madvise(mymemory, size, MADV_HUGEPAGE | MADV_SEQUENTIAL)</code> </pre> <br><p>  Beachten Sie, dass diese Methode nur eine Empfehlung an den Kernel f√ºr die Speicherverwaltung ist.  Dies bedeutet nicht, dass der Kernel automatisch riesige Seiten f√ºr den angegebenen Speicher verwendet. </p><br><p>  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen</a> zur Speicherverwaltung und zu <code>madvise()</code> , einer unglaublich steilen Lernkurve f√ºr dieses Thema, finden Sie auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">madvise-Manpage</a> .  Wenn Sie es wirklich gut verstehen m√∂chten, machen Sie sich bereit, es einige Wochen lang zu lesen und zu testen, bevor Sie mit mindestens einem positiven Ergebnis rechnen. </p><br><p>  <strong>Was zu lesen?</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBM OpenStack-Artikel auf riesigen Seiten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transparente Riesenseiten gegen nicht transparente Riesenseiten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia-Artikel √ºber TLB</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux-Kerneldokumentation auf transparenten riesigen Seiten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stapel√ºberlauf: Riesenseiten sind anf√§llig f√ºr Speicherfragmentierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft Virtual Memory Management-Artikel</a> </li></ul><br><hr><br><p>  <em>Hast du eine Frage?</em>  <em>Schreiben Sie in die Kommentare!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460403/">https://habr.com/ru/post/de460403/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460387/index.html">SELinux Anf√§ngerleitfaden</a></li>
<li><a href="../de460393/index.html">Hintergrund: Was erwartet Sie von Fedora Silverblue?</a></li>
<li><a href="../de460395/index.html">Analytics als Feature: Der Prozess der Arbeit mit Daten in Plesk</a></li>
<li><a href="../de460397/index.html">Schnellstart mit WebComponents</a></li>
<li><a href="../de460399/index.html">SVG-Ladeanzeige auf Vue.js.</a></li>
<li><a href="../de460405/index.html">Warum brauchst du versteckte Spielmechaniken?</a></li>
<li><a href="../de460409/index.html">Arduino und Keyboards (vollst√§ndige Anleitung)</a></li>
<li><a href="../de460411/index.html">Mad Converter GIF'ok zu animierten Aufklebern f√ºr Telegramm</a></li>
<li><a href="../de460413/index.html">7 n√ºtzliche Websites und Anwendungen zum Lernen von Englisch</a></li>
<li><a href="../de460415/index.html">Apple Watch 4 (44 mm, 2019) gegen Pebble Steel Classic (2014)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>