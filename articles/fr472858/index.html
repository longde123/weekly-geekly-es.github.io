<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏾 💽 👩‍❤️‍👨 Clients Python et HTTP rapides 🛐 ⚖️ 👈🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nos jours, si vous écrivez une sorte d'application Python, vous devrez très probablement l'équiper des fonctionnalités d'un client HTTP capable de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Clients Python et HTTP rapides</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472858/">  De nos jours, si vous écrivez une sorte d'application Python, vous devrez très probablement l'équiper des fonctionnalités d'un client HTTP capable de communiquer avec les serveurs HTTP.  L'omniprésence de l'API REST a fait des outils HTTP une fonctionnalité respectée dans d'innombrables projets logiciels.  C'est pourquoi tout programmeur doit posséder des modèles visant à organiser un travail optimal avec des connexions HTTP. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/fv/ix/xt/fvixxt-a-wwkrs5vivurfucn5pe.jpeg"></a> <br><br>  Il existe de nombreux clients HTTP pour Python.  Les plus courantes d'entre elles, et d'ailleurs celle avec laquelle il est facile de travailler, peuvent être appelées <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">requêtes</a> .  Aujourd'hui, ce client est la norme de facto. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Connexions permanentes</font> </h2><br>  La première optimisation à considérer lors de l'utilisation de HTTP est d'utiliser des connexions persistantes aux serveurs Web.  Les connexions persistantes sont devenues standard depuis HTTP 1.1, mais de nombreuses applications ne les utilisent toujours pas.  Cette faille est facile à expliquer, sachant que lors de l'utilisation de la bibliothèque de <code>requests</code> en mode simple (par exemple, en utilisant sa méthode <code>get</code> ), la connexion au serveur est fermée après avoir reçu une réponse de sa part.  Pour éviter cela, l'application doit utiliser l'objet <code>Session</code> , qui permet de réutiliser les connexions ouvertes: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() session.get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    session.get("http://example.com")</span></span></code> </pre> <br>  Les connexions sont stockées dans le pool de connexions (il s'agit par défaut de 10 connexions par défaut).  La taille de la piscine peut être personnalisée: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() adapter = requests.adapters.HTTPAdapter(    pool_connections=<span class="hljs-number"><span class="hljs-number">100</span></span>,    pool_maxsize=<span class="hljs-number"><span class="hljs-number">100</span></span>) session.mount(<span class="hljs-string"><span class="hljs-string">'http://'</span></span>, adapter) response = session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)</code> </pre> <br>  La réutilisation d'une connexion TCP pour envoyer plusieurs requêtes HTTP confère à l'application de nombreux avantages en termes de performances: <br><br><ul><li>  Réduire la charge sur le processeur et réduire le besoin de RAM (en raison du fait que moins de connexions s'ouvrent en même temps). </li><li>  Réduction des retards lors de l'exécution des requêtes les unes après les autres (il n'y a pas de procédure d'établissement de liaison TCP). </li><li>  Des exceptions peuvent être levées sans délai supplémentaire pour fermer la connexion TCP. </li></ul><br>  HTTP 1.1 prend également en charge le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traitement en pipeline</a> des demandes.  Cela vous permet d'envoyer plusieurs demandes au sein de la même connexion sans attendre les réponses aux demandes précédemment envoyées (c'est-à-dire, envoyer des demandes en "paquets").  Malheureusement, la bibliothèque de <code>requests</code> ne prend pas en charge cette fonctionnalité.  Cependant, les demandes de pipelining peuvent ne pas être aussi rapides que leur traitement en parallèle.  Et, en outre, il convient de prêter attention à cela: les réponses aux demandes de «paquets» doivent être envoyées par le serveur dans le même ordre dans lequel il a reçu ces demandes.  Le résultat n'est pas le schéma de traitement des demandes le plus efficace basé sur le principe FIFO («premier entré, premier sorti» - «premier arrivé, premier laissé»). <br><br><h2>  <font color="#3AC1EF">Traitement parallèle des requêtes</font> </h2><br>  <code>requests</code> présentent également un autre inconvénient sérieux.  Il s'agit d'une bibliothèque synchrone.  Un appel de méthode tel que <code>requests.get("http://example.org")</code> bloque le programme jusqu'à ce qu'une réponse complète du serveur HTTP soit reçue.  Le fait que l'application doive attendre et ne rien faire peut être considéré comme un inconvénient de ce schéma d'organisation de l'interaction avec le serveur.  Est-il possible de faire faire au programme quelque chose d'utile au lieu d'attendre simplement? <br><br>  Une application intelligemment conçue peut atténuer ce problème en utilisant un pool de threads, similaire à ceux fournis par <code>concurrent.futures</code> .  Cela vous permet de paralléliser rapidement les requêtes HTTP: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> futures.ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> executor:    futures = [        executor.submit(            <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: requests.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>))        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)    ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Ce modèle très utile est implémenté dans la bibliothèque de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">requêtes-futures</a> .  Dans le même temps, l'utilisation des objets <code>Session</code> est transparente pour le développeur: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions session = sessions.FuturesSession() futures = [    session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>) ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Par défaut, un travailleur avec deux threads est créé, mais le programme peut facilement définir cette valeur en passant l'argument <code>FuturSession</code> ou même son propre exécuteur à l'objet <code>FuturSession</code> .  Par exemple, cela pourrait ressembler à ceci: <br><br><pre> <code class="python hljs">FuturesSession(executor=ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">10</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">Travail asynchrone avec requêtes</font> </h2><br>  Comme déjà mentionné, la bibliothèque de <code>requests</code> est complètement synchrone.  Cela conduit au blocage des applications en attendant une réponse du serveur, ce qui affecte mal les performances.  Une solution à ce problème consiste à exécuter des requêtes HTTP dans des threads séparés.  Mais l'utilisation de threads est une charge supplémentaire sur le système.  De plus, cela signifie l'introduction d'un schéma parallèle de traitement des données dans le programme, qui ne convient pas à tout le monde. <br><br>  À partir de Python 3.5, les fonctionnalités de langage standard incluent la programmation asynchrone utilisant <code>asyncio</code> .  La bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://aio">aiohttp</a> fournit au développeur un client HTTP asynchrone basé sur <code>asyncio</code> .  Cette bibliothèque permet à l'application d'envoyer une série de demandes et de continuer à fonctionner.  Dans le même temps, pour envoyer une autre demande, vous n'avez pas besoin d'attendre une réponse à une demande envoyée précédemment.  Contrairement au pipelining des requêtes HTTP, <code>aiohttp</code> envoie des requêtes en parallèle en utilisant plusieurs connexions.  Cela évite le «problème FIFO» décrit ci-dessus.  Voici à <code>aiohttp</code> ressemble <code>aiohttp</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response loop = asyncio.get_event_loop() coroutines = [get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)] results = loop.run_until_complete(asyncio.gather(*coroutines)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Toutes les approches décrites ci-dessus (en utilisant <code>Session</code> , streams, <code>concurrent.futures</code> ou <code>asyncio</code> ) offrent différentes façons d'accélérer les clients HTTP. <br><br><h2>  <font color="#3AC1EF">Performances</font> </h2><br>  Le code suivant est un exemple dans lequel le client HTTP envoie des requêtes au serveur <code>httpbin.org</code> .  Le serveur prend en charge une API qui peut, entre autres, simuler un système qui met longtemps à répondre à une demande (dans ce cas, c'est 1 seconde).  Ici, toutes les techniques discutées ci-dessus sont mises en œuvre et leurs performances sont mesurées: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> contextlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions URL = <span class="hljs-string"><span class="hljs-string">"http://httpbin.org/delay/1"</span></span> TRIES = <span class="hljs-number"><span class="hljs-number">10</span></span> @contextlib.contextmanager <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report_time</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(test)</span></span></span><span class="hljs-function">:</span></span>    t0 = time.time()    <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>    print(<span class="hljs-string"><span class="hljs-string">"Time needed for `%s' called: %.2fs"</span></span>          % (test, time.time() - t0)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"serialized"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        requests.get(URL) session = requests.Session() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"Session"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        session.get(URL) session = sessions.FuturesSession(max_workers=<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ 2 workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() session = sessions.FuturesSession(max_workers=TRIES) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ max workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.read() loop = asyncio.get_event_loop() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"aiohttp"</span></span>):    loop.run_until_complete(        asyncio.gather(*[get(URL)                         <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]))</code> </pre> <br>  Voici les résultats obtenus après le démarrage de ce programme: <br><br><pre> <code class="python hljs">Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `serialized<span class="hljs-string"><span class="hljs-string">' called: 12.12s Time needed for `Session'</span></span> called: <span class="hljs-number"><span class="hljs-number">11.22</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `FuturesSession w/ <span class="hljs-number"><span class="hljs-number">2</span></span> workers<span class="hljs-string"><span class="hljs-string">' called: 5.65s Time needed for `FuturesSession w/ max workers'</span></span> called: <span class="hljs-number"><span class="hljs-number">1.25</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `aiohttp<span class="hljs-string"><span class="hljs-string">' called: 1.19s</span></span></code> </pre> <br>  Voici un tableau des résultats. <br><img src="https://habrastorage.org/getpro/habr/post_images/c84/655/e65/c84655e655fc6d400a4ffd2d932aaa61.png"><br>  <i><font color="#999999">Les résultats d'une étude des performances de différentes méthodes pour effectuer des requêtes HTTP</font></i> <br><br>  Il n'est pas surprenant que le schéma d'exécution de requête synchrone le plus simple se soit avéré le plus lent.  Le point ici est qu'ici les requêtes sont exécutées une par une, sans réutiliser la connexion.  Par conséquent, il faut 12 secondes pour terminer 10 requêtes. <br><br>  L'utilisation de l'objet <code>Session</code> et, par conséquent, la réutilisation des connexions, économise 8% du temps.  C'est déjà très bien, et pour y parvenir, c'est très simple.  Quiconque se soucie des performances doit utiliser au moins l'objet <code>Session</code> . <br><br>  Si votre système et votre programme vous permettent de travailler avec des threads, c'est une bonne raison de penser à utiliser des threads pour paralléliser les requêtes.  Cependant, les flux créent une charge supplémentaire sur le système, ils ne sont pour ainsi dire pas «gratuits».  Ils doivent être créés, exécutés, vous devez attendre la fin de leur travail. <br><br>  Si vous souhaitez utiliser le client HTTP asynchrone rapide, alors si vous <code>aiohttp</code> pas sur des versions plus anciennes de Python, vous devriez porter la plus grande attention à <code>aiohttp</code> .  Il s'agit de la solution la plus rapide, la plus évolutive.  Il est capable de gérer des centaines de demandes simultanées. <br><br>  Une alternative à <code>aiohttp</code> , pas une alternative particulièrement bonne est de gérer des centaines de threads en parallèle. <br><br><h2>  <font color="#3AC1EF">Traitement des données en continu</font> </h2><br>  Une autre optimisation du travail avec les ressources réseau, qui peut être utile en termes d'amélioration des performances des applications, consiste à utiliser des données en streaming.  Le schéma de traitement des demandes standard ressemble à ceci: l'application envoie une demande, après quoi le corps de cette demande est chargé en une seule fois.  Le paramètre <code>stream</code> , qui prend en charge la bibliothèque de <code>requests</code> , ainsi que l'attribut <code>content</code> de la bibliothèque <code>aiohttp</code> , vous permet de vous éloigner de ce schéma. <br><br>  Voici à quoi ressemble l'organisation du traitement de données en continu à l'aide de <code>requests</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-comment"><span class="hljs-comment">#  `with`          #     . with requests.get('http://example.org', stream=True) as r:    print(list(r.iter_content()))</span></span></code> </pre> <br>  Voici comment diffuser des données en utilisant <code>aiohttp</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.content.read() loop = asyncio.get_event_loop() tasks = [asyncio.ensure_future(get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>))] loop.run_until_complete(asyncio.wait(tasks)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % [task.result() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> task <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tasks])</code> </pre> <br>  L'élimination de la nécessité de charger instantanément le contenu de la réponse complète est importante dans les cas où vous devez éviter la possibilité potentielle d'allocation inutile de centaines de mégaoctets de mémoire.  Si le programme n'a pas besoin d'accéder à la réponse dans son ensemble, s'il peut fonctionner avec des fragments individuels de la réponse, alors il est probablement préférable de recourir à des méthodes de diffusion en continu avec des requêtes.  Par exemple, si vous souhaitez enregistrer des données de la réponse du serveur à un fichier, la lecture et l'écriture partielles seront beaucoup plus efficaces en termes d'utilisation de la mémoire que la lecture de l'ensemble du corps de la réponse, allouant une énorme quantité de mémoire puis écrivant le tout sur le disque. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  J'espère que mon exposé sur les différentes façons d'optimiser le fonctionnement des clients HTTP vous aidera à choisir ce qui convient le mieux à votre application Python. <br><br>  <b>Chers lecteurs!</b>  Si vous connaissez encore d'autres moyens d'optimiser le travail avec les requêtes HTTP dans les applications Python, veuillez les partager. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472858/">https://habr.com/ru/post/fr472858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472840/index.html">Stockage défini par logiciel, ou qu'est-ce qui a tué les dinosaures?</a></li>
<li><a href="../fr472848/index.html">Réflexions sur une carrière en informatique</a></li>
<li><a href="../fr472850/index.html">Profession ou vie: gagnez un cours de netologie si vous n'avez pas peur</a></li>
<li><a href="../fr472854/index.html">Profilage UI Unity: qui gâche mon lot?</a></li>
<li><a href="../fr472856/index.html">Comment j'ai créé un service de contrôle qualité à partir de tables et de bâtons</a></li>
<li><a href="../fr472860/index.html">Invalidation du cache en cascade. Partie 1</a></li>
<li><a href="../fr472862/index.html">Invalidation du cache en cascade. 2e partie</a></li>
<li><a href="../fr472864/index.html">Check Point: optimisation CPU et RAM</a></li>
<li><a href="../fr472866/index.html">Talisman pour une communication stable</a></li>
<li><a href="../fr472868/index.html">Gestion du serveur téléphonique: client mobile RUVDS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>