<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèæ üíΩ üë©‚Äç‚ù§Ô∏è‚Äçüë® Clients Python et HTTP rapides üõê ‚öñÔ∏è üëàüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nos jours, si vous √©crivez une sorte d'application Python, vous devrez tr√®s probablement l'√©quiper des fonctionnalit√©s d'un client HTTP capable de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Clients Python et HTTP rapides</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472858/">  De nos jours, si vous √©crivez une sorte d'application Python, vous devrez tr√®s probablement l'√©quiper des fonctionnalit√©s d'un client HTTP capable de communiquer avec les serveurs HTTP.  L'omnipr√©sence de l'API REST a fait des outils HTTP une fonctionnalit√© respect√©e dans d'innombrables projets logiciels.  C'est pourquoi tout programmeur doit poss√©der des mod√®les visant √† organiser un travail optimal avec des connexions HTTP. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/fv/ix/xt/fvixxt-a-wwkrs5vivurfucn5pe.jpeg"></a> <br><br>  Il existe de nombreux clients HTTP pour Python.  Les plus courantes d'entre elles, et d'ailleurs celle avec laquelle il est facile de travailler, peuvent √™tre appel√©es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">requ√™tes</a> .  Aujourd'hui, ce client est la norme de facto. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Connexions permanentes</font> </h2><br>  La premi√®re optimisation √† consid√©rer lors de l'utilisation de HTTP est d'utiliser des connexions persistantes aux serveurs Web.  Les connexions persistantes sont devenues standard depuis HTTP 1.1, mais de nombreuses applications ne les utilisent toujours pas.  Cette faille est facile √† expliquer, sachant que lors de l'utilisation de la biblioth√®que de <code>requests</code> en mode simple (par exemple, en utilisant sa m√©thode <code>get</code> ), la connexion au serveur est ferm√©e apr√®s avoir re√ßu une r√©ponse de sa part.  Pour √©viter cela, l'application doit utiliser l'objet <code>Session</code> , qui permet de r√©utiliser les connexions ouvertes: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() session.get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    session.get("http://example.com")</span></span></code> </pre> <br>  Les connexions sont stock√©es dans le pool de connexions (il s'agit par d√©faut de 10 connexions par d√©faut).  La taille de la piscine peut √™tre personnalis√©e: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() adapter = requests.adapters.HTTPAdapter(    pool_connections=<span class="hljs-number"><span class="hljs-number">100</span></span>,    pool_maxsize=<span class="hljs-number"><span class="hljs-number">100</span></span>) session.mount(<span class="hljs-string"><span class="hljs-string">'http://'</span></span>, adapter) response = session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)</code> </pre> <br>  La r√©utilisation d'une connexion TCP pour envoyer plusieurs requ√™tes HTTP conf√®re √† l'application de nombreux avantages en termes de performances: <br><br><ul><li>  R√©duire la charge sur le processeur et r√©duire le besoin de RAM (en raison du fait que moins de connexions s'ouvrent en m√™me temps). </li><li>  R√©duction des retards lors de l'ex√©cution des requ√™tes les unes apr√®s les autres (il n'y a pas de proc√©dure d'√©tablissement de liaison TCP). </li><li>  Des exceptions peuvent √™tre lev√©es sans d√©lai suppl√©mentaire pour fermer la connexion TCP. </li></ul><br>  HTTP 1.1 prend √©galement en charge le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traitement en pipeline</a> des demandes.  Cela vous permet d'envoyer plusieurs demandes au sein de la m√™me connexion sans attendre les r√©ponses aux demandes pr√©c√©demment envoy√©es (c'est-√†-dire, envoyer des demandes en "paquets").  Malheureusement, la biblioth√®que de <code>requests</code> ne prend pas en charge cette fonctionnalit√©.  Cependant, les demandes de pipelining peuvent ne pas √™tre aussi rapides que leur traitement en parall√®le.  Et, en outre, il convient de pr√™ter attention √† cela: les r√©ponses aux demandes de ¬´paquets¬ª doivent √™tre envoy√©es par le serveur dans le m√™me ordre dans lequel il a re√ßu ces demandes.  Le r√©sultat n'est pas le sch√©ma de traitement des demandes le plus efficace bas√© sur le principe FIFO (¬´premier entr√©, premier sorti¬ª - ¬´premier arriv√©, premier laiss√©¬ª). <br><br><h2>  <font color="#3AC1EF">Traitement parall√®le des requ√™tes</font> </h2><br>  <code>requests</code> pr√©sentent √©galement un autre inconv√©nient s√©rieux.  Il s'agit d'une biblioth√®que synchrone.  Un appel de m√©thode tel que <code>requests.get("http://example.org")</code> bloque le programme jusqu'√† ce qu'une r√©ponse compl√®te du serveur HTTP soit re√ßue.  Le fait que l'application doive attendre et ne rien faire peut √™tre consid√©r√© comme un inconv√©nient de ce sch√©ma d'organisation de l'interaction avec le serveur.  Est-il possible de faire faire au programme quelque chose d'utile au lieu d'attendre simplement? <br><br>  Une application intelligemment con√ßue peut att√©nuer ce probl√®me en utilisant un pool de threads, similaire √† ceux fournis par <code>concurrent.futures</code> .  Cela vous permet de parall√©liser rapidement les requ√™tes HTTP: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> futures.ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> executor:    futures = [        executor.submit(            <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: requests.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>))        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)    ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Ce mod√®le tr√®s utile est impl√©ment√© dans la biblioth√®que de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">requ√™tes-futures</a> .  Dans le m√™me temps, l'utilisation des objets <code>Session</code> est transparente pour le d√©veloppeur: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions session = sessions.FuturesSession() futures = [    session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>) ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Par d√©faut, un travailleur avec deux threads est cr√©√©, mais le programme peut facilement d√©finir cette valeur en passant l'argument <code>FuturSession</code> ou m√™me son propre ex√©cuteur √† l'objet <code>FuturSession</code> .  Par exemple, cela pourrait ressembler √† ceci: <br><br><pre> <code class="python hljs">FuturesSession(executor=ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">10</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">Travail asynchrone avec requ√™tes</font> </h2><br>  Comme d√©j√† mentionn√©, la biblioth√®que de <code>requests</code> est compl√®tement synchrone.  Cela conduit au blocage des applications en attendant une r√©ponse du serveur, ce qui affecte mal les performances.  Une solution √† ce probl√®me consiste √† ex√©cuter des requ√™tes HTTP dans des threads s√©par√©s.  Mais l'utilisation de threads est une charge suppl√©mentaire sur le syst√®me.  De plus, cela signifie l'introduction d'un sch√©ma parall√®le de traitement des donn√©es dans le programme, qui ne convient pas √† tout le monde. <br><br>  √Ä partir de Python 3.5, les fonctionnalit√©s de langage standard incluent la programmation asynchrone utilisant <code>asyncio</code> .  La biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://aio">aiohttp</a> fournit au d√©veloppeur un client HTTP asynchrone bas√© sur <code>asyncio</code> .  Cette biblioth√®que permet √† l'application d'envoyer une s√©rie de demandes et de continuer √† fonctionner.  Dans le m√™me temps, pour envoyer une autre demande, vous n'avez pas besoin d'attendre une r√©ponse √† une demande envoy√©e pr√©c√©demment.  Contrairement au pipelining des requ√™tes HTTP, <code>aiohttp</code> envoie des requ√™tes en parall√®le en utilisant plusieurs connexions.  Cela √©vite le ¬´probl√®me FIFO¬ª d√©crit ci-dessus.  Voici √† <code>aiohttp</code> ressemble <code>aiohttp</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response loop = asyncio.get_event_loop() coroutines = [get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)] results = loop.run_until_complete(asyncio.gather(*coroutines)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Toutes les approches d√©crites ci-dessus (en utilisant <code>Session</code> , streams, <code>concurrent.futures</code> ou <code>asyncio</code> ) offrent diff√©rentes fa√ßons d'acc√©l√©rer les clients HTTP. <br><br><h2>  <font color="#3AC1EF">Performances</font> </h2><br>  Le code suivant est un exemple dans lequel le client HTTP envoie des requ√™tes au serveur <code>httpbin.org</code> .  Le serveur prend en charge une API qui peut, entre autres, simuler un syst√®me qui met longtemps √† r√©pondre √† une demande (dans ce cas, c'est 1 seconde).  Ici, toutes les techniques discut√©es ci-dessus sont mises en ≈ìuvre et leurs performances sont mesur√©es: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> contextlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions URL = <span class="hljs-string"><span class="hljs-string">"http://httpbin.org/delay/1"</span></span> TRIES = <span class="hljs-number"><span class="hljs-number">10</span></span> @contextlib.contextmanager <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report_time</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(test)</span></span></span><span class="hljs-function">:</span></span>    t0 = time.time()    <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>    print(<span class="hljs-string"><span class="hljs-string">"Time needed for `%s' called: %.2fs"</span></span>          % (test, time.time() - t0)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"serialized"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        requests.get(URL) session = requests.Session() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"Session"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        session.get(URL) session = sessions.FuturesSession(max_workers=<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ 2 workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() session = sessions.FuturesSession(max_workers=TRIES) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ max workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.read() loop = asyncio.get_event_loop() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"aiohttp"</span></span>):    loop.run_until_complete(        asyncio.gather(*[get(URL)                         <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]))</code> </pre> <br>  Voici les r√©sultats obtenus apr√®s le d√©marrage de ce programme: <br><br><pre> <code class="python hljs">Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `serialized<span class="hljs-string"><span class="hljs-string">' called: 12.12s Time needed for `Session'</span></span> called: <span class="hljs-number"><span class="hljs-number">11.22</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `FuturesSession w/ <span class="hljs-number"><span class="hljs-number">2</span></span> workers<span class="hljs-string"><span class="hljs-string">' called: 5.65s Time needed for `FuturesSession w/ max workers'</span></span> called: <span class="hljs-number"><span class="hljs-number">1.25</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `aiohttp<span class="hljs-string"><span class="hljs-string">' called: 1.19s</span></span></code> </pre> <br>  Voici un tableau des r√©sultats. <br><img src="https://habrastorage.org/getpro/habr/post_images/c84/655/e65/c84655e655fc6d400a4ffd2d932aaa61.png"><br>  <i><font color="#999999">Les r√©sultats d'une √©tude des performances de diff√©rentes m√©thodes pour effectuer des requ√™tes HTTP</font></i> <br><br>  Il n'est pas surprenant que le sch√©ma d'ex√©cution de requ√™te synchrone le plus simple se soit av√©r√© le plus lent.  Le point ici est qu'ici les requ√™tes sont ex√©cut√©es une par une, sans r√©utiliser la connexion.  Par cons√©quent, il faut 12 secondes pour terminer 10 requ√™tes. <br><br>  L'utilisation de l'objet <code>Session</code> et, par cons√©quent, la r√©utilisation des connexions, √©conomise 8% du temps.  C'est d√©j√† tr√®s bien, et pour y parvenir, c'est tr√®s simple.  Quiconque se soucie des performances doit utiliser au moins l'objet <code>Session</code> . <br><br>  Si votre syst√®me et votre programme vous permettent de travailler avec des threads, c'est une bonne raison de penser √† utiliser des threads pour parall√©liser les requ√™tes.  Cependant, les flux cr√©ent une charge suppl√©mentaire sur le syst√®me, ils ne sont pour ainsi dire pas ¬´gratuits¬ª.  Ils doivent √™tre cr√©√©s, ex√©cut√©s, vous devez attendre la fin de leur travail. <br><br>  Si vous souhaitez utiliser le client HTTP asynchrone rapide, alors si vous <code>aiohttp</code> pas sur des versions plus anciennes de Python, vous devriez porter la plus grande attention √† <code>aiohttp</code> .  Il s'agit de la solution la plus rapide, la plus √©volutive.  Il est capable de g√©rer des centaines de demandes simultan√©es. <br><br>  Une alternative √† <code>aiohttp</code> , pas une alternative particuli√®rement bonne est de g√©rer des centaines de threads en parall√®le. <br><br><h2>  <font color="#3AC1EF">Traitement des donn√©es en continu</font> </h2><br>  Une autre optimisation du travail avec les ressources r√©seau, qui peut √™tre utile en termes d'am√©lioration des performances des applications, consiste √† utiliser des donn√©es en streaming.  Le sch√©ma de traitement des demandes standard ressemble √† ceci: l'application envoie une demande, apr√®s quoi le corps de cette demande est charg√© en une seule fois.  Le param√®tre <code>stream</code> , qui prend en charge la biblioth√®que de <code>requests</code> , ainsi que l'attribut <code>content</code> de la biblioth√®que <code>aiohttp</code> , vous permet de vous √©loigner de ce sch√©ma. <br><br>  Voici √† quoi ressemble l'organisation du traitement de donn√©es en continu √† l'aide de <code>requests</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-comment"><span class="hljs-comment">#  `with`          #     . with requests.get('http://example.org', stream=True) as r:    print(list(r.iter_content()))</span></span></code> </pre> <br>  Voici comment diffuser des donn√©es en utilisant <code>aiohttp</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.content.read() loop = asyncio.get_event_loop() tasks = [asyncio.ensure_future(get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>))] loop.run_until_complete(asyncio.wait(tasks)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % [task.result() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> task <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tasks])</code> </pre> <br>  L'√©limination de la n√©cessit√© de charger instantan√©ment le contenu de la r√©ponse compl√®te est importante dans les cas o√π vous devez √©viter la possibilit√© potentielle d'allocation inutile de centaines de m√©gaoctets de m√©moire.  Si le programme n'a pas besoin d'acc√©der √† la r√©ponse dans son ensemble, s'il peut fonctionner avec des fragments individuels de la r√©ponse, alors il est probablement pr√©f√©rable de recourir √† des m√©thodes de diffusion en continu avec des requ√™tes.  Par exemple, si vous souhaitez enregistrer des donn√©es de la r√©ponse du serveur √† un fichier, la lecture et l'√©criture partielles seront beaucoup plus efficaces en termes d'utilisation de la m√©moire que la lecture de l'ensemble du corps de la r√©ponse, allouant une √©norme quantit√© de m√©moire puis √©crivant le tout sur le disque. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  J'esp√®re que mon expos√© sur les diff√©rentes fa√ßons d'optimiser le fonctionnement des clients HTTP vous aidera √† choisir ce qui convient le mieux √† votre application Python. <br><br>  <b>Chers lecteurs!</b>  Si vous connaissez encore d'autres moyens d'optimiser le travail avec les requ√™tes HTTP dans les applications Python, veuillez les partager. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472858/">https://habr.com/ru/post/fr472858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472840/index.html">Stockage d√©fini par logiciel, ou qu'est-ce qui a tu√© les dinosaures?</a></li>
<li><a href="../fr472848/index.html">R√©flexions sur une carri√®re en informatique</a></li>
<li><a href="../fr472850/index.html">Profession ou vie: gagnez un cours de netologie si vous n'avez pas peur</a></li>
<li><a href="../fr472854/index.html">Profilage UI Unity: qui g√¢che mon lot?</a></li>
<li><a href="../fr472856/index.html">Comment j'ai cr√©√© un service de contr√¥le qualit√© √† partir de tables et de b√¢tons</a></li>
<li><a href="../fr472860/index.html">Invalidation du cache en cascade. Partie 1</a></li>
<li><a href="../fr472862/index.html">Invalidation du cache en cascade. 2e partie</a></li>
<li><a href="../fr472864/index.html">Check Point: optimisation CPU et RAM</a></li>
<li><a href="../fr472866/index.html">Talisman pour une communication stable</a></li>
<li><a href="../fr472868/index.html">Gestion du serveur t√©l√©phonique: client mobile RUVDS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>