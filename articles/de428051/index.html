<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîº üíì üë®‚Äçüëß Wie man noch mehr ung√ºltige Zust√§nde noch unaussprechlicher macht üíó üå©Ô∏è üöî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor nicht allzu langer Zeit wurde bei Habr ein Artikel √ºber die Verwendung algebraischer Datentypen √ºbersetzt, um sicherzustellen, dass falsche Zust√§n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man noch mehr ung√ºltige Zust√§nde noch unaussprechlicher macht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428051/"><p>  Vor nicht allzu langer Zeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurde</a> bei Habr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Artikel</a> √ºber die Verwendung algebraischer Datentypen √ºbersetzt, um sicherzustellen, dass falsche Zust√§nde nicht ausgedr√ºckt werden k√∂nnen.  Heute schauen wir uns eine etwas allgemeinere, skalierbarere und sicherere M√∂glichkeit an, das Unaussprechliche auszudr√ºcken, und das Haskell wird uns dabei helfen. </p><a name="habracut"></a><br><p> Kurz gesagt, in diesem Artikel wird eine Entit√§t mit einer Postanschrift und einer E-Mail-Adresse sowie mit der zus√§tzlichen Bedingung beschrieben, dass mindestens eine dieser Adressen vorhanden sein muss.  Wie wird vorgeschlagen, diese Bedingung auf Typebene auszudr√ºcken?  Es wird vorgeschlagen, die Adressen wie folgt zu schreiben: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ContactInfo = | EmailOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo | PostOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> PostalContactInfo | EmailAndPost <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo * PostalContactInfo</code> </pre> <br><p>  Welche Probleme hat dieser Ansatz? </p><br><p>  Das offensichtlichste (und mehrfach in den Kommentaren zu diesem Artikel erw√§hnte) ist, dass dieser Ansatz √ºberhaupt nicht skalierbar ist.  Stellen Sie sich vor, wir haben nicht zwei Arten von Adressen, sondern drei oder f√ºnf, und die Korrektheitsbedingung sieht so aus: "Es muss entweder eine Postanschrift oder gleichzeitig eine E-Mail-Adresse und eine Adresse im B√ºro vorhanden sein, und es sollten nicht mehrere Adressen desselben Typs vorhanden sein."  Wer m√∂chte, kann den entsprechenden Typ als √úbung zum Selbsttest schreiben.  Die Aufgabe mit einem Sternchen besteht darin, diesen Typ neu zu schreiben, wenn die Bedingung bez√ºglich des Fehlens von Duplikaten aus dem TOR verschwunden ist. </p><br><h3>  Teilen </h3><br><p>  Wie kann man dieses Problem l√∂sen?  Versuchen wir zu phantasieren.  Zuerst zerlegen und trennen wir die Adressklasse (z. B. Mail- / E-Mail- / Schreibtischnummer im B√ºro) und den Inhalt, der dieser Klasse entspricht: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Wir werden noch nicht √ºber den Inhalt nachdenken, da in der Leistungsbeschreibung nichts f√ºr die G√ºltigkeit der Adressliste enthalten ist. </p><br><p>  Wenn wir die entsprechende Bedingung zur Laufzeit eines Konstruktors einer gew√∂hnlichen OOP-Sprache √ºberpr√ºfen w√ºrden, w√ºrden wir einfach eine Funktion wie schreiben </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">valid</span></span> :: [<span class="hljs-type"><span class="hljs-type">AddrType</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> valid xs = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasNoDups = nub xs == xs <span class="hljs-comment"><span class="hljs-comment">--      hasPost = Post `elem` xs hasEmail = Email `elem` xs hasOffice = Office `elem` xs in hasNoDups &amp;&amp; (hasPost || (hasEmail &amp;&amp; hasOffice))</span></span></code> </pre> <br><p>  und w√ºrde eine Ausf√ºhrung werfen, wenn es <code>False</code> zur√ºckgibt. </p><br><p>  K√∂nnen wir stattdessen beim Kompilieren einen √§hnlichen Zustand mit Hilfe eines Timers √ºberpr√ºfen?  Es stellt sich heraus, dass wir es k√∂nnen, wenn das Typensystem der Sprache ausdrucksstark genug ist, und den Rest des Artikels werden wir diesen Ansatz w√§hlen. </p><br><p>  Hier helfen uns abh√§ngige Typen sehr, und da der am besten geeignete Weg, einen validierten Code in Haskell zu schreiben, darin besteht, ihn zuerst in Agde oder Idris zu schreiben, werden wir unsere Schuhe wechseln und in Idris schreiben.  Die idris-Syntax ist der von Haskell ziemlich √§hnlich: Mit der oben genannten Funktion m√ºssen Sie beispielsweise die Signatur nur geringf√ºgig √§ndern: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> : List AddrType -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span></code> </pre> <br><p>  Denken Sie nun daran, dass wir zus√§tzlich zu den Adressklassen auch deren Inhalt ben√∂tigen und die Abh√§ngigkeit der Felder von der Adressklasse als GADT codieren: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PostFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">city</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">street</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OfficeFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">floor</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">desk</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Das hei√üt, wenn wir einen Wert f√ºr <code>fields</code> Typ <code>AddrFields t</code> , wissen wir, dass <code>t</code> eine AddrType- <code>AddrType</code> und dass <code>fields</code> eine Reihe von Feldern enthalten, die dieser bestimmten Klasse entsprechen. </p><br><div class="spoiler">  <b class="spoiler_title">√úber diesen Beitrag</b> <div class="spoiler_text"><p>  Dies ist nicht die typsicherste Codierung, da GADT nicht injektiv sein muss und es korrekter w√§re, drei separate Datentypen <code>PostFields</code> , <code>EmailFields</code> , <code>EmailFields</code> zu deklarieren und eine Funktion zu schreiben </p><br><pre> <code class="hljs pgsql">addrFields : AddrType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> addrFields Post = PostFields addrFields Email = EmailFields addrFields Office = OfficeFields</code> </pre> <br><p>  Dies ist jedoch zu viel Schrift, was f√ºr den Prototyp keinen signifikanten Gewinn bringt, und im Haskell gibt es daf√ºr noch pr√§zisere und angenehmere Mechanismen. </p></div></div><br><p>  Wie lautet die gesamte Adresse in diesem Modell?  Dies ist ein Paar aus der Adressklasse und den entsprechenden Feldern: </p><br><pre> <code class="hljs pgsql">Addr : <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> Addr = (t : AddrType ** AddrFields t)</code> </pre> <br><p>  Fans der Typentheorie werden sagen, dass dies ein existenziell abh√§ngiger Typ ist: Wenn wir einen Wert vom Typ <code>Addr</code> , bedeutet dies, dass es einen Wert <code>t</code> Typ <code>AddrType</code> und einen entsprechenden Satz von <code>AddrFields t</code> Feldern gibt.  Adressen einer anderen Klasse sind nat√ºrlich vom gleichen Typ: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (Email ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (Office ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Wenn uns au√üerdem <code>EmailFields</code> werden, ist die einzige geeignete <code>EmailFields</code> <code>Email</code> . Sie k√∂nnen sie also weglassen. Der Timer druckt sie selbst aus: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (_ ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (_ ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Wir schreiben eine Hilfsfunktion, die die entsprechende Liste der Adressklassen aus der Adressliste angibt, und verallgemeinern sie sofort auf die Arbeit an einem beliebigen Funktor: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">types</span></span> : Functor f =&gt; f Addr -&gt; f AddrType <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = map fst</code> </pre> <br><p>  Hier verh√§lt sich der existenzielle <code>Addr</code> Typ wie ein bekanntes Paar: Insbesondere k√∂nnen Sie nach seiner ersten Komponente <code>AddrType</code> (Aufgabe mit einem Sternchen: Warum kann ich nicht nach der zweiten Komponente fragen?). </p><br><h4>  Erh√∂hen </h4><br><p>  Jetzt kommen wir zu einem wichtigen Teil unserer Geschichte.  Wir haben also eine Liste von <code>List Addr</code> Adressen und ein <code>valid : List AddrType -&gt; Bool</code> Pr√§dikat <code>valid : List AddrType -&gt; Bool</code> , dessen Ausf√ºhrung f√ºr diese Liste wir auf der Ebene der Typen garantieren m√∂chten.  Wie kombinieren wir sie?  Nat√ºrlich ein anderer Typ! </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Jetzt werden wir analysieren, was wir hier geschrieben haben. </p><br><p>  <code>data ValidatedAddrList : List Addr -&gt; Type where</code> bedeutet, dass der Typ <code>ValidatedAddrList</code> tats√§chlich durch die Adressliste parametrisiert wird. </p><br><p>  Schauen wir uns die Signatur des einzigen <code>MkValidatedAddrList</code> Konstruktors dieses Typs an: <code>(lst : List Addr) -&gt; (prf : valid (types lst) = True) -&gt; ValidatedAddrList lst</code> .  Das hei√üt, es wird eine Liste von <code>lst</code> Adressen und ein anderes <code>prf</code> Argument vom Typ <code>valid (types lst) = True</code> .  Was bedeutet dieser Typ?  Dies bedeutet, dass der Wert links von <code>=</code> gleich dem Wert rechts von <code>=</code> ist, <code>valid (types lst)</code> , tats√§chlich ist er wahr. </p><br><p>  Wie funktioniert es  Signatur <code>=</code> sieht aus wie <code>(x : A) -&gt; (y : B) -&gt; Type</code> .  Das hei√üt, <code>=</code> nimmt zwei beliebige Werte <code>x</code> und <code>y</code> (m√∂glicherweise sogar von unterschiedlichen Typen <code>A</code> und <code>B</code> , was bedeutet, dass die Ungleichung in der Idris heterogen ist und dass sie aus typentheoretischer Sicht etwas mehrdeutig ist, aber dies ist ein Thema f√ºr eine andere Diskussion).  Was zeigt dann Gleichheit?  Und aufgrund der Tatsache, dass der einzige Konstruktor <code>=</code> - <code>Refl</code> mit einer Signatur von <em>fast</em> <code>(x : A) -&gt; x = x</code> .  Das hei√üt, wenn wir einen Wert vom Typ <code>x = y</code> , wissen wir, dass er mit <code>Refl</code> (weil es keine anderen Konstruktoren gibt), was bedeutet, dass <code>x</code> tats√§chlich gleich <code>y</code> . </p><br><p>  Beachten Sie, dass wir deshalb in der Haskell immer bestenfalls so tun, als w√ºrden wir etwas beweisen, weil die Haskell <code>undefined</code> , die einen beliebigen Typ bewohnt, sodass das obige Argument dort nicht funktioniert: f√ºr jedes <code>x</code> , <code>y</code> Term vom Typ <code>x = y</code> k√∂nnte durch <code>undefined</code> (oder durch unendliche Rekursion, sagen wir, dass es im Gro√üen und Ganzen in Bezug auf die Typentheorie dasselbe ist) erzeugt werden. </p><br><p>  Wir stellen auch fest, dass die Gleichheit hier nicht im Sinne von Haskells <code>Eq</code> oder eines <code>operator==</code> in C ++ gemeint ist, sondern wesentlich strenger: strukturell, was vereinfachend bedeutet, dass die beiden Werte dieselbe <em>Form haben</em> .  Das hei√üt, ihn so einfach zu t√§uschen, funktioniert nicht.  Gleichstellungsfragen werden jedoch traditionell in einem separaten Artikel behandelt. </p><br><p>  Um unser Verst√§ndnis von Gleichheit zu festigen, schreiben wir Unit-Tests f√ºr die <code>valid</code> Funktion: </p><br><pre> <code class="hljs powershell">testPostValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>] = True testPostValid = Refl testEmptyInvalid : valid [] = False testEmptyInvalid = Refl testDupsInvalid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Post</span></span>] = False testDupsInvalid = Refl testPostEmailValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Email</span></span>] = True testPostEmailValid = Refl</code> </pre> <br><p>  Diese Tests sind insofern gut, als Sie sie nicht einmal ausf√ºhren m√ºssen. Es reicht aus, wenn der Taypcher sie √ºberpr√ºft hat.  Lassen Sie uns zum Beispiel im ersten Fall <code>True</code> durch <code>False</code> ersetzen und sehen, was passiert: </p><br><pre> <code class="hljs pgsql">testPostValid : <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> [Post] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> testPostValid = Refl</code> </pre> <br><p>  Typsekher schw√∂rt </p><br><p><img src="https://habrastorage.org/webt/l7/to/xm/l7toxmndt6lzzbpmjersntiujfg.png"></p><br><p>  wie erwartet.  Gro√üartig </p><br><h4>  Vereinfachen </h4><br><p>  Lassen Sie uns nun unsere <code>ValidatedAddrList</code> wenig umgestalten. </p><br><p>  Erstens ist das Muster des Vergleichens eines bestimmten Werts mit <code>True</code> ziemlich h√§ufig, daher gibt es daf√ºr einen speziellen Typ <code>So</code> in der idris: Sie k√∂nnen <code>So x</code> als Synonym f√ºr <code>x = True</code> .  Lassen Sie uns die Definition von <code>ValidatedAddrList</code> : </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Dar√ºber hinaus hat <code>So</code> eine bequeme Hilfsfunktion zu <code>choose</code> , die im Wesentlichen die Pr√ºfung auf die Ebene der Typen erh√∂ht: </p><br><pre> <code class="hljs pgsql">&gt; :doc choose Data.So.choose : (b : <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; Either (So b) (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> b)) <span class="hljs-keyword"><span class="hljs-keyword">Perform</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> analysis <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> a <span class="hljs-type"><span class="hljs-type">Boolean</span></span>, providing clients <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a So proof</code> </pre> <br><p>  Dies ist n√ºtzlich, wenn wir Funktionen schreiben, die diesen Typ √§ndern. </p><br><p>  Zweitens kann idris manchmal (insbesondere in der interaktiven Entwicklung) den entsprechenden <code>prf</code> Wert selbst finden.  Damit es in solchen F√§llen nicht von Hand konstruiert werden musste, gibt es einen entsprechenden syntaktischen Zucker: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)} -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Geschweifte Klammern bedeuten, dass dies ein implizites Argument ist, das Idris versuchen wird, aus dem Kontext herauszuziehen, und <code>auto</code> bedeutet, dass er auch versuchen wird, es selbst zu konstruieren. </p><br><p>  Was bietet uns diese neue <code>ValidatedAddrList</code> ?  Und es gibt eine solche Argumentationskette: Sei <code>val</code> ein Wert vom Typ <code>ValidatedAddrList lst</code> .  Dies bedeutet, dass <code>lst</code> eine Liste von Adressen ist. Au√üerdem wurde <code>val</code> mit dem Konstruktor <code>MkValidatedAddrList</code> , an den wir <code>lst</code> diesen <code>lst</code> und einen weiteren <code>prf</code> Wert vom Typ <code>So (valid $ types lst)</code> , der fast <code>valid (types lst) = True</code> .  Und damit wir <code>prf</code> bauen <code>prf</code> , m√ºssen wir tats√§chlich beweisen, dass diese Gleichheit gilt. </p><br><p>  Und das Sch√∂nste ist, dass dies alles von einem Tympher √ºberpr√ºft wird.  Ja, die G√ºltigkeitspr√ºfung muss zur Laufzeit durchgef√ºhrt werden (da die Adressen aus einer Datei oder aus dem Netzwerk gelesen werden k√∂nnen), aber der Timer stellt sicher, dass diese Pr√ºfung durchgef√ºhrt wird: Ohne sie ist es unm√∂glich, eine <code>ValidatedAddrList</code> zu erstellen.  Zumindest in Idris.  In Haskell leider. </p><br><h4>  Einf√ºgen </h4><br><p>  Um die Unvermeidlichkeit der √úberpr√ºfung zu √ºberpr√ºfen, werden wir versuchen, eine Funktion zu schreiben, um der Liste eine Adresse hinzuzuf√ºgen.  Erster Versuch: </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) insert addr (MkValidatedAddrList lst) = MkValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Nein, der Tippfehlerpr√ºfer gibt an den Fingern (obwohl nicht sehr lesbar, sind die Kosten f√ºr die <code>valid</code> zu kompliziert): </p><br><p><img src="https://habrastorage.org/webt/au/oa/6j/auoa6jeo10ucav7rffetqmvylec.png"></p><br><p>  Wie bekommen wir eine Kopie dieses <code>So</code> ?  Nicht wie oben erw√§hnt.  Zweiter Versuch: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; ?rhs</code> </pre> <br><p>  Es ist fast typechetsya.  "Fast", weil nicht klar ist, was <code>rhs</code> .  Vielmehr ist klar: In diesem Fall muss die Funktion irgendwie einen Fehler melden.  Sie m√ºssen also die Signatur √§ndern und den R√ºckgabewert einschlie√üen, z. B. in <code>Maybe</code> : </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; Just $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Dies ist gekachelt und funktioniert wie es sollte. </p><br><p>  Aber jetzt tritt das folgende nicht sehr offensichtliche Problem auf, das tats√§chlich im urspr√ºnglichen Artikel war.  Der Typ dieser Funktion h√∂rt nicht auf, eine solche Implementierung zu schreiben: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Das hei√üt, wir sagen immer, dass wir keine neue Adressliste erstellen konnten.  Typhechaetsya?  Ja  Ist es richtig  Na ja, kaum.  Kann das vermieden werden? </p><br><p>  Es stellt sich heraus, dass dies m√∂glich ist, und wir haben alle notwendigen Werkzeuge daf√ºr.  Bei Erfolg gibt <code>insert</code> eine <code>ValidatedAddrList</code> , die Beweise f√ºr diesen Erfolg enth√§lt.  F√ºgen Sie also eine elegante Symmetrie hinzu und bitten Sie die Funktion, auch einen Fehlernachweis zur√ºckzugeben! </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Either (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> $ valid $ types (addr :: lst))) (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> r</code> </pre> <br><p>  Jetzt k√∂nnen wir nicht einfach <code>Nothing</code> nehmen und immer zur√ºckgeben. </p><br><p>  Sie k√∂nnen dasselbe f√ºr Funktionen zum Entfernen von Adressen und dergleichen tun. </p><br><p>  Mal sehen, wie jetzt am Ende alles aussieht. </p><br><p>  Versuchen wir, eine leere Adressliste zu erstellen: </p><br><p><img src="https://habrastorage.org/webt/9l/pf/a_/9lpfa_ytfrgfsvxbvy4lkk0a8uy.png"></p><br><p>  Es ist unm√∂glich, eine leere Liste ist ung√ºltig. </p><br><p>  Wie w√§re es mit einer Liste nur einer Postanschrift? </p><br><p><img src="https://habrastorage.org/webt/au/d2/jq/aud2jqe2malfgrjg2txzsncdom4.png"></p><br><p>  Okay, versuchen wir, die Postanschrift in die Liste einzuf√ºgen, die bereits die Postanschrift enth√§lt: </p><br><p><img src="https://habrastorage.org/webt/xl/cx/ri/xlcxrimioc_dutfysgtdmr2srmc.png"></p><br><p>  Versuchen wir, die E-Mail einzuf√ºgen: </p><br><p><img src="https://habrastorage.org/webt/sn/1n/zw/sn1nzwqz5erm1vjnq59dkel3zzi.png"></p><br><p>  Am Ende funktioniert alles genau wie erwartet. </p><br><p>  Puh.  Ich dachte, es w√§ren drei Zeilen, aber es stellte sich etwas l√§nger heraus.  Um herauszufinden, wie weit wir im Haskell gehen k√∂nnen, werden wir im n√§chsten Artikel sein.  In der Zwischenzeit ein wenig </p><br><h4>  Nachdenken </h4><br><p>  Was ist am Ende der Gewinn einer solchen Entscheidung im Vergleich zu dem in dem Artikel, auf den wir ganz am Anfang Bezug genommen haben? </p><br><ol><li>  Es ist wiederum viel skalierbarer.  Komplexe Validierungsfunktionen sind einfacher zu schreiben. </li><li>  Es ist eher isoliert.  Der Client-Code muss nicht wissen, was sich in der Validierungsfunktion befindet, w√§hrend das <code>ContactInfo</code> Formular aus dem Originalartikel das <code>ContactInfo</code> erfordert. </li><li>  Die Validierungslogik ist in Form von normalen und vertrauten Funktionen geschrieben, sodass sie sofort durch sorgf√§ltiges Lesen √ºberpr√ºft und mit Tests zur Kompilierungszeit getestet werden kann, anstatt die Bedeutung der Validierung aus einem Datentypformular abzuleiten, das ein bereits verifiziertes Ergebnis darstellt. </li><li>  Es wird m√∂glich, das Verhalten von Funktionen, die mit dem f√ºr uns interessanten Datentyp arbeiten, genauer zu spezifizieren, insbesondere wenn der Test nicht bestanden wird.  Zum Beispiel ist es einfach unm√∂glich, die als Ergebnis geschriebene <code>insert</code> <em>falsch</em> zu schreiben.  In √§hnlicher Weise k√∂nnte man <code>insertOrReplace</code> , <code>insertOrIgnore</code> und dergleichen schreiben, deren Verhalten im Typ vollst√§ndig angegeben ist. </li></ol><br><p>  Was ist der Gewinn im Vergleich zu einer solchen OOP-L√∂sung? </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ValidatedAddrListClass</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">ValidatedAddrListClass</span></span>(std::vector&lt;Addr&gt; addrs) { if (!<span class="hljs-built_in"><span class="hljs-built_in">valid</span></span>(addrs)) throw ValidationError {}; } };</code> </pre> <br><ol><li>  Der Code ist modularer und sicherer.  Im obigen Fall ist eine Pr√ºfung eine <em>Aktion</em> , die einmal gepr√ºft wird und die sie sp√§ter vergessen hat.  Alles basiert auf Ehrlichkeit und dem Verst√§ndnis, dass bei einer <code>ValidatedAddrListClass</code> die Implementierung dort einmal √ºberpr√ºft wurde.  Die Tatsache dieser Pr√ºfung aus der Klasse kann nicht als bestimmter Wert herausgegriffen werden.  Bei einem <em>Wert eines</em> bestimmten Typs kann dieser Wert zwischen verschiedenen Teilen des Programms √ºbertragen werden, um komplexere Werte zu erstellen (z. B. diese Pr√ºfung erneut abzulehnen), Nachforschungen anzustellen (siehe n√§chster Absatz) und im Allgemeinen das Gleiche wie fr√ºher zu tun mit Werten. </li><li>  Solche √úberpr√ºfungen k√∂nnen beim (abh√§ngigen) Mustervergleich verwendet werden.  Richtig, nicht im Fall dieser <code>valid</code> Funktion und nicht im Fall von idris ist sie schmerzhaft kompliziert und idris ist schmerzhaft langweilig, so dass Informationen, die f√ºr Muster n√ºtzlich sind, aus der <code>valid</code> Struktur extrahiert werden k√∂nnen.  Trotzdem kann <code>valid</code> in einem etwas freundlicheren Mustervergleichsstil umgeschrieben werden, aber dies geht √ºber den Rahmen dieses Artikels hinaus und ist an sich im Allgemeinen nicht trivial. </li></ol><br><p>  Was sind die Nachteile? </p><br><p>  Ich sehe nur einen schwerwiegenden Grundfehler: <code>valid</code> ist eine zu dumme Funktion.  Es wird nur eine Information zur√ºckgegeben - unabh√§ngig davon, ob die Daten die Validierung bestanden haben oder nicht.  Bei intelligenteren Typen k√∂nnten wir etwas Interessanteres erreichen. </p><br><p>  Stellen Sie sich zum Beispiel vor, dass die Anforderung der Eindeutigkeit von Adressen aus TK verschwunden ist.  In diesem Fall ist es offensichtlich, dass das Hinzuf√ºgen einer neuen Adresse zur vorhandenen Adressliste die Liste nicht ung√ºltig macht. Wir k√∂nnten <em>diesen Satz</em> also <em>beweisen,</em> indem wir eine Funktion mit dem Typ <code>So (valid $ types lst) -&gt; So (valid $ types $ addr :: lst)</code> und verwenden Sie es zum Beispiel, um typensicher zu schreiben, das immer erfolgreich ist </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Aber leider haben Theoreme wie Rekursion und Induktion, und unser Problem hat keine elegante induktive Struktur, daher ist meiner Meinung nach der Code mit Eiche Boolean <code>valid</code> auch gut. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428051/">https://habr.com/ru/post/de428051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428039/index.html">Die Regierung plant nicht, sich f√ºr die Netzneutralit√§t einzusetzen</a></li>
<li><a href="../de428041/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 336 (22. - 28. Oktober 2018)</a></li>
<li><a href="../de428043/index.html">Warten auf den sechsten, Winamp 5.8: das "Geheimnis" des Ursprungs, die M√∂glichkeit der offiziellen Version</a></li>
<li><a href="../de428045/index.html">PHP Digest Nr. 142 (15. - 29. Oktober 2018)</a></li>
<li><a href="../de428047/index.html">Leistungsanalyse von WSGI-Servern: Setzen Sie uWSGI wieder ein</a></li>
<li><a href="../de428053/index.html">So erstellen Sie eine Teststrategie: Version von echten Ingenieuren</a></li>
<li><a href="../de428055/index.html">R√ºckblick auf Technologie-Startups. Z3 - der erste Relaiscomputer</a></li>
<li><a href="../de428057/index.html">Ein neuer Blick auf die Dokumentation der API und des SDK in Yandex. Vortrag √ºber Hyperbaton</a></li>
<li><a href="../de428059/index.html">Verbinden Sie den Multipath-LUN-Speicher mit VMware ESXi und Debian GNU / Linux</a></li>
<li><a href="../de428061/index.html">Projektkosten mit Earned Value Management verwalten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>