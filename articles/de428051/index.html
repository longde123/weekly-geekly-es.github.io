<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔼 💓 👨‍👧 Wie man noch mehr ungültige Zustände noch unaussprechlicher macht 💗 🌩️ 🚔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor nicht allzu langer Zeit wurde bei Habr ein Artikel über die Verwendung algebraischer Datentypen übersetzt, um sicherzustellen, dass falsche Zustän...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man noch mehr ungültige Zustände noch unaussprechlicher macht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428051/"><p>  Vor nicht allzu langer Zeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurde</a> bei Habr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Artikel</a> über die Verwendung algebraischer Datentypen übersetzt, um sicherzustellen, dass falsche Zustände nicht ausgedrückt werden können.  Heute schauen wir uns eine etwas allgemeinere, skalierbarere und sicherere Möglichkeit an, das Unaussprechliche auszudrücken, und das Haskell wird uns dabei helfen. </p><a name="habracut"></a><br><p> Kurz gesagt, in diesem Artikel wird eine Entität mit einer Postanschrift und einer E-Mail-Adresse sowie mit der zusätzlichen Bedingung beschrieben, dass mindestens eine dieser Adressen vorhanden sein muss.  Wie wird vorgeschlagen, diese Bedingung auf Typebene auszudrücken?  Es wird vorgeschlagen, die Adressen wie folgt zu schreiben: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ContactInfo = | EmailOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo | PostOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> PostalContactInfo | EmailAndPost <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo * PostalContactInfo</code> </pre> <br><p>  Welche Probleme hat dieser Ansatz? </p><br><p>  Das offensichtlichste (und mehrfach in den Kommentaren zu diesem Artikel erwähnte) ist, dass dieser Ansatz überhaupt nicht skalierbar ist.  Stellen Sie sich vor, wir haben nicht zwei Arten von Adressen, sondern drei oder fünf, und die Korrektheitsbedingung sieht so aus: "Es muss entweder eine Postanschrift oder gleichzeitig eine E-Mail-Adresse und eine Adresse im Büro vorhanden sein, und es sollten nicht mehrere Adressen desselben Typs vorhanden sein."  Wer möchte, kann den entsprechenden Typ als Übung zum Selbsttest schreiben.  Die Aufgabe mit einem Sternchen besteht darin, diesen Typ neu zu schreiben, wenn die Bedingung bezüglich des Fehlens von Duplikaten aus dem TOR verschwunden ist. </p><br><h3>  Teilen </h3><br><p>  Wie kann man dieses Problem lösen?  Versuchen wir zu phantasieren.  Zuerst zerlegen und trennen wir die Adressklasse (z. B. Mail- / E-Mail- / Schreibtischnummer im Büro) und den Inhalt, der dieser Klasse entspricht: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Wir werden noch nicht über den Inhalt nachdenken, da in der Leistungsbeschreibung nichts für die Gültigkeit der Adressliste enthalten ist. </p><br><p>  Wenn wir die entsprechende Bedingung zur Laufzeit eines Konstruktors einer gewöhnlichen OOP-Sprache überprüfen würden, würden wir einfach eine Funktion wie schreiben </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">valid</span></span> :: [<span class="hljs-type"><span class="hljs-type">AddrType</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> valid xs = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasNoDups = nub xs == xs <span class="hljs-comment"><span class="hljs-comment">--      hasPost = Post `elem` xs hasEmail = Email `elem` xs hasOffice = Office `elem` xs in hasNoDups &amp;&amp; (hasPost || (hasEmail &amp;&amp; hasOffice))</span></span></code> </pre> <br><p>  und würde eine Ausführung werfen, wenn es <code>False</code> zurückgibt. </p><br><p>  Können wir stattdessen beim Kompilieren einen ähnlichen Zustand mit Hilfe eines Timers überprüfen?  Es stellt sich heraus, dass wir es können, wenn das Typensystem der Sprache ausdrucksstark genug ist, und den Rest des Artikels werden wir diesen Ansatz wählen. </p><br><p>  Hier helfen uns abhängige Typen sehr, und da der am besten geeignete Weg, einen validierten Code in Haskell zu schreiben, darin besteht, ihn zuerst in Agde oder Idris zu schreiben, werden wir unsere Schuhe wechseln und in Idris schreiben.  Die idris-Syntax ist der von Haskell ziemlich ähnlich: Mit der oben genannten Funktion müssen Sie beispielsweise die Signatur nur geringfügig ändern: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> : List AddrType -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span></code> </pre> <br><p>  Denken Sie nun daran, dass wir zusätzlich zu den Adressklassen auch deren Inhalt benötigen und die Abhängigkeit der Felder von der Adressklasse als GADT codieren: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PostFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">city</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">street</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OfficeFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">floor</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">desk</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Das heißt, wenn wir einen Wert für <code>fields</code> Typ <code>AddrFields t</code> , wissen wir, dass <code>t</code> eine AddrType- <code>AddrType</code> und dass <code>fields</code> eine Reihe von Feldern enthalten, die dieser bestimmten Klasse entsprechen. </p><br><div class="spoiler">  <b class="spoiler_title">Über diesen Beitrag</b> <div class="spoiler_text"><p>  Dies ist nicht die typsicherste Codierung, da GADT nicht injektiv sein muss und es korrekter wäre, drei separate Datentypen <code>PostFields</code> , <code>EmailFields</code> , <code>EmailFields</code> zu deklarieren und eine Funktion zu schreiben </p><br><pre> <code class="hljs pgsql">addrFields : AddrType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> addrFields Post = PostFields addrFields Email = EmailFields addrFields Office = OfficeFields</code> </pre> <br><p>  Dies ist jedoch zu viel Schrift, was für den Prototyp keinen signifikanten Gewinn bringt, und im Haskell gibt es dafür noch präzisere und angenehmere Mechanismen. </p></div></div><br><p>  Wie lautet die gesamte Adresse in diesem Modell?  Dies ist ein Paar aus der Adressklasse und den entsprechenden Feldern: </p><br><pre> <code class="hljs pgsql">Addr : <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> Addr = (t : AddrType ** AddrFields t)</code> </pre> <br><p>  Fans der Typentheorie werden sagen, dass dies ein existenziell abhängiger Typ ist: Wenn wir einen Wert vom Typ <code>Addr</code> , bedeutet dies, dass es einen Wert <code>t</code> Typ <code>AddrType</code> und einen entsprechenden Satz von <code>AddrFields t</code> Feldern gibt.  Adressen einer anderen Klasse sind natürlich vom gleichen Typ: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (Email ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (Office ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Wenn uns außerdem <code>EmailFields</code> werden, ist die einzige geeignete <code>EmailFields</code> <code>Email</code> . Sie können sie also weglassen. Der Timer druckt sie selbst aus: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (_ ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (_ ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Wir schreiben eine Hilfsfunktion, die die entsprechende Liste der Adressklassen aus der Adressliste angibt, und verallgemeinern sie sofort auf die Arbeit an einem beliebigen Funktor: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">types</span></span> : Functor f =&gt; f Addr -&gt; f AddrType <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = map fst</code> </pre> <br><p>  Hier verhält sich der existenzielle <code>Addr</code> Typ wie ein bekanntes Paar: Insbesondere können Sie nach seiner ersten Komponente <code>AddrType</code> (Aufgabe mit einem Sternchen: Warum kann ich nicht nach der zweiten Komponente fragen?). </p><br><h4>  Erhöhen </h4><br><p>  Jetzt kommen wir zu einem wichtigen Teil unserer Geschichte.  Wir haben also eine Liste von <code>List Addr</code> Adressen und ein <code>valid : List AddrType -&gt; Bool</code> Prädikat <code>valid : List AddrType -&gt; Bool</code> , dessen Ausführung für diese Liste wir auf der Ebene der Typen garantieren möchten.  Wie kombinieren wir sie?  Natürlich ein anderer Typ! </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Jetzt werden wir analysieren, was wir hier geschrieben haben. </p><br><p>  <code>data ValidatedAddrList : List Addr -&gt; Type where</code> bedeutet, dass der Typ <code>ValidatedAddrList</code> tatsächlich durch die Adressliste parametrisiert wird. </p><br><p>  Schauen wir uns die Signatur des einzigen <code>MkValidatedAddrList</code> Konstruktors dieses Typs an: <code>(lst : List Addr) -&gt; (prf : valid (types lst) = True) -&gt; ValidatedAddrList lst</code> .  Das heißt, es wird eine Liste von <code>lst</code> Adressen und ein anderes <code>prf</code> Argument vom Typ <code>valid (types lst) = True</code> .  Was bedeutet dieser Typ?  Dies bedeutet, dass der Wert links von <code>=</code> gleich dem Wert rechts von <code>=</code> ist, <code>valid (types lst)</code> , tatsächlich ist er wahr. </p><br><p>  Wie funktioniert es  Signatur <code>=</code> sieht aus wie <code>(x : A) -&gt; (y : B) -&gt; Type</code> .  Das heißt, <code>=</code> nimmt zwei beliebige Werte <code>x</code> und <code>y</code> (möglicherweise sogar von unterschiedlichen Typen <code>A</code> und <code>B</code> , was bedeutet, dass die Ungleichung in der Idris heterogen ist und dass sie aus typentheoretischer Sicht etwas mehrdeutig ist, aber dies ist ein Thema für eine andere Diskussion).  Was zeigt dann Gleichheit?  Und aufgrund der Tatsache, dass der einzige Konstruktor <code>=</code> - <code>Refl</code> mit einer Signatur von <em>fast</em> <code>(x : A) -&gt; x = x</code> .  Das heißt, wenn wir einen Wert vom Typ <code>x = y</code> , wissen wir, dass er mit <code>Refl</code> (weil es keine anderen Konstruktoren gibt), was bedeutet, dass <code>x</code> tatsächlich gleich <code>y</code> . </p><br><p>  Beachten Sie, dass wir deshalb in der Haskell immer bestenfalls so tun, als würden wir etwas beweisen, weil die Haskell <code>undefined</code> , die einen beliebigen Typ bewohnt, sodass das obige Argument dort nicht funktioniert: für jedes <code>x</code> , <code>y</code> Term vom Typ <code>x = y</code> könnte durch <code>undefined</code> (oder durch unendliche Rekursion, sagen wir, dass es im Großen und Ganzen in Bezug auf die Typentheorie dasselbe ist) erzeugt werden. </p><br><p>  Wir stellen auch fest, dass die Gleichheit hier nicht im Sinne von Haskells <code>Eq</code> oder eines <code>operator==</code> in C ++ gemeint ist, sondern wesentlich strenger: strukturell, was vereinfachend bedeutet, dass die beiden Werte dieselbe <em>Form haben</em> .  Das heißt, ihn so einfach zu täuschen, funktioniert nicht.  Gleichstellungsfragen werden jedoch traditionell in einem separaten Artikel behandelt. </p><br><p>  Um unser Verständnis von Gleichheit zu festigen, schreiben wir Unit-Tests für die <code>valid</code> Funktion: </p><br><pre> <code class="hljs powershell">testPostValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>] = True testPostValid = Refl testEmptyInvalid : valid [] = False testEmptyInvalid = Refl testDupsInvalid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Post</span></span>] = False testDupsInvalid = Refl testPostEmailValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Email</span></span>] = True testPostEmailValid = Refl</code> </pre> <br><p>  Diese Tests sind insofern gut, als Sie sie nicht einmal ausführen müssen. Es reicht aus, wenn der Taypcher sie überprüft hat.  Lassen Sie uns zum Beispiel im ersten Fall <code>True</code> durch <code>False</code> ersetzen und sehen, was passiert: </p><br><pre> <code class="hljs pgsql">testPostValid : <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> [Post] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> testPostValid = Refl</code> </pre> <br><p>  Typsekher schwört </p><br><p><img src="https://habrastorage.org/webt/l7/to/xm/l7toxmndt6lzzbpmjersntiujfg.png"></p><br><p>  wie erwartet.  Großartig </p><br><h4>  Vereinfachen </h4><br><p>  Lassen Sie uns nun unsere <code>ValidatedAddrList</code> wenig umgestalten. </p><br><p>  Erstens ist das Muster des Vergleichens eines bestimmten Werts mit <code>True</code> ziemlich häufig, daher gibt es dafür einen speziellen Typ <code>So</code> in der idris: Sie können <code>So x</code> als Synonym für <code>x = True</code> .  Lassen Sie uns die Definition von <code>ValidatedAddrList</code> : </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Darüber hinaus hat <code>So</code> eine bequeme Hilfsfunktion zu <code>choose</code> , die im Wesentlichen die Prüfung auf die Ebene der Typen erhöht: </p><br><pre> <code class="hljs pgsql">&gt; :doc choose Data.So.choose : (b : <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; Either (So b) (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> b)) <span class="hljs-keyword"><span class="hljs-keyword">Perform</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> analysis <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> a <span class="hljs-type"><span class="hljs-type">Boolean</span></span>, providing clients <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a So proof</code> </pre> <br><p>  Dies ist nützlich, wenn wir Funktionen schreiben, die diesen Typ ändern. </p><br><p>  Zweitens kann idris manchmal (insbesondere in der interaktiven Entwicklung) den entsprechenden <code>prf</code> Wert selbst finden.  Damit es in solchen Fällen nicht von Hand konstruiert werden musste, gibt es einen entsprechenden syntaktischen Zucker: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)} -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Geschweifte Klammern bedeuten, dass dies ein implizites Argument ist, das Idris versuchen wird, aus dem Kontext herauszuziehen, und <code>auto</code> bedeutet, dass er auch versuchen wird, es selbst zu konstruieren. </p><br><p>  Was bietet uns diese neue <code>ValidatedAddrList</code> ?  Und es gibt eine solche Argumentationskette: Sei <code>val</code> ein Wert vom Typ <code>ValidatedAddrList lst</code> .  Dies bedeutet, dass <code>lst</code> eine Liste von Adressen ist. Außerdem wurde <code>val</code> mit dem Konstruktor <code>MkValidatedAddrList</code> , an den wir <code>lst</code> diesen <code>lst</code> und einen weiteren <code>prf</code> Wert vom Typ <code>So (valid $ types lst)</code> , der fast <code>valid (types lst) = True</code> .  Und damit wir <code>prf</code> bauen <code>prf</code> , müssen wir tatsächlich beweisen, dass diese Gleichheit gilt. </p><br><p>  Und das Schönste ist, dass dies alles von einem Tympher überprüft wird.  Ja, die Gültigkeitsprüfung muss zur Laufzeit durchgeführt werden (da die Adressen aus einer Datei oder aus dem Netzwerk gelesen werden können), aber der Timer stellt sicher, dass diese Prüfung durchgeführt wird: Ohne sie ist es unmöglich, eine <code>ValidatedAddrList</code> zu erstellen.  Zumindest in Idris.  In Haskell leider. </p><br><h4>  Einfügen </h4><br><p>  Um die Unvermeidlichkeit der Überprüfung zu überprüfen, werden wir versuchen, eine Funktion zu schreiben, um der Liste eine Adresse hinzuzufügen.  Erster Versuch: </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) insert addr (MkValidatedAddrList lst) = MkValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Nein, der Tippfehlerprüfer gibt an den Fingern (obwohl nicht sehr lesbar, sind die Kosten für die <code>valid</code> zu kompliziert): </p><br><p><img src="https://habrastorage.org/webt/au/oa/6j/auoa6jeo10ucav7rffetqmvylec.png"></p><br><p>  Wie bekommen wir eine Kopie dieses <code>So</code> ?  Nicht wie oben erwähnt.  Zweiter Versuch: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; ?rhs</code> </pre> <br><p>  Es ist fast typechetsya.  "Fast", weil nicht klar ist, was <code>rhs</code> .  Vielmehr ist klar: In diesem Fall muss die Funktion irgendwie einen Fehler melden.  Sie müssen also die Signatur ändern und den Rückgabewert einschließen, z. B. in <code>Maybe</code> : </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; Just $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Dies ist gekachelt und funktioniert wie es sollte. </p><br><p>  Aber jetzt tritt das folgende nicht sehr offensichtliche Problem auf, das tatsächlich im ursprünglichen Artikel war.  Der Typ dieser Funktion hört nicht auf, eine solche Implementierung zu schreiben: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Das heißt, wir sagen immer, dass wir keine neue Adressliste erstellen konnten.  Typhechaetsya?  Ja  Ist es richtig  Na ja, kaum.  Kann das vermieden werden? </p><br><p>  Es stellt sich heraus, dass dies möglich ist, und wir haben alle notwendigen Werkzeuge dafür.  Bei Erfolg gibt <code>insert</code> eine <code>ValidatedAddrList</code> , die Beweise für diesen Erfolg enthält.  Fügen Sie also eine elegante Symmetrie hinzu und bitten Sie die Funktion, auch einen Fehlernachweis zurückzugeben! </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Either (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> $ valid $ types (addr :: lst))) (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> r</code> </pre> <br><p>  Jetzt können wir nicht einfach <code>Nothing</code> nehmen und immer zurückgeben. </p><br><p>  Sie können dasselbe für Funktionen zum Entfernen von Adressen und dergleichen tun. </p><br><p>  Mal sehen, wie jetzt am Ende alles aussieht. </p><br><p>  Versuchen wir, eine leere Adressliste zu erstellen: </p><br><p><img src="https://habrastorage.org/webt/9l/pf/a_/9lpfa_ytfrgfsvxbvy4lkk0a8uy.png"></p><br><p>  Es ist unmöglich, eine leere Liste ist ungültig. </p><br><p>  Wie wäre es mit einer Liste nur einer Postanschrift? </p><br><p><img src="https://habrastorage.org/webt/au/d2/jq/aud2jqe2malfgrjg2txzsncdom4.png"></p><br><p>  Okay, versuchen wir, die Postanschrift in die Liste einzufügen, die bereits die Postanschrift enthält: </p><br><p><img src="https://habrastorage.org/webt/xl/cx/ri/xlcxrimioc_dutfysgtdmr2srmc.png"></p><br><p>  Versuchen wir, die E-Mail einzufügen: </p><br><p><img src="https://habrastorage.org/webt/sn/1n/zw/sn1nzwqz5erm1vjnq59dkel3zzi.png"></p><br><p>  Am Ende funktioniert alles genau wie erwartet. </p><br><p>  Puh.  Ich dachte, es wären drei Zeilen, aber es stellte sich etwas länger heraus.  Um herauszufinden, wie weit wir im Haskell gehen können, werden wir im nächsten Artikel sein.  In der Zwischenzeit ein wenig </p><br><h4>  Nachdenken </h4><br><p>  Was ist am Ende der Gewinn einer solchen Entscheidung im Vergleich zu dem in dem Artikel, auf den wir ganz am Anfang Bezug genommen haben? </p><br><ol><li>  Es ist wiederum viel skalierbarer.  Komplexe Validierungsfunktionen sind einfacher zu schreiben. </li><li>  Es ist eher isoliert.  Der Client-Code muss nicht wissen, was sich in der Validierungsfunktion befindet, während das <code>ContactInfo</code> Formular aus dem Originalartikel das <code>ContactInfo</code> erfordert. </li><li>  Die Validierungslogik ist in Form von normalen und vertrauten Funktionen geschrieben, sodass sie sofort durch sorgfältiges Lesen überprüft und mit Tests zur Kompilierungszeit getestet werden kann, anstatt die Bedeutung der Validierung aus einem Datentypformular abzuleiten, das ein bereits verifiziertes Ergebnis darstellt. </li><li>  Es wird möglich, das Verhalten von Funktionen, die mit dem für uns interessanten Datentyp arbeiten, genauer zu spezifizieren, insbesondere wenn der Test nicht bestanden wird.  Zum Beispiel ist es einfach unmöglich, die als Ergebnis geschriebene <code>insert</code> <em>falsch</em> zu schreiben.  In ähnlicher Weise könnte man <code>insertOrReplace</code> , <code>insertOrIgnore</code> und dergleichen schreiben, deren Verhalten im Typ vollständig angegeben ist. </li></ol><br><p>  Was ist der Gewinn im Vergleich zu einer solchen OOP-Lösung? </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ValidatedAddrListClass</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">ValidatedAddrListClass</span></span>(std::vector&lt;Addr&gt; addrs) { if (!<span class="hljs-built_in"><span class="hljs-built_in">valid</span></span>(addrs)) throw ValidationError {}; } };</code> </pre> <br><ol><li>  Der Code ist modularer und sicherer.  Im obigen Fall ist eine Prüfung eine <em>Aktion</em> , die einmal geprüft wird und die sie später vergessen hat.  Alles basiert auf Ehrlichkeit und dem Verständnis, dass bei einer <code>ValidatedAddrListClass</code> die Implementierung dort einmal überprüft wurde.  Die Tatsache dieser Prüfung aus der Klasse kann nicht als bestimmter Wert herausgegriffen werden.  Bei einem <em>Wert eines</em> bestimmten Typs kann dieser Wert zwischen verschiedenen Teilen des Programms übertragen werden, um komplexere Werte zu erstellen (z. B. diese Prüfung erneut abzulehnen), Nachforschungen anzustellen (siehe nächster Absatz) und im Allgemeinen das Gleiche wie früher zu tun mit Werten. </li><li>  Solche Überprüfungen können beim (abhängigen) Mustervergleich verwendet werden.  Richtig, nicht im Fall dieser <code>valid</code> Funktion und nicht im Fall von idris ist sie schmerzhaft kompliziert und idris ist schmerzhaft langweilig, so dass Informationen, die für Muster nützlich sind, aus der <code>valid</code> Struktur extrahiert werden können.  Trotzdem kann <code>valid</code> in einem etwas freundlicheren Mustervergleichsstil umgeschrieben werden, aber dies geht über den Rahmen dieses Artikels hinaus und ist an sich im Allgemeinen nicht trivial. </li></ol><br><p>  Was sind die Nachteile? </p><br><p>  Ich sehe nur einen schwerwiegenden Grundfehler: <code>valid</code> ist eine zu dumme Funktion.  Es wird nur eine Information zurückgegeben - unabhängig davon, ob die Daten die Validierung bestanden haben oder nicht.  Bei intelligenteren Typen könnten wir etwas Interessanteres erreichen. </p><br><p>  Stellen Sie sich zum Beispiel vor, dass die Anforderung der Eindeutigkeit von Adressen aus TK verschwunden ist.  In diesem Fall ist es offensichtlich, dass das Hinzufügen einer neuen Adresse zur vorhandenen Adressliste die Liste nicht ungültig macht. Wir könnten <em>diesen Satz</em> also <em>beweisen,</em> indem wir eine Funktion mit dem Typ <code>So (valid $ types lst) -&gt; So (valid $ types $ addr :: lst)</code> und verwenden Sie es zum Beispiel, um typensicher zu schreiben, das immer erfolgreich ist </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Aber leider haben Theoreme wie Rekursion und Induktion, und unser Problem hat keine elegante induktive Struktur, daher ist meiner Meinung nach der Code mit Eiche Boolean <code>valid</code> auch gut. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428051/">https://habr.com/ru/post/de428051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428039/index.html">Die Regierung plant nicht, sich für die Netzneutralität einzusetzen</a></li>
<li><a href="../de428041/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 336 (22. - 28. Oktober 2018)</a></li>
<li><a href="../de428043/index.html">Warten auf den sechsten, Winamp 5.8: das "Geheimnis" des Ursprungs, die Möglichkeit der offiziellen Version</a></li>
<li><a href="../de428045/index.html">PHP Digest Nr. 142 (15. - 29. Oktober 2018)</a></li>
<li><a href="../de428047/index.html">Leistungsanalyse von WSGI-Servern: Setzen Sie uWSGI wieder ein</a></li>
<li><a href="../de428053/index.html">So erstellen Sie eine Teststrategie: Version von echten Ingenieuren</a></li>
<li><a href="../de428055/index.html">Rückblick auf Technologie-Startups. Z3 - der erste Relaiscomputer</a></li>
<li><a href="../de428057/index.html">Ein neuer Blick auf die Dokumentation der API und des SDK in Yandex. Vortrag über Hyperbaton</a></li>
<li><a href="../de428059/index.html">Verbinden Sie den Multipath-LUN-Speicher mit VMware ESXi und Debian GNU / Linux</a></li>
<li><a href="../de428061/index.html">Projektkosten mit Earned Value Management verwalten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>