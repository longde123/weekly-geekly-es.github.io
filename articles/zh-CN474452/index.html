<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚾️ 📭 🐮 Haxe秋季状态报告 ✖️ 🛄 ☯️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="10月26日，莱茵林茨（德国）主持了有关Haxe及其相关技术的2019年HaxeUp Sessions小型会议 。 当然，它最重要的事件是Haxe 4.0.0的最终版本（在发布时，即大约一周后， 发布了4.0.1更新 ）。 在本文中，我想向您介绍会议的第一份报告的译文-关于Haxe团队在2019年所...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haxe秋季状态报告</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474452/"><p>  10月26日，莱茵林茨（德国）主持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了</a>有关Haxe及其相关技术的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2019年HaxeUp Sessions小型会议</a> 。 当然，它最重要的事件是Haxe 4.0.0的最终版本（在发布时，即大约一周后， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发布了4.0.1更新</a> ）。 在本文中，我想向您介绍会议的第一份报告的译文-关于Haxe团队在2019年所做工作的报告。 </p><br><p><img src="https://habrastorage.org/webt/hk/ik/sp/hkiksp6o31il9tcdxjjlm6xnmve.png" alt="图片"></p><a name="habracut"></a><br><p> 关于报告作者的一些信息： </p><br><p> 从2010年开始，Simon就一直在Haxe工作，当时他还是一名学生，并撰写了有关Flash中流体模拟的文章。 这种模拟的实现需要不断访问描述粒子状态的数据（在每个步骤中，要对数据数组进行100多次关于模拟中每个单元格状态的查询），而在ActionScript 3中使用数组的工作并不是那么快。 因此，最初的实现方式根本无法实现，需要找到解决该问题的方法。 在他的搜索中，Simon遇到了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nicolas Kannass</a> （Haxe的创建者）的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章，</a>内容涉及当时未<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">公开的</a> Alchemy操作码，这些代码无法使用ActionScript使用，但是Haxe允许使用它们。 使用操作码在Haxe上重写模拟，Simon得到了有效的模拟！ 因此，由于ActionScript中的慢速数组，Simon了解了Haxe。 </p><br><p> 自2011年以来，Simon参与了Haxe的开发工作，他开始研究OCaml（在其上编写编译器）并对编译器进行了各种更正。 </p><br><p> 从2012年起，他成为主要的编译器开发人员。 同年，成立了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Haxe基金会</a> （该组织的主要目标是开发和维护Haxe生态系统，帮助社区组织会议并提供咨询服务），Simon成为其联合创始人之一。 </p><br><p><img src="https://habrastorage.org/webt/ic/n2/-z/icn2-zvorldkegboovusqzxfdbo.png" alt="图片"></p><br><p> 在2014-2015年，Simon邀请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Josephine Pertosa</a>加入了Haxe基金会，该基金会随后负责组织会议和社区关系。 </p><br><p> 在2016年，Simon首次<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Haxe上发表演讲</a> ，并在2018年组织了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一届HaxeUp会议</a> 。 </p><br><p><img src="https://habrastorage.org/webt/ii/3p/vq/ii3pvqd1f88pj3toyvcaxjcmjr8.png" alt="图片"></p><br><p> 那么在过去的2019年Haxe世界发生了什么？ </p><br><p> 在2月和3月，有2个候选发行版发布（4.0.0-rc1和4.0.0-rc2） <br>  4月， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Aurel Bili</a> （作为实习生）和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alexander Kuzmenko</a> （作为编译器开发人员）加入了Haxe Foundation团队。 </p><br><p>  5月， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">举行了2019年Haxe美国峰会</a> 。 <br>  6月，发布了Haxe 4.0.0-rc3。 而在9月-Haxe 4.0.0-rc4和Haxe 4.0.0-rc5。 </p><br><p><img src="https://habrastorage.org/webt/bg/cz/di/bgczdidj4imp0y_rteusgqy-dwq.png" alt="图片"></p><br><p>  Haxe不仅是编译器，而且还是一整套各种工具，并且在全年中，它们的工作也在不断进行： <br> 由于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Andy Lee</a>的努力<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a> Haxe现在使用Azure Pipelines代替Travis CI和AppVeyor。 这意味着组装和自动化测试现在要快得多。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">休·桑德森</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hugh Sanderson）</a>继续致力于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">hxcpp</a> （Haxe中支持C ++的库）。 <br> 突然，Github <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">terurou</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">takashiski的</a>用户加入了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js externs</a>的工作<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rudy Ges</a>致力于修复和改进，以支持C＃目标。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">George Corney</a>继续支持HTML extern生成器。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jens Fisher正在</a>从事<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vshaxe</a> （与Haxe一起使用的VS Code的扩展）以及许多其他与Haxe相关的项目。 </p><br><p><img src="https://habrastorage.org/webt/4c/n-/vr/4cn-vrhfusi6b6adnvyldgpyd7y.png" alt="图片"></p><br><p> 当然，今年的主要事件当然是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">期待已久的Haxe 4.0.0</a> （以及neko 2.3.0）的发布，它偶然与HaxeUp 2019 Linz碰巧出现:) </p><br><p><img src="https://habrastorage.org/webt/z6/n5/w0/z6n5w0pvjr4oecito4cd4w0ge_i.png" alt="图片"></p><br><p> 西蒙将报告的大部分内容用于Haxe 4.0.0的新功能（您也可以从上一届Haxe US Summit 2019 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的Alexander Kuzmenko</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告中</a>了解到它们）。 </p><br><p><img src="https://habrastorage.org/webt/mn/-z/u2/mn-zu2pk84sti-8ztm8hvhmvizm.png" alt="图片"></p><br><p> 新的eval宏解释器比旧的解释器快几倍。 西蒙<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在2017年欧洲峰会上的讲话中</a>详细谈到了他。 但是从那时起，它改进了代码的调试功能，修复了许多错误，重新设计了字符串的实现。 </p><br><p><img src="https://habrastorage.org/webt/d_/j3/uq/d_j3uqwvxpukog8q9pgp9prafrw.png" alt="图片"></p><br><p> Haxe 4引入了对所有平台（Neko除外）的Unicode支持。 西蒙在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">去年的演讲</a>中对此进行了详细描述。 对于编译器的最终用户，这意味着表达式<code>"Haxeは最高だぞ！".length</code>所有平台的<code>"Haxeは最高だぞ！".length</code>将始终返回<code>10</code> （同样，Neko除外）。 </p><br><p> 最少支持UCS-2编码（每种平台/语言都使用本机支持的编码；在任何地方尝试支持相同的编码都是不切实际的）： </p><br><ul><li>  JavaScript，Flash，HashLink和C ++使用UCS-2编码 </li><li> 用于评估，PHP，Lua-UTF-8 </li><li>  Java和C＃的代码-UTF-16 </li><li> 适用于Python-UTF-32 </li></ul><br><p> 主多语言平面之外的所有字符（包括表情符号）都表示为“代理对”-这些字符用两个字节表示。 例如，如果在Java / C＃/ JavaScript中（即，对于UTF-16和UCS-2编码的字符串）请求由一个表情符号组成的字符串的长度，则结果将为“ 2”。 在这些平台上使用此类字符串时，必须考虑到这一事实。 </p><br><p>  Haxe 4引入了一种新型的迭代器-键值： </p><br><p><img src="https://habrastorage.org/webt/h5/8l/1f/h58l1f46pistrquuipoopbqybeq.png" alt="图片"></p><br><p> 它可以与<code>Map</code>类型（字典）和字符串类型（使用StringTools类）的容器一起使用，但尚未实现对数组的支持。 也可以为自定义类实现这样的迭代器，为此，只需为它们实现<code>keyValueIterator():KeyValueIterator&lt;K, V&gt;</code>方法即可<code>keyValueIterator():KeyValueIterator&lt;K, V&gt;</code> 。 </p><br><p> 新的元标记<code>@:using</code>允许您在声明的静态扩展名和类型之间进行关联。 </p><br><p> 在下面的幻灯片中所示的示例中， <code>MyOption</code>枚举与<code>MyOptionTools</code>相关联，因此我们静态扩展了此枚举（在通常情况下是不可能的），并有机会调用<code>get()</code>方法，将其称为对象方法。 </p><br><p><img src="https://habrastorage.org/webt/ol/i7/in/oli7inyhluzdfnval9ohazjh-lg.png" alt="图片"></p><br><p> 在此示例中， <code>get()</code>方法是内联的，这还允许编译器进一步优化代码：代替调用<code>MyOptionTools.get(myOption)</code>方法，编译器将替换存储的值，即<code>12</code> 。 </p><br><p> 如果该方法未声明为可嵌入，则程序员可以使用的另一个优化工具是将函数嵌入在调用位置（调用站点内联）。 为此，在调用函数时，还必须使用<code>inline</code> ： </p><br><p><img src="https://habrastorage.org/webt/4p/bb/xp/4pbbxpcwmgfbabo5dih7lpqdmm0.png" alt="图片"></p><br><p> 由于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Daniil Korostelev</a>的工作，Haxe现在有机会生成JavaScript的ES6类。 您只需要添加编译标志<code>-D js-es=6</code> 。 </p><br><p> 当前，编译器会为整个项目生成一个js文件（将来可能会为每个类生成单独的js文件，但是到目前为止，只能使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他工具</a>来完成此操作）。 </p><br><p><img src="https://habrastorage.org/webt/md/mk/no/mdmknohyzhrkyftm1frzusodoi4.png" alt="图片"></p><br><p> 对于抽象枚举，现在会自动生成值。 </p><br><p> 在Haxe 3中，必须为每个构造函数手动设置值。 在Haxe 4中，在<code>Int</code>之上创建的抽象枚举的行为与在C中的规则相同。在字符串之上创建的抽象枚举的行为相似-对于它们，生成的值将与构造函数的名称一致。 </p><br><p><img src="https://habrastorage.org/webt/mu/gr/uj/mugrujzah5vmzrw-vcgyjzw42ju.png" alt="图片"></p><br><p> 一些语法改进也值得一提： </p><br><ul><li> 抽象枚举和extern函数已成为Haxe的正式成员，现在您无需使用<code>@:enum</code>和<code>@:extern</code>元标记来声明它们 </li><li>  4th Haxe使用一种新型的交集语法，可以更好地反映扩展结构的本质。 这样的构造在声明数据结构时最有用：表达式<code>typedef T = A &amp; B</code>表示结构<code>T</code>具有所有类型<code>A</code>和<code>B</code>的字段 </li><li> 同样，有四个声明类型参数约束：条目<code>&lt;T:A &amp; B&gt;</code>表示参数<code>T</code>的类型必须同时为<code>A</code>和<code>B</code> </li><li> 旧的语法将起作用（类型限制的语法除外，因为它将与用于描述函数类型的新语法冲突） </li></ul><br><p><img src="https://habrastorage.org/webt/ju/gt/yu/jugtyumi4hrt7fvt7ridshgzt5a.png" alt="图片"></p><br><p> 用于描述函数类型的新语法（函数类型语法）更加合乎逻辑：在函数参数类型周围使用括号在视觉上更易于阅读。 另外，新语法允许您定义参数名称，这些名称可以用作代码文档的一部分（尽管它不会影响键入本身）。 </p><br><p><img src="https://habrastorage.org/webt/1v/yu/y5/1vyuy5q4ayqlbteqmq3ugx9lzba.png" alt="图片"></p><br><p> 在这种情况下，旧语法将继续受支持，并且不会被弃用，因为 否则，将需要对现有代码进行太多更改（Simon自己经常会变得不习惯，并继续使用旧语法）。 </p><br><p>  Haxe 4最终具有箭头功能（或lambda表达式）！ </p><br><p><img src="https://habrastorage.org/webt/vh/49/oo/vh49oomjlu8y1o1t5cs-jmzv7nm.png" alt="图片"></p><br><p>  Haxe中箭头功能的特点是： </p><br><ul><li> 隐性<code>return</code> 。 如果函数主体包含一个表达式，则此函数隐式返回此表达式的值 </li><li> 可以设置函数参数的类型，因为 编译器无法始终确定所需的类型（例如<code>Float</code>或<code>Int</code> ） </li><li> 如果函数的主体包含多个表达式，则需要用花括号将其括起来 </li><li> 但是无法显式设置函数的返回类型 </li></ul><br><p> 通常，箭头函数的语法与Java 8中使用的语法非常相似（尽管其工作原理有所不同）。 </p><br><p> 而且，由于我们提到了Java，因此应该说在Haxe 4中可以直接生成JVM字节码。 为此，在Java下编译项目时，只需添加<code>-D jvm</code>标志。 </p><br><p> 生成JVM字节码意味着无需使用Java编译器，并且编译过程要快得多。 </p><br><p><img src="https://habrastorage.org/webt/ut/bc/mw/utbcmwnuwk1ade_vqrztz5rzhjk.png" alt="图片"></p><br><p> 到目前为止，由于以下原因，JVM目标具有实验状态： </p><br><ul><li> 在某些情况下，字节码比在Java中翻译Haxe然后使用javac编译的结果要慢一些。 但是编译器团队已经意识到了这个问题，并且知道如何解决它，这只需要额外的工作。 </li><li>  Android上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MethodHandle</a>存在问题，这也需要额外的工作（如果西蒙帮助解决这些问题，他会很高兴）。 </li></ul><br><p><img src="https://habrastorage.org/webt/yo/ho/r5/yohor5rg8cydts1horbcezmqqf0.png" alt="图片"></p><br><p> 直接生成字节码（genjvm）和将Haxe编译为Java代码，然后将其编译为字节码（genjava）的一般比较： </p><br><ul><li> 如前所述，就编译速度而言，genjvm比genjava快 <br> 就执行速度而言，字节码genjvm仍然不如genjava </li><li> 使用类型参数和genjava时存在一些问题 </li><li>  genJvm使用MethodHandle来指代函数，而genjava使用所谓的“ Waneck函数”（以纪念Kaui Vanek，以在Haxe中出现Java和C＃支持）。 尽管使用Waneck函数获得的代码看起来并不漂亮，但是它可以正常工作并且足够快。 </li></ul><br><p> 在Haxe中使用Java的一般技巧： </p><br><ul><li> 由于Java中的垃圾收集器速度很快，因此与之相关的问题很少见。 当然，不断创建新对象并不是一个好主意，但是Java很好地应付了内存管理，并且持续照顾分配的需求并不像Haxe支持的某些其他平台（例如，在HashLink中）那么紧迫。 </li><li> 如果通过结构（ <code>typedef</code> ）完成操作，则访问jvm目标中的类的字段可能会非常缓慢-编译器无法优化此类代码 </li><li> 应避免过度使用<code>inline</code>关键字-JIT编译器做得很好 </li><li> 避免使用<code>Null&lt;T&gt;</code> ，尤其是在处理复杂的数学计算时。 否则，许多条件语句将出现在生成的代码中，这会对代码的速度产生负面影响。 </li></ul><br><p>  Haxe 4的新功能Null安全性可以帮助避免使用<code>Null&lt;T&gt;</code> 。 亚历山大·库兹曼科（Alexander Kuzmenko） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在去年的HaxeUp上</a>详细介绍了她。 </p><br><p><img src="https://habrastorage.org/webt/wx/hk/vk/wxhkvkjk-aq9pjo4mlp6l9hxrzi.png" alt="图片"></p><br><p> 在上一张幻灯片的示例中，static <code>safe()</code>方法启用了用于检查Null安全性的严格模式，并且该方法具有可选的<code>arg</code>参数，该参数可以为null值。 为了使该函数成功编译，程序员将需要添加对<code>arg</code>参数值的检查（否则，编译器将显示一条消息，提示无法在可能为null的对象上调用<code>charAt()</code>方法）。 </p><br><p><img src="https://habrastorage.org/webt/sd/mq/md/sdmqmdmuv3lauh3wopzzblnxm8k.png" alt="图片"></p><br><p> 可以在包级别（使用宏），对象的类型和单个字段（使用<code>@:nullSafety</code>元标记）配置Null安全性。 </p><br><p> 空安全性检查的工作模式为：严格，宽松和关闭。 总体而言，这些检查处于禁用状态（关闭模式）。 启用它们时，默认情况下使用“松散”模式（除非您明确指定该模式）。 松散和严格模式之间的主要区别在于，松散模式忽略了在访问这些值的操作之间更改值的可能性。 在下面幻灯片的示例中，我们看到为变量<code>x</code>添加了<code>null</code>检查。 但是，在严格模式下，此代码不会编译，因为 在直接使用变量<code>x</code> ，将<code>sideEffect()</code>方法，该方法可能会使该变量的值无效，因此您将需要添加另一项检查或将变量的值复制到局部变量，我们将继续使用它。 </p><br><p><img src="https://habrastorage.org/webt/m6/sq/6w/m6sq6w1wgue4r9fiylnchvfaxk4.png" alt="图片"></p><br><p>  Haxe 4引入了一个新的<code>final</code>关键字，根据上下文，其含义有所不同： </p><br><ul><li> 如果使用它而不是<code>var</code>关键字，则无法为以此方式声明的字段分配新值。 您只能在声明时（对于静态字段）或在构造函数中（对于非静态字段）直接设置它 </li><li> 如果在声明类时使用它，它将禁止从其继承 </li><li> 如果将它用作访问对象属性的修饰符，则这将禁止在继承类中重新定义getter / setter。 </li></ul><br><p><img src="https://habrastorage.org/webt/fo/je/_6/foje_6ftilhqwsyhnb-zbskf-l8.png" alt="图片"></p><br><p> 从理论上讲，假定该字段的值没有变化，遇到了<code>final</code>关键字的编译器可以尝试优化代码。 但是目前，这种可能性仅在考虑中，尚未在编译器中实现。 </p><br><p><img src="https://habrastorage.org/webt/aa/z_/th/aaz_thozjk6apzimnpf15tsfsja.png" alt="图片"></p><br><p> 关于Haxe的未来： </p><br><ul><li> 当前正在使用异步I / O API <br> 协程支持已经计划好了，但是到目前为止，它们的工作还停留在计划阶段。 也许它们会出现在Haxe 4.1中，甚至以后。 </li><li> 尾部调用优化将出现在编译器中 </li><li> 以及<a href="">模块级可用</a>的<a href="">功能</a> 。 尽管此功能的优先级不断变化 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN474452/">https://habr.com/ru/post/zh-CN474452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN474440/index.html">iOS应用程序中自动续订订阅的收入计算困难</a></li>
<li><a href="../zh-CN474442/index.html">爱尔兰延寿故事</a></li>
<li><a href="../zh-CN474444/index.html">针对开发人员的另外5个大胆的培训项目（层，Squeosh，计算器，网站抓取工具，音乐播放器）</a></li>
<li><a href="../zh-CN474448/index.html">计算机世界中学生的大脑有什么能力</a></li>
<li><a href="../zh-CN474450/index.html">停止为DNS使用非常小的TTL</a></li>
<li><a href="../zh-CN474458/index.html">SQL中的累积总数</a></li>
<li><a href="../zh-CN474460/index.html">使用TableGen的LLVM中的处理器体系结构描述</a></li>
<li><a href="../zh-CN474462/index.html">俄语语音版本1.0的巨大开放数据集</a></li>
<li><a href="../zh-CN474466/index.html">第一部暗黑破坏神的历史</a></li>
<li><a href="../zh-CN474470/index.html">对RDP服务的DDoS攻击：认识并克服。 Tucha的成功经验</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>