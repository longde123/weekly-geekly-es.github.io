<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óæÔ∏è üë®‚Äç‚úàÔ∏è üåü Vis√£o Geral das T√©cnicas de Implementa√ß√£o de Game AI üëΩ ü§õüèΩ üßíüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Este artigo apresentar√° uma ampla gama de conceitos de intelig√™ncia artificial em jogos ("IA de jogos"), para que voc√™ entenda quais f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vis√£o Geral das T√©cnicas de Implementa√ß√£o de Game AI</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420219/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/726/4db/e7b/7264dbe7b1834f3602b36deddc723163.png" alt="imagem"></div><br><h1>  1. Introdu√ß√£o </h1><br>  Este artigo apresentar√° uma ampla gama de conceitos de intelig√™ncia artificial em jogos ("IA de jogos"), para que voc√™ entenda quais ferramentas podem ser usadas para resolver problemas de IA, como elas funcionam juntas e como come√ßar a implement√°-las no mecanismo selecionado. <br><br>  Suponho que voc√™ esteja familiarizado com videogames, um pouco versado em conceitos matem√°ticos como geometria, trigonometria etc.  A maioria dos exemplos de c√≥digo ser√° escrita em pseudoc√≥digo, portanto, voc√™ n√£o precisa conhecer um idioma espec√≠fico. <br><br><h1>  O que √© <i>uma</i> "IA de jogos"? </h1><br>  A IA do jogo lida principalmente com a sele√ß√£o de a√ß√µes de uma entidade, dependendo das condi√ß√µes atuais.  Na literatura tradicional da IA, isso √© chamado de gerenciamento de " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">agentes inteligentes</a> ".  O agente geralmente √© um personagem do jogo, mas pode ser uma m√°quina, um rob√¥ ou at√© algo mais abstrato - um grupo inteiro de entidades, um pa√≠s ou uma civiliza√ß√£o.  De qualquer forma, √© um objeto que monitora seu entorno, toma decis√µes com base nele e age de acordo com essas decis√µes.  √Äs vezes, isso √© chamado de ciclo percep√ß√£o-pensamento-a√ß√£o (Sentir / Pensar / Agir): <br><br><ul><li>  Percep√ß√£o: o agente reconhece - ou √© informado sobre ele - informa√ß√µes sobre o ambiente que podem afetar seu comportamento (por exemplo, perigos pr√≥ximos, itens coletados, pontos importantes etc.) </li><li>  Pensando: o agente decide como responder (por exemplo, decide se √© seguro coletar itens, se deve lutar ou se deve se esconder primeiro) </li><li>  A√ß√£o: o agente executa a√ß√µes para implementar suas decis√µes (por exemplo, come√ßa a se mover ao longo da rota para o inimigo ou para o sujeito, e assim por diante) </li><li>  ... ent√£o, devido √†s a√ß√µes dos personagens, a situa√ß√£o muda, ent√£o o ciclo deve ser repetido com novos dados. </li></ul><a name="habracut"></a><br>  As tarefas de IA do mundo real, especialmente aquelas que s√£o relevantes hoje em dia, geralmente se concentram na "percep√ß√£o".  Por exemplo, ve√≠culos n√£o tripulados devem receber imagens da estrada √† sua frente, combinando-os com outros dados (radar e lidar) e tentando interpretar o que veem.  Normalmente, essa tarefa √© resolvida pelo aprendizado de m√°quina, que funciona especialmente bem com grandes matrizes de dados barulhentos do mundo real (por exemplo, com fotos da estrada em frente ao carro ou alguns quadros de v√≠deo) e d√° a eles algum significado, extraindo informa√ß√µes sem√¢nticas, por exemplo, ‚Äúexistem 20 metros √† minha frente outro carro.  Tais tarefas s√£o chamadas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">problemas de classifica√ß√£o</a> . <br><br>  Os jogos s√£o incomuns, pois n√£o precisam de um sistema complexo para extrair essas informa√ß√µes, pois elas s√£o parte integrante da simula√ß√£o.  N√£o h√° necessidade de executar algoritmos de reconhecimento de imagem para detectar o inimigo √† sua frente;  o jogo <i>sabe</i> que existe um inimigo e pode transmitir essas informa√ß√µes diretamente ao processo de tomada de decis√£o.  Portanto, a ‚Äúpercep√ß√£o‚Äù nesse ciclo √© geralmente bastante simplificada e toda a complexidade surge na implementa√ß√£o de ‚Äúpensamento‚Äù e ‚Äúa√ß√£o‚Äù. <br><br><h1>  Limita√ß√µes do desenvolvimento da IA ‚Äã‚Äãdo jogo </h1><br>  A IA de jogos geralmente leva em considera√ß√£o as seguintes restri√ß√µes: <br><br><ul><li>  Ao contr√°rio do algoritmo de aprendizado de m√°quina, ele geralmente n√£o treina com anteced√™ncia;  ao desenvolver um jogo, n√£o √© pr√°tico escrever uma rede neural para monitorar dezenas de milhares de jogadores, a fim de encontrar a melhor maneira de jogar contra eles, porque o jogo ainda n√£o foi lan√ßado e n√£o possui jogadores! </li><li>  Geralmente, sup√µe-se que o jogo deve divertir e desafiar o jogador, e n√£o ser ‚Äúideal‚Äù - portanto, mesmo que voc√™ possa treinar agentes para resistir da melhor maneira poss√≠vel, os designers precisam de algo diferente deles. </li><li>  Freq√ºentemente, os agentes precisam ter um comportamento "realista" para que os jogadores sintam que est√£o competindo com oponentes semelhantes aos humanos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">O programa AlphaGo</a> acabou sendo muito melhor que as pessoas, mas os movimentos escolhidos est√£o t√£o distantes do entendimento tradicional do jogo que advers√°rios experientes falavam dele como um jogo contra um alien√≠gena.  Se o jogo fingir ser um oponente humano, isso geralmente √© indesej√°vel; portanto, o algoritmo precisa ser configurado para tomar decis√µes <i>plaus√≠veis</i> , e n√£o <i>ideais</i> . </li><li>  A IA deve ser executada em tempo real.  Nesse contexto, isso significa que o algoritmo n√£o pode, por decis√£o, monopolizar os recursos do processador por um longo tempo.  Mesmo 10 milissegundos para tomar uma decis√£o √© demais, porque a maioria dos jogos possui de 16 a 33 milissegundos para concluir todas as opera√ß√µes para o pr√≥ximo quadro do gr√°fico. </li><li>  Idealmente, pelo menos parte do sistema deve depender dos dados e n√£o deve ser codificado para que n√£o-programadores possam fazer altera√ß√µes mais rapidamente. </li></ul><br>  Tendo aprendido tudo isso, podemos come√ßar a considerar abordagens extremamente simples para a cria√ß√£o de IA, que implementam todo o ciclo de "percep√ß√£o-pensamento-a√ß√£o" de maneira a garantir efici√™ncia e permitir que os designers de jogos escolham comportamentos complexos semelhantes √†s a√ß√µes humanas. <br><br><h1>  Tomada de decis√£o f√°cil </h1><br>  Vamos come√ßar com um jogo muito simples, como o Pong.  A tarefa do jogador √© mover a raquete para que a bola salte dela, em vez de passar voando.  As regras s√£o semelhantes ao t√™nis - voc√™ perde se perder a bola.  A IA tem uma tarefa relativamente simples de tomar decis√µes sobre a escolha da dire√ß√£o do movimento da raquete. <br><br><h2>  Constru√ß√µes condicionais codificadas </h2><br>  Se quisermos escrever AI para controlar a raquete, existe uma solu√ß√£o intuitiva e simples - basta mover constantemente a raquete para que fique embaixo da bola.  Quando a bola atinge a raquete, ela j√° est√° em posi√ß√£o perfeita e pode atingi-la. <br><br>  Um algoritmo simples para isso, expresso em pseudo-c√≥digo, pode ser: <br><br><pre>  em cada quadro / atualiza√ß√£o enquanto o jogo est√° em execu√ß√£o:<font></font>
<font></font>
 se a bola estiver √† esquerda da raquete:<font></font>
<font></font>
	 mova a raquete para a esquerda<font></font>
<font></font>
 caso contr√°rio, se a bola estiver √† direita da raquete:<font></font>
<font></font>
	 mova a raquete para a direita </pre><br>  Se assumirmos que a raquete n√£o pode se mover a uma velocidade menor que a bola, esse ser√° o algoritmo perfeito para o jogador de IA em Pong.  Nos casos em que n√£o existem tantos dados de "percep√ß√£o" para processamento e poucas a√ß√µes que o agente possa executar, n√£o precisamos de nada mais complicado. <br><br>  Essa abordagem √© t√£o simples que mal mostra todo o ciclo da "percep√ß√£o-pensamento-a√ß√£o".  Mas ele <i>√©</i> . <br><br><ul><li>  As percep√ß√µes s√£o duas declara√ß√µes if.  O jogo sabe onde est√£o a bola e a raquete.  Portanto, a IA pede ao jogo sua posi√ß√£o, ‚Äúsentindo‚Äù se a bola est√° √† esquerda ou √† direita. </li><li>  O pensamento tamb√©m √© constru√≠do em duas declara√ß√µes if.  Eles cont√™m duas solu√ß√µes, que neste caso s√£o mutuamente exclusivas, levando √† escolha de uma das tr√™s a√ß√µes - mova a raquete para a esquerda, mova para a direita ou n√£o fa√ßa nada se a raquete j√° estiver localizada corretamente. </li><li>  Uma "a√ß√£o" √© "mover a raquete para a esquerda" ou "mover a raquete para a direita".  Dependendo de como o jogo √© implementado, isso pode assumir a forma de mover instantaneamente a posi√ß√£o da raquete ou definir a velocidade e a dire√ß√£o da raquete para que ela possa ser alterada corretamente em outro c√≥digo do jogo. </li></ul><br>  Tais abordagens s√£o frequentemente chamadas de "reativas" porque existe um conjunto simples de regras (no nosso caso, s√£o declara√ß√µes "if" no c√≥digo) que respondem ao estado do mundo e decidem instantaneamente como proceder. <br><br><h2>  √Årvores de decis√£o </h2><br>  Este exemplo de Pong √© realmente semelhante ao conceito formal de IA chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvore de decis√£o</a> .  Este √© um sistema no qual as decis√µes s√£o organizadas na forma de uma √°rvore e o algoritmo deve contorn√°-lo para alcan√ßar uma "planilha" contendo a decis√£o final sobre a a√ß√£o escolhida.  Vamos desenhar uma representa√ß√£o gr√°fica da √°rvore de decis√£o para o algoritmo de raquete Pong usando um fluxograma: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34e/4a2/17e/34e4a217e703a6af9b51b5cfbec7370f.png"></div><br>  Pode-se ver que se assemelha a uma √°rvore, apenas de cabe√ßa para baixo! <br><br>  Cada parte da √°rvore de decis√£o √© geralmente chamada de "n√≥" porque, na IA, a teoria dos grafos √© usada para descrever essas estruturas.  Cada n√≥ pode ser um de dois tipos: <br><br><ol><li>  N√≥s de solu√ß√µes: a escolha de duas alternativas com base na verifica√ß√£o de uma condi√ß√£o.  Cada alternativa √© apresentada como seu pr√≥prio n√≥; </li><li>  N√≥s finais: uma a√ß√£o executada que representa a decis√£o final tomada pela √°rvore. </li></ol><br>  O algoritmo inicia a partir do primeiro n√≥ designado pela "raiz" da √°rvore, ap√≥s o qual decide para qual n√≥ filho acessar com base na condi√ß√£o ou executa a a√ß√£o armazenada no n√≥ e para de funcionar. <br><br>  √Ä primeira vista, a vantagem da √°rvore de decis√£o n√£o √© √≥bvia, porque ela faz exatamente o mesmo trabalho que as instru√ß√µes if da se√ß√£o anterior.  Mas existe um sistema muito geral no qual cada solu√ß√£o tem exatamente 1 condi√ß√£o e 2 resultados poss√≠veis, o que permite ao desenvolvedor criar AI a partir dos dados que representam as solu√ß√µes na √°rvore e evitar escrev√™-las no c√≥digo.  √â f√°cil imaginar um formato de dados simples para descrever uma √°rvore: <br><br><table><tbody><tr><td>  <b>N√∫mero do n√≥</b> </td><td>  <b>Decis√£o (ou "fim")</b> </td><td>  <b>Ac√ß√£o</b> </td><td>  <b>Ac√ß√£o</b> </td></tr><tr><td>  1 </td><td>  A bola √† esquerda da raquete? </td><td>  Hein?  Verifique o n√≥ 2 </td><td>  N√£o?  Verifique o n√≥ 3 </td></tr><tr><td>  2 </td><td>  <i>O fim</i> </td><td colspan="2">  Mover raquete para a esquerda </td></tr><tr><td>  3 </td><td>  A bola √† direita da raquete? </td><td>  Hein?  V√° para o n√≥ 4 </td><td>  N√£o?  V√° para o n√≥ 5 </td></tr><tr><td>  4 </td><td>  <i>O fim</i> </td><td colspan="2">  Mova a raquete para a direita </td></tr><tr><td>  5 </td><td>  <i>O fim</i> </td><td colspan="2">  N√£o fa√ßa nada </td></tr></tbody></table><br>  Do ponto de vista do c√≥digo, precisamos for√ßar o sistema a ler cada uma dessas linhas, criar para cada n√≥, anexar a l√≥gica de decis√£o com base na segunda coluna e anexar n√≥s filhos com base na terceira e quarta colunas.  Ainda precisamos definir manualmente manualmente as condi√ß√µes e a√ß√µes, mas agora podemos imaginar um jogo mais complexo no qual voc√™ pode adicionar novas solu√ß√µes e a√ß√µes, al√©m de configurar toda a IA alterando o √∫nico arquivo de texto que cont√©m a defini√ß√£o da √°rvore.  Podemos transferir o arquivo para o designer do jogo, que poder√° personalizar o comportamento sem a necessidade de recompilar o jogo e alterar o c√≥digo - desde que o c√≥digo j√° tenha condi√ß√µes e a√ß√µes √∫teis. <br><br>  As √°rvores de decis√£o podem ser muito poderosas quando s√£o constru√≠das automaticamente com base em um grande n√∫mero de exemplos (por exemplo, usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o algoritmo ID3</a> ).  Isso os torna uma ferramenta eficaz e de alto desempenho para classificar a situa√ß√£o com base nos dados recebidos, mas este t√≥pico est√° al√©m do escopo dos designers para criar sistemas simples para selecionar a√ß√µes para agentes. <br><br><h2>  Script </h2><br>  Acima, examinamos um sistema de √°rvore de decis√£o que usa condi√ß√µes e a√ß√µes pr√©-criadas.  O desenvolvedor de IA pode reconstruir a √°rvore da maneira que precisar, mas deve confiar no fato de que o programador j√° criou todas as condi√ß√µes e a√ß√µes necess√°rias para ele.  Mas e se dermos ao designer ferramentas mais poderosas que lhe permitem criar suas pr√≥prias condi√ß√µes e talvez suas a√ß√µes? <br><br>  Por exemplo, em vez de for√ßar o codificador a escrever as condi√ß√µes "Bola √† esquerda da raquete?"  e "A bola √† direita da raquete?", ele pode simplesmente criar um sistema no qual o designer escreve independentemente as condi√ß√µes para verificar esses valores.  Como resultado, os dados da √°rvore de decis√£o podem ficar assim: <br><br><table><tbody><tr><td>  <b>N√∫mero do n√≥</b> </td><td>  <b>Decis√£o (ou "fim")</b> </td><td>  <b>Solu√ß√£o</b> </td><td>  <b>Ac√ß√£o</b> </td></tr><tr><td>  1 </td><td>  <b>ball.position.x &lt;paddle.position.x</b> </td><td>  Hein?  Verifique o n√≥ 2 </td><td>  N√£o?  Verifique o n√≥ 3 </td></tr><tr><td>  2 </td><td>  <i>O fim</i> </td><td colspan="2">  Mover raquete para a esquerda </td></tr><tr><td>  3 </td><td>  <b>ball.position.x&gt; paddle.position.x</b> </td><td>  Hein?  Verifique o n√≥ 4 </td><td>  N√£o?  Verifique o n√≥ 5 </td></tr><tr><td>  4 </td><td>  <i>O fim</i> </td><td colspan="2">  Mova a raquete para a direita </td></tr><tr><td>  5 </td><td>  <i>O fim</i> </td><td colspan="2">  N√£o fa√ßa nada </td></tr></tbody></table><br>  O mesmo de antes, mas agora as solu√ß√µes t√™m seu pr√≥prio c√≥digo, semelhante √† parte condicional da instru√ß√£o if.  O c√≥digo ler√° os n√≥s de decis√£o da segunda coluna e, em vez de procurar uma condi√ß√£o espec√≠fica (por exemplo, ‚Äúa bola √† esquerda da raquete?‚Äù), Calcule a express√£o condicional e retorne verdadeiro ou falso.  Isso pode ser implementado incorporando uma <i>linguagem de script</i> , como Lua ou Angelscript, que permite ao desenvolvedor pegar objetos do jogo (por exemplo, uma bola e uma raquete) e criar vari√°veis ‚Äã‚Äãacess√≠veis a partir do script (por exemplo, ball.position).  Geralmente, √© mais f√°cil escrever em uma linguagem de script do que em C ++, e n√£o requer um est√°gio completo de compila√ß√£o; portanto, √© adequado para fazer altera√ß√µes r√°pidas na l√≥gica do jogo e permite que membros da equipe com menos conhecimento t√©cnico criem fun√ß√µes de jogo sem a interven√ß√£o de um codificador. <br><br>  No exemplo acima, a linguagem de script √© usada apenas para avaliar a express√£o condicional, mas as a√ß√µes finais tamb√©m podem ser descritas no script.  Por exemplo, essas a√ß√µes do tipo ‚Äúmover a raquete para a direita‚Äù podem se tornar uma constru√ß√£o de script como <code>ball.position.x += 10</code> , ou seja, a a√ß√£o tamb√©m √© definida no script sem escrever o c√≥digo da fun√ß√£o MovePaddleRight. <br><br>  Se voc√™ der outro passo √† frente, poder√° (e isso geralmente √© feito) chegar √† sua conclus√£o l√≥gica e escrever toda a √°rvore de decis√£o em uma linguagem de script, e n√£o como uma lista de linhas de dados.  Este ser√° um c√≥digo semelhante √†s constru√ß√µes condicionais mostradas acima, apenas que n√£o s√£o "codificadas" - elas est√£o em arquivos de script externos, ou seja, podem ser alteradas sem recompilar o programa inteiro.  Muitas vezes, √© at√© poss√≠vel modificar o arquivo de script durante a execu√ß√£o do jogo, o que permite que os desenvolvedores testem rapidamente v√°rias abordagens para a implementa√ß√£o da IA. <br><br><h2>  Rea√ß√£o a eventos </h2><br>  Os exemplos mostrados acima destinam-se √† execu√ß√£o de quadro √∫nico em jogos simples como o Pong.  A id√©ia √© que eles realizem continuamente um ciclo de "percep√ß√£o-pensamento-a√ß√£o" e continuem a agir com base no √∫ltimo estado do mundo.  Mas em jogos mais complexos, em vez de computar, geralmente √© mais razo√°vel reagir a "eventos", isto √©, a mudan√ßas importantes no ambiente do jogo. <br><br>  Isso n√£o √© particularmente aplic√°vel ao Pong, ent√£o vamos escolher outro exemplo.  Imagine um jogo de tiro em que os inimigos ficam im√≥veis at√© encontrar um jogador, ap√≥s o que come√ßam a executar a√ß√µes dependendo da classe - os lutadores corpo a corpo podem correr em dire√ß√£o ao jogador, e os franco-atiradores ficam √† dist√¢ncia e tentam mirar.  Em ess√™ncia, este √© um sistema reativo simples - ‚Äúse vemos um jogador, fazemos alguma coisa‚Äù - mas pode ser logicamente dividido em um evento (‚Äúver um jogador‚Äù) e rea√ß√£o (selecione uma resposta e execute-a). <br><br>  Isso nos leva de volta ao ciclo percep√ß√£o-pensamento-a√ß√£o.  Podemos ter um fragmento de c√≥digo, que √© um c√≥digo de "percep√ß√£o", que verifica em cada quadro se o inimigo v√™ o jogador.  Caso contr√°rio, nada acontece.  Mas se ele v√™, isso cria um evento "veja o jogador".  O c√≥digo ter√° uma parte separada, que diz: "quando o evento" ver o jogador "ocorrer, faremos" xyz "e" xyz "√© qualquer resposta que queremos processar pensamento e a√ß√£o.  Para um lutador de personagens, voc√™ pode conectar a resposta de corrida e ataque ao evento "ver o jogador".  Para o atirador, conectaremos a fun√ß√£o de resposta "ocultar e apontar" a esse evento.  Como nos exemplos anteriores, podemos criar essas associa√ß√µes no arquivo de dados para que possam ser alteradas rapidamente sem reconstruir o mecanismo.  Al√©m disso, √© poss√≠vel (e isso geralmente √© usado) escrever essas fun√ß√µes de resposta em uma linguagem de script para que elas possam criar solu√ß√µes complexas quando ocorrerem eventos. <br><br><h1>  Melhor tomada de decis√£o </h1><br>  Embora os sistemas reativos simples sejam muito poderosos, h√° muitas situa√ß√µes em que n√£o s√£o suficientes.  √Äs vezes, precisamos tomar decis√µes diferentes com base no que o agente est√° fazendo no momento e apresent√°-lo como uma condi√ß√£o √© inconveniente.  √Äs vezes, existem simplesmente muitas condi√ß√µes para apresent√°-las efetivamente na forma de uma √°rvore ou script de decis√£o.  √Äs vezes, precisamos pensar com anteced√™ncia e avaliar como a situa√ß√£o mudar√° antes de decidir o pr√≥ximo passo.  Para tais tarefas, s√£o necess√°rias solu√ß√µes mais complexas. <br><br><h2>  M√°quinas de estado </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uma</a> m√°quina de estados finitos (FSM) √© uma maneira de dizer em outras palavras que algum objeto - digamos, um de nossos agentes de IA - est√° atualmente em um dos v√°rios estados poss√≠veis e pode ir de um estado para outro.  H√° um n√∫mero finito de tais estados, da√≠ o nome.  Um exemplo do mundo real √© o conjunto de sem√°foros, passando de vermelho para amarelo, depois para verde e novamente para tr√°s.  Em lugares diferentes, existem sequ√™ncias diferentes de luzes, mas o princ√≠pio √© o mesmo - cada estado significa algo ("stand", "eat", "stand, se poss√≠vel" etc.), a qualquer momento existe apenas um estado, e as transi√ß√µes entre eles s√£o baseadas em regras simples. <br><br>  Isso se aplica bem aos NPCs nos jogos.  O guarda pode ter os seguintes estados claramente separados: <br><br><ul><li>  Patrulha </li><li>  Assalto </li><li>  V√¥o </li></ul><br>  E podemos criar as seguintes regras para a transi√ß√£o entre estados: <br><br><ul><li>  Se o guarda v√™ o inimigo, ele ataca </li><li>  Se o guarda ataca, mas n√£o v√™ mais o inimigo, ele volta a patrulhar </li><li>  Se um guarda ataca mas est√° gravemente ferido, ele escapa </li></ul><br>  Esse esquema √© bastante simples e podemos anot√°-lo com operadores "se" estritamente definidos e uma vari√°vel na qual o estado do guarda de seguran√ßa e v√°rias verifica√ß√µes ser√£o armazenados - a presen√ßa de inimigos pr√≥ximos, o n√≠vel de sa√∫de do guarda de seguran√ßa etc.  Mas imagine que precisamos adicionar mais alguns estados: <br><br><ul><li>  Esperando (entre patrulhas) </li><li>  Pesquisa (quando o inimigo visto anteriormente se escondeu) </li><li>  Escapar por ajuda (quando o inimigo √© visto, mas ele √© forte demais para lutar com ele sozinho) </li></ul><br>  E as op√ß√µes dispon√≠veis em cada estado s√£o geralmente limitadas - por exemplo, um guarda provavelmente n√£o vai querer procurar por um inimigo que se perdeu de vista se sua sa√∫de estiver muito baixa. <br><br>  Cedo ou tarde, a longa lista de "se &lt;x e y, mas n√£o z&gt; ent√£o &lt;p&gt;" se torna muito embara√ßosa, e uma abordagem formalizada para a implementa√ß√£o de estados e transi√ß√µes entre eles pode ajudar aqui.  Para fazer isso, consideramos todos os estados e, em cada estado, listamos todas as transi√ß√µes para outros estados, juntamente com as condi√ß√µes necess√°rias para eles.  Tamb√©m precisamos indicar o estado inicial para que possamos saber por onde come√ßar antes de aplicar outras condi√ß√µes. <br><br><table><tbody><tr><td>  <b>Condi√ß√£o</b> </td><td>  <b>Condi√ß√£o de transi√ß√£o</b> </td><td>  <b>Nova condi√ß√£o</b> </td></tr><tr><td rowspan="4">  Esperando </td><td>  esperado por 10 segundos </td><td>  Patrulha </td></tr><tr><td>  o inimigo √© vis√≠vel e o inimigo √© muito forte </td><td>  Ajuda Pesquisa </td></tr><tr><td>  o inimigo √© vis√≠vel e muita sa√∫de </td><td>  Assalto </td></tr><tr><td>  o inimigo √© vis√≠vel e com pouca sa√∫de </td><td>  V√¥o </td></tr><tr><td rowspan="4">  Patrulha </td><td>  rota de patrulha conclu√≠da </td><td>  Esperando </td></tr><tr><td>  o inimigo √© vis√≠vel e o inimigo √© muito forte </td><td>  Ajuda Pesquisa </td></tr><tr><td>  o inimigo √© vis√≠vel e muita sa√∫de </td><td>  Assalto </td></tr><tr><td>  o inimigo √© vis√≠vel e com pouca sa√∫de </td><td>  V√¥o </td></tr><tr><td rowspan="2">  Assalto </td><td>  o inimigo n√£o √© vis√≠vel </td><td>  Esperando </td></tr><tr><td>  pouca sa√∫de </td><td>  V√¥o </td></tr><tr><td>  V√¥o </td><td>  o inimigo n√£o √© vis√≠vel </td><td>  Esperando </td></tr><tr><td rowspan="4">  Pesquisar </td><td>  procurou por 10 segundos </td><td>  Esperando </td></tr><tr><td>  o inimigo √© vis√≠vel e o inimigo √© muito forte </td><td>  Ajuda Pesquisa </td></tr><tr><td>  o inimigo √© vis√≠vel e muita sa√∫de </td><td>  Assalto </td></tr><tr><td>  o inimigo √© vis√≠vel e com pouca sa√∫de </td><td>  V√¥o </td></tr><tr><td>  Ajuda Pesquisa </td><td>  amigo ver </td><td>  Assalto </td></tr><tr><td colspan="3">  <i>Estado inicial: aguardando</i> </td></tr></tbody></table><br>  Esse esquema √© chamado de tabela de transi√ß√£o de estado.  √â uma maneira complexa (e pouco atraente) de representar uma espa√ßonave.  A partir desses dados, voc√™ tamb√©m pode desenhar um diagrama e obter uma representa√ß√£o gr√°fica complexa de como pode ser o comportamento dos NPCs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/a7b/262/ee0a7b2621204b58f17703a71b78ed67.png"></div><br>  Ele captura a pr√≥pria ess√™ncia de tomar decis√µes para o agente com base na situa√ß√£o em que ele est√°.  Cada seta indica uma transi√ß√£o entre estados se a condi√ß√£o ao lado da seta for verdadeira. <br><br>  A cada atualiza√ß√£o (ou ‚Äúciclo‚Äù), verificamos o estado atual do agente, observamos a lista de transi√ß√µes e, se a condi√ß√£o de transi√ß√£o for atendida, passamos para um novo estado.  O estado Pendente verifica em cada quadro ou ciclo se o temporizador de 10 segundos expirou.  Se expirado, inicia a transi√ß√£o para o estado "Patrulha".  Da mesma forma, o estado "Ataque" verifica se o agente tem muita sa√∫de e, nesse caso, faz a transi√ß√£o para o estado "V√¥o". <br><br>  √â assim que as transi√ß√µes de estado s√£o tratadas - mas e os comportamentos associados aos pr√≥prios estados?  Do ponto de vista da execu√ß√£o das pr√≥prias a√ß√µes para um estado, geralmente existem dois tipos de a√ß√µes anexadas a uma espa√ßonave: <br><br><ol><li>  A√ß√µes para o estado atual s√£o realizadas periodicamente, por exemplo, em cada quadro ou "ciclo". </li><li>  As a√ß√µes s√£o executadas durante a transi√ß√£o de um estado para outro. </li></ol><br><br>  Um exemplo do primeiro tipo: o estado "Patrulha" em cada quadro ou ciclo continua a mover o agente ao longo da rota de patrulha.  O estado "Ataque" em cada quadro ou ciclo tenta iniciar um ataque ou mov√™-lo para uma posi√ß√£o de onde √© poss√≠vel.  E assim por diante <br><br>  Um exemplo do segundo tipo: considere a transi√ß√£o "se o inimigo estiver vis√≠vel e o inimigo for muito forte ‚Üí Procure ajuda".  O agente deve escolher para onde se deslocar para procurar ajuda e armazenar essas informa√ß√µes para que o estado ‚ÄúPesquisa de Ajuda‚Äù saiba para onde ir.  Da mesma forma, no estado "Pesquisa de Ajuda", quando a ajuda √© encontrada, o agente retorna ao estado "Ataque" novamente, mas neste momento ele deseja informar o personagem amig√°vel sobre a amea√ßa, para que possa haver uma a√ß√£o "informe um amigo sobre o perigo" realizada durante essa transi√ß√£o. <br><br>  E aqui podemos novamente considerar esse sistema do ponto de vista da "percep√ß√£o-pensamento-a√ß√£o".  A percep√ß√£o √© incorporada nos dados usados ‚Äã‚Äãpela l√≥gica de transi√ß√£o.  O pensamento est√° incorporado nas transi√ß√µes dispon√≠veis para cada estado.  E a a√ß√£o √© executada por a√ß√µes realizadas periodicamente em um estado ou durante a transi√ß√£o entre estados. <br><br>  Esse sistema simples funciona bem, embora algumas vezes as condi√ß√µes de transi√ß√£o da sondagem constante possam ser um processo caro.  Por exemplo, se cada agente precisar executar c√°lculos complexos em cada quadro para determinar a visibilidade dos inimigos e decidir sobre a transi√ß√£o do patrulhamento para o ataque, isso poder√° levar muito tempo no processador.  Como vimos anteriormente, √© poss√≠vel perceber mudan√ßas importantes no estado do mundo como "eventos" que s√£o processados ‚Äã‚Äãap√≥s a ocorr√™ncia.  Portanto, em vez de verificar explicitamente a condi√ß√£o de transi√ß√£o "meu agente pode ver o player?" Em cada quadro, podemos criar um sistema de visibilidade separado que executa essas verifica√ß√µes com menos frequ√™ncia (por exemplo, 5 vezes por segundo) e cria o "player ver ‚Äùquando o teste √© acionado.  Ele √© transmitido para a m√°quina de estado, que agora tem a condi√ß√£o para a transi√ß√£o "Recebeu o evento" jogador v√™ "" e responde a isso de acordo.  O comportamento resultante ser√° semelhante, com exce√ß√£o de um atraso de rea√ß√£o quase impercept√≠vel (e at√© crescente), mas a produtividade aumentar√° devido √† transfer√™ncia de "percep√ß√£o" para uma parte separada do programa. <br><br><h2>  M√°quinas de estado hier√°rquico </h2><br>  Tudo isso √© bom, mas com grandes m√°quinas de estado, torna-se muito inconveniente trabalhar.  Se quisermos expandir o estado de "Ataque", substituindo-o por estados separados de "Ataque corpo a corpo" e "Ataque de longe", teremos que alterar as transi√ß√µes recebidas de cada estado, presente e futuro, que precisa da capacidade de mudar para o estado "Ataque". <br><br>  Voc√™ provavelmente tamb√©m percebeu que em nosso exemplo existem muitas transi√ß√µes duplicadas.  A maioria das transi√ß√µes no estado "Pendente" √© id√™ntica √† do estado "Patrulha", e seria bom evitar a duplica√ß√£o deste trabalho, especialmente se queremos adicionar estados ainda mais semelhantes.  Ser√° l√≥gico combinar ‚ÄúWaiting‚Äù e ‚ÄúPatrolling‚Äù em algum grupo ‚ÄúNon-combat states‚Äù, que possui apenas um conjunto comum de transi√ß√µes para combater estados.  Se apresentarmos esse grupo como um estado, podemos considerar o item ‚ÄúAguardando‚Äù e ‚ÄúPatrulhando‚Äù como ‚Äúsubestados‚Äù desse estado, o que nos permitir√° descrever de maneira mais eficaz o sistema inteiro.  Um exemplo de uso de uma tabela de convers√£o separada para um novo subestado que n√£o seja de combate: <br><br>  <b><i>As principais condi√ß√µes:</i></b> <br><br><table><tbody><tr><td>  <b>Condi√ß√£o</b> </td><td>  <b>Condi√ß√£o de transi√ß√£o</b> </td><td>  <b>Nova condi√ß√£o</b> </td></tr><tr><td rowspan="3">  N√£o combate </td><td>  o inimigo √© vis√≠vel e o inimigo √© muito forte </td><td>  Ajuda Pesquisa </td></tr><tr><td>  o inimigo √© vis√≠vel e muita sa√∫de </td><td>  Assalto </td></tr><tr><td>  o inimigo √© vis√≠vel e com pouca sa√∫de </td><td>  V√¥o </td></tr><tr><td rowspan="2">  Assalto </td><td>  o inimigo n√£o √© vis√≠vel </td><td>  N√£o combate </td></tr><tr><td>  pouca sa√∫de </td><td>  V√¥o </td></tr><tr><td>  V√¥o </td><td>  o inimigo n√£o √© vis√≠vel </td><td>  N√£o combate </td></tr><tr><td rowspan="4">  Pesquisar </td><td>  procurou por 10 segundos </td><td>  N√£o combate </td></tr><tr><td>  o inimigo √© vis√≠vel e o inimigo √© muito forte </td><td>  Ajuda Pesquisa </td></tr><tr><td>  o inimigo √© vis√≠vel e muita sa√∫de </td><td>  Assalto </td></tr><tr><td>  o inimigo √© vis√≠vel e com pouca sa√∫de </td><td>  V√¥o </td></tr><tr><td>  Ajuda Pesquisa </td><td>  amigo ver </td><td>  Assalto </td></tr><tr><td colspan="3">  <i>Estado inicial: n√£o combate</i> </td></tr></tbody></table><br>  <b><i>Status de n√£o combate:</i></b> <br><br><table><tbody><tr><td>  <b>Condi√ß√£o</b> </td><td>  <b>Condi√ß√£o de transi√ß√£o</b> <br><br></td><td>  <b>Nova condi√ß√£o</b> <br><br></td></tr><tr><td>  Esperando </td><td>  esperado por 10 segundos </td><td>  Patrulha </td></tr><tr><td>  Patrulha </td><td>  completou a rota de patrulha </td><td>  Esperando </td></tr><tr><td colspan="3">  <i>Estado inicial: aguardando</i> </td></tr></tbody></table><br>  E em forma de gr√°fico: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/7a0/21f/2407a021fd5e60c214d79069b86148d4.png"></div><br>  De fato, esse √© o mesmo sistema, s√≥ que agora existe um estado de n√£o combate que substitui "Patrulha" e "Espera", que por si s√≥ √© uma m√°quina de estado com dois subestados de patrulha e espera.  Se cada estado puder potencialmente conter uma m√°quina de estado de subestados (e esses subestados tamb√©m podem conter sua pr√≥pria m√°quina de estado e assim por diante), teremos uma m√°quina de estado hier√°rquica (HFSM).  Ao agrupar comportamentos que n√£o s√£o de combate, cortamos v√°rias transi√ß√µes desnecess√°rias e podemos fazer o mesmo para quaisquer novos estados que possam ter transi√ß√µes comuns.  Por exemplo, se no futuro expandirmos o estado "Ataque" para os estados "Ataque corpo a corpo" e "Ataque de proj√©til", eles podem ser subestados, cuja transi√ß√£o se baseia na dist√¢ncia do inimigo e na presen√ßa de muni√ß√£o, que t√™m transi√ß√µes de sa√≠da comuns com base nos n√≠veis de sa√∫de e outras coisas  Assim, com um m√≠nimo de transi√ß√µes duplicadas, comportamentos e sub-comportamentos complexos podem ser representados. <br><br><h2>  √Årvores de comportamento </h2><br>  Com o HFSM, conseguimos criar conjuntos de comportamentos bastante complexos de uma maneira bastante intuitiva.  No entanto, √© imediatamente percept√≠vel que a tomada de decis√£o na forma de regras de transi√ß√£o est√° intimamente relacionada ao estado atual.  Muitos jogos exigem exatamente isso.  E o uso cuidadoso da hierarquia de estados reduz o n√∫mero de transi√ß√µes duplicadas.  Mas, √†s vezes, precisamos de regras que se apliquem independentemente do estado atual ou em quase todos os estados.  Por exemplo, se a sa√∫de do agente caiu para 25%, ele pode querer fugir, independentemente de estar em batalha, esperando ou conversando ou em qualquer outro estado.  N√£o queremos lembrar que precisamos adicionar essa condi√ß√£o a cada estado que possamos adicionar ao personagem no futuro.  Portanto, quando o designer posteriormente disser que deseja alterar o valor do limite de 25% para 10%, n√£o precisaremos resolver e alterar cada transi√ß√£o correspondente. <br><br>  Ideal em tal situa√ß√£o, era um sistema no qual as decis√µes sobre qual estado existisse separadamente dos pr√≥prios estados, para que pud√©ssemos alterar apenas um elemento e as transi√ß√µes ainda fossem processadas corretamente.  √â aqui que as √°rvores de comportamento s√£o √∫teis. <br><br>  Existem v√°rias maneiras de implementar √°rvores comportamentais, mas a ess√™ncia √© a mesma para a maioria e muito semelhante √† √°rvore de decis√£o mencionada acima: o algoritmo come√ßa a funcionar a partir do "n√≥ raiz" e h√° n√≥s na √°rvore que indicam decis√µes ou a√ß√µes.  No entanto, existem diferen√ßas importantes: <br><br><ul><li>  Os n√≥s agora retornam um dos tr√™s valores: "bem-sucedido" (se o trabalho for conclu√≠do), "sem √™xito" (se o trabalho n√£o foi conclu√≠do) ou "realizado" (se o trabalho ainda estiver sendo conclu√≠do e n√£o tiver sido completamente bem-sucedido ou falhar). </li><li>  Agora, n√£o temos n√≥s de decis√£o nos quais escolhemos duas alternativas, mas existem n√≥s decoradores com um √∫nico n√≥ filho.  Se eles forem "bem-sucedidos", eles executam seu √∫nico n√≥ filho.  Os n√≥s do decorador geralmente cont√™m condi√ß√µes que determinam se a execu√ß√£o foi conclu√≠da com √™xito (o que significa que voc√™ precisa executar a sub√°rvore) ou falha (ent√£o nada precisa ser feito).  Eles tamb√©m podem retornar "em andamento". </li><li>  N√≥s de a√ß√µes em execu√ß√£o retornam um valor "running" para indicar o que est√° acontecendo. </li></ul><br>  Um pequeno conjunto de n√≥s pode ser combinado, criando um grande n√∫mero de comportamentos complexos e, muitas vezes, esse esquema √© muito breve.  Por exemplo, podemos reescrever a CA hier√°rquica da guarda do exemplo anterior na forma de uma √°rvore de comportamento: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b9/0f2/d18/9b90f2d18ce7b78b8a9a0673b8cde3d2.png"></div><br>  Ao usar essa estrutura, n√£o h√° necessidade de uma transi√ß√£o expl√≠cita dos estados "Em espera" ou "Patrulha" para os estados "Ataque" ou outros - se a √°rvore for atravessada de cima para baixo e da esquerda para a direita, a decis√£o correta ser√° tomada com base na situa√ß√£o atual.  Se o inimigo estiver vis√≠vel e o personagem tiver pouca sa√∫de, a √°rvore completar√° a corrida no n√≥ "V√¥o", independentemente do n√≥ completo anterior ("Patrulha", "Espera", "Ataque" etc.). <br><br>  Voc√™ pode perceber que ainda n√£o temos uma transi√ß√£o para retornar ao estado "Aguardando" de "Patrulha" - e aqui os decoradores incondicionais ser√£o √∫teis.  O n√≥ do decorador padr√£o √© "Repetir" - ele n√£o tem condi√ß√µes, apenas intercepta o n√≥ filho que retorna "com √™xito" e executa o n√≥ filho novamente, retornando "executado".  A nova √°rvore fica assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/187/487/d73/187487d733f1db9e07920b0475894bb4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As √°rvores comportamentais s√£o bastante complexas porque geralmente existem muitas maneiras diferentes de criar uma √°rvore, e encontrar a combina√ß√£o certa de decorador e n√≥s de componentes pode ser uma tarefa assustadora. Tamb√©m h√° problemas com a frequ√™ncia com que precisamos verificar a √°rvore (queremos atravess√°-la a cada quadro ou quando algo acontece que possa afetar as condi√ß√µes?) E como armazenar o estado em rela√ß√£o aos n√≥s (como sabemos que esperamos 10 segundos? descobriremos quantos n√≥s foram executados pela √∫ltima vez para concluir corretamente a sequ√™ncia?) Portanto, existem muitas implementa√ß√µes diferentes. Por exemplo, em alguns sistemas, como o sistema de √°rvore de comportamento do Unreal Engine 4, os n√≥s do decorador s√£o substitu√≠dos por decoradores de sequ√™ncia de caracteres que verificam a √°rvore somente quando as condi√ß√µes do decorador mudam e fornecem "servi√ßos",que pode ser conectado aos n√≥s e fornecer atualiza√ß√µes peri√≥dicas mesmo quando a √°rvore n√£o √© verificada novamente. As √°rvores comportamentais s√£o ferramentas poderosas, mas aprender a us√°-las corretamente, especialmente com tantas implementa√ß√µes diferentes, pode ser uma tarefa assustadora.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sistemas Baseados em Utilit√°rios </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alguns jogos exigem a exist√™ncia de muitas a√ß√µes diferentes; portanto, exigem regras de transi√ß√£o mais simples e centralizadas, mas n√£o precisam do poder de implementar completamente a √°rvore de comportamento. </font><font style="vertical-align: inherit;">Em vez de criar um conjunto expl√≠cito de op√ß√µes ou uma √°rvore de a√ß√µes em potencial com posi√ß√µes impl√≠citas de fallback definidas pela estrutura da √°rvore, talvez seja melhor simplesmente examinar todas as a√ß√µes e escolher a que √© mais aplic√°vel no momento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â isso que os sistemas baseados em utilidade fazem - esses s√£o sistemas nos quais o agente tem muitas a√ß√µes √† sua disposi√ß√£o e ele escolhe executar uma baseada em </font><i><font style="vertical-align: inherit;">utilidade</font></i><font style="vertical-align: inherit;"> relativa</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toda a√ß√£o. A utilidade aqui √© uma medida arbitr√°ria de import√¢ncia ou conveni√™ncia para um agente executar essa a√ß√£o. Escrevendo fun√ß√µes de utilit√°rio para calcular a utilidade de uma a√ß√£o com base no estado atual do agente e seu ambiente, o agente pode verificar os valores do utilit√°rio e selecionar o estado mais apropriado no momento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso tamb√©m √© muito parecido com uma m√°quina de estados finitos, exceto que as transi√ß√µes s√£o determinadas por uma avalia√ß√£o de cada estado potencial, incluindo o atual. Vale a pena notar que, no caso geral, escolhemos a transi√ß√£o para a a√ß√£o mais valiosa (ou estar nela, se j√° estamos realizando essa a√ß√£o), mas, para maior variabilidade, pode ser uma escolha aleat√≥ria ponderada (priorizando a a√ß√£o mais valiosa, mas permitindo a escolha de outras pessoas) , uma escolha de a√ß√£o aleat√≥ria entre as cinco principais (ou qualquer outra quantidade) etc.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O sistema padr√£o baseado em utilidade atribui um certo intervalo arbitr√°rio de valores de utilidade - digamos de 0 (completamente indesej√°vel) a 100 (absolutamente desej√°vel), e cada a√ß√£o pode ter um conjunto de fatores que influenciam a maneira como o valor √© calculado. </font><font style="vertical-align: inherit;">Voltando ao nosso exemplo com o guarda, podemos imaginar algo assim:</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ac√ß√£o</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√°lculo de utilidade</font></font></b> <br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajuda Pesquisa</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se o inimigo estiver vis√≠vel e o inimigo for forte e a sa√∫de estiver baixa, retorne 100, caso contr√°rio, retorne 0 </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√¥o</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se o inimigo estiver vis√≠vel e tiver pouca sa√∫de, retorne 90, caso contr√°rio, retorne 0 </font></font><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assalto</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se o inimigo estiver vis√≠vel, retorne 80 </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esperando</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se estamos em um estado de espera e j√° esperamos 10 segundos, retorne 0, caso contr√°rio, 50 </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patrulha</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se estivermos no final da rota de patrulha, retorne 0, caso contr√°rio, 50 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dos aspectos mais importantes desse esquema √© que as transi√ß√µes entre a√ß√µes s√£o expressas implicitamente - de qualquer estado que voc√™ possa legitimamente ir para outro. Al√©m disso, as prioridades de a√ß√£o est√£o impl√≠citas nos valores de utilidade retornados. Se o inimigo estiver vis√≠vel, e se ele for forte e o personagem tiver pouca sa√∫de, valores diferentes de zero retornar√£o a </font><i><font style="vertical-align: inherit;">Pesquisa de </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√¥o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajuda</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquisa de Ajuda</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sempre tem uma classifica√ß√£o mais alta. Da mesma forma, as a√ß√µes que n√£o s√£o de combate nunca retornam mais de 50, por isso s√£o sempre derrotadas pelos combates. Com isso em mente, as a√ß√µes e seus c√°lculos de utilidade s√£o criados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No nosso exemplo, as a√ß√µes retornam um valor constante da utilidade ou um dos dois valores constantes da utilidade. Um sistema mais realista usa um valor de retorno de um </font><font style="vertical-align: inherit;">intervalo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cont√≠nuo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de valores. Por exemplo, a a√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getaway</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode retornar valores mais altos de utilidade se a sa√∫de do agente for menor e a a√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ataque</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode retornar valores mais baixos de utilidade se o inimigo for muito forte. Isso permitir√° que o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getaway</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tenha preced√™ncia sobre o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assalto.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em qualquer situa√ß√£o em que o agente sinta que n√£o √© saud√°vel o suficiente para combater o inimigo. Isso permite alterar as prioridades relativas das a√ß√µes com base em qualquer n√∫mero de crit√©rios, o que pode tornar essa abordagem mais flex√≠vel do que uma √°rvore de comportamento ou nave espacial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada a√ß√£o geralmente possui v√°rias condi√ß√µes que influenciam o c√°lculo da utilidade. Para n√£o definir tudo de forma r√≠gida no c√≥digo, voc√™ pode escrev√™-los em uma linguagem de script ou como uma s√©rie de f√≥rmulas matem√°ticas, reunidas de maneira compreens√≠vel. Muito mais informa√ß√µes sobre isso est√£o nas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">palestras</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apresenta√ß√µes de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dave Mark ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@IADaveMark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em alguns jogos que tentam simular a vida cotidiana do personagem, por exemplo, no The Sims, √© adicionada outra camada de c√°lculos em que o agente tem "aspira√ß√µes" ou "motiva√ß√µes" que afetam os valores da utilidade. Por exemplo, se um personagem tem a motiva√ß√£o de Fome, ele pode aumentar com o tempo e o c√°lculo da utilidade da a√ß√£o Eat retornar√° valores cada vez mais altos at√© que o personagem possa executar essa a√ß√£o, reduzindo a fome e a a√ß√£o " Comer ‚Äù√© reduzido a zero ou quase a zero o valor da utilidade.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ideia de escolher a√ß√µes com base no sistema de pontos √© bastante direta, portanto, √© √≥bvio que voc√™ pode usar a tomada de decis√µes com base na utilidade em outros processos de tomada de decis√£o da IA, em vez de substitu√≠-las completamente. </font><font style="vertical-align: inherit;">A √°rvore de decis√£o pode consultar o valor do utilit√°rio de seus dois n√≥s filhos e selecionar o n√≥ com o valor mais alto. </font><font style="vertical-align: inherit;">Da mesma forma, uma √°rvore de comportamento pode ter um n√≥ de utilit√°rio composto que conta o utilit√°rio para selecionar o n√≥ filho a ser executado.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimento e navega√ß√£o </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos exemplos anteriores, havia uma raquete simples, que pedimos para mover para a esquerda-direita, ou um personagem de guarda, que sempre recebia ordens para patrulhar ou atacar. </font><font style="vertical-align: inherit;">Mas como exatamente controlamos o movimento de um agente por um per√≠odo de tempo? </font><font style="vertical-align: inherit;">Como podemos definir a velocidade, evitar obst√°culos, planejar uma rota quando √© imposs√≠vel chegar diretamente ao ponto final? </font><font style="vertical-align: inherit;">Agora vamos considerar esta tarefa.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dire√ß√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No n√≠vel mais simples, geralmente √© aconselh√°vel trabalhar com cada agente como se ele tivesse um valor de velocidade que determine a velocidade e a dire√ß√£o de seu movimento. Essa velocidade pode ser medida em metros por segundo, em milhas por hora, em pixels por segundo e assim por diante. Se recordarmos nosso ciclo de "percep√ß√£o-pensamento-a√ß√£o", podemos imaginar que "pensar" pode escolher velocidade, ap√≥s o que a "a√ß√£o" aplica essa velocidade ao agente, movendo-o ao redor do mundo. Geralmente, nos jogos, existe um sistema de f√≠sica que executa essa tarefa de forma independente, estuda o valor da velocidade de cada entidade e muda sua posi√ß√£o de acordo. Portanto, muitas vezes √© poss√≠vel atribuir esse trabalho a esse sistema, deixando a IA apenas a tarefa de escolher a velocidade do agente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se sabemos onde o agente quer estar, precisamos usar nossa velocidade para mover o agente nessa dire√ß√£o. </font><font style="vertical-align: inherit;">De uma forma trivial, obtemos a seguinte equa√ß√£o:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desejada_viagem = posi√ß√£o_estado - posi√ß√£o_agente </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine um mundo 2D no qual o agente est√° localizado nas coordenadas (-2, -2), e o ponto alvo est√° aproximadamente no nordeste, nas coordenadas (30, 20), ou seja, para chegar l√°, voc√™ precisa se mover (32, 22). </font><font style="vertical-align: inherit;">Vamos assumir que essas posi√ß√µes s√£o indicadas em metros. </font><font style="vertical-align: inherit;">Se decidirmos que o agente pode se mover a uma velocidade de 5 m / s, reduza a escala do vetor de deslocamento para esse valor e verifique se precisamos definir a velocidade aproximadamente (4,12, 2,83). </font><font style="vertical-align: inherit;">Movendo-se com base nesse valor, o agente chegar√° ao terminal em menos de 8 segundos, conforme o esperado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os c√°lculos podem ser realizados novamente a qualquer momento. Por exemplo, se o agente estiver a meio caminho do alvo, o movimento desejado ser√° a metade, mas ap√≥s atingir a velocidade m√°xima do agente de 5 m / s, a velocidade permanecer√° a mesma. Isso tamb√©m funciona para mover alvos (dentro do motivo), o que permite ao agente fazer pequenos ajustes ao longo do caminho. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, muitas vezes precisamos de mais controle. Por exemplo, podemos precisar aumentar lentamente a velocidade, como se o personagem parasse primeiro, depois passasse para um passo e depois corresse. Por outro lado, podemos precisar desaceler√°-lo √† medida que ele se aproxima do alvo. Frequentemente, essas tarefas s√£o resolvidas usando os chamados " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comportamentos de dire√ß√£o"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"tendo nomes pr√≥prios como Procurar, Fugir, Chegada e assim por diante. (No Habr√©, h√° uma s√©rie de artigos sobre eles: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://habr.com/post/358366/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) A ideia deles √© que voc√™ possa aplicar a velocidade do agente for√ßas de acelera√ß√£o baseadas em uma compara√ß√£o da posi√ß√£o do agente e da velocidade atual do movimento em dire√ß√£o ao alvo, criando v√°rias maneiras de se mover em dire√ß√£o ao alvo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada comportamento tem seu pr√≥prio objetivo ligeiramente diferente. Buscar e chegar s√£o usados ‚Äã‚Äãpara mover o agente para seu destino. A preven√ß√£o e separa√ß√£o de obst√°culos ajudam o agente a fazer pequenos movimentos corretivos para contornar pequenos obst√°culos entre o agente e seu destino. O alinhamento e a coes√£o for√ßam os agentes a se moverem juntos, imitando os animais do rebanho. Quaisquer varia√ß√µes de diferentes comportamentos de dire√ß√£o podem ser combinadas, geralmente na forma de uma soma ponderada, para criar um valor total que leva em considera√ß√£o todos esses fatores diferentes e cria um √∫nico vetor resultante. Por exemplo, um agente pode usar o comportamento de Chegada junto com os comportamentos de Separa√ß√£o e Preven√ß√£o de Obst√°culos para ficar longe de paredes e outros agentes. Essa abordagem funciona bem em ambientes abertos que n√£o s√£o muito complexos e lotados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, em ambientes mais complexos, simplesmente adicionar os valores de sa√≠da do comportamento n√£o funciona muito bem - √†s vezes, o movimento pr√≥ximo ao objeto √© muito lento ou o agente fica preso quando o comportamento de chegada deseja passar pelo obst√°culo, e o comportamento de evitar obst√°culos empurra o agente para o lado de onde ele veio. . Portanto, √†s vezes faz sentido considerar varia√ß√µes no comportamento da dire√ß√£o que s√£o mais complicadas do que simplesmente somar todos os valores. Uma das fam√≠lias de tais abordagens consiste em uma implementa√ß√£o diferente - n√£o consideramos cada um dos comportamentos que nos d√£o orienta√ß√£o, seguidos de sua combina√ß√£o para obter consenso (que por si s√≥ pode ser inadequado). Em vez disso, consideramos o movimento em v√°rias dire√ß√µes diferentes - por exemplo, em oito dire√ß√µes da b√∫ssola ou em 5-6 pontos na frente do agente,ap√≥s o que escolhemos o melhor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No entanto, em ambientes complexos com becos sem sa√≠da e op√ß√µes nas curvas, precisaremos de algo mais avan√ßado e passaremos a isso em breve. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Localiza√ß√£o de caminho </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os comportamentos de dire√ß√£o s√£o √≥timos para movimentos simples em uma √°rea bastante aberta, como um campo ou arena de futebol, onde voc√™ pode ir de A a B em uma linha reta com pequenos ajustes para evitar obst√°culos. </font><font style="vertical-align: inherit;">Mas e se a rota para o ponto final for mais complicada? </font><font style="vertical-align: inherit;">Ent√£o, precisamos de uma ‚Äúbusca de caminhos‚Äù - explorando o mundo e tra√ßando um caminho ao longo dele para que o agente atinja o ponto final.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira mais simples √© colocar uma grade no mundo e, para cada c√©lula ao lado do agente, olhar para as c√©lulas vizinhas para as quais podemos nos mover. Se um deles √© o nosso ponto final, volte a rota, de cada c√©lula para a anterior, at√© chegarmos ao in√≠cio, obtendo uma rota. Caso contr√°rio, repita o processo com os vizinhos acess√≠veis dos vizinhos anteriores at√© encontrarmos o ponto final ou ficarmos sem c√©lulas (isso significa que n√£o h√° rota). Formalmente, essa abordagem √© chamada de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> busca em largura (BFS), porque a cada etapa ela √© exibida em todas as dire√ß√µes (ou seja, ‚Äúampla‚Äù) antes de sair das pesquisas. O espa√ßo de busca √© como uma frente de onda que se move at√© trope√ßar no local que procur√°vamos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este √© um exemplo simples de uma pesquisa em a√ß√£o. A √°rea de pesquisa se expande a cada est√°gio at√© que um ponto de extremidade seja inclu√≠do, ap√≥s o qual voc√™ pode rastrear o caminho at√© o in√≠cio.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/08e/15f/f1208e15fc83ffa2b7ac3eca652854fc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, obtemos uma lista de c√©lulas da grade, compondo a rota que voc√™ precisa seguir. Geralmente √© chamado de "caminho", caminho (da√≠ a "pesquisa de caminhos", busca de caminhos), mas voc√™ tamb√©m pode imagin√°-lo como um plano, porque √© uma lista de lugares que voc√™ precisa visitar para atingir seu objetivo, ou seja, o ponto final. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que sabemos a posi√ß√£o de cada c√©lula no mundo, voc√™ pode usar os comportamentos de dire√ß√£o descritos acima para se mover ao longo da rota - primeiro do n√≥ inicial ao n√≥ 2, depois do n√≥ 2 ao n√≥ 3 e assim por diante. A abordagem mais simples √© mover-se em dire√ß√£o ao centro da pr√≥xima c√©lula, mas tamb√©m existe uma alternativa popular - mover-se em dire√ß√£o ao meio da costela entre a c√©lula atual e a pr√≥xima. Isso permite que o agente fa√ßa curvas em curvas fechadas para criar um movimento mais realista.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como voc√™ pode ver, esse algoritmo pode desperdi√ßar recursos porque examina tantas c√©lulas na dire√ß√£o "errada" quanto na "certa". Al√©m disso, n√£o permite levar em conta os custos de movimento, nos quais algumas c√©lulas podem ser "mais caras" do que outras. Aqui chegamos ao aux√≠lio de um algoritmo mais complexo chamado A *. Funciona da mesma maneira que a pesquisa pela primeira vez, mas, em vez de explorar cegamente vizinhos, vizinhos, vizinhos, vizinhos, etc., coloca todos esses n√≥s em uma lista e os classifica para que o pr√≥ximo n√≥ sob investiga√ß√£o seja sempre o √∫nico provavelmente leva √† rota mais curta. Os n√≥s s√£o classificados com base em heur√≠sticas (isto √©, de fato, uma suposi√ß√£o razo√°vel),que leva em considera√ß√£o dois aspectos - o custo de uma rota hipot√©tica para a c√©lula (levando em considera√ß√£o todos os custos necess√°rios para se mover) e uma estimativa de qu√£o longe essa c√©lula est√° do ponto final (deslocando a pesquisa na dire√ß√£o certa).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/406/091/128406091bee8168b7b0e398386797da.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste exemplo, mostramos que ele examina uma c√©lula de cada vez, sempre escolhendo uma c√©lula vizinha que tenha as melhores perspectivas (ou uma das melhores). </font><font style="vertical-align: inherit;">O caminho resultante √© semelhante ao primeiro caminho de pesquisa, mas menos c√©lulas s√£o examinadas no processo, e isso √© muito importante para o desempenho do jogo em n√≠veis complexos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimento sem malha </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos exemplos anteriores, uma grade sobreposta ao mundo foi usada, e estabelecemos uma rota ao redor do mundo atrav√©s das c√©lulas dessa grade. Mas a maioria dos jogos n√£o se sobrep√µe √† grade e, portanto, a sobreposi√ß√£o da grade pode levar a padr√µes de movimento irrealistas. Al√©m disso, essa abordagem pode exigir compromissos em rela√ß√£o ao tamanho de cada c√©lula - se for muito grande, n√£o ser√° poss√≠vel descrever adequadamente pequenos corredores e curvas, se for muito pequena, e a busca por milhares de c√©lulas poder√° ser muito longa. Quais s√£o as alternativas? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira coisa que precisamos entender √© que, do ponto de vista matem√°tico, a grade nos fornece um " </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">gr√°fico</font></a><font style="vertical-align: inherit;"> "</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"de n√≥s conectados. Os algoritmos A * (e BFS) funcionam com gr√°ficos e n√£o se importam com a grade. Portanto, podemos colocar n√≥s em posi√ß√µes arbitr√°rias do mundo, e se houver uma linha reta entre dois n√≥s conectados, mas houver uma linha entre o in√≠cio e o fim se houver apenas um n√≥, nosso algoritmo funcionar√° como antes e, de fato, √© ainda melhor, porque haver√° menos n√≥s. Isso costuma ser chamado de sistema de waypoints, pois cada n√≥ indica uma posi√ß√£o importante no mundo que pode criar parte de qualquer n√∫mero de pu hipot√©tico </font><font style="vertical-align: inherit;">s.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b0/a64/90f/5b0a6490f8fac6a4101d7d6833946325.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo 1: um n√≥ em cada c√©lula da grade. </font><font style="vertical-align: inherit;">A pesquisa come√ßa com o n√≥ no qual o agente est√° localizado e termina com a c√©lula final.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f9/a09/70d/0f9a0970dfadfd31260ae81c93d8792b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo 2: um n√∫mero muito menor de n√≥s ou</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pontos de refer√™ncia </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A pesquisa come√ßa com o agente, passa pelo n√∫mero necess√°rio de waypoints e passa para o endpoint. Observe que mover para o primeiro ponto do caminho a sudoeste do jogador √© uma rota ineficiente; portanto, geralmente √© necess√°rio algum p√≥s-processamento do caminho gerado (por exemplo, para observar que o caminho pode ir diretamente para o waypoint no nordeste).</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este √© um sistema bastante flex√≠vel e poderoso, mas requer uma localiza√ß√£o cuidadosa dos pontos de refer√™ncia, caso contr√°rio, os agentes podem n√£o ver o ponto de refer√™ncia mais pr√≥ximo para iniciar a rota. Seria √≥timo se, de alguma forma, pud√©ssemos gerar waypoints automaticamente com base na geometria do mundo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E ent√£o navmesh vem em socorro. Isso √© abrevia√ß√£o de malha de navega√ß√£o. Em ess√™ncia, essa √© (geralmente) uma malha bidimensional de tri√¢ngulos, que se sobrep√µe aproximadamente √† geometria do mundo nos locais onde o jogo permite que o agente se mova. Cada um dos tri√¢ngulos na malha se torna um n√≥ do gr√°fico e possui at√© tr√™s tri√¢ngulos adjacentes que se tornam n√≥s adjacentes do gr√°fico. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abaixo est√° um exemplo do mecanismo do Unity. O mecanismo analisou a geometria do mundo e criou a malha de navega√ß√£o (azul), que √© uma aproxima√ß√£o da geometria. Cada pol√≠gono de nammesh √© uma √°rea na qual um agente pode ficar e um agente pode passar de um pol√≠gono para qualquer outro adjacente. (Neste exemplo, os pol√≠gonos s√£o mais estreitos que o piso em que se encontram, para levar em considera√ß√£o o raio do agente, que se estende al√©m da posi√ß√£o nominal do agente.)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/051/69e/86005169e23bd5d646664aeecf688b3a.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos procurar uma rota atrav√©s de uma malha usando A * novamente, e isso nos dar√° uma rota ideal ao redor do mundo que leva em conta toda a geometria e n√£o requer um n√∫mero excessivo de n√≥s extras (como seria com a grade) e participa√ß√£o humana na gera√ß√£o de pontos o caminho. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encontrar caminhos √© um t√≥pico extenso, para o qual existem muitas abordagens, especialmente se voc√™ precisar programar detalhes de baixo n√≠vel. </font><font style="vertical-align: inherit;">Uma das melhores fontes de informa√ß√µes adicionais √© o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site de Amit Patel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (tradu√ß√£o do artigo em Habr√©: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://habr.com/post/331192/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Planejamento </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando a pesquisa de caminhos como exemplo, vimos que, √†s vezes, n√£o basta escolher uma dire√ß√£o e come√ßar a se mover nela - precisamos escolher uma rota e fazer v√°rios movimentos antes de chegar ao ponto final desejado. Podemos generalizar essa id√©ia para uma ampla gama de conceitos em que o objetivo n√£o √© apenas o pr√≥ximo passo. Para alcan√ß√°-lo, √© necess√°rio executar uma s√©rie de etapas e, para saber qual deve ser o primeiro passo, talvez voc√™ precise dar alguns passos adiante. Essa abordagem √© chamada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planejamento</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Encontrar caminhos pode ser considerado uma das aplica√ß√µes espec√≠ficas do planejamento, mas esse conceito tem muito mais aplica√ß√µes. Retornando ao ciclo de ‚Äúpercep√ß√£o-pensamento-a√ß√£o‚Äù, esse planejamento √© uma fase do pensamento que tenta planejar v√°rias fases de a√ß√£o para o futuro.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vejamos o jogo Magic: The Gathering. </font><font style="vertical-align: inherit;">Voc√™ tem seu primeiro movimento, h√° v√°rias cartas em suas m√£os, incluindo "P√¢ntano", que fornece 1 ponto de mana preto, e "Floresta", que fornece 1 ponto de mana verde, "Exorcista", que requer 1 ponto de mana azul para chamar e " Elven Mystic ‚Äù, para chamar o que voc√™ precisa de 1 ponto de mana verde. </font><font style="vertical-align: inherit;">(Por simplicidade, omitimos as tr√™s cartas restantes.) As regras dizem que um jogador pode jogar uma carta de terreno por turno, pode "tocar" em suas cartas de terra para obter mana com elas e pode lan√ßar tantas magias (incluindo convocar criaturas) quanta mana ele tem. </font><font style="vertical-align: inherit;">Nesta situa√ß√£o, √© prov√°vel que o jogador jogue "Forest", toque nele para obter 1 ponto de mana verde e depois chame "Elven Mystic". </font><font style="vertical-align: inherit;">Mas como uma IA de jogos sabe que essa decis√£o precisa ser tomada?</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Agendador" simples </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma abordagem ing√™nua pode ser simplesmente iterar cada a√ß√£o em ordem, at√© que existam. Olhando para a m√£o, a AI v√™ que pode jogar "Swamp" e, portanto, o faz. Restam mais a√ß√µes ap√≥s este turno? Ele n√£o pode convocar Elven Mystic ou Exile Wizard, porque isso requer mana verde ou azul, e o p√¢ntano jogado fornece apenas mana negra. E n√£o podemos tocar "Forest" porque j√° tocamos "Swamp". Ou seja, o jogador de IA far√° a jogada de acordo com as regras, mas n√£o ser√° muito ideal. Felizmente, existe uma solu√ß√£o melhor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quase da mesma maneira que a busca de caminhos encontra uma lista de posi√ß√µes para se deslocar pelo mundo para chegar ao ponto certo, nosso planejador pode encontrar uma lista de a√ß√µes que colocam o jogo no estado certo. </font><font style="vertical-align: inherit;">Assim como cada posi√ß√£o no caminho possui um conjunto de vizinhos, que s√£o poss√≠veis op√ß√µes para escolher o pr√≥ximo passo, cada a√ß√£o no plano tem vizinhos, ou "herdeiros", candidatos √† pr√≥xima etapa do plano. </font><font style="vertical-align: inherit;">Podemos procurar essas a√ß√µes e as seguintes a√ß√µes at√© atingir o estado desejado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha, por exemplo, que o resultado desejado seja "convocar uma criatura, se poss√≠vel". </font><font style="vertical-align: inherit;">No in√≠cio da jogada, temos apenas duas a√ß√µes em potencial permitidas pelas regras do jogo:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Jogue ‚ÄúSwamp‚Äù (resultado: ‚ÄúSwamp‚Äù sai da m√£o e entra no jogo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Jogue "Floresta" (resultado: "Floresta" sai da m√£o e entra no jogo) </font></font></pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada a√ß√£o tomada pode abrir outras a√ß√µes ou fech√°-las, tamb√©m de acordo com as regras do jogo. </font><font style="vertical-align: inherit;">Imagine que escolhemos jogar ‚ÄúSwamp‚Äù - isso fecha a oportunidade de jogar esta carta como uma a√ß√£o potencial de heran√ßa (porque ‚ÄúSwamp‚Äù j√° foi jogado), fecha a oportunidade de jogar ‚ÄúForest‚Äù (porque as regras do jogo permitem que voc√™ jogue apenas uma carta de terra por turno) e adiciona a capacidade de tocar no ‚Äúp√¢ntano‚Äù para obter 1 ponto de mana negra - e essa √©, de fato, a √∫nica a√ß√£o herdada. </font><font style="vertical-align: inherit;">Se dermos mais um passo e selecionar "touch" Swamp "", obteremos 1 ponto de mana negra com o qual n√£o podemos fazer nada, ent√£o isso n√£o faz sentido.</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Jogue ‚ÄúSwamp‚Äù (resultado: ‚ÄúSwamp‚Äù sai da m√£o e entra no jogo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            1.1 Toque em "P√¢ntano" (resultado: tocamos em "P√¢ntano", +1 mana preta est√° dispon√≠vel)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                        Nenhuma a√ß√£o restante - END</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Jogue "Floresta" (resultado: "Floresta" sai da m√£o e entra no jogo) </font></font></pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa pequena lista de a√ß√µes n√£o nos deu muito e levou a um "beco sem sa√≠da", se usarmos a analogia com a busca de caminhos. </font><font style="vertical-align: inherit;">Portanto, repetimos o processo para a pr√≥xima etapa. </font><font style="vertical-align: inherit;">N√≥s escolhemos jogar Forest. </font><font style="vertical-align: inherit;">Isso tamb√©m remove a capacidade de "tocar floresta" e "tocar p√¢ntano" e abre como um potencial (e √∫nico) pr√≥ximo passo "tocar a floresta". </font><font style="vertical-align: inherit;">Isso nos d√° 1 ponto de mana verde, que por sua vez abre o terceiro passo - "chame" Elven Mystic "."</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Jogue ‚ÄúSwamp‚Äù (resultado: ‚ÄúSwamp‚Äù sai da m√£o e entra no jogo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            1.1 Toque em "P√¢ntano" (resultado: tocamos em "P√¢ntano", +1 mana preta est√° dispon√≠vel)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                        Nenhuma a√ß√£o restante - END</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Jogue "Floresta" (resultado: "Floresta" sai da m√£o e entra no jogo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            2.1 Toque em "Floresta" (resultado: tocamos em "P√¢ntano", +1 mana verde est√° dispon√≠vel)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                        2.1.1 Chame "Elven Mystic" (resultado: "Elven Mystic" no jogo, -1 mana verde est√° dispon√≠vel)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                                    Nenhuma a√ß√£o restante - END </font></font></pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, investigamos todas as a√ß√µes e a√ß√µes poss√≠veis resultantes dessas a√ß√µes, encontrando um plano que nos permite convocar a criatura: ‚Äútoque a floresta‚Äù, ‚Äútoque a floresta‚Äù, ‚Äúchame o‚Äú elfo m√≠stico ‚Äù‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, este √© um exemplo muito simplificado, e geralmente voc√™ precisa escolher o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melhor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um plano, e n√£o apenas um plano que atenda a alguns crit√©rios (por exemplo, "convocar uma criatura"). Geralmente, voc√™ pode avaliar os planos em potencial com base no resultado final ou nos benef√≠cios cumulativos de usar o plano. Por exemplo, voc√™ pode dar 1 ponto a um mapa de terreno e 3 pontos por chamar uma criatura. ‚ÄúJogar‚Äú P√¢ntano ‚Äù‚Äù ser√° um plano curto, com 1 ponto, e o plano de ‚Äújogar Floresta‚Äù ‚Üí tocar em ‚ÄúFloresta‚Äù ‚Üí chamar ‚ÄúElven M√≠stico‚Äù ‚Äùd√° 4 pontos, 1 para o ch√£o e 3 para a criatura. Este ser√° o plano mais lucrativo dispon√≠vel, portanto, voc√™ deve escolher se nomearmos esses pontos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acima, mostramos como o planejamento funciona em um movimento de Magic: The Gathering, mas tamb√©m pode ser aplicado a a√ß√µes em uma s√©rie de movimentos (por exemplo, "mova um pe√£o para dar espa√ßo ao desenvolvimento do bispo" no xadrez ou "se esconda em uma unidade" ele poderia atirar no pr√≥ximo turno, estar seguro "no XCOM) ou com a estrat√©gia geral de todo o jogo (por exemplo," construir postes em todos os outros edif√≠cios protoss "no Starcraft ou" beber uma po√ß√£o Fortify Health antes de atacar o inimigo "no Skyrim). </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Planejamento aprimorado </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Äs vezes, existem muitas a√ß√µes poss√≠veis a cada etapa, e avaliar cada op√ß√£o n√£o √© razo√°vel. Vamos voltar ao exemplo de Magic: The Gathering - imagine que temos v√°rias criaturas na m√£o, muitos terrenos j√° foram jogados, para que possamos chamar qualquer criatura, v√°rias criaturas com suas habilidades jogadas e h√° mais algumas cartas de terrenos na m√£o - o n√∫mero de permuta√ß√µes terra, uso da terra, convoca√ß√£o de criaturas e o uso das habilidades das criaturas podem ser iguais a milhares ou mesmo dezenas de milhares. Felizmente, existem algumas maneiras de resolver esse problema. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O primeiro √© chamado de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encadeamento reverso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"(" Ida e volta "). Em vez de verificar todas as a√ß√µes e seus resultados, podemos come√ßar com cada um dos resultados finais desejados e ver se podemos encontrar um caminho direto para eles. Voc√™ pode comparar isso com a tentativa de alcan√ßar uma folha espec√≠fica em uma √°rvore - √© muito mais l√≥gico comece a partir desta folha e volte, estabelecendo uma rota ao longo do tronco (e nessa rota podemos seguir na ordem oposta), do que come√ßar a partir do tronco e tentar adivinhar qual ramo escolher em cada etapa. Se voc√™ come√ßar do final e seguir na dire√ß√£o oposta, ent√£o criou e plano ser√° muito mais r√°pido e mais f√°cil.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, se o inimigo tiver 1 ponto de vida restante, pode ser √∫til tentar encontrar um plano para "infligir 1 ou mais pontos de dano direto ao inimigo". Nosso sistema sabe que, para alcan√ßar esse objetivo, ele precisa lan√ßar um feiti√ßo de dano direto, o que, por sua vez, significa que ele deve estar em nossas m√£os e precisamos de mana suficiente para pronunci√°-lo. Por sua vez, isso significa que precisamos tocar em terreno suficiente para receber essa mana, o que pode exigir que voc√™ jogue um mapa de terreno adicional.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra maneira √© pesquisar pela primeira melhor correspond√™ncia. Em vez de contornar todas as permuta√ß√µes por um longo tempo, medimos o qu√£o ‚Äúbom‚Äù √© cada plano parcial (semelhante √† maneira como escolhemos as op√ß√µes de plano acima) e calculamos o mais bonito de todas as vezes. Geralmente, isso permite que voc√™ crie um plano ideal, ou pelo menos razoavelmente bom, sem a necessidade de considerar cada permuta√ß√£o poss√≠vel de planos. A * √© uma varia√ß√£o da busca pela primeira melhor correspond√™ncia - ela explora primeiro as rotas mais promissoras, para que ele possa encontrar o caminho para a meta sem precisar subir demais em outras dire√ß√µes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma op√ß√£o de pesquisa interessante e cada vez mais popular para a primeira melhor correspond√™ncia √© a pesquisa em √°rvore </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Monte Carlo</font></a><font style="vertical-align: inherit;"> .</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em vez de adivinhar quais planos s√£o melhores que outros ao escolher cada a√ß√£o subseq√ºente, esse m√©todo escolhe a√ß√µes subseq√ºentes aleat√≥rias em cada etapa at√© chegar ao fim em que nenhuma a√ß√£o √© mais poss√≠vel - provavelmente porque o plano hipot√©tico levou a um estado de vit√≥ria ou perda - e usa esse resultado para dar mais ou menos peso √†s op√ß√µes selecionadas anteriores. Se o processo for repetido v√°rias vezes, o m√©todo poder√° criar uma boa avalia√ß√£o do melhor pr√≥ximo passo, mesmo que a situa√ß√£o mude (por exemplo, se o inimigo tentar frustrar nossos planos). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, nenhuma discuss√£o sobre planejamento em jogos seria completa sem mencionar o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planejamento de a√ß√µes com base em objetivos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Planejamento de a√ß√µes orientadas a objetivos, GOAP). </font><font style="vertical-align: inherit;">Essa √© uma t√©cnica amplamente usada e amplamente discutida, mas se voc√™ ignorar alguns detalhes espec√≠ficos da implementa√ß√£o, √© essencialmente um planejador de ida e volta que come√ßa com uma meta e tenta pegar uma a√ß√£o que leva a essa meta ou, mais provavelmente, uma lista de a√ß√µes que leva a para o objetivo. </font><font style="vertical-align: inherit;">Por exemplo, se o objetivo era "matar o jogador" e o jogador estivesse coberto, o plano poderia ser: "Fume o jogador com uma granada" ‚Üí "Puxe uma arma" ‚Üí "Ataque".</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geralmente, existem v√°rios objetivos, e cada um tem sua pr√≥pria prioridade. </font><font style="vertical-align: inherit;">Se os objetivos com a maior prioridade n√£o puderem ser alcan√ßados, por exemplo, nenhum conjunto de a√ß√µes poder√° formar o plano "Matar o jogador" porque o jogador n√£o est√° vis√≠vel, ent√£o o sistema retornar√° aos objetivos com prioridades mais baixas, por exemplo, "Patrulha" ou "Guarda no local".</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Treinamento e adapta√ß√£o </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No in√≠cio do artigo, mencionamos que a IA de jogos geralmente n√£o usa ‚Äúaprendizado de m√°quina‚Äù porque geralmente n√£o √© adequada para o controle em tempo real de agentes inteligentes no mundo dos jogos. </font><font style="vertical-align: inherit;">No entanto, isso n√£o significa que n√£o possamos tomar emprestado algo dessa √°rea onde faz sentido. </font><font style="vertical-align: inherit;">Podemos precisar de um oponente de computador no atirador para descobrir os melhores lugares para se mover e obter o m√°ximo de abates. </font><font style="vertical-align: inherit;">Ou podemos querer o oponente em um jogo de luta. </font><font style="vertical-align: inherit;">por exemplo, em Tekken ou Street Fighter, ele aprendeu a reconhecer um jogador usando os mesmos combos para come√ßar a bloque√°-los, for√ßando-o a usar t√°ticas diferentes. </font><font style="vertical-align: inherit;">Ou seja, h√° momentos em que uma certa porcentagem de aprendizado de m√°quina √© √∫til.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estat√≠stica e Probabilidades </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de passarmos a exemplos mais complexos, vale a pena descobrir at√© onde podemos chegar, simplesmente medindo e usando esses dados para tomar decis√µes. Por exemplo, digamos que temos um jogo no g√™nero de estrat√©gia em tempo real, e precisamos entender se o jogador come√ßar√° a se apressar nos primeiros minutos para decidir se constr√≥i mais defesa. Podemos extrapolar o comportamento anterior do jogador para entender qual pode ser o comportamento futuro. Inicialmente, n√£o temos dados que possam ser extrapolados, mas cada vez que a IA joga contra um inimigo vivo, ela pode registrar a hora do primeiro ataque. Ap√≥s algumas partidas, esse tempo pode ser medido e obteremos uma aproxima√ß√£o suficientemente boa do tempo de ataque do jogador no futuro.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O problema da m√©dia simples √© que ela geralmente converge ao longo do tempo no centro. Portanto, se um jogador usou a estrat√©gia de corrida nas primeiras 20 vezes e as pr√≥ximas 20 vezes passaram para uma estrat√©gia muito mais lenta, o valor m√©dio estar√° em algum lugar no meio, o que n√£o nos dar√° nenhuma informa√ß√£o √∫til. Uma maneira de melhorar os dados √© usar uma janela de m√©dia simples que leve em considera√ß√£o apenas os √∫ltimos 20 pontos de dados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma abordagem semelhante pode ser usada para avaliar a probabilidade de certas a√ß√µes, assumindo que as prefer√™ncias anteriores do jogador continuem no futuro. Por exemplo, se um jogador atacou cinco vezes com uma bola de fogo, duas vezes com raios e m√£o a m√£o apenas uma vez, ent√£o provavelmente ele preferiria uma bola de fogo 5 em 8 vezes. Extrapolando esses dados, podemos ver que a probabilidade de usar uma arma √©: Bola de fogo = 62,5%, Raio = 25% Corpo a corpo = 12,5%. Nossos personagens de IA perceber√£o que √© melhor encontrar armaduras √† prova de fogo!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro m√©todo interessante √© usar o Classificador Naive Bayes para estudar grandes volumes de dados de entrada, a fim de classificar a situa√ß√£o atual para que o agente de IA possa responder adequadamente. Os classificadores bayesianos s√£o provavelmente mais conhecidos por serem usados ‚Äã‚Äãem filtros de email de spam, onde avaliam as palavras no email, comparam-nas com aquelas que foram encontradas com mais frequ√™ncia em spam e em mensagens normais no passado. Com base nesses c√°lculos, eles decidem sobre a probabilidade de a √∫ltima mensagem recebida ser spam. Podemos fazer algo semelhante, apenas com menos entrada. Ao registrar todas as informa√ß√µes √∫teis observ√°veis ‚Äã‚Äã(por exemplo, unidades inimigas criadas,feiti√ßos usados ‚Äã‚Äãou tecnologias de pesquisa) e rastreando a situa√ß√£o resultante (guerra / paz, estrat√©gia de ataque / estrat√©gia de defesa, etc.), podemos selecionar o comportamento apropriado com base nisso.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O uso de todas essas t√©cnicas de ensino pode ser suficiente e frequentemente e preferencialmente aplicado aos dados coletados durante o teste de reprodu√ß√£o antes do lan√ßamento do jogo. </font><font style="vertical-align: inherit;">Isso permite que a IA se adapte √†s v√°rias estrat√©gias usadas pelos testadores e n√£o mude ap√≥s o lan√ßamento do jogo. </font><font style="vertical-align: inherit;">Uma IA que se adapta a um jogador ap√≥s o lan√ßamento de um jogo pode se tornar previs√≠vel ou complexa demais para ser derrotada.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√°cil adapta√ß√£o baseada em peso </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos dar um passo adiante. </font><font style="vertical-align: inherit;">Em vez de apenas usar os dados de entrada para escolher entre estrat√©gias predefinidas discretas, voc√™ pode alterar o conjunto de valores que influenciam a tomada de decis√£o. </font><font style="vertical-align: inherit;">Se entendermos bem o mundo do jogo e as regras do jogo, podemos fazer o seguinte:</font></font><br><br><ul><li>              (   ); </li><li>    ¬´¬ª       ; </li><li>         . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine um agente de inform√°tica que pode selecionar salas em um mapa em um jogo de tiro em primeira pessoa. Cada quarto tem um peso que determina a conveni√™ncia de visitar este quarto. Inicialmente, todos os quartos t√™m o mesmo significado. Ao escolher um quarto, a IA o seleciona aleatoriamente, mas com a influ√™ncia desses pesos. Agora imagine que, quando um agente de computador √© morto, ele se lembra em qual sala isso est√° acontecendo e reduz seu peso, de modo que √© menos prov√°vel que volte a ele no futuro. Da mesma forma, imagine que um agente de computa√ß√£o cometeu um assassinato. Depois, ele pode aumentar o peso da sala em que est√°, a fim de levant√°-la na lista de prefer√™ncias. Portanto, se uma sala se torna especialmente perigosa para o jogador de IA, ele come√ßa a evit√°-la no futuro, e se alguma outra sala permitir que a IA tenha muitos assassinatos,ent√£o ele voltar√° para l√°.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modelos de Markov </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E se quis√©ssemos usar os dados que coletamos para fazer previs√µes? </font><font style="vertical-align: inherit;">Por exemplo, se gravarmos todas as salas em que vemos um jogador por um determinado per√≠odo de tempo, podemos prever razoavelmente em qual sala ele pode passar. </font><font style="vertical-align: inherit;">Ao rastrear a sala atual em que o jogador est√° e a anterior e registrar esses pares de valores, podemos calcular com que frequ√™ncia cada uma das situa√ß√µes anteriores leva √† pr√≥xima situa√ß√£o e usar esse conhecimento para obter previs√µes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine que existem tr√™s salas - vermelha, verde e azul, e que durante a sess√£o do jogo recebemos essas observa√ß√µes:</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira sala em que o jogador √© visto</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total de observa√ß√µes</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√≥ximo quarto</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quantas vezes visto</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Percentagem</font></font></b> <br><br></td></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermelho </font></font><br><br></td><td rowspan="3">  10 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermelho </font></font><br><br></td><td>  2 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verde </font></font><br><br></td><td>  7 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 70% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Azul </font></font><br><br></td><td>  1 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10% </font></font><br><br></td></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verde </font></font><br><br></td><td rowspan="3">  10 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermelho </font></font><br><br></td><td>  3 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 30% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verde </font></font><br><br></td><td>  5 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 50% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Azul </font></font><br><br></td><td>  2 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20% </font></font><br><br></td></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Azul </font></font><br><br></td><td rowspan="3">  8 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermelho </font></font><br><br></td><td>  6 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 75% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verde </font></font><br></td><td>  2 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Azul </font></font><br><br></td><td>  0 0 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0% </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O n√∫mero de detec√ß√µes em cada um dos quartos √© razoavelmente uniforme, portanto, isso n√£o nos d√° uma id√©ia de qual dos quartos pode ser um bom lugar para uma emboscada. Os dados podem ser distorcidos pelo fato de os jogadores aparecerem uniformemente no mapa, com igual probabilidade de aparecer em qualquer uma dessas tr√™s salas. Mas os dados sobre a visita √† </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√≥xima</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sala podem ser √∫teis e nos ajudar a prever o movimento do jogador no mapa.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos notar imediatamente que a sala verde √© muito atraente para os jogadores - a maioria dos jogadores da sala vermelha ficou verde e 50% dos jogadores vistos na sala verde permanecem l√° durante a pr√≥xima checagem. Tamb√©m podemos notar que a sala azul √© um lugar pouco atraente. As pessoas raramente mudam de salas vermelhas ou verdes para azuis e parece que ningu√©m gosta de ficar nela por um longo tempo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas os dados nos dizem algo mais espec√≠fico - eles dizem que quando um jogador est√° na sala azul, depois dela √© mais prov√°vel que escolha vermelho, em vez de verde. Apesar do fato de a sala verde ser um lugar muito mais popular do que a vermelha, a tend√™ncia √© ligeiramente oposta se o jogador estiver na sala azul. Parece que o pr√≥ximo estado (ou seja, a sala em que ele decide se mudar) depende do estado anterior (ou seja, a sala em que ele est√° agora), ent√£o esses dados nos permitem criar melhores previs√µes sobre o comportamento dos jogadores do que com contagem de observa√ß√£o independente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa ideia de que podemos usar o conhecimento do estado anterior para prever o estado futuro √© chamada de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modelo de Markov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e exemplos semelhantes nos quais medimos com precis√£o os eventos (por exemplo, "em que sala o jogador est√°") s√£o chamados de cadeias de Markov. Como eles representam a probabilidade de uma transi√ß√£o entre estados sucessivos, eles s√£o frequentemente representados graficamente na forma de uma m√°quina de estados finitos, pr√≥ximo a cada transi√ß√£o cuja probabilidade √© indicada. Anteriormente, usamos uma m√°quina de estado para representar o estado de comportamento no qual o agente est√° localizado, mas esse conceito pode ser estendido a todos os tipos de estados, estejam eles associados ao agente ou n√£o. No nosso caso, os estados indicam os quartos ocupados pelo agente. Ficar√° assim:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e43/53b/691/e4353b691807e7476a2255f91dc2f248.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa √© uma abordagem simples para indicar a probabilidade relativa de transi√ß√£o para diferentes estados, o que d√° √† IA a capacidade de prever o pr√≥ximo estado. </font><font style="vertical-align: inherit;">Mas podemos ir mais longe criando um sistema que olha para o futuro em duas ou mais etapas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se um jogador for visto na sala verde, usaremos dados que nos dizem que h√° 50% de chance de ele ainda estar na sala verde na pr√≥xima observa√ß√£o. </font><font style="vertical-align: inherit;">Mas qual √© a probabilidade de ele permanecer nele pela terceira vez? </font><font style="vertical-align: inherit;">Essa n√£o √© apenas a probabilidade de ele permanecer na sala verde por duas observa√ß√µes (50% * 50% = 25%), mas tamb√©m a probabilidade de que ele saia e retorne. </font><font style="vertical-align: inherit;">Aqui est√° uma nova tabela com valores anteriores aplicados a tr√™s observa√ß√µes: uma atual e duas hipot√©ticas no futuro.</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observa√ß√£o 1</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observa√ß√£o hipot√©tica 2</font></font></b> <br><br></td><td> <b>  </b> <br><br></td><td> <b>  3</b> <br><br></td><td> <b>  </b> <br><br></td><td> <b> </b> <br><br></td></tr><tr><td rowspan="10">  <br></td><td rowspan="3">  <br><br></td><td rowspan="3"> 30% <br><br></td><td>  <br><br></td><td> 20% <br><br></td><td> 6% <br><br></td></tr><tr><td> <b></b> <br><br></td><td> 70% <br><br></td><td> <b>21%</b> <br><br></td></tr><tr><td>  <br><br></td><td> 10% <br><br></td><td> 3% <br><br></td></tr><tr><td rowspan="3">  <br></td><td rowspan="3"> 50% <br><br></td><td>  <br><br></td><td> 30% <br><br></td><td> 15% <br><br></td></tr><tr><td> <b></b> <br><br></td><td> 50% <br><br></td><td> <b>25%</b> <br><br></td></tr><tr><td>  <br><br></td><td> 20% <br><br></td><td> 10% <br><br></td></tr><tr><td rowspan="3">  <br><br></td><td rowspan="3"> 20% <br><br></td><td>  <br><br></td><td> 75% <br><br></td><td> 15% <br><br></td></tr><tr><td> <b></b> <br><br></td><td> 25% <br><br></td><td> <b>5%</b> <br><br></td></tr><tr><td>  <br><br></td><td> 0% <br><br></td><td> 0% <br><br></td></tr><tr><td></td><td></td><td></td><td> <i>:</i> <br><br></td><td> 100% </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui vemos que a probabilidade de ver um jogador na sala verde ap√≥s 2 observa√ß√µes √© de 51% - 21% do que ele vir√° da sala vermelha, 5% do que vemos o jogador visitando a sala azul e 25% do que ele √© o tempo todo vai ficar na sala verde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma tabela √© apenas uma dica visual; um procedimento requer apenas uma multiplica√ß√£o de probabilidades em cada est√°gio. Isso significa que podemos olhar para o futuro, mas com uma ressalva significativa: assumimos que a probabilidade de entrar em uma sala depende inteiramente da sala em que estamos no momento. Essa ideia de que o estado futuro depende apenas da corrente √© chamada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade Markov</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Embora nos permita usar ferramentas poderosas como cadeias de Markov, geralmente √© apenas uma aproxima√ß√£o. </font><font style="vertical-align: inherit;">Os jogadores podem decidir visitar salas com base em outros fatores, como n√≠vel de sa√∫de e quantidade de muni√ß√£o, e como n√£o registramos essas informa√ß√µes como parte da condi√ß√£o, nossas previs√µes ser√£o menos precisas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N gramas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos voltar ao nosso exemplo com reconhecimento de combina√ß√£o em um jogo de luta. Essa √© uma situa√ß√£o semelhante na qual queremos prever o estado futuro com base no passado (para decidir como bloquear ou evitar um ataque), mas em vez de estudar um √∫nico estado ou evento, consideraremos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sequ√™ncias de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eventos que criam um movimento combinado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma maneira de fazer isso √© salvar a entrada de cada jogador (por exemplo, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloco</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) no buffer e gravar o buffer inteiro como um evento. Imagine que um jogador pressiona constantemente </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um chute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um chute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para usar o ataque " </font><i><font style="vertical-align: inherit;">C√¢ncer da Morte</font></i><font style="vertical-align: inherit;"> "</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", e o sistema de AI salva todas as entradas do jogador no buffer e lembra as √∫ltimas 3 entradas usadas em cada etapa. </font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entrar</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma sequ√™ncia de entrada existente</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nova mem√≥ria de entrada</font></font></b> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick </font></font><br><br></td><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o</font></font></i> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Golpe de m√£o </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick </font></font><br><br></td><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o</font></font></i> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick, Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick, Kick </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick, Kick, Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick, Kick </font></font><br><br></td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Golpe de m√£o</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pontap√©, pontap√©, pontap√©, pontap√©, pontap√©</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kick, Kick, Kick</font></font></b> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloquear </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloco, Pontap√©, Pontap√©, Pontap√©, Pontap√©, Bloco </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloco, Pontap√©, Pontap√© </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pontap√©, pontap√©, pontap√©, pontap√©, pontap√©, bloco, pontap√© </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chute, bloqueie, chute </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pontap√©, pontap√©, pontap√©, pontap√©, pontap√©, bloco, pontap√©, pontap√© </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloquear, chutar, chutar </font></font><br><br></td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Golpe de m√£o</font></font></b> <br><br></td><td> <b> ,  ,  ,  ,  , ,  ,  ,  </b> <br><br></td><td> <b> ,  ,  </b> </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Nas linhas em negrito, o jogador executa o ataque "Superbuck of Death".) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode observar todos os momentos em que o jogador escolheu um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no passado </font><font style="vertical-align: inherit;">, seguido de outro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e perceber que a pr√≥xima entrada √© sempre um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Isso permite que o agente de IA fa√ßa uma previs√£o de que, se um jogador acabou de escolher um chute, seguido de um chute, ele provavelmente selecionar√° um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chute a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seguir </font><font style="vertical-align: inherit;">, lan√ßando o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Death Superkulak</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Isso permite que a IA decida escolher uma a√ß√£o que neutralize esse golpe, como bloqueio ou evas√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tais seq√º√™ncias de eventos s√£o chamadas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-gramas.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onde N √© o n√∫mero de itens armazenados. No exemplo anterior, eram 3 gramas, tamb√©m chamado de trigrama, ou seja, os 2 primeiros elementos s√£o usados ‚Äã‚Äãpara prever o terceiro. Nos 5 gramas, o quinto √© previsto para os 4 primeiros elementos, e assim por diante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os desenvolvedores devem escolher cuidadosamente o tamanho de N-gramas (√†s vezes chamado de pedido). Quanto menor o n√∫mero, menos mem√≥ria √© necess√°ria, porque quanto menor o n√∫mero de permuta√ß√µes permitidas, mas menos hist√≥rico √© salvo, o que significa que o contexto √© perdido. Por exemplo, um grama de 2 gramas (tamb√©m chamado de ‚Äúbigram‚Äù) conter√° registros de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chutes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chutes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e grava√ß√µes de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chutes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chutes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas n√£o poder√° salvar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um chute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><i><font style="vertical-align: inherit;">chute de </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , portanto, n√£o pode acompanhar este combo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por outro lado, quanto maior a ordem, mais mem√≥ria √© necess√°ria e o sistema provavelmente ser√° mais dif√≠cil de treinar, porque teremos muito mais permuta√ß√µes poss√≠veis, o que significa que nunca podemos encontrar o mesmo duas vezes. Por exemplo, se houver tr√™s entradas poss√≠veis ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloco</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) e usarmos 10 gramas, haver√° quase 60 mil permuta√ß√µes diferentes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O modelo do bigram √© essencialmente uma cadeia trivial de Markov - cada par "estado futuro / estado atual" √© um bigram e podemos prever o segundo estado com base no primeiro. Trigramas e N-gramas grandes tamb√©m podem ser considerados cadeias de Markov, onde todos os elementos do N-grama, exceto o √∫ltimo, formam o primeiro estado, e o √∫ltimo elemento √© o segundo estado. No nosso exemplo de jogo de luta, √© apresentada a probabilidade de transi√ß√£o do estado de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chute e chute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para o estado de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chute e, em seguida, chute.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Percebendo v√°rios elementos do hist√≥rico de entrada como um √∫nico elemento, transformamos essencialmente a sequ√™ncia de entrada em um fragmento do estado, o que nos d√° uma propriedade Markov, permitindo usar cadeias de Markov para prever a pr√≥xima entrada, ou seja, adivinhando qual movimento de combina√ß√£o seguir√°.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Representa√ß√£o do conhecimento </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discutimos v√°rias maneiras de tomar decis√µes, criar planos e previs√µes, e todas elas s√£o baseadas nas observa√ß√µes do agente sobre o estado do mundo. </font><font style="vertical-align: inherit;">Mas como podemos observar efetivamente todo o mundo do jogo? </font><font style="vertical-align: inherit;">Acima, vimos que a maneira de representar a geometria do mundo afeta muito o movimento ao longo dele, por isso √© f√°cil imaginar que isso √© verdade para outros aspectos da IA ‚Äã‚Äãdo jogo. </font><font style="vertical-align: inherit;">Como podemos coletar e organizar todas as informa√ß√µes necess√°rias da maneira ideal (para que muitas vezes sejam atualizadas e acess√≠veis a muitos agentes) e pr√°ticas (para que as informa√ß√µes possam ser facilmente usadas no processo de tomada de decis√£o)? </font><font style="vertical-align: inherit;">Como transformar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dados</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simples </font><font style="vertical-align: inherit;">em </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informa√ß√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conhecimento</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">Para jogos diferentes, as solu√ß√µes podem ser diferentes, mas existem v√°rias abordagens mais populares.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tags / Tags </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Äs vezes, j√° temos uma quantidade enorme de dados √∫teis, e a √∫nica coisa que precisamos √© de uma boa maneira de categoriz√°-los e procur√°-los. Por exemplo, no mundo do jogo, pode haver muitos objetos, e alguns deles s√£o um bom abrigo contra balas inimigas. Ou, por exemplo, temos v√°rias caixas de di√°logo de √°udio gravadas que s√£o aplic√°veis ‚Äã‚Äãem situa√ß√µes espec√≠ficas e precisamos de uma maneira de descobri-las rapidamente. O passo √≥bvio √© adicionar um pequeno peda√ßo de informa√ß√£o adicional que voc√™ pode usar para pesquisar. Esses fragmentos s√£o chamados de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tags</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou tags.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos voltar ao exemplo do abrigo; no mundo do jogo, pode haver um monte de objetos - caixas, barris, cachos de grama, cercas de arame. Alguns deles s√£o adequados para abrigos, por exemplo, caixas e barris, outros n√£o. Portanto, quando nosso agente executa a a√ß√£o "Mover para abrigo", ele deve procurar objetos pr√≥ximos e identificar candidatos adequados. Ele n√£o pode simplesmente procurar pelo nome - talvez o jogo tenha Crate_01, Crate_02, at√© Crate_27, e n√£o queremos procurar todos esses nomes no c√≥digo. N√£o queremos adicionar outro nome ao c√≥digo sempre que o artista criar uma nova varia√ß√£o da caixa ou barril. Em vez disso, voc√™ pode procurar qualquer nome que contenha a palavra "Caixa", mas um dia um artista pode adicionar "Broken_Crate" com um buraco enorme, inadequado como abrigo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, em vez disso, criaremos uma tag "COVER" e solicitaremos que artistas e designers anexem essa tag a todos os objetos que podem ser usados ‚Äã‚Äãcomo abrigo. Se eles adicionarem uma marca a todos os barris e caixas (inteiras), o procedimento de AI precisar√° apenas encontrar objetos com essa marca e ele saber√° que os objetos s√£o adequados para essa finalidade. A tag funcionar√° mesmo que os objetos sejam renomeados posteriormente e poder√° ser adicionada a objetos no futuro sem fazer altera√ß√µes desnecess√°rias no c√≥digo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No c√≥digo, as tags geralmente s√£o representadas como strings, mas se todas as tags usadas forem conhecidas, voc√™ poder√° converter as strings em n√∫meros exclusivos para economizar espa√ßo e acelerar a pesquisa. Em alguns mecanismos, as tags s√£o funcionalidades internas, por exemplo, no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unreal Engine 4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , portanto, basta determinar a escolha das tags nelas e us√°-las para a finalidade a que se destinam. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objetos inteligentes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As tags s√£o uma maneira de adicionar informa√ß√µes adicionais ao ambiente do agente, para ajud√°-lo a descobrir as op√ß√µes dispon√≠veis, para que solicita√ß√µes como "Encontre-me todos os lugares mais pr√≥ximos para me esconder" ou "Encontre-me todos os inimigos pr√≥ximos que possam lan√ßar feiti√ßos" sejam realizadas com efici√™ncia e com o m√≠nimo esfor√ßo trabalhado para novos recursos do jogo. </font><font style="vertical-align: inherit;">Mas, √†s vezes, as tags n√£o cont√™m informa√ß√µes suficientes para seu uso total.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine um simulador de uma cidade medieval na qual os aventureiros vagam onde querem, se necess√°rio, treinam, lutam e relaxam. Podemos organizar locais de treinamento em diferentes partes da cidade e atribuir a eles a tag "TREINAMENTO" para que os personagens possam encontrar facilmente um local para treinamento. Mas vamos imaginar que um deles seja um campo de tiro para arqueiros, e o outro √© uma escola de magos. Em cada um desses casos, precisamos mostrar nossa anima√ß√£o, porque, sob o nome geral de "treinamento", eles representam a√ß√µes diferentes, e nem todo aventureiro est√° interessado nos dois tipos de treinamento. Voc√™ pode se aprofundar ainda mais e criar tags ARCHERY-TRAINING e MAGIC-TRAINING, separar procedimentos de treinamento um do outro e incorpor√°-los em cada anima√ß√£o diferente. Isso ajudar√° a resolver o problema. Mas imagineque os designers declarar√£o mais tarde "Vamos ter uma escola de Robin Hood, onde voc√™ pode aprender arco e flecha e luta com espadas"! E ent√£o, quando adicionamos a luta de espadas, eles pedem a cria√ß√£o da Academia de Magia de Gandalf e luta de espadas. Como resultado, teremos que armazenar v√°rias tags para cada local e procurar anima√ß√µes diferentes com base em qual aspecto do treinamento o personagem precisa, etc.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra maneira √© armazenar informa√ß√µes diretamente no objeto, juntamente com a influ√™ncia que ele exerce sobre o jogador, para que o ator da IA ‚Äã‚Äãpossa simplesmente listar as op√ß√µes poss√≠veis e escolher entre elas de acordo com as necessidades do agente. </font><font style="vertical-align: inherit;">Depois disso, ele pode ir para o local apropriado, executar as anima√ß√µes apropriadas (ou quaisquer outras a√ß√µes obrigat√≥rias), conforme indicado no objeto, e receber a recompensa apropriada.</font></font><br><br><table><tbody><tr><td><br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anima√ß√£o em execu√ß√£o</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado do Usu√°rio</font></font></b> <br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Campo de tiro</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atirar-flecha </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 Habilidade de Tiro com Arco </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escola de Magia</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Duelo de Espadas </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 Habilidade com espadas </font></font><br><br></td></tr><tr><td rowspan="2"> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Robin Hood School</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atirar-flecha </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +15 de habilidade de tiro com arco </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Duelo de Espadas </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +8 Habilidade com espadas </font></font><br><br></td></tr><tr><td rowspan="2"> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Academia Gandalf</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Duelo de Espadas </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +5 Habilidade com espadas </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lan√ßar feiti√ßo </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 de habilidade m√°gica </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O personagem arqueiro ao lado desses 4 locais ter√° 6 op√ß√µes, 4 das quais n√£o s√£o aplic√°veis ‚Äã‚Äãa ele se ele n√£o usar uma espada ou m√°gica. </font><font style="vertical-align: inherit;">Comparando o resultado nesse caso com uma melhoria na habilidade, em vez de um nome ou tag, podemos expandir facilmente as possibilidades do mundo com novos comportamentos. </font><font style="vertical-align: inherit;">Voc√™ pode adicionar hot√©is para descansar e satisfazer sua fome. </font><font style="vertical-align: inherit;">Voc√™ pode deixar os personagens irem √† biblioteca e ler sobre feiti√ßos e t√©cnicas avan√ßadas de arco e flecha.</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O nome do objeto</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anima√ß√£o em execu√ß√£o</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado final</font></font></b> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hotel </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comprar </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -10 a fome </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hotel </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dormir </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -50 a fadiga </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A biblioteca </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leia o livro </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 de habilidade de conjura√ß√£o </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A biblioteca </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leia o livro </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +5 Habilidade de Tiro com Arco </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se j√° tivermos o comportamento de ‚Äúpraticar arco e flecha‚Äù, mesmo se marcarmos a biblioteca como um local para ARCHERY-TRAINING, provavelmente precisaremos de um caso especial para processar a anima√ß√£o do livro de leitura em vez da anima√ß√£o usual de luta com espadas. </font><font style="vertical-align: inherit;">Esse sistema nos d√° mais flexibilidade, movendo essas associa√ß√µes para dados e armazenando dados no mundo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A exist√™ncia de objetos ou locais - bibliotecas, hot√©is ou escolas - nos fala sobre os servi√ßos que eles oferecem, sobre o personagem que pode obt√™-los, permite que voc√™ use um pequeno n√∫mero de anima√ß√µes. </font><font style="vertical-align: inherit;">A capacidade de tomar decis√µes simples sobre os resultados permite criar uma variedade de comportamentos interessantes. </font><font style="vertical-align: inherit;">Em vez de aguardar passivamente por uma solicita√ß√£o, esses objetos podem fornecer diversas informa√ß√µes sobre como e por que us√°-los.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Curvas de rea√ß√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Muitas vezes, h√° uma situa√ß√£o em que parte do estado do mundo pode ser medida como um valor cont√≠nuo. </font></font> Exemplos: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Porcentagem de sa√∫de" geralmente varia de 0 (morto) a 100 (absolutamente saud√°vel) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Dist√¢ncia para o inimigo mais pr√≥ximo" varia de 0 a algum valor positivo arbitr√°rio </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, o jogo pode ter algum aspecto do sistema de IA, exigindo a entrada de valores cont√≠nuos em algum outro intervalo. Por exemplo, para tomar uma decis√£o de fugir, um sistema de classifica√ß√£o de utilidade pode exigir a dist√¢ncia do inimigo mais pr√≥ximo e a sa√∫de atual do personagem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, o sistema n√£o pode simplesmente somar dois valores do estado do mundo para obter um certo n√≠vel de "seguran√ßa", porque essas duas unidades de medida s√£o incompar√°veis ‚Äã‚Äã- os sistemas assumir√£o que um personagem quase morto a 200 metros do inimigo est√° na mesma seguran√ßa que √© absolutamente saud√°vel personagem a 100 metros do inimigo. Al√©m disso, embora o valor percentual da sa√∫de em sentido amplo seja linear, a dist√¢ncia n√£o √© assim - a diferen√ßa na dist√¢ncia do inimigo 200 e 190 metros √© menos significativa do que a diferen√ßa entre 10 metros e zero.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealmente, precisamos de uma solu√ß√£o que pegue dois indicadores e os converta em intervalos semelhantes para que possam ser comparados diretamente. E precisamos que os designers possam controlar como essas transforma√ß√µes s√£o calculadas para controlar a import√¢ncia relativa de cada valor. Para este fim, s√£o utilizadas curvas de rea√ß√£o (curvas de resposta). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira mais f√°cil de explicar a curva de rea√ß√£o √© como um gr√°fico com entrada ao longo do eixo X, valores arbitr√°rios, por exemplo, ‚Äúdist√¢ncia do inimigo mais pr√≥ximo‚Äù e sa√≠da ao longo do eixo Y (geralmente um valor normalizado na faixa de 0,0 a 1,0). Uma linha ou curva no gr√°fico determina a liga√ß√£o da entrada √† sa√≠da normalizada, e os designers ajustam essas linhas para obter o comportamento necess√°rio.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para calcular o n√≠vel de "seguran√ßa", voc√™ pode manter a linearidade dos valores percentuais de sa√∫de - por exemplo, 10% a mais de sa√∫de - isso geralmente √© bom quando o personagem √© gravemente ferido e quando ele √© ferido facilmente. </font><font style="vertical-align: inherit;">Portanto, atribu√≠mos esses valores ao intervalo de 0 a 1 de maneira direta:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3f/65f/9a9/e3f65f9a90b2557c5408e529c477fb12.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A dist√¢ncia para o inimigo mais pr√≥ximo √© um pouco diferente; portanto, n√£o somos incomodados por inimigos al√©m de uma certa dist√¢ncia (digamos, 50 metros), e estamos muito mais interessados ‚Äã‚Äãnas diferen√ßas a uma curta dist√¢ncia do que a uma grande dist√¢ncia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui vemos que a sa√≠da de "seguran√ßa" para inimigos nos 40 e 50 metros √© quase a mesma: 0,96 e 1,0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b7/8bf/be7/9b78bfbe758bf8407a3abe44b430e7a5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, h√° uma diferen√ßa muito maior entre o inimigo a 15 metros (cerca de 0,5) e o inimigo a 5 metros (cerca de 0,2). Esse cronograma reflete melhor a import√¢ncia de o inimigo se aproximar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao normalizar esses dois valores no intervalo de 0 a 1, podemos calcular o valor total de seguran√ßa como a m√©dia desses dois valores de entrada. Um personagem com 20% de vida e um inimigo a 50 metros ter√£o uma pontua√ß√£o de seguran√ßa de 0,6. Um personagem com 75% de vida e um inimigo a apenas 5 metros de dist√¢ncia ter√£o uma pontua√ß√£o de seguran√ßa de 0,47. Um personagem gravemente ferido com 10% de vida e um inimigo de 5 metros ter√° um √≠ndice de seguran√ßa de apenas 0,145. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O seguinte deve ser considerado aqui:</font></font><br><br><ul><li>              ‚Äî                  ,   . </li><li>         ‚Äî ,  ,   50  ‚Äî      ,    ,      . </li><li>        ,   (  )        .       ,       ‚Äî ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">Unity AnimationCurve</a>    ,           . </li></ul><br><h2> Blackboards </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muitas vezes, nos encontramos em uma situa√ß√£o em que a IA do agente deve come√ßar a monitorar o conhecimento e as informa√ß√µes obtidas durante o jogo, para que possam ser usadas em outras decis√µes. Por exemplo, um agente pode precisar se lembrar de qual √∫ltimo personagem ele atacou para se concentrar nos ataques daquele personagem por um curto per√≠odo de tempo. Ou ele deve se lembrar de quanto tempo se passou depois de ouvir um barulho, para que, ap√≥s certo per√≠odo de tempo, pare de procurar seus motivos e retorne aos estudos anteriores. Muitas vezes, o sistema de grava√ß√£o de dados √© fortemente separado do sistema de leitura de dados, portanto deve ser facilmente acess√≠vel a partir do agente e n√£o incorporado diretamente em v√°rios sistemas de IA. A leitura pode ocorrer algum tempo ap√≥s a grava√ß√£o; portanto, os dados precisam ser armazenados em algum lugar,para que possam ser recuperados mais tarde (e n√£o calculados sob demanda, o que pode n√£o ser vi√°vel).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em um sistema de IA codificado, a solu√ß√£o pode ser adicionar as vari√°veis ‚Äã‚Äãnecess√°rias no processo da necessidade. Essas vari√°veis ‚Äã‚Äãest√£o relacionadas a inst√¢ncias do personagem ou agente, integrando-se diretamente a ele ou criando uma estrutura / classe separada para armazenar essas informa√ß√µes. Os procedimentos de IA podem ser adaptados para ler e gravar esses dados. Em um sistema simples, isso funcionar√° bem, mas √† medida que mais informa√ß√µes s√£o adicionadas, elas se tornam complicadas e geralmente exigem a reconstru√ß√£o do jogo a cada vez.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma abordagem melhor √© transformar o data warehouse em uma estrutura que permita aos sistemas ler e gravar dados arbitr√°rios. Essa solu√ß√£o permite adicionar novas vari√°veis ‚Äã‚Äãsem a necessidade de alterar a estrutura dos dados, fornecendo a capacidade de aumentar o n√∫mero de altera√ß√µes que podem ser feitas a partir de arquivos e scripts de dados sem a necessidade de remontagem. Se cada agente simplesmente armazena uma lista de pares de valores-chave, cada um dos quais √© um conhecimento separado, ent√£o diferentes sistemas de IA podem cooperar adicionando e lendo essas informa√ß√µes, se necess√°rio.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No desenvolvimento da IA, essas abordagens s√£o chamadas de "quadros-negros" ("quadros-negros"), porque cada participante - no nosso caso, os procedimentos de IA (por exemplo, percep√ß√£o, encontrar um caminho e tomar decis√µes) - podem escrever no "quadro-negro", lido a partir do qual os dados para o desempenho de sua tarefa podem ser outros participantes. Voc√™ pode imaginar isso como uma equipe de especialistas reunidos em torno do quadro e escrevendo algo √∫til que voc√™ precisa compartilhar com o grupo. Ao mesmo tempo, eles podem ler as notas anteriores de seus colegas at√© chegar a uma decis√£o ou plano conjunto. Uma lista codificada de vari√°veis ‚Äã‚Äãcomuns no c√≥digo √†s vezes √© chamada de "quadro est√°tico" (porque os elementos nos quais as informa√ß√µes s√£o armazenadas s√£o constantes durante a execu√ß√£o do programa), e uma lista arbitr√°ria de pares de valores-chave √© chamada "quadro din√¢mico".Mas eles s√£o usados ‚Äã‚Äãaproximadamente da mesma maneira - como um link intermedi√°rio entre partes do sistema de IA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na IA tradicional, a √™nfase √© geralmente colocada na colabora√ß√£o de diferentes sistemas para a tomada de decis√µes em conjunto, mas relativamente poucos sistemas est√£o presentes na IA do jogo. </font><font style="vertical-align: inherit;">No entanto, um certo grau de coopera√ß√£o ainda pode estar presente. </font><font style="vertical-align: inherit;">Imagine o seguinte em um RPG de a√ß√£o:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O sistema de ‚Äúpercep√ß√£o‚Äù varre regularmente a √°rea e grava as seguintes entradas no quadro-negro: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inimigo mais pr√≥ximo: Goblin 412 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Dist√¢ncia para o inimigo mais pr√≥ximo": 35,0 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúAmigo pr√≥ximo‚Äù: ‚ÄúGuerreiro 43‚Äù </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúDist√¢ncia para o amigo mais pr√≥ximo‚Äù: 55.4 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Hora do √∫ltimo barulho observado": 12:45 </font></font></li></ul></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sistemas como um sistema de combate podem registrar eventos importantes em um quadro negro, por exemplo: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √öltimo dano causado: 12:34 pm </font></font></li></ul></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muitos desses dados podem parecer redundantes - no final, voc√™ sempre pode distanciar-se do inimigo mais pr√≥ximo, simplesmente sabendo quem √© esse inimigo e atendendo a uma solicita√ß√£o de posi√ß√£o. Por√©m, quando repetida v√°rias vezes por quadro, para decidir se um agente est√° amea√ßando algo ou n√£o, isso se torna uma opera√ß√£o potencialmente lenta, especialmente se ela precisar executar uma consulta espacial para determinar o inimigo mais pr√≥ximo. E os carimbos de hora do ‚Äú√∫ltimo ru√≠do notado‚Äù ou do ‚Äú√∫ltimo dano recebido‚Äù ainda n√£o poder√£o ser instant√¢neos - voc√™ precisa registrar a hora em que esses eventos ocorreram e o quadro-negro √© um local conveniente para isso.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Unreal Engine 4 usa um sistema de quadro din√¢mico para armazenar dados transmitidos por √°rvores de comportamento. </font><font style="vertical-align: inherit;">Gra√ßas a esse objeto de dados comum, os designers podem facilmente escrever novos valores no quadro-negro com base em seus blueprints (scripts visuais), e a √°rvore de comportamento pode posteriormente ler esses valores para selecionar o comportamento, e tudo isso n√£o requer recompila√ß√£o do mecanismo.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mapas de influ√™ncia </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A tarefa padr√£o no AI √© decidir para onde o agente deve se mover. </font><font style="vertical-align: inherit;">No jogo de tiro, podemos escolher a a√ß√£o "Mover para o abrigo", mas como decidir onde o abrigo est√° nas condi√ß√µes de mover inimigos? </font><font style="vertical-align: inherit;">Da mesma forma que a a√ß√£o "Escape" - onde √© a maneira mais segura de escapar? </font><font style="vertical-align: inherit;">Ou no RTS, podemos precisar das tropas para atacar um ponto fraco na defesa do inimigo - como podemos determinar onde est√° esse ponto fraco?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas essas quest√µes podem ser consideradas tarefas geogr√°ficas, porque fazemos uma pergunta sobre a geometria e a forma do ambiente e a posi√ß√£o das entidades nele. No nosso jogo, √© prov√°vel que todos esses dados j√° estejam dispon√≠veis, mas dar sentido a eles n√£o √© uma tarefa f√°cil. Por exemplo, se queremos encontrar um ponto fraco na defesa do inimigo, simplesmente escolher a posi√ß√£o do edif√≠cio ou fortifica√ß√£o mais fraco n√£o √© bom o suficiente se eles tiverem dois poderosos sistemas de armas nos flancos. Precisamos de uma maneira de levar em conta a √°rea local e fazer uma melhor an√°lise da situa√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â para isso que serve a estrutura de dados do "mapa de influ√™ncia". Descreve a ‚Äúinflu√™ncia‚Äù que uma entidade pode ter na √°rea ao seu redor. Combinando a influ√™ncia de v√°rias entidades, criamos uma vis√£o mais realista de todo o cen√°rio. Do ponto de vista da implementa√ß√£o, aproximamos o mundo do jogo sobrepondo uma grade 2D e, ap√≥s determinar em qual c√©lula da grade a entidade est√°, aplicamos uma avalia√ß√£o de impacto a essa e √†s c√©lulas circundantes, indicando o aspecto da jogabilidade que queremos simular. Para obter uma imagem completa, acumulamos esses valores na mesma grade. Depois disso, podemos realizar v√°rias consultas √† grade para entender o mundo e decidir sobre o posicionamento e os pontos de destino.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tomemos, por exemplo, "o ponto mais fraco na defesa do inimigo". </font><font style="vertical-align: inherit;">Temos um muro defensivo, no ataque do qual queremos enviar soldados de infantaria, mas h√° tr√™s catapultas atr√°s dele - duas pr√≥ximas uma da outra √† esquerda, uma √† direita. </font><font style="vertical-align: inherit;">Como escolhemos uma boa posi√ß√£o de ataque? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para come√ßar, podemos atribuir +1 de pontos de prote√ß√£o a todas as c√©lulas da grade dentro do ataque de catapulta. </font><font style="vertical-align: inherit;">Desenhar esses pontos no mapa de influ√™ncia para uma catapulta √© assim:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/e37/df8/0cee37df8083ed361e0bf7362a7e5666.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ret√¢ngulo azul limita todas as c√©lulas nas quais voc√™ pode iniciar um ataque na parede. </font><font style="vertical-align: inherit;">Quadrados vermelhos indicam +1 influ√™ncia de catapulta. </font><font style="vertical-align: inherit;">No nosso caso, isso significa a √°rea do ataque e a amea√ßa √†s unidades atacantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora adicionamos o efeito da segunda catapulta:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db9/e7f/ef1/db9e7fef10229a2f5a38108197548490.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos uma √°rea escura na qual a influ√™ncia de duas catapultas √© formada, o que d√° prote√ß√£o a essas c√©lulas +2. A c√©lula +2 dentro da zona azul pode ser um local particularmente perigoso para atacar a parede! Adicione a influ√™ncia da √∫ltima catapulta:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1aa/da0/6d7/1aada06d7ea16ef8e2e6bca315c196c5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[√çcones: CC-BY: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://game-icons.net/heavenly-dog/originals/defensive-wall.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora temos uma designa√ß√£o completa da √°rea coberta pelas catapultas. Na zona de ataque em potencial, h√° uma c√©lula com +2 influ√™ncias de catapulta, 11 c√©lulas com influ√™ncia de +1 e 2 c√©lulas com 0 influ√™ncias de catapulta - esses s√£o os principais candidatos √† posi√ß√£o de ataque, pois podemos atacar a parede sem medo de fogo de catapulta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A vantagem dos mapas de influ√™ncia √© que eles transformam um espa√ßo cont√≠nuo com um conjunto quase infinito de posi√ß√µes poss√≠veis em um conjunto discreto de posi√ß√µes aproximadas, sobre as quais podemos tomar decis√µes muito rapidamente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, obtivemos essa vantagem apenas escolhendo um pequeno n√∫mero de poss√≠veis posi√ß√µes de ataque. Por que devemos usar o mapa de influ√™ncia aqui em vez de verificar manualmente a dist√¢ncia de cada catapulta a cada uma dessas posi√ß√µes? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em primeiro lugar, o c√°lculo de um mapa de influ√™ncia pode ser muito barato. Depois que os pontos de influ√™ncia s√£o colocados no cart√£o, ele n√£o precisa ser alterado at√© que as entidades comecem a se mover. Isso significa que n√£o precisamos executar constantemente c√°lculos de dist√¢ncia ou interrogar iterativamente todas as unidades poss√≠veis - n√≥s ‚Äúarmazenamos‚Äù essas informa√ß√µes no mapa e podemos enviar solicita√ß√µes para ele v√°rias vezes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, podemos sobrepor e combinar diferentes mapas de influ√™ncia para atender a consultas mais complexas. </font><font style="vertical-align: inherit;">Por exemplo, para selecionar um lugar seguro para escapar, podemos pegar um mapa da influ√™ncia de nossos inimigos e subtrair o mapa de nossos amigos - as c√©lulas da grade com o maior valor negativo ser√£o consideradas seguras.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/726/4db/e7b/7264dbe7b1834f3602b36deddc723163.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quanto mais vermelho, mais perigoso e mais verde, mais seguro. </font><font style="vertical-align: inherit;">√Åreas em que a sobreposi√ß√£o de influ√™ncia pode ser total ou parcialmente neutralizada para refletir √°reas de influ√™ncia conflitantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por fim, √© f√°cil visualizar mapas de influ√™ncia ao renderizar no mundo. </font><font style="vertical-align: inherit;">Eles podem ser uma dica valiosa para designers que precisam personalizar a IA com base em propriedades vis√≠veis e podem ser observados em tempo real para entender por que a AI escolhe suas decis√µes.</font></font><br><br><h1>  Conclus√£o </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que o artigo tenha fornecido uma vis√£o geral das ferramentas e abordagens mais populares usadas na IA de jogos, bem como das situa√ß√µes em que elas podem ser aplicadas. </font><font style="vertical-align: inherit;">O artigo n√£o considerou muitas outras t√©cnicas (elas s√£o usadas com menos frequ√™ncia, mas poderiam ser igualmente eficazes), incluindo o seguinte:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algoritmos de tarefas de otimiza√ß√£o, incluindo escalar para o topo, descida de gradiente e algoritmos gen√©ticos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algoritmos competitivos de pesquisa / planejamento, como minimax e alfa beta clipping </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t√©cnicas de classifica√ß√£o, por exemplo, perceptrons, redes neurais e o m√©todo do vetor de suporte </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sistemas de percep√ß√£o de agentes e processamento de mem√≥ria </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abordagens arquitet√¥nicas da IA, como sistemas h√≠bridos, arquiteturas predicativas (arquiteturas Brooks) e outras maneiras de decompor sistemas da AI em camadas </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ferramentas de anima√ß√£o, como planejamento e correspond√™ncia de movimentos </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tarefas relacionadas ao desempenho, como n√≠vel de detalhe, algoritmos a qualquer momento e pontualidade </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para ler mais sobre esses t√≥picos, bem como os t√≥picos discutidos neste artigo, voc√™ pode estudar as seguintes fontes. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameDev.net tem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigos e tutoriais sobre intelig√™ncia artificial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bem como um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√≥rum sobre intelig√™ncia artificial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AiGameDev.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t√™m muitas apresenta√ß√µes e artigos sobre uma ampla gama de temas de intelig√™ncia artificial no contexto do desenvolvimento de jogos</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O GDC Vault possui relat√≥rios com o GDC AI Summit, muitos dos quais est√£o dispon√≠veis gratuitamente: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.gdcvault.com/</font></font></a> <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, o AI Game Programmers Guild possui v√°rios links para artigos e apresenta√ß√µes antigos desta c√∫pula: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://gameai.com/</font></font></a> <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O pesquisador de IA e desenvolvedor de jogos Tommy Thompson possui um canal no YouTube dedicado a explicar e explorar a IA em jogos comerciais: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.youtube.com/user/tthompso</font></font></a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Muitos dos materiais da mais alta qualidade podem ser encontrados nos livros, incluindo o seguinte: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Game AI Pro Series √© uma cole√ß√£o de artigos curtos que explicam como implementar recursos espec√≠ficos ou resolver problemas espec√≠ficos. </font><font style="vertical-align: inherit;">Em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.gameaipro.com/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> postou trechos gratuitos de livros anteriores.</font></font><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=http://go.gamedev.net/%3Fid%3D13722X707581%26amp%3Bxs%3D1%26amp%3Bisjs%3D1%26amp%3Burl%3Dhttps%253A%252F%252Famzn.to%252F2KGoB8n%26amp%3Bxguid%3Df8ad586e5984991508efff4754027dbd%26amp%3Bxuuid%3D305451ecead59d76ca830fded0aab276%26amp%3Bxsessid%3D6ccb8b9fa3f10b478b65f7ed703a447b%26amp%3Bxcreo%3D0%26amp%3Bxed%3D0%26amp%3Bsref%3Dhttps%253A%252F%252Fwww.gamedev.net%252Farticles%252Fprogramming%252Fartificial-intelligence%252Fthe-total-beginners-guide-to-game-ai-r4942%252F%253Fdo%253Dedit%2526d%253D1%2526id%253D4942%2526csrfKey%253D7015c6d2c5c643e87baa74f8e5d2c094%26amp%3Bpref%3D" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game AI Pro: sabedoria coletada dos profissionais de IA de jogos</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=http://go.gamedev.net/%3Fid%3D13722X707581%26amp%3Bxs%3D1%26amp%3Bisjs%3D1%26amp%3Burl%3Dhttps%253A%252F%252Famzn.to%252F2KFKyoe%26amp%3Bxguid%3Df8ad586e5984991508efff4754027dbd%26amp%3Bxuuid%3D305451ecead59d76ca830fded0aab276%26amp%3Bxsessid%3D6ccb8b9fa3f10b478b65f7ed703a447b%26amp%3Bxcreo%3D0%26amp%3Bxed%3D0%26amp%3Bsref%3Dhttps%253A%252F%252Fwww.gamedev.net%252Farticles%252Fprogramming%252Fartificial-intelligence%252Fthe-total-beginners-guide-to-game-ai-r4942%252F%253Fdo%253Dedit%2526d%253D1%2526id%253D4942%2526csrfKey%253D7015c6d2c5c643e87baa74f8e5d2c094%26amp%3Bpref%3D" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game AI Pro 2: sabedoria coletada dos profissionais de IA de jogos</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game AI Pro 3: sabedoria coletada dos profissionais de IA de jogos</font></font></a> <br></li></ul><br></li><li>  AI Game Programming Wisdom    Game AI Pro.      ,       .    ,          ! <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">AI Game Programming Wisdom 1</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">AI Game Programming Wisdom 2</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">AI Game Programming Wisdom 3</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">AI Game Programming Wisdom 4</a> <br></li></ul></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">Artificial Intelligence: A Modern Approach</a> ‚Äî      ,        .       ,     ,         ,      . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, existem v√°rios bons livros sobre IA de jogos em geral, escritos por profissionais do setor. </font><font style="vertical-align: inherit;">√â dif√≠cil dar prefer√™ncia a qualquer um - leia os coment√°rios e escolha aquele que mais lhe convier.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420219/">https://habr.com/ru/post/pt420219/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420205/index.html">ROMs baseadas em DNA, mem√≥ria de √°cido nucleico e substratos para OxRAM</a></li>
<li><a href="../pt420209/index.html">OpenAI demonstra a transfer√™ncia de manipula√ß√µes complexas de simula√ß√µes para o mundo real</a></li>
<li><a href="../pt420211/index.html">O pensamento m√°gico sobre o aprendizado de m√°quina n√£o aproximar√° a IA real</a></li>
<li><a href="../pt420213/index.html">Vis√£o geral da impressora 3D grande WANHAO D9 acess√≠vel</a></li>
<li><a href="../pt420215/index.html">Console, switches e muito caf√©: um dia na vida de hospedagem VDS</a></li>
<li><a href="../pt420221/index.html">Os invasores invadiram milhares de roteadores D-link e redirecionaram seus propriet√°rios para recursos maliciosos</a></li>
<li><a href="../pt420223/index.html">Algumas dicas simples: como evitar danos ao drone</a></li>
<li><a href="../pt420225/index.html">Melodia Algor√≠tmica Infinita Baseada em N√∫meros Primos</a></li>
<li><a href="../pt420227/index.html">Presidente turco anuncia proibi√ß√£o de importa√ß√£o de eletr√¥nicos nos EUA</a></li>
<li><a href="../pt420229/index.html">As crian√ßas das aldeias podem se tornar programadores se, nas proximidades, ensinarem apenas ferrovi√°rios. Conversa com o "C√≠rculo"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>