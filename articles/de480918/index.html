<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•å üß† üë©üèø‚Äçüè≠ Apache Hadoop Code Qualit√§t: Produktion VS Test üéå üïô üíÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um qualitativ hochwertigen Produktionscode zu erhalten, reicht es nicht aus, nur eine maximale Abdeckung mit Tests zu gew√§hrleisten. Keine Zweifel, gu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Hadoop Code Qualit√§t: Produktion VS Test</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480918/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c48/f76/cf1/c48f76cf15c8138ce1d944918b1dcc07.png" alt="Abbildung 1"></div><br>  Um qualitativ hochwertigen Produktionscode zu erhalten, reicht es nicht aus, nur eine maximale Abdeckung mit Tests zu gew√§hrleisten.  Keine Zweifel, gute Ergebnisse erfordern, dass der Hauptprojektcode und die Tests effizient zusammenarbeiten.  Tests m√ºssen daher genauso beachtet werden wie der Hauptcode.  Ein anst√§ndiger Test ist ein wichtiger Erfolgsfaktor, da er die Regression in der Produktion auff√§ngt.  Werfen wir einen Blick auf die Warnungen des PVS-Studio-Statikanalysators, um festzustellen, wie wichtig es ist, dass Fehler in Tests nicht schlechter sind als in der Produktion.  Der heutige Fokus: Apache Hadoop. <br><a name="habracut"></a><br><h2>  √úber das Projekt </h2><br>  Diejenigen, die sich fr√ºher f√ºr Big Data interessierten, haben wahrscheinlich das <a href="https://hadoop.apache.org/">Apache Hadoop-</a> Projekt geh√∂rt oder sogar mit ihm zusammengearbeitet.  Kurz gesagt, Hadoop ist ein Framework, das als Grundlage f√ºr den Aufbau und die Arbeit mit Big Data-Systemen verwendet werden kann. <br><br>  Hadoop besteht aus vier Hauptmodulen, die jeweils eine bestimmte Aufgabe erf√ºllen, die f√ºr ein Big-Data-Analysesystem erforderlich ist: <br><br><ul><li>  Hadoop gemeinsam </li><li>  Mapreduce </li><li>  Hadoop Distributed File System </li><li>  Garn </li></ul><br>  Jedenfalls gibt es im Internet jede Menge Materialien dazu. <br><br><h2>  √úber den Scheck </h2><br>  Wie in der Dokumentation gezeigt, kann PVS-Studio auf verschiedene Arten in das Projekt integriert werden: <br><br><ul><li>  Verwenden des Maven-Plugins; </li><li>  Verwenden des Gradle-Plugins; </li><li>  Verwenden der gradle IntellJ IDEA; </li><li>  Direkt mit dem Analysator. </li></ul><br>  Hadoop basiert auf dem Maven-Build-System, daher gab es keine Hindernisse bei der √úberpr√ºfung. <br><br>  Nachdem ich das Skript aus der Dokumentation integriert und eine der pom.xml-Dateien bearbeitet hatte (es gab Module in Abh√§ngigkeiten, die nicht verf√ºgbar waren), wurde die Analyse gestartet! <br><br>  Nachdem die Analyse abgeschlossen war, w√§hlte ich die interessantesten Warnungen aus und stellte fest, dass ich im Produktionscode und in Tests die gleiche Anzahl von Warnungen hatte.  Normalerweise ber√ºcksichtige ich keine Warnungen des Analyseger√§ts, die f√ºr Tests ausgegeben wurden.  Aber als ich sie teilte, konnte ich die Warnungen vor "Tests" nicht unbeaufsichtigt lassen.  ‚ÄûWarum sie sich nicht ansehen?‚Äú - dachte ich, denn Fehler in Tests k√∂nnten auch nachteilige Folgen haben.  Sie k√∂nnen zu inkorrekten oder teilweisen Tests oder sogar zu Mischmasch f√ºhren (sie existieren nur, um das Kontrollk√§stchen zu aktivieren, dass sie immer gr√ºn sind). <br><br>  Nachdem ich die interessantesten Warnungen ausgew√§hlt hatte, teilte ich sie in die folgenden Gruppen ein: Produktion, Test und die vier Hauptmodule von Hadoop.  Und jetzt bin ich froh, Ihnen die √úberpr√ºfung der Warnungen des Analyseger√§ts anbieten zu k√∂nnen. <br><br><h2>  Produktionscode </h2><br><h3>  Hadoop gemeinsam </h3><br>  <a href="https://www.viva64.com/en/w/v6033/">V6033</a> Ein Artikel mit demselben Schl√ºssel 'KDC_BIND_ADDRESS' wurde bereits hinzugef√ºgt.  MiniKdc.java (163), MiniKdc.java (162) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MiniKdc</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;String&gt; PROPERTIES = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;String&gt;(); .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { PROPERTIES.add(ORG_NAME); PROPERTIES.add(ORG_DOMAIN); PROPERTIES.add(KDC_BIND_ADDRESS); PROPERTIES.add(KDC_BIND_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">// &lt;= PROPERTIES.add(KDC_PORT); PROPERTIES.add(INSTANCE); .... } .... }</span></span></code> </pre> <br>  Der doppelte Mehrwert in <i>HashSet</i> ist ein sehr h√§ufiger Fehler bei der √úberpr√ºfung von Projekten.  Der zweite Zusatz wird ignoriert.  Ich hoffe, diese Vervielf√§ltigung ist nur eine unn√∂tige Trag√∂die.  Was ist, wenn ein anderer Wert hinzugef√ºgt werden soll? <br><br><h3>  Mapreduce </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise ist dies ein Tippfehler, und die Variable 'localFiles' sollte anstelle von 'localArchives' verwendet werden.  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  Die V6072-Diagnose liefert manchmal einige interessante Ergebnisse.  Der Zweck dieser Diagnose besteht darin, identische Codefragmente zu erkennen, die beim Kopieren und Ersetzen von ein bis zwei Variablen entstanden sind.  In diesem Fall wurden einige Variablen sogar "unterbewertet" gelassen. <br><br>  Der obige Code demonstriert dies.  Im ersten Block wird die Variable <i>localArchives</i> verwendet, im zweiten √§hnlichen Fragment <i>localFiles</i> .  Wenn Sie diesen Code mit der gebotenen Sorgfalt studieren und ihn dann schnell <i>durcharbeiten</i> , wie dies h√§ufig bei der <i>Code√ºberpr√ºfung</i> der <i>Fall</i> ist, werden Sie das Fragment bemerken, bei dem der Autor vergessen hat, die Variable <i>localArchives</i> zu ersetzen. <br><br>  Diese Gaffe kann zu folgendem Szenario f√ºhren: <br><br><ul><li>  Angenommen, wir haben <i>localArchives</i> (Gr√∂√üe = 4) und <i>localFiles</i> (Gr√∂√üe = 2); </li><li>  Beim Erstellen des Arrays <i>localFiles.toArray (neuer String [localArchives.size ()])</i> sind die letzten <i>beiden</i> Elemente <i>null</i> (["pathToFile1", "pathToFile2", null, null]); </li><li>  Dann gibt <i>org.apache.hadoop.util.StringUtils.arrayToString</i> die Zeichenfolgendarstellung unseres Arrays zur√ºck, in der die letzten Dateinamen als "null" ("pathToFile1, pathToFile2, null, null" <i>) dargestellt werden</i> . </li><li>  All dies wird weitergegeben und Gott wei√ü nur, welche Art von Kontrollen es f√ºr solche F√§lle gibt =). </li></ul><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007</a> Ausdruck 'children.size ()&gt; 0' ist immer wahr.  Queue.java (347) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHierarchySameAs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Queue newState)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || children.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(children.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... }</code> </pre> <br>  Da die Anzahl der Elemente separat auf 0 gepr√ºft wird, ist die weitere Pr√ºfung <i>children.size ()&gt; 0</i> immer wahr. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/en/w/v6001/">V6001</a> Links und rechts vom Operator '%' gibt es identische Unterausdr√ºcke 'this.bucketSize'.  RollingWindow.java (79) <br><br><pre> <code class="java hljs"> RollingWindow(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> windowLenMs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numBuckets) { buckets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket[numBuckets]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numBuckets; i++) { buckets[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.windowLenMs = windowLenMs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize = windowLenMs / numBuckets; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize % bucketSize != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new IllegalArgumentException( "The bucket size in the rolling window is not integer: windowLenMs= " + windowLenMs + " numBuckets= " + numBuckets); } }</span></span></code> </pre> <br>  Hier besteht der Mangel darin, dass die Variable durch sich selbst geteilt wird.  Infolgedessen ist die Pr√ºfung auf Multiplizit√§t immer erfolgreich, und im Falle falscher Eingaben ( <i>windowLenMs</i> , <i>numBuckets</i> ) wird die Ausnahme niemals ausgel√∂st. <br><br><h3>  Garn </h3><br>  <a href="https://www.viva64.com/en/w/v6067/">V6067</a> Zwei oder mehr <a href="https://www.viva64.com/en/w/v6067/">Fallzweige</a> f√ºhren die gleichen Aktionen aus.  TimelineEntityV2Converter.java (386), TimelineEntityV2Converter.java (389) <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ApplicationReport </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToApplicationReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TimelineEntity entity)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (metrics != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> memorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedVcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedMemorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TimelineMetric metric : metrics) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (metric.getId()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_CPU_METRICS: vcoreSeconds = getAverageValue(metric.getValues().values()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_METRICS: memorySeconds = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS: preemptedVcoreSeconds = ....; <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS: preemptedVcoreSeconds = ....; // &lt;= break; default: // Should not happen.. break; } } .... } .... }</span></span></code> </pre> <br>  Gleiche Codefragmente in zwei <i>case</i> Zweigen.  Es ist einfach √ºberall!  In der √ºberwiegenden Anzahl von F√§llen handelt es sich nicht um einen echten Fehler, sondern nur um einen Grund, √ºber eine Umgestaltung des <i>Switch</i> nachzudenken.  Aber nicht f√ºr den vorliegenden Fall.  Wiederholte Codefragmente setzen den Wert der Variablen <i>preemptedVcoreSeconds</i> .  Wenn Sie sich die Namen aller Variablen und Konstanten genau <i>ansehen</i> , werden Sie wahrscheinlich den Schluss ziehen, dass im Fall von <i>metric.getId () == APP_MEM_PREEMPT_METRICS</i> der Wert f√ºr die Variable <i>preemptedMemorySeconds festgelegt</i> werden muss, nicht f√ºr <i>preemptedVcoreSeconds</i> .  In dieser Hinsicht bleibt <i>preemptedMemorySeconds</i> nach dem Operator 'switch' immer auf 0, w√§hrend der Wert von <i>preemptedVcoreSeconds</i> m√∂glicherweise falsch ist. <br><br>  <a href="https://www.viva64.com/en/w/v6046/">V6046</a> Falsches Format.  Eine andere Anzahl von Formatelementen wird erwartet.  Nicht verwendete Argumente: 2. AbstractSchedulerPlanFollower.java (186) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synchronizePlan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Plan plan, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shouldReplan)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setQueueEntitlement(planQueueName, ....); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (YarnException e) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Exception while trying to size reservation for plan: {}"</span></span>, currResId, planQueueName, e); } .... }</code> </pre> <br>  Die Variable <i>planQueueName</i> wird bei der Protokollierung nicht verwendet.  In diesem Fall wird entweder zu viel kopiert oder die Formatzeichenfolge ist nicht fertig.  Aber ich beschuldige immer noch die gute alte Kopierpaste, die in manchen F√§llen einfach gro√üartig ist, um sich in den Fu√ü zu schie√üen. <br><br><h2>  Code testen </h2><br><h3>  Hadoop gemeinsam </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise ist dies ein Tippfehler, und die Variable 'allSecretsB' sollte anstelle von 'allSecretsA' verwendet werden.  TestZKSignerSecretProvider.java (316), TestZKSignerSecretProvider.java (309), TestZKSignerSecretProvider.java (306), TestZKSignerSecretProvider.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMultiple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... currentSecretA = secretProviderA.getCurrentSecret(); allSecretsA = secretProviderA.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretA); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, allSecretsA.length); <span class="hljs-comment"><span class="hljs-comment">// &lt;= Assert.assertArrayEquals(secretA2, allSecretsA[0]); Assert.assertArrayEquals(secretA1, allSecretsA[1]); currentSecretB = secretProviderB.getCurrentSecret(); allSecretsB = secretProviderB.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretB); Assert.assertEquals(2, allSecretsA.length); // &lt;= Assert.assertArrayEquals(secretA2, allSecretsB[0]); Assert.assertArrayEquals(secretA1, allSecretsB[1]); .... }</span></span></code> </pre> <br>  Und wieder das V6072.  Schauen Sie sich die Variablen <i>allSecretsA</i> und <i>allSecretsB</i> genau an. <br><br>  <a href="https://www.viva64.com/en/w/v6043/">V6043</a> Betrachten Sie den Operator 'f√ºr'.  Anfangs- und Endwert des Iterators sind gleich.  TestTFile.java (235) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrepWithUnknownLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scanner scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = start; i &lt; start; i++) { String key = String.format(localFormatter, i); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] read = readKey(scanner); assertTrue(<span class="hljs-string"><span class="hljs-string">"keys not equal"</span></span>, Arrays.equals(key.getBytes(), read)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { read = readValue(scanner); assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ie) { <span class="hljs-comment"><span class="hljs-comment">// should have thrown exception } String value = "value" + key; read = readLongValue(scanner, value.getBytes().length); assertTrue("values nto equal", Arrays.equals(read, value.getBytes())); scanner.advance(); } return (start + n); }</span></span></code> </pre> <br>  Ein Test, der immer gr√ºn ist?  =).  Ein Teil der Schleife, der Teil des Tests selbst ist, wird niemals ausgef√ºhrt.  Dies liegt daran, dass der Anfangs- und der Endz√§hlerwert in der <i>for-</i> Anweisung gleich sind.  Infolgedessen wird die Bedingung <i>i &lt;start</i> sofort falsch und f√ºhrt zu einem solchen Verhalten.  Ich habe die Testdatei durchgearbeitet und bin zu dem Schluss gekommen, dass <i>i &lt;(start + n)</i> tats√§chlich in der Schleifenbedingung geschrieben werden musste. <br><br><h3>  Mapreduce </h3><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 Der</a> Ausdruck 'byteAm &lt;0' ist immer falsch.  DataWriter.java (322) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">GenerateOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeSegment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> byteAm, OutputStream out)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> headerLen = getHeaderLength(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byteAm &lt; headerLen) { <span class="hljs-comment"><span class="hljs-comment">// not enough bytes to write even the header return new GenerateOutput(0, 0); } // adjust for header length byteAm -= headerLen; if (byteAm &lt; 0) { // &lt;= byteAm = 0; } .... }</span></span></code> </pre> <br>  Die Bedingung <i>byteAm &lt;0</i> ist immer falsch.  Um es herauszufinden, geben wir den Code √ºber einen anderen Blick.  Wenn die Testausf√ºhrung die Operation <i>byteAm - = headerLen erreicht</i> , bedeutet dies, dass <i>byteAm&gt; = headerLen.</i>  Ab hier wird der <i>ByteAm-</i> Wert nach der Subtraktion niemals negativ sein.  Das mussten wir beweisen. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise ist dies ein Tippfehler, und die Variable 'normalFile' sollte anstelle von 'normalDir' verwendet werden.  TestWebHDFS.java (625), TestWebHDFS.java (615), TestWebHDFS.java (614), TestWebHDFS.java (624) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWebHdfsErasureCodingFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(<span class="hljs-string"><span class="hljs-string">"/dir"</span></span>); dfs.mkdirs(normalDir); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(normalDir, <span class="hljs-string"><span class="hljs-string">"file.log"</span></span>); .... <span class="hljs-comment"><span class="hljs-comment">// logic block #1 FileStatus expectedNormalDirStatus = dfs.getFileStatus(normalDir); FileStatus actualNormalDirStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalDirStatus.isErasureCoded(), actualNormalDirStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalDir); assertTrue(normalDir + " should have erasure coding unset in " + ....); // logic block #2 FileStatus expectedNormalFileStatus = dfs.getFileStatus(normalFile); FileStatus actualNormalFileStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalFileStatus.isErasureCoded(), actualNormalFileStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalFile); assertTrue( normalFile + " should have erasure coding unset in " + ....); }</span></span></code> </pre> <br>  Ob Sie es glauben oder nicht, es ist wieder V6072!  <i>Folgen</i> <i>Sie</i> einfach den Variablen <i>normalDir</i> und <i>normalFile.</i> <br><br>  <a href="https://www.viva64.com/en/w/v6027/">V6027</a> Variablen werden durch Aufruf derselben Funktion initialisiert.  Es ist wahrscheinlich ein Fehler oder nicht optimierter Code.  TestDFSAdmin.java (883), TestDFSAdmin.java (879) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyNodesAndCorruptBlocks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numLiveDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptECBlockGroups, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DFSClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyReplicatedBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyECBlocks)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init vars */</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String expectedCorruptedECBlockGroupsStr = String.format( <span class="hljs-string"><span class="hljs-string">"Block groups with corrupt internal blocks: %d"</span></span>, numCorruptECBlockGroups); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyReplicatedBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyECBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); .... }</code> </pre> <br>  In diesem Fragment werden die Variablen <i>highestPriorityLowRedundancyReplicatedBlocksStr</i> und <i>highestPriorityLowRedundancyECBlocksStr</i> mit denselben Werten initialisiert.  Oft sollte es so sein, aber das ist nicht der Fall.  Variablennamen sind lang und √§hnlich, so dass es nicht verwunderlich ist, dass das kopierte Fragment in keiner Weise ge√§ndert wurde.  Um dies zu beheben, muss der Autor beim Initialisieren der Variable <i>highestPriorityLowRedundancyECBlocksStr</i> den Eingabeparameter <i>highestPriorityLowRedundancyECBlocks verwenden</i> .  Dar√ºber hinaus m√ºssen sie h√∂chstwahrscheinlich die Formatzeile noch korrigieren. <br><br>  <a href="https://www.viva64.com/en/w/v6019/">V6019</a> Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  TestReplaceDatanodeFailureReplication.java (222) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyFileContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., SlowWriter[] slowwriters)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Verify the file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slowwriters.length; i++) { LOG.info(slowwriters[i].filepath + ....); FSDataInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { in = fs.open(slowwriters[i].filepath); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, x;; j++) { x = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x) != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { Assert.assertEquals(j, x); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { IOUtils.closeStream(in); } } }</code> </pre> <br>  Der Analysator beschwert sich, dass der <i>i ++ -</i> Z√§hler in der Schleife nicht ge√§ndert werden kann.  Dies bedeutet, dass in der <i>for (int i = 0; i &lt;slowwriters.length; i ++) {....}</i> -Schleife nicht mehr als eine Iteration ausgef√ºhrt wird.  Finden wir heraus warum.  In der ersten Iteration verkn√ºpfen wir den Thread zum weiteren Lesen mit der Datei, die <i>Slowwriters [0]</i> entspricht.  Als n√§chstes lesen wir den Dateiinhalt √ºber die Schleife <i>nach (int j = 0, x ;; j ++):</i> <br><br><ul><li>  Wenn wir etwas Relevantes lesen, vergleichen wir das gelesene Byte mit dem aktuellen Wert des Z√§hlers <i>j √ºber</i> <i>assertEquals</i> (wenn die Pr√ºfung nicht erfolgreich ist, <i>schlagen</i> wir den Test fehl). </li><li>  Wenn die Datei erfolgreich √ºberpr√ºft wurde und das Dateiende erreicht ist (wir lesen -1), wird die Methode beendet. </li></ul><br>  <i>Unabh√§ngig davon</i> , was bei der Pr√ºfung von <i>Slowwritern [0]</i> passiert, werden nachfolgende Elemente nicht gepr√ºft.  H√∂chstwahrscheinlich muss <i>break</i> anstelle von <i>return verwendet werden.</i> <br><br><h3>  Garn </h3><br>  <a href="https://www.viva64.com/en/w/v6019/">V6019</a> Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  TestNodeManager.java (176) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCreationOfNodeLabelsProviderService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Assert.fail(<span class="hljs-string"><span class="hljs-string">"Exception caught"</span></span>); e.printStackTrace(); } }</code> </pre> <br>  In diesem <i>Fall</i> unterbricht die <i>Assert.fail-</i> Methode den Test und die <i>Stapelverfolgung</i> wird im Falle einer Ausnahme nicht gedruckt.  Wenn die Meldung √ºber die gefangene Ausnahme hier ausreicht, sollten Sie das Drucken der Stapelverfolgung entfernen, um Verwirrung zu vermeiden.  Wenn Sie drucken m√ºssen, m√ºssen Sie sie nur austauschen. <br><br>  Viele √§hnliche Fragmente wurden gefunden: <br><br><ul><li>  V6019 Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  TestResourceTrackerService.java (928) </li><li>  V6019 Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  TestResourceTrackerService.java (737) </li><li>  V6019 Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  TestResourceTrackerService.java (685) </li><li>  .... </li></ul><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise ist dies ein Tippfehler, und die Variable 'publicCache' sollte anstelle von 'usercache' verwendet werden.  TestResourceLocalizationService.java (315), TestResourceLocalizationService.java (309), TestResourceLocalizationService.java (307), TestResourceLocalizationService.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDirectoryCleanupOnNewlyCreatedStateStore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, URISyntaxException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// verify directory creation for (Path p : localDirs) { p = new Path((new URI(p.toString())).getPath()); // logic block #1 Path usercache = new Path(p, ContainerLocalizer.USERCACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(usercache), ....); // logic block #2 Path publicCache = new Path(p, ContainerLocalizer.FILECACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(publicCache), ....); .... } .... }</span></span></code> </pre> <br>  Und zum Schluss nochmal V6072 =).  Variablen zum Anzeigen des verd√§chtigen Fragments: <i>usercache</i> und <i>publicCache</i> . <br><br><h2>  Fazit </h2><br>  Hunderttausende von Codezeilen werden in der Entwicklung geschrieben.  Produktionscode wird normalerweise von Fehlern, Defekten und M√§ngeln freigehalten (Entwickler testen ihren Code, der Code wird √ºberpr√ºft usw.).  Tests sind in dieser Hinsicht definitiv unterlegen.  Fehler in Tests k√∂nnen sich leicht hinter einem "gr√ºnen H√§kchen" verstecken.  Wie Sie wahrscheinlich aus der heutigen √úberpr√ºfung der Warnungen erfahren haben, ist ein gr√ºner Test nicht immer eine erfolgreiche Pr√ºfung. <br><br>  Bei der √úberpr√ºfung der Apache Hadoop-Codebasis stellte sich diesmal heraus, dass statische Analysen sowohl im Produktionscode als auch in Tests, die auch bei der Entwicklung eine wichtige Rolle spielen, dringend erforderlich sind. <br><br>  Wenn Sie sich also um Ihren Code k√ºmmern und die Qualit√§t testen, empfehle ich Ihnen, die statische Analyse im Auge zu behalten.  Lassen Sie <a href="https://www.viva64.com/en/pvs-studio-download/">PVS-Studio</a> der erste Anw√§rter in diesem Unternehmen sein. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480918/">https://habr.com/ru/post/de480918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480904/index.html">PHP Microservice Framework: Entwicklungsumgebung f√ºr Swoft</a></li>
<li><a href="../de480906/index.html">Ein einfaches Python-Spiel schreiben</a></li>
<li><a href="../de480910/index.html">Erstellen einer grundlegenden Testklasse f√ºr Selentests und Initialisieren √ºber JUnit RuleChain</a></li>
<li><a href="../de480912/index.html">Dap in Aktion. TodoMVC schreiben. Teil 1</a></li>
<li><a href="../de480914/index.html">Microservices f√ºr Einsteiger</a></li>
<li><a href="../de480920/index.html">Test von TP-Link Switches mit Long Range PoE. Und ein bisschen √ºber Upgrades alter Modelle</a></li>
<li><a href="../de480922/index.html">Evgeny Usvitsky: ‚ÄûJeder auf der Welt wei√ü, wo er Geodaten frei bekommen kann - nur in OSM‚Äú</a></li>
<li><a href="../de480924/index.html">Wie und warum haben die Macher des Remakes von MediEvil den Kult-Boss des Spiels neu gestaltet</a></li>
<li><a href="../de480926/index.html">Wahrscheinlichkeitstheorie f√ºr physikalisch genaues Rendern</a></li>
<li><a href="../de480928/index.html">Apache Hadoop Code Qualit√§t: Produktion VS Test</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>