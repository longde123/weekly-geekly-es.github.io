<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕊️ 📊 🤳🏽 Testes C sem SMS e registro 💄 👩‍👦 👨🏼‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, a zerocost escreveu um artigo interessante, “Testes em C ++ sem macros e memória dinâmica” , que discute uma estrutura minimalista para ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testes C sem SMS e registro</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435028/"><p><img src="https://habrastorage.org/webt/lg/12/b3/lg12b3c-s5uuok0_nialgfngc9e.png" alt="Cortador de Screenshot" align="right">  Recentemente, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">zerocost</a> escreveu um artigo interessante, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“Testes em C ++ sem macros e memória dinâmica”</a> , que discute uma estrutura minimalista para testar o código C ++.  O autor (quase) conseguiu evitar o uso de macros para registrar testes, mas em vez deles, modelos "mágicos" apareceram no código, o que pessoalmente me parece, desculpe, inimaginavelmente feio.  Depois de ler o artigo, tive uma vaga sensação de insatisfação, pois <em>sabia o</em> que poderia ser feito melhor.  Não consegui me lembrar imediatamente de onde, mas <em>definitivamente vi</em> o código de teste, que não contém um único caractere extra para registrá-los: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ensure_equals(<span class="hljs-string"><span class="hljs-string">"2 + 2 = ?"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br><p>  Por fim, lembrei-me de que essa estrutura é chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Cutter</strong></a> e usa uma maneira genial de identificar funções de teste à sua maneira. </p><a name="habracut"></a><br><p>  (KDPV retirado do site da Cutter sob CC BY-SA.) </p><br><h2 id="v-chyom-zhe-tryuk">  Qual é o truque? </h2><br><p>  O código de teste é montado em uma biblioteca compartilhada separada.  As funções de teste são extraídas dos símbolos da biblioteca exportados e identificadas pelos nomes.  Os testes são realizados por um utilitário externo especial.  Sapienti sentou-se. </p><br><pre> <code class="cpp hljs">$ cat test_addition.c <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cutter.h&gt; void test_addition() { cut_assert_equal_int(2 + 2, 5); }</span></span></span></span></code> </pre> <br><pre> <code class="plaintext hljs">$ cc -shared -o test_addition.so \ -I/usr/include/cutter -lcutter \ test_addition.c</code> </pre> <br><pre> <code class="plaintext hljs">$ cutter . F ========================================================================= Failure: test_addition &lt;2 + 2 == 5&gt; expected: &lt;4&gt; actual: &lt;5&gt; test_addition.c:5: void test_addition(): cut_assert_equal_int(2 + 2, 5, ) ========================================================================= Finished in 0.000943 seconds (total: 0.000615 seconds) 1 test(s), 0 assertion(s), 1 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s) 0% passed</code> </pre> <br><p>  Aqui está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo da documentação do cortador</a> .  Você pode rolar com segurança tudo relacionado ao Autotools e ver apenas o código.  A estrutura é um pouco estranha, sim, como tudo japonês. </p><br><p>  Não entrarei em muitos detalhes sobre os recursos de implementação.  Também não tenho um código completo (e até pelo menos rascunho), pois pessoalmente não preciso dele (no Rust, tudo está fora da caixa).  No entanto, para as pessoas interessadas, este pode ser um bom exercício. </p><br><h2 id="detali-i-vozmozhnosti-realizacii">  Detalhes e opções de implementação </h2><br><p>  Considere algumas das tarefas que você precisa resolver ao escrever uma estrutura para teste usando a abordagem Cutter. </p><br><h3 id="poluchenie-eksportiruemyh-funkciy">  Obtendo funções exportadas </h3><br><p>  Primeiro, você precisa acessar as funções de teste de alguma forma.  O padrão C ++, é claro, não descreve bibliotecas compartilhadas.  O Windows adquiriu recentemente um subsistema Linux, que permite reduzir os três principais sistemas operacionais para POSIX.  Como você sabe, os sistemas POSIX fornecem as funções <code>dlopen()</code> , <code>dlsym()</code> , <code>dlclose()</code> , com as quais você pode obter o endereço da função, sabendo o nome do seu símbolo e ... isso é tudo.  A lista de funções contidas na biblioteca carregada não é divulgada pelo POSIX. </p><br><p>  Infelizmente (embora felizmente), não existe uma maneira portátil padrão de descobrir todas as funções exportadas da biblioteca.  Talvez o fato de o conceito de <em>biblioteca</em> não existir em todas as plataformas (leia-se: incorporado) esteja de alguma forma envolvido aqui.  Mas esse não é o ponto.  O principal é que você precisa usar recursos específicos da plataforma. </p><br><p>  Como uma aproximação inicial, você pode simplesmente chamar o utilitário <strong>nm</strong> : </p><br><pre> <code class="cpp hljs">$ cat test.<span class="hljs-function"><span class="hljs-function">cpp </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><pre> <code class="plaintext hljs">$ clang -shared test.cpp</code> </pre> <br><pre> <code class="plaintext hljs">$ nm -gj ./a.out __Z20test_object_additionv dyld_stub_binder</code> </pre> <br><p>  analise sua saída e use <code>dlsym()</code> . </p><br><p>  Para uma introspecção mais profunda, bibliotecas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">libelf</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">libMachO</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pe-parse são</a> úteis, permitindo analisar programaticamente arquivos executáveis ​​e bibliotecas de plataformas de seu interesse.  De fato, a <strong>nm</strong> e a empresa apenas as usam. </p><br><h3 id="filtraciya-testovyh-funkciy">  Filtragem da função de teste </h3><br><p>  Como você deve ter notado, as bibliotecas contêm alguns caracteres estranhos: </p><br><pre> <code class="plaintext hljs">__Z20test_object_additionv dyld_stub_binder</code> </pre> <br><p>  Isto é o que <code>__Z20test_object_additionv</code> quando chamamos a função just <code>test_object_addition</code> ?  E o que resta deste <code>dyld_stub_binder</code> ? </p><br><p>  Os caracteres " <code>__Z20...</code> " <code>__Z20...</code> são a chamada <em>decoração de</em> nome (nome desconcertante).  Recurso de compilação em C ++, nada pode ser feito, viva com ele.  É assim que as funções são chamadas do ponto de vista do sistema (e <code>dlsym()</code> ).  Para mostrá-los a uma pessoa em sua forma normal, você pode usar bibliotecas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">libdemangle</a> .  Obviamente, a biblioteca que você precisa depende do compilador usado, mas o formato da decoração geralmente é o mesmo dentro da estrutura da plataforma. </p><br><p>  Quanto a funções estranhas como <code>dyld_stub_binder</code> , esses também são recursos da plataforma que devem ser levados em consideração.  Você não precisa chamar nenhuma função ao iniciar os testes, pois não há peixes lá. </p><br><p>  Uma continuação lógica dessa idéia é filtrar a função pelo nome.  Por exemplo, você só pode executar funções com <code>test</code> no nome.  Ou apenas funções do namespace de <code>tests</code> .  E também use namespaces aninhados para agrupar testes.  Não há limite para sua imaginação. </p><br><h3 id="peredacha-konteksta-ispolnyaemogo-testa">  Passando o contexto de um teste executável </h3><br><p>  Os arquivos de objetos com testes são coletados em uma biblioteca compartilhada, cuja execução é completamente controlada por um utilitário externo - <code>cutter</code> para o Cutter.  Consequentemente, as funções de teste interno podem usar isso. </p><br><p>  Por exemplo, o contexto de um teste executável ( <code>IRuntime</code> no artigo original) pode ser passado com segurança por uma variável global (thread-local).  O motorista é responsável por gerenciar e passar o contexto. </p><br><p>  Nesse caso, as funções de teste não requerem argumentos, mas mantêm todos os recursos avançados, como a nomeação arbitrária dos casos testados: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_vector_add_element</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ testing::description(<span class="hljs-string"><span class="hljs-string">"vector size grows after push_back()"</span></span>); }</code> </pre> <br><p>  A função <code>description()</code> acessa o <code>IRuntime</code> condicional <code>IRuntime</code> meio de uma variável global e, portanto, pode passar um comentário para a estrutura de uma pessoa.  A segurança do uso do contexto global é garantida pela estrutura e não é de responsabilidade do gravador de teste. </p><br><p>  Com essa abordagem, haverá menos ruído no código com a transferência de contexto para as instruções de comparação e funções de teste internas que podem precisar ser chamadas da principal. </p><br><h3 id="konstruktory-i-destruktory">  Construtores e destruidores </h3><br><p>  Como a execução dos testes é completamente controlada pelo driver, ele pode executar códigos adicionais em <em>torno dos</em> testes. </p><br><p>  A biblioteca do cortador usa as seguintes funções para isso: </p><br><ul><li>  <code>cut_setup()</code> - antes de cada teste individual </li><li>  <code>cut_teardown()</code> - após cada teste individual </li><li>  <code>cut_startup()</code> - antes de executar todos os testes </li><li>  <code>cut_shutdown()</code> - após a conclusão de todos os testes </li></ul><br><p>  Essas funções são chamadas apenas se definidas no arquivo de teste.  Você pode colocar neles a preparação e limpeza do ambiente de teste (dispositivo elétrico): a criação dos arquivos temporários necessários, a difícil configuração dos objetos testados e outros antipadrões de teste. </p><br><p>  Para C ++, é possível criar uma interface mais idiomática: </p><br><ul><li>  mais orientado a objeto e tipo seguro </li><li>  com melhor suporte ao conceito RAII </li><li>  usando lambdas para execução adiada </li><li>  envolvendo o contexto de execução de teste </li></ul><br><p>  Mas, por enquanto, estou pensando nisso novamente em detalhes agora. </p><br><h3 id="samodostatochnye-ispolnimye-fayly-s-testami">  Executáveis ​​de teste independentes </h3><br><p>  O Cutter usa uma abordagem de biblioteca compartilhada por conveniência.  Vários testes são compilados em um conjunto de bibliotecas que um utilitário de teste separado localiza e executa.  Naturalmente, se desejado, todo o código do driver de teste pode ser incorporado diretamente no arquivo executável, obtendo os arquivos comuns comuns.  No entanto, isso exigirá colaboração com o sistema de compilação para organizar o layout desses arquivos executáveis ​​da maneira correta: sem cortar as funções "não utilizadas", com as dependências corretas, etc. </p><br><h3 id="prochee">  Outros </h3><br><p>  O Cutter e outras estruturas também têm muitas outras coisas úteis que podem facilitar a vida ao escrever testes: </p><br><ul><li>  instruções de teste flexíveis e <em>extensíveis</em> </li><li>  construindo e obtendo dados de teste de arquivos </li><li>  estudos de rastreamento de pilha, manipulação de exceção e queda </li><li>  "níveis de detalhamento" personalizáveis ​​de testes </li><li>  executando testes em vários processos </li></ul><br><p>  Vale a pena olhar para as estruturas existentes ao escrever sua bicicleta.  UX é um tópico muito mais profundo. </p><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>  A abordagem usada pela estrutura do Cutter permite a identificação de funções de teste com carga cognitiva mínima no programador: basta escrever as funções de teste e é isso.  O código não requer o uso de modelos ou macros especiais, o que aumenta sua legibilidade. </p><br><p>  Os recursos de montagem e execução de testes podem estar ocultos em módulos reutilizáveis ​​para sistemas de montagem como Makefile, CMake, etc. Perguntas sobre uma montagem de testes separada ainda terão que ser feitas de uma maneira ou de outra. </p><br><p>  As desvantagens dessa abordagem incluem a dificuldade de colocar os testes no mesmo arquivo (a mesma unidade de tradução) do código principal.  Infelizmente, nesse caso, sem dicas adicionais, não é mais possível descobrir quais funções precisam ser ativadas e quais não.  Felizmente, em C ++, geralmente é comum distribuir testes e implementação em arquivos diferentes. </p><br><p>  Quanto à disposição final das macros, parece-me que, em <em>princípio,</em> elas não devem ser abandonadas.  As macros permitem, por exemplo, escrever instruções de comparação mais curtas, evitando a duplicação de código: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ensure_equals(<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); }</code> </pre> <br><p>  mas, ao mesmo tempo, mantendo o mesmo conteúdo informativo do problema em caso de erros: </p><br><pre> <code class="plaintext hljs">Failure: test_object_addition &lt;ensure_equals(2 + 2, 5)&gt; expected: &lt;5&gt; actual: &lt;4&gt; test.c:5: test_object_addition()</code> </pre> <br><p>  O nome da função que está sendo testada, o nome do arquivo e o número da linha do início da função, em teoria, podem ser extraídos das informações de depuração contidas na biblioteca que está sendo coletada.  O valor esperado e real das expressões comparadas são conhecidas pela função <code>ensure_equals()</code> .  A macro permite "restaurar" a ortografia original da instrução de teste, da qual fica mais claro por que o valor <code>4</code> é esperado. </p><br><p>  No entanto, isso não é para todos.  O benefício das macros para o código de teste termina aí?  Ainda não pensei nesse momento, o que pode se tornar um bom campo para mais <del>  perversões </del>  pesquisa.  Uma pergunta muito mais interessante: é possível criar, de alguma forma, uma <em>estrutura simulada</em> para C ++ sem macros? </p><br><p>  O leitor atento também observou que realmente não há SMS e amianto na implementação, o que é uma vantagem indubitável para a ecologia e a economia da Terra. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435028/">https://habr.com/ru/post/pt435028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435014/index.html">Dart vs Node.js: comparando o desempenho em implementações de servidor HTTP</a></li>
<li><a href="../pt435016/index.html">O que Larry Ellison trará para Tesla</a></li>
<li><a href="../pt435018/index.html">Em 2018, finalmente começamos a levar a sério o tempo gasto no smartphone</a></li>
<li><a href="../pt435020/index.html">Consumer Electronics Hall of Fame: As histórias dos melhores gadgets dos últimos 50 anos, parte 2</a></li>
<li><a href="../pt435026/index.html">Criamos um messenger * que funciona mesmo no elevador</a></li>
<li><a href="../pt435032/index.html">A sonda Chang'e-4 fez um pouso bem-sucedido no lado oposto da lua e enviou a primeira foto</a></li>
<li><a href="../pt435036/index.html">Pensamentos sobre C ++ moderno e desenvolvimento de jogos</a></li>
<li><a href="../pt435038/index.html">Energia nuclear mundial em 2018</a></li>
<li><a href="../pt435040/index.html">Bitcoin há 10 anos</a></li>
<li><a href="../pt435044/index.html">Antiguidades: Minidisc em seu habitat natural</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>