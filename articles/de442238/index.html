<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥üèæ üêï üëÑ Verwenden von Waves Smart Accounts: Von Auktionen zu Bonusprogrammen üëê üë∏üèæ ‚ô†Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blockchain wird oft nur mit Kryptow√§hrungen assoziiert, aber der Umfang der DLT-Technologie ist viel breiter. Einer der vielversprechendsten Bereiche ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von Waves Smart Accounts: Von Auktionen zu Bonusprogrammen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/442238/"><img src="https://habrastorage.org/webt/pi/sa/8g/pisa8gy_wbapc-kdf-n026wjuko.png" alt="Bild"><br><br>  <i>Blockchain wird oft nur mit Kryptow√§hrungen assoziiert, aber der Umfang der DLT-Technologie ist viel breiter.</i>  <i>Einer der vielversprechendsten Bereiche f√ºr die Verwendung der Blockchain ist ein intelligenter Vertrag, der automatisch ausgef√ºhrt wird und kein Vertrauen zwischen den Parteien erfordert, die ihn abgeschlossen haben.</i> <i><br></i> <br>  <b>RIDE - Sprache f√ºr intelligente Vertr√§ge</b> <br><br>  Waves hat eine spezielle Sprache f√ºr intelligente Vertr√§ge entwickelt - RIDE.  Die vollst√§ndige Dokumentation finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Und hier - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Artikel zu diesem Thema</a> √ºber Habr√©. <br><br>  Der Vertrag auf RIDE ist ein Pr√§dikat und gibt f√ºr die Ausgabe "wahr" oder "falsch" zur√ºck.  Dementsprechend wird eine Transaktion entweder in die Blockchain geschrieben oder abgelehnt.  Ein intelligenter Vertrag garantiert die Erf√ºllung bestimmter Bedingungen.  Die Generierung von Transaktionen aus einem Vertrag in RIDE ist derzeit nicht m√∂glich. <br><a name="habracut"></a><br>  Heutzutage gibt es zwei Arten von Waves-Smart-Vertr√§gen: Smart-Accounts und Smart-Assets.  Ein Smart-Konto ist ein regul√§res Benutzerkonto, f√ºr das jedoch ein Skript festgelegt ist, das alle Transaktionen steuert.  Ein Smart Account-Skript k√∂nnte folgenderma√üen aussehen: <br><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> | <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  tx ist eine verarbeitete Transaktion, die wir nur dann verwenden k√∂nnen, wenn es sich nicht um eine √úbertragungstransaktion handelt.  Der RIDE-Mustervergleich wird verwendet, um den Transaktionstyp zu √ºberpr√ºfen.  Im Smart Account-Skript k√∂nnen alle vorhandenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transaktionstypen</a> verarbeitet werden. <br><br>  Au√üerdem k√∂nnen Variablen im Skript deklariert werden, "Wenn-Dann-Sonst" -Konstruktionen und andere Methoden zur vollst√§ndigen √úberpr√ºfung von Bedingungen k√∂nnen verwendet werden.  Damit die Vertr√§ge nachweislich abgeschlossen sind und eine Komplexit√§t (Kosten) aufweisen, die vor Vertragsbeginn leicht vorherzusagen ist, enth√§lt RIDE keine Schleifen und Operatoren wie Jump. <br><br>  Unter anderen Merkmalen von Waves-Konten ist das Vorhandensein eines ‚ÄûStatus‚Äú, dh des Status des Kontos.  Mit Datentransaktionen (DataTransaction) kann eine unendliche Anzahl von Paaren (Schl√ºssel, Wert) in den Kontostatus geschrieben werden.  Dar√ºber hinaus k√∂nnen diese Informationen sowohl √ºber die REST-API als auch direkt im Smart-Vertrag verarbeitet werden. <br><br>  Jede Transaktion kann eine Reihe von Proofs enthalten, in die Sie die Unterschrift des Teilnehmers, die ID der erforderlichen Transaktion usw. eingeben k√∂nnen. <br><br>  Wenn Sie mit RIDE √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IDE arbeiten,</a> k√∂nnen Sie die kompilierte Form des Vertrags anzeigen (falls kompiliert), neue Konten erstellen und Skripte daf√ºr festlegen sowie Transaktionen √ºber die Befehlszeile senden. <br><br>  F√ºr einen vollst√§ndigen Zyklus, einschlie√ülich der Erstellung eines Kontos, der Installation eines intelligenten Vertrags und des Sendens von Transaktionen, k√∂nnen Sie die Bibliothek auch zur Interaktion mit der REST-API verwenden (z. B. C #, C, Java, JavaScript, Python, Rust, Elixir).  Um mit der IDE zu arbeiten, klicken Sie einfach auf die Schaltfl√§che NEU. <br><br>  Die M√∂glichkeiten zur Verwendung intelligenter Vertr√§ge sind vielf√§ltig: vom Verbot von Transaktionen √ºber bestimmte Adressen (die "schwarze Liste") bis hin zu komplexen dApps. <br><br>  <i>Schauen wir uns nun konkrete Beispiele f√ºr den Einsatz intelligenter Vertr√§ge in Unternehmen an: w√§hrend Auktionen, Versicherungen und der Erstellung von Treueprogrammen.</i> <i><br></i> <br>  <b>Auktionen</b> <br><br>  Eine der Voraussetzungen f√ºr eine erfolgreiche Auktion ist Transparenz: Bieter m√ºssen sicher sein, dass Gebote nicht manipuliert werden k√∂nnen.  Dies kann dank der Blockchain erreicht werden, bei der allen Teilnehmern unver√§nderte Daten zu allen Wetten und der Zeitpunkt ihrer Abgabe zur Verf√ºgung stehen. <br><br>  In der Waves-Blockchain k√∂nnen Gebote √ºber DataTransaction im Auktionskontostatus erfasst werden. <br><br>  Sie k√∂nnen die Start- und Endzeit der Auktion auch mithilfe von Blocknummern festlegen: Die H√§ufigkeit der Blockgenerierung in der Waves-Blockchain betr√§gt ca. <b>60</b> Sekunden. <br><br>  <i><b>1. Englische Auktion mit steigendem Preis</b></i> <br><br>  Teilnehmer des englischen Auktionsgebots konkurrieren miteinander.  Jede neue Wette muss die vorherige √ºberschreiten.  Die Auktion endet, wenn nicht mehr bereit ist, das letzte Gebot zu √ºberschreiten.  In diesem Fall muss der H√∂chstbietende den angegebenen Betrag angeben. <br><br>  Es gibt auch eine Auktionsoption, bei der der Verk√§ufer den Mindestpreis f√ºr das Los festlegt und der Endpreis diesen √ºberschreiten muss.  Ansonsten bleibt das Los unverkauft. <br><br>  In diesem Beispiel arbeiten wir mit einem Konto, das speziell f√ºr die Auktion erstellt wurde.  Die Auktionsdauer betr√§gt 3000 Bl√∂cke und der anf√§ngliche Preis des Loses betr√§gt 0,001 WELLEN.  Ein Teilnehmer kann eine Wette abschlie√üen, indem er eine DataTransaction mit dem "Preis" -Schl√ºssel und dem Wert seines Gebots sendet. In den Transaktionsnachweisen m√ºssen Sie den √∂ffentlichen Schl√ºssel und die Unterschrift des Absenders hinzuf√ºgen. <br><br>  Der Preis der neuen Wette sollte h√∂her sein als der aktuelle Preis f√ºr diesen Schl√ºssel, und der Teilnehmer muss mindestens [new_state + Provision] -Token auf dem Konto haben.  Die Adresse des Bieters muss in das Feld "Absender" in der DataTransaction eingegeben werden, und die aktuelle H√∂he des Gebotsblocks muss innerhalb des Auktionszeitraums liegen. <br><br>  Wenn der Bieter am Ende der Auktion den h√∂chsten Preis festgelegt hat, kann er ExchangeTransaction senden, um das entsprechende Los zum angegebenen Preis- und W√§hrungspaar zu zahlen. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">384120</span></span> let finishHeight = startHeight + <span class="hljs-number"><span class="hljs-number">3000</span></span> let startPrice = <span class="hljs-number"><span class="hljs-number">100000</span></span> #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #,      let currentPrice = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #    then extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> startPrice #    let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let priceIsBigger = newPrice &gt; currentPrice let fee = <span class="hljs-number"><span class="hljs-number">700000</span></span> let hasMoney = wavesBalance(address) + fee &gt;= newPrice let correctFields = size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) == toBase58String(address.bytes) startHeight &lt;= height &amp;&amp; height &lt;= finishHeight &amp;&amp; priceIsBigger &amp;&amp; hasMoney &amp;&amp; correctFields &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #       let pk = o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let senderIsWinner = address == addressFromString(extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) #,    ,    let correctAssetPair = o.assetPair.amountAsset == token &amp;&amp; ! isDefined(o.assetPair.priceAsset) let correctAmount = o.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctPrice = o.price == extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) height &gt; finishHeight &amp;&amp; senderIsWinner &amp;&amp; correctAssetPair &amp;&amp; correctAmount &amp;&amp; correctPrice &amp;&amp; sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <i><b>2. Niederl√§ndische Versteigerung fallender Preise</b></i> <br><br>  Bei einer niederl√§ndischen Auktion wird zun√§chst viel zu einem h√∂heren Preis angeboten, als der K√§ufer bereit ist zu zahlen.  Der Preis wird schrittweise reduziert, bis einer der Teilnehmer dem Kauf des Loses zum aktuellen Preis zustimmt. <br><br>  In diesem Beispiel verwenden wir dieselben Konstanten wie im vorherigen Beispiel sowie den Preisschritt beim Verringern des Deltas.  Das Kontoskript pr√ºft, ob der Teilnehmer wirklich der erste ist, der setzt.  In den Transaktionsnachweisen m√ºssen Sie den √∂ffentlichen Schl√ºssel und die Signatur des Absenders hinzuf√ºgen. Andernfalls wird DataTransaction von der Blockchain nicht akzeptiert. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">384120</span></span> let finishHeight = startHeight + <span class="hljs-number"><span class="hljs-number">3000</span></span> let startPrice = <span class="hljs-number"><span class="hljs-number">100000000</span></span> let delta = <span class="hljs-number"><span class="hljs-number">100</span></span> #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let currentPrice = startPrice - delta * (height - startHeight) #   -  <span class="hljs-string"><span class="hljs-string">"price"</span></span> let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let correctFields = extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) == toBase58String(address.bytes) &amp;&amp; size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; newPrice == currentPrice #,         <span class="hljs-string"><span class="hljs-string">"sender"</span></span> let noBetsBefore = !isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) let fee = <span class="hljs-number"><span class="hljs-number">700000</span></span> let hasMoney = wavesBalance(address) - fee &gt;= newPrice startHeight &lt;= height &amp;&amp; height &lt;= finishHeight &amp;&amp; noBetsBefore &amp;&amp; hasMoney &amp;&amp; correctFields &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #       let pk = o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) #,           sender let senderIsWinner = address == addressFromString(extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) #,  mount   ,   - - waves let correctAssetPair = o.assetPair.amountAsset == token &amp;&amp; ! isDefined(o.assetPair.priceAsset) let correctAmount = o.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctPrice = o.price == extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) height &gt; finishHeight &amp;&amp; senderIsWinner &amp;&amp; correctAssetPair &amp;&amp; correctAmount &amp;&amp; correctPrice &amp;&amp; sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <i><b>3. All-Pay-Auktion</b></i> <br><br>  "All-Pay" - eine Auktion, bei der alle Teilnehmer das Gebot zahlen, unabh√§ngig davon, wer das Los gewinnt.  Jeder neue Teilnehmer zahlt die Wette und der Teilnehmer, der die maximale Wette abgeschlossen hat, gewinnt das Los. <br><br>  In unserem Beispiel gibt jeder Auktionsteilnehmer ein Gebot √ºber eine DataTransaction mit (Schl√ºssel, Wert) * = ("Gewinner", Adresse), ("Preis", Preis) ab.  Eine solche DataTransaction wird nur genehmigt, wenn f√ºr diesen Teilnehmer bereits eine TransferTransaction mit ihrer Signatur vorhanden ist und die Rate h√∂her ist als bei allen vorherigen.  Die Auktion wird bis zum Ende von H√∂he fortgesetzt. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">1000</span></span> let endHeight = <span class="hljs-number"><span class="hljs-number">2000</span></span> let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #   -  <span class="hljs-string"><span class="hljs-string">"price"</span></span> let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) #        let proofTx = extract(transactionById(d.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>])) height &gt; startHeight &amp;&amp; height &lt; endHeight &amp;&amp; size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> #,   ,    ,   ,    &amp;&amp; extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"winner"</span></span>)) == toBase58String(address.bytes) &amp;&amp; newPrice &gt; extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #,    &amp;&amp; sigVerify(d.bodyBytes, d.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) #  ,    &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> proofTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tr : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; tr.sender == address &amp;&amp; tr.amount == newPrice <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) || ( height &gt; endHeight &amp;&amp; extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"winner"</span></span>)) == toBase58String((addressFromRecipient(t.recipient)).bytes) &amp;&amp; t.assetId == token &amp;&amp; t.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre> <br>  <b>Versicherung / Crowdfunding</b> <br><br>  Stellen Sie sich eine Situation vor, in der Sie Benutzerverm√∂gen vor finanziellen Verlusten versichern m√ºssen.  Beispielsweise m√∂chte der Benutzer eine Garantie erhalten, dass er bei einer Wertminderung des Tokens den f√ºr diese Token gezahlten Gesamtbetrag zur√ºckgeben kann und bereit ist, einen angemessenen Versicherungsbetrag zu zahlen. <br><br>  Um dies zu implementieren, m√ºssen Sie "Versicherungstoken" ausstellen.  Anschlie√üend wird auf dem Konto des Versicherungsnehmers ein Skript installiert, mit dem Sie nur die ExchangeTransactions ausf√ºhren k√∂nnen, die bestimmte Bedingungen erf√ºllen. <br><br>  Um doppelte Ausgaben zu vermeiden, m√ºssen Sie den Benutzer auffordern, DataTransaction im Voraus mit (Schl√ºssel, Wert) = (purchaseTransactionId, sellOrderId) an das Konto des Versicherungsnehmers zu senden und das Senden von DataTransactions mit dem bereits verwendeten Schl√ºssel zu verhindern. <br><br>  Daher m√ºssen die Proofs des Benutzers die Transaktions-ID des Kaufs des Versicherungstokens enthalten.  Das W√§hrungspaar muss mit dem Kaufvorgang identisch sein.  Die Kosten sollten auch den zum Zeitpunkt des Kaufs erfassten Kosten abz√ºglich des Versicherungspreises entsprechen. <br><br>  Es versteht sich, dass das Versicherungskonto anschlie√üend die Versicherungstoken vom Benutzer zu einem Preis einl√∂st, der nicht niedriger ist als der Preis, zu dem er sie gekauft hat: Das Versicherungskonto erstellt ExchangeTransaction, der Benutzer signiert die Bestellung (wenn die Transaktion korrekt abgeschlossen wurde), das Versicherungskonto signiert die zweite Bestellung und die gesamte Transaktion und sendet sie an die Blockchain . <br><br>  Wenn der Kauf nicht erfolgt, kann der Benutzer eine Bestellung gem√§√ü den im Skript beschriebenen Regeln erstellen und die Transaktion an die Blockchain senden.  So kann der Benutzer das f√ºr den Kauf versicherter Token ausgegebene Geld zur√ºckgeben. <br><br><pre> <code class="scala hljs">let insuranceToken = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let freezePeriod = <span class="hljs-number"><span class="hljs-number">150000</span></span> let insurancePrice = <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { #, ,   -,              <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #     ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isDefined(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) then sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.senderPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #     ,         let purchaseTx = transactionById(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) let purchaseTxHeight = extract(transactionHeightById(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #    <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span> =&gt; let correctSender = purchase.sender == o.sender let correctAssetPair = o.assetPair.amountAsset == insuranceToken &amp;&amp; purchase.sellOrder.assetPair.amountAsset == insuranceToken &amp;&amp; o.assetPair.priceAsset == purchase.sellOrder.assetPair.priceAsset let correctPrice = o.price == purchase.price - insurancePrice &amp;&amp; o.amount == purchase.amount let correctHeight = height &gt; purchaseTxHeight + freezePeriod #,   -   <span class="hljs-type"><span class="hljs-type">ID</span></span>   let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == o.id correctSender &amp;&amp; correctAssetPair &amp;&amp; correctPrice &amp;&amp; correctHeight &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre><br>  Ein Versicherungstoken kann beispielsweise zu einem intelligenten Verm√∂genswert gemacht werden, um seine √úbertragung an Dritte zu verhindern. <br><br>  Dieses Schema kann auch f√ºr Crowdfunding-Token implementiert werden, die an die Eigent√ºmer zur√ºckgegeben werden, wenn der erforderliche Betrag nicht eingezogen wurde. <br><br>  <b>Transaktionssteuern</b> <br><br>  Intelligente Vertr√§ge gelten auch in F√§llen, in denen Steuern aus jeder Transaktion mit verschiedenen Arten von Verm√∂genswerten erhoben werden m√ºssen.  Dies kann durch ein neues <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesponsertes</a> Asset f√ºr Transaktionen mit intelligenten Assets erfolgen: <br><br>  1. Wir ver√∂ffentlichen FeeCoin, das zu einem festen Preis an Benutzer gesendet wird: 0,01 WAVES = 0,001 FeeCoin. <br><br>  2. Wir haben Sponsoring f√ºr FeeCoin und Wechselkurs eingerichtet: 0,001 WAVES = 0,001 FeeCoin. <br><br>  3. Wir legen das folgende Skript f√ºr das Smart Asset fest: <br><br><pre> <code class="scala hljs">let feeAssetId = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let taxDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; t.feeAssetId == feeAssetId &amp;&amp; t.fee == t.amount / taxDivisor <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e: <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span>| <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  Jedes Mal, wenn jemand N Smart Assets √ºbertr√§gt, gibt er Ihnen FeeCoin in H√∂he von N / taxDivisor (der bei Ihnen f√ºr 10 * N / taxDivisor WAVES gekauft werden kann) und Sie geben dem Bergmann N / taxDivisor WAVES.  Infolgedessen betr√§gt Ihr Gewinn (Steuer) 9 * N / taxDivisor WAVES. <br><br>  Sie k√∂nnen auch mit einem Smart Asset-Skript und MassTransferTransaction Steuern erheben: <br><br><pre> <code class="scala hljs">let taxDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t : <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; let twoTransfers = size(t.transfers) == <span class="hljs-number"><span class="hljs-number">2</span></span> let issuerIsRecipient = t.transfers[<span class="hljs-number"><span class="hljs-number">0</span></span>].recipient == addressFromString(<span class="hljs-string"><span class="hljs-string">"3MgkTXzD72BTfYpd9UW42wdqTVg8HqnXEfc"</span></span>) let taxesPaid = t.transfers[<span class="hljs-number"><span class="hljs-number">0</span></span>].amount &gt;= t.transfers[<span class="hljs-number"><span class="hljs-number">1</span></span>].amount / taxDivisor twoTransfers &amp;&amp; issuerIsRecipient &amp;&amp; taxesPaid <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <b>Cashback- und Treueprogramme</b> <br><br>  Cashback ist eine Art Treueprogramm, bei dem ein Teil des f√ºr ein Produkt oder eine Dienstleistung ausgegebenen Betrags an den K√§ufer zur√ºckgegeben wird. <br><br>  Wenn wir diesen Fall mit einem Smart Account implementieren, m√ºssen wir die Beweise auf die gleiche Weise pr√ºfen wie im Versicherungsfall.  Um doppelte Ausgaben zu vermeiden, muss der Benutzer vor Erhalt eines Cashbacks eine DataTransaction mit (Schl√ºssel, Wert) = (purchaseTransactionId, cashbackTransactionId) senden. <br><br>  Wir m√ºssen auch vorhandene Schl√ºssel mithilfe einer DataTransaction sperren.  CashbackDivisor - eine Einheit geteilt durch den Anteil des Cashbacks.  Das hei√üt,  Wenn der Cashback-Anteil 0,1 betr√§gt, ist CashbackDivisor 1 / 0,1 = 10. <br><br><pre> <code class="scala hljs">let cashbackToken = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let cashbackDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { #, ,   -,              <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; #     ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isDefined(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) then sigVerify(e.bodyBytes, e.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], e.senderPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #     ,         let purchaseTx = transactionById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) let purchaseTxHeight = extract(transactionHeightById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #    <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let correctSender = purchase.sender == e.sender let correctAsset = e.assetId == cashbackToken let correctPrice = e.amount == purchase.amount / cashbackDivisor #,   -   <span class="hljs-type"><span class="hljs-type">ID</span></span>   let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == e.id correctSender &amp;&amp; correctAsset &amp;&amp; correctPrice &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre> <br>  <b>Atomtausch</b> <br><br>  Mit Atomic Swap k√∂nnen Benutzer Assets ohne Hilfe eines Austauschs austauschen.  Bei einem Atomic Swap m√ºssen beide Teilnehmer der Transaktion diese innerhalb eines bestimmten Zeitraums best√§tigen. <br><br>  Wenn mindestens einer der Teilnehmer nicht innerhalb der f√ºr die Transaktion vorgesehenen Zeit die korrekte Best√§tigung der Transaktion vorlegt, wird die Transaktion abgebrochen und es findet kein Umtausch statt. <br><br>  In unserem Beispiel verwenden wir das folgende Smart Account-Skript: <br><br><pre> <code class="scala hljs">let <span class="hljs-type"><span class="hljs-type">Bob</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3NBVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8') let <span class="hljs-type"><span class="hljs-type">Alice</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3PNX6XwMeEXaaP1rf5MCk8weYeF7z2vJZB</span></span>g') let beforeHeight = <span class="hljs-number"><span class="hljs-number">100000</span></span> let secret = base58<span class="hljs-symbol"><span class="hljs-symbol">'BN6RTYGWcwektQfSFzH8raYo9awaLgQ7pLyWLQY4S4F</span></span>5' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let txToBob = t.recipient == <span class="hljs-type"><span class="hljs-type">Bob</span></span> &amp;&amp; sha256(t.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>]) == secret &amp;&amp; <span class="hljs-number"><span class="hljs-number">20</span></span> + beforeHeight &gt;= height let backToAliceAfterHeight = height &gt;= <span class="hljs-number"><span class="hljs-number">21</span></span> + beforeHeight &amp;&amp; t.recipient == <span class="hljs-type"><span class="hljs-type">Alice</span></span> txToBob || backToAliceAfterHeight <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <i>Im n√§chsten Artikel werden wir die Verwendung intelligenter Konten in Finanzinstrumenten wie Optionen, Futures und Rechnungen betrachten.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442238/">https://habr.com/ru/post/de442238/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442226/index.html">Dieser Inhalt ist in Ihrem Land nicht verf√ºgbar: Nachrichten, die Sie nicht von Russland lernen k√∂nnen</a></li>
<li><a href="../de442230/index.html">Welcher der in derselben Stadt lebenden Entwickler verdient mehr: Fernarbeit oder im B√ºro?</a></li>
<li><a href="../de442232/index.html">Alternativer Slf4j-Spulenlogger</a></li>
<li><a href="../de442234/index.html">Kolonie. Nachwort</a></li>
<li><a href="../de442236/index.html">Warum braucht Dodo Pizza 250 Entwickler?</a></li>
<li><a href="../de442242/index.html">Aktuelle Nachrichten: Die gr√∂√üte Solarzellenanlage der westlichen Hemisph√§re wurde in Betrieb genommen</a></li>
<li><a href="../de442244/index.html">Rust 1.33 Release</a></li>
<li><a href="../de442248/index.html">Die NASA genehmigte den unbemannten Teststart von Dragon-2</a></li>
<li><a href="../de442250/index.html">Reagieren und Vue: St√§rken</a></li>
<li><a href="../de442252/index.html">Python-Code-Lebenszyklus - CPython-Laufzeitmodell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>