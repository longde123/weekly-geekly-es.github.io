<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴🏾 🐕 👄 Verwenden von Waves Smart Accounts: Von Auktionen zu Bonusprogrammen 👐 👸🏾 ♠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blockchain wird oft nur mit Kryptowährungen assoziiert, aber der Umfang der DLT-Technologie ist viel breiter. Einer der vielversprechendsten Bereiche ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von Waves Smart Accounts: Von Auktionen zu Bonusprogrammen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/442238/"><img src="https://habrastorage.org/webt/pi/sa/8g/pisa8gy_wbapc-kdf-n026wjuko.png" alt="Bild"><br><br>  <i>Blockchain wird oft nur mit Kryptowährungen assoziiert, aber der Umfang der DLT-Technologie ist viel breiter.</i>  <i>Einer der vielversprechendsten Bereiche für die Verwendung der Blockchain ist ein intelligenter Vertrag, der automatisch ausgeführt wird und kein Vertrauen zwischen den Parteien erfordert, die ihn abgeschlossen haben.</i> <i><br></i> <br>  <b>RIDE - Sprache für intelligente Verträge</b> <br><br>  Waves hat eine spezielle Sprache für intelligente Verträge entwickelt - RIDE.  Die vollständige Dokumentation finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Und hier - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Artikel zu diesem Thema</a> über Habré. <br><br>  Der Vertrag auf RIDE ist ein Prädikat und gibt für die Ausgabe "wahr" oder "falsch" zurück.  Dementsprechend wird eine Transaktion entweder in die Blockchain geschrieben oder abgelehnt.  Ein intelligenter Vertrag garantiert die Erfüllung bestimmter Bedingungen.  Die Generierung von Transaktionen aus einem Vertrag in RIDE ist derzeit nicht möglich. <br><a name="habracut"></a><br>  Heutzutage gibt es zwei Arten von Waves-Smart-Verträgen: Smart-Accounts und Smart-Assets.  Ein Smart-Konto ist ein reguläres Benutzerkonto, für das jedoch ein Skript festgelegt ist, das alle Transaktionen steuert.  Ein Smart Account-Skript könnte folgendermaßen aussehen: <br><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> | <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  tx ist eine verarbeitete Transaktion, die wir nur dann verwenden können, wenn es sich nicht um eine Übertragungstransaktion handelt.  Der RIDE-Mustervergleich wird verwendet, um den Transaktionstyp zu überprüfen.  Im Smart Account-Skript können alle vorhandenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transaktionstypen</a> verarbeitet werden. <br><br>  Außerdem können Variablen im Skript deklariert werden, "Wenn-Dann-Sonst" -Konstruktionen und andere Methoden zur vollständigen Überprüfung von Bedingungen können verwendet werden.  Damit die Verträge nachweislich abgeschlossen sind und eine Komplexität (Kosten) aufweisen, die vor Vertragsbeginn leicht vorherzusagen ist, enthält RIDE keine Schleifen und Operatoren wie Jump. <br><br>  Unter anderen Merkmalen von Waves-Konten ist das Vorhandensein eines „Status“, dh des Status des Kontos.  Mit Datentransaktionen (DataTransaction) kann eine unendliche Anzahl von Paaren (Schlüssel, Wert) in den Kontostatus geschrieben werden.  Darüber hinaus können diese Informationen sowohl über die REST-API als auch direkt im Smart-Vertrag verarbeitet werden. <br><br>  Jede Transaktion kann eine Reihe von Proofs enthalten, in die Sie die Unterschrift des Teilnehmers, die ID der erforderlichen Transaktion usw. eingeben können. <br><br>  Wenn Sie mit RIDE über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IDE arbeiten,</a> können Sie die kompilierte Form des Vertrags anzeigen (falls kompiliert), neue Konten erstellen und Skripte dafür festlegen sowie Transaktionen über die Befehlszeile senden. <br><br>  Für einen vollständigen Zyklus, einschließlich der Erstellung eines Kontos, der Installation eines intelligenten Vertrags und des Sendens von Transaktionen, können Sie die Bibliothek auch zur Interaktion mit der REST-API verwenden (z. B. C #, C, Java, JavaScript, Python, Rust, Elixir).  Um mit der IDE zu arbeiten, klicken Sie einfach auf die Schaltfläche NEU. <br><br>  Die Möglichkeiten zur Verwendung intelligenter Verträge sind vielfältig: vom Verbot von Transaktionen über bestimmte Adressen (die "schwarze Liste") bis hin zu komplexen dApps. <br><br>  <i>Schauen wir uns nun konkrete Beispiele für den Einsatz intelligenter Verträge in Unternehmen an: während Auktionen, Versicherungen und der Erstellung von Treueprogrammen.</i> <i><br></i> <br>  <b>Auktionen</b> <br><br>  Eine der Voraussetzungen für eine erfolgreiche Auktion ist Transparenz: Bieter müssen sicher sein, dass Gebote nicht manipuliert werden können.  Dies kann dank der Blockchain erreicht werden, bei der allen Teilnehmern unveränderte Daten zu allen Wetten und der Zeitpunkt ihrer Abgabe zur Verfügung stehen. <br><br>  In der Waves-Blockchain können Gebote über DataTransaction im Auktionskontostatus erfasst werden. <br><br>  Sie können die Start- und Endzeit der Auktion auch mithilfe von Blocknummern festlegen: Die Häufigkeit der Blockgenerierung in der Waves-Blockchain beträgt ca. <b>60</b> Sekunden. <br><br>  <i><b>1. Englische Auktion mit steigendem Preis</b></i> <br><br>  Teilnehmer des englischen Auktionsgebots konkurrieren miteinander.  Jede neue Wette muss die vorherige überschreiten.  Die Auktion endet, wenn nicht mehr bereit ist, das letzte Gebot zu überschreiten.  In diesem Fall muss der Höchstbietende den angegebenen Betrag angeben. <br><br>  Es gibt auch eine Auktionsoption, bei der der Verkäufer den Mindestpreis für das Los festlegt und der Endpreis diesen überschreiten muss.  Ansonsten bleibt das Los unverkauft. <br><br>  In diesem Beispiel arbeiten wir mit einem Konto, das speziell für die Auktion erstellt wurde.  Die Auktionsdauer beträgt 3000 Blöcke und der anfängliche Preis des Loses beträgt 0,001 WELLEN.  Ein Teilnehmer kann eine Wette abschließen, indem er eine DataTransaction mit dem "Preis" -Schlüssel und dem Wert seines Gebots sendet. In den Transaktionsnachweisen müssen Sie den öffentlichen Schlüssel und die Unterschrift des Absenders hinzufügen. <br><br>  Der Preis der neuen Wette sollte höher sein als der aktuelle Preis für diesen Schlüssel, und der Teilnehmer muss mindestens [new_state + Provision] -Token auf dem Konto haben.  Die Adresse des Bieters muss in das Feld "Absender" in der DataTransaction eingegeben werden, und die aktuelle Höhe des Gebotsblocks muss innerhalb des Auktionszeitraums liegen. <br><br>  Wenn der Bieter am Ende der Auktion den höchsten Preis festgelegt hat, kann er ExchangeTransaction senden, um das entsprechende Los zum angegebenen Preis- und Währungspaar zu zahlen. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">384120</span></span> let finishHeight = startHeight + <span class="hljs-number"><span class="hljs-number">3000</span></span> let startPrice = <span class="hljs-number"><span class="hljs-number">100000</span></span> #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #,      let currentPrice = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #    then extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> startPrice #    let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let priceIsBigger = newPrice &gt; currentPrice let fee = <span class="hljs-number"><span class="hljs-number">700000</span></span> let hasMoney = wavesBalance(address) + fee &gt;= newPrice let correctFields = size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) == toBase58String(address.bytes) startHeight &lt;= height &amp;&amp; height &lt;= finishHeight &amp;&amp; priceIsBigger &amp;&amp; hasMoney &amp;&amp; correctFields &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #       let pk = o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let senderIsWinner = address == addressFromString(extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) #,    ,    let correctAssetPair = o.assetPair.amountAsset == token &amp;&amp; ! isDefined(o.assetPair.priceAsset) let correctAmount = o.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctPrice = o.price == extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) height &gt; finishHeight &amp;&amp; senderIsWinner &amp;&amp; correctAssetPair &amp;&amp; correctAmount &amp;&amp; correctPrice &amp;&amp; sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <i><b>2. Niederländische Versteigerung fallender Preise</b></i> <br><br>  Bei einer niederländischen Auktion wird zunächst viel zu einem höheren Preis angeboten, als der Käufer bereit ist zu zahlen.  Der Preis wird schrittweise reduziert, bis einer der Teilnehmer dem Kauf des Loses zum aktuellen Preis zustimmt. <br><br>  In diesem Beispiel verwenden wir dieselben Konstanten wie im vorherigen Beispiel sowie den Preisschritt beim Verringern des Deltas.  Das Kontoskript prüft, ob der Teilnehmer wirklich der erste ist, der setzt.  In den Transaktionsnachweisen müssen Sie den öffentlichen Schlüssel und die Signatur des Absenders hinzufügen. Andernfalls wird DataTransaction von der Blockchain nicht akzeptiert. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">384120</span></span> let finishHeight = startHeight + <span class="hljs-number"><span class="hljs-number">3000</span></span> let startPrice = <span class="hljs-number"><span class="hljs-number">100000000</span></span> let delta = <span class="hljs-number"><span class="hljs-number">100</span></span> #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let currentPrice = startPrice - delta * (height - startHeight) #   -  <span class="hljs-string"><span class="hljs-string">"price"</span></span> let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let correctFields = extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) == toBase58String(address.bytes) &amp;&amp; size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; newPrice == currentPrice #,         <span class="hljs-string"><span class="hljs-string">"sender"</span></span> let noBetsBefore = !isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) let fee = <span class="hljs-number"><span class="hljs-number">700000</span></span> let hasMoney = wavesBalance(address) - fee &gt;= newPrice startHeight &lt;= height &amp;&amp; height &lt;= finishHeight &amp;&amp; noBetsBefore &amp;&amp; hasMoney &amp;&amp; correctFields &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #       let pk = o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) #,           sender let senderIsWinner = address == addressFromString(extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) #,  mount   ,   - - waves let correctAssetPair = o.assetPair.amountAsset == token &amp;&amp; ! isDefined(o.assetPair.priceAsset) let correctAmount = o.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctPrice = o.price == extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) height &gt; finishHeight &amp;&amp; senderIsWinner &amp;&amp; correctAssetPair &amp;&amp; correctAmount &amp;&amp; correctPrice &amp;&amp; sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <i><b>3. All-Pay-Auktion</b></i> <br><br>  "All-Pay" - eine Auktion, bei der alle Teilnehmer das Gebot zahlen, unabhängig davon, wer das Los gewinnt.  Jeder neue Teilnehmer zahlt die Wette und der Teilnehmer, der die maximale Wette abgeschlossen hat, gewinnt das Los. <br><br>  In unserem Beispiel gibt jeder Auktionsteilnehmer ein Gebot über eine DataTransaction mit (Schlüssel, Wert) * = ("Gewinner", Adresse), ("Preis", Preis) ab.  Eine solche DataTransaction wird nur genehmigt, wenn für diesen Teilnehmer bereits eine TransferTransaction mit ihrer Signatur vorhanden ist und die Rate höher ist als bei allen vorherigen.  Die Auktion wird bis zum Ende von Höhe fortgesetzt. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">1000</span></span> let endHeight = <span class="hljs-number"><span class="hljs-number">2000</span></span> let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #   -  <span class="hljs-string"><span class="hljs-string">"price"</span></span> let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) #        let proofTx = extract(transactionById(d.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>])) height &gt; startHeight &amp;&amp; height &lt; endHeight &amp;&amp; size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> #,   ,    ,   ,    &amp;&amp; extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"winner"</span></span>)) == toBase58String(address.bytes) &amp;&amp; newPrice &gt; extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #,    &amp;&amp; sigVerify(d.bodyBytes, d.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) #  ,    &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> proofTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tr : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; tr.sender == address &amp;&amp; tr.amount == newPrice <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) || ( height &gt; endHeight &amp;&amp; extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"winner"</span></span>)) == toBase58String((addressFromRecipient(t.recipient)).bytes) &amp;&amp; t.assetId == token &amp;&amp; t.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre> <br>  <b>Versicherung / Crowdfunding</b> <br><br>  Stellen Sie sich eine Situation vor, in der Sie Benutzervermögen vor finanziellen Verlusten versichern müssen.  Beispielsweise möchte der Benutzer eine Garantie erhalten, dass er bei einer Wertminderung des Tokens den für diese Token gezahlten Gesamtbetrag zurückgeben kann und bereit ist, einen angemessenen Versicherungsbetrag zu zahlen. <br><br>  Um dies zu implementieren, müssen Sie "Versicherungstoken" ausstellen.  Anschließend wird auf dem Konto des Versicherungsnehmers ein Skript installiert, mit dem Sie nur die ExchangeTransactions ausführen können, die bestimmte Bedingungen erfüllen. <br><br>  Um doppelte Ausgaben zu vermeiden, müssen Sie den Benutzer auffordern, DataTransaction im Voraus mit (Schlüssel, Wert) = (purchaseTransactionId, sellOrderId) an das Konto des Versicherungsnehmers zu senden und das Senden von DataTransactions mit dem bereits verwendeten Schlüssel zu verhindern. <br><br>  Daher müssen die Proofs des Benutzers die Transaktions-ID des Kaufs des Versicherungstokens enthalten.  Das Währungspaar muss mit dem Kaufvorgang identisch sein.  Die Kosten sollten auch den zum Zeitpunkt des Kaufs erfassten Kosten abzüglich des Versicherungspreises entsprechen. <br><br>  Es versteht sich, dass das Versicherungskonto anschließend die Versicherungstoken vom Benutzer zu einem Preis einlöst, der nicht niedriger ist als der Preis, zu dem er sie gekauft hat: Das Versicherungskonto erstellt ExchangeTransaction, der Benutzer signiert die Bestellung (wenn die Transaktion korrekt abgeschlossen wurde), das Versicherungskonto signiert die zweite Bestellung und die gesamte Transaktion und sendet sie an die Blockchain . <br><br>  Wenn der Kauf nicht erfolgt, kann der Benutzer eine Bestellung gemäß den im Skript beschriebenen Regeln erstellen und die Transaktion an die Blockchain senden.  So kann der Benutzer das für den Kauf versicherter Token ausgegebene Geld zurückgeben. <br><br><pre> <code class="scala hljs">let insuranceToken = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let freezePeriod = <span class="hljs-number"><span class="hljs-number">150000</span></span> let insurancePrice = <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { #, ,   -,              <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #     ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isDefined(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) then sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.senderPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #     ,         let purchaseTx = transactionById(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) let purchaseTxHeight = extract(transactionHeightById(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #    <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span> =&gt; let correctSender = purchase.sender == o.sender let correctAssetPair = o.assetPair.amountAsset == insuranceToken &amp;&amp; purchase.sellOrder.assetPair.amountAsset == insuranceToken &amp;&amp; o.assetPair.priceAsset == purchase.sellOrder.assetPair.priceAsset let correctPrice = o.price == purchase.price - insurancePrice &amp;&amp; o.amount == purchase.amount let correctHeight = height &gt; purchaseTxHeight + freezePeriod #,   -   <span class="hljs-type"><span class="hljs-type">ID</span></span>   let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == o.id correctSender &amp;&amp; correctAssetPair &amp;&amp; correctPrice &amp;&amp; correctHeight &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre><br>  Ein Versicherungstoken kann beispielsweise zu einem intelligenten Vermögenswert gemacht werden, um seine Übertragung an Dritte zu verhindern. <br><br>  Dieses Schema kann auch für Crowdfunding-Token implementiert werden, die an die Eigentümer zurückgegeben werden, wenn der erforderliche Betrag nicht eingezogen wurde. <br><br>  <b>Transaktionssteuern</b> <br><br>  Intelligente Verträge gelten auch in Fällen, in denen Steuern aus jeder Transaktion mit verschiedenen Arten von Vermögenswerten erhoben werden müssen.  Dies kann durch ein neues <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesponsertes</a> Asset für Transaktionen mit intelligenten Assets erfolgen: <br><br>  1. Wir veröffentlichen FeeCoin, das zu einem festen Preis an Benutzer gesendet wird: 0,01 WAVES = 0,001 FeeCoin. <br><br>  2. Wir haben Sponsoring für FeeCoin und Wechselkurs eingerichtet: 0,001 WAVES = 0,001 FeeCoin. <br><br>  3. Wir legen das folgende Skript für das Smart Asset fest: <br><br><pre> <code class="scala hljs">let feeAssetId = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let taxDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; t.feeAssetId == feeAssetId &amp;&amp; t.fee == t.amount / taxDivisor <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e: <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span>| <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  Jedes Mal, wenn jemand N Smart Assets überträgt, gibt er Ihnen FeeCoin in Höhe von N / taxDivisor (der bei Ihnen für 10 * N / taxDivisor WAVES gekauft werden kann) und Sie geben dem Bergmann N / taxDivisor WAVES.  Infolgedessen beträgt Ihr Gewinn (Steuer) 9 * N / taxDivisor WAVES. <br><br>  Sie können auch mit einem Smart Asset-Skript und MassTransferTransaction Steuern erheben: <br><br><pre> <code class="scala hljs">let taxDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t : <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; let twoTransfers = size(t.transfers) == <span class="hljs-number"><span class="hljs-number">2</span></span> let issuerIsRecipient = t.transfers[<span class="hljs-number"><span class="hljs-number">0</span></span>].recipient == addressFromString(<span class="hljs-string"><span class="hljs-string">"3MgkTXzD72BTfYpd9UW42wdqTVg8HqnXEfc"</span></span>) let taxesPaid = t.transfers[<span class="hljs-number"><span class="hljs-number">0</span></span>].amount &gt;= t.transfers[<span class="hljs-number"><span class="hljs-number">1</span></span>].amount / taxDivisor twoTransfers &amp;&amp; issuerIsRecipient &amp;&amp; taxesPaid <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <b>Cashback- und Treueprogramme</b> <br><br>  Cashback ist eine Art Treueprogramm, bei dem ein Teil des für ein Produkt oder eine Dienstleistung ausgegebenen Betrags an den Käufer zurückgegeben wird. <br><br>  Wenn wir diesen Fall mit einem Smart Account implementieren, müssen wir die Beweise auf die gleiche Weise prüfen wie im Versicherungsfall.  Um doppelte Ausgaben zu vermeiden, muss der Benutzer vor Erhalt eines Cashbacks eine DataTransaction mit (Schlüssel, Wert) = (purchaseTransactionId, cashbackTransactionId) senden. <br><br>  Wir müssen auch vorhandene Schlüssel mithilfe einer DataTransaction sperren.  CashbackDivisor - eine Einheit geteilt durch den Anteil des Cashbacks.  Das heißt,  Wenn der Cashback-Anteil 0,1 beträgt, ist CashbackDivisor 1 / 0,1 = 10. <br><br><pre> <code class="scala hljs">let cashbackToken = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let cashbackDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { #, ,   -,              <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; #     ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isDefined(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) then sigVerify(e.bodyBytes, e.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], e.senderPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #     ,         let purchaseTx = transactionById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) let purchaseTxHeight = extract(transactionHeightById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #    <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let correctSender = purchase.sender == e.sender let correctAsset = e.assetId == cashbackToken let correctPrice = e.amount == purchase.amount / cashbackDivisor #,   -   <span class="hljs-type"><span class="hljs-type">ID</span></span>   let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == e.id correctSender &amp;&amp; correctAsset &amp;&amp; correctPrice &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre> <br>  <b>Atomtausch</b> <br><br>  Mit Atomic Swap können Benutzer Assets ohne Hilfe eines Austauschs austauschen.  Bei einem Atomic Swap müssen beide Teilnehmer der Transaktion diese innerhalb eines bestimmten Zeitraums bestätigen. <br><br>  Wenn mindestens einer der Teilnehmer nicht innerhalb der für die Transaktion vorgesehenen Zeit die korrekte Bestätigung der Transaktion vorlegt, wird die Transaktion abgebrochen und es findet kein Umtausch statt. <br><br>  In unserem Beispiel verwenden wir das folgende Smart Account-Skript: <br><br><pre> <code class="scala hljs">let <span class="hljs-type"><span class="hljs-type">Bob</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3NBVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8') let <span class="hljs-type"><span class="hljs-type">Alice</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3PNX6XwMeEXaaP1rf5MCk8weYeF7z2vJZB</span></span>g') let beforeHeight = <span class="hljs-number"><span class="hljs-number">100000</span></span> let secret = base58<span class="hljs-symbol"><span class="hljs-symbol">'BN6RTYGWcwektQfSFzH8raYo9awaLgQ7pLyWLQY4S4F</span></span>5' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let txToBob = t.recipient == <span class="hljs-type"><span class="hljs-type">Bob</span></span> &amp;&amp; sha256(t.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>]) == secret &amp;&amp; <span class="hljs-number"><span class="hljs-number">20</span></span> + beforeHeight &gt;= height let backToAliceAfterHeight = height &gt;= <span class="hljs-number"><span class="hljs-number">21</span></span> + beforeHeight &amp;&amp; t.recipient == <span class="hljs-type"><span class="hljs-type">Alice</span></span> txToBob || backToAliceAfterHeight <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <i>Im nächsten Artikel werden wir die Verwendung intelligenter Konten in Finanzinstrumenten wie Optionen, Futures und Rechnungen betrachten.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442238/">https://habr.com/ru/post/de442238/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442226/index.html">Dieser Inhalt ist in Ihrem Land nicht verfügbar: Nachrichten, die Sie nicht von Russland lernen können</a></li>
<li><a href="../de442230/index.html">Welcher der in derselben Stadt lebenden Entwickler verdient mehr: Fernarbeit oder im Büro?</a></li>
<li><a href="../de442232/index.html">Alternativer Slf4j-Spulenlogger</a></li>
<li><a href="../de442234/index.html">Kolonie. Nachwort</a></li>
<li><a href="../de442236/index.html">Warum braucht Dodo Pizza 250 Entwickler?</a></li>
<li><a href="../de442242/index.html">Aktuelle Nachrichten: Die größte Solarzellenanlage der westlichen Hemisphäre wurde in Betrieb genommen</a></li>
<li><a href="../de442244/index.html">Rust 1.33 Release</a></li>
<li><a href="../de442248/index.html">Die NASA genehmigte den unbemannten Teststart von Dragon-2</a></li>
<li><a href="../de442250/index.html">Reagieren und Vue: Stärken</a></li>
<li><a href="../de442252/index.html">Python-Code-Lebenszyklus - CPython-Laufzeitmodell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>