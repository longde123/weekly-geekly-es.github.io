<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍽️ 🏣 👁‍🗨 Die Logik des Denkens Spin-off 2: einige Verkettungsalgorithmen 👨‍🎓 🥥 📬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Herausforderung:
 Trennen Sie die oft wiederholten Abfolgen von Ereignissen in eine separate Kette, in der nichts überflüssig ist.
 Diese Aufgabe hat ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Logik des Denkens Spin-off 2: einige Verkettungsalgorithmen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/388725/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Herausforderung:</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trennen Sie die oft wiederholten Abfolgen von Ereignissen in eine separate Kette, in der nichts überflüssig ist.</font></font><br>
<a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Aufgabe hat viele Lösungen. Oft verwendetes "Backen" - die Beziehungen, die oft verwendet werden, sind festgelegt, während andere geschwächt sind. Im Finale sollten Sie eine Kette erhalten, in der die am häufigsten wiederholten Ereignisse eng miteinander verbunden sind. Diese Lösung weist viele Mängel auf, darunter - niedrige Geschwindigkeit. Aber wir haben Identifikationswellen von Redozubov, wir können andere Algorithmen verwenden, die nach der ersten Wiederholung eine neue Kette bilden können. Beginnen wir mit einem einfachen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">letzten Note</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Verfahren zum Aufzeichnen aller Ereignisse in einer Speicherkette wird beschrieben. </font><font style="vertical-align: inherit;">Lassen Sie das System einmal das Wort "Verfall" und zu einem anderen Zeitpunkt das Wort "Wasserfall" lesen. </font><font style="vertical-align: inherit;">Diese beiden Wörter haben den gleichen Teil - das Ende von drei Buchstaben. </font><font style="vertical-align: inherit;">Entsprechend den Bedingungen des Problems ist es notwendig, das Kettenpad hervorzuheben. </font><font style="vertical-align: inherit;">Diese Kette hat keine Voraussetzungen, dh sie erkennt die entsprechende Eingabe leicht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Lösung</font></font></h2><br>
<img src="https://habrastorage.org/files/e2d/fed/f56/e2dfedf56cab44f5b147eabedaa9d22f.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir teilen die Aufgabe in zwei Teile: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) Finden Sie zwei ähnliche Ereignisreihen (Sie müssen verstehen, dass ungefähr diese beiden Wörter ähnliche Sequenzen enthalten). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) Wählen Sie sie in einer separaten Kette aus („Pad“).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit Teil 2. Wir komplizieren den Neurocluster mit Zeitstempeln, in denen alle Ereignisse in der Speicherkette gespeichert sind, wie im Bild gezeigt. Dank des erkennenden Teils (der Richtung der Verbindungen von den Attributen zum verallgemeinerten Zeitstempel) wird Teilaufgabe 1 gelöst - um eine Position mit gemeinsamen Attributen zu finden, und dank der Speicherkette mit nach unten verlinkenden Gliedern wird Teilaufgabe 2 gelöst. Die Lösung für Teilaufgabe 2 lautet: Wir werden zwei Wörter gleichzeitig abrufen wo sie gemeinsam haben. Das heißt, das System sendet eine Aktivierung durch Neuronen, die diesen Buchstaben entsprechen. Wenn der Buchstabe in beiden Wörtern gefunden wird, muss er gespeichert werden. Lassen Sie dazu die Erinnerung mit der halben Kraft geschehen. Wenn die Aktivierungsschwelle des Neurons T ist, sollte die Speicherkette 0,5 T des Aktionspotentials senden. Dann wird die Aktivierungsschwelle nur dann überschritten, wennwenn sich das Symptom in beiden Ketten traf. Danach wird das Symptom aktiviert. Dann können Sie den üblichen Algorithmus zum Auswendiglernen mit dem Code aus dem vorherigen Artikel verwenden - der Hippocampus erstellt eine Speicherkette und weist ihm die Zeichen zu, die beiden Ketten gemeinsam waren. Wir haben die Lösung auf die vorherige reduziert.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In ENS (natürliches NS) kann eine „halbe Aktivierung“ erreicht werden, indem die Sendezeit (die Anzahl der eingetroffenen Spitzen), die Anzahl der Neurotransmitter oder möglicherweise inhibitorische Verbindungen (um 1T in 0,5T umzuwandeln) variiert werden.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unteraufgabe 1 ist etwas komplizierter, da sie mit Fuzzy-Erkennung funktionieren sollte. </font><font style="vertical-align: inherit;">Das heißt, auch wenn es nur wenige gemeinsame Anzeichen in der Kette gibt, die irgendwo in der Mitte der Kette verloren gehen, sollten Sie diese Situation dennoch bemerken. </font><font style="vertical-align: inherit;">Ich möchte Sie daran erinnern, dass sich Neuronen relativ gesehen in drei Modi befinden können: Ruhe, Senden eines einzelnen Signals und Hochfrequenzaktivierungsmodus. </font><font style="vertical-align: inherit;">Es kann akzeptiert werden, dass "vollständige Erkennung" zum Übergang des Neurons in den Hochfrequenzaktivierungsmodus führt und die Fuzzy-Erkennung zu einer einzelnen Signalübertragung führt. </font><font style="vertical-align: inherit;">Oder wir können davon ausgehen, dass der Neurocluster spezialisierte Neuronen enthält, von denen einige nur mit völliger Übereinstimmung und sicherer Erkennung funktionieren, und das andere Neuron funktioniert, wenn nur ein Teil der Merkmale erkannt wird. </font><font style="vertical-align: inherit;">Es gibt viele Lösungen, die Hauptsache ist, das Auftreten einer Aktivierung auf den gewünschten Clustern irgendwie zu bemerken.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann es zu tun ist</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Frage ist, wann eine solche Suche durchgeführt werden muss. Es gibt verschiedene Ansätze: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) einen speziellen Schlafmodus - genauer gesagt „langsamer Schlaf“. Das System durchläuft alle Ereignisse, die es an einem Tag gelernt hat, und sucht nach Übereinstimmungen mit seinen anderen Erinnerungen. In diesem Fall verwendet das System Speicher, der in einer absteigenden Kette sendet, und gibt dann den Neuronen der Zeichen Zeit, Signale zu senden, die bereits „bis“ zu anderen Speichern reichen. Danach fasst er die Erinnerungen zusammen und sucht sie, die die größte Gesamtaktivierung aufweisen. Dann wählt er einen dieser Orte aus und startet die Unteraufgabe 2 - „Wähle die Kette“.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) ohne ein spezielles Schlafschema. </font><font style="vertical-align: inherit;">Das System kann während der Wahrnehmung eine Suche im laufenden Betrieb durchführen - und wie sieht die aktuelle Situation aus? </font><font style="vertical-align: inherit;">Tatsächlich erfolgt die Suche während des normalen Denkens aufgrund des Sendens von Signalen durch Neuronen automatisch. Das System kann nur auf die Erinnerungen achten, die viel mit der aktuellen Situation gemeinsam haben, und bei Bedarf die Analyse ausführen - die allgemeine Unterkette hervorheben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ähnliche Algorithmen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Algorithmen scheinen einfach zu sein, enthalten jedoch viele Feinheiten, noch mehr als beim schnellen Sortieralgorithmus, der, wie Sie wissen, lange Zeit nicht fehlerfrei geschrieben werden konnte.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Aufgabe ähnelt bekannten Aufgaben, beispielsweise der Suche nach gemeinsamen DNA-Teilsequenzen. Nur DNA in jedem Schritt kann nur ein Nukleotid haben, und im neuronalen Netzwerk kann es für jeden Zeitstempel eine beliebige Anzahl von Zeichen geben. Daher ist diese Aufgabe im Vergleich zur DNA-Suche ein allgemeinerer Fall. Wenn Sie versuchen, vorhandene Algorithmen zu übertragen und ein solches „Schlupfloch“ -Problem ohne neuronale Netze zu lösen, indem Sie die Zeichenlisten manipulieren, dreht sich Ihr Kopf - all diese verschachtelten Übereinstimmungslisten, Listen von Übereinstimmungssequenzen, andere Fragen. Die Lösung dieses Problems durch Senden von Aktivierungen an Neuronen ist viel einfacher - Neuronen existieren bereits, sie erledigen alles automatisch, ihr Speicher ist bereits zugewiesen, es werden keine verschachtelten Listen benötigt, es müssen nur einige Neuronen analysiert und die erforderlichen Algorithmen ausgeführt werden.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich nenne die Unteraufgaben 1 und 2 Modi mit einer bzw. zwei führenden Ketten. </font><font style="vertical-align: inherit;">Das heißt, "wie viele aktive absteigende Neuronen in den Speicherketten senden Signale, um Übereinstimmungen hervorzuheben." </font><font style="vertical-align: inherit;">Wenn es nur eine solche zurückgerufene Kette gibt, sucht sie nach einem zweiten Kandidaten für die Überprüfung. </font><font style="vertical-align: inherit;">Und wenn der Kandidat bereits gefunden wurde, können Sie ihn aktivieren und die Zeichen hervorheben. </font><font style="vertical-align: inherit;">Solche Namen - "1 oder 2 führende Ketten" - ermöglichen es, diese Algorithmen namentlich und nicht "Teilaufgabe 1 oder 2" zu benennen. </font><font style="vertical-align: inherit;">Der Modus mit einer führenden Kette kann auch als "Koinzidenz-Suchmodus" bezeichnet werden, und die beiden führenden Ketten können als Koinzidenz-Hervorhebungsmodus bezeichnet werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suche nach Übereinstimmungen ...</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(1, 1 führende Kette) kann auf folgende Arten ausgeführt werden: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) Alle Erinnerungen, die sich während des Tages getroffen haben, linear anzeigen. Der Übergang zu Debugging-Zwecken in diesen Modus kann wie folgt erfolgen: Ein spezielles Unicode-Zeichen oder ein spezielles Wort wird in die Testsätze der Eingabedaten für das ANN eingefügt. Beim Lesen wechselt das ANN in den Modus „Slow Sleep“ und beginnt mit der Suche nach Übereinstimmungen. Die Bedeutung ist folgende: Sie füllten die ANN mit realen Daten und starteten Debugging-Algorithmen, um Verallgemeinerungen zu finden.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) keine lineare Suche zu verwenden, sondern die Analyse mit den interessantesten Situationen zu beginnen - mit denen, die die größte emotionale Farbe hatten. Diese Optimierung ist erforderlich, da diese Algorithmen sehr unersättlich sind. Bei Ratten scheint die Erinnerung an den Tag nur etwa zehnmal schneller zu sein als tagsüber. Schlaf braucht weniger Zeit als Wachheit. Bei einer gleichmäßigen Zeitverteilung über alle Speicher kann jeder Speicher so verwaltet werden, dass nur wenige ähnliche Situationen verglichen werden, von denen die meisten Müll und unbedeutende Zufälle sind. Daher ist es vorteilhaft, sich auf das Wichtigste zu konzentrieren und damit zu arbeiten. Wir können sagen, dass der Algorithmus eine weitere Schritt - 0 führende Kette hinzufügt. In diesem Schritt sollte das System das nächste Ereignis im Speicher mit maximaler Wichtigkeit auswählen.und geben Sie es an den nächsten Schritt weiter - machen Sie es zur Führungskette für die Suche nach Übereinstimmungen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3) Es ist möglich, Serifen aus der Zeit des Wachseins herzustellen - im Voraus, um Verbindungen zu den interessantesten Orten herzustellen, die nachts verglichen werden müssen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ausgewählte Ketten mit Zufällen werden in Erinnerung behalten, aber in Zukunft können sie vergessen werden, wenn ihre Bedeutung mit der Zeit nachlässt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergessen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch das Vergessen wird der Neurocluster gelöscht - die Operation removeNC, die Umkehrung der Operation newNC. </font><font style="vertical-align: inherit;">In der ENS werden Neuronen nirgendwo hingehen, sie werden nicht sterben, ihre Verbindungen werden einfach so stark geschwächt, dass sie nicht mehr auf ihre Zeichen reagieren und bereit sind, sich neu einzustellen, um sich an eine andere Kombination zu erinnern. </font><font style="vertical-align: inherit;">In unserem Modell müssen solche Neuronen nicht gespeichert werden, sie können sofort entfernt werden - dies beschleunigt den Betrieb des ANN, reduziert den Speicherverbrauch und vereinfacht das Debuggen. </font><font style="vertical-align: inherit;">Auf diese Weise können Sie den Speicherverbrauch möglicherweise um eine Größenordnung reduzieren.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallelisierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Übergang vom 1- zum 2-Modus zu schaffen, habe ich zunächst versucht, Kontrollneuronen zu erstellen, die Signalumschaltung, Analyse und Modusänderung bewirken. Aber dann fand ich diese Arbeit zu niedrig und begann, zwingenden C ++ - Code zu schreiben - Code wie „Alle Cluster durchlaufen, analysieren, den gewünschten auswählen, überlegen, ob der Betriebsmodus geändert werden soll“.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Frage nach der Leistung eines solchen Systems: Wenn Sie Neuronenhardware herstellen, können Sie diese parallelisieren (ja, zumindest auf Grafikkarten). Dann wird der Code mit der Steuerung von Neuronen und Verbindungen innerhalb des Clusters einfach und automatisch parallelisiert (dies ist nur ein Aktivierungspaket, das gemäß den Bedingungen der Aufgabe parallelisiert wird), aber der zwingende C ++ - Code muss jedes Mal unabhängig parallelisiert werden. Daher ist es für kleine neuronale Netze mit einem Thread einfacher, C ++ - Code zu schreiben, und für massiv parallele ANNs ist es besser, diese Arbeit innerhalb des ANN selbst auf die Schultern von Neuronen und die Verbindungen zwischen ihnen zu übertragen. Wir dürfen nicht vergessen, dass der "Zyklus durch alle Neuronen" oder der "Zyklus durch alle Neurocluster" in C ++ aus Sicht der Hardware ANN O (1) ist, ein einzelner Schritt zum Senden der Aktivierung. Daher kann es gesehen werdenSowohl 1VTs als auch 2VTs (führende Ketten) für ideal parallelisierte ANNs haben den gleichen Rechenaufwand.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortsetzung: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primitive Prognose in ANN</font></font></a></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de388725/">https://habr.com/ru/post/de388725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de388711/index.html">Automatisierung der Beleuchtung eines Grundstücks in einem Dorf oder der erste Schritt zu einem Smart Home</a></li>
<li><a href="../de388713/index.html">Die siebte Periode des Periodensystems ist jetzt gefüllt, und dies ist offiziell</a></li>
<li><a href="../de388715/index.html">In der neuen Version von Android N wechselt Google zu OpenJDK</a></li>
<li><a href="../de388719/index.html">Die Logik des Denkens - Ausgründung</a></li>
<li><a href="../de388723/index.html">Gestorben Peter Naur, einer der Schöpfer von Algol und der BNF-Notation</a></li>
<li><a href="../de388727/index.html">Die Entwickler eines Implantats, das die Funktionalität gelähmter Gliedmaßen wiederherstellen kann, erhielten 16 Millionen US-Dollar</a></li>
<li><a href="../de388729/index.html">M5BAT - ein neuer Ansatz zur industriellen Energiespeicherung</a></li>
<li><a href="../de388731/index.html">7 besten Wissenschaftsfotos von 2015 laut Wired</a></li>
<li><a href="../de388733/index.html">Windows 95 auf Nintendo 3DS starten? Ja, das ist möglich</a></li>
<li><a href="../de388735/index.html">Zurück zu den Grundlagen: Die Nachfrage nach Audiokassetten hat 2015 deutlich zugenommen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>