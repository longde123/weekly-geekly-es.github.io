<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😪 💇🏿 🈯️ Angular 6+ est un guide d'injection de dépendance complet. fourni par rapport aux fournisseurs: [] 🗝️ 🏔️ 👨‍👨‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Angular 6 a introduit une nouvelle syntaxe améliorée pour l'incorporation des dépendances de service dans une application ( provideIn ). Malgré le fai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angular 6+ est un guide d'injection de dépendance complet. fourni par rapport aux fournisseurs: []</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429342/"><img src="https://habrastorage.org/getpro/habr/post_images/878/6df/25a/8786df25a4fd4d9b0699cabbfc8dcaec.jpg" alt="image"><br><br>  Angular 6 a introduit une nouvelle syntaxe améliorée pour l'incorporation des dépendances de service dans une application ( <b>provideIn</b> ).  Malgré le fait qu'Angular 7 ait déjà été publié, ce sujet est toujours d'actualité.  <b>Il y a beaucoup de confusion dans les commentaires de GitHub, Slack et Stack Overflow, alors examinons de plus près ce sujet.</b> <b><br></b> <br><h3>  Dans cet article, nous considérerons: </h3><br><ol><li>  <b>Injection de dépendance</b> </li><li>  Ancienne façon d'injecter des dépendances dans Angular ( <b>fournisseurs: []</b> ); </li><li>  Une nouvelle façon d'injecter des dépendances dans Angular ( <b>providedIn: 'root' | SomeModule</b> ); </li><li>  <b>Les</b> scénarios <b>UseIn fournissentIn</b> ; </li><li>  Recommandations pour l'utilisation de la nouvelle syntaxe dans les applications; </li><li>  Pour résumer. </li></ol><a name="habracut"></a><br><h3>  Injection de dépendance </h3><br>  Vous pouvez ignorer cette section si vous avez déjà une idée de <b>DI</b> . <br><blockquote>  L' <b>injection de</b> dépendance ( <b>DI</b> ) est un moyen de créer des objets qui dépendent d'autres objets.  Le système d'injection de dépendances fournit des objets dépendants lorsqu'il instancie une classe. <br><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation angulaire</a> </blockquote><br>  Les explications formelles sont bonnes, mais regardons de plus près ce qu'est l'injection de dépendance. <br><br>  Tous les composants et services sont des classes.  Chaque classe a une méthode <b>constructeur</b> spéciale qui, lorsqu'elle est appelée, crée un objet instance de cette classe, qui est utilisé dans l'application. <br><br>  Supposons que l'un de nos services comporte le code suivant: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private http: HttpClient)</code> </pre> <br>  Si vous le créez sans utiliser le mécanisme d'injection de dépendances, vous devez ajouter <b>HttpClient</b> manuellement.  Ensuite, le code ressemblera à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyService(httpClient)</code> </pre> <br>  Mais où dans ce cas obtenir <b>httpClient</b> ?  Il doit également être créé: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(httpHandler)</code> </pre> <br>  Mais où trouver <b>httpHandler</b> maintenant?  Et ainsi de suite, jusqu'à ce que toutes les classes nécessaires soient instanciées.  Comme nous pouvons le voir, la création manuelle peut être compliquée et des erreurs peuvent survenir au cours du processus. <br><br>  <b>Le mécanisme d'injection de dépendance angulaire fait tout cela automatiquement.</b>  <b>Tout ce que nous devons faire est de spécifier les dépendances dans le constructeur du composant et elles seront ajoutées sans aucun effort de notre part.</b> <br><br><h3>  Ancienne façon d'injecter des dépendances dans Angular (fournisseurs: []) </h3><br>  Pour exécuter l'application, Angular doit connaître chaque objet individuel que nous voulons implémenter dans les composants et les services.  Avant la sortie d'Angular 6, la seule façon de procéder était de spécifier les services dans la propriété des <b>fournisseurs: []</b> décorateurs <b>@NgModule</b> , <b>@</b> <b>omponent</b> et <b>@Directive</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6c/3a7/433/f6c3a7433a1f72dc45b9e9cd2b5edc18.png" alt="image"><br><br>  Voici trois utilisations principales des <b>fournisseurs: []</b> : <br><br><ol><li>  Dans le décorateur <b>@NgModule</b> du module immédiatement chargé ( <b>avide</b> ); </li><li>  Dans le décorateur <b>@NgModule</b> du module de chargement différé ( <b>paresseux</b> ); </li><li>  Dans les décorateurs <b>@Component</b> et <b>@Directive</b> . </li></ol><br><h4>  Modules téléchargés avec l'application (Désireux) </h4><br>  Dans ce cas, le service est enregistré dans la portée globale en tant que singleton.  Ce sera un singleton même s'il est inclus dans les <b>fournisseurs [] de</b> plusieurs modules.  Une seule instance de la classe de service est créée et sera enregistrée au niveau racine de l'application. <br><br><h4>  Modules de charge différée (paresseux) </h4><br>  Une instance du service connecté au module <b>paresseux</b> sera créée lors de son initialisation.  L'ajout d'un tel service au composant <b>impatient</b> du module entraînera une erreur: <b>aucun fournisseur pour MyService!</b>  <b>erreur</b> . <br><br><h4>  Implémentation dans @ Component et @ Directive </h4><br>  Lorsqu'il est implémenté dans un composant ou une directive, une instance distincte du service est créée, qui sera disponible dans ce composant et tous les enfants.  <b>Dans cette situation, le service ne sera pas un singleton, son instance sera créée chaque fois que le composant est utilisé et supprimé avec la suppression du composant du DOM.</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b0/4fc/6a9/6b04fc6a974ad8278ba910524a3e062e.png" alt="image"><br><br>  Dans ce cas, <b>RandomService n'est</b> pas implémenté au niveau du module et n'est pas un singleton, <br>  mais enregistré auprès des <b>fournisseurs: []</b> du composant <b>RandomComponent</b> .  Par conséquent, nous obtiendrons un nouveau nombre aléatoire à chaque fois en utilisant <b>&lt;rand®m&gt; &lt;/ rand®m&gt;</b> . <br><br><h3>  Nouvelle façon d'injecter des dépendances dans Angular (providedIn: 'root' | SomeModule) </h3><br>  Dans Angular 6, nous avons obtenu un nouvel outil <b>«Tree-shakable providers»</b> pour <b>injecter des</b> dépendances dans une application, qui peut être utilisé en utilisant la propriété <b>providedIn du</b> décorateur <b>@Injectable</b> . <br><br>  <b>Vous pouvez imaginer <b>fourniIn</b> comme l'implémentation de dépendances dans le sens inverse: avant que le module ne décrive les services auxquels il sera connecté, maintenant le service définit le module auquel il est connecté.</b> <br><br>  Le service peut être intégré à la racine de l'application ( <b>fourni dans: «racine»</b> ) ou dans n'importe quel module ( <b>fourni dans: SomeModule</b> ).  <b>providedIn: 'root'</b> est une abréviation pour l'implémentation dans l' <b>AppModule</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c41/57a/fa6/c4157afa6304838f407ab76f4665aaa8.png" alt="image"><br><br>  Analysons les principaux scénarios d'utilisation de la nouvelle syntaxe: <br><br><ol><li>  Implémentation dans le module racine de l'application ( <b>fourniIn: 'root'</b> ); </li><li>  Implémentation dans le module immédiatement chargé ( <b>avide</b> ); </li><li>  Implémentation dans le module avec chargement différé ( <b>paresseux</b> ). </li></ol><br><h4>  Implémentation dans le module racine de l'application (fourniIn: 'root') </h4><br>  Il s'agit de l'option d'injection de dépendance la plus courante.  Dans ce cas, le service ne sera ajouté à l'application groupée que s'il est effectivement utilisé, c'est-à-dire  intégré dans un composant ou un autre service. <br><br>  Lors de l'utilisation de la nouvelle approche, il n'y aura pas beaucoup de différence dans une application SPA monolithique, où tous les services écrits sont utilisés, mais <b>fournis dans: 'root'</b> sera utile lors de l'écriture de bibliothèques. <br><br>  Auparavant, tous les services de bibliothèque devaient être ajoutés aux <b>fournisseurs: [] de</b> son module.  Après l'importation de la bibliothèque dans l'application, tous les services ont été ajoutés au bundle, même si un seul a été utilisé.  Dans le cas de <b>providedIn: 'root',</b> il n'est pas nécessaire de connecter le module de bibliothèque.  Intégrez simplement le service dans le composant souhaité. <br><br><h4>  Module de chargement différé (paresseux) et fourni dans: 'root' </h4><br>  Que se passe-t-il si vous implémentez le service avec <b>providedIn: 'root'</b> dans le module <b>paresseux</b> ? <br><br>  Techniquement, <b>«root»</b> signifie <b>AppModule</b> , mais Angular est suffisamment intelligent pour ajouter un service à l'ensemble <b>paresseux</b> d'un module s'il n'est implémenté que dans ses composants et services.  Mais il y a un problème (bien que certaines personnes prétendent que c'est une fonctionnalité).  Si vous introduisez ultérieurement le service utilisé uniquement dans le module <b>paresseux</b> dans le module principal, le service sera transféré vers le bundle principal.  Dans les grandes applications avec de nombreux modules et services, cela peut entraîner des problèmes de suivi des dépendances et un comportement imprévisible. <br><br>  <b>Faites attention!</b>  <b>L'implémentation d'un service dans plusieurs modules peut conduire à des dépendances cachées qui sont difficiles à comprendre et impossibles à démêler.</b> <br><br>  Heureusement, il existe des moyens d'empêcher cela, et nous les examinerons ci-dessous. <br><br><h3>  Injection de dépendances dans un module immédiatement chargé (impatient) </h3><br>  En règle générale, ce cas n'a pas de sens et au lieu de cela, nous pouvons utiliser <b>providedIn: 'root'</b> .  La connexion d'un service dans <b>EagerModule</b> peut être utilisée pour l'encapsulation et empêchera la mise en œuvre sans connecter de module, mais dans la plupart des cas, cela n'est pas nécessaire. <br><br>  Si vous avez vraiment besoin de limiter la portée du service, il est plus facile d'utiliser l'ancienne méthode des <b>fournisseurs: []</b> , car elle ne conduira certainement pas à des dépendances cycliques. <br><br>  <b>Si possible, essayez d'utiliser providedIn: 'root' dans tous les modules désireux.</b> <br><br><h4>  Remarque  L'avantage des modules à chargement différé (paresseux) </h4><br>  L'une des principales caractéristiques d'Angular est la possibilité de diviser facilement l'application en fragments, ce qui offre les avantages suivants: <br><br><ol><li>  La petite taille du bundle principal de l'application, grâce à laquelle l'application se charge et démarre plus rapidement; </li><li>  Le module de chargement différé est bien isolé et est connecté dans l'application une fois dans la propriété <b>loadChildren</b> de l'itinéraire correspondant. </li></ol><br>  <b>Grâce au chargement retardé, un module entier avec des centaines de services et de composants peut être supprimé ou déplacé vers une application ou une bibliothèque distincte, avec peu ou pas d'effort.</b> <br><br>  Un autre avantage de l'isolement du module <b>paresseux</b> est qu'une erreur commise dans celui-ci n'affectera pas le reste de l'application.  Vous pouvez maintenant dormir paisiblement même le jour de la sortie. <br><br><h3>  Implémentation dans un module à chargement différé (fourni dans: LazyModule) </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/6ce/a76/ebd/6cea76ebda5a5fe9190c79554065f399.png" alt="image"><br><br>  L'injection de dépendances dans un module spécifique empêche l'utilisation du service dans d'autres parties de l'application.  Cela préserve la structure de dépendance, ce qui est particulièrement utile pour les grandes applications où l'injection de dépendances désordonnée peut conduire à la confusion. <br><br>  <b>Fait intéressant: si vous implémentez le service paresseux dans la partie principale de l'application, l'assembly (même AOT) échouera sans erreur, mais l'application plantera avec l'erreur «Aucun fournisseur pour LazyService».</b> <br><br><h4>  Le problème de la dépendance cyclique </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/789/f3d/551/789f3d551cca5651454027e49a1513c3.png" alt="image"><br><br>  Vous pouvez reproduire l'erreur comme suit: <br><br><ol><li>  Créez le module <b>LazyModule</b> ; </li><li>  Nous créons le service <b>LazyService</b> et nous nous connectons à l'aide de <b>providedIn: LazyModule</b> ; </li><li>  Nous créons le composant <b>LazyComponent</b> et le connectons au <b>LazyModule</b> ; </li><li>  Ajoutez <b>LazyService</b> au constructeur du composant <b>LazyComponent</b> ; </li><li>  Nous obtenons une erreur avec une dépendance cyclique. </li></ol><br>  Schématiquement, cela ressemble à ceci: <b>service -&gt; module -&gt; composant -&gt; service</b> . <br><br>  Vous pouvez résoudre ce problème en créant un sous-module <b>LazyServiceModule</b> , qui sera connecté à <b>LazyModule</b> .  Connectez les services au sous-module. <br><img src="https://habrastorage.org/getpro/habr/post_images/c9c/da3/bae/c9cda3bae241d0c3e748ca16007ed816.jpg" alt="image"><br><br>  Dans ce cas, vous devrez créer un module supplémentaire, mais cela ne nécessitera pas beaucoup d'efforts et offrira les avantages suivants: <br><br><ol><li>  Cela empêchera l'introduction du service dans d'autres modules d'application; </li><li>  Un service sera ajouté au bundle uniquement s'il est intégré dans un composant ou un autre service utilisé dans le module. </li></ol><br><h4>  Incorporation d'un service dans un composant (fourni dans: SomeComponent) </h4><br>  Est-il possible d'incorporer un service dans <b>@Component</b> ou <b>@Directive en</b> utilisant la nouvelle syntaxe? <br><br>  <b>Pas pour le moment!</b> <br><br>  Pour créer une instance du service pour chaque composant, vous devez toujours utiliser les <b>fournisseurs: []</b> dans les <b>décorateurs</b> <b>@</b> <b>omponent</b> ou <b>@Directive</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46b/56b/6af/46b56b6af20ae67ffe30cff15fc0eb47.png" alt="image"><br><br><h3>  Meilleures pratiques pour l'utilisation de la nouvelle syntaxe dans les applications </h3><br><h4>  Bibliothèques </h4><br>  <b>providedIn: 'root'</b> est bon pour créer des bibliothèques.  Il s'agit d'un moyen très pratique de connecter uniquement la partie directement utilisée de la fonctionnalité à l'application principale et de réduire la taille de l'assemblage final. <br><br>  <b>Un exemple pratique est la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ngx-model</a> , qui a été réécrite en utilisant la nouvelle syntaxe et s'appelle désormais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@ angular-extensions / model</a> .</b>  <b>Dans la nouvelle implémentation, il n'est pas nécessaire de connecter NgxModelModule à l'application, il suffit juste d'incorporer ModelFactory dans le composant nécessaire.</b>  <b>Les détails de la mise en œuvre peuvent être trouvés <a href="">ici</a> .</b> <br><br><h4>  Modules de téléchargement différé (paresseux) </h4><br>  Utilisez le module distinct <b>fourni In: LazyServicesModule</b> pour les services et branchez-le sur <b>LazyModule</b> .  Cette approche encapsule les services et les empêche d'être connectés à d'autres modules.  Cela établira des limites et aidera à créer une architecture évolutive. <br><br>  <b>D'après mon expérience, une introduction accidentelle dans le module principal ou supplémentaire (à l'aide de providedIn: 'root') peut prêter à confusion et n'est pas la meilleure solution!</b> <br><br>  <b>providedIn: 'root'</b> fonctionnera également correctement, mais lors de l'utilisation de <b>providedIn: LazyServideModule,</b> nous obtenons une erreur <b>«fournisseur manquant»</b> lors de l'implémentation dans d'autres modules et nous pouvons corriger l'architecture.  <b>Déplacez le service vers un emplacement plus approprié dans la partie principale de l'application.</b> <br><br><h4>  Quand faut-il recourir aux prestataires: []? </h4><br>  Dans les cas où il est nécessaire de configurer le module.  Par exemple, connectez le service uniquement à <b>SomeModule.forRoot (someConfig)</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe3/244/6e1/fe32446e118077fc5fb5839bb32c7501.png" alt="image"><br><br>  <b>D'un autre côté, dans cette situation, vous pouvez utiliser providedIn: 'root'.</b>  <b>Cela garantira que le service ne sera ajouté à l'application qu'une seule fois.</b> <br><br><h3>  Conclusions </h3><br><ol><li>  Utilisez <b>providedIn: 'root'</b> pour enregistrer le service en tant que singleton, disponible dans toute l'application. </li><li>  Pour le module inclus dans le bundle principal, utilisez <b>providedIn: 'root'</b> , not <b>providedIn: EagerlyImportedModule</b> .  Dans des cas exceptionnels, utilisez des <b>fournisseurs: []</b> pour l'encapsulation. </li><li>  Créez un sous-module avec des services pour limiter leur portée <b>fournie dans: LazyServiceModule</b> lors de l'utilisation du chargement <b>différé</b> . </li><li>  Branchez le module <b>LazyServiceModule</b> dans Le <b>LazyModule</b> pour éviter une dépendance circulaire. </li><li>  Utilisez les <b>fournisseurs: []</b> dans les <b>décorateurs</b> <b>@</b> <b>omponent</b> et <b>@Directive</b> pour créer une nouvelle instance de service pour chaque nouvelle instance de composant.  Une instance de service sera également disponible dans tous les composants enfants. </li><li>  Limitez toujours la portée des dépendances pour améliorer l'architecture et éviter de confondre les dépendances. </li></ol><br><h3>  Les références </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article d'origine.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Angular est une communauté russophone.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Meetups Angulaire en Russie</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429342/">https://habr.com/ru/post/fr429342/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429330/index.html">Mythes et légendes de l'Agile - des pharaons à nos jours</a></li>
<li><a href="../fr429332/index.html">Sabre laser maison - tel quel, partie 1</a></li>
<li><a href="../fr429336/index.html">Communication entre le pilote et le périphérique par la méthode _HID ACPI en utilisant le GPIO du contrôleur Lynxpoint comme exemple</a></li>
<li><a href="../fr429338/index.html">Stockage Android: interne, externe, amovible. Partie 1/3</a></li>
<li><a href="../fr429340/index.html">Réfléchissez bien avant d'utiliser Helm.</a></li>
<li><a href="../fr429344/index.html">Lecture de fin de semaine: ressources de réglage audio et de conception d'enceintes</a></li>
<li><a href="../fr429346/index.html">Vers le programme de master sans examens: une nouvelle direction "Big Data" aux JO "Je suis un professionnel"</a></li>
<li><a href="../fr429348/index.html">Pourquoi à l'avenir Agile ne sera pas nécessaire</a></li>
<li><a href="../fr429350/index.html">Le marché du câblage et du câblage de l'énergie éolienne offshore atteint 14 milliards de livres sterling</a></li>
<li><a href="../fr429352/index.html">Une liste de IT'shnik sains, ou comment ne pas gâcher votre vie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>