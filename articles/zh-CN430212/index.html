<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌷 🚉 ♂️ OpenSceneGraph：场景几何基础 👠 👲 🐇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 
 OpenGL是OpenSceneGraph的后端，它使用几何图元（例如点，线，三角形和多边形面）构造三维世界中的所有对象。 

 这些图元由有关其顶点的数据定义，这些数据包括顶点的坐标，法线分量，颜色数据和纹理坐标。 此数据存储在特殊数组中。 例如，可以通过为描述基元的对象指定一个顶点索引...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph：场景几何基础</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430212/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="图片"><br><br><h1> 引言 </h1><br>  OpenGL是OpenSceneGraph的后端，它使用几何图元（例如点，线，三角形和多边形面）构造三维世界中的所有对象。 <br><br> 这些图元由有关其顶点的数据定义，这些数据包括顶点的坐标，法线分量，颜色数据和纹理坐标。 此数据存储在特殊数组中。 例如，可以通过为描述基元的对象指定一个顶点索引列表来形成基元。 此方法称为顶点数组方法，它消除了内存中多余顶点的存储，并具有良好的性能。 <br><br> 此外，当在视频存储器中准备好的原语可以被重用时，OpenGL可以使用所谓的<i>显示列表</i>机制，从而显着加快了静态对象的显示速度。 <br><br> 默认情况下，OSG使用顶点数组方法和显示列表方法来渲染几何图形。 但是，可以根据呈现几何数据的方式更改渲染策略。 在本文中，我们将介绍在OSG中使用几何的基本技术。 <br><a name="habracut"></a><br><h1>  1.类Geode和Drawable </h1><br>  osg :: Geode类是一个终端，即场景树的所谓“叶”节点。 它不能具有子节点，但是它包含用于渲染几何图形的所有必要信息。 它的名称Geode是几何节点的缩写。 <br><br> 引擎要处理的几何数据存储在osg :: Drawable类的对象集中，该对象集由osg :: Geode类管理。  osg :: Drawable类是纯虚拟类。 它继承了许多子类，它们是三维模型，OpenGL管道处理的图像和文本。  OSG将drawable称为引擎可以绘制的所有元素。 <br><br>  osg :: Geode类提供了许多用于附着和分离可绘制对象的方法： <br><br><ul><li> 公共方法addDrawable（）-将指针传递给osg :: Geode类实例中的drawable元素。 所有这些元素均由osg :: ref_ptr &lt;&gt;智能指针控制。 <br></li><li> 公共方法removeDrawable（）和removeDrawables（）从osg :: Geode中删除对象，并减少其引用计数。  removeDrawable（）方法将指向感兴趣元素的指针作为单个参数，而removeDrawables（）方法采用两个参数：初始索引和要从osg :: Geode对象数组中删除的元素数。 <br></li><li>  getDrawable（）方法返回指向作为参数传递的索引处的元素的指针。 <br></li><li>  getNumDrawables（）方法返回附加到osg :: Geode的元素总数。 例如，要从osg :: Geode中删除所有元素，可以使用以下代码 <br></li></ul><br><pre><code class="cpp hljs">geode-&gt;removeDrawables(<span class="hljs-number"><span class="hljs-number">0</span></span>, geode-&gt;getNumDrawables());</code> </pre> <br><h1>  2.绘制简单的形状 </h1><br>  OSG提供了osg :: ShapeDrawable类，它是osg :: Drawable类的后代，旨在创建简单的三维基元。 此类包括一个osg :: Shape对象，该对象存储有关特定几何形状和其他参数的信息。 例如，使用setShape（）方法生成基元 <br><br><pre> <code class="cpp hljs">shapeDrawable-&gt;setShape(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Box(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">5.0f</span></span>));</code> </pre><br> 创建一个矩形框，该矩形框在点（1.0，0.0，0.0）处的几何中心，宽度和高度为10，深度为5个单位。  osg :: Vec3类在三维空间中定义矢量（此外，还提供了描述相应维数的osg :: Vec2和osg :: Vec4类）。 <br><br> 在OSG中，最流行的原语由osg :: Box，osg :: Capsule，osg :: Cone，osg :: Cylinder和osg :: Sphere表示。 <br><br> 考虑该机制的应用示例。 <br><br>  <strong>主文件</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ShapeDrawable&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::ShapeDrawable&gt; shape1 = new osg::ShapeDrawable; shape1-&gt;setShape(new osg::Box(osg::Vec3(-3.0f, 0.0f, 0.0f), 2.0f, 2.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape2 = new osg::ShapeDrawable; shape2-&gt;setShape(new osg::Cone(osg::Vec3(0.0f, 0.0f, 0.0f), 1.0f, 1.0f)); shape2-&gt;setColor(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape3 = new osg::ShapeDrawable; shape3-&gt;setShape(new osg::Sphere(osg::Vec3(3.0f, 0.0f, 0.0f), 1.0f)); shape3-&gt;setColor(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(shape1.get()); root-&gt;addDrawable(shape2.get()); root-&gt;addDrawable(shape3.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br> 这个例子尤其不需要注释：在程序中创建了三个简单的形状，编译和启动后，我们将看到这样的结果 <br><br><img src="https://habrastorage.org/webt/mu/kl/cq/muklcqrapar1quikfyshzkang-4.png"><br><br> 示例中显示的机制非常简单明了，但这并不是创建几何体的最有效方法，只能用于测试。  osg :: Geometry类用于在基于OSG的高性能应用程序中创建几何。 <br><br><h1>  3.几何数据的存储：osg ::数组和osg ::几何 </h1><br>  osg :: Array类是一个基本的抽象类，从该类继承了几个后代，这些后代旨在存储传递给OpenGL函数的数据。 使用此类类似于使用C ++标准库中的std :: vector。 以下代码说明了使用push_back（）方法将向量添加到顶点数组 <br><br><pre> <code class="cpp hljs">vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  OSG数组在堆上分配，并由智能指针管理。 但是，这不适用于数组元素，例如osg :: Vec3或osg :: Vec2，它们也可以在堆栈上创建。 <br><br>  osg :: Geometry类是使用顶点数组的OpenGL函数的包装。 它是从osg :: Drawable类派生的，可以轻松地添加到osg :: Geode对象列表中。 此类将上述数组作为输入，并使用它们使用OpenGL生成几何。 <br><br><h1>  4.顶点及其属性 </h1><br> 顶点是几何图元的原子单位。 它具有许多描述二维或三维空间中的点的属性。 属性包括：位置，颜色，法线向量，纹理坐标，雾坐标等。 顶部必须始终在空间中具有位置，因为对于其他属性，可以选择存在它们。  OpenGL支持16种基本顶点属性，并且可以使用不同的数组来存储它们。  osg :: Geometry类支持所有属性数组，并且可以使用set * Array（）形式的方法进行设置。 <br><br>  <b>OpenSceneGraph中的顶点属性</b> <br><table><tbody><tr><th> 属性 </th><th> 资料类型 </th><th>  Osg ::几何方法 </th><th> 等效的OpenGL调用 </th></tr><tr><td> 位置 </td><td>  3向量 </td><td>  setVertexArray（） </td><td>  glVertexPointer（） </td></tr><tr><td> 正常的 </td><td>  3向量 </td><td>  setNormalArray（） </td><td>  glNormalPointer（） </td></tr><tr><td> 色泽 </td><td>  4向量 </td><td>  setColorArray（） </td><td>  glColorPointer（） </td></tr><tr><td> 二次色 </td><td>  4向量 </td><td>  setSecondaryColorArray（） </td><td>  glSecondaryColorPointerEXT（） </td></tr><tr><td> 雾坐标 </td><td> 飘浮 </td><td>  setFogCoordArray（） </td><td>  glFogCoordPointerEXT（） </td></tr><tr><td> 纹理坐标 </td><td>  2或3向量 </td><td>  setTexCoordArray（） </td><td>  glTexCoordPointer（） </td></tr><tr><td> 其他属性 </td><td> 用户定义 </td><td>  setVertexArribArray（） </td><td>  glVertexAttribPointerARB（） </td></tr></tbody></table><br> 原则上，必须为每个顶点设置自己的属性，这将导致形成多个具有相同大小的属性数组-否则，数组大小的不匹配会导致引擎的行为不确定。  OSG支持多种链接顶点属性的方法，例如 <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br> 表示每个顶点和顶点的每种颜色都是一对一关联的。 但是，如果您看这样的代码 <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br> 然后他将一种颜色应用于整个几何。 同样，可以通过调用setNormalBinding（），setSecondaryColorBinding（），setFogCoordBinding（）和setVertexAttribBinding（）方法来配置其他属性之间的关系。 <br><br><h1>  5.几何图元集 </h1><br> 定义顶点属性数组之后的下一步是描述如何渲染顶点数据。 虚拟osg :: PrimitiveSet类用于控制渲染器从一组顶点生成的几何图元。  osg :: Geometry类提供了几种处理几何图元集的方法： <br><br><ul><li>  addPrimitiveSet（）-将指针传递给osg :: Geometry对象中的一组图元。 <br></li><li>  removePrimitiveSet（）-删除一组原语。 作为参数，它使用集合的初始索引和要删除的集合数。 <br></li><li>  getPrimitiveSet（）-在作为参数传递的索引处返回一组原始元素。 <br></li><li>  getNumPrimitiveSets（）-返回与此几何关联的图元的总数。 <br></li></ul><br>  osg :: PrimitiveSet类是抽象的，无法实例化，但是封装了与OpenGL一起操作的原始集的几个派生类（例如osg :: DrawArrays和osg :: DrawElementsUInt）从其继承。 <br><br>  osg :: DrawArrays类使用顶点数组的几个连续元素来构造几何图元。 可以通过调用方法来创建它并将其附加到几何。 <br><br><pre> <code class="cpp hljs">geom-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(mode, first, count));</code> </pre><br> 第一个参数模式将基本类型设置为相应的OpenGL基本类型：GL_POINTS，GL_LINE_STRIP，GL_LINE_LOOP，GL_LINES，GL_TRIANGLE_STRIP，GL_TRIANGLE_FAN，GL_TRIANGLES，GL_QUAD_STRIP，GL_QUADS和GL_POLY。 <br><br> 第一个和第二个参数指定顶点数组中的第一个索引以及应从中生成几何图形的顶点数。  <strong>此外，OSG不会检查指定的顶点数是否足以构建该模式指定的几何，这可能导致应用程序崩溃！</strong> <br><br><h1>  6.示例-绘制一个涂漆的正方形 </h1><br> 我们将上述所有内容作为一个简单示例 <br><br><div class="spoiler">  <b class="spoiler_title">Quad示例的完整源代码</b> <div class="spoiler_text">  <strong>主文件</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 1.0f)); vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back(osg::Vec3(0.0f, -1.0f, 0.0f)); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back(osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br> 编译执行后，我们得到的结果与此类似 <br><br><img src="https://habrastorage.org/webt/pz/1p/e4/pz1pe4inopylxd1vikvi4kzm8m0.png"><br><br> 这个例子需要澄清。 因此，首先，我们创建一个正方形的顶点数组，在其中存储其坐标 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br> 接下来，我们设置法线数组。 在我们的简单情况下，我们不需要为每个顶点创建一个法线-只需描述一个垂直于正方形平面的单位矢量即可 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br> 为每个顶点设置颜色 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec4Array&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec4Array; colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br> 现在创建一个几何对象，该对象将存储正方形的描述，然后由渲染器处理。 我们将顶点数组传递给此几何 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get());</code> </pre><br> 通过指定一组法线，我们通过指定法线BIND_OVAERALL的绑定方法（“绑定”）来通知引擎所有单个顶点将使用一个法线 <br><br><pre> <code class="cpp hljs">quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br> 相反，传递顶点的颜色表示每个顶点将具有自己的颜色 <br><br><pre> <code class="cpp hljs">quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br> 现在为几何创建一组图元。 我们指示应从顶点数组生成正方形（GL_QUADS）面，将索引为0的顶点作为第一个顶点，并且顶点总数将为4 <br><br><pre> <code class="cpp hljs">quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>));</code> </pre><br> 好吧，我认为没有必要解释几何的转移和渲染的启动 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br> 上面的代码等效于纯OpenGL中的以下设计 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLfloat vertices[][<span class="hljs-number"><span class="hljs-number">3</span></span>] = { … }; glEnableClientState( GL_VERTEX_ARRAY ); glVertexPointer( <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, vertices ); glDrawArrays( GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> );</code> </pre><br><h1>  7.索引图元中的顶点 </h1><br>  osg :: DrawArrays类在直接从数组中无间隙地读取顶点数据时效果很好。 但是，当同一个顶点可以属于一个对象的多个面时，这并不是那么有效。 让我们来看一个例子。 <br><br><img src="https://habrastorage.org/webt/yp/is/wm/ypiswmcxzm2uokv9xdreonovmf4.png"><br><br> 立方体有八个顶点。 但是，从图中可以看出（我们看立方体在平面上的展开），某些顶点属于多个面。 如果您构建一个由12个三角形面组成的立方体，则这些顶点将被重复，而不是由8个顶点组成的数组，而是由36个顶点组成的数组，其中大多数实际上是相同的顶点！ <br><br> 在OSG中，有类osg :: DrawElementsUInt，osg :: DrawElementsUByte和osg :: DrawElementsUShort，它们使用顶点索引数组作为数据来解决上述问题。 索引数组存储描述面和几何图形其他元素的图元顶点的索引。 将这些类应用于多维数据集时，足以存储通过索引数组与面相关联的八个顶点的数组。 <br><br>  osg :: DrawElements *类型的类的构建方式与标准类std :: vector相同。 此类代码可用于添加索引。 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; de = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">3</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br> 该代码定义了图中所示立方体的正面。 <br><br> 让我们考虑另一个说明性的例子-八面体 <br><br><img src="https://habrastorage.org/webt/is/cg/3r/iscg3rdq59wftnoy7h1iulgoczk.png"><br><br> 有趣的是，它仅包含六个顶点，但是每个顶点最多可以输入四个三角形面！ 我们可以使用osg :: DrawArrays创建一个包含24个顶点的数组来显示所有八个面。 但是，否则，我们将执行其他操作-将顶点存储在六个元素的数组中，并使用osg :: DrawElementsUInt类生成面。 <br><br><div class="spoiler">  <b class="spoiler_title">八面体示例的完整资料</b> <div class="spoiler_text">  <strong>主文件</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/SmoothingVisitor&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array(6); (*vertices)[0].set( 0.0f, 0.0f, 1.0f); (*vertices)[1].set(-0.5f, -0.5f, 0.0f); (*vertices)[2].set( 0.5f, -0.5f, 0.0f); (*vertices)[3].set( 0.5f, 0.5f, 0.0f); (*vertices)[4].set(-0.5f, 0.5f, 0.0f); (*vertices)[5].set( 0.0f, 0.0f, -1.0f); osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = new osg::DrawElementsUInt(GL_TRIANGLES, 24); (*indices)[ 0] = 0; (*indices)[ 1] = 1; (*indices)[ 2] = 2; (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;addPrimitiveSet(indices.get()); osgUtil::SmoothingVisitor::smooth(*geom); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br> 让我们更详细地分析此代码。 当然，我们要做的第一件事是创建六个顶点的数组 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array(<span class="hljs-number"><span class="hljs-number">6</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">0</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">1</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">2</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">3</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">4</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">5</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>);</code> </pre><br> 我们通过使用指针和operator []运算符的解引用操作访问其坐标的向量来直接初始化每个顶点（我们记得osg :: Array在其设备上与std :: vector相似）。 <br><br> 现在创建面作为顶点索引列表 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">24</span></span>); (*indices)[ <span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; //  1 (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; //  2 (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; //  3 (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; //  4 (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; //  5 (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; //  6 (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; //  7</span></span></code> </pre><br> 面将是三角形，将有8个，这意味着索引列表应包含24个元素。 面的索引在此数组中顺序排列：例如，面0由顶点0、1和2形成； 面1-顶点0、4和1； 面2-顶点4、5和1等。 如果您查看脸部的脸部，则这些顶点按逆时针顺序列出（请参见上图）。 <br><br> 我们在前面的示例中执行了创建几何的其他步骤。 我们唯一没有做的是自动生成平滑的（平均）法线，在此示例中，我们通过调用 <br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br> 确实，如果给出了一个面的顶点，那么很容易计算出它的法线。 在几个面会聚的顶点处，计算出一定的平均法线-将会聚面的法线相加，然后将所得总和再次归一化。 这些操作（以及更多操作！）可以由引擎本身使用osgUtil库中的类来执行。 因此，在我们的示例中，我们将向链接器添加一条指令，以使用* .pro文件中的该库来构建程序。 <br><br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">八面体</a></strong> <br><br><pre> <code class="cmake hljs">CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,_d) . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil }</code> </pre><br> 结果，我们得到以下结果 <br><br><img src="https://habrastorage.org/webt/sf/ia/yg/sfiayg-o7wqijwskwuw6276xx0y.png"><br><br> 要了解其工作原理，请考虑OpenGL管道 <br><br><img src="https://habrastorage.org/webt/7w/f0/mq/7wf0mqmabsa1ltwbzsgt189jsmy.png"><br><br> 顶点数组机制减少了OpenGL调用的次数。 它将顶点数据存储在应用程序内存中，供客户端使用。 服务器端的OpenGL管道可以访问各种顶点数组。 如图所示，OpenGL从客户端的顶点缓冲区接收数据，并以有序的方式执行图元的组装。 这就是使用osg :: Geometry类的set * Array（）方法处理数据的方式。  osg :: DrawArrays类直接遍历这些数组并显示它们。 <br><br> 当使用osg :: DrawElements *时，顶点数组的维数减小，并且转移到管道的顶点数减少。 索引数组使您可以在服务器端创建顶点缓存。  OpenGL从缓存读取顶点数据，而不是从客户端的顶点缓冲区读取。 这显着提高了整体渲染性能。 <br><br><h1>  8.多边形网格处理技术 </h1><br>  OpenSceneGraph支持各种技术来处理场景几何对象的多边形网格。 这些预处理方法（例如多边形缩小和细分）通常用于创建和优化多边形模型。 它们具有一个简单的界面，但是在此过程中，它们执行许多复杂的计算，因此不适合即时执行。 <br><br> 描述的技术包括： <br><br><ol><li>  osgUtil ::简化器-减少几何中的三角形数量。  simple（）公共方法用于简化模型几何。 <br></li><li>  osgUtil :: SmootingVisitor-法线的计算。  smooth（）方法可用于为模型生成平滑的法线，而不是独立地计算它们并通过法线数组显式设置它们。 <br></li><li>  osgUtil :: TangentSpaceGenerator-为模型顶点生成切线基础向量。 它通过调用generate（）方法启动，并保存getTangentArray（），getNormalArray（）和getBinormalArray（）方法返回的结果。 在GLSL中编写着色器时，这些结果可用于各种顶点属性。 <br></li><li>  osgUtil :: Tesselator-执行多边形网格的细分-将复杂的图元拆分为一系列简单的图元（retesselatePolygons（）方法） <br></li><li>  osgUtil :: TriStripVisitor-将几何表面转换成一组三角形的面，从而可以有效地消耗内存进行渲染。  stripify（）方法基于GL_TRIANGLE_STRIP集将一组模型图元转换为几何。 <br></li></ol><br> 所有方法都将对象的几何图形作为osg :: Geometry＆link传递的参数，例如 <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; tsv.stripify(*geom);</code> </pre><br> 其中geom指的是智能指针描述的几何实例。 <br><br>  osg :: Simplifier，osg :: SmoothingVisitor和osg :: TriStripVisitor类可以直接与场景图中的节点一起使用 <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; node-&gt;accept(tsv);</code> </pre><br>  accept（）方法处理所有子节点，直到将指定的操作应用于存储在osg :: Geode类型的节点中的场景树此部分的所有终端节点为止。 <br><br> 让我们在实践中尝试镶嵌技术。 <br><br><div class="spoiler">  <b class="spoiler_title">完整的镶嵌器示例代码</b> <div class="spoiler_text">  <strong>主文件</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/Tessellator&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    ----- | _| | |_ | | ----- */</span></span></span><span class="hljs-meta"> osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); // 0 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 0.0f) ); // 1 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 1.0f) ); // 2 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.0f) ); // 3 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 2.0f) ); // 4 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 2.0f) ); // 5 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 3.0f) ); // 6 vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 3.0f) ); // 7 osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;setNormalArray(normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); geom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_POLYGON, 0, 8)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br> 在此示例中，基于顶点的空间位置，我们看到我们正在尝试使用GL_POLYGON类型的一个面的生成来创建八个顶点的非凸多边形。 此示例的组装和执行表明，我们预期的结果不起作用-该示例显示不正确 <br><br><img src="https://habrastorage.org/webt/yb/d3/0f/ybd30fn9fa9duvxedfyb6igt3ui.png"><br><br> 要解决此问题，必须在将构造的几何体传递给查看器之前对其进行细分。 <br><br><pre> <code class="cpp hljs">osgUtil::Tessellator ts; ts.retessellatePolygons(*geom);</code> </pre><br> 之后我们得到正确的结果 <br><br><img src="https://habrastorage.org/webt/p7/wj/fa/p7wjfanogrvkbdxksemk5li_vdi.png"><br><br> 如何运作？ 如果未使用正确的细分，则不会显示非凸多边形，因为寻求优化性能的OpenGL会将其视为简单的凸多边形，或者将其忽略，这可能会带来完全出乎意料的结果。 <br><br>  osgUtil :: Tessellator类使用算法将凸多边形转换为一系列非凸多边形-在我们的示例中，它将几何转换为GL_TRIANGLE_STRIP。 <br><br><img src="https://habrastorage.org/webt/05/ho/do/05hodotfc4iltbsnlyevejuhvfw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此类可以处理孔多边形和自相交多边形。使用公共setWindingType（）方法，可以定义各种处理规则，例如GLU_TESS_WINDING_ODD或GLU_TESS_WINDING_NONZERO，它们指定复杂多边形的内部和外部区域。</font></font><br><br><h1> 结论 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中，我们对OSG引擎中如何存储和处理三维对象的几何有了基本的了解。</font><font style="vertical-align: inherit;">不要认为本文中考虑的那些简单但不太令人印象深刻的示例是引擎功能的限制。</font><font style="vertical-align: inherit;">仅这些示例就可以帮助开发人员了解OpenSceneGraph的机制，如果没有这种了解，就很难想象更复杂的事物的工作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文基于对</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenSceneGraph 3.0</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">书中相应章节的文本的翻译和处理</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">。</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">入门指南</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">所有示例均由我亲自检查，其源代码</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可在此处获取</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待续...</font></font></a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430212/">https://habr.com/ru/post/zh-CN430212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430202/index.html">使用DirectX 11在C ++中编写成对相互作用的粒子系统</a></li>
<li><a href="../zh-CN430204/index.html">麻省理工学院的课程“计算机系统安全”。 讲座18：“私人互联网浏览”，第1部分</a></li>
<li><a href="../zh-CN430206/index.html">麻省理工学院的课程“计算机系统安全”。 第18课：私人浏览Internet，第2部分</a></li>
<li><a href="../zh-CN430208/index.html">麻省理工学院的课程“计算机系统安全”。 讲座18：“私人互联网浏览”，第3部分</a></li>
<li><a href="../zh-CN430210/index.html">Check Point安全学院测试我的耐心</a></li>
<li><a href="../zh-CN430216/index.html">据我了解，我吃了很多甜食，或者按申请中的支票分类商品</a></li>
<li><a href="../zh-CN430218/index.html">能源优化STM32：实用指南</a></li>
<li><a href="../zh-CN430220/index.html">如何将“百年纪念” USB集线器变成智能托管并节省300美元</a></li>
<li><a href="../zh-CN430222/index.html">寻找工作的高级工程师。 我如何接受20次人力资源采访以​​及对此的看法</a></li>
<li><a href="../zh-CN430224/index.html">精神分裂症：内在外观</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>