<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèΩ üßúüèΩ ‚òùüèΩ Asynchrone Programmierung - asynchrone Leistung: Verstehen Sie die Kosten der asynchronen Programmierung und warten Sie ‚ò†Ô∏è üê® üßúüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist ziemlich alt, hat aber seine Relevanz nicht verloren. Wenn es um Async / Warten geht, wird normalerweise ein Link dazu angezeigt. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchrone Programmierung - asynchrone Leistung: Verstehen Sie die Kosten der asynchronen Programmierung und warten Sie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458332/"><p>  Dieser Artikel ist ziemlich alt, hat aber seine Relevanz nicht verloren.  Wenn es um Async / Warten geht, wird normalerweise ein Link dazu angezeigt.  Ich konnte keine √úbersetzung ins Russische finden und beschloss, jemandem zu helfen, der nicht flie√üend ist. </p><br><hr><br><p> Asynchrone Programmierung ist seit langem das K√∂nigreich der erfahrensten Entwickler mit einem Verlangen nach Masochismus - diejenigen, die genug Freizeit, Neigung und psychische F√§higkeit hatten, um R√ºckrufe von R√ºckrufen in einem nichtlinearen Ablauf der Ausf√ºhrung zu betrachten.  Mit dem Aufkommen von Microsoft .NET Framework 4.5 haben uns C # und Visual Basic alle Asynchronit√§t gebracht, sodass blo√üe Sterbliche jetzt fast so einfach asynchrone Methoden schreiben k√∂nnen wie synchrone.  R√ºckrufe werden nicht mehr ben√∂tigt.  Kein explizites Marshalling von Code von einem Synchronisationskontext zum anderen.  Machen Sie sich keine Sorgen mehr dar√ºber, wie sich Ausf√ºhrungsergebnisse oder Ausnahmen verschieben.  Es sind keine Tricks erforderlich, die die Mittel der Programmiersprachen verzerren, um asynchronen Code zu entwickeln.  Kurz gesagt, es gibt keine Probleme und Kopfschmerzen mehr. </p><a name="habracut"></a><br><p>  Obwohl es jetzt einfach ist, asynchrone Methoden zu schreiben (siehe die Artikel von Eric Lippert und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mads Torgersen</a> in diesem <em>MSDN-Magazin [OKTOBER 2011]</em> ), ist Verst√§ndnis erforderlich, um dies korrekt zu tun. Was passiert unter der Haube?  Jedes Mal, wenn eine Sprache oder Bibliothek den Abstraktionsgrad erh√∂ht, den ein Entwickler verwenden kann, geht dies unweigerlich mit versteckten Kosten einher, die die Produktivit√§t verringern.  In vielen F√§llen sind diese Kosten vernachl√§ssigbar, so dass sie in den meisten F√§llen von den meisten Programmierern vernachl√§ssigt werden k√∂nnen.  Fortgeschrittene Entwickler sollten jedoch vollst√§ndig verstehen, welche Kosten anfallen, um die erforderlichen Ma√ünahmen zu ergreifen und m√∂gliche Probleme zu l√∂sen, wenn sie sich manifestieren.  Dies ist erforderlich, wenn asynchrone Programmiertools in C # und Visual Basic verwendet werden. </p><br><p>  In diesem Artikel werde ich die Ein- und Ausgaben von asynchronen Methoden beschreiben, beschreiben, wie asynchrone Methoden implementiert werden, und einige der geringeren Kosten diskutieren.  Beachten Sie, dass dies keine Empfehlung ist, lesbaren Code im Namen der Mikrooptimierung und Leistung in etwas zu verzerren, das schwer zu warten ist.  Dies ist nur das Wissen, das bei der Diagnose von Problemen hilft, auf das Sie m√∂glicherweise sto√üen, und eine Reihe von Tools, um diese Probleme zu √ºberwinden.  Dar√ºber hinaus basiert dieser Artikel auf der Vorschau von .NET Framework Version 4.5, und wahrscheinlich k√∂nnen sich die spezifischen Implementierungsdetails in der endg√ºltigen Version √§ndern. </p><br><h4 id="poluchit-udobnuyu-model-myshleniya">  Holen Sie sich ein komfortables Denkmodell </h4><br><p>  Seit Jahrzehnten verwenden Programmierer die Programmiersprachen C #, Visual Basic, F # und C ++ auf hoher Ebene, um produktive Anwendungen zu entwickeln.  Diese Erfahrung erm√∂glichte es Programmierern, die Kosten verschiedener Vorg√§nge zu bewerten und Kenntnisse √ºber die besten Entwicklungstechniken zu erlangen.  In den meisten F√§llen ist das Aufrufen einer synchronen Methode beispielsweise relativ wirtschaftlich, insbesondere wenn der Compiler den Inhalt der aufgerufenen Methode direkt in den Aufrufpunkt einbetten kann.  Daher sind Entwickler daran gew√∂hnt, den Code in kleine, einfach zu wartende Methoden zu unterteilen, ohne sich √ºber die negativen Folgen einer Erh√∂hung der Anzahl der Aufrufe Gedanken machen zu m√ºssen.  Das Denkmodell dieser Programmierer ist f√ºr die Verarbeitung von Methodenaufrufen ausgelegt. </p><br><p>  Mit dem Aufkommen asynchroner Methoden ist ein neues Denkmodell erforderlich.  C # und Visual Basic mit ihren Compilern k√∂nnen die Illusion erzeugen, dass die asynchrone Methode als synchrones Gegenst√ºck fungiert, obwohl innen alles v√∂llig falsch ist.  Der Compiler generiert eine gro√üe Menge an Code f√ºr den Programmierer, √§hnlich der Standardvorlage, die die Entwickler geschrieben haben, um die Asynchronit√§t zu unterst√ºtzen, als dies von Hand erforderlich war.  Dar√ºber hinaus enth√§lt der vom Compiler generierte Code Aufrufe der Bibliotheksfunktionen von .NET Framework, wodurch der Arbeitsaufwand f√ºr einen Programmierer weiter reduziert wird.  Um das richtige Denkmodell zu haben und damit fundierte Entscheidungen zu treffen, ist es wichtig zu verstehen, was der Compiler f√ºr Sie generiert. </p><br><h4 id="bolshe-razmer-metodov-menshe-vyzovov">  Mehr Methoden, weniger Aufrufe </h4><br><p>  Wenn Sie mit synchronem Code arbeiten, ist das Ausf√ºhren von Methoden mit leerem Inhalt praktisch wertlos.  Bei asynchronen Methoden ist dies nicht der Fall.  Betrachten Sie diese asynchrone Methode, die aus einer Anweisung besteht (und die aufgrund fehlender Anweisungen zum Warten synchron ausgef√ºhrt wird): </p><br><pre><code class="plaintext hljs">public static async Task SimpleBodyAsync() { Console.WriteLine("Hello, Async World!"); }</code> </pre> <br><p>  Ein Intermediate Language Decompiler (IL) zeigt nach der Kompilierung den wahren Inhalt dieser Funktion an und gibt etwas √Ñhnliches wie in Abbildung 1 aus. Aus einem einfachen Einzeiler wurden zwei Methoden, von denen eine zur Hilfsklasse der Zustandsmaschine geh√∂rt.  Die erste ist eine Stub-Methode, die eine √§hnliche Signatur wie die vom Programmierer geschriebene hat (diese Methode hat denselben Namen, denselben Bereich, dieselben Parameter und denselben Typ), enth√§lt jedoch keinen vom Programmierer geschriebenen Code.  Es enth√§lt nur eine Standard-Heizplatte f√ºr die Ersteinrichtung.  Der anf√§ngliche Setup-Code initialisiert die Zustandsmaschine, die zur Darstellung der asynchronen Methode ben√∂tigt wird, und startet sie mit einem Aufruf der Dienstprogrammmethode MoveNext.  Der Objekttyp der Zustandsmaschine enth√§lt eine Variable mit dem Ausf√ºhrungsstatus der asynchronen Methode, sodass Sie diese beim Umschalten zwischen asynchronen Wartepunkten speichern k√∂nnen.  Es enth√§lt auch Code, der von einem Programmierer geschrieben wurde und ge√§ndert wurde, um die √úbertragung von Ausf√ºhrungsergebnissen und Ausnahmen an das zur√ºckgegebene Task-Objekt sicherzustellen.  Halten der aktuellen Position in der Methode, damit die Ausf√ºhrung von dieser Position nach Wiederaufnahme usw. fortgesetzt werden kann. </p><br><p>  <strong>Abbildung 1</strong> Asynchrone Methodenvorlage </p><br><pre> <code class="plaintext hljs">[DebuggerStepThrough] public static Task SimpleBodyAsync() { &lt;SimpleBodyAsync&gt;d__0 d__ = new &lt;SimpleBodyAsync&gt;d__0(); d__.&lt;&gt;t__builder = AsyncTaskMethodBuilder.Create(); d__.MoveNext(); return d__.&lt;&gt;t__builder.Task; } [CompilerGenerated] [StructLayout(LayoutKind.Sequential)] private struct &lt;SimpleBodyAsync&gt;d__0 : &lt;&gt;t__IStateMachine { private int &lt;&gt;1__state; public AsyncTaskMethodBuilder &lt;&gt;t__builder; public Action &lt;&gt;t__MoveNextDelegate; public void MoveNext() { try { if (this.&lt;&gt;1__state == -1) return; Console.WriteLine("Hello, Async World!"); } catch (Exception e) { this.&lt;&gt;1__state = -1; this.&lt;&gt;t__builder.SetException(e); return; } this.&lt;&gt;1__state = -1; this.&lt;&gt;t__builder.SetResult(); } ... }</code> </pre> <br><p>  Wenn Sie sich fragen, wie viel Aufrufe von asynchronen Methoden kosten, denken Sie an dieses Muster.  Der try / catch-Block in der MoveNext-Methode wird ben√∂tigt, um einen m√∂glichen Versuch zu verhindern, diese JIT-Methode durch den Compiler einzubetten, sodass zumindest die Kosten f√ºr den Aufruf der Methode anfallen, w√§hrend dies bei Verwendung der synchronen Methode h√∂chstwahrscheinlich nicht der Fall ist (vorausgesetzt, dass dies nicht der Fall ist) minimalistischer Inhalt).  Wir werden mehrere Aufrufe von Framework-Prozeduren erhalten (z. B. SetResult).  Sowie mehrere Schreibvorg√§nge in den Feldern des Zustandsmaschinenobjekts.  Nat√ºrlich m√ºssen wir all diese Kosten mit den Kosten von Console.WriteLine vergleichen, die wahrscheinlich vorherrschen (einschlie√ülich der Kosten f√ºr Sperren, E / A usw.). Achten Sie auf die Optimierungen, die die Umgebung f√ºr Sie vornimmt.  Beispielsweise wird ein Objekt einer Zustandsmaschine als Struktur (Struktur) implementiert.  Diese Struktur wird nur dann in einem verwalteten Heap gespeichert, wenn die Methode die Ausf√ºhrung anhalten und auf den Abschluss des Vorgangs warten muss. Dies wird bei dieser einfachen Methode niemals der Fall sein.  Das Muster dieser asynchronen Methode erfordert also keine Speicherzuweisung vom Heap.  Der Compiler und die Laufzeit versuchen, die Anzahl der Speicherzuweisungsvorg√§nge zu minimieren. </p><br><h4 id="kogda-ne-nuzhno-ispolzovat-async">  Wann sollte Async nicht verwendet werden? </h4><br><p>  Das .NET Framework versucht, mithilfe verschiedener Optimierungsmethoden effiziente Implementierungen f√ºr asynchrone Methoden zu generieren.  Aufgrund ihrer Erfahrung wenden Entwickler jedoch h√§ufig ihre Optimierungsmethoden an, die f√ºr die Automatisierung durch den Compiler und die Laufzeit riskant und unpraktisch sein k√∂nnen, da sie versuchen, universelle Ans√§tze zu verwenden.  Wenn Sie es nicht vergessen, ist die Ablehnung der Verwendung von asynchronen Methoden in einer Reihe von speziellen F√§llen von Vorteil, insbesondere f√ºr Methoden in Bibliotheken, die mit feineren Einstellungen verwendet werden k√∂nnen.  Normalerweise geschieht dies, wenn bekannt ist, dass die Methode synchron ausgef√ºhrt werden kann, da die Daten, von denen sie abh√§ngt, bereits bereit sind. </p><br><p>  Beim Erstellen asynchroner Methoden haben .NET Framework-Entwickler viel Zeit damit verbracht, die Anzahl der Speicherverwaltungsvorg√§nge zu optimieren.  Dies ist erforderlich, da die Speicherverwaltung die gr√∂√üten Kosten f√ºr die Leistung einer asynchronen Infrastruktur verursacht.  Die Zuweisung von Speicher f√ºr ein Objekt ist normalerweise relativ kosteng√ºnstig.  Das Zuweisen von Speicher f√ºr Objekte √§hnelt dem Bef√ºllen des Einkaufswagens mit Produkten im Supermarkt. Sie geben nichts aus, wenn Sie sie in den Einkaufswagen legen.  Ausgaben entstehen, wenn Sie an der Kasse bezahlen, Ihre Brieftasche herausnehmen und anst√§ndiges Geld geben.  Wenn die Speicherzuweisung einfach ist, kann die nachfolgende Speicherbereinigung die Anwendungsleistung erheblich beeintr√§chtigen.  Wenn Sie mit der Speicherbereinigung beginnen, werden Objekte gescannt und markiert, die sich derzeit im Speicher befinden, aber keine Verkn√ºpfungen haben.  Je mehr Objekte platziert werden, desto l√§nger dauert das Markieren.  Je gr√∂√üer die Anzahl der platzierten Objekte ist, desto h√§ufiger ist eine Speicherbereinigung erforderlich.  Dieser Aspekt der Arbeit mit dem Speicher hat globale Auswirkungen auf das System: Je mehr M√ºll durch asynchrone Methoden erzeugt wird, desto langsamer wird die Anwendung ausgef√ºhrt, auch wenn Mikrotests keine signifikanten Kosten f√ºr ihre Leistung aufweisen. </p><br><p>  Bei asynchronen Methoden, die ihre Ausf√ºhrung unterbrechen (auf Daten warten, die noch nicht bereit sind), muss die Umgebung ein Objekt vom Typ Task erstellen, das von der Methode zur√ºckgegeben wird, da dieses Objekt als eindeutige Referenz auf den Aufruf dient.  Oft k√∂nnen jedoch asynchrone Methodenaufrufe ohne Unterbrechung durchgef√ºhrt werden.  Anschlie√üend kann die Laufzeit das zuvor abgeschlossene Task-Objekt aus dem Cache zur√ºckgeben, das immer wieder verwendet wird, ohne dass neue Task-Objekte erstellt werden m√ºssen.  Dies ist zwar nur unter bestimmten Bedingungen zul√§ssig, z. B. wenn die asynchrone Methode ein nicht universelles (nicht generisches) Objekt Task, Task zur√ºckgibt oder wenn die universelle Task durch einen Referenztyp TResult angegeben wird und null von der Methode zur√ºckgegeben wird.  Obwohl die Liste dieser Bedingungen im Laufe der Zeit erweitert wird, ist es immer noch besser, wenn Sie wissen, wie der Vorgang implementiert wird. <br></p><p>  Betrachten Sie eine Implementierung wie MemoryStream.  MemoryStream wird von Stream geerbt und definiert neue in .NET 4.5 implementierte Methoden neu: ReadAsync, WriteAsync und FlushAsync, um eine speicherspezifische Codeoptimierung bereitzustellen.  Da die Leseoperation aus einem im Speicher befindlichen Puffer ausgef√ºhrt wird, dh tats√§chlich eine Kopie des Speicherbereichs ist, ist die beste Leistung zu erzielen, wenn ReadAsync im synchronen Modus ausgef√ºhrt wird.  Eine Implementierung in einer asynchronen Methode k√∂nnte folgenderma√üen aussehen: </p><br><pre> <code class="plaintext hljs">public override async Task&lt;int&gt; ReadAsync(byte [] buffer, int offset, int count, CancellationToken cancellationToken) { cancellationToken.ThrowIfCancellationRequested(); return this.Read(buffer, offset, count); }</code> </pre> <br><p>  Einfach genug.  Und da Read ein synchroner Aufruf ist und die Methode keine Warteanweisungen zur Steuerung der Erwartungen hat, werden alle Aufrufe dieses ReadAsync tats√§chlich synchron ausgef√ºhrt.  Betrachten wir nun einen Standardfall f√ºr die Verwendung von Threads, beispielsweise eine Kopieroperation: </p><br><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead); }</code> </pre> <br><p>  Beachten Sie, dass im angegebenen ReadAsync-Beispiel der Quelldatenstrom immer mit demselben Pufferl√§ngenparameter aufgerufen wird. Dies bedeutet, dass der R√ºckgabewert (die Anzahl der gelesenen Bytes) sehr wahrscheinlich ebenfalls wiederholt wird.  Au√üer in einigen seltenen F√§llen ist es unwahrscheinlich, dass bei der Implementierung von ReadAsync das zwischengespeicherte Task-Objekt als R√ºckgabewert verwendet wird. Sie k√∂nnen dies jedoch tun. </p><br><p>  Betrachten Sie eine andere Implementierungsoption f√ºr diese Methode (siehe Abbildung 2). Durch die Vorteile der inh√§renten Aspekte in Standardskripten f√ºr diese Methode k√∂nnen wir die Implementierung optimieren, indem wir Speicherzuweisungsvorg√§nge ausschlie√üen, die zur Laufzeit wahrscheinlich nicht zu erwarten sind.  Wir k√∂nnen Speicherverlust vollst√§ndig beseitigen, indem wir dasselbe Task-Objekt zur√ºckgeben, das im vorherigen ReadAsync-Aufruf verwendet wurde, wenn dieselbe Anzahl von Bytes gelesen wurde.  Und f√ºr eine solche Operation auf niedriger Ebene, die wahrscheinlich sehr schnell ist und wiederholt aufgerufen wird, hat diese Optimierung erhebliche Auswirkungen, insbesondere auf die Anzahl der Speicherbereinigungen. </p><br><p>  <strong>Abbildung 2</strong> Optimierung der Aufgabenerstellung </p><br><pre> <code class="plaintext hljs">private Task&lt;int&gt; m_lastTask; public override Task&lt;int&gt; ReadAsync(byte [] buffer, int offset, int count, CancellationToken cancellationToken) { if (cancellationToken.IsCancellationRequested) { var tcs = new TaskCompletionSource&lt;int&gt;(); tcs.SetCanceled(); return tcs.Task; } try { int numRead = this.Read(buffer, offset, count); return m_lastTask != null &amp;&amp; numRead == m_lastTask.Result ? m_lastTask : (m_lastTask = Task.FromResult(numRead)); } catch(Exception e) { var tcs = new TaskCompletionSource&lt;int&gt;(); tcs.SetException(e); return tcs.Task; } }</code> </pre> <br><p>  Eine √§hnliche Optimierungsmethode durch Eliminieren der unn√∂tigen Erstellung von Task-Objekten kann verwendet werden, wenn Caching erforderlich ist.  Stellen Sie sich eine Methode vor, mit der der Inhalt einer Webseite abgerufen und zur sp√§teren Bezugnahme zwischengespeichert werden kann.  Als asynchrone Methode kann dies wie folgt geschrieben werden (unter Verwendung der neuen System.Net.Http.dll-Bibliothek f√ºr .NET 4.5): </p><br><pre> <code class="plaintext hljs">private static ConcurrentDictionary&lt;string,string&gt; s_urlToContents; public static async Task&lt;string&gt; GetContentsAsync(string url) { string contents; if (!s_urlToContents.TryGetValue(url, out contents)) { var response = await new HttpClient().GetAsync(url); contents = response.EnsureSuccessStatusCode().Content.ReadAsString(); s_urlToContents.TryAdd(url, contents); } return contents; }</code> </pre> <br><p>  Dies ist eine Stirnimplementierung.  Bei GetContentsAsync-Aufrufen, bei denen keine Daten im Cache gefunden werden, kann der Aufwand f√ºr das Erstellen eines neuen Task-Objekts im Vergleich zu den Kosten f√ºr den Empfang von Daten √ºber das Netzwerk vernachl√§ssigt werden.  Wenn Sie jedoch Daten aus dem Cache abrufen, werden diese Kosten erheblich, wenn Sie einfach die verf√ºgbaren lokalen Daten einpacken und angeben. <br></p><p>  Um diese Kosten zu eliminieren (falls erforderlich, um eine hohe Leistung zu erzielen), k√∂nnen Sie die Methode wie in Abbildung 3 dargestellt neu schreiben. Jetzt haben wir zwei Methoden: eine synchrone √∂ffentliche Methode und eine asynchrone private Methode, an die die √∂ffentlichen Delegierten delegieren.  Die Dictionary-Sammlung speichert jetzt die erstellten Task-Objekte und nicht deren Inhalt zwischen, sodass zuk√ºnftige Versuche, den Inhalt einer zuvor erfolgreich erhaltenen Seite abzurufen, durch einfachen Zugriff auf die Sammlung ausgef√ºhrt werden k√∂nnen, um das vorhandene Task-Objekt zur√ºckzugeben.  Im Inneren k√∂nnen Sie die ContinueWith-Methoden des Task-Objekts verwenden, mit denen wir das ausgef√ºhrte Objekt in der Sammlung speichern k√∂nnen - falls das Laden der Seite erfolgreich war.  Nat√ºrlich ist dieser Code komplexer und erfordert wie √ºblich viel Entwicklung und Unterst√ºtzung, wenn Sie die Leistung optimieren: Sie m√∂chten keine Zeit damit verbringen, ihn zu schreiben, bis Leistungstests zeigen, dass diese Komplikationen zu seiner Verbesserung f√ºhren, was beeindruckend und offensichtlich ist.  Welche Verbesserungen tats√§chlich von der Art der Anwendung abh√§ngen.  Sie k√∂nnen eine Testsuite erstellen, die h√§ufige Anwendungsf√§lle simuliert, und die Ergebnisse auswerten, um festzustellen, ob das Spiel die Kerze wert ist. </p><br><p>  <strong>Abbildung 3</strong> Manuelles Zwischenspeichern von Aufgaben </p><br><pre> <code class="plaintext hljs">private static ConcurrentDictionary&lt;string,Task&lt;string&gt;&gt; s_urlToContents; public static Task&lt;string&gt; GetContentsAsync(string url) { Task&lt;string&gt; contents; if (!s_urlToContents.TryGetValue(url, out contents)) { contents = GetContentsInternalAsync(url); contents.ContinueWith(delegate { s_urlToContents.TryAdd(url, contents); }, CancellationToken.None, TaskContinuationOptions.OnlyOnRanToCompletion | TaskContinuatOptions.ExecuteSynchronously, TaskScheduler.Default); } return contents; } private static async Task&lt;string&gt; GetContentsInternalAsync(string url) { var response = await new HttpClient().GetAsync(url); return response.EnsureSuccessStatusCode().Content.ReadAsString(); }</code> </pre> <br><p>  Eine andere Optimierungsmethode, die Task-Objekten zugeordnet ist, besteht darin, zu bestimmen, ob ein solches Objekt √ºberhaupt von der asynchronen Methode zur√ºckgegeben werden soll.  Sowohl C # als auch Visual Basic unterst√ºtzen asynchrone Methoden, die einen Nullwert (void) zur√ºckgeben, und sie erstellen √ºberhaupt keine Task-Objekte.  Asynchrone Methoden in Bibliotheken sollten immer Task und Task zur√ºckgeben, da Sie beim Entwerfen einer Bibliothek nicht wissen k√∂nnen, dass sie nicht zum Warten auf den Abschluss verwendet werden.  Bei der Entwicklung von Anwendungen k√∂nnen jedoch Methoden, die void zur√ºckgeben, ihren Platz finden.  Der Hauptgrund f√ºr das Vorhandensein solcher Methoden besteht darin, vorhandene ereignisgesteuerte Umgebungen wie ASP.NET und Windows Presentation Foundation (WPF) bereitzustellen.  Mit async und await erleichtern diese Methoden die Implementierung von Schaltfl√§chenhandlern, Seitenladeereignissen usw.  Wenn Sie eine asynchrone Methode mit void verwenden m√∂chten, gehen Sie vorsichtig mit Ausnahmen um: Ausnahmen werden in jedem SynchronizationContext angezeigt, der zum Zeitpunkt des Aufrufs der Methode aktiv war. <br></p><h4 id="ne-zabyvayte-o-kontekste">  Vergiss den Kontext nicht </h4><br><p>  Es gibt viele verschiedene Kontexte in .NET Framework: LogicalCallContext, SynchronizationContext, HostExecutionContext, SecurityContext, ExecutionContext und andere (ihre gigantische Menge k√∂nnte darauf hindeuten, dass die Ersteller des Frameworks finanziell motiviert waren, neue Kontexte zu erstellen, aber ich wei√ü sicher, dass dies nicht der Fall ist).  Einige dieser Kontexte wirken sich stark auf asynchrone Methoden aus, nicht nur in Bezug auf die Funktionalit√§t, sondern auch in Bezug auf die Leistung. </p><br><p>  <strong>SynchronizationContext</strong> SynchronizationContext spielt f√ºr asynchrone Methoden eine wichtige Rolle.  Ein ‚ÄûSynchronisationskontext‚Äú ist nur eine Abstraktion, um sicherzustellen, dass ein Delegatenaufruf mit den Besonderheiten einer bestimmten Bibliothek oder Umgebung gemarshallt wird.  Beispielsweise verf√ºgt WPF √ºber einen DispatcherSynchronizationContext, der einen Benutzeroberfl√§chenthread f√ºr Dispatcher darstellt: Durch das Senden eines Delegaten an diesen Synchronisationskontext wird dieser Delegat zur Ausf√ºhrung durch den Dispatcher in seinem Thread in die Warteschlange gestellt.  ASP.NET bietet einen AspNetSynchronizationContext, mit dem sichergestellt wird, dass asynchrone Vorg√§nge, die an der Verarbeitung einer ASP.NET-Anforderung beteiligt sind, garantiert nacheinander ausgef√ºhrt werden und an den korrekten HttpContext-Status gebunden sind.  Nun, etc.  Im Allgemeinen gibt es in .NET Framework etwa 10 Spezialisierungen des SynchronizationContext, einige offen, andere intern. </p><br><p>  Wenn Sie auf Aufgaben oder Objekte anderer Typen warten, f√ºr die .NET Framework dies implementieren kann, erfassen Objekte, die auf sie warten (z. B. TaskAwaiter), den aktuellen SynchronizationContext zu dem Zeitpunkt, zu dem das Warten (Warten) beginnt.  Wenn nach Abschluss des Wartens der SynchronizationContext erfasst wurde, wird die Fortsetzung der asynchronen Methode an diesen Synchronisationskontext gesendet.  Aus diesem Grund m√ºssen Programmierer, die asynchrone Methoden schreiben, die vom UI-Stream aufgerufen werden, Aufrufe zum UI-Stream nicht manuell zur√ºckf√ºhren, um die UI-Steuerelemente zu aktualisieren: Das Framework f√ºhrt dieses Marshalling automatisch durch. </p><br><p>  Leider hat dieses Marshalling seinen Preis.  F√ºr Anwendungsentwickler, die wait verwenden, um ihren Kontrollfluss zu implementieren, ist das automatische Marshalling die richtige L√∂sung.  Bibliotheken haben oft eine ganz andere Geschichte.  F√ºr Anwendungsentwickler ist dieses Marshalling haupts√§chlich erforderlich, damit der Code den Kontext steuert, in dem er ausgef√ºhrt wird, z. B. um auf UI-Steuerelemente zuzugreifen oder um auf den HttpContext zuzugreifen, der der erforderlichen ASP.NET-Anforderung entspricht.  Bibliotheken sind jedoch im Allgemeinen nicht erforderlich, um eine solche Anforderung zu erf√ºllen.  Infolgedessen verursacht das automatische Marshalling h√§ufig v√∂llig unn√∂tige zus√§tzliche Kosten.  Schauen wir uns noch einmal den Code an, der Daten von einem Stream in einen anderen kopiert: </p><br><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead); }</code> </pre> <br><p>  Wenn diese Kopie vom UI-Stream aufgerufen wird, erzwingt jede Lese- und Schreiboperation, dass die Ausf√ºhrung zum UI-Stream zur√ºckkehrt.  Im Fall eines Megabytes an Daten in der Quelle und in Streams, die asynchron lesen und schreiben (dh die meisten ihrer Implementierungen), bedeutet dies, dass etwa 500 vom Hintergrund-Stream zum UI-Stream gewechselt werden.  Um dieses Verhalten in den Task- und Task-Typen zu behandeln, wird die ConfigureAwait-Methode erstellt.  Diese Methode akzeptiert den Parameter continueOnCapturedContext eines booleschen Typs, der das Marshalling steuert.  Wenn true (Standardeinstellung), gibt wait automatisch die Kontrolle √ºber den erfassten SynchronizationContext zur√ºck.  Wenn false verwendet wird, wird der Synchronisationskontext ignoriert und die Umgebung f√ºhrt die asynchrone Operation in dem Thread weiter aus, in dem sie unterbrochen wurde.  Durch die Implementierung dieser Logik erhalten Sie eine effizientere Version des Kopiercodes zwischen den Threads: <br></p><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length).ConfigureAwait(false)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead).ConfigureAwait(false); }</code> </pre> <br><p>  F√ºr Bibliotheksentwickler reicht eine solche Beschleunigung aus, um immer √ºber die Verwendung von ConfigureAwait nachzudenken, mit Ausnahme seltener Bedingungen, unter denen die Bibliothek genug √ºber die Laufzeit wei√ü und die Methode mit Zugriff auf den richtigen Kontext ausf√ºhren muss. </p><br><p>  Neben der Leistung gibt es noch einen weiteren Grund, warum Sie ConfigureAwait bei der Entwicklung von Bibliotheken verwenden m√ºssen.  Stellen Sie sich vor, dass die CopyStreamToStreamAsync-Methode, die mit der Version des Codes ohne ConfigureAwait implementiert wurde, beispielsweise aus dem UI-Stream in WPF aufgerufen wird: </p><br><pre> <code class="plaintext hljs">private void button1_Click(object sender, EventArgs args) { Stream src = ‚Ä¶, dst = ‚Ä¶; Task t = CopyStreamToStreamAsync(src, dst); t.Wait(); // deadlock! }</code> </pre> <br><p>  In diesem Fall musste der Programmierer button1_Click als asynchrone Methode schreiben, bei der der Warteoperator die Task ausf√ºhren soll, und nicht die synchrone Wait-Methode dieses Objekts verwenden.  Die Wait-Methode muss in vielen anderen F√§llen verwendet werden, aber es ist fast immer ein Fehler, sie zum Warten in einem UI-Stream zu verwenden, wie hier gezeigt.  Die Wait-Methode wird erst zur√ºckgegeben, wenn die Aufgabe abgeschlossen ist.  Im Fall von CopyStreamToStreamAsync versucht sein asynchroner Stream, die Ausf√ºhrung mit dem Senden von Daten an den erfassten SynchronizationContext zur√ºckzugeben, und kann erst abgeschlossen werden, wenn solche √úbertragungen abgeschlossen sind (da sie erforderlich sind, um den Betrieb fortzusetzen).  Diese Versendungen k√∂nnen jedoch nicht ausgef√ºhrt werden, da der UI-Thread, der sie verarbeiten muss, durch den Wait-Aufruf blockiert wird.  Dies ist eine zyklische Abh√§ngigkeit, die zu einem Deadlock f√ºhrt.  Wenn CopyStreamToStreamAsync mit ConfigureAwait (false) implementiert ist, gibt es keine Abh√§ngigkeit oder Sperre. </p><br><p>  <strong>ExecutionContext</strong> ExecutionContext ist ein wichtiger Bestandteil von .NET Framework, aber die meisten Programmierer sind sich seiner Existenz gl√ºcklicherweise nicht bewusst. ExecutionContext ‚Äì  ,        SecurityContext  LogicalCallContext,   ,         .  ,    ThreadPool.QueueUserWorkItem, Task.Run, Delegate.BeginInvoke, Stream.BeginRead, WebClient.DownloadStringAsync      Framework,    ExecutionContext   ExecutionContext.Run ( ). ,  ,  ThreadPool.QueueUserWorkItem,  Windows  (identity),           WaitCallback.   ,   Task.Run    LogicalCallContext,         LogicalCallContext    Action. ExecutionContext     . </p><br><p>  Framework    ,          ExecutionContext,     ,      .     Windows      LogicalCallContext     .     (WindowsIdentity.Impersonate  CallContext.LogicalSetData)               . </p><br><h4 id="osvobodites-ot-sborki-musora">     </h4><br><p>        .    C#  Visual Basic     ,        .          await.  ,      ,    -   .   C#  Visual Basic  (¬´¬ª)      ,     await  (boxed)  ,     . </p><br><p>                  .   ,     . ,       ,     ,     . </p><br><p>       C#  Visual Basic      ,      . ,     </p><br><pre> <code class="plaintext hljs">public static async Task FooAsync() { var dto = DateTimeOffset.Now; var dt = dto.DateTime; await Task.Yield(); Console.WriteLine(dt); }</code> </pre> <br><p>    dto      await,     .    ,  , -    dto: </p><br><p> <strong>Figure 4</strong>    </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Sequential), CompilerGenerated] private struct &lt;FooAsync&gt;d__0 : &lt;&gt;t__IStateMachine { private int &lt;&gt;1__state; public AsyncTaskMethodBuilder &lt;&gt;t__builder; public Action &lt;&gt;t__MoveNextDelegate; public DateTimeOffset &lt;dto&gt;5__1; public DateTime &lt;dt&gt;5__2; private object &lt;&gt;t__stack; private object &lt;&gt;t__awaiter; public void MoveNext(); [DebuggerHidden] public void &lt;&gt;t__SetMoveNextDelegate(Action param0); }</code> </pre> <br><p>         ,     .   ,     ,  , ,        .       ,        : </p><br><pre> <code class="plaintext hljs">public static async Task FooAsync() { var dt = DateTimeOffset.Now.DateTime; await Task.Yield(); Console.WriteLine(dt); }</code> </pre> <br><p>  ,   .NET (GC)    ,  ,      ,  :      0,  ,    ,     (.NET GC    0, 1  2).      ,    GC        .     ,  ,   ,    ,     ,     ,   .     0,   ,    ,   .   ,     ,         ,    . </p><br><p>                (        ,       ).    JIT   ,        ,               ,        ,      .          ,    ,        .   ,      ,  ,     ,     .   ,          ,     .  ,  C#  Visual Basic        ,       ,     . </p><br><h4 id="izbegayte-slozhnosti">   </h4><br><p>  C#  Visual Basic  ,       awaits:  .   await      ,     Task  ,       ,  . ,   ,      : <br></p><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { return Sum(await a, await b, await c); } private static int Sum(int a, int b, int c) { return a + b + c; }</code> </pre> <br><p>  C#     ‚Äúawait b‚Äù    Sum.      await,       Sum,  -       async ,   ¬´¬ª     await.    ,       await       .   ,  ,       CLR,    ,      ,       .         ,                 &lt;&gt;t__stack.         ,   ,   Tuple&lt;int, int&gt;             &lt;&gt;__stack.  ,     ,    ,          . ,    SumAsync : </p><br><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { int ra = await a; int rb = await b; int rc = await c; return Sum(ra, rb, rc); }</code> </pre> <br><p>            ,   ra, rb  rc,    .  ,    :                   .          ,           ,        ,    .  ,           ,    ,       ,          . </p><br><p> ,        ,        .      Sum   ,    await   ,       .     ,    await   ,  .      await  ,      Task.WhenAll: </p><br><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { int [] results = await Task.WhenAll(a, b, c); return Sum(results[0], results[1], results[2]); }</code> </pre> <br><p>  Task.WhenAll  Task&lt;TResult[]&gt;,    ,       ,     ,       .           .     ,         WhenAll,    Task  Task.        ,          ,    ,   ,   ,    WhenAll ,    .         WhenAll,     , ,   params,       .    ,  ,         .   Figure 5 <br></p><p> <strong>Figure 5</strong>     </p><br><pre> <code class="plaintext hljs">public static Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { return (a.Status == TaskStatus.RanToCompletion &amp;&amp; b.Status == TaskStatus.RanToCompletion &amp;&amp; c.Status == TaskStatus.RanToCompletion) ? Task.FromResult(Sum(a.Result, b.Result, c.Result)) : SumAsyncInternal(a, b, c); } private static async Task&lt;int&gt; SumAsyncInternal(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { await Task.WhenAll((Task)a, b, c).ConfigureAwait(false); return Sum(a.Result, b.Result, c.Result); }</code> </pre> <br><h4 id="asinhronnost-i-proizvoditelnost">    </h4><br><p>      ,           .  ,         .            ,            . ,      ,     :      ,      ,      /          ,       .     .NET Framework              ,       .   ,       .NET Framework,     .  ,  ,       Framework,   ,     ,  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458332/">https://habr.com/ru/post/de458332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458316/index.html">Yandex Retro Games Battle 2019 - Entwicklung von Spielen f√ºr ZX Spectrum</a></li>
<li><a href="../de458324/index.html">Alles, was Sie brauchen, um mit Vue.js zu beginnen</a></li>
<li><a href="../de458326/index.html">Yandex √∂ffnet Toloka-Datens√§tze f√ºr Forscher</a></li>
<li><a href="../de458328/index.html">So duplizieren Sie Ziele aus Yandex.Metrica in Google Analytics</a></li>
<li><a href="../de458330/index.html">Der Perfektion sind keine Grenzen gesetzt: Wie neuronale Schnittstellen der Menschheit helfen</a></li>
<li><a href="../de458334/index.html">Kontinuierliche Replikation von altem zu neuem PostgreSQL mit Slony</a></li>
<li><a href="../de458336/index.html">Der gesamte Zyklus der IT-Produktentwicklung anhand des Projektbeispiels: Teamrollen, Kundenaufgaben, Phasen</a></li>
<li><a href="../de458338/index.html">Anwendungssicherheits-Manager. Entwickler oder Sicherheit?</a></li>
<li><a href="../de458342/index.html">Texturierung oder was Sie wissen m√ºssen, um ein Oberfl√§chenk√ºnstler zu werden. Teil 1. Pixel</a></li>
<li><a href="../de458344/index.html">Verwenden von asynchronem Messaging zur Verbesserung der Verf√ºgbarkeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>