<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úã üïµÔ∏è üêú La evoluci√≥n de la arquitectura del sistema de comercio y compensaci√≥n de la Bolsa de Mosc√∫. Parte 2 üîØ üîå üõ•Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta es la continuaci√≥n de una larga historia sobre nuestro camino espinoso para crear un sistema potente y altamente cargado que garantice el funcion...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La evoluci√≥n de la arquitectura del sistema de comercio y compensaci√≥n de la Bolsa de Mosc√∫. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/moex/blog/444302/"><img src="https://habrastorage.org/webt/fj/7h/zk/fj7hzkntltigzuhy-4zrisejpyu.jpeg"><br><br>  Esta es la continuaci√≥n de una larga historia sobre nuestro camino espinoso para crear un sistema potente y altamente cargado que garantice el funcionamiento del intercambio.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La primera parte est√° aqu√≠</a> . <br><a name="habracut"></a><br><h2>  Error misterioso </h2><br>  Despu√©s de numerosas pruebas, se puso en funcionamiento el sistema actualizado de negociaci√≥n y compensaci√≥n, y nos encontramos con un error sobre el cual era correcto escribir una historia de detectives m√≠stica. <br><br>  Poco despu√©s de comenzar en el servidor principal, una de las transacciones se proces√≥ con un error.  Al mismo tiempo, todo estaba en orden en el servidor de respaldo.  ¬°Result√≥ que una simple operaci√≥n matem√°tica de calcular el exponente en el servidor principal dio un resultado negativo de un argumento v√°lido!  Las encuestas continuaron, y en el registro SSE2 encontraron una diferencia en un bit, que es responsable del redondeo cuando se trabaja con n√∫meros de punto flotante. <br><br>  Escribieron una utilidad de prueba simple para calcular el exponente con el conjunto de bits de redondeo.  Result√≥ que en la versi√≥n de RedHat Linux que usamos, hab√≠a un error al trabajar con una funci√≥n matem√°tica cuando se insertaba el bit desafortunado.  Le informamos esto a RedHat, despu√©s de un tiempo recibimos un parche de ellos y lo enrollamos.  El error ya no ocurri√≥, pero no estaba claro de d√≥nde vino este bit.  La <code>fesetround</code> funci√≥n de C fue responsable de ello. Analizamos cuidadosamente nuestro c√≥digo en busca del supuesto error: verificamos todas las situaciones posibles;  consider√≥ todas las funciones que usaban redondeo;  intent√≥ jugar una sesi√≥n fallida;  us√≥ diferentes compiladores con diferentes opciones;  Utilizado an√°lisis est√°tico y din√°mico. <br><br>  No se pudo encontrar la causa del error. <br><br>  Luego comenzaron a verificar el hardware: llevaron a cabo pruebas de carga de los procesadores;  comprob√≥ la RAM;  incluso ejecut√≥ pruebas para un escenario muy poco probable de un error de varios bits en una celda.  De nada sirvi√≥. <br><br>  Al final, se decidieron por teor√≠as del mundo de la f√≠sica de alta energ√≠a: algunas part√≠culas de alta energ√≠a volaron a nuestro centro de datos, atravesaron la pared de la caja, golpearon el procesador y causaron que el pestillo del gatillo se quedara pegado en el mismo bit.  Esta teor√≠a absurda se llamaba "neutrino".  Si est√° lejos de la f√≠sica de part√≠culas elementales: los neutrinos apenas interact√∫an con el mundo exterior, y ciertamente no pueden afectar al procesador. <br><br>  Como no fue posible encontrar la causa de la falla, en caso de que excluyeran al servidor "delincuente" de la operaci√≥n. <br><br>  Despu√©s de un tiempo, comenzamos a mejorar el sistema de espera activa: presentamos las llamadas "reservas c√°lidas" (r√©plicas as√≠ncronas).  Recibieron un flujo de transacciones que pueden estar en diferentes centros de datos, pero c√°lido no admit√≠a la interacci√≥n activa con otros servidores. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61c/4fd/67f/61c4fd67f72a529370bcc7a792ae946e.png"><br><br>  ¬øPor qu√© se hizo esto?  Si el servidor de respaldo falla, el enlace en caliente con el servidor principal se convierte en el nuevo respaldo.  Es decir, despu√©s de una falla, el sistema no permanece hasta el final de la sesi√≥n de negociaci√≥n con un servidor principal. <br><br>  Y cuando la nueva versi√≥n del sistema se prob√≥ y se puso en funcionamiento, nuevamente se produjo un error con un bit de redondeo.  Adem√°s, con el aumento en el n√∫mero de servidores en caliente, el error comenz√≥ a aparecer con m√°s frecuencia.  En este caso, el vendedor no ten√≠a nada que presentar, ya que no hay evidencia concreta. <br><br>  Durante el siguiente an√°lisis de la situaci√≥n, surgi√≥ la teor√≠a de que el problema podr√≠a estar relacionado con el sistema operativo.  Escribimos un programa simple que llama a la funci√≥n <code>fesetround</code> en un bucle sin fin, recuerda el estado actual y lo verifica durante el sue√±o, y esto se hace en muchos hilos competidores.  Una vez seleccionados los par√°metros de suspensi√≥n y la cantidad de subprocesos, comenzamos a reproducir de manera estable el fallo de bits despu√©s de aproximadamente 5 minutos de la utilidad.  Sin embargo, el soporte de Red Hat no pudo reproducirlo.  Las pruebas de nuestros otros servidores mostraron que solo aquellos con ciertos procesadores instalados est√°n afectados por el error.  Al mismo tiempo, la transici√≥n a un nuevo n√∫cleo resolvi√≥ el problema.  Al final, simplemente reemplazamos el sistema operativo, y la verdadera causa del error segu√≠a sin estar clara. <br><br>  Y de repente, el a√±o pasado apareci√≥ un art√≠culo sobre Habr√© " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo encontr√© un error en los procesadores Intel Skylake</a> ".  La situaci√≥n descrita en ella era muy similar a la nuestra, pero el autor avanz√≥ m√°s en la investigaci√≥n y adelant√≥ la teor√≠a de que el error estaba en el microc√≥digo.  Y al actualizar los n√∫cleos de Linux, los fabricantes tambi√©n actualizan el microc√≥digo. <br><br><h2>  Desarrollo posterior del sistema. </h2><br>  Aunque nos deshicimos del error, esta historia nos hizo reconsiderar la arquitectura del sistema nuevamente.  Despu√©s de todo, no est√°bamos protegidos de la repetici√≥n de tales errores. <br><br>  Los siguientes principios formaron la base para futuras mejoras en el sistema de respaldo: <br><br><ul><li>  No puedes confiar en nadie.  Los servidores pueden no funcionar correctamente. </li><li>  Redundancia mayoritaria. </li><li>  Creaci√≥n de consenso.  Como complemento l√≥gico a la redundancia mayoritaria. </li><li>  Las fallas dobles son posibles. </li><li>  Vitalidad.  El nuevo esquema de repuesto din√°mico no deber√≠a ser peor que el anterior.  El comercio deber√≠a ir sin problemas hasta el √∫ltimo servidor. </li><li>  Un ligero aumento en el retraso.  Cualquier tiempo de inactividad conlleva enormes p√©rdidas financieras. </li><li>  M√≠nima interacci√≥n de red para que el retraso sea lo m√°s bajo posible. </li><li>  Seleccione un nuevo servidor maestro en segundos. </li></ul><br>  Ninguna de las soluciones disponibles en el mercado nos conven√≠a, y el protocolo Raft estaba reci√©n en pa√±ales, as√≠ que creamos nuestra propia soluci√≥n. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d50/bc0/73e/d50bc073e4a2bbb805b724d0040b18f9.png"><br><br><h2>  Conectividad de red </h2><br>  Adem√°s del sistema de respaldo, comenzamos a modernizar la conectividad de la red.  El subsistema de E / S era una multitud de procesos que, en la peor forma, afectaban el jitter y el retraso.  Teniendo cientos de procesos que procesan conexiones TCP, nos vimos obligados a cambiar constantemente entre ellos, y en una escala de microsegundos, esta es una operaci√≥n bastante larga.  Pero la peor parte es que cuando un proceso recibi√≥ un paquete para su procesamiento, lo envi√≥ a una cola de SystemV y luego esper√≥ eventos de otra cola de SystemV.  Sin embargo, con una gran cantidad de nodos, la llegada de un nuevo paquete TCP en un proceso y la recepci√≥n de datos en una cola en otro representan dos eventos competitivos para el sistema operativo.  En este caso, si no hay procesadores f√≠sicos disponibles para ambas tareas, se procesar√° uno y el segundo permanecer√° en la cola de espera.  Es imposible predecir las consecuencias. <br><br>  En tales situaciones, puede aplicar el control din√°mico de prioridad del proceso, pero esto requerir√° el uso de llamadas al sistema que requieren muchos recursos.  Como resultado, cambiamos a un subproceso usando el cl√°sico epoll, esto aument√≥ enormemente la velocidad y redujo el tiempo de procesamiento de la transacci√≥n.  Tambi√©n nos deshicimos de ciertos procesos de interacci√≥n de red e interacci√≥n a trav√©s de SystemV, redujimos significativamente el n√∫mero de llamadas al sistema y comenzamos a controlar las prioridades de las operaciones.  Usando solo un subsistema de E / S, fue posible ahorrar aproximadamente 8-17 microsegundos, dependiendo del escenario.  Este esquema de un solo subproceso se ha aplicado sin cambios, una secuencia de epoll con un margen es suficiente para dar servicio a todas las conexiones. <br><br><h2>  Procesamiento de transacciones </h2><br>  La creciente carga en nuestro sistema requiri√≥ la modernizaci√≥n de casi todos sus componentes.  Pero, desafortunadamente, el estancamiento en el aumento de la velocidad del reloj del procesador en los √∫ltimos a√±os ya no nos permiti√≥ escalar los procesos "de frente".  Por lo tanto, decidimos dividir el proceso del Motor en tres niveles, el m√°s cargado de los cuales es el sistema de verificaci√≥n de riesgos, que eval√∫a la disponibilidad de fondos en las cuentas y crea las transacciones.  Pero el dinero puede estar en diferentes monedas, y fue necesario descubrir en qu√© principio dividir el procesamiento de solicitudes. <br><br>  La soluci√≥n l√≥gica es dividir por moneda: un servidor cotiza en d√≥lares, otro en libras y un tercer euro.  Pero si, con tal esquema, se env√≠an dos transacciones para comprar monedas diferentes, entonces habr√° un problema de billeteras no sincronizadas.  Y la sincronizaci√≥n es dif√≠cil y costosa.  Por lo tanto, ser√° correcto fragmentar por separado en las billeteras y por separado en las herramientas.  Por cierto, en la mayor√≠a de los intercambios occidentales, la tarea de verificar los riesgos no es tan aguda como la nuestra, por lo que a menudo esto se hace fuera de l√≠nea.  Necesit√°bamos implementar un cheque en l√≠nea. <br><br>  Vamos a ilustrar con un ejemplo.  El comerciante quiere comprar $ 30, y la solicitud va a validar la transacci√≥n: verificamos si este comerciante tiene permiso para este modo de negociaci√≥n, si tiene los derechos necesarios.  Si todo est√° en orden, la solicitud va al sistema de verificaci√≥n de riesgos, es decir.  verificar la suficiencia de fondos para concluir una transacci√≥n.  Hay una nota de que la cantidad requerida est√° actualmente bloqueada.  Adem√°s, la solicitud se redirige al sistema de negociaci√≥n, que aprueba o no esta transacci√≥n.  Digamos que la transacci√≥n se aprueba, luego el sistema de verificaci√≥n de riesgos observa que el dinero se desbloquea y los rublos se convierten en d√≥lares. <br><br>  En general, el sistema de verificaci√≥n de riesgos contiene algoritmos complejos y realiza una gran cantidad de c√°lculos muy intensivos en recursos, y no solo verifica el "saldo de la cuenta", como podr√≠a parecer a primera vista. <br><br>  Cuando comenzamos a dividir el proceso del motor en niveles, nos encontramos con un problema: el c√≥digo que estaba disponible en ese momento en las etapas de validaci√≥n y verificaci√≥n usaba activamente la misma matriz de datos, lo que requer√≠a reescribir toda la base del c√≥digo.  Como resultado, tomamos prestada una metodolog√≠a para procesar instrucciones de los procesadores modernos: cada uno de ellos se divide en peque√±as etapas y varias acciones se realizan en paralelo en un ciclo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40f/d5b/011/40fd5b0119fef43d909ce33abc898ff8.png"><br><br>  Despu√©s de una peque√±a adaptaci√≥n del c√≥digo, creamos una tuber√≠a para el procesamiento paralelo de transacciones, en la cual la transacci√≥n se dividi√≥ en 4 etapas de la tuber√≠a: interacci√≥n de red, validaci√≥n, ejecuci√≥n y publicaci√≥n del resultado <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd6/90f/55b/dd690f55b9be4e03a50a9ecb3930c746.png"><br><br>  Considera un ejemplo.  Tenemos dos sistemas de procesamiento, serial y paralelo.  Llega la primera transacci√≥n, y en ambos sistemas se valida.  Luego llega la segunda transacci√≥n: en un sistema paralelo, inmediatamente se pone a trabajar, y en un sistema secuencial se pone en cola esperando que la primera transacci√≥n pase por la etapa de procesamiento actual.  Es decir, la principal ventaja de la canalizaci√≥n es que procesamos la cola de transacciones m√°s r√°pido. <br><br>  Entonces tenemos el sistema ASTS +. <br><br>  Es cierto, tambi√©n con los transportadores, no todo es tan suave.  Supongamos que tenemos una transacci√≥n que afecta las matrices de datos en una transacci√≥n vecina, esta es una situaci√≥n t√≠pica para el intercambio.  Dicha transacci√≥n no se puede ejecutar en la tuber√≠a, porque puede afectar a otros.  Esta situaci√≥n se denomina riesgo de datos, y tales transacciones simplemente se procesan por separado: cuando finalizan las transacciones "r√°pidas" en la cola, la tuber√≠a se detiene, el sistema procesa la transacci√≥n "lenta" y luego comienza la tuber√≠a nuevamente.  Afortunadamente, la proporci√≥n de tales transacciones en el flujo total es muy peque√±a, por lo que la tuber√≠a se detiene tan raramente que no afecta el rendimiento general. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e0/131/de5/0e0131de5df810723111aba61853dd77.png"><br><br>  Luego comenzamos a resolver el problema de sincronizar tres hilos de ejecuci√≥n.  Como resultado, naci√≥ un sistema basado en un b√∫fer circular con celdas de tama√±o fijo.  En este sistema, todo est√° sujeto a la velocidad de procesamiento, los datos no se copian. <br><br><ul><li>  Todos los paquetes de red entrantes entran en la etapa de asignaci√≥n. </li><li>  Los colocamos en una matriz y marcamos que est√°n disponibles para la etapa No. 1. </li><li>  Lleg√≥ la segunda transacci√≥n, nuevamente est√° disponible para la etapa No. 1. </li><li>  El primer flujo de procesamiento ve las transacciones disponibles, las procesa y las transfiere a la siguiente etapa del segundo flujo de procesamiento. </li><li>  Luego procesa la primera transacci√≥n y marca la celda correspondiente con la bandera <code>deleted</code> ; ahora est√° disponible para un nuevo uso. </li></ul><br>  Por lo tanto, se procesa toda la cola. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a8/172/d67/3a8172d67dad9c45dc21448dfb74e135.png"><br><br>  El procesamiento de cada etapa requiere unidades o decenas de microsegundos.  Y si utiliza esquemas est√°ndar de sincronizaci√≥n del sistema operativo, perderemos m√°s tiempo en la sincronizaci√≥n misma.  Por lo tanto, comenzamos a usar spinlock.  Sin embargo, este es un tono muy malo en un sistema de tiempo real, y RedHat recomienda encarecidamente no hacerlo, por lo que usamos spinlock durante 100 ms y luego entramos en modo sem√°foro para excluir la posibilidad de un punto muerto. <br><br>  Como resultado, logramos un rendimiento de aproximadamente 8 millones de transacciones por segundo.  Y solo dos meses despu√©s, en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> sobre LMAX Disruptor, vieron una descripci√≥n de un circuito con la misma funcionalidad. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b31/498/732/b31498732113050fe76ed4dee7c9c82e.png"><br><br>  Ahora en una etapa podr√≠a haber varios hilos de ejecuci√≥n.  Todas las transacciones se procesaron a su vez, en el orden recibido.  Como resultado, el rendimiento m√°ximo aument√≥ de 18 mil a 50 mil transacciones por segundo. <br><br><h2>  Sistema de gesti√≥n de riesgos cambiarios </h2><br>  La perfecci√≥n no tiene l√≠mites, y pronto comenzamos a modernizarnos nuevamente: en el marco de ASTS +, comenzamos a transferir sistemas de gesti√≥n de riesgos y operaciones de liquidaci√≥n a componentes aut√≥nomos.  Desarrollamos una arquitectura moderna flexible y un nuevo modelo de riesgo jer√°rquico, probamos siempre que fue posible usar la clase <code>fixed_point</code> lugar de <code>double</code> . <br><br>  Pero inmediatamente surgi√≥ el problema: ¬øc√≥mo sincronizar toda la l√≥gica de negocios que ha estado funcionando durante muchos a√±os y transferirla al nuevo sistema?  Como resultado, la primera versi√≥n del prototipo del nuevo sistema tuvo que ser abandonada.  La segunda versi√≥n, que actualmente est√° trabajando en producci√≥n, se basa en el mismo c√≥digo que funciona tanto en la parte comercial como en la de riesgo.  Durante el desarrollo, lo m√°s dif√≠cil fue hacer que git se fusionara entre las dos versiones.  Nuestro colega Evgeny Mazurenok realiz√≥ esta operaci√≥n todas las semanas y maldijo durante mucho tiempo cada vez. <br><br>  Al seleccionar un nuevo sistema, inmediatamente tuvimos que resolver el problema de interacci√≥n.  Al elegir un bus de datos, era necesario garantizar una fluctuaci√≥n estable y un retraso m√≠nimo.  Para esto, la red InfiniBand RDMA es la m√°s adecuada: el tiempo de procesamiento promedio es 4 veces menor que en las redes Ethernet de 10 G.  Pero la verdadera diferencia estaba en los percentiles: 99 y 99.9. <br><br>  Por supuesto, InfiniBand tiene sus propias dificultades.  Primero, otra API es ibverbs en lugar de sockets.  En segundo lugar, casi no hay soluciones de mensajer√≠a de c√≥digo abierto ampliamente disponibles.  Intentamos hacer nuestro prototipo, pero result√≥ ser muy dif√≠cil, por lo que elegimos una soluci√≥n comercial: Confinity Low Latency Messaging (anteriormente IBM MQ LLM). <br><br>  Entonces surgi√≥ el problema de la separaci√≥n correcta del sistema de riesgo.  Si solo elimina el motor de riesgos y no crea un nodo intermedio, las transacciones de dos fuentes pueden mezclarse. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41c/b59/4c9/41cb594c970d774c5715a43f43d3f29b.png"><br><br>  Las llamadas soluciones de ultra baja latencia tienen un modo de reordenamiento: las transacciones de dos fuentes se pueden organizar en el orden correcto al recibirlas, esto se realiza utilizando un canal separado para intercambiar informaci√≥n sobre la secuencia.  Pero todav√≠a no aplicamos este modo: complica todo el proceso y, en algunas soluciones, no es compatible en absoluto.  Adem√°s, cada transacci√≥n deber√≠a tener asignadas las marcas de tiempo apropiadas, y en nuestro esquema este mecanismo es muy dif√≠cil de implementar correctamente.  Por lo tanto, utilizamos el esquema cl√°sico con el intermediario de mensajes, es decir, con un despachador que distribuye mensajes entre Risk Engine. <br><br>  El segundo problema estaba relacionado con el acceso del cliente: si hay varias puertas de enlace de riesgo, el cliente debe conectarse a cada una de ellas, y para ello deber√° realizar cambios en la capa del cliente.  Quer√≠amos alejarnos de esto en esta etapa, por lo que en el esquema actual de Risk Gateway procesan todo el flujo de datos.  Esto limita severamente el rendimiento m√°ximo, pero simplifica enormemente la integraci√≥n del sistema. <br><br><h2>  Duplicaci√≥n </h2><br>  Nuestro sistema no debe tener un solo punto de falla, es decir, todos los componentes deben estar duplicados, incluido un intermediario de mensajes.  Resolvimos este problema utilizando el sistema CLLM: contiene un cl√∫ster RCMS en el que dos despachadores pueden trabajar en modo maestro-esclavo, y cuando uno falla, el sistema cambia autom√°ticamente al otro. <br><br><h2>  Trabajar con un centro de datos de respaldo </h2><br>  InfiniBand est√° optimizado para funcionar como una red local, es decir, para conectar equipos montados en bastidor, y no hay forma de establecer una red InfiniBand entre dos centros de datos distribuidos geogr√°ficamente.  Por lo tanto, implementamos un puente / despachador que se conecta al almac√©n de mensajes a trav√©s de redes Ethernet regulares y retransmite todas las transacciones a la segunda red IB.  Cuando necesite migrar desde el centro de datos, podemos elegir con qu√© centro de datos trabajar ahora. <br><br><h2>  Resumen </h2><br>  Todo lo anterior no se hizo a la vez, tom√≥ varias iteraciones del desarrollo de una nueva arquitectura.  Creamos el prototipo en un mes, pero tard√≥ m√°s de dos a√±os en finalizar las condiciones de trabajo.  Intentamos lograr el mejor compromiso entre aumentar la duraci√≥n del procesamiento de la transacci√≥n y aumentar la confiabilidad del sistema. <br><br>  Como el sistema se actualiz√≥ en gran medida, implementamos la recuperaci√≥n de datos de dos fuentes independientes.  Si por alg√∫n motivo el almac√©n de mensajes no funciona correctamente, puede tomar el registro de transacciones de una segunda fuente: Risk Engine.  Este principio se respeta en todo el sistema. <br><br>  Entre otras cosas, logramos mantener la API del cliente para que ni los corredores ni nadie m√°s requirieran una alteraci√≥n significativa para la nueva arquitectura.  Tuve que cambiar algunas interfaces, pero no tuve que hacer cambios significativos en el modelo de trabajo. <br><br>  Llamamos a la versi√≥n actual de nuestra plataforma Rebus, como abreviatura de las dos innovaciones m√°s notables en arquitectura, Risk Engine y BUS. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/179/4f2/bf5/1794f2bf5eb87f3ab59df9d9e0d829d8.png"><br><br>  Inicialmente, quer√≠amos resaltar solo la parte de compensaci√≥n, pero el resultado fue un gran sistema distribuido.  Ahora los clientes pueden interactuar con Trading Gateway, con la compensaci√≥n o con ambos a la vez. <br><br>  Lo que finalmente logramos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d4/6e7/d8d/2d46e7d8d73032984b0c5ecb8bc1e9e1.png"><br><br>  Reducido el nivel de retraso.  Con un peque√±o volumen de transacciones, el sistema funciona igual que la versi√≥n anterior, pero al mismo tiempo soporta una carga mucho mayor. <br><br>  La productividad m√°xima aument√≥ de 50 mil a 180 mil transacciones por segundo.  Una nueva corriente de informaci√≥n est√° obstaculizando un mayor crecimiento. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay dos formas de mejorar a√∫n m√°s: la coincidencia de paralelizaci√≥n y el cambio del esquema de trabajo con Gateway. </font><font style="vertical-align: inherit;">Ahora todas las puertas de enlace funcionan de acuerdo con el esquema de replicaci√≥n, que a esta carga deja de funcionar normalmente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al final, puedo dar algunos consejos a aquellos que est√°n desarrollando sistemas empresariales:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prep√°rate para lo peor todo el tiempo. </font><font style="vertical-align: inherit;">Los problemas siempre surgen inesperadamente.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo general, es imposible rehacer la arquitectura r√°pidamente. </font><font style="vertical-align: inherit;">Especialmente si necesita lograr la m√°xima confiabilidad en una variedad de indicadores. </font><font style="vertical-align: inherit;">Cuantos m√°s nodos, m√°s recursos se necesitan para el soporte.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todas las soluciones especiales y patentadas requerir√°n adem√°s recursos para investigaci√≥n, soporte y soporte. </font></font></li><li>          ,      . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444302/">https://habr.com/ru/post/444302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444290/index.html">Los fundamentos de la programaci√≥n reactiva con RxJS. Parte 2. Operadores y tuber√≠as.</a></li>
<li><a href="../444294/index.html">C√≥mo funciona la aviaci√≥n de negocios en Rusia (centros FBO)</a></li>
<li><a href="../444296/index.html">6 recursos y servicios √∫tiles para potenciales emigrantes a los EE. UU., Alemania y Canad√°</a></li>
<li><a href="../444298/index.html">Los cient√≠ficos dicen que pueden remodelar dinosaurios vivos durante 5 a√±os</a></li>
<li><a href="../444300/index.html">La evoluci√≥n de la arquitectura del sistema de comercio y compensaci√≥n de la Bolsa de Mosc√∫. Parte 1</a></li>
<li><a href="../444304/index.html">Huawei y Nutanix anuncian asociaci√≥n con HCI</a></li>
<li><a href="../444306/index.html">Sexo, amor y relaciones a trav√©s del prisma de la arquitectura de microservicios.</a></li>
<li><a href="../444308/index.html">Noticias de la industria del juego (11-18 de marzo de 2019)</a></li>
<li><a href="../444312/index.html">Instale ReactOS desde una memoria USB</a></li>
<li><a href="../444314/index.html">La v√°lvula comienza a combatir las cr√≠ticas negativas en alta mar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>