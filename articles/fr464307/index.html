<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëêüèΩ üíâ üßîüèª Test d'int√©gration de microservices sur Scala üë©üèª‚Äçüè≠ üë©üèæ‚Äç‚öïÔ∏è üßùüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les tests unitaires sont excellents, mais un n'est pas suffisant. Souvent, vous voulez √©galement vous assurer que l'application en cours d'ex√©cution f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Test d'int√©gration de microservices sur Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/464307/">  Les tests unitaires sont excellents, mais un n'est pas suffisant.  Souvent, vous voulez √©galement vous assurer que l'application en cours d'ex√©cution fonctionnera.  Les tests d'int√©gration viennent √† la rescousse.  Il est de plus en plus utilis√© pour tester les services et Docker vous permet de g√©rer facilement votre environnement de test.  Mais, comme toujours, les choses ne sont pas si simples quand il y a beaucoup plus de microservices et de d√©pendances. <br><br>  Yuri Badalyants de RIT ++ a racont√© comment dans 2GIS ils testent un tas d'un grand nombre de services et tout un zoo technologique.  Sous la coupe, la version de ce rapport, compl√©t√©e et mise √† jour sous la supervision attentive de l'orateur: quelles options vous avez essay√©es, ce que vous avez trouv√©, quels probl√®mes vous n'avez pas √† r√©soudre maintenant.  Il s'agira de Docker, de Testcontainers et √©galement de Scala. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zE2sLcIeoZk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√Ä propos du conf√©rencier:</strong> Yuri Badalyants (@ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LMnet</a> ) a commenc√© sa carri√®re en 2011 en tant que d√©veloppeur Web, a travaill√© avec PHP, JavaScript et Java.  Maintenant, il √©crit sur Scala dans 2GIS. <br><br><h2>  Casino </h2><br>  2GIS fournit des cartes de ville et des r√©pertoires d'entreprises depuis 20 ans et nous avons r√©cemment une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nouvelle version</a> avec une carte illimit√©e de la Russie.  Je vais vous parler de l'exp√©rience acquise pendant que je travaillais dans l'√©quipe Casino.  Cette √©quipe intervient dans trois domaines principaux: <br><br><ul><li>  Publicit√© - quels annonceurs afficher, lesquels masquer, lesquels augmenter et comment abaisser la note. </li></ul><br><ul><li>  BigData est li√© √† la publicit√© et √† sa personnalisation, ainsi qu'√† la construction d'analyses et de m√©triques. </li><li>  Crawler est un programme qui recherche des organisations sur Internet pour les ajouter automatiquement √† la base de donn√©es. </li></ul><br>  Ces trois domaines sont les t√¢ches principales qui, √† leur tour, comportent un grand nombre de sous-t√¢ches.  Actuellement, il existe plus de 25 microservices √©crits en Scala.  Il s'agit exclusivement de notre code, mais nous utilisons √©galement des syst√®mes tiers, par exemple, PostgreSQL, Cassandra et Kafka.  Nous stockons les donn√©es dans Hadoop et les traitons dans Spark.  De plus, nous utilisons les m√©thodes d'apprentissage automatique fournies par l'√©quipe Data Science. <br><br>  En cons√©quence, nous avons un grand nombre de services et de microservices, un grand nombre de d√©pendances et, bien s√ªr, tout cela doit √™tre test√© d'une mani√®re ou d'une autre. <br><br>  Bien s√ªr, nous √©crivons des tests unitaires.  Cependant, m√™me si tous les tests sont verts, cela ne signifie pas que tout fonctionne.  Quelque chose peut mal tourner pendant la phase d'int√©gration des composants ou des microservices.  Par cons√©quent, nous √©crivons des tests d'int√©gration. <br><br><h2>  Tests d'int√©gration </h2><br>  Chaque microservice d√©velopp√© par l'√©quipe Casino r√©sout son probl√®me commercial et se trouve dans un r√©f√©rentiel s√©par√© dans GitLab.  Cet article se concentrera sur les tests d'int√©gration au sein d'un tel r√©f√©rentiel (microservice) avec des d√©pendances verrouill√©es, qui est la responsabilit√© des d√©veloppeurs eux-m√™mes.  L'√©quipe QA teste l'interaction des microservices, et je n'aborderai pas ce sujet. <br><br>  Lorsque j'ai rejoint l'√©quipe pour la premi√®re fois, fin 2016, il y avait approximativement le sch√©ma de test d'int√©gration suivant: <br><img src="https://habrastorage.org/webt/ws/fx/0r/wsfx0rhcuvtffigxdhrpmmoizya.png"><br><br><ol><li>  Le d√©veloppeur ins√®re son code dans GIT, apr√®s quoi le code du microservice entre dans TeamCity.  TeamCity commence √† construire du code et √† ex√©cuter des tests. </li><li>  TeamCity prend le fichier de configuration (config) de Chef (un syst√®me de gestion de configuration similaire √† Ansible, uniquement √©crit en Ruby).  Chef sert √©galement √† automatiser le d√©ploiement.  Quand j'ai 100 machines, je ne veux pas aller sur chacune d'elles et installer ce dont j'ai besoin sur SSH, et Chef me permet d'automatiser cela. </li><li>  TeamCity collecte le fichier jar (puisque nous √©crivons dans Scala, l'artefact que nous publions est le jar), puis le programme le charge dans l'environnement CI.  Notre application y est d√©ploy√©e, il y a aussi quelques d√©pendances.  Dans le diagramme, l'une des d√©pendances est repr√©sent√©e comme une base de donn√©es.  Il peut y avoir autant de d√©pendances que possible, et gr√¢ce √† Chef, notre application les conna√Æt et commence √† interagir avec elles. </li><li>  Ensuite, TeamCity lance <strong>SBT</strong> (c'est notre syst√®me de construction o√π la compilation et les tests sont ex√©cut√©s) et ex√©cute les tests eux-m√™mes.  Ils sont relativement similaires aux tests unitaires, mais ils fonctionnent principalement sur ce principe: aller via http √† une adresse sp√©cifique, v√©rifier une m√©thode et voir ce qu'elle renvoie;  ou faites un peu de pr√©paration, puis voyez si ce dont vous avez besoin est revenu. </li></ol><br>  <strong>Que dire d'un tel dispositif?</strong>  Plus important encore, cela fonctionne.  Lorsque tout est configur√©, l'ex√©cution des tests est facile, car ils ressemblent √† des tests unitaires.  Mais les avantages s'arr√™tent l√†. <br><br>  Et les inconv√©nients commencent.  <strong>L'environnement CI est toujours activ√©</strong> , ce qui repr√©sente un gaspillage suppl√©mentaire de ressources.  Puisque Chef est une configuration statique, vous devriez toujours avoir une sorte de machine o√π toutes les d√©pendances seront configur√©es, o√π les applications seront d√©ploy√©es ind√©pendamment.  Une telle machine consommera des ressources suppl√©mentaires, car les tests sont ex√©cut√©s de temps en temps, et la machine doit √™tre pr√™te tout le temps.  De plus, l'environnement CI est inclus avec toutes les d√©pendances. <br><br>  <strong>Il n'est pas possible d'ex√©cuter des tests sur deux branches en m√™me temps</strong> .  Cela d√©coule du paragraphe pr√©c√©dent: comme nous avons un seul environnement, nous ne pouvons tout simplement pas les ex√©cuter en parall√®le. <br><br>  <strong>Il n'est pas possible de tester le d√©marrage, l'arr√™t et le red√©marrage</strong> .  J'expliquerai pourquoi cela est n√©cessaire: toutes nos applications ob√©issent √† la logique du soi-disant <strong>arr√™t gracieux</strong> , c'est-√†-dire que lorsque nous obtenons SIGTERM, nous n'arr√™tons pas le processus au milieu, mais interceptons ce signal et comprenons que nous devons d√©sactiver le programme.  √Ä ce stade, une certaine logique est activ√©e, par exemple, les requ√™tes HTTP qui sont ¬´en cours¬ª sont trait√©es, ou si nous travaillons avec Kafka, nous validons tous les offs - en d'autres termes, nous effectuons certaines actions afin de pouvoir terminer le travail en toute s√©curit√©, et puis, quand tout est fait, √©teignez. <br><br>  Cette logique n'est pas toujours simple, et vous ne pouvez la tester avec un tel sch√©ma que manuellement, car √† partir des tests nous ne contr√¥lons pas le cycle de vie de l'application.  Il s'av√®re que TeamCity a en quelque sorte d√©ploy√© quelque chose via Chef, alors que les tests sont √† un stade diff√©rent et ne savent pas comment l'application est d√©ploy√©e. <br><br>  Le prochain <strong>inconv√©nient</strong> est qu'il est tr√®s <strong>difficile de configurer tout cela localement</strong> .  Autrement dit, il existe de nombreuses d√©pendances, elles ont leurs propres configurations, elles doivent √™tre g√©n√©r√©es sur la machine locale.  L'application elle-m√™me poss√®de √©galement son propre fichier de configuration, dans lequel il existe de nombreuses valeurs.  Les tests eux-m√™mes ont une configuration qui doit √™tre mise en correspondance avec la configuration de l'application, et il peut √©galement y avoir plus d'une valeur de configuration.  Il semble que tout cela ne semble pas si effrayant, comme ¬´aller r√©parer les configurations √† trois endroits¬ª, mais en r√©alit√©, cela peut prendre des heures aux nouveaux employ√©s pour le faire. <br><br><h3>  Docker GitLab CI + </h3><br>  Au fil du temps, ce sch√©ma s'est transform√© en un autre: <strong>GitLab CI</strong> et <strong>Docker</strong> .  Cela ne s'est pas produit parce que le sch√©ma pr√©c√©dent n'√©tait pas id√©al, mais parce que l'entreprise a l√©g√®rement chang√© de cap en termes d'organisation administrative. <br><br>  Auparavant, chaque √©quipe, et nous en avons beaucoup, comme nous le voulions ou comme nous le pouvions, et d√©ployait son travail.  Par exemple, nous avions TeamCity, Chef et d'autres √©quipes pouvaient utiliser Jenkins ou Ansible. <br><br>  Nous nous dirigeons maintenant vers le cloud local et Kubernetes, et il existe une √©quipe distincte qui g√®re tout cela, √† la fois GitLab CI et Kubernetes.  D'autres √©quipes l'utilisent simplement comme un service.  C'est beaucoup plus pratique car vous n'avez pas besoin d'administrer tout cela manuellement. <br><br>  En utilisant Kubernetes, nous avons d√©ploy√© le sch√©ma suivant: <br><img src="https://habrastorage.org/webt/lr/uc/gq/lrucgqg479qcboq4xxwpil0pohq.png"><br><br><ol><li>  Au lieu de TeamCity, Gitlab CI est maintenant utilis√©. </li><li>  GitLab CI cr√©e une image Docker et la d√©ploie sur Kubernetes.  La configuration est d√©sormais stock√©e directement dans le r√©f√©rentiel, et non s√©par√©ment dans Chef, donc pour le d√©ploiement, vous n'avez pas besoin de travailler avec un service de configuration tiers. </li><li>  Les d√©pendances sont soulev√©es √† l'avance, √©galement √† Kubernetes. </li><li>  Ensuite, GitLab CI lance SBT et teste dans une √©tape distincte. </li></ol><br>  Tout est assez similaire au sch√©ma pr√©c√©dent et ne diff√®re pas fondamentalement de celui-ci, c'est-√†-dire que m√™me les avantages et les inconv√©nients seront exactement les m√™mes, mais Docker appara√Æt. <br><br>  Avec docker, vous pouvez faire diff√©rentes choses plus amusantes et l'une d'entre elles est la composition de docker. <br><br><h3>  Docker-compose </h3><br>  Il s'agit d'une sorte de "superposition" sur Docker, qui vous permet d'ex√©cuter plusieurs images de docker en une seule entit√©. <br><br>  Un bon exemple o√π docker-compose aide vraiment est Kafka.  Elle a besoin de ZooKeeper pour fonctionner.  Si vous soulevez Kafka et ZooKeeper sans composition de docker, vous devez soulever s√©par√©ment ZooKeeper dans le docker, s√©par√©ment - Kafka, et garder ces deux conteneurs de docker coh√©rents.  Ce n'est pas tr√®s pratique, et docker-compose vous permet de d√©crire les deux conteneurs dans un seul fichier docker-compose.yml et d'utiliser la simple commande <code>docker-compose run Kafka</code> augmenter Kafka et ZooKeeper. <br><br>  Vous pouvez cr√©er des tests d'int√©gration sur docker-compose.  Voyons √† quoi cela ressemblera. <br><img src="https://habrastorage.org/webt/ae/a9/wn/aea9wn8lh9tdi8ezctgs1hfhkuw.png"><br><br><ol><li>  Encore une fois, poussez tout dans GitLab. </li><li>  GitLab CI lance docker-compose. </li><li>  Dans docker-compose, l'application monte, toutes les d√©pendances et SBT montent, et le SBT conduit les tests pour cette application - tout se passe √† l'int√©rieur de docker-compose. </li></ol><br>  Gr√¢ce √† ce sch√©ma, il n'est pas n√©cessaire de conserver un environnement et des d√©pendances s√©par√©s, car tout va directement au runner GitLab CI, o√π doivent simplement se trouver docker et docker-compose.  Au d√©marrage, il va pomper les images n√©cessaires et les ex√©cuter. <br><br>  De plus, vous pouvez tester diff√©rentes branches en m√™me temps car tout se passe sur le coureur. <br><br>  Il <strong>est</strong> d√©sormais <strong>plus facile de configurer l'</strong> environnement <strong>localement</strong> , mais vous devez toujours coordonner plusieurs endroits.  Le fait est que maintenant, lorsque nous faisons la configuration locale, nous n'avons pas besoin de tout mettre sur la machine locale, tout est √©crit dans le fichier docker-compose.yml.  Ainsi, vous devez configurer √† deux endroits diff√©rents - c'est docker-compose.yml et la configuration de nos tests. <br><br>  En ce qui concerne les inconv√©nients, <strong>il est toujours impossible de tester le d√©marrage, l'arr√™t et le red√©marrage</strong> , car √† partir du SBT, √† partir des tests, nous ne contr√¥lons pas le cycle de vie de l'application.  Il est ex√©cut√© par docker-compose, il ex√©cute SBT et les tests sont ex√©cut√©s √† l'int√©rieur de SBT.  Ainsi, il n'y a pas de gestion compl√®te du cycle de vie de l'application.  Il y a aussi des difficult√©s avec le lancement, dont je voudrais parler davantage. <br><br><h4>  docker-compose 2 </h4><br>  √Ä l'√©poque de docker-compose 2, docker-compose.yml, le fichier ressemblait √† ceci: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'2.1'</span></span> services: web: build: . depends_on: db: condition: service_healthy redis: condition: service_started redis: image: redis db: image: db healthcheck: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>: <span class="hljs-string"><span class="hljs-string">"some test here"</span></span></code> </pre> <br>  Les services sont enregistr√©s ici, c'est-√†-dire ce que nous allons lever dans le cadre de ce docker-compose.  Dans ce cas, je viens de prendre un exemple de la documentation docker-compose.  Il existe trois services: web, redis et db (base de donn√©es). <br><br>  Le Web est notre application, et redis et db sont des d√©pendances. <br><br>  Il y a un √©l√©ment dans le bloc Web appel√© <code>depends_on</code> .  Cela sugg√®re que l'application Web d√©pend de certains autres conteneurs et est d√©crite ci-dessous sur laquelle: √† partir de la base de donn√©es et de redis. <br><br>  Il existe √©galement une clause <code>condition</code> .  Pour redis, il s'agit de <code>service_started</code> , ce qui signifie que jusqu'au d√©marrage de redis, le conteneur n'essaiera pas de d√©marrer l'application Web. <br><br>  Quant √† la base de donn√©es, son √©tat est <code>service_healthy</code> , et le bilan de sant√© est d√©crit ci-dessous.  Autrement dit, nous devons non seulement lancer le conteneur Docker, mais √©galement ex√©cuter un certain contr√¥le de sant√©.  Il peut s'agir de n'importe quelle logique personnalis√©e. <br><br>  Par exemple, nous utilisons PostgreSQL, qui utilise l'extension PostGIS, et il a besoin d'un certain temps pour s'initialiser.  Lorsque nous lan√ßons le conteneur Docker, nous ne pouvons pas travailler imm√©diatement avec l'extension postgis - nous devons attendre que l'extension s'initialise.  Par cons√©quent, nous <code>SELECT PostGIS_Version();</code> simplement <code>SELECT PostGIS_Version();</code> requ√™tes <code>SELECT PostGIS_Version();</code> √† <code>SELECT PostGIS_Version();</code>  .  Jusqu'√† ce que l'extension soit initialis√©e, la requ√™te g√©n√©rera une erreur et lorsque l'extension sera initialis√©e, elle commencera √† renvoyer la version.  C'est tr√®s pratique et logique - <strong>nous allons d'abord augmenter toutes les d√©pendances, puis l'application</strong> . <br><br><h4>  docker-compose 3 </h4><br>  Lorsque docker-compose 3 est sorti, nous avons commenc√© √† l'utiliser. <br><br>  Mais dans la documentation, un √©l√©ment est apparu lors de la modification de la logique depend_on.  Les d√©veloppeurs de dockers ont d√©cid√© qu'une description du graphique de d√©pendance √©tait suffisante.  Cela signifie que lorsque vous lancez la commande <code>docker-compose run web</code> , l'application elle-m√™me et la base de donn√©es dont elle d√©pend d√©marrent simultan√©ment. <br><br><img src="https://habrastorage.org/webt/yp/4_/vy/yp4_vyw7zxudu9naji96akfjeic.png"><br><br>  Le paragraphe suivant de la documentation indique que depend_on n'est plus une condition. <br><br>  Ainsi, si vous souhaitez toujours obtenir la fonctionnalit√© utilis√©e dans la deuxi√®me version, vous devrez tout prendre en main. <br><br>  La page <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contr√¥le de la commande de d√©marrage</a> propose plusieurs solutions.  La premi√®re option consiste √† utiliser <strong>wait-for-it.sh</strong> . <br><br>  Maintenant, docker-compose.yml est un peu diff√©rent: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: web: build: . depends_on: [ db, redis ] redis: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-it.sh"</span></span>, ... ] db: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-db.sh"</span></span>, ... ]</code> </pre> <br>  <code>depends_on</code> est juste un tableau, il n'y a aucune condition. <br><br>  Dans nos d√©pendances, nous red√©finissons la commande, c'est-√†-dire que dans docker-compose, vous pouvez attacher une commande avec laquelle le conteneur docker d√©marre. <br><br>  L√†, nous devrions √©crire wait-for-it.sh, et autre chose.  Au lieu des trois points dans l'exemple ci-dessus, nous devons √©crire ce que nous devons attendre, ainsi que la commande d'origine qui lance le conteneur Docker. <br><br>  Pour ce faire, vous devez trouver le fichier docker, copier la commande pour redis √† partir de l√† et le coller, il en va de m√™me pour la base de donn√©es.  Un √©norme inconv√©nient est que l' <strong>abstraction tombe en panne</strong> - je ne veux pas savoir quelle commande lance le conteneur Docker.  Ces commandes peuvent √™tre non triviales, assez complexes, mais je ne veux pas d√©ranger, je veux juste entrer dans la <code>docker run</code> et c'est tout. <br><br>  Personnellement, je n'aime pas vraiment cette solution, mais nous avions quelques services qui fonctionnent comme √ßa. <br><br><h4>  Script au-dessus de docker-compose </h4><br>  Puis j'ai d√©cid√© que le moment √©tait venu pour la " <strong>construction de</strong> v√©los", et j'ai eu <strong>docker-compose-run.sh</strong> : <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: postgres: ... my_service: depends_on: [ postgres ] ... sbt: depends_on: [ my_service ] ...</code> </pre><br>  Permettez-moi de vous donner un exemple semi-r√©aliste: il y a postgres dans docker-compose.yml, il y a mon_service application, qui d√©pend de postgres, et SBT, dans lequel les tests sont ex√©cut√©s et qui d√©pend de mon service. <br><br>  J'ex√©cute le programme non pas via <code>docker run</code> , mais via le script docker-compose-run.sh. <br><br>  Premi√®rement, cela commence d'abord par la d√©pendance la plus profonde, dans mon cas c'est postgres.  Le script d√©marre la d√©pendance en mode "d√©mon", c'est-√†-dire qu'il ne bloque pas le terminal: <br><br><pre> <code class="bash hljs">docker-compose up -d postgres</code> </pre> <br>  J'attends ensuite que la condition soit satisfaite par la fonction wait_until.  C'est presque la m√™me chose que wait-for-it.sh, seulement, pour ainsi dire, dans un style imp√©ratif.  Pendant l'initialisation de PostGIS, le terminal est bloqu√©, c'est-√†-dire que le programme attend √©galement, et s'il n'attend pas, une erreur est g√©n√©r√©e et les tests cessent de fonctionner. <br><br><pre> <code class="bash hljs">wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T postgres psql</code> </pre> <br>  Lorsque PostGIS est initialis√©, passez √† l'√©tape suivante et faites de m√™me avec le service.  Pour lui, le test est un peu plus simple: le port 80 doit √™tre li√©. <br><br><pre> <code class="bash hljs">docker-compose up -d my_service wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T \ my_service sh -c <span class="hljs-string"><span class="hljs-string">"netstat -ntlp | grep 80 || exit 1"</span></span></code> </pre> <br>  La derni√®re √©tape consiste √† ex√©cuter SBT via la commande run, dans laquelle les tests sont ex√©cut√©s. <br><br><pre> <code class="bash hljs">docker-compose run sbt down $?</code> </pre> <br>  Ainsi, tout est relev√© dans le bon ordre, mais manuellement. <br><br>  √Ä la fin, la fonction <code>down</code> est appel√©e, qui accepte le r√©sultat de la commande pr√©c√©dente.  Si c'est "0", alors les tests ont r√©ussi et nous d√©sactivons simplement docker-compose;  sinon, nous ¬´crachons¬ª d'abord les journaux pour comprendre ce qui n'a pas fonctionn√©, puis nous d√©sactivons la composition par docker. <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> down { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Exiting with code </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$1</span></span> -eq 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> docker-compose logs -t postgres my_service docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> }</code> </pre> <br>  Un tel sch√©ma fonctionne, mais ne s'adapte pas bien.  Chaque service devra d√©crire son docker-compose-run.sh avec sa propre logique.  De plus, la configuration de lancement s'√©tend entre docker-compose-run.sh et docker-compose.yml.  Eh bien, en g√©n√©ral, il semble que nous n'utilisions pas de composition de docker, mais que nous ayons des probl√®mes avec ses lacunes. <br><br><h4>  Ex√©cuter Docker √† partir du code </h4><br>  Lorsque le sch√©ma pr√©c√©dent a √©t√© cr√©√©, j'ai pens√©: si j'ai d√©j√† tout dans le docker, alors pourquoi ne pas l'ex√©cuter √† partir du code.  J'ai commenc√© √† chercher une solution et j'ai trouv√© plusieurs options. <br><br>  La premi√®re option consiste √† simplement <strong>utiliser le client docker</strong> .  Il existe deux principaux clients dockers dans le monde JVM: <strong>docker-java</strong> et <strong>spotify docker-client</strong> . <br><br>  Le client Docker vous permet d'ex√©cuter des commandes Docker directement √† partir du code √† l'aide de l'API.  Autrement dit, au lieu de concat√©ner des cha√Ænes pour cr√©er des commandes comme <code>`docker run ...`</code> , vous pouvez simplement former une telle commande dans le code et l'ex√©cuter.  C'est beaucoup plus pratique. <br><br>  Cette m√©thode fonctionne bien et, bien s√ªr, ils peuvent tout faire, cependant, c'est un niveau tr√®s bas.  Je devrais cr√©er mon propre analogique de composition de docker, ce qui est une tr√®s grosse t√¢che. <br><br>  L'option suivante est la <strong>biblioth√®que docker-it-scala</strong> , qui encapsule ces deux clients et vous permet de choisir le backend √† utiliser.  Elle peut g√©rer les conteneurs dont vous avez besoin. <br><br>  Mais l'inconv√©nient de cette biblioth√®que est qu'elle n'a pas d'API tr√®s flexible et qu'il n'y a pas de contr√¥le du cycle de vie. <br><br>  Je n'aimais pas non plus cette option, j'ai continu√© ma recherche et trouv√© des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Testcontainers</a> .  Je voudrais vous en dire plus √† ce sujet. <br><br><h2>  Conteneurs d'essai </h2><br>  Il s'agit d'une sorte de biblioth√®que java pour lancer et tester des conteneurs Docker.  Il y a une fa√ßade Scala, testcontainers-scala.  Hors de la bo√Æte, il existe un certain nombre de services populaires, par exemple, PostgreSQL, MySQL, Nginx, Kafka, Selenium.  Vous pouvez ex√©cuter n'importe quel autre conteneur.  La biblioth√®que poss√®de une API assez simple et flexible, sur laquelle je m'attarderai plus en d√©tail. <br><br><h3>  Conteneurs pr√©d√©finis </h3><br>  Alors, comment travailler avec des conteneurs pr√©d√©finis, qui sont dans la biblioth√®que: en fait, tout est assez simple, car les conteneurs sont repr√©sent√©s comme des objets: <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) pgContainer.start() val pgUrl: String = pgContainer.jdbcUrl val pgPort: Int = pgContainer.mappedPort(5432) pgContainer.stop()</code> </pre> <br>  Dans ce cas, nous cr√©ons <code>PostgreSQLContainer</code> , nous pouvons le d√©marrer et commencer √† travailler avec.  Ensuite, nous obtenons <code>jbdcUrl</code> , avec lequel vous pouvez vous connecter √† PostgreSQL.  Apr√®s cela, nous obtenons <code>mappedPort</code> . <br><br>  Cela signifie que PostgreSQL sort du port docker 5432, et Testcontainers voit ce port et l'attribue automatiquement √† un port al√©atoire.  Autrement dit, d'apr√®s les tests que nous voyons, par exemple, 32422. L'affectation se produit automatiquement. <br><br><h3>  Conteneur personnalis√© </h3><br>  La vue suivante, le soi-disant conteneur personnalis√©, est √©galement assez simple: <br><br><pre> <code class="bash hljs">class GenericContainer( imageName: String, exposedPorts: Seq[Int] = Seq(), env: Map[String, String] = Map(), <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: Seq[String] = Seq(), classpathResourceMapping: Seq[(String, String, BindMode)] = Seq(), waitStrategy: Option[WaitStrategy] = None ) ...</code> </pre> <br>  Il existe un <code>GenericContainer</code> dont vous devez h√©riter et remplacer un certain nombre de champs.  Assurez-vous de d√©finir uniquement <code>imageName</code> - c'est le nom du conteneur que nous voulons cr√©er. <br><br>  Vous pouvez d√©finir les ports <code>exposedPorts</code> : ces ports que le conteneur d√©passera.  Dans env, vous pouvez d√©finir des variables d'environnement; vous pouvez √©galement d√©finir la <code>command</code> √† ex√©cuter. <br><br>  <code>classpathResourceMapping</code> vous permet de jeter des ressources du classpath dans le conteneur Docker.  C'est tr√®s pratique, par exemple, si la configuration de l'application se trouve directement dans les ressources de test.  Vous mappez simplement √† l'int√©rieur et l'application √† l'int√©rieur de docker a acc√®s √† cette configuration. <br><br>  <code>waitStrategy</code> est une chose tr√®s pratique qui manquait dans docker-compose 3, en fait c'est HealthCheck.  Il existe plusieurs <code>waitStrategy</code> pr√©d√©finies, par exemple, vous pouvez attendre jusqu'√† ce qu'une liaison de port se produise, ou une m√©thode http sp√©cifique renverra 200. Mais vous pouvez √©crire n'importe lequel de vos HealthCheck. <br><br>  Puisque vous √©crivez HealthCheck simplement dans votre code, vous pouvez utiliser, d'une part, une langue normale, pas bash, et, d'autre part, toutes les biblioth√®ques disponibles √† partir de votre code: si vous voulez faire une HealthCheck personnalis√©e dans Cassandra - prenez le pilote et √©crivez tout HealthCheck. <br><br><h3>  Ex√©cution de tests </h3><br>  Et maintenant un peu sur la fa√ßon d'ex√©cuter des tests: <br><br><pre> <code class="bash hljs">class PostgresqlSpec extends FlatSpec with ForAllTestContainer { override val container = PostgreSQLContainer() <span class="hljs-string"><span class="hljs-string">"PostgreSQL container"</span></span> should <span class="hljs-string"><span class="hljs-string">"be started"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { Class.forName(container.driverClassName) val connection = DriverManager .getConnection(container.jdbcUrl, container.username, container.password) // <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> some stuff } }</code> </pre> <br>  Je vais parler de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ScalaTest</a> , la norme de facto pour les tests dans le monde Scala. <br><br>  Par exemple, nous voulons √©crire des tests pour Postgres.  Cr√©ez un test <code>PostgresqlSpec</code> et <code>ForAllTestContainer</code> de <code>ForAllTestContainer</code> .  Il s'agit d'un trait fourni par la biblioth√®que.  Il d√©marrera les conteneurs n√©cessaires avant tous les tests et les arr√™tera apr√®s tous les tests.  Ou vous pouvez utiliser <code>ForeachTestContainer</code> , puis les conteneurs commencent avant chaque test et s'arr√™tent apr√®s chacun d'eux. <br><br>  Ensuite, vous devez red√©finir le conteneur.  Cela peut √™tre fait en rempla√ßant la propri√©t√© du <code>container</code> .  Dans mon cas, j'utilise <code>PostgreSQLContainer</code> . <br><br>  Ensuite, nous √©crivons des tests.  Dans l'exemple, je cr√©e une connexion, prends jdbcUrl, nom d'utilisateur, mot de passe, √©cris des tests sp√©cifiques, envoie des requ√™tes. <br><br>  En r√®gle g√©n√©rale, les tests d'int√©gration n√©cessitent plusieurs conteneurs.  Je peux les cr√©er en utilisant <code>MultipleContainers</code> : <br><br><pre> <code class="bash hljs">val pgContainer = PostgreSQLContainer() val myContainer = MyContainer() override val container = MultipleContainers(pgContainer, myContainer)</code> </pre> <br>  Autrement dit, je cr√©e des conteneurs, je les ajoute √† <code>MultipleContainers</code> et je les utilise comme <code>container</code> . <br><br>  Le sch√©ma d'ex√©cution des tests avec Testcontainers est le suivant: <br><br><img src="https://habrastorage.org/webt/vp/0f/-e/vp0f-ehxlezqapcu3rfq3tqzmeu.jpeg"><br><br><ol><li>  Poussez le code dans GitLa. </li><li>  Le coureur GitLab CI lance SBT. </li><li>  SBT ex√©cute des tests.  A l'int√©rieur des tests, notre application et ses d√©pendances sont lanc√©es. </li></ol><br>  Les avantages de ce sch√©ma: <br><br><ul><li>  Pas besoin de garder un environnement et des d√©pendances s√©par√©s, tout se passe sur le runner. </li><li>  Vous pouvez tester diff√©rentes branches en m√™me temps. </li><li>  Vous pouvez tester le d√©marrage, l'arr√™t et le red√©marrage, car nous pouvons contr√¥ler le cycle de vie de l'application (tout commence directement dans le code de test). </li><li>  Il existe des bilans de sant√© flexibles qui faisaient cruellement d√©faut. </li><li>  Il n'y a pas de fichiers * .sh dans le r√©f√©rentiel, vous pouvez configurer les tests dans l'application aussi facilement que vous le souhaitez. </li><li>  Gr√¢ce au mappage classpathResource, vous pouvez utiliser la m√™me configuration avec les tests et l'application. </li><li>  Vous pouvez configurer des tests √† partir du code. </li><li>  Tout cela s'ex√©cute aussi facilement √† la fois dans CI et localement, car ce ne sont que des tests qui ressemblent et s'ex√©cutent comme des tests unitaires, seul tout monte dans le conteneur Docker. </li></ul><br>  Il s'av√®re que tout est √©trangement lisse et bon, mais ce n'est qu'√† premi√®re vue, en fait, nous avons rencontr√© un certain nombre de probl√®mes. <br><br><h3>  Conteneurs d√©pendants </h3><br>  Le premier probl√®me que nous avons rencontr√© concerne <strong>les conteneurs d√©pendants</strong> .  Disons qu'il existe une sorte de test: <br><br><pre> <code class="bash hljs">class MySpec extends FlatSpec with ForAllTestContainer { val pgCont = PostgreSQLContainer() val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override val container = MultipleContainers(appCont, pgCont) // tests here }</code> </pre> <br>  Il ex√©cute postgres et AppContainer.  L'appContainer de postgres re√ßoit jdbcUrl, le nom d'utilisateur et le mot de passe pour la connexion.  Ensuite, MultipleContainers est cr√©√© et le test lui-m√™me est d√©crit. <br><br>  J'ex√©cute le programme et je vois une erreur: <br><br><pre> <code class="bash hljs">Exception encountered when invoking run on a nested suite - Mapped port can only be obtained after the container is started</code> </pre> <br>  Le fait est que le port attribu√© ne peut pas √™tre pris avant le d√©marrage du conteneur.  Pourquoi cela se produit-il? <br><br>  Le fait est que <code>ForAllTestContainer</code> ou <code>ForEachTestContainer</code> d√©marrent les conteneurs imm√©diatement avant les tests, et non au moment o√π je cr√©e des instances de conteneur.  Il s'av√®re qu'au moment o√π je cr√©e l'AppContainer, je n'ai pas encore <code>PostgreSQLContainer</code> activ√©, ce qui signifie que je ne peux pas obtenir le port attribu√© √† partir de celui-ci, et il est n√©cessaire de former <code>jdbcUrl</code> . <br><br>  Le probl√®me est que l'essence du conteneur est modifiable: il a plusieurs √©tats.  Par exemple, il peut √™tre d√©sactiv√© et r√©activ√©. <br><br>  Comment r√©soudre ce probl√®me?  La premi√®re m√©thode que j'appellerais ¬´paresseuse¬ª. <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { lazy val pgCont = PostgreSQLContainer() lazy val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() } // tests here }</code> </pre> <br>  L'id√©e principale est de cr√©er des conteneurs en utilisant <strong>lazy lazy</strong> .  Ensuite, ils ne seront pas initialis√©s imm√©diatement dans le constructeur de test, mais attendront le premier appel.  Nous allons initialiser dans les <code>afterAll</code> <code>beforeAll</code> et <code>afterAll</code> , que le <code>BeforeAndAfterAll</code> BeforeAndAfterAll de ScalaTest fournit.  Dans <code>beforeAll</code> conteneurs d√©marrent et dans <code>afterAll</code> , ils s'√©teignent.  Comme les conteneurs sont d√©clar√©s paresseux, au moment o√π la m√©thode de d√©marrage est appel√©e dans beforeAll, ils seront cr√©√©s, initialis√©s et d√©marr√©s. <br><br>  Cependant, une erreur se produit quand m√™me que je ne peux pas rejoindre localhost: 32787: <br><br><pre> <code class="bash hljs">org.postgresql.util.PSQLException: Connection to localhost:32787 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.</code> </pre> <br>  Il semblerait que nous ayons utilis√© jdbcUrl, pourquoi localhost appara√Æt-il?  Voyons comment fonctionne jdbcUrl: <br><br><pre> <code class="bash hljs">@Override public String <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJdbcUrl</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://"</span></span> + getContainerIpAddress() + <span class="hljs-string"><span class="hljs-string">":"</span></span> + getMappedPort(POSTGRESQL_PORT) + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + databaseName; }</code> </pre> <br>  Il s'agit simplement d'une concat√©nation de cha√Ænes.  Tout est clair avec des constantes, elles ne peuvent pas casser.  <code>getMappedPort</code> devrait √©galement fonctionner, car nous l'avons d√©j√† corrig√©.  <code>databaseName</code> est une constante cod√©e en dur.  Mais avec <code>getContainerIpAddress</code> plus int√©ressant.  Par son nom, nous pouvons supposer qu'il doit renvoyer l'adresse IP du conteneur.  Mais si vous ex√©cutez ce code, il s'av√®re qu'il renvoie toujours localhost.  Il s'est av√©r√© que cette m√©thode n'est pas destin√©e √† l'interaction entre conteneurs: <code>getContainerIpAddress</code> <strong>fournit une interaction √† partir de tests √† l'int√©rieur du conteneur</strong> . <br><br>  Recommandation du d√©veloppeur Testcontainers: <strong>cr√©er un r√©seau personnalis√© pour la communication entre conteneurs</strong> .  Docker-compose fonctionne comme ceci: il cr√©e un r√©seau et r√©sout tout par lui-m√™me. <br><br>  Vous devez donc cr√©er un r√©seau. <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() network.close() } // tests here }</code> </pre> <br>  Nous devons maintenant configurer manuellement notre jdbcUrl.  Nous devons √©galement activer nos conteneurs dans le r√©seau et d√©finir l'alias du PostgreSQLContainer afin qu'il soit accessible au sein du r√©seau par un nom de domaine.  En fin de compte, vous devez vous rappeler de ¬´tuer¬ª le r√©seau. <br><br>  Enfin, un tel programme fonctionnera. <br><br>  Dans les versions r√©centes de testcontainers-scala, l'initialisation des conteneurs paresseux est prise en charge imm√©diatement: <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with ForAllTestContainer with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override val container = MultipleContainers(pgCont, appCont) override def afterAll(): Unit = { super.afterAll() network.close() } // tests here }</code> </pre> <br>  Vous pouvez √† nouveau utiliser <code>ForAllTestContainer</code> et <code>MultipleContainers</code> .  Dans <code>beforeAll</code> n'avez plus besoin de <code>beforeAll</code> manuellement <code>beforeAll</code> ordre de d√©part.  Maintenant, <code>MultipleContainers</code> peut travailler avec lazy lazy et les ex√©cuter dans le bon ordre, et ne fait pas d'initialisation stricte imm√©diatement lors de la cr√©ation.  Dans le m√™me temps, les manipulations avec le r√©seau personnalis√© et jdbcUrl doivent √©galement √™tre effectu√©es manuellement. <br><br><h3>  Se moquer </h3><br>  Cependant, il y a encore des probl√®mes.  Par exemple moki.  Parfois, il n'est pas tr√®s pratique de cr√©er une sorte de d√©pendance dans un conteneur Docker.  Nous utilisons Spark JobServer, qui cr√©e des t√¢ches Spark et contr√¥le leur cycle de vie dans Spark.  Nous utilisons deux de ses m√©thodes: ¬´cr√©er¬ª et ¬´donner un statut¬ª. <br><br>  Pour ex√©cuter Spark JobServer dans Docker.  Il faut soulever Spark, et jusqu'√† r√©cemment, il n'y avait pas du tout de docker et il fallait l'assembler soi-m√™me.  De plus, Spark JobServer utilise PostgreSQL pour stocker les √©tats.  Par cons√©quent, vous devez faire beaucoup de travail difficile lorsque vous n'avez vraiment besoin que de deux m√©thodes avec une API simple. <br><br>  Mais vous pouvez jeter un ≈ìil √† l'impl√©mentation de Spark JobServer et cr√©er une maquette qui se comporte de la m√™me mani√®re, mais qui ne n√©cessite pas les d√©pendances de Spark JobServer d'origine. <br><br>  Cela ressemble √† ceci (dans l'exemple, un pseudocode simplifi√©): <br><br><pre> <code class="bash hljs">val hostIp = ??? AppContainer(sparkJobServerMockHost = hostIp) val sparkJobServerMock = new SparkJobServerMock() sparkJobServerMock.init(someData) val apiResult = appApi.callMethod() assert(apiResult == someData)</code> </pre> <br>       http-    API    Spark JobServer.    - ,          . ,   ,   ,     mock. <br><br>   -  ,      .       :    ¬´¬ª    config;   ,   host. <br><br>  <code>SparkJobServerMock</code>    ,     host-,     docker-, ,   ,       docker-. <br><br>      ?      docker-,   ,    gateway  ,   docker-. <br><br>   ,   Testcontainers   API. ,   Testcontainers    docker-java-,     .    ¬´¬ª docker-: <br><br><pre> <code class="bash hljs">val client: com.github.dockerjava.api.DockerClient = DockerClientFactory .instance .client val networkInfo: com.github.dockerjava.api.model.Network = client .inspectNetworkCmd() .withNetworkId(network.getId) .<span class="hljs-built_in"><span class="hljs-built_in">exec</span></span>() val hostIp: String = networkInfo .getIpam .getConfig .get(0) .getGateway</code> </pre> <br> -,   <code>DockerClient</code> .  Testcontainers  <code>DockerClientFactory</code>  .  c  <code>inspectNetworkCmd</code> .   ,  info,  gateway. <br><br>      ,      ,   . <br><br>       ‚Äî    . Docker    : Windows, Mac,   .        Linux.     ,  ,     Linux      . <br><br>  ,    Testcontainers    .         ,      docker-.    : <br><br><pre> <code class="bash hljs">Testcontainers.exposeHostPorts(sparkJobServerMockPort)</code> </pre> <br> ,      <strong>  </strong> .        docker-.        <code>`host.testcontainers.internal`</code> . <br><br>  ,    : <br><br><pre> <code class="bash hljs">val sparkJobServerMockHost = <span class="hljs-string"><span class="hljs-string">"host.testcontainers.internal"</span></span> val sparkJobServerMockPort = 33333 Testcontainers.exposeHostPorts(sparkJobServerPort) AppContainer(sparkJobServerMockHost, sparkJobServerMockPort)</code> </pre> <br><br><h3>  Testcontainers </h3><br>    ,  ,     Testcontainers   ,      .   Java-,   Scala-.       : <br><br><ul><li>          . , testcontainers-java    JUnit,  testcontainers-scala   ScalaTest,   testcontainers-java       .  Scala-    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> Scala </a> .      .    ,    .  ,   predefined         Java-.        ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  API</a> .        API,          . ,      .    ,       ,   . </li></ul><br><h2>  R√©sum√© </h2><br>     . Docker ,      ,      ,     ,   network gateway. <br><br> Testcontainers ‚Äî   ,    . API   ,      . <br><br>     Java-,        .      ‚Äî     .     . <br><br>        ,    docker-,         . <br><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"> <strong><em>‚Äî       ,       , ,     . .?</em></strong> <br><br> ,    . <br><br> <strong><em>‚Äî   -     ?</em></strong> <br><br>     Kubernetes,     .      end-to-end ,    ,    ,   ,   . <br><br>      ,   ,       unit-,            . <br><br> <strong><em>‚Äî         Kubernetes    ?</em></strong> <br><br> -,  ,  -,   ,     ,        ,    Spark  Kubernetes   ;       ,       . <br><br> ,       ,      unit-,   , ,  break point  ,       ,    . <br><br> ,   ,  ,   CI  ,      . <br><br>  ,       minicube ‚Äî     Mac, .       ,      ,   ,   ,  . <br><br> <strong><em>‚Äî     ?       :  master? ,    - ,  ,   2.1,    2.2,   ?</em></strong> <br><br>    ImageName,   Postgres 9.6. <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>)</code> </pre> <br>    9.6,     10.    [ ],     . <br><br>      Image tag ‚Äî   , ‚Äî       ,        .    ,    latest   . <br><br> <strong><em>‚Äî ,           ?</em></strong> <br><br> ,  CI    ,  GitLab CI , ,  Branch Name. <br><br> <strong><em>‚Äî  ,      ,    ,   ?     - ,      ?    20-   ,   ?</em></strong> <br><br> -,       ,        .      ,      ,  ,  ,     ,  . <br><br> -      ,    ,    full-time ,   ,      ,  . <br><br>      commit',       , ,      ,    Android, iOS  . .    ,       ,  ,   , ‚Äî   . <br><br>     ,  ,      -: -  , - . , -    . <br></div></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous voulez plus de d√©tails sur les microservices eux-m√™mes et pas seulement sur Scala - notre programme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScalaConf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a des r√©ponses √† diverses questions. </font><font style="vertical-align: inherit;">Plus int√©ress√©s par l'architecture et les interconnexions de ses diff√©rentes parties - venez √† </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HighLoad ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> les 7 et 8 novembre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout est si savoureux, et on ne sait pas quoi choisir, alors abonnez-vous √† la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">newsletter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans laquelle nous parlons de rapports et collectons des documents utiles sur le sujet.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464307/">https://habr.com/ru/post/fr464307/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464293/index.html">Les crochets se remplacent-ils dans React Redux?</a></li>
<li><a href="../fr464295/index.html">Exemples d'utilisation de nouvelles fonctionnalit√©s JavaScript</a></li>
<li><a href="../fr464299/index.html">0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 0, 2, 6, 5, 4, 0, 5, 3, 0, 3, 2, 9, 0, 4, 9, 3, 6, 14, 0, 6, 3, 5, 15, 0, 5, 3, 5 ...</a></li>
<li><a href="../fr464303/index.html">Donn√©es de s√©ries chronologiques dans un SGBD relationnel. Extensions TimescaleDB et PipelineDB pour PostgreSQL</a></li>
<li><a href="../fr464305/index.html">Petit, oui. D√©ballage du p√©tard microvirtuel</a></li>
<li><a href="../fr464309/index.html">Bouton d'appel bricolage. Raspberry Pi, MajorDoMo, Freeswitch et Linphonec</a></li>
<li><a href="../fr464315/index.html">Le film dans lequel il y avait de la terre. Recherche sur Yandex et bref historique de la recherche par sens</a></li>
<li><a href="../fr464317/index.html">Projet Konbanwa</a></li>
<li><a href="../fr464325/index.html">Comment Scrumban unit le meilleur des m√©thodologies Kanban et Scrum</a></li>
<li><a href="../fr464327/index.html">Comparaison de l'utilisation de la m√©moire des diff√©rentes interfaces graphiques de la bo√Æte √† outils</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>