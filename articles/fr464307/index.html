<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏽 💉 🧔🏻 Test d'intégration de microservices sur Scala 👩🏻‍🏭 👩🏾‍⚕️ 🧝🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les tests unitaires sont excellents, mais un n'est pas suffisant. Souvent, vous voulez également vous assurer que l'application en cours d'exécution f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Test d'intégration de microservices sur Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/464307/">  Les tests unitaires sont excellents, mais un n'est pas suffisant.  Souvent, vous voulez également vous assurer que l'application en cours d'exécution fonctionnera.  Les tests d'intégration viennent à la rescousse.  Il est de plus en plus utilisé pour tester les services et Docker vous permet de gérer facilement votre environnement de test.  Mais, comme toujours, les choses ne sont pas si simples quand il y a beaucoup plus de microservices et de dépendances. <br><br>  Yuri Badalyants de RIT ++ a raconté comment dans 2GIS ils testent un tas d'un grand nombre de services et tout un zoo technologique.  Sous la coupe, la version de ce rapport, complétée et mise à jour sous la supervision attentive de l'orateur: quelles options vous avez essayées, ce que vous avez trouvé, quels problèmes vous n'avez pas à résoudre maintenant.  Il s'agira de Docker, de Testcontainers et également de Scala. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zE2sLcIeoZk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>À propos du conférencier:</strong> Yuri Badalyants (@ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LMnet</a> ) a commencé sa carrière en 2011 en tant que développeur Web, a travaillé avec PHP, JavaScript et Java.  Maintenant, il écrit sur Scala dans 2GIS. <br><br><h2>  Casino </h2><br>  2GIS fournit des cartes de ville et des répertoires d'entreprises depuis 20 ans et nous avons récemment une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nouvelle version</a> avec une carte illimitée de la Russie.  Je vais vous parler de l'expérience acquise pendant que je travaillais dans l'équipe Casino.  Cette équipe intervient dans trois domaines principaux: <br><br><ul><li>  Publicité - quels annonceurs afficher, lesquels masquer, lesquels augmenter et comment abaisser la note. </li></ul><br><ul><li>  BigData est lié à la publicité et à sa personnalisation, ainsi qu'à la construction d'analyses et de métriques. </li><li>  Crawler est un programme qui recherche des organisations sur Internet pour les ajouter automatiquement à la base de données. </li></ul><br>  Ces trois domaines sont les tâches principales qui, à leur tour, comportent un grand nombre de sous-tâches.  Actuellement, il existe plus de 25 microservices écrits en Scala.  Il s'agit exclusivement de notre code, mais nous utilisons également des systèmes tiers, par exemple, PostgreSQL, Cassandra et Kafka.  Nous stockons les données dans Hadoop et les traitons dans Spark.  De plus, nous utilisons les méthodes d'apprentissage automatique fournies par l'équipe Data Science. <br><br>  En conséquence, nous avons un grand nombre de services et de microservices, un grand nombre de dépendances et, bien sûr, tout cela doit être testé d'une manière ou d'une autre. <br><br>  Bien sûr, nous écrivons des tests unitaires.  Cependant, même si tous les tests sont verts, cela ne signifie pas que tout fonctionne.  Quelque chose peut mal tourner pendant la phase d'intégration des composants ou des microservices.  Par conséquent, nous écrivons des tests d'intégration. <br><br><h2>  Tests d'intégration </h2><br>  Chaque microservice développé par l'équipe Casino résout son problème commercial et se trouve dans un référentiel séparé dans GitLab.  Cet article se concentrera sur les tests d'intégration au sein d'un tel référentiel (microservice) avec des dépendances verrouillées, qui est la responsabilité des développeurs eux-mêmes.  L'équipe QA teste l'interaction des microservices, et je n'aborderai pas ce sujet. <br><br>  Lorsque j'ai rejoint l'équipe pour la première fois, fin 2016, il y avait approximativement le schéma de test d'intégration suivant: <br><img src="https://habrastorage.org/webt/ws/fx/0r/wsfx0rhcuvtffigxdhrpmmoizya.png"><br><br><ol><li>  Le développeur insère son code dans GIT, après quoi le code du microservice entre dans TeamCity.  TeamCity commence à construire du code et à exécuter des tests. </li><li>  TeamCity prend le fichier de configuration (config) de Chef (un système de gestion de configuration similaire à Ansible, uniquement écrit en Ruby).  Chef sert également à automatiser le déploiement.  Quand j'ai 100 machines, je ne veux pas aller sur chacune d'elles et installer ce dont j'ai besoin sur SSH, et Chef me permet d'automatiser cela. </li><li>  TeamCity collecte le fichier jar (puisque nous écrivons dans Scala, l'artefact que nous publions est le jar), puis le programme le charge dans l'environnement CI.  Notre application y est déployée, il y a aussi quelques dépendances.  Dans le diagramme, l'une des dépendances est représentée comme une base de données.  Il peut y avoir autant de dépendances que possible, et grâce à Chef, notre application les connaît et commence à interagir avec elles. </li><li>  Ensuite, TeamCity lance <strong>SBT</strong> (c'est notre système de construction où la compilation et les tests sont exécutés) et exécute les tests eux-mêmes.  Ils sont relativement similaires aux tests unitaires, mais ils fonctionnent principalement sur ce principe: aller via http à une adresse spécifique, vérifier une méthode et voir ce qu'elle renvoie;  ou faites un peu de préparation, puis voyez si ce dont vous avez besoin est revenu. </li></ol><br>  <strong>Que dire d'un tel dispositif?</strong>  Plus important encore, cela fonctionne.  Lorsque tout est configuré, l'exécution des tests est facile, car ils ressemblent à des tests unitaires.  Mais les avantages s'arrêtent là. <br><br>  Et les inconvénients commencent.  <strong>L'environnement CI est toujours activé</strong> , ce qui représente un gaspillage supplémentaire de ressources.  Puisque Chef est une configuration statique, vous devriez toujours avoir une sorte de machine où toutes les dépendances seront configurées, où les applications seront déployées indépendamment.  Une telle machine consommera des ressources supplémentaires, car les tests sont exécutés de temps en temps, et la machine doit être prête tout le temps.  De plus, l'environnement CI est inclus avec toutes les dépendances. <br><br>  <strong>Il n'est pas possible d'exécuter des tests sur deux branches en même temps</strong> .  Cela découle du paragraphe précédent: comme nous avons un seul environnement, nous ne pouvons tout simplement pas les exécuter en parallèle. <br><br>  <strong>Il n'est pas possible de tester le démarrage, l'arrêt et le redémarrage</strong> .  J'expliquerai pourquoi cela est nécessaire: toutes nos applications obéissent à la logique du soi-disant <strong>arrêt gracieux</strong> , c'est-à-dire que lorsque nous obtenons SIGTERM, nous n'arrêtons pas le processus au milieu, mais interceptons ce signal et comprenons que nous devons désactiver le programme.  À ce stade, une certaine logique est activée, par exemple, les requêtes HTTP qui sont «en cours» sont traitées, ou si nous travaillons avec Kafka, nous validons tous les offs - en d'autres termes, nous effectuons certaines actions afin de pouvoir terminer le travail en toute sécurité, et puis, quand tout est fait, éteignez. <br><br>  Cette logique n'est pas toujours simple, et vous ne pouvez la tester avec un tel schéma que manuellement, car à partir des tests nous ne contrôlons pas le cycle de vie de l'application.  Il s'avère que TeamCity a en quelque sorte déployé quelque chose via Chef, alors que les tests sont à un stade différent et ne savent pas comment l'application est déployée. <br><br>  Le prochain <strong>inconvénient</strong> est qu'il est très <strong>difficile de configurer tout cela localement</strong> .  Autrement dit, il existe de nombreuses dépendances, elles ont leurs propres configurations, elles doivent être générées sur la machine locale.  L'application elle-même possède également son propre fichier de configuration, dans lequel il existe de nombreuses valeurs.  Les tests eux-mêmes ont une configuration qui doit être mise en correspondance avec la configuration de l'application, et il peut également y avoir plus d'une valeur de configuration.  Il semble que tout cela ne semble pas si effrayant, comme «aller réparer les configurations à trois endroits», mais en réalité, cela peut prendre des heures aux nouveaux employés pour le faire. <br><br><h3>  Docker GitLab CI + </h3><br>  Au fil du temps, ce schéma s'est transformé en un autre: <strong>GitLab CI</strong> et <strong>Docker</strong> .  Cela ne s'est pas produit parce que le schéma précédent n'était pas idéal, mais parce que l'entreprise a légèrement changé de cap en termes d'organisation administrative. <br><br>  Auparavant, chaque équipe, et nous en avons beaucoup, comme nous le voulions ou comme nous le pouvions, et déployait son travail.  Par exemple, nous avions TeamCity, Chef et d'autres équipes pouvaient utiliser Jenkins ou Ansible. <br><br>  Nous nous dirigeons maintenant vers le cloud local et Kubernetes, et il existe une équipe distincte qui gère tout cela, à la fois GitLab CI et Kubernetes.  D'autres équipes l'utilisent simplement comme un service.  C'est beaucoup plus pratique car vous n'avez pas besoin d'administrer tout cela manuellement. <br><br>  En utilisant Kubernetes, nous avons déployé le schéma suivant: <br><img src="https://habrastorage.org/webt/lr/uc/gq/lrucgqg479qcboq4xxwpil0pohq.png"><br><br><ol><li>  Au lieu de TeamCity, Gitlab CI est maintenant utilisé. </li><li>  GitLab CI crée une image Docker et la déploie sur Kubernetes.  La configuration est désormais stockée directement dans le référentiel, et non séparément dans Chef, donc pour le déploiement, vous n'avez pas besoin de travailler avec un service de configuration tiers. </li><li>  Les dépendances sont soulevées à l'avance, également à Kubernetes. </li><li>  Ensuite, GitLab CI lance SBT et teste dans une étape distincte. </li></ol><br>  Tout est assez similaire au schéma précédent et ne diffère pas fondamentalement de celui-ci, c'est-à-dire que même les avantages et les inconvénients seront exactement les mêmes, mais Docker apparaît. <br><br>  Avec docker, vous pouvez faire différentes choses plus amusantes et l'une d'entre elles est la composition de docker. <br><br><h3>  Docker-compose </h3><br>  Il s'agit d'une sorte de "superposition" sur Docker, qui vous permet d'exécuter plusieurs images de docker en une seule entité. <br><br>  Un bon exemple où docker-compose aide vraiment est Kafka.  Elle a besoin de ZooKeeper pour fonctionner.  Si vous soulevez Kafka et ZooKeeper sans composition de docker, vous devez soulever séparément ZooKeeper dans le docker, séparément - Kafka, et garder ces deux conteneurs de docker cohérents.  Ce n'est pas très pratique, et docker-compose vous permet de décrire les deux conteneurs dans un seul fichier docker-compose.yml et d'utiliser la simple commande <code>docker-compose run Kafka</code> augmenter Kafka et ZooKeeper. <br><br>  Vous pouvez créer des tests d'intégration sur docker-compose.  Voyons à quoi cela ressemblera. <br><img src="https://habrastorage.org/webt/ae/a9/wn/aea9wn8lh9tdi8ezctgs1hfhkuw.png"><br><br><ol><li>  Encore une fois, poussez tout dans GitLab. </li><li>  GitLab CI lance docker-compose. </li><li>  Dans docker-compose, l'application monte, toutes les dépendances et SBT montent, et le SBT conduit les tests pour cette application - tout se passe à l'intérieur de docker-compose. </li></ol><br>  Grâce à ce schéma, il n'est pas nécessaire de conserver un environnement et des dépendances séparés, car tout va directement au runner GitLab CI, où doivent simplement se trouver docker et docker-compose.  Au démarrage, il va pomper les images nécessaires et les exécuter. <br><br>  De plus, vous pouvez tester différentes branches en même temps car tout se passe sur le coureur. <br><br>  Il <strong>est</strong> désormais <strong>plus facile de configurer l'</strong> environnement <strong>localement</strong> , mais vous devez toujours coordonner plusieurs endroits.  Le fait est que maintenant, lorsque nous faisons la configuration locale, nous n'avons pas besoin de tout mettre sur la machine locale, tout est écrit dans le fichier docker-compose.yml.  Ainsi, vous devez configurer à deux endroits différents - c'est docker-compose.yml et la configuration de nos tests. <br><br>  En ce qui concerne les inconvénients, <strong>il est toujours impossible de tester le démarrage, l'arrêt et le redémarrage</strong> , car à partir du SBT, à partir des tests, nous ne contrôlons pas le cycle de vie de l'application.  Il est exécuté par docker-compose, il exécute SBT et les tests sont exécutés à l'intérieur de SBT.  Ainsi, il n'y a pas de gestion complète du cycle de vie de l'application.  Il y a aussi des difficultés avec le lancement, dont je voudrais parler davantage. <br><br><h4>  docker-compose 2 </h4><br>  À l'époque de docker-compose 2, docker-compose.yml, le fichier ressemblait à ceci: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'2.1'</span></span> services: web: build: . depends_on: db: condition: service_healthy redis: condition: service_started redis: image: redis db: image: db healthcheck: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>: <span class="hljs-string"><span class="hljs-string">"some test here"</span></span></code> </pre> <br>  Les services sont enregistrés ici, c'est-à-dire ce que nous allons lever dans le cadre de ce docker-compose.  Dans ce cas, je viens de prendre un exemple de la documentation docker-compose.  Il existe trois services: web, redis et db (base de données). <br><br>  Le Web est notre application, et redis et db sont des dépendances. <br><br>  Il y a un élément dans le bloc Web appelé <code>depends_on</code> .  Cela suggère que l'application Web dépend de certains autres conteneurs et est décrite ci-dessous sur laquelle: à partir de la base de données et de redis. <br><br>  Il existe également une clause <code>condition</code> .  Pour redis, il s'agit de <code>service_started</code> , ce qui signifie que jusqu'au démarrage de redis, le conteneur n'essaiera pas de démarrer l'application Web. <br><br>  Quant à la base de données, son état est <code>service_healthy</code> , et le bilan de santé est décrit ci-dessous.  Autrement dit, nous devons non seulement lancer le conteneur Docker, mais également exécuter un certain contrôle de santé.  Il peut s'agir de n'importe quelle logique personnalisée. <br><br>  Par exemple, nous utilisons PostgreSQL, qui utilise l'extension PostGIS, et il a besoin d'un certain temps pour s'initialiser.  Lorsque nous lançons le conteneur Docker, nous ne pouvons pas travailler immédiatement avec l'extension postgis - nous devons attendre que l'extension s'initialise.  Par conséquent, nous <code>SELECT PostGIS_Version();</code> simplement <code>SELECT PostGIS_Version();</code> requêtes <code>SELECT PostGIS_Version();</code> à <code>SELECT PostGIS_Version();</code>  .  Jusqu'à ce que l'extension soit initialisée, la requête générera une erreur et lorsque l'extension sera initialisée, elle commencera à renvoyer la version.  C'est très pratique et logique - <strong>nous allons d'abord augmenter toutes les dépendances, puis l'application</strong> . <br><br><h4>  docker-compose 3 </h4><br>  Lorsque docker-compose 3 est sorti, nous avons commencé à l'utiliser. <br><br>  Mais dans la documentation, un élément est apparu lors de la modification de la logique depend_on.  Les développeurs de dockers ont décidé qu'une description du graphique de dépendance était suffisante.  Cela signifie que lorsque vous lancez la commande <code>docker-compose run web</code> , l'application elle-même et la base de données dont elle dépend démarrent simultanément. <br><br><img src="https://habrastorage.org/webt/yp/4_/vy/yp4_vyw7zxudu9naji96akfjeic.png"><br><br>  Le paragraphe suivant de la documentation indique que depend_on n'est plus une condition. <br><br>  Ainsi, si vous souhaitez toujours obtenir la fonctionnalité utilisée dans la deuxième version, vous devrez tout prendre en main. <br><br>  La page <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contrôle de la commande de démarrage</a> propose plusieurs solutions.  La première option consiste à utiliser <strong>wait-for-it.sh</strong> . <br><br>  Maintenant, docker-compose.yml est un peu différent: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: web: build: . depends_on: [ db, redis ] redis: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-it.sh"</span></span>, ... ] db: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-db.sh"</span></span>, ... ]</code> </pre> <br>  <code>depends_on</code> est juste un tableau, il n'y a aucune condition. <br><br>  Dans nos dépendances, nous redéfinissons la commande, c'est-à-dire que dans docker-compose, vous pouvez attacher une commande avec laquelle le conteneur docker démarre. <br><br>  Là, nous devrions écrire wait-for-it.sh, et autre chose.  Au lieu des trois points dans l'exemple ci-dessus, nous devons écrire ce que nous devons attendre, ainsi que la commande d'origine qui lance le conteneur Docker. <br><br>  Pour ce faire, vous devez trouver le fichier docker, copier la commande pour redis à partir de là et le coller, il en va de même pour la base de données.  Un énorme inconvénient est que l' <strong>abstraction tombe en panne</strong> - je ne veux pas savoir quelle commande lance le conteneur Docker.  Ces commandes peuvent être non triviales, assez complexes, mais je ne veux pas déranger, je veux juste entrer dans la <code>docker run</code> et c'est tout. <br><br>  Personnellement, je n'aime pas vraiment cette solution, mais nous avions quelques services qui fonctionnent comme ça. <br><br><h4>  Script au-dessus de docker-compose </h4><br>  Puis j'ai décidé que le moment était venu pour la " <strong>construction de</strong> vélos", et j'ai eu <strong>docker-compose-run.sh</strong> : <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: postgres: ... my_service: depends_on: [ postgres ] ... sbt: depends_on: [ my_service ] ...</code> </pre><br>  Permettez-moi de vous donner un exemple semi-réaliste: il y a postgres dans docker-compose.yml, il y a mon_service application, qui dépend de postgres, et SBT, dans lequel les tests sont exécutés et qui dépend de mon service. <br><br>  J'exécute le programme non pas via <code>docker run</code> , mais via le script docker-compose-run.sh. <br><br>  Premièrement, cela commence d'abord par la dépendance la plus profonde, dans mon cas c'est postgres.  Le script démarre la dépendance en mode "démon", c'est-à-dire qu'il ne bloque pas le terminal: <br><br><pre> <code class="bash hljs">docker-compose up -d postgres</code> </pre> <br>  J'attends ensuite que la condition soit satisfaite par la fonction wait_until.  C'est presque la même chose que wait-for-it.sh, seulement, pour ainsi dire, dans un style impératif.  Pendant l'initialisation de PostGIS, le terminal est bloqué, c'est-à-dire que le programme attend également, et s'il n'attend pas, une erreur est générée et les tests cessent de fonctionner. <br><br><pre> <code class="bash hljs">wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T postgres psql</code> </pre> <br>  Lorsque PostGIS est initialisé, passez à l'étape suivante et faites de même avec le service.  Pour lui, le test est un peu plus simple: le port 80 doit être lié. <br><br><pre> <code class="bash hljs">docker-compose up -d my_service wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T \ my_service sh -c <span class="hljs-string"><span class="hljs-string">"netstat -ntlp | grep 80 || exit 1"</span></span></code> </pre> <br>  La dernière étape consiste à exécuter SBT via la commande run, dans laquelle les tests sont exécutés. <br><br><pre> <code class="bash hljs">docker-compose run sbt down $?</code> </pre> <br>  Ainsi, tout est relevé dans le bon ordre, mais manuellement. <br><br>  À la fin, la fonction <code>down</code> est appelée, qui accepte le résultat de la commande précédente.  Si c'est "0", alors les tests ont réussi et nous désactivons simplement docker-compose;  sinon, nous «crachons» d'abord les journaux pour comprendre ce qui n'a pas fonctionné, puis nous désactivons la composition par docker. <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> down { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Exiting with code </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$1</span></span> -eq 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> docker-compose logs -t postgres my_service docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> }</code> </pre> <br>  Un tel schéma fonctionne, mais ne s'adapte pas bien.  Chaque service devra décrire son docker-compose-run.sh avec sa propre logique.  De plus, la configuration de lancement s'étend entre docker-compose-run.sh et docker-compose.yml.  Eh bien, en général, il semble que nous n'utilisions pas de composition de docker, mais que nous ayons des problèmes avec ses lacunes. <br><br><h4>  Exécuter Docker à partir du code </h4><br>  Lorsque le schéma précédent a été créé, j'ai pensé: si j'ai déjà tout dans le docker, alors pourquoi ne pas l'exécuter à partir du code.  J'ai commencé à chercher une solution et j'ai trouvé plusieurs options. <br><br>  La première option consiste à simplement <strong>utiliser le client docker</strong> .  Il existe deux principaux clients dockers dans le monde JVM: <strong>docker-java</strong> et <strong>spotify docker-client</strong> . <br><br>  Le client Docker vous permet d'exécuter des commandes Docker directement à partir du code à l'aide de l'API.  Autrement dit, au lieu de concaténer des chaînes pour créer des commandes comme <code>`docker run ...`</code> , vous pouvez simplement former une telle commande dans le code et l'exécuter.  C'est beaucoup plus pratique. <br><br>  Cette méthode fonctionne bien et, bien sûr, ils peuvent tout faire, cependant, c'est un niveau très bas.  Je devrais créer mon propre analogique de composition de docker, ce qui est une très grosse tâche. <br><br>  L'option suivante est la <strong>bibliothèque docker-it-scala</strong> , qui encapsule ces deux clients et vous permet de choisir le backend à utiliser.  Elle peut gérer les conteneurs dont vous avez besoin. <br><br>  Mais l'inconvénient de cette bibliothèque est qu'elle n'a pas d'API très flexible et qu'il n'y a pas de contrôle du cycle de vie. <br><br>  Je n'aimais pas non plus cette option, j'ai continué ma recherche et trouvé des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Testcontainers</a> .  Je voudrais vous en dire plus à ce sujet. <br><br><h2>  Conteneurs d'essai </h2><br>  Il s'agit d'une sorte de bibliothèque java pour lancer et tester des conteneurs Docker.  Il y a une façade Scala, testcontainers-scala.  Hors de la boîte, il existe un certain nombre de services populaires, par exemple, PostgreSQL, MySQL, Nginx, Kafka, Selenium.  Vous pouvez exécuter n'importe quel autre conteneur.  La bibliothèque possède une API assez simple et flexible, sur laquelle je m'attarderai plus en détail. <br><br><h3>  Conteneurs prédéfinis </h3><br>  Alors, comment travailler avec des conteneurs prédéfinis, qui sont dans la bibliothèque: en fait, tout est assez simple, car les conteneurs sont représentés comme des objets: <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) pgContainer.start() val pgUrl: String = pgContainer.jdbcUrl val pgPort: Int = pgContainer.mappedPort(5432) pgContainer.stop()</code> </pre> <br>  Dans ce cas, nous créons <code>PostgreSQLContainer</code> , nous pouvons le démarrer et commencer à travailler avec.  Ensuite, nous obtenons <code>jbdcUrl</code> , avec lequel vous pouvez vous connecter à PostgreSQL.  Après cela, nous obtenons <code>mappedPort</code> . <br><br>  Cela signifie que PostgreSQL sort du port docker 5432, et Testcontainers voit ce port et l'attribue automatiquement à un port aléatoire.  Autrement dit, d'après les tests que nous voyons, par exemple, 32422. L'affectation se produit automatiquement. <br><br><h3>  Conteneur personnalisé </h3><br>  La vue suivante, le soi-disant conteneur personnalisé, est également assez simple: <br><br><pre> <code class="bash hljs">class GenericContainer( imageName: String, exposedPorts: Seq[Int] = Seq(), env: Map[String, String] = Map(), <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: Seq[String] = Seq(), classpathResourceMapping: Seq[(String, String, BindMode)] = Seq(), waitStrategy: Option[WaitStrategy] = None ) ...</code> </pre> <br>  Il existe un <code>GenericContainer</code> dont vous devez hériter et remplacer un certain nombre de champs.  Assurez-vous de définir uniquement <code>imageName</code> - c'est le nom du conteneur que nous voulons créer. <br><br>  Vous pouvez définir les ports <code>exposedPorts</code> : ces ports que le conteneur dépassera.  Dans env, vous pouvez définir des variables d'environnement; vous pouvez également définir la <code>command</code> à exécuter. <br><br>  <code>classpathResourceMapping</code> vous permet de jeter des ressources du classpath dans le conteneur Docker.  C'est très pratique, par exemple, si la configuration de l'application se trouve directement dans les ressources de test.  Vous mappez simplement à l'intérieur et l'application à l'intérieur de docker a accès à cette configuration. <br><br>  <code>waitStrategy</code> est une chose très pratique qui manquait dans docker-compose 3, en fait c'est HealthCheck.  Il existe plusieurs <code>waitStrategy</code> prédéfinies, par exemple, vous pouvez attendre jusqu'à ce qu'une liaison de port se produise, ou une méthode http spécifique renverra 200. Mais vous pouvez écrire n'importe lequel de vos HealthCheck. <br><br>  Puisque vous écrivez HealthCheck simplement dans votre code, vous pouvez utiliser, d'une part, une langue normale, pas bash, et, d'autre part, toutes les bibliothèques disponibles à partir de votre code: si vous voulez faire une HealthCheck personnalisée dans Cassandra - prenez le pilote et écrivez tout HealthCheck. <br><br><h3>  Exécution de tests </h3><br>  Et maintenant un peu sur la façon d'exécuter des tests: <br><br><pre> <code class="bash hljs">class PostgresqlSpec extends FlatSpec with ForAllTestContainer { override val container = PostgreSQLContainer() <span class="hljs-string"><span class="hljs-string">"PostgreSQL container"</span></span> should <span class="hljs-string"><span class="hljs-string">"be started"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { Class.forName(container.driverClassName) val connection = DriverManager .getConnection(container.jdbcUrl, container.username, container.password) // <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> some stuff } }</code> </pre> <br>  Je vais parler de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ScalaTest</a> , la norme de facto pour les tests dans le monde Scala. <br><br>  Par exemple, nous voulons écrire des tests pour Postgres.  Créez un test <code>PostgresqlSpec</code> et <code>ForAllTestContainer</code> de <code>ForAllTestContainer</code> .  Il s'agit d'un trait fourni par la bibliothèque.  Il démarrera les conteneurs nécessaires avant tous les tests et les arrêtera après tous les tests.  Ou vous pouvez utiliser <code>ForeachTestContainer</code> , puis les conteneurs commencent avant chaque test et s'arrêtent après chacun d'eux. <br><br>  Ensuite, vous devez redéfinir le conteneur.  Cela peut être fait en remplaçant la propriété du <code>container</code> .  Dans mon cas, j'utilise <code>PostgreSQLContainer</code> . <br><br>  Ensuite, nous écrivons des tests.  Dans l'exemple, je crée une connexion, prends jdbcUrl, nom d'utilisateur, mot de passe, écris des tests spécifiques, envoie des requêtes. <br><br>  En règle générale, les tests d'intégration nécessitent plusieurs conteneurs.  Je peux les créer en utilisant <code>MultipleContainers</code> : <br><br><pre> <code class="bash hljs">val pgContainer = PostgreSQLContainer() val myContainer = MyContainer() override val container = MultipleContainers(pgContainer, myContainer)</code> </pre> <br>  Autrement dit, je crée des conteneurs, je les ajoute à <code>MultipleContainers</code> et je les utilise comme <code>container</code> . <br><br>  Le schéma d'exécution des tests avec Testcontainers est le suivant: <br><br><img src="https://habrastorage.org/webt/vp/0f/-e/vp0f-ehxlezqapcu3rfq3tqzmeu.jpeg"><br><br><ol><li>  Poussez le code dans GitLa. </li><li>  Le coureur GitLab CI lance SBT. </li><li>  SBT exécute des tests.  A l'intérieur des tests, notre application et ses dépendances sont lancées. </li></ol><br>  Les avantages de ce schéma: <br><br><ul><li>  Pas besoin de garder un environnement et des dépendances séparés, tout se passe sur le runner. </li><li>  Vous pouvez tester différentes branches en même temps. </li><li>  Vous pouvez tester le démarrage, l'arrêt et le redémarrage, car nous pouvons contrôler le cycle de vie de l'application (tout commence directement dans le code de test). </li><li>  Il existe des bilans de santé flexibles qui faisaient cruellement défaut. </li><li>  Il n'y a pas de fichiers * .sh dans le référentiel, vous pouvez configurer les tests dans l'application aussi facilement que vous le souhaitez. </li><li>  Grâce au mappage classpathResource, vous pouvez utiliser la même configuration avec les tests et l'application. </li><li>  Vous pouvez configurer des tests à partir du code. </li><li>  Tout cela s'exécute aussi facilement à la fois dans CI et localement, car ce ne sont que des tests qui ressemblent et s'exécutent comme des tests unitaires, seul tout monte dans le conteneur Docker. </li></ul><br>  Il s'avère que tout est étrangement lisse et bon, mais ce n'est qu'à première vue, en fait, nous avons rencontré un certain nombre de problèmes. <br><br><h3>  Conteneurs dépendants </h3><br>  Le premier problème que nous avons rencontré concerne <strong>les conteneurs dépendants</strong> .  Disons qu'il existe une sorte de test: <br><br><pre> <code class="bash hljs">class MySpec extends FlatSpec with ForAllTestContainer { val pgCont = PostgreSQLContainer() val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override val container = MultipleContainers(appCont, pgCont) // tests here }</code> </pre> <br>  Il exécute postgres et AppContainer.  L'appContainer de postgres reçoit jdbcUrl, le nom d'utilisateur et le mot de passe pour la connexion.  Ensuite, MultipleContainers est créé et le test lui-même est décrit. <br><br>  J'exécute le programme et je vois une erreur: <br><br><pre> <code class="bash hljs">Exception encountered when invoking run on a nested suite - Mapped port can only be obtained after the container is started</code> </pre> <br>  Le fait est que le port attribué ne peut pas être pris avant le démarrage du conteneur.  Pourquoi cela se produit-il? <br><br>  Le fait est que <code>ForAllTestContainer</code> ou <code>ForEachTestContainer</code> démarrent les conteneurs immédiatement avant les tests, et non au moment où je crée des instances de conteneur.  Il s'avère qu'au moment où je crée l'AppContainer, je n'ai pas encore <code>PostgreSQLContainer</code> activé, ce qui signifie que je ne peux pas obtenir le port attribué à partir de celui-ci, et il est nécessaire de former <code>jdbcUrl</code> . <br><br>  Le problème est que l'essence du conteneur est modifiable: il a plusieurs états.  Par exemple, il peut être désactivé et réactivé. <br><br>  Comment résoudre ce problème?  La première méthode que j'appellerais «paresseuse». <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { lazy val pgCont = PostgreSQLContainer() lazy val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() } // tests here }</code> </pre> <br>  L'idée principale est de créer des conteneurs en utilisant <strong>lazy lazy</strong> .  Ensuite, ils ne seront pas initialisés immédiatement dans le constructeur de test, mais attendront le premier appel.  Nous allons initialiser dans les <code>afterAll</code> <code>beforeAll</code> et <code>afterAll</code> , que le <code>BeforeAndAfterAll</code> BeforeAndAfterAll de ScalaTest fournit.  Dans <code>beforeAll</code> conteneurs démarrent et dans <code>afterAll</code> , ils s'éteignent.  Comme les conteneurs sont déclarés paresseux, au moment où la méthode de démarrage est appelée dans beforeAll, ils seront créés, initialisés et démarrés. <br><br>  Cependant, une erreur se produit quand même que je ne peux pas rejoindre localhost: 32787: <br><br><pre> <code class="bash hljs">org.postgresql.util.PSQLException: Connection to localhost:32787 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.</code> </pre> <br>  Il semblerait que nous ayons utilisé jdbcUrl, pourquoi localhost apparaît-il?  Voyons comment fonctionne jdbcUrl: <br><br><pre> <code class="bash hljs">@Override public String <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJdbcUrl</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://"</span></span> + getContainerIpAddress() + <span class="hljs-string"><span class="hljs-string">":"</span></span> + getMappedPort(POSTGRESQL_PORT) + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + databaseName; }</code> </pre> <br>  Il s'agit simplement d'une concaténation de chaînes.  Tout est clair avec des constantes, elles ne peuvent pas casser.  <code>getMappedPort</code> devrait également fonctionner, car nous l'avons déjà corrigé.  <code>databaseName</code> est une constante codée en dur.  Mais avec <code>getContainerIpAddress</code> plus intéressant.  Par son nom, nous pouvons supposer qu'il doit renvoyer l'adresse IP du conteneur.  Mais si vous exécutez ce code, il s'avère qu'il renvoie toujours localhost.  Il s'est avéré que cette méthode n'est pas destinée à l'interaction entre conteneurs: <code>getContainerIpAddress</code> <strong>fournit une interaction à partir de tests à l'intérieur du conteneur</strong> . <br><br>  Recommandation du développeur Testcontainers: <strong>créer un réseau personnalisé pour la communication entre conteneurs</strong> .  Docker-compose fonctionne comme ceci: il crée un réseau et résout tout par lui-même. <br><br>  Vous devez donc créer un réseau. <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() network.close() } // tests here }</code> </pre> <br>  Nous devons maintenant configurer manuellement notre jdbcUrl.  Nous devons également activer nos conteneurs dans le réseau et définir l'alias du PostgreSQLContainer afin qu'il soit accessible au sein du réseau par un nom de domaine.  En fin de compte, vous devez vous rappeler de «tuer» le réseau. <br><br>  Enfin, un tel programme fonctionnera. <br><br>  Dans les versions récentes de testcontainers-scala, l'initialisation des conteneurs paresseux est prise en charge immédiatement: <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with ForAllTestContainer with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override val container = MultipleContainers(pgCont, appCont) override def afterAll(): Unit = { super.afterAll() network.close() } // tests here }</code> </pre> <br>  Vous pouvez à nouveau utiliser <code>ForAllTestContainer</code> et <code>MultipleContainers</code> .  Dans <code>beforeAll</code> n'avez plus besoin de <code>beforeAll</code> manuellement <code>beforeAll</code> ordre de départ.  Maintenant, <code>MultipleContainers</code> peut travailler avec lazy lazy et les exécuter dans le bon ordre, et ne fait pas d'initialisation stricte immédiatement lors de la création.  Dans le même temps, les manipulations avec le réseau personnalisé et jdbcUrl doivent également être effectuées manuellement. <br><br><h3>  Se moquer </h3><br>  Cependant, il y a encore des problèmes.  Par exemple moki.  Parfois, il n'est pas très pratique de créer une sorte de dépendance dans un conteneur Docker.  Nous utilisons Spark JobServer, qui crée des tâches Spark et contrôle leur cycle de vie dans Spark.  Nous utilisons deux de ses méthodes: «créer» et «donner un statut». <br><br>  Pour exécuter Spark JobServer dans Docker.  Il faut soulever Spark, et jusqu'à récemment, il n'y avait pas du tout de docker et il fallait l'assembler soi-même.  De plus, Spark JobServer utilise PostgreSQL pour stocker les états.  Par conséquent, vous devez faire beaucoup de travail difficile lorsque vous n'avez vraiment besoin que de deux méthodes avec une API simple. <br><br>  Mais vous pouvez jeter un œil à l'implémentation de Spark JobServer et créer une maquette qui se comporte de la même manière, mais qui ne nécessite pas les dépendances de Spark JobServer d'origine. <br><br>  Cela ressemble à ceci (dans l'exemple, un pseudocode simplifié): <br><br><pre> <code class="bash hljs">val hostIp = ??? AppContainer(sparkJobServerMockHost = hostIp) val sparkJobServerMock = new SparkJobServerMock() sparkJobServerMock.init(someData) val apiResult = appApi.callMethod() assert(apiResult == someData)</code> </pre> <br>       http-    API    Spark JobServer.    - ,          . ,   ,   ,     mock. <br><br>   -  ,      .       :    «»    config;   ,   host. <br><br>  <code>SparkJobServerMock</code>    ,     host-,     docker-, ,   ,       docker-. <br><br>      ?      docker-,   ,    gateway  ,   docker-. <br><br>   ,   Testcontainers   API. ,   Testcontainers    docker-java-,     .    «» docker-: <br><br><pre> <code class="bash hljs">val client: com.github.dockerjava.api.DockerClient = DockerClientFactory .instance .client val networkInfo: com.github.dockerjava.api.model.Network = client .inspectNetworkCmd() .withNetworkId(network.getId) .<span class="hljs-built_in"><span class="hljs-built_in">exec</span></span>() val hostIp: String = networkInfo .getIpam .getConfig .get(0) .getGateway</code> </pre> <br> -,   <code>DockerClient</code> .  Testcontainers  <code>DockerClientFactory</code>  .  c  <code>inspectNetworkCmd</code> .   ,  info,  gateway. <br><br>      ,      ,   . <br><br>       —    . Docker    : Windows, Mac,   .        Linux.     ,  ,     Linux      . <br><br>  ,    Testcontainers    .         ,      docker-.    : <br><br><pre> <code class="bash hljs">Testcontainers.exposeHostPorts(sparkJobServerMockPort)</code> </pre> <br> ,      <strong>  </strong> .        docker-.        <code>`host.testcontainers.internal`</code> . <br><br>  ,    : <br><br><pre> <code class="bash hljs">val sparkJobServerMockHost = <span class="hljs-string"><span class="hljs-string">"host.testcontainers.internal"</span></span> val sparkJobServerMockPort = 33333 Testcontainers.exposeHostPorts(sparkJobServerPort) AppContainer(sparkJobServerMockHost, sparkJobServerMockPort)</code> </pre> <br><br><h3>  Testcontainers </h3><br>    ,  ,     Testcontainers   ,      .   Java-,   Scala-.       : <br><br><ul><li>          . , testcontainers-java    JUnit,  testcontainers-scala   ScalaTest,   testcontainers-java       .  Scala-    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> Scala </a> .      .    ,    .  ,   predefined         Java-.        ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  API</a> .        API,          . ,      .    ,       ,   . </li></ul><br><h2>  Résumé </h2><br>     . Docker ,      ,      ,     ,   network gateway. <br><br> Testcontainers —   ,    . API   ,      . <br><br>     Java-,        .      —     .     . <br><br>        ,    docker-,         . <br><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"> <strong><em>—       ,       , ,     . .?</em></strong> <br><br> ,    . <br><br> <strong><em>—   -     ?</em></strong> <br><br>     Kubernetes,     .      end-to-end ,    ,    ,   ,   . <br><br>      ,   ,       unit-,            . <br><br> <strong><em>—         Kubernetes    ?</em></strong> <br><br> -,  ,  -,   ,     ,        ,    Spark  Kubernetes   ;       ,       . <br><br> ,       ,      unit-,   , ,  break point  ,       ,    . <br><br> ,   ,  ,   CI  ,      . <br><br>  ,       minicube —     Mac, .       ,      ,   ,   ,  . <br><br> <strong><em>—     ?       :  master? ,    - ,  ,   2.1,    2.2,   ?</em></strong> <br><br>    ImageName,   Postgres 9.6. <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>)</code> </pre> <br>    9.6,     10.    [ ],     . <br><br>      Image tag —   , —       ,        .    ,    latest   . <br><br> <strong><em>— ,           ?</em></strong> <br><br> ,  CI    ,  GitLab CI , ,  Branch Name. <br><br> <strong><em>—  ,      ,    ,   ?     - ,      ?    20-   ,   ?</em></strong> <br><br> -,       ,        .      ,      ,  ,  ,     ,  . <br><br> -      ,    ,    full-time ,   ,      ,  . <br><br>      commit',       , ,      ,    Android, iOS  . .    ,       ,  ,   , —   . <br><br>     ,  ,      -: -  , - . , -    . <br></div></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous voulez plus de détails sur les microservices eux-mêmes et pas seulement sur Scala - notre programme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScalaConf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a des réponses à diverses questions. </font><font style="vertical-align: inherit;">Plus intéressés par l'architecture et les interconnexions de ses différentes parties - venez à </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HighLoad ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> les 7 et 8 novembre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout est si savoureux, et on ne sait pas quoi choisir, alors abonnez-vous à la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">newsletter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans laquelle nous parlons de rapports et collectons des documents utiles sur le sujet.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464307/">https://habr.com/ru/post/fr464307/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464293/index.html">Les crochets se remplacent-ils dans React Redux?</a></li>
<li><a href="../fr464295/index.html">Exemples d'utilisation de nouvelles fonctionnalités JavaScript</a></li>
<li><a href="../fr464299/index.html">0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 0, 2, 6, 5, 4, 0, 5, 3, 0, 3, 2, 9, 0, 4, 9, 3, 6, 14, 0, 6, 3, 5, 15, 0, 5, 3, 5 ...</a></li>
<li><a href="../fr464303/index.html">Données de séries chronologiques dans un SGBD relationnel. Extensions TimescaleDB et PipelineDB pour PostgreSQL</a></li>
<li><a href="../fr464305/index.html">Petit, oui. Déballage du pétard microvirtuel</a></li>
<li><a href="../fr464309/index.html">Bouton d'appel bricolage. Raspberry Pi, MajorDoMo, Freeswitch et Linphonec</a></li>
<li><a href="../fr464315/index.html">Le film dans lequel il y avait de la terre. Recherche sur Yandex et bref historique de la recherche par sens</a></li>
<li><a href="../fr464317/index.html">Projet Konbanwa</a></li>
<li><a href="../fr464325/index.html">Comment Scrumban unit le meilleur des méthodologies Kanban et Scrum</a></li>
<li><a href="../fr464327/index.html">Comparaison de l'utilisation de la mémoire des différentes interfaces graphiques de la boîte à outils</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>