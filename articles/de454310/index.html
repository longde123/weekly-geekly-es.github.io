<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚öïÔ∏è ü•É üïò Generischer Verschluss in Rust ‚õπüèº üë©üèæ‚Äçüíº üëèüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem kurzen Artikel werde ich √ºber ein Muster in Rust sprechen, mit dem Sie einen Typ, der eine generische Methode durchl√§uft, f√ºr die sp√§tere Ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generischer Verschluss in Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454310/"><p><img src="https://habrastorage.org/webt/jc/35/qj/jc35qjpmk7ypmaece7ki1xpzsz8.jpeg"></p><br><p>  In diesem kurzen Artikel werde ich √ºber ein Muster in Rust sprechen, mit dem Sie einen Typ, der eine generische Methode durchl√§uft, f√ºr die sp√§tere Verwendung "speichern" k√∂nnen.  Dieses Muster befindet sich in den Quellbibliotheken von Rust-Bibliotheken und wird manchmal auch in meinen Projekten verwendet.  Ich konnte im Netzwerk keine Ver√∂ffentlichungen √ºber ihn finden und gab ihm meinen Namen: "Generalized Type Closure". In diesem Artikel m√∂chte ich Ihnen sagen, was es ist, warum und wie es verwendet werden kann. </p><a name="habracut"></a><br><h2 id="problema">  Das Problem </h2><br><p>  In Rust reichen ein entwickeltes statisches Typsystem und seine statischen F√§higkeiten f√ºr wahrscheinlich 80% der F√§lle aus.  Es kommt jedoch vor, dass eine dynamische Eingabe erforderlich ist, wenn Sie Objekte unterschiedlichen Typs an derselben Stelle speichern m√∂chten.  Zeichentyp-Objekte helfen hier: Sie l√∂schen die realen Objekttypen, reduzieren sie auf eine bestimmte allgemeine Schnittstelle, die vom Typ definiert wird, und dann k√∂nnen Sie diese Objekte als dieselben Typ-Typ-Objekte bearbeiten. </p><br><p> Dies funktioniert in der H√§lfte der verbleibenden F√§lle gut.  Was aber, wenn wir die gel√∂schten Objekttypen bei ihrer Verwendung noch wiederherstellen m√ºssen?  Zum Beispiel, wenn das Verhalten unserer Objekte durch einen Typ bestimmt wird, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht als Typobjekt verwendet werden kann</a> .  Dies ist eine h√§ufige Situation f√ºr Merkmale mit zugeh√∂rigen Typen.  Was ist in diesem Fall zu tun? </p><br><h2 id="reshenie">  L√∂sung </h2><br><p> F√ºr alle <code>'static</code> Typen (dh Typen, die keine nicht statischen Links enthalten) implementiert Rust den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Any</code></a> Typ, der die Konvertierung des <code>dyn Any</code> Typ-Objekts in einen Verweis auf den urspr√ºnglichen Objekttyp erm√∂glicht: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = <span class="hljs-string"><span class="hljs-string">"test"</span></span>.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value_any = &amp;value <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &amp;dyn Any; <span class="hljs-comment"><span class="hljs-comment">//       String.  //   -      . if let Some(as_string) = value_any.downcast_ref::&lt;String&gt;() { println!("String: {}", as_string); } else { println!("Unknown type"); }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  <code>Box</code> hat zu diesem Zweck auch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>downcast</code></a> Methode. </p><br><p>  Diese L√∂sung eignet sich f√ºr F√§lle, in denen der Quellentyp am Arbeitsort bekannt ist.  Aber was ist, wenn es nicht so ist?  Was ist, wenn der aufrufende Code den Quelltyp des Objekts anstelle seiner Verwendung einfach nicht kennt?  Dann m√ºssen wir uns irgendwie an den Originaltyp erinnern, ihn dort ablegen, wo er definiert ist, und ihn zusammen mit dem <code>dyn Any</code> Typ-Objekt speichern, damit dieser sp√§ter an der richtigen Stelle in den Originaltyp konvertiert wird. </p><br><p>  Verallgemeinerte Typen in Rust k√∂nnen als Typvariablen behandelt werden, an die der eine oder andere Typwert beim Aufruf √ºbergeben werden kann.  In Rust gibt es jedoch keine M√∂glichkeit, sich an diesen Typ f√ºr die weitere Verwendung an anderer Stelle zu erinnern.  Es gibt jedoch eine M√∂glichkeit, sich alle Funktionen dieses Typs zusammen mit diesem Typ zu merken.  Dies ist die Idee des Musters "Schlie√üen eines verallgemeinerten Typs": Code, der einen Typ verwendet, wird in Form eines Verschlusses ausgef√ºhrt, der als normale Funktion gespeichert wird, da au√üer verallgemeinerten Typen keine Objekte der Umgebung verwendet werden. </p><br><h2 id="realizaciya">  Implementierung </h2><br><p>  Schauen wir uns ein Implementierungsbeispiel an.  Angenommen, wir m√∂chten einen rekursiven Baum erstellen, der eine Hierarchie von Grafikobjekten darstellt, in der jeder Knoten entweder ein Grafikprimitiv mit untergeordneten Knoten oder eine Komponente sein kann - ein separater Baum von Grafikobjekten: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span> { Prim(Primitive), Comp(Component), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Primitive</span></span></span></span> { shape: Shape, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Node&gt;, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span> { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Node&gt;, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span></span> { Rectangle, Circle, }</code> </pre> <br><p>  <code>Node</code> in der <code>Component</code> ist erforderlich, da die <code>Component</code> selbst im <code>Node</code> . </p><br><p>  Nehmen wir nun an, unser Baum ist nur eine Darstellung eines Modells, mit dem er verkn√ºpft werden soll.  Dar√ºber hinaus hat jede Komponente ein eigenes Modell: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Primitive</span></span></span></span>&lt;Model&gt; { shape: Shape, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Node&lt;Model&gt;&gt;, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span>&lt;Model&gt; { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Node&lt;Model&gt;&gt;, model: Model, <span class="hljs-comment"><span class="hljs-comment">//   Model }</span></span></code> </pre> <br><p>  Wir k√∂nnten schreiben: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;Model&gt; { Prim(Primitive&lt;Model&gt;), Comp(Component&lt;Model&gt;), }</code> </pre> <br><p>  Dieser Code funktioniert jedoch nicht wie erforderlich.  Weil die Komponente ein eigenes Modell haben muss und nicht das Modell des √ºbergeordneten Elements, das die Komponente enth√§lt.  Das hei√üt, wir brauchen: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;Model&gt; { Prim(Primitive&lt;Model&gt;), Comp(Component), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Primitive</span></span></span></span>&lt;Model&gt; { shape: Shape, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Node&lt;Model&gt;&gt;, _model: PhantomData&lt;Model&gt;, <span class="hljs-comment"><span class="hljs-comment">//   Model } struct Component { node: Box&lt;dyn Any&gt;, model: Box&lt;dyn Any&gt;, } impl Component { fn new&lt;Model: 'static&gt;(node: Node&lt;Model&gt;, model: Model) -&gt; Self { Self { node: Box::new(node), model: Box::new(model), } } }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  Wir haben die Angabe eines bestimmten Modelltyps auf die <code>new</code> Methode verschoben und in der Komponente selbst das Modell und den Teilbaum bereits mit gel√∂schten Typen gespeichert. </p><br><p>  <code>use_model</code> nun die <code>use_model</code> Methode hinzu, die das Modell verwendet, jedoch nicht nach Typ parametrisiert wird: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span> { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Any&gt;, model: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Any&gt;, use_model_closure: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(&amp;Component), } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Component { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>&lt;Model: <span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt;(node: Node&lt;Model&gt;, model: Model) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> use_model_closure = |comp: &amp;Component| { comp.model.downcast_ref::&lt;Model&gt;().unwrap(); }; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(node), model: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(model), use_model_closure, } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_model</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.use_model_closure)(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  Beachten Sie, dass wir in der Komponente einen Zeiger auf eine Funktion speichern, die in der <code>new</code> Methode mithilfe der Syntax zum Definieren eines Abschlusses erstellt wird.  Alles, was von au√üen erfasst werden sollte, ist der <code>Model</code> . Daher m√ºssen wir √ºber ein Argument einen Link zur Komponente selbst an diese Funktion √ºbergeben. </p><br><blockquote>  Es scheint, dass wir anstelle des Abschlusses eine interne Funktion verwenden k√∂nnen, aber ein solcher Code wird nicht kompiliert.  Weil die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interne Funktion in Rust keine verallgemeinerten Typen von der externen erfassen kann</a> , da sie sich nur in der Sichtbarkeit von der √ºblichen Funktion der obersten Ebene unterscheidet. </blockquote><p>  Die <code>use_model</code> Methode kann <code>use_model</code> in einem Kontext verwendet werden, in dem der tats√§chliche <code>use_model</code> unbekannt ist.  Zum Beispiel in einer rekursiven Baumdurchquerung, die aus vielen verschiedenen Komponenten mit verschiedenen Modellen besteht. </p><br><h2 id="alternativa">  Alternative </h2><br><p>  Wenn es m√∂glich ist, die Schnittstelle der Komponente auf einen Typ zu √ºbertragen, mit dem ein Typobjekt erstellt werden kann, ist es besser, dies zu tun und stattdessen die Komponente selbst zu verwenden, um das Typobjekt zu bearbeiten: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;Model&gt; { Prim(Primitive&lt;Model&gt;), Comp(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn ComponentApi&gt;), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span>&lt;Model&gt; { node: Node&lt;Model&gt;, model: Model, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Model&gt; Component&lt;Model&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(node: Node&lt;Model&gt;, model: Model) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { node, model, } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentApi</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_model</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Model&gt; ComponentApi <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Component&lt;Model&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_model</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.model; } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Es stellt sich heraus, dass Schlie√üungen in Rust nicht nur Umgebungsobjekte, sondern auch Typen erfassen k√∂nnen.  Sie k√∂nnen jedoch als gew√∂hnliche Funktionen interpretiert werden.  Diese Eigenschaft ist n√ºtzlich, wenn Sie einheitlich mit verschiedenen Typen arbeiten m√ºssen, ohne Informationen dar√ºber zu verlieren, wenn Zeichentypen nicht anwendbar sind. </p><br><p>  Ich hoffe, dieser Artikel hilft Ihnen bei der Verwendung von Rust.  Teilen Sie Ihre Gedanken in den Kommentaren. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454310/">https://habr.com/ru/post/de454310/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454300/index.html">Wie unterscheiden sich CTTs von herk√∂mmlichen Heatpipes und wie werden sie angewendet?</a></li>
<li><a href="../de454302/index.html">QVD-Dateien - was drin ist</a></li>
<li><a href="../de454304/index.html">DIY 3D-Drucker f√ºr Keramik zum Selbermachen</a></li>
<li><a href="../de454306/index.html">F√ºnf Fehler, die ich als Hauptentwickler gemacht habe</a></li>
<li><a href="../de454308/index.html">AMA mit Habr. V.9.0. Podcast, Konferenz und Konzepte</a></li>
<li><a href="../de454312/index.html">Verwendung der jQuery-Bibliothek mit Angular Framework (wenn dies wirklich erforderlich ist)</a></li>
<li><a href="../de454314/index.html">10 Prinzipien der objektorientierten Programmierung, die jeder Entwickler kennen sollte</a></li>
<li><a href="../de454316/index.html">Auf den Spuren des industriellen Ninja: Wir laden Sie ein, am Online-Wettbewerb f√ºr Arbeitssicherheit teilzunehmen</a></li>
<li><a href="../de454318/index.html">Die Vergangenheit klingen lassen. Ein Leitfaden f√ºr Historiker zur Konvertierung von Daten in Ton</a></li>
<li><a href="../de454320/index.html">Arbeitsmarktanalysten und Datenwissenschaftler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>