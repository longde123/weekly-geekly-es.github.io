<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍⚕️ 🥃 🕘 Generischer Verschluss in Rust ⛹🏼 👩🏾‍💼 👏🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem kurzen Artikel werde ich über ein Muster in Rust sprechen, mit dem Sie einen Typ, der eine generische Methode durchläuft, für die spätere Ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generischer Verschluss in Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454310/"><p><img src="https://habrastorage.org/webt/jc/35/qj/jc35qjpmk7ypmaece7ki1xpzsz8.jpeg"></p><br><p>  In diesem kurzen Artikel werde ich über ein Muster in Rust sprechen, mit dem Sie einen Typ, der eine generische Methode durchläuft, für die spätere Verwendung "speichern" können.  Dieses Muster befindet sich in den Quellbibliotheken von Rust-Bibliotheken und wird manchmal auch in meinen Projekten verwendet.  Ich konnte im Netzwerk keine Veröffentlichungen über ihn finden und gab ihm meinen Namen: "Generalized Type Closure". In diesem Artikel möchte ich Ihnen sagen, was es ist, warum und wie es verwendet werden kann. </p><a name="habracut"></a><br><h2 id="problema">  Das Problem </h2><br><p>  In Rust reichen ein entwickeltes statisches Typsystem und seine statischen Fähigkeiten für wahrscheinlich 80% der Fälle aus.  Es kommt jedoch vor, dass eine dynamische Eingabe erforderlich ist, wenn Sie Objekte unterschiedlichen Typs an derselben Stelle speichern möchten.  Zeichentyp-Objekte helfen hier: Sie löschen die realen Objekttypen, reduzieren sie auf eine bestimmte allgemeine Schnittstelle, die vom Typ definiert wird, und dann können Sie diese Objekte als dieselben Typ-Typ-Objekte bearbeiten. </p><br><p> Dies funktioniert in der Hälfte der verbleibenden Fälle gut.  Was aber, wenn wir die gelöschten Objekttypen bei ihrer Verwendung noch wiederherstellen müssen?  Zum Beispiel, wenn das Verhalten unserer Objekte durch einen Typ bestimmt wird, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht als Typobjekt verwendet werden kann</a> .  Dies ist eine häufige Situation für Merkmale mit zugehörigen Typen.  Was ist in diesem Fall zu tun? </p><br><h2 id="reshenie">  Lösung </h2><br><p> Für alle <code>'static</code> Typen (dh Typen, die keine nicht statischen Links enthalten) implementiert Rust den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Any</code></a> Typ, der die Konvertierung des <code>dyn Any</code> Typ-Objekts in einen Verweis auf den ursprünglichen Objekttyp ermöglicht: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = <span class="hljs-string"><span class="hljs-string">"test"</span></span>.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value_any = &amp;value <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &amp;dyn Any; <span class="hljs-comment"><span class="hljs-comment">//       String.  //   -      . if let Some(as_string) = value_any.downcast_ref::&lt;String&gt;() { println!("String: {}", as_string); } else { println!("Unknown type"); }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  <code>Box</code> hat zu diesem Zweck auch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>downcast</code></a> Methode. </p><br><p>  Diese Lösung eignet sich für Fälle, in denen der Quellentyp am Arbeitsort bekannt ist.  Aber was ist, wenn es nicht so ist?  Was ist, wenn der aufrufende Code den Quelltyp des Objekts anstelle seiner Verwendung einfach nicht kennt?  Dann müssen wir uns irgendwie an den Originaltyp erinnern, ihn dort ablegen, wo er definiert ist, und ihn zusammen mit dem <code>dyn Any</code> Typ-Objekt speichern, damit dieser später an der richtigen Stelle in den Originaltyp konvertiert wird. </p><br><p>  Verallgemeinerte Typen in Rust können als Typvariablen behandelt werden, an die der eine oder andere Typwert beim Aufruf übergeben werden kann.  In Rust gibt es jedoch keine Möglichkeit, sich an diesen Typ für die weitere Verwendung an anderer Stelle zu erinnern.  Es gibt jedoch eine Möglichkeit, sich alle Funktionen dieses Typs zusammen mit diesem Typ zu merken.  Dies ist die Idee des Musters "Schließen eines verallgemeinerten Typs": Code, der einen Typ verwendet, wird in Form eines Verschlusses ausgeführt, der als normale Funktion gespeichert wird, da außer verallgemeinerten Typen keine Objekte der Umgebung verwendet werden. </p><br><h2 id="realizaciya">  Implementierung </h2><br><p>  Schauen wir uns ein Implementierungsbeispiel an.  Angenommen, wir möchten einen rekursiven Baum erstellen, der eine Hierarchie von Grafikobjekten darstellt, in der jeder Knoten entweder ein Grafikprimitiv mit untergeordneten Knoten oder eine Komponente sein kann - ein separater Baum von Grafikobjekten: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span> { Prim(Primitive), Comp(Component), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Primitive</span></span></span></span> { shape: Shape, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Node&gt;, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span> { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Node&gt;, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span></span> { Rectangle, Circle, }</code> </pre> <br><p>  <code>Node</code> in der <code>Component</code> ist erforderlich, da die <code>Component</code> selbst im <code>Node</code> . </p><br><p>  Nehmen wir nun an, unser Baum ist nur eine Darstellung eines Modells, mit dem er verknüpft werden soll.  Darüber hinaus hat jede Komponente ein eigenes Modell: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Primitive</span></span></span></span>&lt;Model&gt; { shape: Shape, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Node&lt;Model&gt;&gt;, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span>&lt;Model&gt; { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Node&lt;Model&gt;&gt;, model: Model, <span class="hljs-comment"><span class="hljs-comment">//   Model }</span></span></code> </pre> <br><p>  Wir könnten schreiben: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;Model&gt; { Prim(Primitive&lt;Model&gt;), Comp(Component&lt;Model&gt;), }</code> </pre> <br><p>  Dieser Code funktioniert jedoch nicht wie erforderlich.  Weil die Komponente ein eigenes Modell haben muss und nicht das Modell des übergeordneten Elements, das die Komponente enthält.  Das heißt, wir brauchen: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;Model&gt; { Prim(Primitive&lt;Model&gt;), Comp(Component), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Primitive</span></span></span></span>&lt;Model&gt; { shape: Shape, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Node&lt;Model&gt;&gt;, _model: PhantomData&lt;Model&gt;, <span class="hljs-comment"><span class="hljs-comment">//   Model } struct Component { node: Box&lt;dyn Any&gt;, model: Box&lt;dyn Any&gt;, } impl Component { fn new&lt;Model: 'static&gt;(node: Node&lt;Model&gt;, model: Model) -&gt; Self { Self { node: Box::new(node), model: Box::new(model), } } }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  Wir haben die Angabe eines bestimmten Modelltyps auf die <code>new</code> Methode verschoben und in der Komponente selbst das Modell und den Teilbaum bereits mit gelöschten Typen gespeichert. </p><br><p>  <code>use_model</code> nun die <code>use_model</code> Methode hinzu, die das Modell verwendet, jedoch nicht nach Typ parametrisiert wird: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span> { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Any&gt;, model: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Any&gt;, use_model_closure: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(&amp;Component), } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Component { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>&lt;Model: <span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt;(node: Node&lt;Model&gt;, model: Model) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> use_model_closure = |comp: &amp;Component| { comp.model.downcast_ref::&lt;Model&gt;().unwrap(); }; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(node), model: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(model), use_model_closure, } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_model</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.use_model_closure)(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  Beachten Sie, dass wir in der Komponente einen Zeiger auf eine Funktion speichern, die in der <code>new</code> Methode mithilfe der Syntax zum Definieren eines Abschlusses erstellt wird.  Alles, was von außen erfasst werden sollte, ist der <code>Model</code> . Daher müssen wir über ein Argument einen Link zur Komponente selbst an diese Funktion übergeben. </p><br><blockquote>  Es scheint, dass wir anstelle des Abschlusses eine interne Funktion verwenden können, aber ein solcher Code wird nicht kompiliert.  Weil die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interne Funktion in Rust keine verallgemeinerten Typen von der externen erfassen kann</a> , da sie sich nur in der Sichtbarkeit von der üblichen Funktion der obersten Ebene unterscheidet. </blockquote><p>  Die <code>use_model</code> Methode kann <code>use_model</code> in einem Kontext verwendet werden, in dem der tatsächliche <code>use_model</code> unbekannt ist.  Zum Beispiel in einer rekursiven Baumdurchquerung, die aus vielen verschiedenen Komponenten mit verschiedenen Modellen besteht. </p><br><h2 id="alternativa">  Alternative </h2><br><p>  Wenn es möglich ist, die Schnittstelle der Komponente auf einen Typ zu übertragen, mit dem ein Typobjekt erstellt werden kann, ist es besser, dies zu tun und stattdessen die Komponente selbst zu verwenden, um das Typobjekt zu bearbeiten: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;Model&gt; { Prim(Primitive&lt;Model&gt;), Comp(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn ComponentApi&gt;), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span>&lt;Model&gt; { node: Node&lt;Model&gt;, model: Model, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Model&gt; Component&lt;Model&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(node: Node&lt;Model&gt;, model: Model) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { node, model, } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentApi</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_model</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Model&gt; ComponentApi <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Component&lt;Model&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_model</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.model; } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Es stellt sich heraus, dass Schließungen in Rust nicht nur Umgebungsobjekte, sondern auch Typen erfassen können.  Sie können jedoch als gewöhnliche Funktionen interpretiert werden.  Diese Eigenschaft ist nützlich, wenn Sie einheitlich mit verschiedenen Typen arbeiten müssen, ohne Informationen darüber zu verlieren, wenn Zeichentypen nicht anwendbar sind. </p><br><p>  Ich hoffe, dieser Artikel hilft Ihnen bei der Verwendung von Rust.  Teilen Sie Ihre Gedanken in den Kommentaren. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454310/">https://habr.com/ru/post/de454310/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454300/index.html">Wie unterscheiden sich CTTs von herkömmlichen Heatpipes und wie werden sie angewendet?</a></li>
<li><a href="../de454302/index.html">QVD-Dateien - was drin ist</a></li>
<li><a href="../de454304/index.html">DIY 3D-Drucker für Keramik zum Selbermachen</a></li>
<li><a href="../de454306/index.html">Fünf Fehler, die ich als Hauptentwickler gemacht habe</a></li>
<li><a href="../de454308/index.html">AMA mit Habr. V.9.0. Podcast, Konferenz und Konzepte</a></li>
<li><a href="../de454312/index.html">Verwendung der jQuery-Bibliothek mit Angular Framework (wenn dies wirklich erforderlich ist)</a></li>
<li><a href="../de454314/index.html">10 Prinzipien der objektorientierten Programmierung, die jeder Entwickler kennen sollte</a></li>
<li><a href="../de454316/index.html">Auf den Spuren des industriellen Ninja: Wir laden Sie ein, am Online-Wettbewerb für Arbeitssicherheit teilzunehmen</a></li>
<li><a href="../de454318/index.html">Die Vergangenheit klingen lassen. Ein Leitfaden für Historiker zur Konvertierung von Daten in Ton</a></li>
<li><a href="../de454320/index.html">Arbeitsmarktanalysten und Datenwissenschaftler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>