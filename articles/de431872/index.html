<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úñÔ∏è üëåüèø ü•ï JavaScript-Handbuch Teil 9: √úbersicht √ºber die ES7-, ES8- und ES9-Standards üí≤ üßô ‚ÜïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute, im neunten Teil der √úbersetzung des JavaScript-Handbuchs, wird ein √úberblick √ºber die Funktionen gegeben, die dank der Standards ES7, ES8 und E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Handbuch Teil 9: √úbersicht √ºber die ES7-, ES8- und ES9-Standards</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431872/">  Heute, im neunten Teil der √úbersetzung des JavaScript-Handbuchs, wird ein √úberblick √ºber die Funktionen gegeben, die dank der Standards ES7, ES8 und ES9 in der Sprache erschienen sind. <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Erstes Programm, Sprachfunktionen, Standards</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Codestil und Programmstruktur</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Variablen, Datentypen, Ausdr√ºcke, Objekte</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Funktionen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5: Arrays und Loops</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 6: Ausnahmen, Semikolons, Platzhalterliterale</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 7: Strict Mode, dieses Schl√ºsselwort, Ereignisse, Module, mathematische Berechnungen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 8: √úbersicht √ºber die ES6-Funktionen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 9: √úbersicht √ºber die ES7-, ES8- und ES9-Standards</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">ES7 Standard</font> </h2><br>  Der ES7-Standard, der gem√§√ü der offiziellen Terminologie ES2016 hei√üt, wurde im Sommer 2016 ver√∂ffentlicht.  Er, im Vergleich zu ES6, in die Sprache gebracht, ist nicht viel neu.  Insbesondere sprechen wir √ºber Folgendes: <br><br><ul><li> <code>Array.prototype.includes()</code> -Methode. </li><li>  Potenzierungsoperator. </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Methode Array.prototype.includes ()</font> </h3><br>  Die Methode <code>Array.prototype.includes()</code> dient zum √úberpr√ºfen des Vorhandenseins eines Elements im Array.  Wenn Sie das gew√ºnschte Element im Array finden, wird <code>true</code> , nicht - <code>false</code> .  Vor ES7 wurde die Methode <code>indexOf()</code> verwendet, um dieselbe Operation auszuf√ºhren. Wenn ein Element gefunden wird, wird der erste Index zur√ºckgegeben, anhand dessen es im Array gefunden werden kann.  Wenn <code>indexOf()</code> das Element nicht findet, gibt es die Zahl <code>-1</code> . <br><br>  Gem√§√ü den Konvertierungsregeln f√ºr JavaScript-Typen wird die Zahl <code>-1</code> in <code>true</code> konvertiert.  <code>indexOf()</code> die Ergebnisse der Operation von <code>indexOf()</code> zu √ºberpr√ºfen <code>indexOf()</code> sollte daher eine nicht besonders bequeme Konstruktion der folgenden Form verwendet werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">3</span></span>) === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Not found'</span></span>) }</code> </pre> <br>  Wenn in einer √§hnlichen Situation unter der Annahme, dass <code>indexOf()</code> , ohne ein Element zu finden, <code>false</code> zur√ºckgibt, etwas wie das unten gezeigte verwendet wird, funktioniert der Code nicht richtig. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">3</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// console.log('Not found') }</span></span></code> </pre> <br>  In diesem Fall stellt sich heraus, dass die Konstruktion <code>![1,2].indexOf(3)</code> <code>false</code> ergibt. <br><br>  Mit der <code>includes()</code> -Methode sehen solche Vergleiche viel logischer aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].includes(<span class="hljs-number"><span class="hljs-number">3</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Not found'</span></span>) }</code> </pre> <br>  In diesem Fall gibt die Konstruktion <code>[1,2].includes(3)</code> <code>false</code> , dieser Wert ist ein Operator <code>!</code>  wird auf <code>true</code> und die Konsole erh√§lt eine Meldung, dass das Element im Array nicht gefunden wurde. <br><br><h3>  <font color="#3AC1EF">‚ñç Potenzierungsoperator</font> </h3><br>  Der Exponentiationsoperator f√ºhrt dieselbe Funktion wie die <code>Math.pow()</code> -Methode aus, ist jedoch bequemer als eine Bibliotheksfunktion, da sie Teil der Sprache ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">4</span></span> ** <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br>  Dieser Operator kann als angenehme Erg√§nzung zu JS angesehen werden, was in Anwendungen n√ºtzlich ist, die bestimmte Berechnungen durchf√ºhren.  Ein √§hnlicher Operator existiert in anderen Programmiersprachen. <br><br><h2>  <font color="#3AC1EF">ES8 Standard</font> </h2><br>  Der ES8-Standard (ES2017) wurde 2017 ver√∂ffentlicht.  Er brachte wie ES7 nicht viel in die Sprache.  Wir sprechen n√§mlich √ºber die folgenden Merkmale: <br><br><ul><li>  Hinzuf√ºgen von Zeichenfolgen zu einer bestimmten L√§nge. </li><li>  Methode <code>Object.values()</code> . </li><li>  Methode <code>Object.entries()</code> . </li><li>  Methode <code>Object.getOwnPropertyDescriptors()</code> . </li><li>  Nachgestellte Kommas in Funktionsparametern. </li><li>  Asynchrone Funktionen. </li><li>  Arbeiten Sie mit Shared Memory und atomaren Operationen. </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Hinzuf√ºgen von Zeilen zu einer bestimmten L√§nge</font> </h3><br>  ES8 f√ºhrte zwei neue <code>String</code> Objektmethoden ein - <code>padStart()</code> und <code>padEnd()</code> . <br><br>  Die <code>padStart()</code> -Methode f√ºllt die aktuelle Zeile mit einer weiteren Zeile, bis die letzte Zeile die gew√ºnschte L√§nge erreicht hat.  Das Bef√ºllen erfolgt am Zeilenanfang (links).  Hier erfahren Sie, wie Sie diese Methode verwenden. <br><br><pre> <code class="javascript hljs">str.padStart(targetLength [, padString])</code> </pre> <br>  Hier ist <code>str</code> die aktuelle Zeile, <code>targetLength</code> die L√§nge der letzten Zeile (wenn sie kleiner als die L√§nge der aktuellen Zeile ist, wird diese Zeile ohne √Ñnderungen zur√ºckgegeben), <code>padString</code> ist ein optionaler Parameter - die Zeile, die zum F√ºllen der aktuellen Zeile verwendet wird.  Wenn <code>padString</code> nicht angegeben ist, wird ein Leerzeichen verwendet, <code>padString</code> aktuelle Zeile auf die angegebene L√§nge <code>padString</code> . <br><br>  Die <code>padEnd()</code> -Methode √§hnelt <code>padStart()</code> , die Zeile wird jedoch rechts ausgef√ºllt. <br><br>  Betrachten Sie Beispiele f√ºr die Verwendung dieser Methoden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">'test'</span></span>.padStart(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str1 = <span class="hljs-string"><span class="hljs-string">'test'</span></span>.padEnd(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-string"><span class="hljs-string">'*'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">'`</span></span>) <span class="hljs-comment"><span class="hljs-comment">//'      test' console.log(`'${str1}'`) //'test******'</span></span></code> </pre> <br>  Hier wurden bei Verwendung von <code>padStart()</code> mit nur der gew√ºnschten L√§nge der resultierenden Zeichenfolge Leerzeichen am Anfang der urspr√ºnglichen Zeichenfolge hinzugef√ºgt.  Bei Verwendung von <code>padEnd()</code> mit der L√§nge der letzten Zeile und der zu f√ºllenden Zeile wurden die Zeichen <code>*</code> am Ende der urspr√ºnglichen Zeile hinzugef√ºgt. <br><br><h3>  <font color="#3AC1EF">‚ñç Methode Object.values ‚Äã‚Äã()</font> </h3><br>  Diese Methode gibt ein Array zur√ºck, das die Werte der eigenen Eigenschaften des Objekts enth√§lt, dh die Eigenschaften, die das Objekt selbst enth√§lt, und nicht diejenigen, auf die es √ºber die Prototypkette zugreifen kann. <br><br>  Hier erfahren Sie, wie Sie es verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personValues = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(personValues) <span class="hljs-comment"><span class="hljs-comment">// ['Fred', 87]</span></span></code> </pre> <br>  Diese Methode gilt auch f√ºr Arrays. <br><br><h3>  <font color="#3AC1EF">‚ñç Methode Object.entries ()</font> </h3><br>  Diese Methode gibt ein Array zur√ºck, von dem jedes Element auch ein Array ist, das im Format <code>[key, value]</code> Schl√ºssel und Werte der eigenen Eigenschaften des Objekts enth√§lt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personValues = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(personValues) <span class="hljs-comment"><span class="hljs-comment">// [['name', 'Fred'], ['age', 87]]</span></span></code> </pre> <br>  Wenn Sie diese Methode auf Arrays anwenden, werden die Indizes der Elemente als Schl√ºssel angezeigt, und was im Array an den entsprechenden Indizes gespeichert ist, wird als Werte angezeigt. <br><br><h3>  <font color="#3AC1EF">‚ñç Methode getOwnPropertyDescriptors ()</font> </h3><br>  Diese Methode gibt Informationen zu allen Eigenschaften des Objekts zur√ºck.  Attributmengen (Deskriptoren) sind Objekteigenschaften zugeordnet.  Insbesondere sprechen wir √ºber die folgenden Attribute: <br><br><ul><li>  <code>value</code> - Der Wert der Eigenschaft des Objekts. </li><li>  <code>writable</code> - enth√§lt <code>true</code> wenn die Eigenschaft ge√§ndert werden kann. </li><li>  <code>get</code> - enth√§lt eine Getter-Funktion, die der Eigenschaft zugeordnet ist, oder, falls keine solche Funktion vorhanden ist, <code>undefined</code> . </li><li>  <code>set</code> - enth√§lt die Setter-Funktion f√ºr die Eigenschaft oder <code>undefined</code> . </li><li>  <code>configurable</code> - wenn es <code>false</code> - die Eigenschaft kann nicht gel√∂scht werden, ihre Attribute k√∂nnen au√üer dem Wert nicht ge√§ndert werden. </li><li>  <code>enumerable</code> - Wenn true in dieser Eigenschaft enthalten ist, ist die <code></code> aufz√§hlbar. </li></ul><br>  Hier erfahren Sie, wie Sie diese Methode verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(obj)</code> </pre> <br>  Es nimmt ein Objekt, dessen Eigenschaftsinformationen Sie herausfinden m√ºssen, und gibt ein Objekt zur√ºck, das diese Informationen enth√§lt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> propDescr = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(propDescr) <span class="hljs-comment"><span class="hljs-comment">/* { name:  { value: 'Fred',    writable: true,    enumerable: true,    configurable: true }, age:  { value: 87,    writable: true,    enumerable: true,    configurable: true } } */</span></span></code> </pre> <br>  Warum wird diese Methode ben√∂tigt?  Tatsache ist, dass Sie damit kleine Kopien von Objekten erstellen und diese kopieren k√∂nnen, zus√§tzlich zu anderen Eigenschaften, Gettern und Setzern.  Dies konnte nicht mit der <code>Object.assign()</code> -Methode durchgef√ºhrt werden, die im ES6-Standard zum Kopieren von Objekten enthalten war. <br><br>  Das folgende Beispiel enth√§lt ein Objekt mit einem Setter, das mithilfe von <code>console.log()</code> anzeigt, was in die entsprechende Eigenschaft geschrieben werden soll. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person1 = { set name(newName) {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(newName) } } person1.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">// x</span></span></code> </pre> <br>  Versuchen wir, dieses Objekt mit der Methode <code>assign()</code> zu kopieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person2 = {} <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(person2, person1) person2.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">//     ,   </span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, funktioniert dieser Ansatz nicht.  Die <code>name</code> Eigenschaft, die der Setter im urspr√ºnglichen Objekt war, wird jetzt als regul√§re Eigenschaft dargestellt. <br><br>  Jetzt kopieren wir das Objekt mit den Methoden <code>Object.defineProperties()</code> (es erschien in ES5.1) und <code>Object.getOwnPropertyDescriptors()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person3 = {} <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperties(person3, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(person1)) person3.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">//x</span></span></code> </pre> <br>  Hier bleibt der Setter in der Kopie des Objekts. <br><br>  Es ist zu beachten, dass die f√ºr <code>Object.assign()</code> spezifischen Einschr√§nkungen auch f√ºr die <code>Object.create()</code> -Methode charakteristisch sind, wenn sie zum Klonen von Objekten verwendet werden. <br><br><h3>  <font color="#3AC1EF">‚ñçVollendungskommas in Funktionsparametern</font> </h3><br>  Mit dieser Funktion k√∂nnen Sie beim Deklarieren und beim Aufrufen von Funktionen ein Komma am Ende der Liste der Parameter bzw. Argumente lassen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> var1, var2, </span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... } doSomething( 'test1', 'test2', )</span></span></code> </pre> <br>  Dies verbessert die Benutzerfreundlichkeit von Versionskontrollsystemen.  Wir sprechen n√§mlich von der Tatsache, dass Sie beim Hinzuf√ºgen neuer Parameter zu einer Funktion den vorhandenen Code nicht nur zum Einf√ºgen eines Kommas √§ndern m√ºssen. <br><br><h3>  <font color="#3AC1EF">‚ñçAsynchrone Funktionen</font> </h3><br>  Das Konstrukt <code>async/await</code> ist im ES2017-Standard enthalten, der als wichtigste Neuerung dieser Sprachversion angesehen werden kann. <br><br>  Asynchrone Funktionen sind eine Kombination aus Versprechungen und Generatoren. Sie vereinfachen Konstruktionen, f√ºr deren Beschreibung zuvor eine gro√üe Menge an Vorlagencode und unbequeme Versprechungsketten erforderlich waren.  In der Tat sprechen wir √ºber eine Abstraktion auf hoher Ebene √ºber Versprechen. <br><br>  Als im ES2015-Standard Versprechungen auftauchten, wurden sie entwickelt, um bestehende Probleme mit asynchronem Code zu l√∂sen, was sie auch taten.  In den zwei Jahren, in denen die Standards ES2015 und ES2017 geteilt wurden, wurde jedoch klar, dass Versprechen nicht als endg√ºltige L√∂sung f√ºr diese Probleme angesehen werden k√∂nnen. <br><br>  Die Versprechen zielten insbesondere darauf ab, das Problem der ‚ÄûR√ºckrufh√∂lle‚Äú zu l√∂sen, aber nachdem sie dieses Problem gel√∂st hatten, zeigten sie selbst aufgrund der Komplexit√§t des Codes, in dem sie verwendet werden, nicht ihre beste Seite.  Tats√§chlich l√∂st die asynchrone <code>async/await</code> Konstruktion das Problem der Versprechen und verbessert die Verwendbarkeit von asynchronem Code. <br><br>  Betrachten Sie ein Beispiel. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {     setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>) }) } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br>  Dieser Code gibt Folgendes an die Konsole aus. <br><br><pre> <code class="javascript hljs">Before After I did something</code> </pre> <br>  Wie Sie sehen, <code>doSomething()</code> Programm nach dem Aufruf von <code>doSomething()</code> weiter ausgef√ºhrt, nachdem <code>Before</code> , Nachher in der Konsole angezeigt wurde und nachdem drei Sekunden vergangen sind, habe <code>I did something</code> . <br><br><h4>  Serieller asynchroner Funktionsaufruf </h4><br>  Bei Bedarf k√∂nnen asynchrone Funktionen so etwas wie Aufrufketten bilden.  Solche Designs zeichnen sich durch eine bessere Lesbarkeit aus als √§hnliche, die ausschlie√ülich auf Versprechungen beruhen.  Dies ist im folgenden Beispiel zu sehen. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">promiseToDoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)=&gt;</span></span>{     setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>) }) } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchOverSomeoneDoingSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchOverSomeoneWatchingSomeoneDoingSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) <span class="hljs-comment"><span class="hljs-comment">// I did something and I watched and I watched as well })</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Shared Memory und atomare Operationen</font> </h3><br>  Hier geht es um das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SharedArrayBuffer-</a> Objekt, mit dem Sie gemeinsam genutzte Speicherbereiche beschreiben k√∂nnen, und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Atomics-</a> Objekt, das eine Reihe von atomaren Operationen in Form statischer Methoden enth√§lt.  Details zu den M√∂glichkeiten, die diese Objekte dem Programmierer bieten, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  <font color="#3AC1EF">ES9 Standard</font> </h2><br>  ES9 (ES2018) ist die neueste Version des Standards zum Zeitpunkt der Ver√∂ffentlichung dieses Materials.  Hier sind die Hauptmerkmale: <br><br><ul><li>  Wenden Sie Spread- und Rest-Anweisungen auf Objekte an. </li><li>  Asynchrone Iteratoren. </li><li>  Methode <code>Promise.prototype.finally()</code> . </li><li>  Verbesserungen des regul√§ren Ausdrucks. </li></ul><br><h3>  <font color="#3AC1EF">‚ñçAnwendung von Spread- und Rest-Operatoren auf Objekte</font> </h3><br>  Wir haben bereits √ºber die √ºbrigen und verbreiteten Operatoren gesprochen, die in ES6 erschienen sind und f√ºr die Arbeit mit Arrays verwendet werden k√∂nnen.  Beide sehen aus wie drei Punkte.  Mit dem Rest-Operator im folgenden Beispiel f√ºr die Destrukturierung eines Arrays k√∂nnen Sie das erste und das zweite Element in die Konstanten <code>first</code> und <code>second</code> und den Rest in die Konstante <code>others</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [first, second, ...others] = numbers <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first) <span class="hljs-comment"><span class="hljs-comment">//1 console.log(second) //2 console.log(others) //[ 3, 4, 5 ]</span></span></code> </pre> <br>  Mit dem <code>spread</code> Operator k√∂nnen Sie Arrays an Funktionen √ºbergeben, die regelm√§√üige Parameterlisten erwarten. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c, d, e</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b + c + d + e <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = sum(...numbers) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) <span class="hljs-comment"><span class="hljs-comment">//15</span></span></code> </pre> <br>  Mit demselben Ansatz k√∂nnen Sie jetzt mit Objekten arbeiten.  Hier ist ein Beispiel f√ºr die Verwendung der rest-Anweisung in einer destruktiven Zuweisungsoperation. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { first, second, ...others } = { <span class="hljs-attr"><span class="hljs-attr">first</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">second</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">third</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">fourth</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">fifth</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first) <span class="hljs-comment"><span class="hljs-comment">//1 console.log(second) //2 console.log(others) //{ third: 3, fourth: 4, fifth: 5 }</span></span></code> </pre> <br>  Hier ist die Spread-Anweisung, die beim Erstellen eines neuen Objekts basierend auf einem vorhandenen Objekt verwendet wird.  Dieses Beispiel setzt das vorherige fort. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> items = { first, second, ...others } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(items) <span class="hljs-comment"><span class="hljs-comment">//{ first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçAsynchrone Iteratoren</font> </h3><br>  Mit dem neuen <code>for-await-of</code> Konstrukt k√∂nnen Sie asynchrone Funktionen aufrufen, die Versprechen in Schleifen zur√ºckgeben.  Solche Schleifen warten auf die L√∂sung des Versprechens, bevor sie mit dem n√§chsten Schritt fortfahren.  So sieht es aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> readLines(filePath)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(line) }</code> </pre> <br>  Gleichzeitig sollte beachtet werden, dass solche Schleifen in asynchronen Funktionen verwendet werden sollten - genauso wie bei der Arbeit mit dem Konstrukt <code>async/await</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Promise.prototype.finally () -Methode</font> </h3><br>  Wenn das Versprechen erfolgreich gel√∂st wurde, wird die n√§chste <code>then()</code> -Methode aufgerufen.  Wenn etwas schief geht, wird die <code>catch()</code> -Methode aufgerufen.  Mit der Methode <code>finally()</code> k√∂nnen Sie Code ausf√ºhren, unabh√§ngig davon, was zuvor passiert ist. <br><br><pre> <code class="javascript hljs">fetch(<span class="hljs-string"><span class="hljs-string">'file.json'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.json()) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error)) .finally(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'finished'</span></span>))</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Verbesserungen des regul√§ren Ausdrucks</font> </h3><br>  Regul√§re Ausdr√ºcke k√∂nnen Zeichenfolgen nachtr√§glich √ºberpr√ºfen ( <code>?&lt;=</code> ).  Auf diese Weise k√∂nnen Sie in den Zeilen nach bestimmten Konstruktionen suchen, vor denen sich einige andere Konstruktionen befinden. <br><br>  Die M√∂glichkeit, √úberpr√ºfungen mit dem Konstrukt <code>?=</code> Vorangehen zu k√∂nnen, war in regul√§ren Ausdr√ºcken vorhanden, die vor dem ES2018-Standard in JavaScript implementiert wurden.  Solche √úberpr√ºfungen zeigen an, ob ein anderes Fragment einem bestimmten Fragment einer Zeile folgt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/Roger(?= Waters)/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//false console.log(res2) //true</span></span></code> </pre> <br>  Bau <code>?!</code>  f√ºhrt die entgegengesetzte Operation aus - eine √úbereinstimmung wird nur gefunden, wenn eine andere Zeile nicht der angegebenen Zeile folgt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/Roger(?! Waters)/g</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//true console.log(res2) //false</span></span></code> </pre> <br>  Bei der nachtr√§glichen √úberpr√ºfung wird, wie bereits erw√§hnt, die Konstruktion <code>?&lt;=</code> Verwendet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;=Roger) Waters/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Pink Waters is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//false console.log(res2) //true</span></span></code> </pre> <br>  Die der beschriebenen entgegengesetzte Operation kann mit der Konstruktion <code>?&lt;!</code>  . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;!Roger) Waters/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Pink Waters is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//true console.log(res2) //false</span></span></code> </pre> <br><h4>  Unicode-Regex-Escape-Sequenzen </h4><br>  In regul√§ren Ausdr√ºcken k√∂nnen Sie die Klasse <code>\d</code> , die einer beliebigen Ziffer entspricht, die Klasse <code>\s</code> , die einem beliebigen Leerzeichen entspricht, die Klasse <code>\w</code> , die einem beliebigen alphanumerischen Zeichen entspricht, usw.  Die betreffende Funktion erweitert den Satz von Klassen, die in regul√§ren Ausdr√ºcken verwendet werden k√∂nnen, sodass Sie mit Unicode-Sequenzen arbeiten k√∂nnen.  Wir sprechen √ºber die Klasse <code>\p{}</code> und die Umkehrung der Klasse <code>\P{}</code> . <br><br>  In Unicode verf√ºgt jedes Zeichen √ºber eine Reihe von Eigenschaften.  Diese Eigenschaften sind in geschweiften Klammern der Gruppe <code>\p{}</code> .  Beispielsweise bestimmt die <code>Script</code> Eigenschaft die Sprachfamilie, zu der ein Zeichen geh√∂rt. Die logische <code>ASCII</code> Eigenschaft <code>true</code> f√ºr ASCII-Zeichen usw.  Wir werden beispielsweise herausfinden, ob einige Zeilen nur ASCII-Zeichen enthalten. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('ABC@')) //true console.log(r.test('ABC')) //false</span></span></code> </pre> <br>  Die Eigenschaft <code>ASCII_Hex_Digit</code> <code>true</code> nur f√ºr Zeichen, die zum Schreiben von Hexadezimalzahlen verwendet werden k√∂nnen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/^\p{ASCII_Hex_Digit}+$/u</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'0123456789ABCDEF'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('H')) //false</span></span></code> </pre> <br>  Es gibt viele andere √§hnliche Eigenschaften, die auf die gleiche Weise wie oben beschrieben verwendet werden.  Unter ihnen sind <code>Uppercase</code> , <code>Lowercase</code> , <code>White_Space</code> , <code>Alphabetic</code> , <code>Emoji</code> . <br><br>  Im <code>Script</code> erfahren Sie beispielsweise, wie Sie mithilfe der <code>Script</code> Eigenschaft bestimmen, welches Alphabet in einer Zeichenfolge verwendet wird.  Hier √ºberpr√ºfen wir die Zeichenfolge auf die Verwendung des griechischen Alphabets. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/^\p{Script=Greek}+$/u</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'ŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('hey')) //false</span></span></code> </pre> <br>  Details zu diesen Eigenschaften finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h4>  Benannte Gruppen </h4><br>  Erfasste Zeichengruppen in ES2018 k√∂nnen mit Namen versehen werden.  So sieht es aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> re = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = re.exec(<span class="hljs-string"><span class="hljs-string">'2015-01-02'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">/* [ '2015-01-02', '2015', '01', '02', index: 0, input: '2015-01-02', groups: { year: '2015', month: '01', day: '02' } ] */</span></span></code> </pre> <br>  Ohne die Verwendung benannter Gruppen w√§ren dieselben Daten nur als Array-Elemente verf√ºgbar. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> re = <span class="hljs-regexp"><span class="hljs-regexp">/(\d{4})-(\d{2})-(\d{2})/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = re.exec(<span class="hljs-string"><span class="hljs-string">'2015-01-02'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">/* [ '2015-01-02', '2015', '01', '02', index: 0, input: '2015-01-02', groups: undefined ] */</span></span></code> </pre> <br><h4>  Regex-Flagge s </h4><br>  Die Verwendung des <code>s</code> Flags f√ºhrt zu einem Zeichen <code>.</code>  (Punkt) stimmt unter anderem mit dem Zeilenumbruchzeichen √ºberein.  Ohne dieses Flag entspricht ein Punkt einem beliebigen Zeichen mit Ausnahme einer neuen Zeile. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/hi.welcome/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'hi\nwelcome'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// false console.log(/hi.welcome/s.test('hi\nwelcome')) // true</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Mit diesem Material schlie√üen wir die Ver√∂ffentlichung der √úbersetzungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> JavaScript-Handbuchs ab.  Wir hoffen, dass diese Ver√∂ffentlichungen denjenigen, die zuvor noch nicht mit JavaScript gearbeitet hatten, geholfen haben, ihre ersten Schritte bei der Programmierung in dieser Sprache zu unternehmen. <br><br>  <b>Liebe Leser!</b>  Wenn Sie noch nie in JS geschrieben und diese Sprache in diesem Handbuch beherrschen, teilen Sie uns bitte Ihre Eindr√ºcke mit. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431872/">https://habr.com/ru/post/de431872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431862/index.html">Mitap Sbertekh in Jekaterinburg</a></li>
<li><a href="../de431864/index.html">PVS-Studio ROI: Wie man nicht Millionen verliert (Entwurfsversion des Artikels)</a></li>
<li><a href="../de431866/index.html">Programmierer falsche Vorstellungen √ºber Namen - mit Beispielen</a></li>
<li><a href="../de431868/index.html">Stunden auf Gasentladungslampen (GRI) sind sie Nixie Uhr</a></li>
<li><a href="../de431870/index.html">Entwickler interaktiver B√ºcher mit LEDs beschweren sich √ºber den Diebstahl von Ideen durch Google-Mitarbeiter</a></li>
<li><a href="../de431874/index.html">Imba: JavaScript-kompatible Sprache f√ºr die schnelle Arbeit mit DOM</a></li>
<li><a href="../de431876/index.html">Optimierung von Winkelanwendungen</a></li>
<li><a href="../de431878/index.html">Wenig bekannte JavaScript-Funktionen</a></li>
<li><a href="../de431880/index.html">Doom of SceneKit. Yandex Erfahrung mit 3D-Grafik in iOS</a></li>
<li><a href="../de431884/index.html">Microsoft hat Apple bei der Marktkapitalisierung √ºbertroffen: Wie ist das passiert?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>