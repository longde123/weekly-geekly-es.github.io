<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💧 🌨️ ⏱️ Calme calme conflit 🥪 👩‍👩‍👦 💴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a trois ans, j'ai écrit un article sur la bibliothèque DI pour la langue Swift. À partir de ce moment, la bibliothèque a beaucoup changé et est d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Calme calme conflit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457188/"><img src="https://habrastorage.org/files/c6d/c89/5d0/c6dc895d02324b96bc679f41228ab6bf.png" align="right" width="140" alt="icône de la bibliothèque">  Il y a trois ans, j'ai écrit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article</a> sur la bibliothèque DI pour la langue Swift.  À partir de ce moment, la bibliothèque a beaucoup changé et est devenue la <s>meilleure</s> concurrente digne <s>de ce genre</s> de Swinject, la dépassant à bien des égards.  L'article est consacré aux capacités de la bibliothèque, mais a également des considérations théoriques.  Alors, qui sont intéressés par les sujets DI, DIP, IoC, ou qui fait un choix entre Swinject et Swinject, je demande une coupe: <br clear="all"><a name="habracut"></a><br><br><h1>  Qu'est-ce que DIP, IoC et avec quoi mange-t-il? </h1><br><h2>  Théorie du <abbr title="Principe d'inversion de dépendance">DIP</abbr> et de l' <abbr title="Inversion de contrôle">IoC</abbr> </h2><br>  La théorie est l'un des éléments les plus importants de la programmation.  Oui, vous pouvez écrire du code sans éducation, mais malgré cela, les programmeurs lisent constamment des articles, sont intéressés par diverses pratiques, etc.  Autrement dit, d'une manière ou d'une autre, j'acquiert des connaissances théoriques afin de les mettre en pratique. <br><br>  L'un des sujets que les gens aiment demander pour des entretiens est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SOLIDE</a> .  Aucun article ne parle de lui du tout, ne vous inquiétez pas.  Mais nous avons besoin d'une lettre, car elle est étroitement liée à ma bibliothèque.  Il s'agit de la lettre «D» - Principe d'inversion de dépendance. <br><br>  Le principe d'inversion de dépendance stipule: <br><br><ul><li>  Les modules de niveau supérieur ne doivent pas dépendre de modules de niveau inférieur.  Les deux types de modules doivent dépendre d'abstractions. </li><li>  Les abstractions ne devraient pas dépendre des détails.  Les détails doivent dépendre des abstractions. </li></ul><br>  Beaucoup de gens supposent à tort que s'ils utilisent des protocoles / interfaces, ils adhèrent automatiquement à ce principe, mais ce n'est pas entièrement vrai. <br><br>  <abbr title="Les modules de niveau supérieur ne doivent pas dépendre de modules de niveau inférieur. Les deux types de modules doivent dépendre d'abstractions.">La première déclaration</abbr> dit quelque chose sur les dépendances entre les modules - les modules doivent dépendre des abstractions.  Attendez, qu'est-ce que l'abstraction?  - Il vaut mieux se demander non pas ce qu'est l'abstraction, mais qu'est-ce que l'abstraction?  Autrement dit, vous devez comprendre ce qu'est le processus, et le résultat de ce processus sera une abstraction.  <b>L'abstraction</b> est une distraction dans le processus de cognition des parties, propriétés, relations non essentielles afin de mettre en évidence des signes essentiels et réguliers. <br><br>  Le même objet, selon les objectifs, peut avoir différentes abstractions.  Par exemple, la machine du point de vue du propriétaire a les propriétés importantes suivantes: couleur, élégance, commodité.  Mais du point de vue du mécanicien, tout est quelque peu différent: marque, modèle, modification, kilométrage, participation à un accident.  Deux abstractions différentes pour un objet viennent d'être nommées - la machine. <br><br>  Notez que dans Swift, il est habituel d'utiliser des protocoles pour les abstractions, mais ce n'est pas une exigence.  Personne ne prend la peine de créer une classe, d'allouer un ensemble de méthodes publiques à partir de celle-ci et de laisser les détails de l'implémentation privés.  En termes d'abstraction, rien n'est cassé.  Nous devons nous rappeler la thèse importante - «l'abstraction n'est pas liée à la langue» - c'est un processus qui se produit constamment dans notre tête, et comment cela est transféré au code n'est pas si important.  Ici, nous pouvons également mentionner l' <abbr title="fusion et masquage de données">encapsulation</abbr> , comme exemple de ce qui est associé au langage.  Chaque langue a ses propres moyens pour la fournir.  Sur Swift, ce sont des classes, des champs d'accès et des protocoles;  sur les interfaces Obj-C, les protocoles et la séparation des fichiers h et m. <br><br>  <abbr title="Les abstractions ne devraient pas dépendre des détails. Les détails doivent dépendre des abstractions.">la deuxième affirmation est</abbr> plus intéressante, car elle est ignorée ou mal comprise.  Il parle de l'interaction des abstractions avec les détails, et quels sont les détails?  Il y a une idée fausse selon laquelle les détails sont des classes qui implémentent des protocoles - oui, c'est vrai, mais pas complet.  Vous devez comprendre que les détails ne sont pas liés aux langages de programmation - le langage C n'a ni protocoles ni classes, mais ce principe agit également sur lui.  Il est difficile pour moi d'expliquer théoriquement ce qu'est la capture, je vais donc donner deux exemples, puis essayer de prouver pourquoi le deuxième exemple est plus correct. <br><br>  Supposons qu'il y ait une voiture de classe et un moteur de classe.  Il se trouve que nous devons les connecter - la machine contient un moteur.  En tant que programmeurs compétents, nous sélectionnons le moteur de protocole, implémentons le protocole et transmettons l'implémentation du protocole à la classe de la machine.  Tout semble aller bien - maintenant vous pouvez facilement remplacer l'implémentation du moteur et ne pas penser que quelque chose va casser.  Ensuite, un mécanicien moteur est ajouté au circuit.  Il s'intéresse aux caractéristiques du moteur complètement différentes de la voiture.  Nous étendons le protocole et il contient maintenant un ensemble de fonctionnalités plus important qu'au départ.  L'histoire se répète pour le propriétaire de la voiture, pour les moteurs qui produisent en usine, etc. <br><br><img src="https://habrastorage.org/webt/yh/hh/v1/yhhhv1kv5yvffc1hcoqu489pfqi.png" alt="Pas d'inversion"><br><br>  Mais où est l'erreur de raisonnement?  Le problème est que la connexion décrite, malgré la disponibilité des protocoles, est en fait un «détail» - un «détail».  Plus précisément, sous quel nom et où se situe le protocole du moteur. <br><br>  Considérez maintenant l'autre <s>bonne</s> option. <br><br>  Comme auparavant, il existe deux classes - moteur et voiture.  Comme auparavant, ils doivent être connectés.  Mais maintenant, nous annonçons le protocole «Car Engine» ou «Heart of a Car».  Nous y plaçons uniquement les caractéristiques dont la voiture a besoin pour le moteur.  Et nous plaçons le protocole non pas à côté de son implémentation «moteur», mais à côté de la machine.  De plus, si nous avons besoin d'un mécanicien, nous devrons créer un autre protocole et l'implémenter dans le moteur.  Il semble que rien n'a changé, mais l'approche est radicalement différente - la question n'est pas tant dans les noms, mais à qui appartiennent les protocoles et à quoi le protocole appartient - une «abstraction» ou un «détail». <br><br><img src="https://habrastorage.org/webt/wb/xl/qw/wbxlqwjb7ltz4pqvek-gybtxc00.png" alt="L'inversion est"><br><br>  Tirons maintenant une analogie avec un autre cas, car ces arguments peuvent ne pas être évidents. <br><br>  Il y a un backend et certaines fonctionnalités sont nécessaires.  Le backend nous donne une grande méthode qui contient un tas de données, et dit - "vous avez besoin de ces 3 champs sur 1000" <br><br><div class="spoiler">  <b class="spoiler_title">Petite histoire</b> <div class="spoiler_text">  Beaucoup peuvent dire que cela ne se produit pas.  Et ils auront relativement raison - il arrive que le backend soit écrit séparément pour l'application mobile.  Il se trouve que j'ai travaillé pour une entreprise où le backend est un service avec une histoire de 10 ans qui, entre autres, est lié à l'API de l'État.  Pour de nombreuses raisons, il n'était pas habituel pour l'entreprise d'écrire une méthode distincte pour le mobile, et j'ai dû utiliser ce qui était.  Et il y avait une merveilleuse méthode avec une centaine de paramètres à la racine, et certains d'entre eux étaient des dictionnaires imbriqués.  Imaginez maintenant 100 paramètres, dont 20% ont des paramètres imbriqués, et dans chaque paramètre imbriqué, il y a 20 à 30 autres paramètres qui ont tous la même imbrication.  Je ne me souviens pas exactement, mais le nombre de paramètres a dépassé 800 pour les objets simples, et pour les objets complexes, il pourrait être supérieur à 1000. </div></div><br>  Sonne pas très bien, non?  Habituellement, le backend écrit une méthode pour des tâches spécifiques pour le frontend, et le frontend est le client / utilisateur de ces méthodes.  Hmm ... Mais si vous y réfléchissez, le backend est le moteur et le frontend est la voiture - la machine a besoin de certaines caractéristiques du moteur, et non pas le moteur doit avoir les caractéristiques de la voiture.  Alors pourquoi, malgré cela, nous continuons d'écrire le protocole Engine et de le rapprocher de l'implémentation du moteur, et non de la machine?  Tout dépend de l'échelle - dans la plupart des programmes iOS, il est très rare d'avoir à étendre les fonctionnalités à tel point qu'une telle solution devient un problème. <br><br><h2>  Et puis qu'est-ce que <abbr title="Injection de dépendance">DI</abbr> </h2><br>  Il y a une substitution de concepts - DI n'est pas une abréviation pour DIP, mais une abréviation complètement différente, malgré le fait qu'elle recoupe très étroitement avec DIP.  DI est une injection de dépendance ou une injection de dépendance, pas une inversion.  Inversion explique comment les classes et les protocoles doivent interagir les uns avec les autres, et l'implémentation vous indique d'où les obtenir.  En général, vous pouvez l'implémenter de différentes manières - en commençant par les dépendances: constructeur, propriété, méthode;  se terminant par ceux qui les créent et comment ce processus est automatisé.  Les approches sont différentes mais, à mon avis, les plus pratiques sont les conteneurs pour l'injection de dépendance.  En bref, leur sens se résume à une règle simple: nous informons le conteneur où et comment l'implémenter et après cela, tout est implémenté indépendamment.  Cette approche correspond à la «mise en œuvre réelle des dépendances» - c'est lorsque les classes dans lesquelles les dépendances sont introduites ne savent rien de comment cela se produit, c'est-à-dire qu'elles sont passives. <br><br>  Dans de nombreux langages, l'approche suivante est utilisée pour cette implémentation: Dans les classes / fichiers individuels, les règles d'implémentation sont décrites à l'aide de la syntaxe du langage, après quoi elles sont compilées et implémentées automatiquement.  Il n'y a pas de magie - rien ne se passe automatiquement, seules les bibliothèques sont étroitement intégrées aux moyens de base du langage, et surchargent les méthodes de création.  Donc, pour Swift / Obj-C, il est généralement admis que le point de départ est l'UIViewController, et les bibliothèques peuvent facilement s'intégrer dans le ViewController créé à partir du Storyboard.  Certes, si vous n'utilisez pas le Storyboard, vous devrez effectuer une partie du travail avec des stylos. <br><br>  Oh oui, j'ai presque oublié - la réponse à la question principale, "pourquoi en avons-nous besoin?"  Sans aucun doute, vous pouvez vous-même prendre en charge l'injection de dépendance, tout prescrire avec des stylos.  Mais des problèmes surviennent lorsque les graphiques deviennent volumineux - vous devez mentionner beaucoup de connexions entre les classes, le code commence à grandir beaucoup.  Par conséquent, les bibliothèques qui implémentent automatiquement des dépendances récursives (et même cycliques) prennent ce soin sur elles-mêmes et, en prime, contrôlent leur durée de vie.  Autrement dit, la bibliothèque ne fait rien de plus que le naturel - elle simplifie simplement la vie du développeur.  Certes, ne pensez pas que vous pouvez écrire une telle bibliothèque en une journée - c'est une chose d'écrire au stylet toutes les dépendances pour un cas particulier, c'est une autre chose d'apprendre à un ordinateur à l'implémenter universellement et correctement. <br><br><h1>  Histoire de la bibliothèque </h1><br>  L'histoire ne serait pas complète si je ne la racontais pas brièvement.  Si vous suivez la bibliothèque de la version bêta, elle ne sera pas si intéressante pour vous, mais pour ceux qui la verront pour la première fois, je pense qu'il vaut la peine de comprendre comment elle est apparue et quels objectifs l'auteur a suivis (c'est-à-dire moi). <br>  La bibliothèque était mon deuxième projet, que j'ai décidé, à des fins d'auto-éducation, d'écrire en swift.  Avant cela, j'ai réussi à écrire un enregistreur, mais je ne l'ai pas téléchargé dans le domaine public - c'est de mieux en mieux. <br><br>  Mais avec DI, l'histoire est plus intéressante.  Quand j'ai commencé à le faire, je n'ai pu trouver qu'une seule bibliothèque sur Swift - Swinject.  A cette époque, elle avait 500 étoiles et des bugs que les cycles ne sont pas normalement traités.  J'ai regardé tout cela et ... Mon comportement est mieux décrit par ma phrase préférée «Et ensuite Ostap a souffert» - J'ai parcouru 5-6 langues, regardé ce qui est dans ces langues, lu des articles sur ce sujet et réalisé que cela pouvait être mieux fait.  Et maintenant, après presque trois ans, je peux dire avec confiance que l'objectif a été atteint, en ce moment DITranquillity est le meilleur de ma vision du monde. <br><br>  Comprenons ce qu'est une bonne bibliothèque DI: <br><br><ul><li>  Il devrait fournir toutes les implémentations de base: constructeur, propriétés, méthodes </li><li>  Cela ne devrait pas affecter le code d'entreprise. </li><li>  Elle devrait décrire clairement ce qui n'a pas fonctionné. </li><li>  Elle doit comprendre à l'avance où il y a des erreurs, pas au moment de l'exécution. </li><li>  Il doit être intégré aux outils de base (Storyboard) </li><li>  Il doit avoir une syntaxe concise et concise. </li><li>  Elle doit tout faire rapidement et efficacement. </li><li>  (Facultatif) Il doit être hiérarchique </li></ul><br>  Ce sont ces principes que j'essaie d'adhérer tout au long du développement de la bibliothèque. <br><br><h1>  Caractéristiques et avantages de la bibliothèque </h1><br>  Tout d'abord, un lien vers le référentiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/ivlevAstef/DITranquillity</a> <br><br>  Le principal avantage concurrentiel, qui est assez important pour moi, est que la bibliothèque parle d'erreurs de démarrage.  Après avoir démarré l'application et appelé la fonction souhaitée, tous les problèmes, existants et potentiels, seront signalés.  C'est précisément le sens du nom de la bibliothèque «calme» - en fait, après avoir démarré le programme, la bibliothèque garantit que toutes les dépendances requises existeront et qu'il n'y aura pas de cycles insolubles.  Dans les endroits où il y a ambiguïté, la bibliothèque avertira qu'il peut y avoir des problèmes potentiels. <br><br>  Cela me semble très bien.  Il n'y a pas de plantage pendant l'exécution du programme, si le programmeur a oublié quelque chose, cela sera immédiatement signalé. <br><br>  Une fonction de journal est utilisée pour décrire les problèmes, que je recommande fortement d'utiliser.  La journalisation a 4 niveaux: erreur, avertissement, info, verbeux.  Les trois premiers sont assez importants.  Ce dernier n'est pas si important - il écrit tout ce qui se passe - quel objet a été enregistré, quel objet a commencé à être introduit, quel objet a été créé, etc. <br><br>  Mais ce n'est pas tout ce que la bibliothèque peut se vanter: <br><br><ul><li>  Sécurité totale des threads - toute opération peut être effectuée à partir de n'importe quel thread et tout fonctionnera.  La plupart des gens n'en ont pas besoin, donc en termes de sécurité des threads, un travail a été fait pour optimiser la vitesse d'exécution.  Mais la bibliothèque des concurrents, malgré les promesses, tombe si vous commencez à vous inscrire et à recevoir un objet en même temps </li><li>  Vitesse d'exécution rapide.  Sur un véritable appareil, DITranquillity est deux fois plus rapide que son concurrent.  Vrai sur le simulateur, la vitesse d'exécution est presque équivalente.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien de test</a> </li><li>  Petite taille - la bibliothèque pèse moins que Swinject + SwinjectStoryboad + SwinjectAutoregistration, mais surpasse cet ensemble de capacités </li><li>  Une note concise et concise, bien que provoquant une dépendance </li><li>  Hiérarchie.  Pour les grands projets, qui se composent de nombreux modules, c'est un très gros avantage, car la bibliothèque est capable de trouver les classes nécessaires par distance du module actuel.  Autrement dit, si vous avez votre propre implémentation d'un protocole dans chaque module, alors dans chaque module, vous obtiendrez l'implémentation souhaitée sans aucun effort </li></ul><br><h1>  Démonstration </h1><br>  Et donc commençons.  Comme la dernière fois le projet sera considéré: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SampleHabr</a> .  Je n'ai pas spécifiquement commencé à changer l'exemple - vous pouvez donc comparer comment tout a changé.  Et l'exemple montre de nombreuses fonctionnalités de la bibliothèque. <br><br>  Juste au cas où, pour qu'il n'y ait pas de malentendu, puisque le projet est affiché, il utilise de nombreuses fonctionnalités.  Mais personne ne prend la peine d'utiliser la bibliothèque de manière simplifiée - téléchargé, créé un conteneur, enregistré quelques classes, utilisez le conteneur. <br><br>  Nous devons d'abord créer un cadre (facultatif): <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppFramework</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DIFramework</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   public static func load(container: DIContainer) { //     } }</span></span></code> </pre> <br>  Et au début du programme, créez votre propre conteneur, avec l'ajout de ce framework: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-type"><span class="hljs-type">DIContainer</span></span>() <span class="hljs-comment"><span class="hljs-comment">//   container.append(framework: AppFramework.self) //     . //          ifdef DEBUG      ,         ,     . if !container.validate() { fatalError() }</span></span></code> </pre><br><h3>  Storyboard </h3><br>  Ensuite, vous devez créer un écran de base.  Habituellement, les storyboards sont utilisés pour cela, et dans cet exemple, je vais l'utiliser, mais personne ne se soucie d'utiliser UIViewControllers. <br><br>  Pour commencer, nous devons enregistrer un Storyboard.  Pour ce faire, créez une «partie» (facultative - vous pouvez écrire tout le code dans le framework) avec le Storyboard enregistré dedans: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DITranquillity class AppPart: DIPart { static func load(container: DIContainer) { container.registerStoryboard(name: "Main", bundle: nil) .lifetime(.single) <span class="hljs-comment"><span class="hljs-comment">//   -    . } }</span></span></code> </pre><br><br>  Et ajoutez une pièce à AppFramework: <br><pre> <code class="swift hljs">container.append(part: <span class="hljs-type"><span class="hljs-type">AppPart</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre><br>  Comme vous pouvez le voir, la bibliothèque a une syntaxe pratique pour enregistrer Storyboard, et je recommande fortement de l'utiliser.  En principe, vous pouvez écrire du code équivalent sans cette méthode, mais il sera plus volumineux et ne pourra pas prendre en charge StoryboardReferences.  Autrement dit, ce Storyboard ne fonctionnera pas d'un autre. <br><br>  Maintenant, la seule chose qui reste est de créer un Storyboard et d'afficher l'écran de démarrage.  Cela se fait dans AppDelegate, après avoir vérifié le conteneur: <br><br><pre> <code class="swift hljs">window = <span class="hljs-type"><span class="hljs-type">UIWindow</span></span>(frame: <span class="hljs-type"><span class="hljs-type">UIScreen</span></span>.main.bounds) <span class="hljs-comment"><span class="hljs-comment">///  Storyboard let storyboard: UIStoryboard = container.resolve(name: "Main") window!.rootViewController = storyboard.instantiateInitialViewController() window!.makeKeyAndVisible()</span></span></code> </pre><br>  La création d'un Storyboard à l'aide d'une bibliothèque n'est pas beaucoup plus compliquée que d'habitude.  Dans cet exemple, le nom pourrait être manquant, car nous n'avons qu'un seul Storyboard - la bibliothèque aurait deviné que vous l'aviez en tête.  Mais dans certains projets, il y a beaucoup de storyboards, alors ne manquez plus le nom. <br><br><h3>  Presenter et ViewController </h3><br>  Accédez à l'écran lui-même.  Nous ne chargerons pas le projet avec des architectures complexes, mais nous utiliserons le MVP habituel.  De plus, je suis tellement paresseux que je ne créerai pas de protocole pour un présentateur.  Le protocole sera un peu plus tard pour une autre classe, ici il est important de montrer comment enregistrer et lier Presenter et ViewController. <br><br>  Pour ce faire, ajoutez le code suivant à AppPart: <br><br><pre> <code class="swift hljs">container.register(<span class="hljs-type"><span class="hljs-type">YourPresenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>) container.register(<span class="hljs-type"><span class="hljs-type">YourViewController</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .injection(\.presenter) <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  Ces trois lignes nous permettront d'enregistrer deux classes et d'établir une connexion entre elles. <br><br>  Les personnes curieuses peuvent se demander - pourquoi la syntaxe de Swinject dans une bibliothèque séparée est-elle la principale du projet?  La réponse réside dans les objectifs - grâce à cette syntaxe, la bibliothèque stocke tous les liens à l'avance, plutôt que de les calculer au moment de l'exécution.  Cette syntaxe vous donne accès à de nombreuses fonctionnalités qui ne sont pas disponibles pour d'autres bibliothèques. <br><br>  Nous démarrons l'application, et tout fonctionne, toutes les classes sont créées. <br><br><h3>  Les données </h3><br>  Eh bien, maintenant nous devons ajouter une classe et un protocole pour recevoir des données du serveur: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Server</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Data?</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerImpl</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Server</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(domain: <span class="hljs-type"><span class="hljs-type">String</span></span>) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Data?</span></span> { ... } }</code> </pre><br>  Et pour la beauté, nous allons créer une classe DI ServerPart distincte pour le serveur, dans laquelle nous l'enregistrons.  Permettez-moi de vous rappeler que cela n'est pas nécessaire et peut être enregistré directement dans le conteneur, mais nous ne cherchons pas de moyens simples :) <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DITranquillity class ServerPart: DIPart { static func load(container: DIContainer) { container.register{ ServerImpl(domain: "https:<span class="hljs-comment"><span class="hljs-comment">//github.com/") } .as(check: Server.self){$0} .lifetime(.single) } }</span></span></code> </pre><br>  Dans ce code, tout n'est pas aussi transparent que dans les précédents et nécessite une clarification.  Tout d'abord, à l'intérieur du registre de fonction, une classe est créée avec un paramètre passé. <br><br>  Deuxièmement, il y a la fonction `as` - elle dit que la classe sera accessible par un autre type - le protocole.  L'étrange fin de cette opération sous la forme de {{$ 0} `fait partie du nom` check: `.  Autrement dit, ce code garantit que ServerImpl est un successeur de Server.  Mais il existe une autre syntaxe: `as (Server.self)` qui fera de même, mais sans vérification.  Pour voir ce que le compilateur produira dans les deux cas, vous pouvez supprimer l'implémentation du protocole. <br><br>  Il peut y avoir plusieurs fonctions «as» - cela signifie que le type est disponible sous l'un de ces noms.  J'attire votre attention sur le fait qu'il s'agira d'un seul enregistrement, ce qui signifie que si la classe est un singleton, la même instance sera disponible pour tout type spécifié. <br><br>  En principe, si vous souhaitez vous protéger de la possibilité de créer une classe par type d'implémentation, ou si vous n'êtes pas encore habitué à cette syntaxe, vous pouvez écrire: <br><br><pre> <code class="swift hljs">container.register{ <span class="hljs-type"><span class="hljs-type">ServerImpl</span></span>(domain: <span class="hljs-string"><span class="hljs-string">"https://github.com/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">Server</span></span> }</code> </pre><br>  Ce sera un équivalent, mais sans la possibilité de spécifier plusieurs types distincts. <br><br>  Vous pouvez maintenant implémenter le serveur dans Presenter, pour cela nous allons corriger Presenter pour qu'il accepte le serveur: <br><br><pre> <code class="swift hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YourPresenter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(server: <span class="hljs-type"><span class="hljs-type">Server</span></span>) { ... } }</code> </pre><br>  Nous démarrons le programme, et il tombe sur les fonctions `validate` dans AppDelegate, avec le message que le type` Server` n'a pas été trouvé, mais il est requis par` YourPresenter`.  Quoi de neuf?  Veuillez noter que l'erreur s'est produite au début de l'exécution du programme, et non un post factum.  Et la raison est assez simple - ils ont oublié d'ajouter «ServerPart» à «AppFramework»: <br><br><pre> <code class="swift hljs">container.append(part: <span class="hljs-type"><span class="hljs-type">ServerPart</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre><br>  Nous commençons - tout fonctionne. <br><br><h3>  Enregistreur </h3><br>  Avant cela, il y avait une connaissance des opportunités qui ne sont pas très impressionnantes et beaucoup l'ont.  Il y aura maintenant une démonstration que les autres bibliothèques sur Swift ne savent pas comment. <br><br>  Un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet</a> distinct <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a</a> été créé sous l'enregistreur. <br><br>  Tout d'abord, comprenons ce qui sera un enregistreur.  À des fins éducatives, nous ne ferons pas un système trompé, donc l'enregistreur est un protocole avec une méthode et plusieurs implémentations: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConsoleLogger</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileLogger</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(file: <span class="hljs-type"><span class="hljs-type">String</span></span>) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerLogger</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(server: <span class="hljs-type"><span class="hljs-type">String</span></span>) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainLogger</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(loggers: [<span class="hljs-type"><span class="hljs-type">Logger</span></span>]) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> { ... } }</code> </pre><br>  Au total, nous avons: <br><br><ul><li>  Protocole public </li><li>  3 implémentations d'enregistreur différentes, chacune écrivant dans un endroit différent </li><li>  Un enregistreur central qui appelle la fonction de journalisation pour tout le monde </li></ul><br>  Le projet a créé «LoggerFramework» et «LoggerPart».  Je n'écrirai pas leur code, mais je n'écrirai que les éléments internes de `LoggerPart`: <br><br><pre> <code class="swift hljs">container.register{ <span class="hljs-type"><span class="hljs-type">ConsoleLogger</span></span>() } .<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(<span class="hljs-type"><span class="hljs-type">Logger</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .lifetime(.single) container.register{ <span class="hljs-type"><span class="hljs-type">FileLogger</span></span>(file: <span class="hljs-string"><span class="hljs-string">"file.log"</span></span>) } .<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(<span class="hljs-type"><span class="hljs-type">Logger</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .lifetime(.single) container.register{ <span class="hljs-type"><span class="hljs-type">ServerLogger</span></span>(server: <span class="hljs-string"><span class="hljs-string">"http://server.com/"</span></span>) } .<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(<span class="hljs-type"><span class="hljs-type">Logger</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .lifetime(.single) container.register{ <span class="hljs-type"><span class="hljs-type">MainLogger</span></span>(loggers: many($<span class="hljs-number"><span class="hljs-number">0</span></span>)) } .<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(<span class="hljs-type"><span class="hljs-type">Logger</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>() .lifetime(.single)</code> </pre><br>  Nous avons déjà vu les 3 premières inscriptions, et la dernière pose question. <br><br>  Un paramètre est passé à l'entrée.  Un exemple similaire a déjà été montré lors de la création du présentateur, bien qu'il y ait un enregistrement abrégé - la méthode `init` vient d'être utilisée, mais personne ne prend la peine d'écrire comme ceci: <br><br><pre> <code class="swift hljs">container.register { <span class="hljs-type"><span class="hljs-type">YourPresenter</span></span>(server: $<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br>  S'il y avait plusieurs paramètres, alors on pourrait utiliser «$ 1», «$ 2», «$ 3», etc.  jusqu'au 16. <br><br>  Mais ce paramètre appelle la fonction `many`.  Et ici, le plaisir commence.  Il y a deux modificateurs `many` et` tag` dans la bibliothèque. <div class="spoiler">  <b class="spoiler_title">Texte masqué</b> <div class="spoiler_text">  Il existe un troisième modificateur `arg`, mais il n'est pas sûr </div></div>  Le modificateur `many` indique que vous devez obtenir tous les objets correspondant au type souhaité.  Dans ce cas, le protocole Logger est attendu, donc toutes les classes qui héritent de ce protocole seront trouvées et créées, à une exception près - elle-même, c'est-à-dire de manière récursive.  Il ne se créera pas lors de l'initialisation, bien qu'il puisse le faire en toute sécurité lorsqu'il est implémenté via une propriété. <br><br>  L'étiquette, à son tour, est un type distinct qui doit être spécifié à la fois lors de l'utilisation et lors de l'enregistrement.  Autrement dit, les balises sont des critères supplémentaires s'il n'y a pas suffisamment de types de base. <br><br>  Vous pouvez en savoir plus à ce sujet: <a href="">Modificateurs</a> <br><br>  La présence de modificateurs, en particulier `many ', rend la bibliothèque meilleure que les autres.  Par exemple, vous pouvez implémenter le modèle Observer à un niveau complètement différent.  En raison de ces 4 lettres, dans le projet, il a été possible de supprimer 30 à 50 lignes de code de chaque observateur du projet et de résoudre le problème avec la question - où et quand les objets devraient-ils être ajoutés à l'observable.  Clear business n'est pas la seule application, mais elle est importante. <br><br>  Eh bien, nous terminerons la présentation des fonctionnalités en introduisant un enregistreur dans YourPresenter: <br><br><pre> <code class="swift hljs">container.register(<span class="hljs-type"><span class="hljs-type">YourPresenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>) .injection { $<span class="hljs-number"><span class="hljs-number">0</span></span>.logger = $<span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br>  Ici, par exemple, il est écrit un peu différemment qu'auparavant - cela se fait pour un exemple d'une syntaxe différente. <br><br>  Veuillez noter que la propriété de l'enregistreur est facultative: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger: <span class="hljs-type"><span class="hljs-type">Logger?</span></span></code> </pre><br>  Et cela n'apparaît pas dans la syntaxe de la bibliothèque.  Contrairement à la première version, maintenant toutes les opérations pour le type habituel, facultatif et forcé facultatif se ressemblent.  De plus, la logique à l'intérieur est différente - si le type est facultatif et n'est pas enregistré dans le conteneur, le programme ne se bloquera pas, mais continuera son exécution. <br><br><h2>  Résumé </h2><br>  Les résultats sont similaires à la dernière fois, seule la syntaxe est devenue plus courte et plus fonctionnelle. <br><br><h4>  Ce qui a été examiné: </h4><br><ul><li>  <a href="">Inscrivez-vous brièvement</a> </li><li>  <a href="">Travailler avec Storyboard, mais la bibliothèque peut fonctionner avec StoryboardReferences</a> </li><li>  <a href="">Inscription via une méthode ou une propriété d'initialisation</a> </li><li>  <a href="">Implémentation multiple</a> </li><li>  <a href="">Travailler avec des cadres et des pièces</a> </li><li>  <a href="">Un peu de validation</a> </li></ul><br><h4>  Que peut faire d'autre la bibliothèque: </h4><br><ul><li>  <a href="">5 durées de vie: simple, perRun (.weak / .strong), perContainer (.weak / .strong), objectGraph, prototype</a> </li><li>  <a href="">Nom des balises</a> </li><li>  <a href="">Journalisation</a> </li><li>  <a href="">Travailler avec des dépendances cycliques</a> </li><li>  <a href="">Prenez racine dans les vues</a> </li><li>  <a href="">Mise en œuvre différée</a> </li><li>  L'introduction d'arguments, mais la fonctionnalité n'est pas documentée en raison de sa non-sécurité </li></ul><br><h2>  Plans </h2><br>  Tout d'abord, il est prévu de passer à la vérification du graphe au stade de la compilation, c'est-à-dire une intégration plus étroite avec le compilateur.  Il existe une implémentation préliminaire utilisant SourceKitten, mais une telle implémentation a de sérieuses difficultés avec l'inférence de type, il est donc prévu de passer à ast-dump - en swift5, elle est devenue opérationnelle sur de grands projets.  Ici, je tiens à remercier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nekitosss</a> pour l'énorme contribution dans ce sens. <br><br>  Deuxièmement, je voudrais m'intégrer aux services de visualisation.  Ce sera un projet légèrement différent, mais étroitement lié à la bibliothèque.  À quoi ça sert?  Maintenant, la bibliothèque stocke le graphique complet des connexions, c'est-à-dire qu'en théorie, tout ce qui est enregistré dans la bibliothèque peut être affiché sous forme de diagramme de classe / composant UML.  Et ce serait bien de voir parfois ce schéma. <br><br>  Cette fonctionnalité est prévue en deux parties - la première vous permettra d'ajouter une API pour obtenir toutes les informations, et la seconde est déjà l'intégration avec différents services. <br><br>  L'option la plus simple consiste à afficher un graphique de liens sous forme de texte, mais je n'ai pas vu d'options lisibles - si oui, suggérez des options dans les commentaires. <br><br>  WatchOS - Je n'écris pas moi-même de projets pour eux.  Pour sa vie, il n'a écrit qu'une seule fois, puis petit.  Mais je voudrais faire une intégration étroite, comme avec le Storyboard. <br><br>  C'est tout merci de votre attention.  J'espère vraiment avoir des commentaires et des réponses à l'enquête. <br><br><div class="spoiler">  <b class="spoiler_title">À propos de moi</b> <div class="spoiler_text">  Ivlev Alexander Evgenievich - senior / chef d'équipe dans l'équipe iOS.  Je travaille dans le commerce depuis 7 ans, sous iOS 4,5 ans - avant cela, j'étais développeur C ++.  Mais l'expérience de programmation totale est de plus de 15 ans - à l'école, j'ai fait la connaissance de ce monde incroyable et j'ai été tellement emporté par lui qu'il y a eu une période où j'ai échangé des jeux <s>, de la nourriture, des toilettes, un rêve</s> pour écrire du code.  Selon l'un de mes articles, vous pouvez deviner que je suis une ancienne Olympiade - en conséquence, il ne m'a pas été difficile d'écrire un travail compétent avec des graphiques.  Spécialité - Systèmes de mesure de l'information, et à une époque j'étais obsédé par le multithreading et le parallélisme - oui, j'écris du code dans lequel je fais des hypothèses et des bugs sur des sujets similaires, mais je comprends les zones à problèmes et comprends parfaitement où vous pouvez négliger le mutex, et où pas la peine. <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457188/">https://habr.com/ru/post/fr457188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457178/index.html">Conception et fabrication des processeurs: conception du processeur</a></li>
<li><a href="../fr457180/index.html">Le site officiel Node.js est maintenant en russe</a></li>
<li><a href="../fr457182/index.html">Langue REXX, 40e anniversaire</a></li>
<li><a href="../fr457184/index.html">Créez dynamiquement robots.txt pour les sites ASP.NET Core</a></li>
<li><a href="../fr457186/index.html">Python dans Visual Studio Code - version de juin</a></li>
<li><a href="../fr457190/index.html">Nous traitons les affaires grâce à la mise en œuvre de systèmes CRM</a></li>
<li><a href="../fr457192/index.html">Airbus prend de nouveaux sommets avec la réalité mixte de Microsoft</a></li>
<li><a href="../fr457194/index.html">Airbus atteint de nouveaux sommets avec l'aide de la technologie de réalité mixte de Microsoft</a></li>
<li><a href="../fr457196/index.html">Petty little joy # 5: Dynaconf - gestion des paramètres dans le projet</a></li>
<li><a href="../fr457198/index.html">Le réseau neuronal a appris à dessiner des scènes complexes à partir d'une description textuelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>