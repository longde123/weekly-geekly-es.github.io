<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ© ğŸ—‘ï¸ ğŸ¤¦ğŸ» Mengimplementasikan hot reload kode C ++ di Linux ğŸ¬ ğŸ™ âœ‚ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Tautan ke perpustakaan di akhir artikel. Artikel itu sendiri menguraikan mekanisme yang diterapkan di perpustakaan, dengan detail menengah. Implemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengimplementasikan hot reload kode C ++ di Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435260/"><p><img src="https://alexpolt.github.io/images/stroustrup-didnt-plan-for-this.png" alt="gambar"></p><br><p>  * Tautan ke perpustakaan di akhir artikel.  Artikel itu sendiri menguraikan mekanisme yang diterapkan di perpustakaan, dengan detail menengah.  Implementasi untuk macOS belum selesai, tetapi tidak jauh berbeda dari implementasi untuk Linux.  Ini terutama merupakan implementasi untuk Linux. </p><br><p>  Berjalan di sekitar github pada suatu Sabtu sore, saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan</a> yang mengimplementasikan pembaruan kode c ++ dengan cepat untuk windows.  Saya sendiri turun dari windows beberapa tahun yang lalu, tidak menyesal sedikit pun, dan sekarang semua pemrograman dilakukan baik di Linux (di rumah) atau di macOS (di tempat kerja).  Googling sedikit, saya menemukan bahwa pendekatan dari perpustakaan di atas cukup populer, dan msvc menggunakan teknik yang sama untuk fungsi "Edit dan lanjutkan" di Visual Studio.  Satu-satunya masalah adalah bahwa saya tidak menemukan implementasi di bawah non-windows (apakah saya terlihat buruk?).  Untuk pertanyaan kepada penulis perpustakaan di atas apakah ia akan membuat port untuk platform lain, jawabannya adalah tidak. </p><br><p>  Saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">harus segera mengatakan</a> bahwa saya hanya tertarik pada opsi di mana saya tidak perlu mengubah kode proyek yang ada (seperti, misalnya, dalam kasus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RCCPP</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cr</a> , di mana semua kode yang berpotensi dimuat kembali harus berada di perpustakaan terpisah yang dimuat secara dinamis). </p><br><p>  "Bagaimana bisa begitu?"  - Saya pikir, dan mulai menyalakan dupa. </p><a name="habracut"></a><br><h2 id="zachem">  Mengapa </h2><br><p>  Saya terutama melakukan gamedev.  Sebagian besar waktu kerja saya dihabiskan untuk menulis logika permainan dan tata letak visual apa pun.  Saya juga menggunakan imgui untuk utilitas pembantu.  Siklus saya bekerja dengan kode, seperti yang mungkin Anda duga, adalah Write -&gt; Compile -&gt; Run -&gt; Repeat.  Semuanya terjadi dengan sangat cepat (peningkatan bertahap, semua jenis ccache, dll.).  Masalahnya di sini adalah bahwa siklus ini harus diulang cukup sering.  Misalnya, saya menulis mekanisme permainan baru, biarlah "Lompat", Lompat yang valid dan terkontrol: </p><br><p>  1. Menulis rancangan implementasi berdasarkan momentum, disusun, diluncurkan.  Saya melihat bahwa saya secara tidak sengaja menerapkan pulsa ke setiap frame, dan tidak sekali. </p><br><p>  2. Memperbaiki, memasang, meluncurkan, sekarang normal.  Tetapi akan perlu untuk mengambil nilai absolut dari impuls lebih. </p><br><p>  3. Memperbaiki, memasang, meluncurkan, bekerja.  Tapi entah kenapa rasanya salah.  Perlu untuk mencoba atas dasar kekuatan untuk dilakukan. </p><br><p>  4. Menulis rancangan implementasi berdasarkan kekuatan, dirakit, diluncurkan, karya.  Hanya perlu mengubah kecepatan sesaat pada saat lompat. <br>  ... </p><br><p> 10. Memperbaiki, mengumpulkan, meluncurkan, bekerja.  Tapi tetap saja tidak.  Mungkin perlu mencoba implementasi berdasarkan perubahan pada <code>gravityScale</code> . <br>  ... </p><br><p>  20. Hebat, ini terlihat super!  Sekarang kita ambil semua parameter di editor untuk gamediz, test dan fill. <br>  ... </p><br><p>  30. Lompatan siap. </p><br><p>  Dan pada setiap iterasi, Anda perlu mengumpulkan kode dan dalam aplikasi yang diluncurkan sampai ke tempat di mana saya bisa melompat.  Ini biasanya membutuhkan setidaknya 10 detik.  Dan jika saya hanya bisa melompat di area terbuka, mana yang masih harus dijangkau?  Dan jika saya harus dapat melompat ke blok dengan ketinggian N unit?  Di sini saya sudah perlu mengumpulkan tempat uji, yang juga perlu debugged, dan yang juga perlu menghabiskan waktu.  Ini untuk iterasi sedemikian rupa sehingga pemuatan ulang kode menjadi ideal.  Tentu saja, ini bukan obat mujarab, ini tidak cocok untuk semuanya, dan setelah mem-boot ulang kadang-kadang Anda perlu membuat ulang bagian dari dunia game, dan ini harus diperhitungkan.  Tetapi dalam banyak hal, ini bisa bermanfaat dan bisa menghemat perhatian dan banyak waktu. </p><br><h2 id="trebovaniya-i-postanovka-zadachi">  Persyaratan dan pernyataan masalah </h2><br><ul><li>  Saat mengubah kode, versi baru dari semua fungsi harus menggantikan versi lama dari fungsi yang sama </li><li>  Ini harus bekerja di Linux dan macOS </li><li>  Ini seharusnya tidak memerlukan perubahan pada kode aplikasi yang ada. </li><li>  Idealnya, ini harus perpustakaan, secara statis atau dinamis terkait dengan aplikasi, tanpa utilitas pihak ketiga </li><li>  Sangat diharapkan bahwa perpustakaan ini tidak terlalu mempengaruhi kinerja aplikasi. </li><li>  Cukup jika ini bekerja dengan cmake + make / ninja </li><li>  Sudah cukup jika ini akan bekerja dengan build debazine (tanpa optimasi, tanpa pemangkasan karakter, dll.) </li></ul><br><p>  Ini adalah serangkaian persyaratan minimum yang harus dipenuhi oleh suatu implementasi.  Ke depan, saya akan menjelaskan secara singkat apa yang diterapkan tambahan: </p><br><ul><li>  Mentransfer nilai variabel statis ke kode baru (lihat bagian "Mentransfer variabel statis" untuk mencari tahu mengapa ini penting) </li><li>  Reload berdasarkan dependensi (header diubah -&gt; dibangun kembali <del>  setengah proyek </del>  semua file dependen) </li><li>  Memuat ulang kode dari pustaka dinamis </li></ul><br><h2 id="realizaciya">  Implementasi </h2><br><p>  Sampai saat itu, saya benar-benar jauh dari area subjek, jadi saya harus mengumpulkan dan mengasimilasi informasi dari awal. </p><br><p>  Pada level tinggi, mekanismenya terlihat seperti ini: </p><br><ul><li>  Kami memantau sistem file untuk perubahan sumber </li><li>  Ketika sumber berubah, perpustakaan membangunnya kembali menggunakan perintah kompilasi yang file ini sudah dikompilasi </li><li>  Semua objek yang dikumpulkan ditautkan ke perpustakaan yang dimuat secara dinamis </li><li>  Perpustakaan dimuat ke ruang alamat proses </li><li>  Semua fungsi dari perpustakaan menggantikan fungsi yang sama dalam aplikasi. </li><li>  Nilai-nilai variabel statis ditransfer dari aplikasi ke perpustakaan </li></ul><br><p>  Mari kita mulai dengan yang paling menarik - mekanisme reload fungsi. </p><br><h4 id="perezagruzka-funkciy">  Reload fungsi </h4><br><p>  Berikut adalah 3 cara yang kurang lebih populer untuk mengganti fungsi dalam (atau hampir) runtime: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Trik dengan LD_PRELOAD</a> - memungkinkan Anda untuk membangun pustaka yang dimuat secara dinamis dengan, misalnya, fungsi <code>strcpy</code> , dan membuatnya sehingga ketika Anda memulai aplikasi mengambil versi saya dari <code>strcpy</code> alih-alih perpustakaan </li><li>  Ubah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel PLT dan GOT</a> - memungkinkan Anda untuk "kelebihan" fungsi yang diekspor </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hooking fungsi</a> - memungkinkan Anda untuk mengarahkan utas eksekusi dari satu fungsi ke fungsi lainnya </li></ul><br><p>  2 opsi pertama, jelas, tidak cocok, karena hanya berfungsi dengan fungsi yang diekspor, dan kami tidak ingin menandai semua fungsi aplikasi kami dengan atribut apa pun.  Karena itu, Fungsi hooking adalah pilihan kami! </p><br><p>  Singkatnya, pekerjaan hooking seperti ini: </p><br><ul><li>  Alamat fungsi ditemukan </li><li>  Beberapa byte pertama dari fungsi ditimpa oleh transisi tanpa syarat ke tubuh fungsi lain </li><li>  ... </li><li>  Untung! <br>  Di msvc ada 2 flag untuk ini - <code>/hotpatch</code> dan <code>/FUNCTIONPADMIN</code> .  Yang pertama di awal setiap fungsi menulis 2 byte, yang tidak melakukan apa-apa, untuk penulisan ulang berikutnya dengan "lompatan pendek".  Yang kedua memungkinkan Anda untuk meninggalkan ruang kosong di depan tubuh masing-masing fungsi dalam bentuk instruksi <code>nop</code> untuk "lompat jauh" ke lokasi yang diinginkan, jadi dalam 2 lompatan Anda dapat beralih dari fungsi lama ke yang baru.  Anda dapat membaca lebih lanjut tentang bagaimana ini diterapkan di windows dan msvc, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </li></ul><br><p>  Sayangnya, tidak ada yang serupa di dentang dan gcc (setidaknya di Linux dan macOS).  Sebenarnya ini bukan masalah besar, kami akan menulis langsung di atas fungsi lama.  Dalam hal ini, kami berisiko mendapat masalah jika aplikasi kami multithreaded.  Jika biasanya dalam lingkungan multi-utas kami membatasi akses ke data oleh satu utas sementara utas lain memodifikasinya, maka kita perlu membatasi kemampuan untuk mengeksekusi kode pada satu utas sedangkan utas lain mengubah kode ini.  Saya belum menemukan cara untuk melakukan ini, sehingga implementasinya akan berperilaku tak terduga di lingkungan multi-utas. </p><br><p>  Ada satu titik halus.  Pada sistem 32-bit, 5 byte sudah cukup bagi kita untuk "melompat" ke sembarang tempat.  Pada sistem 64-bit, jika kita tidak ingin merusak register, kita perlu 14 byte.  Intinya adalah bahwa 14 byte dalam skala kode mesin cukup banyak, dan jika kode memiliki fungsi rintisan dengan badan kosong, kemungkinan panjangnya kurang dari 14 byte.  Saya tidak tahu seluruh kebenaran, tetapi saya menghabiskan waktu di belakang disassembler sambil berpikir, menulis dan men-debug kode, dan saya perhatikan bahwa semua fungsi diselaraskan pada batas 16-byte (debug build tanpa optimisasi, tidak yakin tentang kode yang dioptimalkan).  Dan ini berarti bahwa di antara dua fungsi awal akan ada setidaknya 16 byte, yang cukup bagi kita untuk "macet" mereka.  Googling dangkal mengarah ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , namun, saya tidak tahu pasti, saya hanya beruntung, atau hari ini semua penyusun melakukan ini.  Bagaimanapun, jika ragu, cukup deklarasikan beberapa variabel di awal fungsi rintisan sehingga menjadi cukup besar. </p><br><p>  Jadi, kami memiliki butir pertama - mekanisme untuk mengalihkan fungsi dari versi lama ke yang baru. </p><br><h4 id="poisk-funkciy-v-skopmilirovannoy-programme">  Cari fungsi dalam program yang disalin </h4><br><p>  Sekarang kita perlu entah bagaimana mendapatkan alamat semua fungsi (tidak hanya diekspor) dari program kami atau pustaka dinamis sewenang-wenang.  Ini dapat dilakukan cukup sederhana menggunakan api sistem jika karakter tidak keluar dari aplikasi Anda.  Di Linux, ini adalah api dari <code>elf.h</code> dan <code>link.h</code> , di macOS, <code>loader.h</code> dan <code>nlist.h</code> . </p><br><ul><li>  Menggunakan <code>dl_iterate_phdr</code> kita pergi melalui semua pustaka yang dimuat dan, pada kenyataannya, program </li><li>  Temukan alamat tempat perpustakaan dimuat </li><li>  Dari bagian <code>.symtab</code> mendapatkan semua informasi tentang karakter, yaitu nama, jenis, indeks bagian di mana ia berada, ukuran, dan juga menghitung alamat "nyata" berdasarkan alamat virtual dan alamat pustaka memuat alamat </li></ul><br><p>  Ada satu kehalusan.  Saat mengunduh file elf, sistem tidak memuat bagian <code>.symtab</code> (benar jika salah), dan bagian <code>.dynsym</code> tidak cocok untuk kami, karena kami tidak dapat mengekstraksi karakter dengan visibilitas <code>STV_INTERNAL</code> dan <code>STV_HIDDEN</code> .  Sederhananya, kita tidak akan melihat fungsi-fungsi seperti: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp namespace { int someUsefulFunction(int value) // &lt;----- { return value * 2; } }</span></span></code> </pre> <br><p>  dan variabel-variabel tersebut: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp void someDefaultFunction() { static int someVariable = 0; // &lt;----- ... }</span></span></code> </pre> <br><p>  Jadi, dalam paragraf 3, kami tidak bekerja dengan program yang diberikan <code>dl_iterate_phdr</code> kepada <code>dl_iterate_phdr</code> , tetapi dengan file yang kami unduh dari disk dan diurai oleh beberapa parser elf (atau di api kosong).  Jadi kami tidak ketinggalan apa pun.  Pada macOS, prosedurnya mirip, hanya nama-nama fungsi dari api sistem yang berbeda. </p><br><p>  Setelah itu, kami memfilter semua karakter dan hanya menyimpan: </p><br><ul><li>  Fungsi yang dapat dimuat ulang adalah karakter dari jenis <code>STT_FUNC</code> terletak di bagian <code>.text</code> , yang berukuran bukan nol.  Filter semacam itu hanya melompati fungsi yang kodenya benar-benar terdapat dalam program atau pustaka ini </li><li>  Variabel statis yang nilainya ingin Anda transfer adalah karakter bertipe <code>STT_OBJECT</code> terletak di bagian <code>.bss</code> </li></ul><br><h2 id="edinicy-translyacii">  Unit Siaran </h2><br><p>  Untuk memuat ulang kode, kita perlu tahu di mana mendapatkan file kode sumber dan cara mengompilasinya. </p><br><p>  Dalam implementasi pertama, saya membaca informasi ini dari bagian <code>.debug_info</code> , yang berisi informasi debug dalam format DWARF.  Agar setiap unit kompilasi (ET) dalam DWARF mendapatkan garis kompilasi untuk ET ini, Anda harus melewatkan <code>-grecord-gcc-switches</code> selama kompilasi.  DWARF sendiri, saya parsing perpustakaan libdwarf, yang dibundel dengan <code>libelf</code> .  Selain perintah kompilasi dari DWARF, Anda dapat memperoleh informasi tentang dependensi ET kami pada file lain.  Tetapi saya menolak implementasi ini karena beberapa alasan: </p><br><ul><li>  Perpustakaan cukup berat </li><li>  Mem-parsing aplikasi DWARF yang dikompilasi dari ~ 500 ET, dengan parsing dependensi, membutuhkan waktu lebih dari 10 detik </li></ul><br><p>  10 detik untuk memulai aplikasi terlalu banyak.  Setelah beberapa pemikiran, saya menulis ulang logika parsing DWARF ke parsing <code>compile_commands.json</code> .  File ini dapat dihasilkan hanya dengan menambahkan <code>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</code> ke CMakeLists.txt Anda.  Dengan demikian, kami mendapatkan semua informasi yang kami butuhkan. </p><br><h2 id="obrabotka-zavisimostey">  Penanganan ketergantungan </h2><br><p>  Karena kita meninggalkan DWARF, kita perlu menemukan opsi lain, bagaimana menangani dependensi antar file.  Saya benar-benar tidak ingin mem-parsing file dengan tangan saya dan mencari <code>include</code> di dalamnya, dan siapa yang tahu lebih banyak tentang dependensi daripada kompiler itu sendiri? </p><br><p>  Ada sejumlah opsi dalam dentang dan gcc yang menghasilkan apa yang disebut depfiles hampir gratis.  File-file ini menggunakan sistem make dan ninja build untuk menyelesaikan dependensi antar file.  Depfile memiliki format yang sangat sederhana: </p><br><pre> <code class="plaintext hljs">CMakeFiles/lib_efsw.dir/libs/efsw/src/efsw/DirectorySnapshot.cpp.o: \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/base.hpp \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/sophist.h \ /home/ddovod/_private/_projects/jet/live/libs/efsw/include/efsw/efsw.hpp \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/c++/7.3.0/string \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/c++config.h \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/os_defines.h \ ...</code> </pre> <br><p>  Compiler meletakkan file-file ini di sebelah file objek untuk setiap ET, itu tetap bagi kita untuk mengurai mereka dan meletakkannya dalam sebuah hashmap.  Total parsing <code>compile_commands.json</code> + depfiles untuk 500 ET yang sama membutuhkan waktu lebih dari 1 detik.  Agar semuanya berfungsi, kita perlu menambahkan flag <code>-MD</code> secara global untuk semua file proyek dalam opsi kompilasi. </p><br><p>  Ada satu kehalusan yang terkait dengan ninja.  Sistem build ini menghasilkan depfile terlepas dari keberadaan flag <code>-MD</code> untuk kebutuhan mereka.  Tetapi setelah dihasilkan, ia menerjemahkannya ke dalam format binernya, dan menghapus file sumber.  Karena itu, ketika memulai ninja, Anda harus melewati flag <code>-d keepdepfile</code> .  Juga, untuk alasan yang tidak diketahui oleh saya, dalam kasus make (dengan opsi <code>-MD</code> ) file disebut <code>some_file.cpp.d</code> , sedangkan dengan ninja disebut <code>some_file.cpp.od</code> .  Karena itu, Anda perlu memeriksa kedua versi. </p><br><h2 id="perenos-staticheskih-peremennyh">  Transfer Variabel Statis </h2><br><p>  Misalkan kita memiliki kode seperti itu (contoh yang sangat sintetik): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Singleton.hpp class Singletor { public: static Singleton&amp; instance(); }; int veryUsefulFunction(int value); // Singleton.cpp Singleton&amp; Singletor::instance() { static Singleton ins; return ins; } int veryUsefulFunction(int value) { return value * 2; }</span></span></code> </pre> <br><p>  Kami ingin mengubah fungsi <code>veryUsefulFunction</code> menjadi ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veryUsefulFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value * <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br><p>  Ketika memuat ulang, di perpustakaan dinamis dengan kode baru, di samping <code>veryUsefulFunction</code> , variabel <code>static Singleton ins;</code>  , dan metode <code>Singletor::instance</code> .  Akibatnya, program akan mulai memanggil versi baru dari kedua fungsi.  Tetapi <code>ins</code> statis di perpustakaan ini belum diinisialisasi, dan oleh karena itu, saat pertama kali diakses, konstruktor dari kelas <code>Singleton</code> akan dipanggil.  Tentu saja, kami tidak menginginkan ini.  Oleh karena itu, implementasinya mentransfer nilai-nilai semua variabel yang ditemukan di pustaka dinamis yang dirakit dari kode lama ke pustaka yang sangat dinamis ini dengan kode baru beserta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">variabel penjaganya</a> . </p><br><p>  Ada satu momen halus dan umumnya tidak larut. <br>  Misalkan kita memiliki kelas: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  Metode dipanggilEachUpdate disebut 60 kali per detik.  Kami mengubahnya dengan menambahkan bidang baru: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; m_someVar2++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  Jika sebuah instance dari kelas ini terletak di memori dinamis atau di stack, setelah memuat ulang kode, aplikasi kemungkinan akan crash.  Instance yang dialokasikan hanya berisi variabel <code>m_someVar1</code> , tetapi setelah reboot, metode <code>calledEachUpdate</code> akan mencoba mengubah <code>m_someVar2</code> , mengubah apa yang sebenarnya bukan milik instance ini, yang mengarah pada konsekuensi yang tidak dapat diprediksi.  Dalam hal ini, logika transfer keadaan ditransfer ke programmer, yang entah bagaimana harus menyimpan keadaan objek dan menghapus objek itu sendiri sebelum kode dimuat ulang, dan membuat objek baru setelah reboot.  Perpustakaan menyediakan acara dalam bentuk metode delegasi <code>onCodePostLoad</code> dan <code>onCodePostLoad</code> yang dapat diproses aplikasi. </p><br><p>  Saya tidak tahu bagaimana (dan apakah) mungkin untuk menyelesaikan situasi ini secara umum, saya akan berpikir.  Sekarang kasus ini "lebih atau kurang normal" hanya akan berfungsi untuk variabel statis, ia menggunakan logika berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* oldVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* newVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> oldVarSize = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> newVarSize = ...; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(newVarPtr, oldVarPtr, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(oldVarSize, newVarSize));</code> </pre> <br><p>  Ini tidak terlalu benar, tetapi ini adalah yang terbaik yang saya dapatkan. </p><br><p>  Akibatnya, kode akan berperilaku tidak terduga jika runtime mengubah set dan tata letak bidang dalam struktur data.  Hal yang sama berlaku untuk tipe polimorfik. </p><br><h2 id="sobiraem-vse-vmeste">  Menyatukan semuanya </h2><br><p>  Bagaimana semuanya bekerja bersama. </p><br><ul><li>  Perpustakaan beralih ke header dari semua perpustakaan yang dimuat secara dinamis ke dalam proses dan, pada kenyataannya, program itu sendiri, mem-parsing dan menyaring karakter. </li><li>  Selanjutnya, perpustakaan mencoba menemukan file <code>compile_commands.json</code> di direktori aplikasi dan di direktori induk secara rekursif, dan mengeluarkan semua informasi yang diperlukan tentang ET dari sana. </li><li>  Mengetahui path ke file objek, pustaka memuat dan mem-parsing depfile. </li><li>  Setelah itu, direktori paling umum untuk semua file kode sumber program dihitung, dan pemantauan direktori ini dimulai secara rekursif. </li><li>  Ketika suatu file berubah, perpustakaan melihat untuk melihat apakah itu ada dalam hashmap dependensi, dan jika ada, memulai beberapa proses kompilasi dari file yang diubah dan dependensinya di latar belakang, menggunakan perintah kompilasi dari <code>compile_commands.json</code> . </li><li>  Ketika program meminta Anda memuat ulang kode (dalam aplikasi saya, kombinasi <code>Ctrl+r</code> ditugaskan untuk ini), pustaka menunggu penyelesaian proses kompilasi dan menautkan semua objek baru ke pustaka dinamis. </li><li>  Pustaka ini kemudian dimuat ke ruang alamat proses <code>dlopen</code> fungsi <code>dlopen</code> . </li><li>  Informasi tentang simbol diambil dari perpustakaan ini, dan seluruh persimpangan set simbol dari perpustakaan ini dan simbol yang sudah hidup dalam proses dapat dimuat ulang (jika itu adalah fungsi) atau ditransfer (jika itu adalah variabel statis). </li></ul><br><p>  Ini bekerja dengan sangat baik, terutama ketika Anda tahu apa yang ada di balik tudung dan apa yang diharapkan, setidaknya pada tingkat tinggi. </p><br><p>  Secara pribadi, saya sangat terkejut dengan kurangnya solusi untuk Linux, adakah yang benar-benar tertarik dengan ini? </p><br><p>  Saya akan senang dengan kritik apa pun, terima kasih! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Tautan ke implementasi</strong></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435260/">https://habr.com/ru/post/id435260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435250/index.html">Bagaimana Universitas ITMO bekerja: tur laboratorium cyberphysical kami</a></li>
<li><a href="../id435252/index.html">Jessica Livingston: â€œBagaimana Kami Menciptakan Y Combinator. Komponen emosional "</a></li>
<li><a href="../id435254/index.html">Penanganan kesalahan fungsional di Kotlin menggunakan Panah</a></li>
<li><a href="../id435256/index.html">Kami menilai perekrut melalui surat dingin</a></li>
<li><a href="../id435258/index.html">Kami menulis bahasa pemrograman kami, bagian 2: representasi program menengah</a></li>
<li><a href="../id435262/index.html">Li-Fi: Masa Depan Internet</a></li>
<li><a href="../id435264/index.html">Mengedit harga dalam RMK. 1C: Manajemen Perdagangan 11</a></li>
<li><a href="../id435268/index.html">Jangan perlakukan aku, dokter</a></li>
<li><a href="../id435270/index.html">Amankan kunci SSH</a></li>
<li><a href="../id435272/index.html">Siklofobia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>