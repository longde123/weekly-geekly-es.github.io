<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèß ‚ôêÔ∏è ü¶ë Auswahl der richtigen Datenstruktur in Swift üßùüèª üèÅ üí¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo nochmal. Bevor wir zum Wochenende abreisen, m√∂chten wir Ihnen eine √úbersetzung von Material mitteilen, das speziell f√ºr den Grundkurs ‚ÄûiOS Devel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Auswahl der richtigen Datenstruktur in Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/468239/">  <i>Hallo nochmal.</i>  <i>Bevor wir zum Wochenende abreisen, m√∂chten wir Ihnen eine √úbersetzung von Material mitteilen, das speziell f√ºr den Grundkurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûiOS Developer‚Äú erstellt wurde</a> .</i> <br><br><img src="https://habrastorage.org/webt/hu/wa/i0/huwai0itmfwakcyvain6xjf2jlm.png"><br><hr><br>  Die Entscheidung, welche Datenstruktur zur Darstellung eines bestimmten Wertesatzes verwendet werden soll, ist oft viel schwieriger als es scheint.  Da jede Art von Datenstruktur f√ºr eine bestimmte Anzahl von Anwendungsf√§llen optimiert ist, kann die Auswahl der richtigen Anpassung f√ºr jeden Datensatz h√§ufig einen gro√üen Einfluss auf die Leistung unseres Codes haben. <a name="habracut"></a><br><br>  Die Standard-Swift-Bibliothek enth√§lt drei Hauptdatenstrukturen: <code>Array</code> , <code>Dictionary</code> und <code>Set</code> , von denen jede ihre eigenen Optimierungen, Vor- und Nachteile hat.  Schauen wir uns einige ihrer Merkmale sowie F√§lle an, in denen wir m√∂glicherweise √ºber die Standardbibliothek hinausgehen m√ºssen, um die richtige Datenstruktur f√ºr unsere Zwecke zu finden. <br><br><h3>  Array-Linearit√§t </h3><br>  <code>Array</code> ist wahrscheinlich eine der am h√§ufigsten verwendeten Datenstrukturen in Swift, und daf√ºr gibt es gute Gr√ºnde.  Es speichert seine Elemente nacheinander, sie sind leicht vorhersehbar zu sortieren und alle Werte k√∂nnen darin gespeichert werden: von Strukturen bis zu Instanzen von Klassen und anderen Sammlungen. <br><br>  Hier verwenden wir beispielsweise ein Array, um eine Sammlung von Formen zu speichern, die in einer Zeichenanwendung auf einer <code>Canvas</code> platziert sind.  Wenn wir dann die Leinwand in ein Bild rendern m√ºssen, gehen wir einfach durch das Array, um jedes Element mit dem <code>DrawingContext</code> zu zeichnen - wie folgt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes: [<span class="hljs-type"><span class="hljs-type">Shape</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } }</code> </pre> <br>  Wenn es um das sequentielle Rendern aller unserer Formen geht, wie oben beschrieben, passt das Array perfekt.  Arrays speichern ihre Elemente nicht nur sehr effizient, sondern verf√ºgen auch √ºber eine garantierte Sortierreihenfolge, die eine vorhersehbare Renderreihenfolge bietet, ohne dass zus√§tzliche Arbeiten erforderlich sind. <br><br>  Wie alle anderen Datenstrukturen haben Arrays jedoch ihre Nachteile.  In unserem Fall werden wir auf einen seiner Nachteile sto√üen, wenn wir Formen von der Leinwand entfernen m√∂chten.  Da die Elemente des Arrays nach Index gespeichert sind, m√ºssen wir immer zuerst herausfinden, welchem ‚Äã‚ÄãIndex die Figur zugeordnet ist, bevor wir sie l√∂schen k√∂nnen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = shapes.firstIndex(of: shape) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(at: index) } }</code> </pre> <br>  Auf den ersten <code>firstIndex</code> mag der obige Code nicht so problematisch erscheinen, aber er kann zu einem Leistungsengpass f√ºr jede <code>firstIndex</code> die eine gro√üe Anzahl von Formen enth√§lt, da <code>firstIndex</code> in Bezug auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeitkomplexit√§t</a> linear (O (N)) ist. <br><br>  Obwohl wir diese Einschr√§nkung umgehen k√∂nnen, wenn wir unseren Canvas-Typ verwenden.  Wenn Sie sich beispielsweise immer auf Zahlen nach Index und nicht nach Wert oder ID beziehen, wird unser Code komplexer und fragiler, da wir immer sicherstellen m√ºssen, dass unsere Indizes nicht ablaufen, wenn die Zeichenfl√§che verwendet wird, mit der wir arbeiten wird sich √§ndern. <br><br><h3>  Geschwindigkeitss√§tze </h3><br>  Lassen Sie uns stattdessen sehen, ob wir den <code>Canvas</code> selbst optimieren k√∂nnen, indem wir die zugrunde liegende Datenstruktur √§ndern.  In Anbetracht des obigen Problems k√∂nnte eine unserer ersten Ideen darin bestehen, <code>Set</code> (Sets) anstelle von <code>Array</code> .  Wie wir bereits in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Potenz von Mengen in Swift</a> besprochen haben, besteht einer der wesentlichen Vorteile von Mengen gegen√ºber Arrays darin, dass sowohl das Einf√ºgen als auch das L√∂schen immer in einer konstanten (O (1)) Zeit ausgef√ºhrt werden k√∂nnen. da Elemente nach Hashwert und nicht nach Index gespeichert werden. <br><br>  Durch die Aktualisierung von <code>Canvas</code> zur Verwendung von Sets erhalten wir Folgendes: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes: <span class="hljs-type"><span class="hljs-type">Set</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { shapes.remove(shape) } }</code> </pre> <br>  Auch hier kann der obige Code richtig aussehen und sogar problemlos kompiliert werden.  Obwohl wir das L√∂schproblem gel√∂st haben, haben wir auch unsere stabile Renderreihenfolge verloren - da Sets im Gegensatz zu Arrays keine garantierte Sortierreihenfolge bieten -, was in dieser Situation ein Stolperstein ist, da es so aussieht, als w√ºrden wir benutzerdefinierte Formen zeichnen zuf√§llig. <br><br><h3>  Indizierung von Indizes </h3><br>  Lass uns weiter experimentieren.  Lassen Sie uns nun sehen, ob wir den <code>Canvas</code> optimieren k√∂nnen, indem wir ein <code>Dictionary</code> einf√ºhren, mit dem wir anhand seiner ID nach dem Index einer beliebigen Form suchen k√∂nnen.  Zun√§chst √§ndern wir die Zugriffsebene f√ºr unser <code>shapes</code> Array in " <code>private</code> damit wir das Einf√ºgen von Elementen mithilfe der neuen <code>add</code> Methode steuern k√∂nnen.  Und jedes Mal, wenn eine neue Figur hinzugef√ºgt wird, f√ºgen wir ihren Index auch unserem W√∂rterbuch hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indexes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> : <span class="hljs-type"><span class="hljs-type">Int</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = shapes.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> indexes[shape.id] = index shapes.append(shape) } }</code> </pre> <br>  Da wir jetzt immer wissen, an welchem ‚Äã‚ÄãIndex eine bestimmte Zahl gespeichert ist, k√∂nnen wir das L√∂schen schnell in konstanter Zeit durchf√ºhren, wie bei Verwendung eines Satzes: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = indexes[shape.id] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(at: index) indexes[shape.id] = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Es gibt jedoch einen ziemlich schwerwiegenden Fehler in unserer neuen <code>Canvas</code> Implementierung.  Jedes Mal, wenn wir eine Form l√∂schen, werden alle Indizes ung√ºltig, die h√∂her sind als der gerade gel√∂schte. Da jedes dieser Elemente einen Schritt an den Anfang des Arrays verschoben wird.  Wir k√∂nnten dieses Problem l√∂sen, indem wir diese Indizes nach jedem L√∂schen anpassen, aber dies w√ºrde uns wieder in das O (N) -Gebiet zur√ºckbringen, das wir von Anfang an zu vermeiden versuchten. <br><br>  Unsere neueste Implementierung hat ihre Vorz√ºge.  Im Allgemeinen kann die Verwendung einer Kombination aus zwei Datenstrukturen in solchen Situationen eine gute Idee sein, da wir h√§ufig die St√§rken einer Datenstruktur verwenden k√∂nnen, um die M√§ngel der anderen zu kompensieren, und umgekehrt. <br><br>  Versuchen wir es also noch einmal mit einer anderen Kombination, aber diesmal betrachten wir zun√§chst unsere <i>tats√§chlichen Anforderungen</i> : <br><br><ul><li>  Wir brauchen sowohl Einf√ºgungen als auch L√∂schungen, um eine konstante zeitliche Komplexit√§t zu haben, und es sollte m√∂glich sein, die Figur zu l√∂schen, ohne ihren Basisindex zu kennen. </li><li>  Wir ben√∂tigen eine garantierte Sortierreihenfolge, um eine stabile Renderreihenfolge aufrechterhalten zu k√∂nnen. </li></ul><br>  Wenn man sich die oben genannten Anforderungen ansieht, stellt sich heraus, dass wir zwar eine stabile Sortierreihenfolge ben√∂tigen, aber tats√§chlich keine Indizes ben√∂tigen.  Dies w√ºrde die verkn√ºpfte Liste perfekt f√ºr unseren Anwendungsfall machen. <br><br>  Verkn√ºpfte Listen bestehen aus Knoten, wobei jeder Knoten einen Link (oder Link) zum n√§chsten Knoten in der Liste enth√§lt. Dies bedeutet, dass er auf vorhersehbare Weise sortiert werden kann - ohne dass Indexaktualisierungen erforderlich sind, wenn ein Element gel√∂scht wird.  Die Swift-Standardbibliothek enth√§lt jedoch (bisher) keinen verkn√ºpften Listentyp. Wenn wir ihn also verwenden m√∂chten, m√ºssen wir ihn zuerst erstellen. <br><br><h3>  Erstellen Sie eine verkn√ºpfte Liste </h3><br>  Beginnen wir mit der Deklaration einer Listenstruktur, die den ersten und den letzten Knoten in unserer Liste verfolgt.  Wir werden diese beiden Eigenschaften au√üerhalb unseres Typs schreibgesch√ºtzt machen, um die Datenkonsistenz sicherzustellen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> }</code> </pre> <br>  Als n√§chstes erstellen wir unseren Knotentyp (Knoten), den wir zu einer Klasse machen, da wir in der Lage sein m√∂chten, auf Knoten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nach Referenz und nicht nach Wert</a> zu verweisen.  Unsere Liste wird doppelt verbunden sein, was bedeutet, dass jeder Knoten eine Verkn√ºpfung sowohl zum n√§chsten als auch zum vorherigen Nachbarn enth√§lt.  Jeder Knoten speichert auch einen Wert - wie folgt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previous: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> next: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(value: <span class="hljs-type"><span class="hljs-type">Value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value } } }</code> </pre> <br><blockquote>  Der Grund, warum wir die vorherige Eigenschaft schwach machen, besteht darin, die Retain-Schleifen zu vermeiden, die auftreten w√ºrden, wenn wir starke Verbindungen in beide Richtungen beibehalten w√ºrden.  Weitere Informationen zum Vermeiden von Aufbewahrungszyklen finden Sie im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûSpeicherverwaltung‚Äú</a> . </blockquote>  Dies ist eigentlich der gesamte Code, den wir ben√∂tigen, damit Werte in unserer verkn√ºpften Liste gespeichert werden k√∂nnen.  Dies ist jedoch nur der erste Teil des Puzzles, wie in jeder anderen Sammlung m√∂chten wir auch in der Lage sein, dar√ºber zu iterieren und seinen Inhalt zu √§ndern.  Beginnen wir mit Iterationen, die dank des sehr protokollorientierten Swift-Designs einfach implementiert werden k√∂nnen, indem die Einhaltung des <code>Sequence</code> sichergestellt und die <code>makeIterator</code> Methode implementiert wird: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Value</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = firstNode <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,    ,    : let value = node?.value node = node?.next return value } } }</span></span></code> </pre> <br><blockquote>  Da die obige Iteration sehr einfach ist, verwenden wir die <code>AnyIterator</code> Standardbibliothek, um zu vermeiden, dass ein benutzerdefinierter Iteratortyp implementiert werden muss.  F√ºr komplexere Szenarien kann es durch Hinzuf√ºgen einer √úbereinstimmung zu <code>IteratorProtocol</code> implementiert werden. </blockquote>  Als n√§chstes f√ºgen wir eine API hinzu, um unsere verkn√ºpfte Liste zu √§ndern, beginnend mit den Einf√ºgungen.  Wir werden die <code>List</code> mit der <code>append</code> Methode erweitern, die einen neuen Knoten f√ºr den eingef√ºgten Wert hinzuf√ºgt und diesen Knoten dann wie folgt zur√ºckgibt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@discardableResult</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value: Value)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Node</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = <span class="hljs-type"><span class="hljs-type">Node</span></span>(value: value) node.previous = lastNode lastNode?.next = node lastNode = node <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNode == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { firstNode = node } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node } }</code> </pre> <br><blockquote>  Oben verwenden wir das Attribut <code>@discardableResult</code> , das den Compiler <code>@discardableResult</code> , keine Warnungen zu generieren, wenn das Ergebnis des Aufrufs unserer Methode nicht verwendet wurde, da wir nicht immer an dem erstellten Knoten interessiert sind. </blockquote>  Da verkn√ºpfte Listen nicht auf Indizes basieren, sondern auf der Aufrechterhaltung einer Wertekette √ºber Verkn√ºpfungen, m√ºssen beim Implementieren von L√∂schungen nur die folgenden und vorherigen Nachbarn der Remote-Knoten aktualisiert werden, sodass sie stattdessen aufeinander verweisen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> node: Node)</span></span></span></span> { node.previous?.next = node.next node.next?.previous = node.previous <span class="hljs-comment"><span class="hljs-comment">//  ¬´ ¬ª,        ,    : if firstNode === node { firstNode = node.next } if lastNode === node { lastNode = node.previous } } }</span></span></code> </pre> <br>  Auf der Grundlage des Vorstehenden ist die urspr√ºngliche Version unserer Liste fertiggestellt, und wir sind bereit, sie in Aktion zu √ºberpr√ºfen.  Aktualisieren wir den Canvas-Bereich, um unsere neue Liste sowie ein W√∂rterbuch zu verwenden, mit dem wir schnell herausfinden k√∂nnen, welcher Knoten mit einer bestimmten Form-ID √ºbereinstimmt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes = <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> : <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt;.<span class="hljs-type"><span class="hljs-type">Node</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { nodes[shape.id] = shapes.append(shape) } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = nodes.removeValue(forKey: shape.id) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(node) } }</code> </pre> <br>  Jetzt haben wir sowohl schnelles Einf√ºgen als auch L√∂schen und eine vorhersehbare Sortierreihenfolge, ohne dass der Anrufprozess noch komplexer werden muss - es ist ziemlich cool!  Und da unsere neue Liste ein v√∂llig universeller Typ ist, k√∂nnen wir sie jetzt verwenden, wenn wir erneut Werte ohne Index linear speichern m√ºssen. <br><br><h3>  Fazit </h3><br>  Trotz der Tatsache, dass die Datenstrukturen so grundlegend sind, dass sie in allen Arten von Programmiersprachen zu finden sind, erfordert die Entscheidung, welche in jeder spezifischen Situation verwendet werden soll, m√∂glicherweise noch viel Nachdenken, Testen und Experimentieren, insbesondere wenn wir dies m√∂chten Damit unser Code wirksam bleibt, wenn der Datensatz w√§chst. <br><br>  Es ist auch sehr wahrscheinlich, dass sich die geeignete Datenstruktur f√ºr jede spezifische Situation im Laufe der Zeit √§ndert, wenn sich unsere Anforderungen √§ndern, und manchmal kann die Verwendung einer Kombination aus mehreren Datenstrukturen und nicht nur einer eine M√∂glichkeit sein, die erforderlichen Leistungsmerkmale zu erreichen. <br><br>  In den folgenden Artikeln werden wir uns weiter mit der Welt der Datenstrukturen befassen und uns auf diejenigen konzentrieren, die noch nicht in der Standardbibliothek implementiert sind.  Wie bei so vielen anderen Dingen m√ºssen wir manchmal unser Denken √ºber Swift hinaus erweitern, um die richtige Datenstruktur f√ºr jede Situation auszuw√§hlen. <br><br>  Sie k√∂nnen mich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Twitter finden</a> oder mir eine E-Mail senden, wenn Sie Fragen, Kommentare oder Feedback haben. <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468239/">https://habr.com/ru/post/de468239/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468229/index.html">Ein Hinweis zur Leere in JavaScript und TypeScript</a></li>
<li><a href="../de468231/index.html">Ist die Sicherheit in AEM ein Plattform- oder Implementierungsproblem?</a></li>
<li><a href="../de468233/index.html">Die M√∂glichkeit, 4 Millionen Zeilen Python-Code zu √ºberpr√ºfen. Teil 1</a></li>
<li><a href="../de468235/index.html">Die M√∂glichkeit, 4 Millionen Zeilen Python-Code zu √ºberpr√ºfen. Teil 2</a></li>
<li><a href="../de468237/index.html">Die M√∂glichkeit, 4 Millionen Zeilen Python-Code zu √ºberpr√ºfen. Teil 3</a></li>
<li><a href="../de468241/index.html">TR-069 bei Mikrotik. Testen von Freeacs als Autokonfigurationsserver f√ºr RouterOS</a></li>
<li><a href="../de468245/index.html">Wir brauchen keine √úbersetzungskorrekturen: Unser √úbersetzer wei√ü besser, wie dies √ºbersetzt werden soll</a></li>
<li><a href="../de468251/index.html">Es gibt keine Zukunft</a></li>
<li><a href="../de468253/index.html">Einfacher Bildschieberegler in CSS und Javascript</a></li>
<li><a href="../de468259/index.html">F√ºnf H√∂hepunkte des Helmgipfels 2019 in Amsterdam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>