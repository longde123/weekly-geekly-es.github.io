<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏧 ♐️ 🦑 Auswahl der richtigen Datenstruktur in Swift 🧝🏻 🏁 💢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo nochmal. Bevor wir zum Wochenende abreisen, möchten wir Ihnen eine Übersetzung von Material mitteilen, das speziell für den Grundkurs „iOS Devel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Auswahl der richtigen Datenstruktur in Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/468239/">  <i>Hallo nochmal.</i>  <i>Bevor wir zum Wochenende abreisen, möchten wir Ihnen eine Übersetzung von Material mitteilen, das speziell für den Grundkurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„iOS Developer“ erstellt wurde</a> .</i> <br><br><img src="https://habrastorage.org/webt/hu/wa/i0/huwai0itmfwakcyvain6xjf2jlm.png"><br><hr><br>  Die Entscheidung, welche Datenstruktur zur Darstellung eines bestimmten Wertesatzes verwendet werden soll, ist oft viel schwieriger als es scheint.  Da jede Art von Datenstruktur für eine bestimmte Anzahl von Anwendungsfällen optimiert ist, kann die Auswahl der richtigen Anpassung für jeden Datensatz häufig einen großen Einfluss auf die Leistung unseres Codes haben. <a name="habracut"></a><br><br>  Die Standard-Swift-Bibliothek enthält drei Hauptdatenstrukturen: <code>Array</code> , <code>Dictionary</code> und <code>Set</code> , von denen jede ihre eigenen Optimierungen, Vor- und Nachteile hat.  Schauen wir uns einige ihrer Merkmale sowie Fälle an, in denen wir möglicherweise über die Standardbibliothek hinausgehen müssen, um die richtige Datenstruktur für unsere Zwecke zu finden. <br><br><h3>  Array-Linearität </h3><br>  <code>Array</code> ist wahrscheinlich eine der am häufigsten verwendeten Datenstrukturen in Swift, und dafür gibt es gute Gründe.  Es speichert seine Elemente nacheinander, sie sind leicht vorhersehbar zu sortieren und alle Werte können darin gespeichert werden: von Strukturen bis zu Instanzen von Klassen und anderen Sammlungen. <br><br>  Hier verwenden wir beispielsweise ein Array, um eine Sammlung von Formen zu speichern, die in einer Zeichenanwendung auf einer <code>Canvas</code> platziert sind.  Wenn wir dann die Leinwand in ein Bild rendern müssen, gehen wir einfach durch das Array, um jedes Element mit dem <code>DrawingContext</code> zu zeichnen - wie folgt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes: [<span class="hljs-type"><span class="hljs-type">Shape</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } }</code> </pre> <br>  Wenn es um das sequentielle Rendern aller unserer Formen geht, wie oben beschrieben, passt das Array perfekt.  Arrays speichern ihre Elemente nicht nur sehr effizient, sondern verfügen auch über eine garantierte Sortierreihenfolge, die eine vorhersehbare Renderreihenfolge bietet, ohne dass zusätzliche Arbeiten erforderlich sind. <br><br>  Wie alle anderen Datenstrukturen haben Arrays jedoch ihre Nachteile.  In unserem Fall werden wir auf einen seiner Nachteile stoßen, wenn wir Formen von der Leinwand entfernen möchten.  Da die Elemente des Arrays nach Index gespeichert sind, müssen wir immer zuerst herausfinden, welchem ​​Index die Figur zugeordnet ist, bevor wir sie löschen können: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = shapes.firstIndex(of: shape) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(at: index) } }</code> </pre> <br>  Auf den ersten <code>firstIndex</code> mag der obige Code nicht so problematisch erscheinen, aber er kann zu einem Leistungsengpass für jede <code>firstIndex</code> die eine große Anzahl von Formen enthält, da <code>firstIndex</code> in Bezug auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeitkomplexität</a> linear (O (N)) ist. <br><br>  Obwohl wir diese Einschränkung umgehen können, wenn wir unseren Canvas-Typ verwenden.  Wenn Sie sich beispielsweise immer auf Zahlen nach Index und nicht nach Wert oder ID beziehen, wird unser Code komplexer und fragiler, da wir immer sicherstellen müssen, dass unsere Indizes nicht ablaufen, wenn die Zeichenfläche verwendet wird, mit der wir arbeiten wird sich ändern. <br><br><h3>  Geschwindigkeitssätze </h3><br>  Lassen Sie uns stattdessen sehen, ob wir den <code>Canvas</code> selbst optimieren können, indem wir die zugrunde liegende Datenstruktur ändern.  In Anbetracht des obigen Problems könnte eine unserer ersten Ideen darin bestehen, <code>Set</code> (Sets) anstelle von <code>Array</code> .  Wie wir bereits in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Potenz von Mengen in Swift</a> besprochen haben, besteht einer der wesentlichen Vorteile von Mengen gegenüber Arrays darin, dass sowohl das Einfügen als auch das Löschen immer in einer konstanten (O (1)) Zeit ausgeführt werden können. da Elemente nach Hashwert und nicht nach Index gespeichert werden. <br><br>  Durch die Aktualisierung von <code>Canvas</code> zur Verwendung von Sets erhalten wir Folgendes: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes: <span class="hljs-type"><span class="hljs-type">Set</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { shapes.remove(shape) } }</code> </pre> <br>  Auch hier kann der obige Code richtig aussehen und sogar problemlos kompiliert werden.  Obwohl wir das Löschproblem gelöst haben, haben wir auch unsere stabile Renderreihenfolge verloren - da Sets im Gegensatz zu Arrays keine garantierte Sortierreihenfolge bieten -, was in dieser Situation ein Stolperstein ist, da es so aussieht, als würden wir benutzerdefinierte Formen zeichnen zufällig. <br><br><h3>  Indizierung von Indizes </h3><br>  Lass uns weiter experimentieren.  Lassen Sie uns nun sehen, ob wir den <code>Canvas</code> optimieren können, indem wir ein <code>Dictionary</code> einführen, mit dem wir anhand seiner ID nach dem Index einer beliebigen Form suchen können.  Zunächst ändern wir die Zugriffsebene für unser <code>shapes</code> Array in " <code>private</code> damit wir das Einfügen von Elementen mithilfe der neuen <code>add</code> Methode steuern können.  Und jedes Mal, wenn eine neue Figur hinzugefügt wird, fügen wir ihren Index auch unserem Wörterbuch hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indexes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> : <span class="hljs-type"><span class="hljs-type">Int</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = shapes.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> indexes[shape.id] = index shapes.append(shape) } }</code> </pre> <br>  Da wir jetzt immer wissen, an welchem ​​Index eine bestimmte Zahl gespeichert ist, können wir das Löschen schnell in konstanter Zeit durchführen, wie bei Verwendung eines Satzes: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = indexes[shape.id] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(at: index) indexes[shape.id] = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Es gibt jedoch einen ziemlich schwerwiegenden Fehler in unserer neuen <code>Canvas</code> Implementierung.  Jedes Mal, wenn wir eine Form löschen, werden alle Indizes ungültig, die höher sind als der gerade gelöschte. Da jedes dieser Elemente einen Schritt an den Anfang des Arrays verschoben wird.  Wir könnten dieses Problem lösen, indem wir diese Indizes nach jedem Löschen anpassen, aber dies würde uns wieder in das O (N) -Gebiet zurückbringen, das wir von Anfang an zu vermeiden versuchten. <br><br>  Unsere neueste Implementierung hat ihre Vorzüge.  Im Allgemeinen kann die Verwendung einer Kombination aus zwei Datenstrukturen in solchen Situationen eine gute Idee sein, da wir häufig die Stärken einer Datenstruktur verwenden können, um die Mängel der anderen zu kompensieren, und umgekehrt. <br><br>  Versuchen wir es also noch einmal mit einer anderen Kombination, aber diesmal betrachten wir zunächst unsere <i>tatsächlichen Anforderungen</i> : <br><br><ul><li>  Wir brauchen sowohl Einfügungen als auch Löschungen, um eine konstante zeitliche Komplexität zu haben, und es sollte möglich sein, die Figur zu löschen, ohne ihren Basisindex zu kennen. </li><li>  Wir benötigen eine garantierte Sortierreihenfolge, um eine stabile Renderreihenfolge aufrechterhalten zu können. </li></ul><br>  Wenn man sich die oben genannten Anforderungen ansieht, stellt sich heraus, dass wir zwar eine stabile Sortierreihenfolge benötigen, aber tatsächlich keine Indizes benötigen.  Dies würde die verknüpfte Liste perfekt für unseren Anwendungsfall machen. <br><br>  Verknüpfte Listen bestehen aus Knoten, wobei jeder Knoten einen Link (oder Link) zum nächsten Knoten in der Liste enthält. Dies bedeutet, dass er auf vorhersehbare Weise sortiert werden kann - ohne dass Indexaktualisierungen erforderlich sind, wenn ein Element gelöscht wird.  Die Swift-Standardbibliothek enthält jedoch (bisher) keinen verknüpften Listentyp. Wenn wir ihn also verwenden möchten, müssen wir ihn zuerst erstellen. <br><br><h3>  Erstellen Sie eine verknüpfte Liste </h3><br>  Beginnen wir mit der Deklaration einer Listenstruktur, die den ersten und den letzten Knoten in unserer Liste verfolgt.  Wir werden diese beiden Eigenschaften außerhalb unseres Typs schreibgeschützt machen, um die Datenkonsistenz sicherzustellen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> }</code> </pre> <br>  Als nächstes erstellen wir unseren Knotentyp (Knoten), den wir zu einer Klasse machen, da wir in der Lage sein möchten, auf Knoten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nach Referenz und nicht nach Wert</a> zu verweisen.  Unsere Liste wird doppelt verbunden sein, was bedeutet, dass jeder Knoten eine Verknüpfung sowohl zum nächsten als auch zum vorherigen Nachbarn enthält.  Jeder Knoten speichert auch einen Wert - wie folgt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previous: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> next: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(value: <span class="hljs-type"><span class="hljs-type">Value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value } } }</code> </pre> <br><blockquote>  Der Grund, warum wir die vorherige Eigenschaft schwach machen, besteht darin, die Retain-Schleifen zu vermeiden, die auftreten würden, wenn wir starke Verbindungen in beide Richtungen beibehalten würden.  Weitere Informationen zum Vermeiden von Aufbewahrungszyklen finden Sie im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Speicherverwaltung“</a> . </blockquote>  Dies ist eigentlich der gesamte Code, den wir benötigen, damit Werte in unserer verknüpften Liste gespeichert werden können.  Dies ist jedoch nur der erste Teil des Puzzles, wie in jeder anderen Sammlung möchten wir auch in der Lage sein, darüber zu iterieren und seinen Inhalt zu ändern.  Beginnen wir mit Iterationen, die dank des sehr protokollorientierten Swift-Designs einfach implementiert werden können, indem die Einhaltung des <code>Sequence</code> sichergestellt und die <code>makeIterator</code> Methode implementiert wird: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Value</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = firstNode <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,    ,    : let value = node?.value node = node?.next return value } } }</span></span></code> </pre> <br><blockquote>  Da die obige Iteration sehr einfach ist, verwenden wir die <code>AnyIterator</code> Standardbibliothek, um zu vermeiden, dass ein benutzerdefinierter Iteratortyp implementiert werden muss.  Für komplexere Szenarien kann es durch Hinzufügen einer Übereinstimmung zu <code>IteratorProtocol</code> implementiert werden. </blockquote>  Als nächstes fügen wir eine API hinzu, um unsere verknüpfte Liste zu ändern, beginnend mit den Einfügungen.  Wir werden die <code>List</code> mit der <code>append</code> Methode erweitern, die einen neuen Knoten für den eingefügten Wert hinzufügt und diesen Knoten dann wie folgt zurückgibt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@discardableResult</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value: Value)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Node</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = <span class="hljs-type"><span class="hljs-type">Node</span></span>(value: value) node.previous = lastNode lastNode?.next = node lastNode = node <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNode == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { firstNode = node } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node } }</code> </pre> <br><blockquote>  Oben verwenden wir das Attribut <code>@discardableResult</code> , das den Compiler <code>@discardableResult</code> , keine Warnungen zu generieren, wenn das Ergebnis des Aufrufs unserer Methode nicht verwendet wurde, da wir nicht immer an dem erstellten Knoten interessiert sind. </blockquote>  Da verknüpfte Listen nicht auf Indizes basieren, sondern auf der Aufrechterhaltung einer Wertekette über Verknüpfungen, müssen beim Implementieren von Löschungen nur die folgenden und vorherigen Nachbarn der Remote-Knoten aktualisiert werden, sodass sie stattdessen aufeinander verweisen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> node: Node)</span></span></span></span> { node.previous?.next = node.next node.next?.previous = node.previous <span class="hljs-comment"><span class="hljs-comment">//  « »,        ,    : if firstNode === node { firstNode = node.next } if lastNode === node { lastNode = node.previous } } }</span></span></code> </pre> <br>  Auf der Grundlage des Vorstehenden ist die ursprüngliche Version unserer Liste fertiggestellt, und wir sind bereit, sie in Aktion zu überprüfen.  Aktualisieren wir den Canvas-Bereich, um unsere neue Liste sowie ein Wörterbuch zu verwenden, mit dem wir schnell herausfinden können, welcher Knoten mit einer bestimmten Form-ID übereinstimmt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes = <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> : <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt;.<span class="hljs-type"><span class="hljs-type">Node</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { nodes[shape.id] = shapes.append(shape) } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = nodes.removeValue(forKey: shape.id) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(node) } }</code> </pre> <br>  Jetzt haben wir sowohl schnelles Einfügen als auch Löschen und eine vorhersehbare Sortierreihenfolge, ohne dass der Anrufprozess noch komplexer werden muss - es ist ziemlich cool!  Und da unsere neue Liste ein völlig universeller Typ ist, können wir sie jetzt verwenden, wenn wir erneut Werte ohne Index linear speichern müssen. <br><br><h3>  Fazit </h3><br>  Trotz der Tatsache, dass die Datenstrukturen so grundlegend sind, dass sie in allen Arten von Programmiersprachen zu finden sind, erfordert die Entscheidung, welche in jeder spezifischen Situation verwendet werden soll, möglicherweise noch viel Nachdenken, Testen und Experimentieren, insbesondere wenn wir dies möchten Damit unser Code wirksam bleibt, wenn der Datensatz wächst. <br><br>  Es ist auch sehr wahrscheinlich, dass sich die geeignete Datenstruktur für jede spezifische Situation im Laufe der Zeit ändert, wenn sich unsere Anforderungen ändern, und manchmal kann die Verwendung einer Kombination aus mehreren Datenstrukturen und nicht nur einer eine Möglichkeit sein, die erforderlichen Leistungsmerkmale zu erreichen. <br><br>  In den folgenden Artikeln werden wir uns weiter mit der Welt der Datenstrukturen befassen und uns auf diejenigen konzentrieren, die noch nicht in der Standardbibliothek implementiert sind.  Wie bei so vielen anderen Dingen müssen wir manchmal unser Denken über Swift hinaus erweitern, um die richtige Datenstruktur für jede Situation auszuwählen. <br><br>  Sie können mich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Twitter finden</a> oder mir eine E-Mail senden, wenn Sie Fragen, Kommentare oder Feedback haben. <br><br>  Vielen Dank für Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468239/">https://habr.com/ru/post/de468239/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468229/index.html">Ein Hinweis zur Leere in JavaScript und TypeScript</a></li>
<li><a href="../de468231/index.html">Ist die Sicherheit in AEM ein Plattform- oder Implementierungsproblem?</a></li>
<li><a href="../de468233/index.html">Die Möglichkeit, 4 Millionen Zeilen Python-Code zu überprüfen. Teil 1</a></li>
<li><a href="../de468235/index.html">Die Möglichkeit, 4 Millionen Zeilen Python-Code zu überprüfen. Teil 2</a></li>
<li><a href="../de468237/index.html">Die Möglichkeit, 4 Millionen Zeilen Python-Code zu überprüfen. Teil 3</a></li>
<li><a href="../de468241/index.html">TR-069 bei Mikrotik. Testen von Freeacs als Autokonfigurationsserver für RouterOS</a></li>
<li><a href="../de468245/index.html">Wir brauchen keine Übersetzungskorrekturen: Unser Übersetzer weiß besser, wie dies übersetzt werden soll</a></li>
<li><a href="../de468251/index.html">Es gibt keine Zukunft</a></li>
<li><a href="../de468253/index.html">Einfacher Bildschieberegler in CSS und Javascript</a></li>
<li><a href="../de468259/index.html">Fünf Höhepunkte des Helmgipfels 2019 in Amsterdam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>