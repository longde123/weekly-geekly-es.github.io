<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆗 🎁 📱 GraphQL-一种新的API ⛹️ 👩‍❤️‍💋‍👩 👨🏾‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GraphQL查询语言是什么？ 这项技术提供了哪些优势？开发人员在使用该技术时会面临哪些问题？ 如何有效使用GraphQL？ 关于这一切的削减。 



 本文基于2017年Joker会议的Vladimir Tsukur （ volodymyrtsukur ）的介绍水平报告。 


 我叫弗拉基米尔...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GraphQL-一种新的API</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/428517/">  GraphQL查询语言是什么？ 这项技术提供了哪些优势？开发人员在使用该技术时会面临哪些问题？ 如何有效使用GraphQL？ 关于这一切的削减。 <br><br><img src="https://habrastorage.org/webt/d4/w4/cg/d4w4cgweq81ewi6vo51e1kbw9tu.jpeg"><br><br> 本文基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2017年Joker</a>会议的<b>Vladimir Tsukur</b> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">volodymyrtsukur</a> ）的介绍水平报告。 <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YgRmgHPTXr4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 我叫弗拉基米尔（Vladimir），我负责WIX部门之一的开发。 超过一亿的WIX用户创建了各种方向的网站-从名片网站和商店到复杂的Web应用程序，您可以在其中编写代码和任意逻辑。 作为WIX上一个项目的生动示例，我想向您展示成功的网站商店<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">unicornadoptions.com</a> ，该网站提供了购买驯服独角兽的工具包的机会-这是给孩子的好礼物。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a9/7ec/db8/2a97ecdb8542ecb4aff1213a5b8690b9.jpg"><br><br> 该站点的访问者可以选择他们喜欢驯服独角兽的工具箱（例如粉红色），然后查看该工具箱中的确切内容：玩具，证书，徽章。 此外，购买者有机会将商品添加到购物篮，查看其内容并下订单。 这是商店站点的一个简单示例，我们有成百上千的此类站点。 所有这些都建立在具有一个后端的同一平台上，并且我们为此使用API​​支持了一组客户端。 关于API，将进一步讨论。 <br><br><h2> 简单的API及其问题 </h2><br> 让我们想象一下可以创建哪个通用API（即平台顶部所有商店的一个API）来提供商店功能。 让我们仅专注于获取数据。 <br><br> 对于此类站点上的产品页面，应返回产品名称，价格，图片，描述，其他信息等。 在WIX商店的完整解决方案中，有超过两个这样的数据字段。 在HTTP API上执行此类任务的标准解决方案是描述<code>/products/:id</code>资源，该资源返回<code>GET</code>请求中的产品数据。 以下是响应数据的示例： <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"59eb83c0040fa80b29938e3f"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Combo Pack with Dreamy Eyes 12\" (Pink) Soft Toy"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: <span class="hljs-number"><span class="hljs-number">26.99</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Spread Unicorn love amongst your friends and family by purchasing a Unicorn adoption combo pack today. You'll receive your very own fabulous adoption pack and a 12\" Dreamy Eyes (Pink) cuddly toy. It makes the perfect gift for loved ones. Go on, you know you want to, adopt today!"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sku"</span></span>:<span class="hljs-string"><span class="hljs-string">"010"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"images"</span></span>: [   <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/img/918d8d4cc83d4e5f8680ca4edfd5b6b2.jpg"</span></span>,   <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/img/f343889c0bb94965845e65d3f39f8798.jpg"</span></span>,   <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/img/dd55129473e04f489806db0dc6468dd9.jpg"</span></span>,   <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/img/64eba4524a1f4d5d9f1687a815795643.jpg"</span></span>,   <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/img/5727549e9131440dbb3cd707dce45d0f.jpg"</span></span>,   <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/img/28ae9369ec3c442dbfe6901434ad15af.jpg"</span></span> ] }</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/ecf/5d6/4ac/ecf5d64acd1da66df56b6aa49f5eb6be.jpg"><br><br> 现在让我们看一下产品目录页面。 对于此页面，您需要<i>/ products</i>资源集合。 但是，仅在目录页面上显示产品集合时，并不需要所有产品数据，而仅需要价格，名称和主图像。 例如，描述，附加信息，背景图像等对我们而言并不重要。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa4/82b/0ed/aa482b0edf598fcc605eee75216e963b.png"><br><br> 为了简单起见，假设我们决定对资源<code>/products</code>和<code>/products/:id</code>使用相同的产品数据模型。 在收集此类产品的情况下，可能会有几种。 响应方案可以表示如下： <br><br><pre> <code class="javascript hljs">GET /products [ {   title   price   images   description   info   ... } ]</code> </pre><br> 现在，让我们看一下服务器对产品集合的响应的“有效负载”。 这是客户在两个以上字段中实际使用的内容： <br><br> <code>{ <br> <s>"id": "59eb83c0040fa80b29938e3f",</s> <br> "title": "Combo Pack with Dreamy Eyes 12\" (Pink) Soft Toy", <br> "price": 26.99, <br> <s>"info": "Spread Unicorn love amongst your friends and family by purchasing a Unicorn adoption combo pack today. You'll receive your very own fabulous adoption pack and a 12\" Dreamy Eyes (Pink) cuddly toy. It makes the perfect gift for loved ones. Go on, you know you want to, adopt todayl",</s> <br> " <s>description": "Your fabulous Unicorn adoption combo pack contains:\nA 12\" Dreamy Eyes (Pink) Unicorn Soft Toy\nA blank Unicorn adoption certificate — name your Unicorn!\nA confirmation letter\nA Unicorn badge\nA Unicorn key ring\nA Unicorn face mask (self assembly)\nA Unicorn bookmark\nA Unicorn colouring in sheet\nA A4 Unicorn posters\n2 x Unicorn postcards\n3 x Unicorn stickers",</s> <br> "images": [ <br> "http://localhost:8080/img/918d8d4cc83d4e5f8680ca4edfd5b6b2.jpg", <br> <s>"http://localhost:8080/img/f343889c0bb94965845e65d3f39f8798.jpg",</s> <br> <s>"http://localhost:8080/img/dd55129473604f489806db0dC6468dd9.jpg",</s> <br> <s>"http://localhost:8080/img/64eba4524a1f4d5d9f1687a815795643.jpg",</s> <br> <s>"http://localhost:8080/img/5727549e9l3l440dbb3cd707dce45d0f.jpg",</s> <br> <s>"http://localhost:8080/img/28ae9369ec3c442dbfe6901434ad15af.jpg"</s> <br> ], <br> <s>...</s> <br> }</code> <br> <br> 显然，如果我想通过返回相同的数据来保持产品模型的简单性，那么我将遇到一个过度获取的问题，在某些情况下，获取的数据比我需要的多。 在这种情况下，这会出现在产品目录页面上，但是通常，以某种方式与产品连接的任何UI屏幕都可能只需要其中一部分（而不是全部）数据。 <br><br> 现在让我们看一下购物车页面。 在购物篮中，除了产品本身之外，还有数量（在此购物篮中），价格以及整个订单的总费用： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/653/da1/ad3/653da1ad36872dff8cda2d13b28b5f45.png"><br><br> 如果继续使用HTTP API的简单建模方法，则可以通过resource <i>/ carts /：id</i>来表示该购物篮，其表示形式是指添加到此购物篮的产品资源： <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: [   {     <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: <span class="hljs-string"><span class="hljs-string">"/products/59eb83c0040fa80b29938e3f"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"total"</span></span>: <span class="hljs-number"><span class="hljs-number">26.99</span></span>   },   {     <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: <span class="hljs-string"><span class="hljs-string">"/products/59eb83c0040fa80b29938e40"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"total"</span></span>: <span class="hljs-number"><span class="hljs-number">25.98</span></span>   },   {     <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: <span class="hljs-string"><span class="hljs-string">"/products/59eb88bd040fa8125aa9c400"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"total"</span></span>: <span class="hljs-number"><span class="hljs-number">26.99</span></span>   } ], <span class="hljs-attr"><span class="hljs-attr">"subTotal"</span></span>: <span class="hljs-number"><span class="hljs-number">79.96</span></span> }</code> </pre><br> 现在，例如，为了在前端绘制一个包含三个产品的购物篮，您需要发出四个请求：一个请求本身加载购物篮，三个请求以加载产品数据（名称，价格和SKU编号）。 <br><br> 我们遇到的第二个问题是获取不足。 篮子和产品资源之间的责任区分导致需要提出其他要求。 显然这里存在许多弊端：由于请求数量增加，我们更快地降低了手机的电池电量，而获得完整答案的速度却越来越慢。 而且我们解决方案的可扩展性也引发了疑问。 <br><br> 当然，这种解决方案不适合生产。 解决该问题的一种方法是为篮子增加投影支撑。 除购物篮本身的数据外，此类预测之一还可以返回有关产品的数据。 此外，此预测将非常具体，因为您需要在购物篮页面上输入产品的库存编号（SKU）。 在其他任何地方都不需要SKU。 <br><br><pre> <code class="plaintext hljs">GET /carts/1?projection=with-products</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/a5f/3d7/901/a5f3d7901a3d60622575ae1fdf6787d1.png"><br><br> 针对特定UI的这种“适合”资源通常不会结束，并且我们开始生成其他预测：关于购物篮的简要信息，针对移动网络的购物篮投影，然后是针对独角兽的投影。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ff/6b5/dad/9ff6b5dad7ee3ec4e7d95790dcd2eb05.png"><br><br>  （通常，在WIX Designer中，您作为用户可以配置要在产品页面上显示的产品数据以及要在购物篮中显示的数据） <br><br> 在这里，困难仍在等待着我们：我们正在构筑花园并寻找复杂的解决方案。 从API的角度来看，针对这种任务的标准解决方案很少，它们通常在很大程度上取决于框架或HTTP资源描述库。 <br><br> 更为重要的是，现在工作变得越来越困难，因为当客户端的需求发生变化时，后端必须不断“追赶”并满足它们。 <br><br> 作为“蛋糕上的樱桃”，让我们来看另一个重要的问题。 对于简单的HTTP API，服务器开发人员不知道客户端使用的是哪种数据。 使用价格了吗？ 说明？ 一幅或全部图像？ <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f1/943/2d4/1f19432d49f8577cc70197bdb74a7987.png"><br><br> 因此，出现了几个问题。 如何处理已过时/过时的数据？ 我如何知道不再使用哪些数据？ 从响应中删除数据而不破坏大多数客户端相对安全吗？ 通常的HTTP API无法回答这些问题。 尽管我们很乐观并且API看起来很简单，但情况似乎并不那么热。  API问题的范围不是WIX独有的。 许多公司不得不与他们打交道。 现在来看一个潜在的解决方案很有趣。 <br><br><h2>  GraphQL。 开始 </h2><br>  2012年，在开发移动应用程序的过程中，Facebook面临类似的问题。 工程师希望实现对服务器的移动应用程序调用的最小数量，而在每个步骤中，他们仅接收必要的数据，而仅接收到它们。 他们努力的结果是在2015 React Conf会议上展示的GraphQL。  GraphQL是查询描述语言，也是这些查询的运行时环境。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/9fc/00c/0529fc00c59b43faf40c8cbd4064d1ac.png"><br><br> 考虑使用GraphQL服务器的典型方法。 <br><br><h3> 我们描述方案 </h3><br>  GraphQL中的数据模式定义了它们之间的类型和关系，并以强类型的方式定义了它们。 例如，想象一个简单的社交网络模型。  <code>User</code>了解<code>friends</code> 。 用户生活在城市中，城市通过<code>citizens</code>字段了解其居民。 这是GraphQL中这种模型的图形： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae4/5e8/2e9/ae45e82e9610ff7abb7291fbe4671062.png"><br><br> 当然，为了使图表有用，还需要所谓的“入口点”。 例如，这样的入口点可能是通过名称获取用户。 <br><br><h3> 索取资料 </h3><br> 让我们看看GraphQL查询语言的本质是什么。 让我们将这个问题翻译成这种语言： <i>“对于一个名叫Vanya Unicorn的用户，我想知道他的朋友的名字，以及Vanya所居住城市的名称和人口”</i> ： <br><br><pre> <code class="javascript hljs">{ user(name: <span class="hljs-string"><span class="hljs-string">"Vanya Unicorn"</span></span>) {   friends {     name   }   city {     name     population   } } }</code> </pre> <br> 这是来自GraphQL服务器的答案： <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"friends"</span></span>: [       { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Lena"</span></span> },       { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Stas"</span></span> }     ]     <span class="hljs-string"><span class="hljs-string">"city"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Kyiv"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"population"</span></span>: <span class="hljs-number"><span class="hljs-number">2928087</span></span>     }   } } }</code> </pre><br> 请注意，请求表单与响应表单是“辅音”。 感觉这种查询语言是为JSON创建的。 具有强大的打字能力。 所有这些都是在一个HTTP POST请求中完成的-无需多次调用服务器。 <br><br> 让我们看看它在实际中的外观。 让我们打开GraphQL服务器的标准控制台，这称为Graph <i>i</i> QL（“图形”）。 要请求购物篮，我将满足以下要求： <i>“我想通过标识1获取购物篮，我对该购物篮的所有位置和产品信息感兴趣。</i>  <i>从信息中，名称，价格，库存编号和图像很重要（并且只有第一个）。</i>  <i>我还对这些产品的数量，价格和篮子里的总成本感兴趣</i> 。 <i>”</i> <br><br><pre> <code class="javascript hljs">{ cart(id: <span class="hljs-number"><span class="hljs-number">1</span></span>) {   items {     product {       title       price       sku       images(limit: <span class="hljs-number"><span class="hljs-number">1</span></span>)     }     quantity     total   }   subTotal } }</code> </pre> <br> 成功完成请求后，我们将得到确切的要求： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf7/c04/a8e/cf7c04a8ef9d309387a6bcc935d40d10.png"><br><br><h2> 主要好处 </h2><br><ul><li>  <b>灵活的采样。</b> 客户可以根据自己的具体要求提出要求。 <br></li><li>  <b>有效采样。</b> 响应仅返回请求的数据。 <br></li><li>  <b>发展更快。</b> 客户端上可以进行许多更改，而无需在服务器端进行任何更改。 例如，根据我们的示例，您可以轻松显示移动网络购物篮的其他视图。 <br></li><li>  <b>有用的分析。</b> 由于客户端必须在请求中显式指示字段，因此服务器确切知道真正需要哪些字段。 这是弃用政策的重要信息。 <br></li><li>  <b>适用于任何数据源和传输。</b>  GraphQL允许您在任何数据源和任何传输之上工作，这一点很重要。 在这种情况下，HTTP并不是万能的，GraphQL也可以通过WebSocket运行，稍后我们将讨论这一点。 <br></li></ul><br> 如今，几乎可以使用任何语言制作GraphQL服务器。  GraphQL服务器的最完整版本是用于Node平台的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GraphQL.js</a> 。 在Java社区中，参考实现是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GraphQL Java</a> 。 <br><br><h2> 创建GraphQL API </h2><br> 让我们看看如何在一个具体的生活示例中创建GraphQL服务器。 <br><br> 考虑一个基于微服务架构的在线商店的简化版本，该架构具有两个组件： <br><br><ul><li> 提供定制篮子服务的购物车服务。 将数据存储在关系数据库中，并使用SQL访问数据。 非常简单的服务，没有太多的魔法:) <br></li><li> 产品服务提供对产品目录的访问，实际上是从该目录中填充了购物篮。 提供用于访问产品数据的HTTP API。 <br></li></ul><br> 两种服务都在经典的Spring Boot之上实现，并且已经包含所有基本逻辑。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f0/1e9/560/5f01e95602be2c3d88178f1327f791c6.png"><br><br> 我们打算在Cart服务的顶部创建GraphQL API。 此API旨在提供对购物篮数据和添加到其中的产品的访问。 <br><br><h3> 第一版 </h3><br> 我们前面提到的Java生态系统的GraphQL参考实现-GraphQL Java，将为我们提供帮助。 <br><br> 向<code>pom.xml:</code>添加一些依赖项<code>pom.xml:</code> <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>com.graphql-java<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>graphql-java<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>9.3<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>com.graphql-java<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>graphql-java-tools<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>5.2.4<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>com.graphql-java<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>graphql-spring-boot-starter<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>5.0.2<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>com.graphql-java<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>graphiql-spring-boot-starter<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>5.0.2<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 除了前面提到的<code>graphql-java</code>我们还将需要一个<code>graphql-java-tools,</code>库<code>graphql-java-tools,</code>以及GraphQL的Spring Boot“启动器”，这将大大简化创建GraphQL服务器的第一步： <br><br><ul><li>  <i>graphql-spring-boot-starter</i>提供了一种将GraphQL Java快速连接到Spring Boot的机制。 <br></li><li>  <i>graphiql-spring-boot-starter</i>添加了一个交互式Graph <i>i</i> QL Web控制台来运行GraphQL查询。 <br></li></ul><br> 下一个重要步骤是确定graphQL服务方案，即我们的图形。 该图的节点使用<i>类型</i>描述，而边使用<i>字段描述</i> 。 空图定义如下所示： <br><br><pre> <code class="javascript hljs">schema { }</code> </pre> <br> 您记得，在这种方案中，存在“入口点”或顶级查询。 它们是通过模式中的<i>查询</i>字段定义的。 调用我们的<i>EntryPoints</i>入口<i>点</i>类型： <br><br><pre> <code class="javascript hljs">schema { <span class="hljs-attr"><span class="hljs-attr">query</span></span>: EntryPoints }</code> </pre><br> 我们在其中定义按标识符进行篮子搜索作为第一个入口点： <br><br><pre> <code class="javascript hljs">type EntryPoints { cart(id: Long!): Cart }</code> </pre><br>  <code>Cart</code>仅是GraphQL术语中的一个<i>字段</i> 。  <code>id</code>是标量类型<code>Long</code>的此字段的参数。 感叹号<code>!</code> 指定类型后，表示该参数是必需的。 <br><br> 是时候识别并输入<code>Cart</code> ： <br><br><pre> <code class="javascript hljs">type Cart { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: Long! items: [CartItem!]! subTotal: BigDecimal! }</code> </pre><br> 除标准<code>id</code> ，购物篮还包括其item元素和所有<code>subTotal</code>产品的金额。 请注意， <i>项目</i>定义为列表，如方括号<code>[]</code> 。 此列表的元素是<code>CartItem</code>类型。 字段类型名称后面有一个感叹号<code>!</code> 表示必填字段。 这意味着如果请求，服务器同意为该字段返回一个非空值。 <br><br> 剩下的要看的是<code>CartItem</code>类型的定义，其中包括指向产品（ <i>productId</i> ）的链接，将其添加到购物篮的次数（number）和产品的数量（根据数量（ <code>total</code> ）计算）： <br><br><pre> <code class="javascript hljs">type CartItem { <span class="hljs-attr"><span class="hljs-attr">productId</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>! quantity: Int! total: BigDecimal! }</code> </pre><br> 这里的一切都很简单-标量类型的所有字段都是必填字段。 <br><br> 这个方案并非偶然。  Cart服务已经使用与GraphQL模式中完全相同的字段名称和类型定义了<code>CartItem</code>购物篮及其<code>CartItem</code>元素。  cart模型使用Lombok库自动生成getter / setter，构造函数和其他方法。  JPA用于数据库中的持久性。 <br><br>  <code>Cart</code>类别： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.Data; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.persistence.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.math.BigDecimal; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cart</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-meta"><span class="hljs-meta">@Id</span></span>   <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id;   <span class="hljs-meta"><span class="hljs-meta">@ElementCollection</span></span>(fetch = FetchType.EAGER)   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CartItem&gt; items = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSubTotal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getItems().stream()               .map(Item::getTotal)               .reduce(BigDecimal.ZERO, BigDecimal::add);   } }</code> </pre><br>  <code>CartItem</code>类别： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.AllArgsConstructor; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.Data; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.persistence.Column; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.persistence.Embeddable; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.math.BigDecimal; <span class="hljs-meta"><span class="hljs-meta">@Embeddable</span></span> <span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CartItem</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(nullable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String productId;   <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(nullable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> quantity;   <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(nullable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigDecimal total; }</code> </pre><br> 因此，在GraphQL图和代码中都描述了购物篮（ <code>Cart</code> ）和购物篮元素（ <code>CartItem</code> ），它们根据字段集及其类型相互“兼容”。 但这还不足以使我们的服务正常工作。 <br><br> 我们需要明确说明入口点“ <code>cart(id: Long!): Cart</code> ”的工作方式。 为此，请使用GraphQLQueryResolver类型的bean为Spring创建一个非常简单的Java配置。  GraphQLQueryResolver仅描述架构中的“入口点”。 我们定义一个名称与入口点（ <code>cart</code> ）的字段相同的方法，使其与参数类型兼容，并使用<code>cartService</code>通过标识符查找相同的cart： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GraphQLQueryResolver </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queryResolver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLQueryResolver () {       <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Cart </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cartService.findCart(id);       }   } }</code> </pre><br> 这些更改足以使我们获得有效的应用程序。 在GraphiQL控制台中重新启动Cart服务后，以下查询将开始成功执行： <br><br><pre> <code class="javascript hljs">{ cart(id: <span class="hljs-number"><span class="hljs-number">1</span></span>) {   items {     productId     quantity     total   }   subTotal } }</code> </pre> <br><h3> 注意事项 </h3><br><ul><li> 我们使用标量类型<code>Long</code>和<code>String</code>作为购物篮和产品的唯一标识符。  GraphQL为此具有特殊的类型<code>ID</code> 。 从语义上来说，这对于真实的API是更好的选择。  <code>ID</code>类型的值可以用作缓存的键。 <br></li><li> 在我们应用程序开发的现阶段，内部和外部域模型是完全相同的。 我们正在谈论<code>Cart</code>和<code>CartItem</code>以及它们在GraphQL解析器中的直接使用。 在战斗应用中，建议将这些模型分开。 对于GraphQL解析器，必须存在与内部主题区域分开的模型。 <br></li></ul><br><h3> 使API有用 </h3><br> 所以我们得到了第一个结果，这真是太好了。 但是现在我们的API太原始了。 例如，到目前为止，尚无方法请求产品的有用数据，例如其名称，价格，商品，图片等。 相反，只有<code>productId</code> 。 让我们使该API真正有用，并添加对产品概念的全面支持。 这是它的定义在图中的样子： <br><br><pre> <code class="javascript hljs">type Product { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>! title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>! price: BigDecimal! description: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> sku: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>! images: [<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>!]! }</code> </pre><br> 将必填字段添加到<code>CartItem</code> ，并将productId字段<code>productId</code>为已弃用： <br><br><pre> <code class="javascript hljs">type Item { <span class="hljs-attr"><span class="hljs-attr">quantity</span></span>: Int! product: Product! productId: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>! @deprecated(reason: <span class="hljs-string"><span class="hljs-string">"don't use it!"</span></span>) total: BigDecimal! }</code> </pre> <br> 我们想出了方案。 现在是时候描述<code>product</code>领域的选择如何工作了。 之前，我们在<code>Cart</code>和<code>CartItem</code>依赖于getter方法，从而使GraphQL Java自动绑定值。 但是在这里应该记得， <code>CartItem</code>类中的<code>product</code>属性不是： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Embeddable</span></span> <span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CartItem</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(nullable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String productId;   <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(nullable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> quantity;   <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(nullable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigDecimal total; }</code> </pre><br> 我们可以选择： <br><br><ol><li> 将<i>产品</i>属性添加到<i>CartItem</i>并“教”它如何接收产品数据； <br></li><li> 确定如何获取<i>产品</i>而不更改<i>CartItem</i>类。 <br></li></ol><br> 第二种方法是可取的，因为在这种情况下内部域的描述模型（ <code>CartItem</code>类）将不包含Graph <i>i</i> QL API的实现细节。 <br><br> 为了实现此目标，GraphQLResolver标记器接口将有所帮助。 通过实现它，您可以确定（或覆盖）如何获取类型<code>T</code>的字段值<code>T</code> 这是相应的bean在Spring配置中的样子： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GraphQLResolver&lt;CartItem&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cartItemResolver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLResolver&lt;CartItem&gt;() {       <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">product</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CartItem item)</span></span></span><span class="hljs-function"> </span></span>{           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.getForObject(<span class="hljs-string"><span class="hljs-string">"http://localhost:9090/products/{id}"</span></span>,                   Product.class,                   item.getProductId());       }   }; }</code> </pre> <br>  <code>product</code>方法的名称不是偶然选择的。  GraphQL Java正在按字段名称寻找数据下载器方法，我们只需要为<code>product</code>字段定义一个加载器！ 作为参数传递的<code>CartItem</code>类型的对象定义了选择产品的上下文。 接下来是技术问题。 使用诸如<code>RestTemplate</code>类的<code>http</code>客户端<code>RestTemplate</code>我们向Product服务发出GET请求，并将结果转换为<code>Product</code> ，如下所示： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String id;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String title;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigDecimal price;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String description;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String sku;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;String&gt; images; }</code> </pre> <br> 这些更改应足以实施更有趣的示例，其中包括购物篮与添加到其中的产品之间的真实关系。 <br><br> 重新启动应用程序后，您可以在Graph <i>i</i> QL控制台中尝试新的查询。 <br><br><pre> <code class="javascript hljs">{ cart(id: <span class="hljs-number"><span class="hljs-number">1</span></span>) {   items {     product {       title       price       sku       images     }     quantity     total   }   subTotal } }</code> </pre><br> 这是查询执行的结果： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c8/778/3f4/0c87783f4f843696b9900771c2b2860e.png"><br><br> 尽管<code>productId</code>被标记为<code>@deprecated</code> ，但指示该字段的查询将继续起作用。 但是Graph <i>i</i> QL控制台不会为此类字段提供自动完成功能，而是以特殊方式突出显示它们的用法： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/afc/96a/d45/afc96ad45f3f4372a8e86cf78b892acd.png"><br><br> 现在该展示Graph <i>i</i> QL控制台的一部分的Document Explorer了，它是基于GraphQL模式构建的，并显示所有已定义类型的信息。 这是<code>CartItem</code>类型的文档资源管理器的外观： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f83/c04/38b/f83c0438b2f906b34414b764182a37fc.png"><br><br> 但是回到例子。 为了实现与第一个演示中相同的功能，返回的图像数量仍然没有足够的限制。 确实，例如，对于一个购物篮，每个产品只需要一个图像： <br><br><pre> <code class="javascript hljs">images(limit: <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br> 为此，请更改方案，然后将<i>图像</i>字段的新参数添加到<i>产品</i>类型： <br><br><pre> <code class="javascript hljs">type Product { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: ID! title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>! price: BigDecimal! description: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> sku: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>! images(limit: Int = <span class="hljs-number"><span class="hljs-number">0</span></span>): [<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>!]! }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在应用程序代码中，我们将再次使用它</font></font><code>GraphQLResolver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，仅这次按类型</font></font><code>Product</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GraphQLResolver&lt;Product&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">productResolver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLResolver&lt;Product&gt;() {       <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">images</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> limit)</span></span></span><span class="hljs-function"> </span></span>{           List&lt;String&gt; images = product.getImages();           <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> normalizedLimit = limit &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? limit : images.size();           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> images.subList(<span class="hljs-number"><span class="hljs-number">0</span></span>, Math.min(normalizedLimit, images.size()));       }   }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我再次提请注意以下事实：方法的名称并非偶然：它与字段的名称一致</font></font><code>images</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">上下文对象</font></font><code>Product</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以访问图像，并且</font></font><code>limit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是字段本身的参数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果客户未将任何值指定为</font></font><code>limit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则我们的服务将返回该产品的所有图像。</font><font style="vertical-align: inherit;">如果客户端指定了一个特定值，则该服务将返回的值与返回值完全相同（但不超过产品中的值）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们编译项目，然后等待服务器重新启动。</font><font style="vertical-align: inherit;">在控制台中重新启动电路并执行请求，我们看到一个完整的请求确实有效。</font></font><br><br><pre> <code class="javascript hljs">{ cart(id: <span class="hljs-number"><span class="hljs-number">1</span></span>) {   items {     product {       title       price       sku       images(limit: <span class="hljs-number"><span class="hljs-number">1</span></span>)     }     quantity     total   }   subTotal } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同意，这一切都很酷。</font><font style="vertical-align: inherit;">在短时间内，我们不仅了解了GraphQL，而且还转移了一个简单的微服务系统来支持此类API。</font><font style="vertical-align: inherit;">对于我们来说，数据来自哪里并不重要：SQL和HTTP API都可以很好地融合在一起。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码优先和GraphQL SPQR方法 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可能已经注意到，在开发过程中存在一些不便之处，即需要不断保持GraphQL模式和代码同步。类型更改始终必须在两个地方进行。在许多情况下，使用代码优先方法更为方便。其实质是GraphQL的架构是从代码自动生成的。在这种情况下，您无需单独维护电路。现在，我将展示它的外观。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅GraphQL Java的基本功能对我们来说还不够，我们还需要GraphQL SPQR库。好消息是GraphQL SPQR是GraphQL Java的附加组件，而不是Java中GraphQL服务器的替代实现。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将所需的依赖项添加到</font></font><code>pom.xml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>io.leangen.graphql<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>spqr<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>0.9.8<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这是为篮子实现相同的基于GraphQL SPQR的功能的代码： </font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CartGraph</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CartService cartService;   <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CartGraph</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CartService cartService)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cartService = cartService;   }   <span class="hljs-meta"><span class="hljs-meta">@GraphQLQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"cart"</span></span>)   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Cart </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@GraphQLArgument(name = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id) </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cartService.findCart(id);   } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对于产品： </font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductGraph</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RestTemplate http;   <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProductGraph</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RestTemplate http)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http = http;   }   <span class="hljs-meta"><span class="hljs-meta">@GraphQLQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"product"</span></span>)   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">product</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@GraphQLContext CartItem cartItem)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.getForObject(               <span class="hljs-string"><span class="hljs-string">"http://localhost:9090/products/{id}"</span></span>,               Product.class,               cartItem.getProductId()       );   }   <span class="hljs-meta"><span class="hljs-meta">@GraphQLQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"images"</span></span>)   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">images</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@GraphQLContext Product product,                              @GraphQLArgument(name = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"limit"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, defaultValue = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> limit) </span></span>{       List&lt;String&gt; images = product.getImages();       <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> normalizedLimit = limit &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? limit : images.size();       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> images.subList(<span class="hljs-number"><span class="hljs-number">0</span></span>, Math.min(normalizedLimit, images.size()));   } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@GraphQLQuery批注用于标记字段加载器方法。</font><font style="vertical-align: inherit;">注释</font></font><code>@GraphQLContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义了字段的选择类型。</font><font style="vertical-align: inherit;">注释</font></font><code>@GraphQLArgument</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清楚地标记了参数参数。</font><font style="vertical-align: inherit;">所有这些都是一种机制的一部分，可以帮助GraphQL SPQR自动生成模式。</font><font style="vertical-align: inherit;">现在，如果删除旧的Java配置和方案，并使用GraphQL SPQR中的新芯片重新启动Cart服务，则可以确保所有工作均与以前相同。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们解决N + 1的问题 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在是时候看看b </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lshih详细介绍了如何“引擎盖下”全要求的执行。我们快速创建了GraphQL API，但是它能有效地工作吗？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请考虑以下示例：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/05c/626/303/05c62630323d9ad9eeb97999c19fcd04.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取篮子</font></font><code>cart</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生在对数据库的一个SQL查询中。数据</font></font><code>items</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并在</font></font><code>subtotal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那里返回，因为根据急切的获取JPA策略，购物篮元素已随整个集合一起加载：</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cart</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-meta"><span class="hljs-meta">@ElementCollection</span></span>(fetch = FetchType.EAGER)   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Item&gt; items = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();   ... }</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/674/0e4/863/6740e4863b4847f782f64588e52ecc36.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当下载产品上的数据时，对产品服务的请求将与该系列产品中的请求完全一样地执行。如果购物篮中有三种不同的产品，那么我们将收到三个对产品服务的HTTP API的请求，如果有十种，那么同一服务将必须回答十个此类请求。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/92c/9c0/b1a/92c9c0b1a06c15f081c0eb9dc9ce8a1f.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是Charles Proxy中Cart服务和Product服务之间的通信：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c15/8df/d08/c158dfd08badf133f49499baa43c1970.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们回到经典的N + 1问题。正是他们在报告一开始就竭尽全力摆脱的那个人。毫无疑问，我们取得了进步，因为在最终客户端和我们的系统之间只执行了一个请求。但是在服务器生态系统内，性能显然需要提高。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我想通过在一个请求中获得所有合适的产品来解决此问题。</font><font style="vertical-align: inherit;">幸运的是，产品服务已经通过</font></font><code>ids</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收集资源中</font><font style="vertical-align: inherit;">的参数支持此功能</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="plaintext hljs">GET /products?ids=:id1,:id2,...,:idn</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看看如何修改</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">product</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段的示例方法代码</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">先前版本：</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@GraphQLQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"product"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">product</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@GraphQLContext CartItem cartItem)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.getForObject(           <span class="hljs-string"><span class="hljs-string">"http://localhost:9090/products/{id}"</span></span>,           Product.class,           cartItem.getProductId()   ); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 替换为更有效的一个： </font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@GraphQLQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"product"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Batched</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Product&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">products</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@GraphQLContext List&lt;Item&gt; items)</span></span></span><span class="hljs-function"> </span></span>{   String productIds = items.stream()           .map(Item::getProductId)           .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">","</span></span>));   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.getForObject(           <span class="hljs-string"><span class="hljs-string">"http://localhost:9090/products?ids={ids}"</span></span>,           Products.class,           productIds   ).getProducts(); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们做了三件事： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@Batched</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">批注标记引导加载程序方法，</font><font style="vertical-align: inherit;">以便GraphQL SPQR清楚加载应该批量进行;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将返回类型和上下文参数更改为列表，因为使用批处理假定已接受并返回了多个对象； </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 改变了方法的主体，一次实现了所有必要产品的选择。 </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些更改足以解决我们的N + 1问题。</font><font style="vertical-align: inherit;">现在，“ Charles Proxy”应用程序窗口将向Product服务显示一个请求，该请求将立即返回三个产品：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c2/806/98d/5c280698dfbdf383cf44052f51a09ae8.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 有效现场样本 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们解决了主要问题，但是您可以使选择更快！</font><font style="vertical-align: inherit;">现在，无论最终客户需要什么，产品服务都会返回所有数据。</font><font style="vertical-align: inherit;">我们可以改进查询并仅返回请求的字段。</font><font style="vertical-align: inherit;">例如，如果最终客户未要求提供图片，为什么我们需要将其转移到购​​物车服务？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很棒的一点是，Product服务的HTTP API已经通过</font><font style="vertical-align: inherit;">相同集合资源</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">include</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数支持此功能</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="plaintext hljs">GET /products?ids=...?include=:field1,:field2,...,:fieldN</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于bootloader方法，添加带有注释的Set类型的参数</font></font><code>@GraphQLEnvironment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">GraphQL SPQR了解这种情况下的代码“请求”了产品所要求的字段名称列表，并自动将其填写在：</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@GraphQLQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"product"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Batched</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Product&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">products</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@GraphQLContext List&lt;Item&gt; items,                             @GraphQLEnvironment Set&lt;String&gt; fields)</span></span></span><span class="hljs-function"> </span></span>{   String productIds = items.stream()           .map(Item::getProductId)           .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">","</span></span>));   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.getForObject(           <span class="hljs-string"><span class="hljs-string">"http://localhost:9090/products?ids={ids}&amp;include={fields}"</span></span>,           Products.class,           productIds,           String.join(<span class="hljs-string"><span class="hljs-string">","</span></span>, fields)   ).getProducts(); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在我们的样本非常有效，没有N + 1问题，仅使用必要的数据： </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/242/592/98f/24259298fe8acb19d21e04083689d5dd.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “大量”查询 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">想象一下在经典的社交网络（例如Facebook）中使用用户图的情况。</font><font style="vertical-align: inherit;">如果此类系统提供了GraphQL API，则不会阻止客户端发送以下性质的请求：</font></font><br><br><pre> <code class="javascript hljs">{ user(name: <span class="hljs-string"><span class="hljs-string">"Vova Unicorn"</span></span>) {   friends {     name     friends {       name       friends {         name         friends {            name            ...         }       }     }   } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在5-6层的嵌套级别，完全执行此请求将导致选择世界上所有用户。</font><font style="vertical-align: inherit;">服务器肯定无法一次坐下来应付这样的任务，并且很可能会“跌倒”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了保护自己免受此类情况的侵害，必须采取多种措施：</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">限制请求深度。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">换句话说，不应允许客户请求任意嵌套的数据。</font></font><br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">限制请求的复杂性。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过为每个字段分配权重并计算请求中所有字段的权重之和，您可以在服务器上接受或拒绝此类请求。</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 例如，考虑以下查询： </font></font><br><br><pre> <code class="javascript hljs">{ cart(id: <span class="hljs-number"><span class="hljs-number">1</span></span>) {   items {     product {       title     }     quantity   }   subTotal } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，此类请求的深度为4，因为最长的路径在其中</font></font><code>cart -&gt; items -&gt; product -&gt; title</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们假设每个字段的权重为1，则考虑到查询中的7个字段，其复杂度也为7。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在GraphQL Java中，通过在创建对象时指示其他工具来实现检查的叠加</font></font><code>GraphQL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="java hljs">GraphQL.newGraphQL(schema)       .instrumentation(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChainedInstrumentation(Arrays.asList(               <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaxQueryComplexityInstrumentation(<span class="hljs-number"><span class="hljs-number">20</span></span>),               <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaxQueryDepthInstrumentation(<span class="hljs-number"><span class="hljs-number">3</span></span>)       )))       .build();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仪表</font></font><code>MaxQueryDepthInstrumentation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查请求的深度和不允许运行太“深”的要求（在这种情况下-一个深度大于3）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仪表</font></font><code>MaxQueryComplexityInstrumentation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请求计数的执行之前，并验证其复杂性。如果此数字超过指定的值（20），则将拒绝此类请求。您可以重新定义每个字段的权重，因为其中某些字段显然比其他字段“更难”。例如，可以通过</font></font><code>@GraphQLComplexity,</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GraphQL SPQR支持</font><font style="vertical-align: inherit;">的注释将乘积字段分配给复杂性10 </font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@GraphQLQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"product"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@GraphQLComplexity</span></span>(<span class="hljs-string"><span class="hljs-string">"10"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Product&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">products</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是深度检查明显超过指定值时的示例：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/54c/c39/584/54cc39584792997b198370c40e8b2431.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺便说一下，检测机制不限于施加限制。</font><font style="vertical-align: inherit;">它也可以用于其他目的，例如日志记录或跟踪。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们研究了针对GraphQL的“保护”措施。</font><font style="vertical-align: inherit;">但是，无论API的类型如何，都有许多技巧值得关注：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 节流/速率限制-限制每单位时间的请求数 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 超时-与其他服务，数据库等一起进行操作的时间限制； </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 分页-分页支持。 </font></font><br></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 数据突变 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们一直在考虑纯粹的数据采样。</font><font style="vertical-align: inherit;">但是GraphQL允许您不仅有机地组织数据的接收，还组织它们的更改。</font><font style="vertical-align: inherit;">这有一个机制</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在方案中，为此保留了一个特殊的位置-字段</font></font><code>mutation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="javascript hljs">schema { <span class="hljs-attr"><span class="hljs-attr">query</span></span>: EntryPoints, <span class="hljs-attr"><span class="hljs-attr">mutation</span></span>: Mutations }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 例如，可以通过以下突变来组织将产品添加到购物篮中： </font></font><br><br><pre> <code class="javascript hljs">type Mutations {   addProductToCart(cartId: Long!,                    <span class="hljs-attr"><span class="hljs-attr">productId</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>!,                    <span class="hljs-attr"><span class="hljs-attr">count</span></span>: Int = <span class="hljs-number"><span class="hljs-number">1</span></span>): Cart }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这类似于定义字段，因为变异也具有参数和返回值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用GraphQL SPQR在服务器代码中实现突变的方法如下：</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@GraphQLMutation</span></span>(name = <span class="hljs-string"><span class="hljs-string">"addProductToCart"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Cart </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addProductToCart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       @GraphQLArgument(name = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cartId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long cartId,       @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GraphQLArgument</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"productId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String productId,       @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GraphQLArgument</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"quantity"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, defaultValue = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> quantity) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cartService.addProductToCart(cartId, productId, quantity); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，大多数有用的工作都是在内部完成的</font></font><code>cartService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这个中间层方法的任务是将其与API关联。与数据采样一样，由于有了注释，因此</font></font><code>@GraphQL*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很容易理解从该方法定义生成的GraphQL模式。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在GraphQL控制台中，您现在可以执行更改请求，以将特定产品添加到我们的购物篮中，数量为2：</font></font><br><br><pre> <code class="javascript hljs">mutation { addProductToCart(     cartId: <span class="hljs-number"><span class="hljs-number">1</span></span>,     <span class="hljs-attr"><span class="hljs-attr">productId</span></span>: <span class="hljs-string"><span class="hljs-string">"59eb83c0040fa80b29938e3f"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">quantity</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>) {   items {     product {       title     }     quantity     total   }   subTotal } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于突变具有返回值，因此可以根据与普通样本相同的规则向其请求字段。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些WIX开发团队正在积极地将GraphQL与Scala和Sangria库一起使用，Sangria库是该语言中GraphQL的主要实现。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WIX中使用的一种有用技术是在呈现HTML时支持GraphQL查询。</font><font style="vertical-align: inherit;">我们这样做是为了直接在页面代码中生成JSON。</font><font style="vertical-align: inherit;">以下是填充HTML模板的示例：</font></font><br><br><pre> <code class="xml hljs">// Pre-rendered <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-embedded-graphiql</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> {   product(productId: $productId)     title     description     price     ...   } } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这是输出： </font></font><br><br><pre> <code class="xml hljs">// Rendered <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">window</span></span></span><span class="javascript">.DATA = {   </span><span class="hljs-attr"><span class="javascript"><span class="hljs-attr">product</span></span></span><span class="javascript">: {          </span><span class="hljs-attr"><span class="javascript"><span class="hljs-attr">title</span></span></span><span class="javascript">: </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'GraphQL Sticker'</span></span></span><span class="javascript">,          </span><span class="hljs-attr"><span class="javascript"><span class="hljs-attr">description</span></span></span><span class="javascript">: </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'High quality sticker'</span></span></span><span class="javascript">,           </span><span class="hljs-attr"><span class="javascript"><span class="hljs-attr">price</span></span></span><span class="javascript">: </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'$2'</span></span></span><span class="javascript">           ... } } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTML渲染器和GraphQL服务器的这种组合使我们可以最大程度地重用我们的API，而无需创建额外的控制器层。</font><font style="vertical-align: inherit;">而且，该技术通常在性能方面具有优势，因为在加载页面后，JavaScript应用程序不需要进入后端就可以获取第一个必要的数据-它已经在页面上了。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GraphQL的缺点 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如今，GraphQL使用了许多公司，包括GitHub，Yelp，Facebook等巨人。</font><font style="vertical-align: inherit;">而且，如果您决定加入他们的团队，那么您不仅应该知道GraphQL的优点，也应该知道它的缺点，其中有很多：</font></font><br><br><ul><li> -,  GraphQL <b>     </b> .  GraphQL      ,   HTTP API.  <i>Cache-Control</i>  <i>Last-Modified</i>    HTTP      GraphQL API.         ,  proxy  gateways (Varnish, Fastly  ).   , GraphQL    ,    ,   . <br></li><li>   GraphQL — <b>    </b> .    ,         API,    ,       . <br></li><li> <b> </b>  GraphQL       .        . <br></li><li>  <b>     </b> . GraphQL —       .     JSON  XML, , ,          GraphQL,       . <br></li><li>  GraphQL <b>   </b> . ,       HTTP   <i>PUT</i>     <i>POST</i>  -.   ,       .    GraphQL       .        . <br></li><li> <b>   </b> . ,     -: «delete»  «kill», «annihilate»  «terminate»,    .   GraphQL API    .   HTTP          <i>DELETE</i> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Joker 2016   </a>   .  GraphQL <b>      </b> .  API-   ,   ,    ,     HATEOAS,     ,   « REST». ,     ,  GraphQL     . <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还需要记住的是，如果您未能成功开发HTTP API，很可能将无法开发GraphQL API。毕竟，在任何API的开发中最重要的是什么？将内部域模型与外部API模型分开。根据使用情况而不是应用程序的内部设备构建API。仅打开必要的最少信息，而不是全部打开。选择正确的名称。正确描述图形。 HTTP API中有一个资源图，而GraphQL API中有一个字段图。在这两种情况下，都必须定性地绘制该图。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP API世界中有多种选择，当您需要复杂的选择时，您不必总是使用GraphQL。</font><font style="vertical-align: inherit;">例如，存在OData标准，该标准支持部分选择和扩展选择，例如GraphQL，并且可以在HTTP之上工作。</font><font style="vertical-align: inherit;">有一个与JSON一起使用的标准JSON API，并支持超媒体和复杂的提取功能。</font><font style="vertical-align: inherit;">另外还有LinkRest，您可以从</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrus Adamchik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Joker 2017上</font><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">https://youtu.be/EsldBtrb1Qc“&gt;报告中</font></a><font style="vertical-align: inherit;">了解更多信息</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于那些想尝试GraphQL的人，我强烈建议阅读那些精通该技术的工程师的比较文章。从实践和哲学的角度来看REST和GraphQL：</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://philsturgeon.uk/api/2017/01/24/graphql-vs-rest-overview/</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://blog.runscope.com/posts/you-might-not-need-graphql</font></font></a> <br></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后关于订阅和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">延迟</font></font></a> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GraphQL与标准API相比有一个有趣的优势。</font><font style="vertical-align: inherit;">在GraphQL中，同步和异步用例都可以放在同一屋檐下。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们考虑过通过您接收数据，通过来</font></font><code>query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改服务器的状态</font></font><code>mutation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是还有另外一个好处。</font><font style="vertical-align: inherit;">例如，组织订阅的能力</font></font><code>subscriptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">想象一下，一个客户想要接收有关异步将产品添加到购物篮的通知。</font><font style="vertical-align: inherit;">通过GraphQL API，可以基于以下方案完成此操作：</font></font><br><br><pre> <code class="javascript hljs">schema { <span class="hljs-attr"><span class="hljs-attr">query</span></span>: Queries, <span class="hljs-attr"><span class="hljs-attr">mutation</span></span>: Mutations, <span class="hljs-attr"><span class="hljs-attr">subscription</span></span>: Subscriptions } type Subscriptions { productAdded(cartId: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>!): Cart }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 客户可以通过以下请求进行订阅： </font></font><br><br><pre> <code class="javascript hljs">subscription { productAdded(cart: <span class="hljs-number"><span class="hljs-number">1</span></span>) {   items {     product ...   }   subTotal } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，每次将产品添加到购物篮1时，服务器都会在WebSocket上向每个订阅的客户端发送一条消息，其中包含请求的数据。</font><font style="vertical-align: inherit;">同样，继续执行GraphQL策略，只有客户端在订阅时请求的数据才会出现：</font></font><br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"productAdded"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: [       { <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: …, <span class="hljs-attr"><span class="hljs-attr">"subTotal"</span></span>: … },       { <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: …, <span class="hljs-attr"><span class="hljs-attr">"subTotal"</span></span>: … },       { <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: …, <span class="hljs-attr"><span class="hljs-attr">"subTotal"</span></span>: … },       { <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: …, <span class="hljs-attr"><span class="hljs-attr">"subTotal"</span></span>: … }     ],     <span class="hljs-attr"><span class="hljs-attr">"subTotal"</span></span>: <span class="hljs-number"><span class="hljs-number">289.33</span></span>   } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户现在可以重新绘制购物篮，而不必重新绘制整个页面。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这很方便，因为可以通过GraphQL描述同步API（HTTP）和异步API（WebSocket）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用异步通信的另一个示例是</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">延迟</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机制</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">主要思想是，客户端选择他希望立即（同步）接收的数据，以及他准备稍后接收（异步）的数据。</font><font style="vertical-align: inherit;">例如，对于这样的请求：</font></font><br><br><pre> <code class="javascript hljs">query { feedStories {   author { name }   message   comments @defer {     author { name }     message   } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 服务器将首先返回作者和每个故事的消息： </font></font><br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"feedStories"</span></span>: [     {       <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: …,       <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: …     },     {       <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: …,       <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: …     }   ] } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 之后，接收到注释数据的服务器将通过WebSocket异步将其传送到客户端，并在路径中指出现在已准备好历史注释： </font></font><br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"feedStories"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"comments"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: [   {     <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: …,     <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: …   } ] }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 样本来源 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在GitHub上找到</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于准备此报告的代码</font><font style="vertical-align: inherit;">。</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最近，我们宣布了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JPoint 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将于2019年4月5日至6日举行。</font><font style="vertical-align: inherit;">您可以从我们的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中心</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解有关会议期望的更多信息</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">直到12月1日，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Early Bird门票</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仍将</font><font style="vertical-align: inherit;">以最低价出售。</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428517/">https://habr.com/ru/post/zh-CN428517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428507/index.html">我们使用longpoll在python上为VKontakte编写了机器人聊天程序</a></li>
<li><a href="../zh-CN428509/index.html">H＆M如何尝试通过AI和大数据来拯救自己</a></li>
<li><a href="../zh-CN428511/index.html">氢能：漫漫长路</a></li>
<li><a href="../zh-CN428513/index.html">一处放置500个激光笔</a></li>
<li><a href="../zh-CN428515/index.html">顶级3D商店：我们一年来的变化-2018年业绩</a></li>
<li><a href="../zh-CN428521/index.html">为什么在GitHub上没有朋友。 关于Robbie Barrath，明显和版权</a></li>
<li><a href="../zh-CN428523/index.html">ShadowCloud-通用云客户端</a></li>
<li><a href="../zh-CN428525/index.html">以最快的速度RecyclerView：解析库</a></li>
<li><a href="../zh-CN428526/index.html">Google税：180°转</a></li>
<li><a href="../zh-CN428528/index.html">为什么革命者喜欢辛辣食物，或者辣椒如何到达中国</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>