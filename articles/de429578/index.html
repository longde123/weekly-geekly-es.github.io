<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÖ∞Ô∏è üë®üèª‚Äçüéì ‚úãüèø Welche Fehler sind im Infer.NET-Code versteckt? üôèüèø ‚≠ïÔ∏è üë©‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Ver√∂ffentlichung des Quellcodes durch Microsoft f√ºr seine Projekte ist ein guter Grund, diese zu √ºberpr√ºfen. Diesmal war dies keine Ausnahme, und ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Welche Fehler sind im Infer.NET-Code versteckt?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/429578/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3f/18a/6a6/d3f18a6a6127aceeae10d53591e0ce65.png"></div><br>  Die Ver√∂ffentlichung des Quellcodes durch Microsoft f√ºr seine Projekte ist ein guter Grund, diese zu √ºberpr√ºfen.  Diesmal war dies keine Ausnahme, und heute sehen wir uns die verd√§chtigen Stellen im Infer.NET-Code an.  Nieder mit der Anmerkung - kommen Sie auf den Punkt! <br><a name="habracut"></a><br><h2>  Ein bisschen √ºber das Projekt und den Analysator </h2><br>  Infer.NET ist ein maschinelles Lernsystem, das von Spezialisten von Microsoft entwickelt wurde.  Der Quellcode des Projekts ist seit kurzem auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verf√ºgbar, was der Grund f√ºr seine √úberpr√ºfung war.  Weitere Details zum Projekt finden Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Das Projekt wurde mit dem statischen Analyseger√§t PVS-Studio Version 6.26 √ºberpr√ºft.  Ich m√∂chte Sie daran erinnern, dass PVS-Studio unter C, C ++ \ C # (und bald auch unter Java) unter Windows, Linux und MacOS nach Codefehlern sucht.  C # -Code analysieren wir bisher nur unter Windows.  Der Analysator kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">heruntergeladen und</a> in Ihrem Projekt getestet werden. <br><br>  Die √úberpr√ºfung selbst war sehr einfach und ohne Probleme.  Zuvor habe ich das Projekt von GitHub entladen, die erforderlichen Pakete (Abh√§ngigkeiten) wiederhergestellt und sichergestellt, dass das Projekt erfolgreich erstellt wurde.  Dies ist erforderlich, damit der Analysator Zugriff auf alle erforderlichen Informationen f√ºr eine vollst√§ndige Analyse hat.  Nach dem Zusammenbau mit wenigen Klicks startete ich die Analyse der L√∂sung √ºber das PVS-Studio-Plugin f√ºr Visual Studio. <br><br>  Dies ist √ºbrigens nicht das erste Projekt von Microsoft, das mit PVS-Studio getestet wurde - es gab andere: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Roslyn</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MSBuild</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PowerShell</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoreFX</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere</a> . <br><br>  <b>Hinweis</b>  Wenn Sie oder Ihre Bekannten an der Analyse von Java-Code interessiert sind, k√∂nnen Sie uns zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung</a> schreiben, indem Sie "Ich m√∂chte einen Analysator f√ºr Java" ausw√§hlen.  Es gibt keine √∂ffentliche Beta-Version des Analysators, diese sollte jedoch bald verf√ºgbar sein.  Irgendwo in einem geheimen Labor (durch die Wand) arbeiten die Jungs aktiv daran. <br><br>  Aber genug abstraktes Gerede - schauen wir uns die Probleme im Code an. <br><br><h2>  Ist das ein Fehler oder eine Funktion? </h2><br>  Ich schlage vor, den Fehler selbst zu finden - eine vollst√§ndig l√∂sbare Aufgabe.  Ehrlich gesagt, keine Witze im Sinne des Artikels ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Top 10 Fehler in C ++ - Projekten f√ºr 2017</a> ‚Äú.  Beeilen Sie sich also nicht, die nach dem Code-Snippet bereitgestellte Analyse-Warnung zu lesen. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MergeParallelTransitions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( transition1.DestinationStateIndex == transition2.DestinationStateIndex &amp;&amp; transition1.Group == transition2.Group) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transition1.IsEpsilon &amp;&amp; transition2.IsEpsilon) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!transition1.IsEpsilon &amp;&amp; !transition2.IsEpsilon) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.IsInfinity(transition1.Weight.Value) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.IsInfinity(transition1.Weight.Value)) { newElementDistribution.SetToSum( <span class="hljs-number"><span class="hljs-number">1.0</span></span>, transition1.ElementDistribution, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, transition2.ElementDistribution); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { newElementDistribution.SetToSum( transition1.Weight.Value, transition1.ElementDistribution, transition2.Weight.Value, transition2.ElementDistribution); } .... }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3001</a> Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdr√ºcke 'double.IsInfinity (Transition1.Weight.Value)'.  Runtime Automaton.Simplification.cs 479 <br><br>  Wie Sie dem Code-Snippet entnehmen k√∂nnen, arbeitet die Methode mit zwei Variablen - <i>√úbergang1</i> und <i>√úbergang2</i> .  Die Verwendung √§hnlicher Namen ist manchmal durchaus gerechtfertigt, aber es ist zu beachten, dass in diesem Fall die Wahrscheinlichkeit steigt, versehentlich irgendwo mit dem Namen einen Fehler zu machen. <br><br>  Dies geschah, wenn Zahlen auf unendlich √ºberpr√ºft wurden ( <i>double.IsInfinity</i> ).  Aufgrund eines Fehlers haben wir den Wert derselben Variablen zweimal √ºberpr√ºft - <i>Transition1.Weight.Value</i> .  Der √ºberpr√ºfte Wert im zweiten Unterausdruck sollte die Variable <i>Transition2.Weight.Value sein</i> . <br><br>  Ein weiterer √§hnlicher verd√§chtiger Code. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> MethodBase </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToMethodInternal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IMethodReference imr</span></span></span><span class="hljs-function">)</span></span> { .... bf |= BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance; .... }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3001</a> Links und rechts vom '|' befinden sich identische Unterausdr√ºcke 'BindingFlags.Public'.  Betreiber.  Compiler CodeBuilder.cs 194 <br><br>  Bei der Bildung des Werts der Variablen <i>bf</i> wird das Aufz√§hlungselement <i>BindingFlags.Public</i> zweimal verwendet.  Entweder enth√§lt dieser Code eine zus√§tzliche Kennzeichnungsoperation, oder anstelle der zweiten Verwendung von <i>BindingFlags.Public</i> sollte ein anderer Aufz√§hlungswert vorhanden sein. <br><br>  √úbrigens ist dieser Code im Quellcode in einer Zeile geschrieben.  Es scheint mir, dass das Problem leichter zu erkennen ist, wenn es in einem Tabellenstil (wie hier) formatiert ist. <br><br>  Lass uns weitermachen.  Ich bringe den ganzen K√∂rper der Methode mit und wieder schlage ich vor, dass Sie den Fehler (oder vielleicht den Fehler) selbst finden. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForEachPrefix</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IExpression expr, Action&lt;IExpression&gt; action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// This method must be kept consistent with GetTargets. if (expr is IArrayIndexerExpression) ForEachPrefix(((IArrayIndexerExpression)expr).Target, action); else if (expr is IAddressOutExpression) ForEachPrefix(((IAddressOutExpression)expr).Expression, action); else if (expr is IPropertyReferenceExpression) ForEachPrefix(((IPropertyReferenceExpression)expr).Target, action); else if (expr is IFieldReferenceExpression) { IExpression target = ((IFieldReferenceExpression)expr).Target; if (!(target is IThisReferenceExpression)) ForEachPrefix(target, action); } else if (expr is ICastExpression) ForEachPrefix(((ICastExpression)expr).Expression, action); else if (expr is IPropertyIndexerExpression) ForEachPrefix(((IPropertyIndexerExpression)expr).Target, action); else if (expr is IEventReferenceExpression) ForEachPrefix(((IEventReferenceExpression)expr).Target, action); else if (expr is IUnaryExpression) ForEachPrefix(((IUnaryExpression)expr).Expression, action); else if (expr is IAddressReferenceExpression) ForEachPrefix(((IAddressReferenceExpression)expr).Expression, action); else if (expr is IMethodInvokeExpression) ForEachPrefix(((IMethodInvokeExpression)expr).Method, action); else if (expr is IMethodReferenceExpression) ForEachPrefix(((IMethodReferenceExpression)expr).Target, action); else if (expr is IUnaryExpression) ForEachPrefix(((IUnaryExpression)expr).Expression, action); else if (expr is IAddressReferenceExpression) ForEachPrefix(((IAddressReferenceExpression)expr).Expression, action); else if (expr is IDelegateInvokeExpression) ForEachPrefix(((IDelegateInvokeExpression)expr).Target, action); action(expr); }</span></span></code> </pre> <br>  Hast du gefunden?  Wir pr√ºfen! <br><br>  <b>PVS-Studio-Warnungen</b> : <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3003</a> Die Verwendung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Musters</a> 'if (A) {...} else if (A) {...}' wurde erkannt.  Es besteht die Wahrscheinlichkeit eines logischen Fehlers.  √úberpr√ºfen Sie die Zeilen: 1719, 1727. Compiler CodeRecognizer.cs 1719 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3003</a> Die Verwendung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Musters</a> 'if (A) {...} else if (A) {...}' wurde erkannt.  Es besteht die Wahrscheinlichkeit eines logischen Fehlers.  √úberpr√ºfen Sie die Zeilen: 1721, 1729. Compiler CodeRecognizer.cs 1721 </li></ul><br>  Vereinfachen Sie den Code ein wenig, um die Probleme offensichtlicher zu machen. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForEachPrefix</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IExpression expr, Action&lt;IExpression&gt; action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> IUnaryExpression) ForEachPrefix(((IUnaryExpression)expr).Expression, action); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> IAddressReferenceExpression) ForEachPrefix(((IAddressReferenceExpression)expr).Expression, action); .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> IUnaryExpression) ForEachPrefix(((IUnaryExpression)expr).Expression, action); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> IAddressReferenceExpression) ForEachPrefix(((IAddressReferenceExpression)expr).Expression, action) .... }</code> </pre> <br>  Bedingte Ausdr√ºcke und <i>dann</i> Verzweigungen mehrerer <i>if-Anweisungen werden</i> dupliziert.  M√∂glicherweise wurde dieser Code mit der Copy-Paste-Methode geschrieben, weshalb das Problem aufgetreten ist.  Nun stellt sich heraus, dass <i>dann</i> Zweige der Duplikate niemals ausgef√ºhrt werden, da: <br><br><ul><li>  Wenn der bedingte Ausdruck wahr ist, wird der Hauptteil der ersten <i>if-Anweisung</i> des entsprechenden Paares ausgef√ºhrt. </li><li>  Wenn der bedingte Ausdruck im ersten Fall falsch ist, ist er im zweiten falsch. </li></ul><br>  Da Zweige <i>damals</i> dieselben Aktionen enthalten, sieht es jetzt wie redundanter Code aus, der verwirrend ist.  Es ist m√∂glich, dass dies ein anderes Problem ist - anstelle von Duplikaten sollten andere √úberpr√ºfungen durchgef√ºhrt worden sein. <br><br>  Wir fahren fort. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Pair&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; x, Pair&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.First &lt; y.First) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.Second &gt;= y.Second) { <span class="hljs-comment"><span class="hljs-comment">// y strictly contains x return 1; } else { // No containment - order by left bound return 1; } } else if (x.First &gt; y.First) { if (x.Second &lt;= y.Second) { // x strictly contains y return -1; } else { // No containment - order by left bound return -1; } } .... }</span></span></code> </pre> <br>  <b>PVS-Studio-Warnungen</b> : <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3004</a> Die Anweisung 'then' entspricht der Anweisung 'else'.  Laufzeit RegexpTreeBuilder.cs 1080 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3004</a> Die Anweisung 'then' entspricht der Anweisung 'else'.  Laufzeit RegexpTreeBuilder.cs 1093 </li></ul><br>  Der Code sieht √§u√üerst verd√§chtig aus, da er zwei bedingte Anweisungen mit identischen K√∂rpern von <i>then</i> und <i>else</i> branch enth√§lt.  In beiden F√§llen lohnt es sich wahrscheinlich, unterschiedliche Werte zur√ºckzugeben.  Wenn dies ein gedachtes Verhalten ist, ist es hilfreich, redundante bedingte Anweisungen zu entfernen. <br><br>  Es gab interessante Zyklen.  Beispiel unten: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Set&lt;StochasticityPattern&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectPatterns</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;StochasticityPattern&gt; patterns</span></span></span><span class="hljs-function">)</span></span> { Set&lt;StochasticityPattern&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Set&lt;StochasticityPattern&gt;(); result.AddRange(patterns); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> changed; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = result.Count; AddIntersections(result); changed = (result.Count != count); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (changed); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3020</a> Eine bedingungslose Unterbrechung innerhalb einer Schleife.  Compiler DefaultFactorManager.cs 474 <br><br>  Aufgrund der bedingungslosen <i>break-</i> Anweisung wird genau eine Iteration der Schleife ausgef√ºhrt, und die <i>ge√§nderte Steuervariable</i> wird nicht einmal verwendet.  Im Allgemeinen sieht der Code seltsam und verd√§chtig aus. <br><br>  Die gleiche Methode (exakte Kopie) wurde in einer anderen Klasse gefunden.  Entsprechende Analysatorwarnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3020</a> Eine bedingungslose Unterbrechung innerhalb einer Schleife.  Visualizers.Windows FactorManagerView.cs 350 <br><br>  √úbrigens traf eine Methode auf eine bedingungslose <i>continue-</i> Anweisung in einer Schleife (sie wurde vom Analysator mit derselben Diagnose gefunden), aber dar√ºber befand sich ein Kommentar, der best√§tigte, dass dies eine spezielle tempor√§re L√∂sung ist: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TEMPORARY continue;</span></span></code> </pre> <br>  Ich erinnere mich, dass es in der N√§he der bedingungslosen <i>Unterbrechungserkl√§rung</i> keine derartigen Kommentare gab. <br><br>  Lass uns weitermachen. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DependencyInformation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDependencyInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... IExpression resultIndex = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resultIndex != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.IsDefined( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(SkipIfMatchingIndexIsUniformAttribute), <span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resultIndex == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InferCompilerException( parameter.Name + <span class="hljs-string"><span class="hljs-string">" has SkipIfMatchingIndexIsUniformAttribute but "</span></span> + StringUtil.MethodNameToString(method) + <span class="hljs-string"><span class="hljs-string">" has no resultIndex parameter"</span></span>); .... } .... } .... }</code> </pre> <br>  <b>PVS-Studio-</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warnung</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022 Der</a> Ausdruck 'resultIndex == null' ist immer falsch.  Compiler FactorManager.cs 382 <br><br>  Ich <i>stelle</i> sofort fest, dass sich zwischen der Deklaration und der obigen √úberpr√ºfung der Wert der Variablen <i>resultIndex</i> √§ndern kann.  Zwischen den √úberpr√ºfungen <i>resultIndex! = Null</i> und <i>resultIndex == null kann der</i> Wert jedoch nicht bereits ge√§ndert werden.  Daher ist das Ergebnis des Ausdrucks <i>resultIndex == null</i> immer <i>falsch</i> , was bedeutet, dass niemals eine Ausnahme ausgel√∂st wird. <br><br>  Ich hoffe, dass Sie ein Interesse daran haben, ohne meine Vorschl√§ge selbst Fehler zu finden, um ein Problem zu finden, aber f√ºr den Fall, dass ich es erneut vorschlage.  Der Methodencode ist klein, ich werde ihn in seiner Gesamtheit geben. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Tuple&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeMovieGenre</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> feature</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] genres = feature.Split(<span class="hljs-string"><span class="hljs-string">'|'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (genres.Length &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; genres.Length &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format( <span class="hljs-string"><span class="hljs-string">"Movies should have between 1 and 3 genres; given {0}."</span></span>, genres.Length)); } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / genres.Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder( <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format( <span class="hljs-string"><span class="hljs-string">"{0}:{1}"</span></span>, offset + MovieGenreBuckets[genres[<span class="hljs-number"><span class="hljs-number">0</span></span>]], <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; genres.Length; ++i) { result.Append( <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format( <span class="hljs-string"><span class="hljs-string">"|{0}:{1}"</span></span>, offset + MovieGenreBuckets[genres[i].Trim()], <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(MovieGenreBucketCount, result.ToString()); }</code> </pre> <br>  Mal sehen, was hier passiert.  Die Eingabezeichenfolge wird durch das Zeichen '|' analysiert.  Wenn die L√§nge des Arrays nicht wie erwartet ist, muss eine Ausnahme ausgel√∂st werden.  <i>Warten Sie eine Sekunde</i> ... <i>genres.Length &lt;1 &amp;&amp; genres.Length&gt; 3</i> ?  Da es keine Zahl gibt, die sofort in den f√ºr den Ausdruck ( <i>[int.MinValue..1)</i> und <i>(3..int.MaxValue]</i> ) erforderlichen Wertebereich f√§llt, ist das Ergebnis des Ausdrucks immer <i>falsch</i> .  Daher sch√ºtzt diese Pr√ºfung nicht vor irgendetwas und die erwartete Ausnahme wird nicht ausgel√∂st. <br><br>  Genau davor warnt der Analysator: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022</a> Ausdruck 'genres.Length &lt;1 &amp;&amp; genres.Length&gt; 3' ist immer falsch.  Wahrscheinlich das '||'  Operator sollte hier verwendet werden.  Evaluator Features.cs 242 <br><br>  Verd√§chtige Spaltoperation erf√ºllt. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTrueThetaAndPhi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> expectedRepeatOfTopicInDoc = averageDocLength / numUniqueTopicsPerDoc; .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt = Poisson.Sample(expectedRepeatOfTopicInDoc); .... }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3041</a> Der Ausdruck wurde implizit vom Typ 'int' in den Typ 'double' umgewandelt.  Erw√§gen Sie die Verwendung eines expliziten Typgusses, um den Verlust eines Bruchteils zu vermeiden.  Ein Beispiel: double A = (double) (X) / Y;  LDA Utilities.cs 74 <br><br>  Dies ist hier verd√§chtig: Es wird eine Ganzzahldivision durchgef√ºhrt (die Variablen <i>averDocLength</i> und <i>numUniqueTopicsPerDoc</i> sind vom Typ <i>int</i> ), und das Ergebnis wird in eine Variable vom Typ <i>double geschrieben</i> .  Die Frage lautet: Wird es speziell gemacht oder wurde die Aufteilung reeller Zahlen noch impliziert?  Wenn die Variable <i>expectedRepeatOfTopicInDoc</i> vom Typ <i>int w√§re</i> , w√ºrde dies m√∂gliche Fragen kl√§ren. <br><br>  An anderen Stellen wird beispielsweise die <i>Poisson.Sample-</i> Methode verwendet, deren Argument die verd√§chtige Variable <i>expectedRepeatOfTopicInDoc</i> ist. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numUniqueWordsPerTopic = Poisson.Sample((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)averageWordsPerTopic);</code> </pre> <br>  <i>averWordsPerTopic</i> ist vom Typ <i>int</i> , der am Verwendungsort bereits in <i>double</i> konvertiert wurde. <br><br>  Und hier ist ein weiterer Einsatzort: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> expectedRepeatOfWordInTopic = ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)numDocs) * averageDocLength / numUniqueWordsPerTopic; .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt = Poisson.Sample(expectedRepeatOfWordInTopic);</code> </pre> <br>  Bitte beachten Sie, dass die Variablen dieselben Namen wie im urspr√ºnglichen Beispiel haben. Zum Initialisieren der <i>erwarteten</i> <i>Wiederholung</i> von <i>WordInTopic</i> wird nur die Division von reellen Zahlen verwendet (aufgrund der expliziten Konvertierung von <i>numDocs</i> in <i>double</i> ). <br><br>  Im Allgemeinen lohnt es sich, den Startpunkt zu betrachten, an dem der Analysator eine Warnung ausgegeben hat. <br><br>  Aber √úberlegungen, ob es sich lohnt, sie zu bearbeiten und wie, lassen Sie die Autoren des Codes (sie wissen es besser), aber lassen Sie uns weiter gehen.  Zur n√§chsten verd√§chtigen Abteilung. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NonconjugateGaussian </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BAverageLogarithm</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v_opt = <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> * (Math.Log(mx * mz / Ex2 / <span class="hljs-number"><span class="hljs-number">2</span></span>) - m); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v_opt != v) { .... } .... }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3041</a> Der Ausdruck wurde implizit vom Typ 'int' in den Typ 'double' umgewandelt.  Erw√§gen Sie die Verwendung eines expliziten Typgusses, um den Verlust eines Bruchteils zu vermeiden.  Ein Beispiel: double A = (double) (X) / Y;  Laufzeit ProductExp.cs 137 <br><br>  Der Analysator erkannte erneut den verd√§chtigen Vorgang der Ganzzahldivision als  <i>2</i> und <i>3</i> sind ganzzahlige numerische Literale, und das Ergebnis des Ausdrucks 2/3 ist <i>0</i> .  Infolgedessen hat der gesamte Ausdruck die Form: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v_opt = <span class="hljs-number"><span class="hljs-number">0</span></span> * expr;</code> </pre> <br>  Stimmen Sie zu, ein wenig seltsam.  Mehrmals kehrte ich zu dieser Warnung zur√ºck und versuchte, einen Fang zu finden, ohne ihn dem Artikel hinzuzuf√ºgen.  Die Methode ist mit Mathematik und verschiedenen Formeln gef√ºllt (die ich ehrlich gesagt nicht wirklich zerlegen wollte). Sie wissen nie, was Sie erwartet.  Au√üerdem versuche ich, den Warnungen, die ich in dem Artikel schreibe, so skeptisch wie m√∂glich gegen√ºber zu sein, und beschreibe sie erst, nachdem ich sie besser studiert habe. <br><br>  Aber dann wurde mir klar, warum ich einen Faktor von <i>0</i> brauche, geschrieben als <i>2/3</i> ?  Dieser Ort ist also trotzdem einen Blick wert. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TextWriter writer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> defaultValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Func&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; converter = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( defaultValue == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Equals(defaultValue)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> stringValue = converter == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ToString() : converter(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); writer.Write(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{name}</span></span></span><span class="hljs-string">=\"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{stringValue}</span></span></span><span class="hljs-string">\" "</span></span>); }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung.  Betrachten Sie die √úberpr√ºfung des Werts.  Compiler WriteHelpers.cs 78 <br><br>  Ziemlich faire Aussage des Analysators basierend auf der Bedingung  Die Dereferenzierung einer <i>Nullreferenz</i> kann im Ausdruck <i>value.Equals (defaultValue) erfolgen,</i> wenn <i>value == null</i> .  Da dieser Ausdruck der rechte Operand des Operators || ist, muss der linke Operand zur Berechnung <i>falsch sein</i> . Dazu reicht es aus, dass mindestens eine der Variablen <i>defaultValue</i> \ <i>value</i> nicht <i>null ist</i> .  Wenn <i>defaultValue! = Null</i> und <i>value == null</i> : <br><br><ul><li>  <i>defaultValue == null</i> -&gt; <i>false</i> ; </li><li>  <i>defaultValue == null &amp;&amp; value == null</i> -&gt; <i>false</i> ;  (Wertpr√ºfung nicht stattgefunden) </li><li>  <i>value.Equals (defaultValue)</i> -&gt; <i>NullReferenceException</i> , da <i>value</i> <i>null ist</i> . </li></ul><br>  Schauen wir uns einen √§hnlichen Fall an: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FeatureParameterDistribution</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> GaussianMatrix traitFeatureWeightDistribution, GaussianArray biasFeatureWeightDistribution</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( (traitFeatureWeightDistribution == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; biasFeatureWeightDistribution == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || traitFeatureWeightDistribution.All( w =&gt; w != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; w.Count == biasFeatureWeightDistribution.Count), <span class="hljs-string"><span class="hljs-string">"The provided distributions should be valid and consistent in the number of features."</span></span>); .... }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie 'traitFeatureWeightDistribution'.  Recommender FeatureParameterDistribution.cs 65 <br><br>  Wir werfen den √úberschuss weg und lassen nur die Logik f√ºr die Berechnung des Booleschen Werts √ºbrig, damit es einfacher ist, Folgendes herauszufinden: <br><br><pre> <code class="cs hljs">(traitFeatureWeightDistribution == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; biasFeatureWeightDistribution == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || traitFeatureWeightDistribution.All( w =&gt; w != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; w.Count == biasFeatureWeightDistribution.Count)</code> </pre> <br>  Wieder der richtige Operand des ||  Es wird nur berechnet, wenn das Ergebnis der linken Berechnung <i>falsch ist</i> .  Der linke Operand kann <i>falsch sein</i> , auch wenn <i>traitFeatureWeightDistribution == null</i> und <i>BiasFeatureWeightDistribution! = Null sind</i> .  Dann wird der richtige Operand des Operators || berechnet und ein Aufruf von <i>traitFeatureWeightDistribution.All l√∂st</i> eine <i>ArgumentNullException aus</i> . <br><br>  Ein weiterer interessanter Code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetQuantile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> probability, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] quantiles</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = quantiles.Length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (quantiles == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(quantiles)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"quantiles array is empty"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(quantiles)); .... }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3095</a> Das 'Quantiles'-Objekt wurde verwendet, bevor es gegen Null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 91, 92. Runtime OuterQuantiles.cs 91 <br><br>  Beachten Sie, dass zuerst auf die Eigenschaft <i>quantiles.Length zugegriffen</i> wird und dann die <i>Quantile</i> auf <i>Null</i> √ºberpr√ºft werden.  Wenn <i>Quantile == null sind</i> , <i>l√∂st</i> die Methode daher eine Ausnahme aus, die nur ein wenig falsch ist und ein wenig nicht dort, wo sie ben√∂tigt wurde.  Anscheinend haben sie die Linien stellenweise durcheinander gebracht. <br><br>  Wenn Sie sich erfolgreich mit der Erkennung fr√ºherer Fehler befasst haben, empfehle ich Ihnen, eine Tasse Kaffee zu kochen und zu versuchen, das Kunstst√ºck zu wiederholen, wobei Sie den Fehler in der folgenden Methode finden.  Um es etwas interessanter zu machen, zitiere ich den gesamten Code der Methode. <br><br>  ( <a href="">Link zum Fullsize</a> ) <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c2c/5ff/2d9/c2c5ff2d99aca64bbda4136acfa4b1d4.png" alt="Bild 2"></p><br><br>  Okay, okay, das war ein Witz (oder hast du es geschafft ?!).  Lassen Sie uns die Aufgabe etwas vereinfachen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sample.Precision &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { precisionIsBetween = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; lowerBound = <span class="hljs-number"><span class="hljs-number">-1.0</span></span> / v; upperBound = -mean.Precision; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sample.Precision &lt; -mean.Precision) { precisionIsBetween = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; lowerBound = <span class="hljs-number"><span class="hljs-number">0</span></span>; upperBound = -mean.Precision; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// in this case, the precision should NOT be in this interval. precisionIsBetween = false; lowerBound = -mean.Precision; lowerBound = -1.0 / v; }</span></span></code> </pre> <br>  Ist es besser geworden?  Der Analysator hat die folgende Warnung f√ºr diesen Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgegeben</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3008</a> Der Variablen 'lowerBound' werden zweimal nacheinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 324, 323. Runtime GaussianOp.cs 324 <br><br>  In der Tat wird im letzten Zweig <i>else</i> der Wert der Variablen <i>lowerBound</i> zweimal hintereinander zugewiesen.  Anscheinend (und nach dem obigen Code zu urteilen) muss die Variable <i>UpperBound</i> an einer der Zuweisungen beteiligt sein. <br><br>  Wir folgen weiter. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAucMatrix</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; c &lt; classLabelCount; c++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> labelWidth = labels[c].Length; columnWidths[c + <span class="hljs-number"><span class="hljs-number">1</span></span>] = labelWidth &gt; MaxLabelWidth ? MaxLabelWidth : labelWidth; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; r &lt; classLabelCount; r++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> countWidth = MaxValueWidth; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countWidth &gt; columnWidths[c + <span class="hljs-number"><span class="hljs-number">1</span></span>]) { columnWidths[c + <span class="hljs-number"><span class="hljs-number">1</span></span>] = countWidth; } } .... }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3081</a> Der ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">r'</a> -Z√§hler wird nicht in einer verschachtelten Schleife verwendet.  √úberpr√ºfen Sie die Verwendung des C-Z√§hlers.  CommandLine ClassifierEvaluationModule.cs 459 <br><br>  Bitte beachten Sie, dass der Z√§hler der inneren Schleife - <i>r</i> - im K√∂rper dieser Schleife nicht verwendet wird.  Aus diesem Grund stellt sich heraus, dass w√§hrend aller Iterationen der inneren Schleife dieselben Operationen an denselben Elementen ausgef√ºhrt werden - da die Indizes auch den Z√§hler der √§u√üeren Schleife ( <i>c</i> ) und nicht den inneren ( <i>r</i> ) verwenden. <br><br>  Mal sehen, was sonst noch interessant war. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegexpFormattingSettings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> putOptionalInSquareBrackets, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> showAnyElementAsQuestionMark, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ignoreElementDistributionDetails, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> truncationLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> escapeCharacters, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useLazyQuantifier</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PutOptionalInSquareBrackets = putOptionalInSquareBrackets; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ShowAnyElementAsQuestionMark = showAnyElementAsQuestionMark; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IgnoreElementDistributionDetails = ignoreElementDistributionDetails; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.TruncationLength = truncationLength; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.EscapeCharacters = escapeCharacters; }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3117-</a> Konstruktorparameter 'useLazyQuantifier' wird nicht verwendet.  Runtime RegexpFormattingSettings.cs 38 <br><br>  Der Konstruktor verwendet keinen Parameter - <i>useLazyQuantifier</i> .  Dies erscheint vor dem Hintergrund besonders verd√§chtig, dass in der Klasse <i>UseLazyQuantifier</i> eine Eigenschaft mit dem entsprechenden Namen und Typ definiert ist.  Anscheinend haben sie vergessen, es √ºber den entsprechenden Parameter zu initialisieren. <br><br>  Traf mehrere potenziell gef√§hrliche Ereignishandler.  Ein Beispiel f√ºr einen von ihnen ist unten angegeben: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RecommenderRun</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Started; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Report that the run has been started if (this.Started != null) { this.Started(this, EventArgs.Empty); } .... } .... }</span></span></code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3083</a> Unsicherer Aufruf des Ereignisses 'Gestartet', NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  Evaluator RecommenderRun.cs 115 <br><br>  Tatsache ist, dass zwischen der Pr√ºfung auf <i>Null-</i> Ungleichung und dem Aufruf des Handlers ein Ereignis abgemeldet werden kann. Wenn das Ereignis im Moment zwischen der Pr√ºfung auf <i>Null</i> und dem Aufruf der Handler keine Abonnenten hat, wird eine <i>NullReferenceException ausgel√∂st</i> .  Um solche Probleme zu vermeiden, k√∂nnen Sie beispielsweise den Link zur Delegatenkette in einer lokalen Variablen speichern oder den Operator '?.' Verwenden  Handler anrufen. <br><br>  Zus√§tzlich zu dem obigen Code-Snippet gab es 35 solcher Stellen. <br><br>  √úbrigens wurden auch <b>785</b> Warnungen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3024</a> erf√ºllt.  Warnung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3024</a> wird ausgegeben, wenn reelle Zahlen mit den Operatoren '! =' Oder '==' verglichen werden.  Ich werde hier nicht n√§her darauf eingehen, warum solche Vergleiche nicht immer korrekt sind - mehr dazu in der Dokumentation, es gibt auch einen Link zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StackOverflow</a> (das ist es). <br><br>  In Anbetracht der Tatsache, dass Formeln und Berechnungen h√§ufig eingehalten wurden, k√∂nnen diese Warnungen ebenfalls wichtig sein, obwohl sie auf Stufe 3 gebracht werden (da sie in allen Projekten nicht relevant sind). <br><br>  Wenn Sie sicher sind, dass diese Warnungen irrelevant sind, k√∂nnen Sie sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fast einem Klick</a> entfernen, wodurch sich die Gesamtzahl der Analysatorvorg√§nge verringert. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47e/77b/72d/47e77b72dbb716dadbd1623513150819.png"></div><br><br><h2>  Fazit </h2><br>  Irgendwie stellte sich heraus, dass ich lange Zeit keine Artikel √ºber das √úberpr√ºfen von Projekten geschrieben hatte, und es war sehr angenehm, diesen Prozess noch einmal zu ber√ºhren.  Ich hoffe, dass Sie aus diesem Artikel auch etwas Neues / N√ºtzliches gelernt haben oder es zumindest mit Interesse gelesen haben. <br><br>  Ich w√ºnsche den Entwicklern eine fr√ºhzeitige Korrektur der Problembereiche und erinnere Sie daran, dass es normal ist, Fehler zu machen, aber wir sind Menschen.  Daf√ºr werden zus√§tzliche Tools wie statische Analyseger√§te ben√∂tigt, um herauszufinden, was eine Person vermisst hat, oder?  Wie auch immer - viel Gl√ºck mit dem Projekt und vielen Dank f√ºr die Arbeit! <br><br>  Und denken Sie daran, dass der maximale Nutzen eines statischen Analysators durch seine <i>regelm√§√üige Verwendung erreicht wird</i> . <br><br>  Alles Gute! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Sergey Vasiliev.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Welche Fehler lauern im Infer.NET-Code?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429578/">https://habr.com/ru/post/de429578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429564/index.html">‚ÄûIch bin nur ein Projektbegeisterter und Benutzer der Dart-Sprache‚Äú - Interview mit Ari Lerner, Autor des ber√ºhmten ng-Buches</a></li>
<li><a href="../de429568/index.html">Reduzieren Sie mit Zextras Backup die Ausfallzeiten von Zimbra bei Serverabst√ºrzen</a></li>
<li><a href="../de429570/index.html">Einem Agenten beibringen, Mario Kart mit Filtern zu spielen</a></li>
<li><a href="../de429572/index.html">Abfangen privater Konversationen in Skype mit Devicelock DLP</a></li>
<li><a href="../de429574/index.html">Kostenloser Check Point f√ºr Anf√§ngerkurs bei CheckMates</a></li>
<li><a href="../de429580/index.html">Mikrointeraktionen in iOS. Yandex Vortrag</a></li>
<li><a href="../de429582/index.html">Analoge Anzeige der Computerlast</a></li>
<li><a href="../de429586/index.html">So bestimmen Sie den besten Zeitpunkt f√ºr den Handel an der B√∂rse</a></li>
<li><a href="../de429588/index.html">Die ganze Wahrheit √ºber RTOS. Artikel Nr. 20. Semaphoren: Nebendienstleistungen und Datenstrukturen</a></li>
<li><a href="../de429590/index.html">Sprachanalyse f√ºr SOLR-basierte Call Center</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>