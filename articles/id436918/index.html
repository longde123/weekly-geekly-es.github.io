<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤´ğŸ¼ â˜®ï¸ ğŸ¨ Membuat Game untuk Game Boy, Bagian 2 ğŸ¤¦ğŸ» ğŸ¥© ğŸ‘©â€ğŸ”§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa minggu yang lalu, saya memutuskan untuk mengerjakan game untuk Game Boy, kreasi yang memberi saya kesenangan besar. Nama kerjanya adalah Aqua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat Game untuk Game Boy, Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436918/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/849/ccb/9b1/849ccb9b1062f45b917d8771b08bf2c0.png" alt="gambar"></div><br>  Beberapa minggu yang lalu, saya memutuskan untuk mengerjakan game untuk Game Boy, kreasi yang memberi saya kesenangan besar.  Nama kerjanya adalah Aqua dan Abu.  Game ini memiliki sumber terbuka dan diposting di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Bagian sebelumnya dari artikel ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Sprite fantastis dan di mana mereka tinggal </h2><br>  Pada bagian terakhir, saya selesai merender beberapa sprite di layar.  Ini dilakukan dengan cara yang sangat sewenang-wenang dan kacau.  Bahkan, saya harus menunjukkan dalam kode apa dan di mana saya ingin ditampilkan.  Ini membuat pembuatan animasi hampir mustahil, menghabiskan banyak waktu CPU dan dukungan kode yang rumit.  Saya membutuhkan cara yang lebih baik. <br><br>  Secara khusus, saya membutuhkan sistem di mana saya bisa dengan mudah mengulangi nomor animasi, nomor bingkai, dan timer untuk setiap animasi individu.  Jika saya perlu mengubah animasi, saya hanya akan mengubah animasi dan mereset penghitung bingkai.  Prosedur animasi yang dilakukan di setiap frame cukup dengan memilih sprite yang sesuai untuk ditampilkan dan melemparkannya di layar tanpa usaha apa pun dari saya. <br><a name="habracut"></a><br>  Dan ternyata, tugas ini secara praktis diselesaikan.  Apa yang saya cari disebut <em>pemetaan sprite</em> .  Peta sprite adalah struktur data yang (secara kasar) berisi daftar sprite.  Setiap peta sprite berisi semua sprite untuk merender objek tunggal.  Juga terkait dengan mereka adalah <em>peta animasi (pemetaan animasi)</em> , yang merupakan daftar peta sprite dengan informasi tentang cara loop. <br><br>  Cukup lucu bahwa pada bulan Mei, saya menambahkan editor peta animasi ke editor peta sprite yang sudah jadi untuk game Sonic 16-bit tentang Sonic.  (Dia ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , kamu bisa belajar) Itu belum selesai, karena agak kasar, sangat lambat dan tidak nyaman untuk digunakan.  Tetapi dari sudut pandang teknis, ini berhasil.  Dan menurut <em>saya</em> itu cukup keren ... (Salah satu alasan dari kekasarannya adalah saya pertama kali bekerja dengan kerangka JavaScript.) Sonic adalah game lama, jadi ini ideal sebagai fondasi untuk game baru-lama saya. <br><br><h2>  Format Kartu Sonic 2 </h2><br>  Saya bermaksud menggunakan editor di Sonic 2 karena saya ingin membuat retasan untuk Genesis.  Sonic 1 dan 3K pada dasarnya hampir sama, tetapi agar tidak menyulitkan, saya akan membatasi diri pada cerita tentang bagian kedua. <br><br>  Pertama, mari kita lihat peta sprite.  Inilah sprite Tail yang cukup khas, bagian dari animasi blink. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a1/5c7/1a0/6a15c71a0607d906333fe5e189c3b223.png"></div><br>  Konsol Genesis menciptakan sprite sedikit berbeda.  Genteng Genesis (kebanyakan programmer menyebutnya "pola") adalah 8x8, sama seperti pada Game Boy.  Sprite terdiri dari kotak hingga 4x4 ubin, mirip dengan mode sprite 8x16 pada Game Boy, tetapi lebih fleksibel.  Kuncinya di sini adalah bahwa dalam memori ubin ini harus bersebelahan.  Pengembang Sonic 2 ingin menggunakan kembali ubin sebanyak mungkin untuk bingkai Tails yang berkedip dari bingkai Tails yang berdiri.  Oleh karena itu, Tails dibagi menjadi 2 sprite perangkat keras, terdiri dari ubin 3x2 - satu untuk kepala, yang lain untuk tubuh.  Mereka ditunjukkan pada gambar di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3c/f35/4fd/b3cf354fd7f9f482b3e04ca5ab6b7ad3.png"></div><br>  Bagian atas kotak dialog ini adalah atribut sprite perangkat keras.  Ini berisi posisi mereka relatif terhadap titik awal (angka negatif terputus; pada kenyataannya, ini adalah -16 dan -12 untuk sprite pertama dan -12 untuk yang kedua), ubin awal yang digunakan dalam VRAM, lebar dan tinggi sprite, serta berbagai bit status untuk gambar cermin sprite dan palet. <br><br>  Ubin ditampilkan di bagian bawah karena diambil dari ROM ke VRAM.  Tidak ada ruang yang cukup untuk menyimpan semua sprite Tails di VRAM, jadi ubin yang diperlukan harus disalin ke memori di setiap frame.  Mereka disebut <em>Dynamic Load Load Isues</em> .  Namun, sementara kita dapat melewati mereka, karena mereka hampir tidak bergantung pada peta sprite, dan karena itu mereka dapat dengan mudah ditambahkan nanti. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e7/fc5/33b/8e7fc533b1b25a0ea1edcc785163f1ba.png"></div><br>  Sedangkan untuk animasi, semuanya di sini sedikit lebih mudah.  Peta animasi di Sonic adalah daftar peta sprite dengan dua potong metadata - nilai kecepatan dan tindakan yang harus diambil setelah animasi selesai.  Tiga tindakan yang paling umum digunakan adalah: loop atas semua frame, loop atas frame N terakhir, atau transisi ke animasi yang sama sekali berbeda (misalnya, ketika beralih dari animasi Sonic berdiri ke animasi keinginannya menginjak-injak kakinya).  Ada beberapa perintah yang menentukan flag internal di memori objek, tetapi tidak banyak objek yang menggunakannya.  (Sekarang terpikir oleh saya bahwa Anda dapat mengatur bit dalam RAM objek ke nilai ketika mengulang animasi. Ini akan berguna untuk efek suara dan hal-hal lain.) <br><br>  Jika Anda melihat kode <a href="">Sonic 1 yang dibongkar</a> (kode Sonic 2 terlalu besar untuk ditautkan), Anda akan melihat bahwa tautan ke animasi tidak dibuat oleh ID apa pun.  Setiap objek diberi daftar animasi, dan indeks animasi disimpan dalam memori.  Untuk membuat animasi tertentu, gim ini mengambil indeks, mencarinya di daftar animasi, lalu merendernya.  Ini membuat pekerjaan sedikit lebih mudah, karena Anda tidak perlu memindai animasi untuk menemukan yang Anda butuhkan. <br><br><h2>  Kami membersihkan sup dari struktur </h2><br>  Mari kita lihat jenis kartu: <br><br><ol><li>  Peta sprite: daftar sprite yang terdiri dari ubin awal, jumlah ubin, posisi, keadaan refleksi (sprite dicerminkan atau tidak) dan palet. </li><li>  DPLC: daftar ubin ROM yang perlu dimuat ke VRAM.  Setiap item dalam DPLC terdiri dari ubin awal dan panjang;  setiap item ditempatkan di VRAM setelah yang terakhir. </li><li>  Peta Animasi: Daftar animasi yang terdiri dari daftar peta sprite, nilai kecepatan, dan tindakan siklus. </li><li>  Daftar animasi: Daftar petunjuk untuk tindakan setiap animasi. </li></ol><br>  Karena kami bekerja dengan Game Boy, beberapa penyederhanaan dapat dilakukan.  Kita tahu bahwa dalam peta sprite dalam sprite 8x16 akan selalu ada dua ubin.  Namun, semua yang lain harus dilestarikan.  Untuk saat ini, kami dapat sepenuhnya meninggalkan DPLC dan menyimpan semuanya di VRAM.  Ini adalah solusi sementara, tetapi, seperti yang saya katakan, masalah ini akan mudah dipecahkan.  Akhirnya, kita dapat membuang nilai kecepatan jika kita mengasumsikan bahwa setiap animasi bekerja pada kecepatan yang sama. <br><br>  Mari kita mulai mencari tahu bagaimana menerapkan sistem serupa di game saya. <br><br>  Periksa dengan komit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2e5e5b7</a> ! <br><br>  Mari kita mulai dengan peta sprite.  Setiap elemen dalam peta harus mencerminkan OAM (Object Attribute Memory - sprite VRAM) dan dengan demikian loop dan memcpy sederhana akan cukup untuk menampilkan objek.  Biarkan saya mengingatkan Anda bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">elemen dalam OAM terdiri dari Y, X, ubin awal dan byte atribut</a> .  Saya hanya perlu membuat daftar mereka.  Dengan menggunakan pseudo-operator EQU, saya menyiapkan byte atribut terlebih dahulu sehingga saya memiliki nama yang dapat dibaca untuk setiap kombinasi atribut yang mungkin.  (Anda dapat melihat bahwa di komit sebelumnya, saya mengganti ubin Y / X di kartu. Ini terjadi karena saya membaca spesifikasi OAM secara tidak sengaja. Saya juga menambahkan penghitung sprite untuk mengetahui berapa lama pengulangan harus dilakukan.) <br><br>  Anda akan melihat bahwa tubuh dan ekor rubah kutub disimpan secara terpisah.  Jika mereka disimpan bersama, maka akan ada <em>banyak</em> redundansi, karena setiap animasi harus diduplikasi untuk setiap keadaan ekor.  Dan skala redundansi akan meningkat dengan cepat.  Dalam Sonic 2, masalah yang sama muncul dengan Tails.  Mereka menyelesaikannya di sana, membuat Tails menjadi objek terpisah dengan keadaan animasi dan timer sendiri.  Saya tidak ingin melakukan ini karena saya tidak mencoba memecahkan masalah mempertahankan posisi ekor yang benar relatif terhadap rubah. <br><br>  Saya memecahkan masalah melalui peta animasi.  Jika Anda melihat peta animasi (tunggal) saya, maka ada tiga bagian metadata di dalamnya.  Ini menunjukkan jumlah kartu animasi, jadi saya tahu kapan mereka akan berakhir.  (Dalam Sonic, diperiksa bahwa animasi berikut tidak valid, mirip dengan konsep nol byte pada baris C. Solusi dari Sonic membebaskan case, tetapi menambahkan perbandingan yang akan bekerja terhadap saya.) Tentu saja, masih ada aksi loop.  (Saya mengubah sirkuit Sonic 2-byte menjadi angka 1-byte di mana bit 7 adalah bit mode.) Tetapi saya juga memiliki jumlah <em>kartu sprite</em> , tetapi tidak dalam Sonic.  Memiliki beberapa peta sprite per bingkai animasi memungkinkan saya menggunakan kembali animasi dalam beberapa animasi, yang, menurut saya, akan menghemat banyak ruang berharga.  Anda juga dapat melihat bahwa animasi digandakan untuk setiap arah.  Ini karena peta untuk setiap arah berbeda, dan Anda perlu menambahkannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e9/e7d/240/8e9e7d2401e1a07d0c77e2f0c6c99e3d.png" alt="gambar"></div><br><h2>  Menari dengan register </h2><br>  Lihat <a href="">file ini</a> di 1713848. <br><br>  Mari kita mulai dengan menggambar satu sprite di layar.  Jadi, saya akui, saya berbohong.  Biarkan saya mengingatkan Anda bahwa kami tidak dapat merekam pada layar di luar VBlank.  Dan seluruh proses ini terlalu panjang untuk muat di VBlank.  Oleh karena itu, kita perlu merekam area memori yang akan kita alokasikan untuk DMA.  Pada akhirnya, itu tidak mengubah apa pun, penting untuk merekam di tempat yang tepat. <br><br>  Mari kita mulai menghitung register.  Prosesor GBZ80 memiliki 6 register, dari A ke E, H dan L. H dan L adalah register khusus, sehingga mereka sangat cocok untuk melakukan iterasi dari memori.  (Karena mereka digunakan bersama, mereka disebut HL.) Dalam satu opcode, saya dapat menulis ke alamat memori yang terkandung dalam HL dan menambahkan satu ke dalamnya.  Ini sulit ditangani.  Anda dapat menggunakannya sebagai sumber atau sebagai tujuan.  Saya menggunakannya sebagai alamat, dan kombinasi register BC sebagai sumber, karena itu paling nyaman.  Kami hanya memiliki A, D dan E. Saya perlu mendaftar A untuk operasi matematika dan sejenisnya.  Untuk apa DE bisa digunakan?  Saya menggunakan D sebagai penghitung lingkaran, dan E sebagai ruang kerja.  Dan di sinilah register berakhir. <br><br>  Katakanlah kita memiliki 4 sprite.  Kami mengatur register D (penghitung siklus) ke 4, register HL (tujuan) alamat penyangga OAM, dan BC (sumber) lokasi dalam ROM tempat kartu kami disimpan.  Sekarang saya ingin memanggil memcpy.  Namun, masalah kecil muncul.  Ingat koordinat X dan Y?  Mereka ditunjukkan relatif ke titik awal, pusat objek digunakan untuk tabrakan dan sejenisnya.  Jika kita merekamnya apa adanya, maka setiap objek akan ditampilkan di sudut kiri atas layar.  Ini tidak cocok untuk kita.  Untuk memperbaiki ini, kita perlu menambahkan koordinat X dan Y dari objek ke X dan Y dari sprite. <br><br>  Catatan singkat: Saya berbicara tentang "objek", tetapi saya tidak menjelaskan konsep ini kepada Anda.  Sebuah objek hanyalah sekumpulan atribut yang terkait dengan objek dalam sebuah game.  Atribut adalah posisi, kecepatan, arah.  deskripsi barang, dll.  Saya membicarakan hal ini karena saya perlu mengekstrak data X dan Y dari objek-objek ini.Untuk melakukan ini, kita memerlukan set register ketiga yang menunjuk ke tempat di RAM dari objek di mana koordinat berada.  Dan kemudian kita perlu menyimpan X dan Y di suatu tempat.Hal yang sama berlaku untuk arah, karena membantu kita menentukan ke arah mana sprite mencari.  Selain itu, kita perlu me <em>-</em> render <em>semua</em> objek, sehingga mereka juga membutuhkan counter loop.  Dan kita belum sampai ke animasinya!  Semuanya dengan cepat di luar kendali ... <br><br><h2>  Peninjauan keputusan </h2><br>  Jadi, saya berlari terlalu jauh ke depan.  Mari kita kembali dan memikirkan setiap bagian data yang perlu saya lacak, dan di mana harus menulisnya. <br><br>  Untuk memulai, mari bagi ini menjadi "langkah-langkah."  Setiap langkah hanya akan menerima data untuk langkah berikutnya, kecuali yang terakhir yang melakukan penyalinan. <br><br><ol><li>  Object (loop) - mencari tahu apakah objek harus dirender, dan merendernya. </li><li>  Daftar animasi - menentukan animasi yang akan ditampilkan.  Juga mendapat atribut dari suatu objek. </li><li>  Animasi (loop) - menentukan daftar peta mana yang akan digunakan, dan membuat setiap peta darinya. </li><li>  Peta (siklus) - berulang melalui setiap sprite dalam daftar sprite </li><li>  Sprite - menyalin atribut sprite ke buffer OAM </li></ol><br>  Untuk setiap tahap saya telah membuat daftar variabel yang mereka butuhkan, peran yang mereka mainkan dan tempat untuk menyimpannya.  Tabel ini terlihat seperti ini. <br><br><table><tbody><tr><th>  Deskripsi </th><th>  Ukuran </th><th>  Panggung </th><th>  Gunakan </th><th>  Dari mana </th><th>  Tempat </th><th>  Ke mana </th></tr><tr><td>  Buffer OAM </td><td>  2 </td><td>  Sprite </td><td>  Pointer </td><td>  Hl </td><td>  Hl </td><td></td></tr><tr><td>  Sumber peta </td><td>  2 </td><td>  Sprite </td><td>  Pointer </td><td>  SM </td><td>  SM </td><td></td></tr><tr><td>  Byte saat ini </td><td>  1 </td><td>  Sprite </td><td>  Ruang kerja </td><td>  Sumber peta </td><td>  E </td><td></td></tr><tr><td>  X </td><td>  1 </td><td>  Sprite </td><td>  Variabel </td><td>  Hiram </td><td>  A </td><td></td></tr><tr><td>  Y </td><td>  1 </td><td>  Sprite </td><td>  Variabel </td><td>  Hiram </td><td>  A </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Mulai dari peta animasi </td><td>  2 </td><td>  Peta sprite </td><td>  Pointer </td><td>  Tumpukan3 </td><td>  DE </td><td></td></tr><tr><td>  Sumber peta </td><td>  2 </td><td>  Peta sprite </td><td>  Pointer </td><td>  [DE] </td><td>  SM </td><td></td></tr><tr><td>  Sprite yang tersisa </td><td>  1 </td><td>  Peta sprite </td><td>  Gores </td><td>  Sumber peta </td><td>  D </td><td></td></tr><tr><td>  Buffer OAM </td><td>  1 </td><td>  Peta sprite </td><td>  Pointer </td><td>  Hl </td><td>  Hl </td><td>  Tumpukan1 </td></tr><tr><td colspan="7"></td></tr><tr><td>  Mulai dari peta animasi </td><td>  2 </td><td>  Animasi </td><td>  Ruang kerja </td><td>  BC / Stack3 </td><td>  SM </td><td>  Tumpukan3 </td></tr><tr><td>  Kartu yang tersisa </td><td>  1 </td><td>  Animasi </td><td>  Ruang kerja </td><td>  Animasi dimulai </td><td>  Hiram </td><td></td></tr><tr><td>  Total jumlah kartu </td><td>  1 </td><td>  Animasi </td><td>  Variabel </td><td>  Animasi dimulai </td><td>  Hiram </td><td></td></tr><tr><td>  Arah Objek </td><td>  1 </td><td>  Animasi </td><td>  Variabel </td><td>  Hiram </td><td>  Hiram </td><td></td></tr><tr><td>  Kartu per bingkai </td><td>  1 </td><td>  Animasi </td><td>  Variabel </td><td>  Animasi dimulai </td><td>  TIDAK DIGUNAKAN !!! </td><td></td></tr><tr><td>  Nomor bingkai </td><td>  1 </td><td>  Animasi </td><td>  Variabel </td><td>  Hiram </td><td>  A </td><td></td></tr><tr><td>  Penunjuk peta </td><td>  2 </td><td>  Animasi </td><td>  Pointer </td><td>  AnimStart + Dir * TMC + MpF * F # </td><td>  SM </td><td>  DE </td></tr><tr><td>  Buffer OAM </td><td>  2 </td><td>  Animasi </td><td>  Pointer </td><td>  Tumpukan1 </td><td>  Hl </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Mulai dari tabel animasi </td><td>  2 </td><td>  Daftar Animasi </td><td>  Ruang kerja </td><td>  Sulit diatur </td><td>  DE </td><td></td></tr><tr><td>  Sumber Obyek </td><td>  2 </td><td>  Daftar Animasi </td><td>  Pointer </td><td>  Hl </td><td>  Hl </td><td>  Tumpukan2 </td></tr><tr><td>  Nomor bingkai </td><td>  1 </td><td>  Daftar Animasi </td><td>  Variabel </td><td>  Sumber Obyek </td><td>  Hiram </td><td></td></tr><tr><td>  Nomor animasi </td><td>  1 </td><td>  Daftar Animasi </td><td>  Ruang kerja </td><td>  Sumber Obyek </td><td>  A </td><td></td></tr><tr><td>  Objek X </td><td>  1 </td><td>  Daftar benda </td><td>  Variabel </td><td>  Sumber Obyek </td><td>  Hiram </td><td></td></tr><tr><td>  Objek Y </td><td>  1 </td><td>  Daftar Animasi </td><td>  Variabel </td><td>  Sumber Obyek </td><td>  Hiram </td><td></td></tr><tr><td>  Arah Objek </td><td>  1 </td><td>  Daftar Animasi </td><td>  Variabel </td><td>  Obj src </td><td>  Hiram </td><td></td></tr><tr><td>  Mulai dari peta animasi </td><td>  2 </td><td>  Daftar Animasi </td><td>  Pointer </td><td>  [Tabel Animasi + Animasi #] </td><td>  SM </td><td></td></tr><tr><td>  Buffer OAM </td><td>  2 </td><td>  Daftar Animasi </td><td>  Pointer </td><td>  DE </td><td>  Tumpukan1 </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Sumber Obyek </td><td>  2 </td><td>  Siklus objek </td><td>  Plang </td><td>  Hard Set / Stack2 </td><td>  Hl </td><td></td></tr><tr><td>  Benda yang tersisa </td><td>  1 </td><td>  Siklus objek </td><td>  Variabel </td><td>  Dihitung </td><td>  B </td><td></td></tr><tr><td>  Bidang bit aktif suatu objek </td><td>  1 </td><td>  Siklus objek </td><td>  Variabel </td><td>  Dihitung </td><td>  C </td><td></td></tr><tr><td>  Buffer OAM </td><td>  2 </td><td>  Siklus objek </td><td>  Pointer </td><td>  Sulit diatur </td><td>  DE </td><td></td></tr></tbody></table><br>  Ya, sangat membingungkan.  Sejujurnya, saya membuat tabel ini hanya untuk posting, untuk menjelaskan lebih jelas, tetapi sudah mulai bermanfaat.  Saya akan mencoba menjelaskannya. Mari kita mulai dari akhir dan mulai dari awal.  Anda akan melihat setiap bagian data yang saya mulai dengan: sumber objek, buffer OAM, dan variabel loop yang dikomputasi.  Dalam setiap siklus, kita mulai dengan ini dan hanya ini, kecuali bahwa sumber objek diperbarui di setiap siklus. <br><br>  Untuk setiap objek yang kami render, perlu untuk menentukan animasi yang ditampilkan.  Sementara kita melakukan ini, kita juga dapat menyimpan atribut X, Y, Frame #, dan Direction sebelum menambahkan pointer objek ke objek berikutnya dan menyimpannya ke stack untuk mengambil kembali ketika keluar.  Kami menggunakan nomor animasi dalam kombinasi dengan tabel animasi yang dikodekan dalam kode untuk menentukan di mana peta animasi dimulai.  (Di sini saya menyederhanakan, dengan asumsi bahwa setiap objek memiliki tabel animasi yang sama. Ini membatasi saya untuk 256 animasi per game, tetapi saya tidak mungkin melebihi nilai ini.) Kami juga dapat menulis buffer OAM untuk menyimpan beberapa register. <br><br>  Setelah mengekstraksi peta animasi, kita perlu menemukan di mana daftar peta sprite untuk frame dan arah yang diberikan berada, serta berapa banyak peta yang perlu dirender.  Anda mungkin memperhatikan bahwa variabel kartu per bingkai tidak digunakan.  Itu terjadi karena saya tidak berpikir dan menetapkan nilai konstan 2. Saya harus memperbaikinya.  Kita juga perlu mengekstrak buffer OAM dari stack.  Anda juga mungkin melihat kurangnya kontrol siklus.  Hal ini dilakukan dalam sub-prosedur terpisah, jauh lebih sederhana, yang memungkinkan Anda untuk menyingkirkan juggling dengan register. <br><br>  Setelah itu, semuanya menjadi sangat sederhana.  Peta adalah sekelompok sprite, jadi kami memutarnya dalam satu lingkaran dan menggambar berdasarkan koordinat X dan Y yang disimpan. Namun, kami kembali menyimpan pointer OAM ke akhir daftar sprite sehingga peta berikutnya dimulai dari tempat kami selesai. <br><br>  Apa hasil akhir dari semua ini?  Persis sama seperti sebelumnya: rubah kutub melambaikan ekornya dalam gelap.  Tetapi menambahkan animasi atau sprite baru sekarang jauh lebih mudah.  Pada bagian selanjutnya, saya akan berbicara tentang latar belakang yang kompleks dan scroll paralaks. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/cc5/431/19fcc54315854aa3dd7eafcad60c7c38.png" alt="gambar"></div><br><h2>  Bagian 4. Latar Belakang Parallax </h2><br>  Biarkan saya mengingatkan Anda, pada tahap saat ini, kami memiliki animasi sprite pada latar belakang hitam pekat.  Jika saya tidak berencana membuat game arcade tahun 70-an, maka ini jelas tidak akan cukup.  Saya perlu semacam gambar latar belakang. <br><br>  Pada bagian pertama, ketika saya menggambar grafik, saya juga membuat beberapa ubin latar belakang.  Sudah saatnya menggunakannya.  Kami akan memiliki tiga jenis ubin "dasar" (langit, rumput, dan bumi) dan dua ubin transisi.  Semuanya dimuat ke dalam VRAM dan siap digunakan.  Sekarang kita hanya perlu menuliskannya di latar belakang. <br><br><h2>  Latar belakang </h2><br>  Latar belakang pada Game Boy disimpan dalam memori dalam array 32x32 8x8 ubin.  Setiap 32 byte sesuai dengan satu baris ubin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d4/f70/972/3d4f70972bfc10421deaf1d18809e4f6.png"></div><br>  Sejauh ini, saya berencana untuk mengulangi <em>kolom</em> ubin yang sama di seluruh ruang 32x32.  Ini hebat, tetapi ini menciptakan masalah kecil: Saya perlu mengatur <em>setiap</em> ubin 32 kali berturut-turut.  Ini akan menjadi waktu yang lama untuk menulis. <br><br>  Secara naluriah, saya memutuskan untuk menggunakan perintah REPT untuk menambahkan 32 byte / baris, dan kemudian menggunakan memcpy untuk menyalin latar belakang ke dalam VRAM. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">REPT</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> db BG_SKY ENDR REPT <span class="hljs-number"><span class="hljs-number">32</span></span> db BG_GRASS ENDR ...</code> </pre> <br>  Namun, ini berarti Anda harus mengalokasikan 256 byte hanya untuk satu latar belakang, yang cukup banyak.  Masalah ini diperburuk jika Anda ingat bahwa menyalin peta latar belakang yang dibuat sebelumnya dengan memcpy tidak akan memungkinkan Anda untuk menambahkan jenis kolom lainnya (misalnya, gerbang, hambatan) tanpa kerumitan yang signifikan dan tumpukan kartrid ROM yang terbuang. <br><br>  Jadi sebagai gantinya, saya memutuskan untuk membuat satu kolom sebagai berikut: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">db</span></span> BG_SKY, BG_SKY, BG_SKY, ..., BG_GRASS</code> </pre> <br>  dan kemudian gunakan loop sederhana untuk menyalin setiap item dalam daftar ini sebanyak 32 kali.  (lihat <a href=""><code> LoadGFX</code> file <code> LoadGFX</code> dari commit 739986a</a> .) <br><br>  Kemudahan dari pendekatan ini adalah nantinya saya dapat menambahkan antrian untuk menulis sesuatu seperti ini: <br><br><pre> <code class="hljs perl">BGCOL_Field: db BG_SKY, ... BGCOL_LeftGoal: db BG_SKY, ... BGCOL_RightGoal: db BG_SKY, ... ... BGMAP_overview: db <span class="hljs-number"><span class="hljs-number">1</span></span> dw BGCOL_LeftGoal db <span class="hljs-number"><span class="hljs-number">30</span></span> dw BGCOL_Field db <span class="hljs-number"><span class="hljs-number">1</span></span> dw BGCOL_RightGoal db $FF</code> </pre> <br>  Jika saya memutuskan untuk merender BGMAP_overview, maka itu akan menggambar 1 kolom LeftGoal, setelah itu akan ada 30 kolom Field dan 1 kolom RightGoal.  Jika <code>BGMAP_overview</code> menggunakan RAM, maka saya dapat mengubahnya dengan cepat tergantung pada posisi kamera di X. <br><br><h2>  Kamera dan posisi </h2><br>  Oh ya, kameranya.  Ini adalah konsep penting yang belum saya bicarakan.  Di sini kita berhadapan dengan banyak koordinat, jadi sebelum berbicara tentang kamera, pertama-tama kita akan menganalisis semua ini. <br><br>  Kita perlu bekerja dengan dua sistem koordinat.  Yang pertama adalah <em>koordinat layar</em> .  Ini adalah area 256x256 yang dapat dimuat dalam VRAM konsol Game Boy.  Kita dapat menggulir bagian layar yang terlihat dalam 256x256 ini, tetapi ketika kita melampaui batas, kita runtuh. <br><br>  Lebar, saya perlu lebih dari 256 piksel, jadi saya menambahkan <em>koordinat dunia</em> , yang dalam game ini akan memiliki dimensi 65536x256.  (Saya tidak perlu ketinggian ekstra dalam Y, karena permainan berlangsung di bidang datar.) Sistem ini benar-benar terpisah dari sistem koordinat layar.  Semua fisika dan tabrakan harus dilakukan dalam koordinat dunia, karena jika tidak, objek akan bertabrakan dengan objek di layar lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56c/557/fd6/56c557fd66ec77707c4083b6f38565f4.png"></div><br>  <i>Perbandingan layar dan koordinat dunia</i> <br><br>  Karena posisi semua objek direpresentasikan dalam koordinat dunia, mereka harus dikonversi menjadi koordinat layar sebelum rendering.  Di ujung paling kiri dunia, koordinat dunia bertepatan dengan koordinat layar.  Jika kita perlu menampilkan hal-hal di kanan di layar, maka kita perlu mengambil semua yang ada di koordinat dunia dan memindahkannya ke kiri sehingga mereka berada di koordinat layar. <br><br>  Untuk melakukan ini, kita akan mengatur variabel "kamera X", yang didefinisikan sebagai batas kiri layar di dunia.  Misalnya, jika <code>camera X</code> adalah 1000, maka kita dapat melihat koordinat dunia 1000-1192, karena layar yang terlihat memiliki lebar 192 piksel. <br><br>  Untuk memproses objek, kita cukup mengambil posisi mereka di X (misalnya, 1002), kurangi posisi kamera sama dengan 1000, dan gambar objek pada posisi yang diberikan oleh perbedaan (dalam kasus kami, 2).  Untuk latar belakang yang <em>tidak ada</em> dalam koordinat dunia, tetapi sudah dijelaskan dalam koordinat layar, kami mengatur posisi sama dengan byte bawah dari variabel <code>camera X</code> .  Berkat ini, latar belakang akan gulir ke kiri dan kanan dengan kamera. <br><br><h2>  Paralaks </h2><br>  Sistem yang kami buat terlihat agak datar.  Setiap lapisan latar belakang bergerak dengan kecepatan yang sama.  Itu tidak terasa tiga dimensi, dan kita perlu memperbaikinya. <br><br>  Cara sederhana untuk menambahkan simulasi 3D disebut parallax scrolling.  Bayangkan Anda mengemudi di jalan dan sangat lelah.  Game Boy telah kehabisan baterai dan Anda harus melihat keluar dari jendela mobil.  Jika Anda melihat tanah di sebelah Anda, Anda akan melihat.  bahwa dia bergerak dengan kecepatan 70 mil per jam.  Namun, jika Anda melihat bidang di kejauhan, tampaknya mereka bergerak jauh lebih lambat.  Dan jika Anda melihat gunung yang sangat jauh, mereka tampaknya hampir tidak bergerak. <br><br>  Kita dapat mensimulasikan efek ini dengan tiga lembar kertas.  Jika Anda menggambar barisan gunung pada satu lembar, bidang pada lembar kedua, dan jalan pada lembar ketiga, dan meletakkannya di atas satu sama lain seperti ini.  sehingga setiap lapisan terlihat, itu akan menjadi tiruan dari apa yang kita lihat dari jendela mobil.  Jika kita ingin memindahkan "mobil" ke kiri, maka kita memindahkan lembar paling atas (dengan jalan) jauh ke kanan, yang berikutnya sedikit ke kanan, dan yang terakhir sedikit ke kanan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4d/b52/691/d4db5269121565e6eda63ce5e240d96e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce4/c39/8db/ce4c398dbae155b1da618016c83d440f.png"></div><br>  Namun, ketika menerapkan sistem seperti itu di Game Boy, masalah kecil muncul.  Konsol hanya memiliki satu lapisan latar belakang.  Ini mirip dengan fakta bahwa kita hanya memiliki satu lembar kertas.  Anda tidak dapat membuat efek paralaks hanya dengan satu lembar kertas.  Atau mungkinkah? <br><br><h2>  B-kosong </h2><br>  Layar Game Boy diberikan baris demi baris.  Sebagai hasil dari meniru perilaku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TV CRT lama,</a> ada sedikit keterlambatan antara setiap baris.  Bagaimana jika kita bisa menggunakannya entah bagaimana?  Ternyata Game Boy memiliki interupsi perangkat keras khusus untuk tujuan ini. <br><br>  Mirip dengan interupsi VBlank, yang kami terus gunakan untuk menunggu sampai akhir frame untuk merekam dalam VRAM, ada interupsi HBlank.  Dengan mengatur bit 6 register pada <code>$FF41</code> , menyalakan interupsi <code>LCD STAT</code> , dan menulis nomor baris pada <code>$FF45</code> , kita bisa memberi tahu Game Boy untuk memulai interupsi <code>LCD STAT</code> ketika akan menarik garis yang ditentukan (dan ketika berada di HBlank-nya). <br><br>  Selama ini, kita dapat mengubah variabel VRAM.  Ini tidak <em>banyak</em> waktu, jadi kami tidak dapat mengubah lebih dari beberapa register, tetapi kami masih memiliki beberapa kemungkinan.  Kami ingin mengubah daftar gulir horizontal pada <code>$FF43</code> .  Dalam hal ini, semua yang ada di layar di bawah garis yang ditentukan akan bergerak dengan jumlah shift tertentu, menciptakan efek paralaks. <br><br>  Jika Anda kembali ke contoh gunung, Anda dapat melihat masalah potensial.  Gunung, awan, dan bunga bukanlah garis datar!  Kami tidak dapat memindahkan garis yang dipilih ke atas dan ke bawah selama proses rendering;  jika kita memilihnya, maka itu tetap sama setidaknya sampai HBlank berikutnya.  Artinya, kita hanya bisa memotong garis lurus. <br><br>  Untuk mengatasi masalah ini, kita harus melakukan sedikit lebih pintar.  Kami dapat mendeklarasikan beberapa garis di latar belakang sebagai garis yang tidak dapat dilewati siapa pun, yang berarti mengubah mode objek di atas dan di bawahnya, dan pemain tidak akan dapat melihat apa pun.  Misalnya, di sinilah garis-garis ini berada dalam adegan dengan gunung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f3/371/46a/7f337146a97de76d1c7647ec0d0d78db.png"></div><br>  Di sini saya membuat irisan tepat di atas dan di bawah gunung.  Segala sesuatu dari atas ke baris pertama bergerak lambat, semuanya ke baris kedua bergerak dengan kecepatan rata-rata, dan semua yang di bawah garis ini bergerak cepat.  Ini adalah trik sederhana namun cerdas.  Dan mempelajarinya, Anda bisa melihatnya di banyak game retro, terutama untuk Genesis / Mega Drive, tetapi juga di konsol lain.  Salah satu contoh yang paling jelas adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian dari gua</a> dari Mickey Mania.  Anda dapat melihat bahwa stalagmit dan stalaktit di latar belakang dipisahkan <em>persis</em> sepanjang garis horizontal dengan batas hitam yang jelas di antara lapisan. <br><br>  Saya menyadari hal yang sama di latar belakang saya.  Namun, ada satu trik.  Misalkan latar depan bergerak dengan kecepatan satu lawan satu bersamaan dengan pergerakan kamera, dan kecepatan latar belakang adalah sepertiga dari pergerakan piksel kamera, yaitu latar belakang bergerak seperti sepertiga latar depan.  Tapi, tentu saja, sepertiga dari piksel tidak ada.  Oleh karena itu, saya perlu memindahkan latar belakang satu piksel untuk setiap tiga piksel gerakan. <br><br>  Jika Anda bekerja dengan komputer yang mampu perhitungan matematis, Anda akan mengambil posisi kamera, membaginya dengan 3 dan menjadikan nilai ini sebagai pengimbang latar belakang.  Sayangnya, Game Boy tidak mampu melakukan pembagian, belum lagi fakta bahwa pembagian program adalah proses yang sangat lambat dan menyakitkan.  Menambahkan perangkat untuk membagi (atau mengalikan) ke CPU yang lemah untuk konsol hiburan portabel di tahun 80-an sepertinya bukan langkah yang hemat biaya, jadi kami harus menemukan cara lain. <br><br>  Dalam kode tersebut, saya melakukan hal berikut: alih-alih membaca posisi kamera dari suatu variabel, saya menuntutnya untuk menambah atau mengurangi.  Berkat ini, dengan setiap kenaikan ketiga, saya dapat melakukan peningkatan posisi latar belakang, dan dengan setiap kenaikan pertama - peningkatan posisi latar depan.  Ini menyulitkan sedikit pengguliran ke posisi dari ujung bidang yang lain (cara termudah adalah dengan hanya mengatur ulang posisi lapisan setelah transisi tertentu), tetapi menyelamatkan kita dari kebutuhan untuk membagi. <br><br><h2>  Hasil </h2><br>  Setelah <em>semua ini,</em> saya mendapat yang berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47d/f64/3a2/47df643a2bd620cf8899b3601162748b.gif"></div><br>  Untuk game di Game Boy, ini sebenarnya cukup keren.  Sejauh yang saya tahu, tidak semua dari mereka memiliki paralaks yang diimplementasikan seperti ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436918/">https://habr.com/ru/post/id436918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436908/index.html">6 cara untuk menyembunyikan data di aplikasi Android</a></li>
<li><a href="../id436910/index.html">Kiat untuk membuat alur kerja khusus di GitLab CI</a></li>
<li><a href="../id436912/index.html">2019 Tren CRM: menyenangkan untuk dibaca, berbahaya untuk dipercaya</a></li>
<li><a href="../id436914/index.html">Masalah Pertumbuhan Startup - Pemantauan</a></li>
<li><a href="../id436916/index.html">VShard - penskalaan horizontal di Tarantool</a></li>
<li><a href="../id436920/index.html">Transpiler PAS2JS dari Pascal ke JavaScript: tidak kompatibel dengan Delphi dan solusi</a></li>
<li><a href="../id436922/index.html">Mengoptimalkan waktu startup Prometheus 2.6.0 dengan pprof</a></li>
<li><a href="../id436924/index.html">Beberapa kata tentang organisasi kompetisi robot</a></li>
<li><a href="../id436926/index.html">Pahlawan autentikasi dua faktor, atau cara "berjalan di posisi orang lain"</a></li>
<li><a href="../id436928/index.html">WebRTC - lebih mudah (EasyRTC)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>