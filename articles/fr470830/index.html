<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí± üî≤ üò∏ Async / wait en C #: concept, design interne, astuces utiles ü§òüèø üêó üíê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour. Cette fois, nous allons parler d'un sujet que tous les adeptes qui se respectent du langage C # ont commenc√© √† comprendre - la programmation ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Async / wait en C #: concept, design interne, astuces utiles</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470830/">  Bonjour.  Cette fois, nous allons parler d'un sujet que tous les adeptes qui se respectent du langage C # ont commenc√© √† comprendre - la programmation asynchrone √† l'aide de Task ou, chez les gens ordinaires, async / wait.  Microsoft a fait du bon travail - pour utiliser l'asynchronie dans la plupart des cas, il suffit de conna√Ætre la syntaxe et aucun autre d√©tail.  Mais si vous allez en profondeur, le sujet est assez volumineux et complexe.  Il a √©t√© d√©clar√© par beaucoup, chacun dans son propre style.  Il y a beaucoup d'articles sympas sur ce sujet, mais il y a encore beaucoup d'id√©es fausses autour de lui.  Nous essaierons de corriger la situation et de m√¢cher le mat√©riel autant que possible, sans sacrifier ni la profondeur ni la compr√©hension. <br><br><img src="https://habrastorage.org/webt/zn/or/r1/znorr1o7rsk1tzudgdrmgchrss4.jpeg"><br><a name="habracut"></a><br>  Sujets / chapitres couverts: <br><br><ol><li> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le concept d'asynchronie</a></b> - les avantages de l'asynchronie et les mythes sur un thread "bloqu√©" </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TAP.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Syntaxe et conditions de compilation</a></b> - pr√©requis pour √©crire une m√©thode de compilation </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travailler avec l'utilisation de TAP</a></b> - la m√©canique et le comportement du programme en code asynchrone (lib√©rer des threads, d√©marrer des t√¢ches et attendre qu'elles se terminent) </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dans les coulisses: la machine √† √©tats</a></b> - un aper√ßu des transformations du compilateur et des classes qu'il g√©n√®re </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les origines de l'asynchronie.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le dispositif des m√©thodes asynchrones standard</a></b> - <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m√©thodes</a></b> asynchrones pour travailler avec les fichiers et le r√©seau de l'int√©rieur </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les classes et astuces TAP</a></b> sont des astuces utiles qui peuvent vous aider √† g√©rer et √† acc√©l√©rer un programme √† l'aide de TAP </li></ol><a name="conception"></a><br><h2>  Concept asynchrone </h2><br>  L'asynchronie en soi est loin d'√™tre nouvelle.  L'asynchronie implique g√©n√©ralement l'ex√©cution d'une op√©ration dans un style qui n'implique pas le blocage du thread appelant, c'est-√†-dire le d√©marrage de l'op√©ration sans attendre sa fin.  Le blocage n'est pas aussi mauvais qu'il est d√©crit.  On peut rencontrer des affirmations selon lesquelles les threads bloqu√©s perdent du temps CPU, fonctionnent plus lentement et provoquent la pluie.  Cette derni√®re semble-t-elle peu probable?  En fait, les 2 points pr√©c√©dents sont les m√™mes. <br><br>  Au niveau du planificateur du syst√®me d'exploitation, lorsqu'un thread est dans un √©tat ¬´bloqu√©¬ª, un temps processeur pr√©cieux ne lui sera pas allou√©.  Les appels du planificateur tombent g√©n√©ralement sur des op√©rations qui provoquent des blocages, des interruptions de temporisation et d'autres interruptions.  Autrement dit, lorsque, par exemple, le contr√¥leur de disque termine l'op√©ration de lecture et lance une interruption appropri√©e, le planificateur d√©marre.  Il d√©cidera de d√©marrer un thread qui a √©t√© bloqu√© par cette op√©ration, ou un autre avec une priorit√© plus √©lev√©e. <br><br>  Un travail lent semble encore plus absurde.  En effet, en fait, le travail est le m√™me.  Seule l'op√©ration asynchrone ajoutera un peu plus de surcharge. <br><br>  Le d√©fi de la pluie n'est g√©n√©ralement pas quelque chose de cette r√©gion. <br><br>  Le principal probl√®me de blocage est la consommation d√©raisonnable de ressources informatiques.  M√™me si nous oublions le temps de cr√©er un thread et de travailler avec un pool de threads, chaque thread bloqu√© consomme plus d'espace.  Eh bien, il existe des sc√©narios o√π un seul thread peut effectuer certains travaux (par exemple, un thread d'interface utilisateur).  En cons√©quence, je ne voudrais pas qu'il soit occup√© par une t√¢che qu'un autre thread peut effectuer, sacrifiant la performance des op√©rations qui lui sont exclusives. <br><br>  L'asynchronie est un concept tr√®s large et peut √™tre r√©alis√© de plusieurs mani√®res. <br>  <b>Les √©l√©ments suivants peuvent √™tre distingu√©s dans l'histoire de .NET</b> : <br><br><ol><li>  EAP (Event-based Asynchronous Pattern) - comme son nom l'indique, la randonn√©e est bas√©e sur les √©v√©nements qui se d√©clenchent lorsque l'op√©ration est termin√©e et la m√©thode habituelle qui appelle cette op√©ration </li><li>  APM (mod√®le de programmation asynchrone) - bas√© sur 2 m√©thodes.  La m√©thode BeginSmth renvoie l'interface IAsyncResult.  La m√©thode EndSmth accepte IAsyncResult (si l'op√©ration n'est pas termin√©e au moment de l'appel EndSmth, le thread est bloqu√©) </li><li>  TAP (Task-based Asynchronous Pattern) est le m√™me asynchrone / wait (√† proprement parler, ces mots sont apparus apr√®s l'approche et les types Task et Task &lt;TResult&gt; sont apparus, mais async / wait a consid√©rablement am√©lior√© ce concept) </li></ol><br>  Cette derni√®re approche a connu un tel succ√®s que tout le monde a r√©ussi √† oublier les pr√©c√©dentes.  Donc, ce sera √† propos de lui. <br><a name="tap_syntax"></a><br><h2>  Mod√®le asynchrone bas√© sur les t√¢ches.  Conditions de syntaxe et de compilation </h2><br>  La m√©thode asynchrone standard de style TAP est tr√®s facile √† √©crire. <br><br>  <b>Pour ce faire, vous avez besoin de</b> : <br><br><ol><li>  Pour que la valeur de retour soit Task, Task &lt;T&gt; ou void (non recommand√©, discut√© plus tard).  En C # 7 sont venus les types de t√¢ches (discut√©s dans le dernier chapitre).  En C # 8, IAsyncEnumerable &lt;T&gt; et IAsyncEnumerator &lt;T&gt; sont ajout√©s √† cette liste. </li><li>  Pour que la m√©thode soit marqu√©e avec le mot-cl√© async et contienne wait inside.  Ces mots cl√©s sont associ√©s.  De plus, si la m√©thode contient wait, assurez-vous de la marquer comme asynchrone, l'inverse n'est pas vrai, mais c'est inutile </li><li>  Pour la d√©cence, respectez la convention de suffixe Async.  Bien s√ªr, le compilateur ne consid√©rera pas cela comme une erreur.  Si vous √™tes un d√©veloppeur tr√®s d√©cent, vous pouvez ajouter des surcharges avec un CancellationToken (discut√© dans le dernier chapitre) </li></ol><br>  Pour de telles m√©thodes, le compilateur fait un travail s√©rieux.  Et ils deviennent compl√®tement m√©connaissables dans les coulisses, mais plus √† ce sujet plus tard. <br><br>  Il a √©t√© mentionn√© que la m√©thode devrait contenir le mot-cl√© wait.  Il (le mot) indique la n√©cessit√© d'une attente asynchrone pour l'ex√©cution de la t√¢che, qui est l'objet de t√¢che auquel elle est appliqu√©e. <br><br>  <b>L'objet de t√¢che a √©galement certaines conditions pour que l'attente puisse lui √™tre appliqu√©e:</b> <br><br><ol><li>  Le type attendu doit avoir une m√©thode GetAwaiter () publique (ou interne), il peut √©galement s'agir d'une m√©thode d'extension.  Cette m√©thode renvoie un objet d'attente. </li><li>  L'objet wait doit impl√©menter l'interface INotifyCompletion, qui n√©cessite l'impl√©mentation de la m√©thode void OnCompleted (Action continuation).  Il doit √©galement avoir la propri√©t√© d'instance bool IsCompleted, la m√©thode void GetResult ().  Il peut s'agir d'une structure ou d'une classe. </li></ol><br>  L'exemple ci-dessous montre comment rendre un int attendu et m√™me jamais ex√©cut√©. <br><br><div class="spoiler">  <b class="spoiler_title">Extension int</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WeirdExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AnyTypeAwaiter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAwaiter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnyTypeAwaiter(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AnyTypeAwaiter</span></span> : <span class="hljs-title"><span class="hljs-title">INotifyCompletion</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCompleted =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCompleted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action continuation</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } }</code> </pre> <br></div></div><br><a name="tap_progr"></a><br><h2>  Travailler avec TAP </h2><br>  Il est difficile d'entrer dans la jungle sans comprendre comment quelque chose devrait fonctionner.  Consid√©rez TAP en termes de comportement du programme. <br><br>  En terminologie: la m√©thode asynchrone en question, dont le code sera consid√©r√©, j'appellerai la <b>m√©thode asynchrone</b> , et les m√©thodes asynchrones appel√©es √† l'int√©rieur, j'appellerai l' <b>op√©ration asynchrone</b> . <br><br>  Prenons l'exemple le plus simple, en tant qu'op√©ration asynchrone, nous prenons Task.Delay, qui retarde pendant le temps sp√©cifi√© sans bloquer le flux. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DelayOperationAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//   { BeforeCall(); Task task = Task.Delay(1000); //  AfterCall(); await task; AfterAwait(); }</span></span></span></span></code> </pre><br>  L'ex√©cution de la m√©thode en termes de comportement est la suivante. <br><br><ol><li>  Tout le code qui pr√©c√®de l'invocation de l'op√©ration asynchrone est ex√©cut√©.  Dans ce cas, il s'agit de la m√©thode <i>BeforeCall</i> </li><li>  Un appel d'op√©ration asynchrone est en cours.  √Ä ce stade, le thread n'est ni lib√©r√© ni bloqu√©.  Cette op√©ration renvoie le r√©sultat - l'objet de t√¢che mentionn√© (g√©n√©ralement Task), qui est stock√© dans une variable locale </li><li>  Le code est ex√©cut√© apr√®s avoir appel√© l'op√©ration asynchrone, mais avant d'attendre (attendre).  Dans l'exemple - <i>AfterCall</i> </li><li>  En attente de fin sur l'objet de t√¢che (qui est stock√© dans une variable locale) - attendre la t√¢che. <br><br>  Si l'op√©ration asynchrone est termin√©e √† ce stade, l'ex√©cution continue de mani√®re synchrone, dans le m√™me thread. <br><br>  Si l'op√©ration asynchrone n'est pas termin√©e, le code est enregistr√© qui doit √™tre appel√© √† la fin de l'op√©ration asynchrone (la soi-disant continuation), et le flux retourne au pool de threads et devient disponible pour utilisation. </li><li>  L'ex√©cution des op√©rations apr√®s l'attente - <i>AfterAwait</i> - est effectu√©e soit imm√©diatement, dans le m√™me thread, lorsque l'op√©ration au moment de l'attente a √©t√© termin√©e, soit, √† la fin de l'op√©ration, un nouveau thread est pris qui continuera (enregistr√© √† l'√©tape pr√©c√©dente) </li></ol><br><a name="internals"></a><br><h2>  Dans les coulisses.  Machine d'√©tat </h2><br>  En fait, notre m√©thode est transform√©e par le compilateur en une m√©thode stub dans laquelle la classe g√©n√©r√©e - la machine d'√©tat - est initialis√©e.  Ensuite, il (la machine) d√©marre et l'objet Task utilis√© √† l'√©tape 2 est renvoy√© par la m√©thode. <br><br>  La m√©thode <i>MoveNext de</i> la machine √† √©tats est particuli√®rement int√©ressante.  Cette m√©thode fait ce qu'elle √©tait avant la conversion dans la m√©thode asynchrone.  Il casse le code entre chaque appel en attente.  Chaque partie est r√©alis√©e dans un certain √©tat de la machine.  La m√©thode <i>MoveNext</i> elle-m√™me est attach√©e √† l'objet d'attente en tant que continuation.  La pr√©servation de l'√âtat garantit l'ex√©cution de la partie de celui-ci qui a logiquement suivi l'attente. <br><br>  Comme on dit, il vaut mieux voir 1 fois que d'entendre 100 fois, donc je vous recommande fortement de vous familiariser avec l'exemple ci-dessous.  J'ai r√©√©crit un peu le code, am√©lior√© le nommage des variables et comment√© g√©n√©reusement. <br><br><div class="spoiler">  <b class="spoiler_title">Code source</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delays</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">M√©thode du talon</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AsyncStateMachine(typeof(DelaysStateMachine))</span></span>] [DebuggerStepThrough] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delays</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DelaysStateMachine stateMachine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DelaysStateMachine(); stateMachine.taskMethodBuilder = AsyncTaskMethodBuilder.Create(); stateMachine.currentState = <span class="hljs-number"><span class="hljs-number">-1</span></span>; AsyncTaskMethodBuilder builder = stateMachine.taskMethodBuilder; taskMethodBuilder.Start(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> stateMachine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stateMachine.taskMethodBuilder.Task; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Machine d'√©tat</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DelaysStateMachine</span></span> : <span class="hljs-title"><span class="hljs-title">IAsyncStateMachine</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     await   //       await'a public int currentState; public AsyncTaskMethodBuilder taskMethodBuilder; //   private TaskAwaiter taskAwaiter; //  ,             ""  public int paramInt; private int localInt; private void MoveNext() { int num = currentState; try { TaskAwaiter awaiter5; TaskAwaiter awaiter4; TaskAwaiter awaiter3; TaskAwaiter awaiter2; TaskAwaiter awaiter; switch (num) { default: localInt = paramInt; //  await Console.WriteLine(1); //  await awaiter5 = Task.Delay(1000).GetAwaiter(); //  await if (!awaiter5.IsCompleted) //  await. ,    { num = (currentState = 0); // ,      taskAwaiter = awaiter5; //    ,        DelaysStateMachine stateMachine = this; //    taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter5, ref stateMachine); //                 return; } goto Il_AfterFirstAwait; //  ,   ,    case 0: //            ,        .   ,          awaiter5 = taskAwaiter; //   taskAwaiter = default(TaskAwaiter); //   num = (currentState = -1); //  goto Il_AfterFirstAwait; //       case 1: //  ,      ,    ,     . awaiter4 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterSecondAwait; case 2: // ,     . awaiter3 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterThirdAwait; case 3: //    awaiter2 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterFourthAwait; case 4: //    { awaiter = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); break; } Il_AfterFourthAwait: awaiter2.GetResult(); Console.WriteLine(5); //     awaiter = Task.Delay(1000).GetAwaiter(); //   if (!awaiter.IsCompleted) { num = (currentState = 4); taskAwaiter = awaiter; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine); return; } break; Il_AfterFirstAwait: //  ,        awaiter5.GetResult(); //       Console.WriteLine(2); //  ,     await awaiter4 = Task.Delay(1000).GetAwaiter(); //    if (!awaiter4.IsCompleted) { num = (currentState = 1); taskAwaiter = awaiter4; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter4, ref stateMachine); return; } goto Il_AfterSecondAwait; Il_AfterThirdAwait: awaiter3.GetResult(); Console.WriteLine(4); //     awaiter2 = Task.Delay(1000).GetAwaiter(); //   if (!awaiter2.IsCompleted) { num = (currentState = 3); taskAwaiter = awaiter2; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter2, ref stateMachine); return; } goto Il_AfterFourthAwait; Il_AfterSecondAwait: awaiter4.GetResult(); Console.WriteLine(3); //     awaiter3 = Task.Delay(1000).GetAwaiter(); //   if (!awaiter3.IsCompleted) { num = (currentState = 2); taskAwaiter = awaiter3; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter3, ref stateMachine); return; } goto Il_AfterThirdAwait; } awaiter.GetResult(); } catch (Exception exception) { currentState = -2; taskMethodBuilder.SetException(exception); return; } currentState = -2; taskMethodBuilder.SetResult(); //    ,   ,       } void IAsyncStateMachine.MoveNext() {...} [DebuggerHidden] private void SetStateMachine(IAsyncStateMachine stateMachine) {...} void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine) {...} }</span></span></code> </pre><br></div></div><br>  Je me concentre sur la phrase "√† ce stade n'a pas √©t√© ex√©cut√© de mani√®re synchrone."  Une op√©ration asynchrone peut √©galement suivre un chemin d'ex√©cution synchrone.  La condition principale pour que la m√©thode asynchrone actuelle soit ex√©cut√©e de mani√®re synchrone, c'est-√†-dire sans changer le thread, est la fin de l'op√©ration asynchrone au moment de la v√©rification <i>IsCompleted</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Cet exemple illustre clairement ce comportement.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-comment"><span class="hljs-comment">//1 Task task = Task.Delay(1000); Thread.Sleep(1700); await task; Console.WriteLine(Thread.CurrentThread.ManagedThreadId); //1 }</span></span></code> </pre><br></div></div><br>  √Ä propos du contexte de synchronisation.  La m√©thode <i>AwaitUnsafeOnCompleted</i> utilis√©e dans la machine aboutit finalement √† un appel √† la m√©thode <i>Task.SetContinuationForAwait</i> .  Dans cette m√©thode, le contexte de synchronisation actuel <i>SynchronizationContext.Current</i> est r√©cup√©r√©.  Le contexte de synchronisation peut √™tre interpr√©t√© comme un type de flux.  S'il est √©galement sp√©cifique (par exemple, le contexte du thread d'interface utilisateur), une continuation est cr√©√©e √† l'aide de la classe <i>SynchronizationContextAwaitTaskContinuation</i> .  Cette classe pour d√©marrer la continuation appelle la m√©thode Post sur le contexte enregistr√©, ce qui garantit que la continuation est ex√©cut√©e dans le contexte exact o√π la m√©thode a √©t√© ex√©cut√©e.  La logique sp√©cifique pour ex√©cuter la continuation d√©pend de la m√©thode <i>Post</i> dans un contexte qui, pour le dire l√©g√®rement, n'est pas connu pour la vitesse.  S'il n'y avait pas de contexte de synchronisation (ou s'il a √©t√© indiqu√© que peu importe pour nous dans quel contexte l'ex√©cution continuera √† l'aide de ConfigureAwait (false), ce qui sera discut√© dans le dernier chapitre), la poursuite sera effectu√©e par le thread du pool. <br><a name="libs"></a><br><h2>  Les origines de l'asynchronie.  Les m√©thodes asynchrones standard de l'appareil </h2><br>  Nous avons examin√© comment une m√©thode utilisant asynchrone et attend les regards et ce qui se passe dans les coulisses.  Cette information n'est pas rare.  Mais il est important de comprendre la nature des op√©rations asynchrones.  Parce que, comme nous l'avons vu dans la machine √† √©tats, les op√©rations asynchrones sont appel√©es dans le code, √† moins que leur r√©sultat ne soit trait√© de mani√®re plus astucieuse.  Cependant, que se passe-t-il √† l'int√©rieur des op√©rations asynchrones elles-m√™mes?  Probablement la m√™me chose, mais cela ne peut pas se produire √† l'infini. <br><br>  Une t√¢che importante consiste √† comprendre la nature de l'asynchronie.  Quand on essaie de comprendre l'asynchronie, il y a une alternance d'√©tats "maintenant clair" et "maintenant encore incompr√©hensible".  Et cette alternance se fera jusqu'√† ce que la source de l'asynchronie soit comprise. <br><br>  Lorsque nous travaillons avec l'asynchronie, nous op√©rons sur des t√¢ches.  Ce n'est pas du tout la m√™me chose qu'un flux.  Une t√¢che peut √™tre effectu√©e par plusieurs threads et un thread peut effectuer de nombreuses t√¢ches. <br><br>  Asynchrony commence g√©n√©ralement par une m√©thode qui retourne Task (par exemple), mais n'est pas √©tiquet√©e avec async et n'utilise donc pas wait inside.  Cette m√©thode ne tol√®re aucune modification du compilateur; elle est ex√©cut√©e telle quelle. <br><br>  <b>Alors, regardons quelques-unes des racines de l'asynchronie.</b> <br><br><ol><li>  Task.Run, new Task (..). Start (), Factory.StartNew et similaires.  La fa√ßon la plus simple de d√©marrer l'ex√©cution asynchrone.  Ces m√©thodes cr√©ent simplement un nouvel objet de t√¢che, en passant un d√©l√©gu√© comme l'un des param√®tres.  La t√¢che est transf√©r√©e au planificateur, ce qui lui permet d'√™tre ex√©cut√©e par l'un des threads du pool.  La t√¢che termin√©e attendue est renvoy√©e.  En r√®gle g√©n√©rale, cette approche est utilis√©e pour d√©marrer le calcul (li√© au processeur) dans un thread s√©par√©. </li><li>  TaskCompletionSource.  Une classe d'assistance qui permet de contr√¥ler l'objet de t√¢che.  Con√ßu pour ceux qui ne peuvent pas affecter un d√©l√©gu√© √† la mise en ≈ìuvre et utilise des m√©canismes plus sophistiqu√©s pour contr√¥ler l'ach√®vement.  Il poss√®de une API tr√®s simple - SetResult, SetError, etc., qui met √† jour la t√¢che en cons√©quence.  Cette t√¢che est disponible via la propri√©t√© Task.  Peut-√™tre qu'√† l'int√©rieur, vous cr√©erez des discussions, aurez une logique complexe pour leur interaction ou leur ach√®vement par √©v√©nement.  Un peu plus de d√©tails sur cette classe seront dans la derni√®re section. </li></ol><br>  Dans un paragraphe suppl√©mentaire, vous pouvez faire les m√©thodes des biblioth√®ques standard.  Il s'agit notamment de lire / √©crire des fichiers, de travailler avec un r√©seau, etc.  En r√®gle g√©n√©rale, ces m√©thodes populaires et courantes utilisent des appels syst√®me qui varient sur diff√©rentes plates-formes, et leur appareil est extr√™mement divertissant.  Pensez √† travailler avec des fichiers et le r√©seau. <br><br><h3>  Fichiers </h3><br>  Remarque importante - si vous souhaitez travailler avec des fichiers, vous devez sp√©cifier useAsync = true lors de la cr√©ation de FileStream. <br><br>  Tout est organis√© dans des fichiers de mani√®re non triviale et d√©routante.  La classe FileStream est d√©clar√©e comme partielle.  Et en plus, il existe 6 modules compl√©mentaires sp√©cifiques √† la plate-forme.  Ainsi, sous Unix, l'acc√®s asynchrone √† un fichier arbitraire, en r√®gle g√©n√©rale, utilise une op√©ration synchrone dans un thread s√©par√©.  Dans Windows, il existe des appels syst√®me pour un fonctionnement asynchrone, qui, bien s√ªr, sont utilis√©s.  Cela conduit √† des diff√©rences de travail sur diff√©rentes plates-formes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources</a> . <br><br>  <b>Unix</b> <br><br>  Le comportement standard lors de l'√©criture ou de la lecture consiste √† effectuer l'op√©ration de mani√®re synchrone, si le tampon le permet et que le flux n'est pas occup√© par une autre op√©ration: <br><br>  1. Le flux n'est pas occup√© par une autre op√©ration <br><br>  La classe Filestream poss√®de un objet h√©rit√© de SemaphoreSlim avec les param√®tres (1, 1) - c'est-√†-dire une section critique - le fragment de code prot√©g√© par ce s√©maphore ne peut √™tre ex√©cut√© que par un seul thread √† la fois.  Ce s√©maphore est utilis√© √† la fois pour la lecture et l'√©criture.  Autrement dit, il est impossible de produire simultan√©ment la lecture et l'√©criture.  Dans ce cas, le blocage sur le s√©maphore ne se produit pas.  La m√©thode this._asyncState.WaitAsync () est appel√©e dessus, ce qui retourne l'objet de t√¢che (il n'y a pas de verrou ou d'attente, ce serait le cas si le mot-cl√© attendait √©tait appliqu√© au r√©sultat de la m√©thode).  Si cet objet de t√¢che n'est pas termin√©, c'est-√†-dire que le s√©maphore est captur√©, la continuation (Task.ContinueWith) dans laquelle l'op√©ration est effectu√©e est attach√©e √† l'objet d'attente renvoy√©.  Si l'objet est libre, vous devez v√©rifier les √©l√©ments suivants <br><br>  2. Le tampon permet <br><br>  Ici, le comportement d√©pend d√©j√† de la nature de l'op√©ration. <br><br>  Pour l'enregistrement - il est v√©rifi√© que la taille des donn√©es pour l'√©criture + la position dans le fichier est inf√©rieure √† la taille du tampon, qui par d√©faut est de 4096 octets.  Autrement dit, nous devons √©crire 4096 octets depuis le d√©but, 2048 octets avec un d√©calage de 2048, et ainsi de suite.  Si tel est le cas, l'op√©ration est effectu√©e de mani√®re synchrone, sinon la continuation est attach√©e (Task.ContinueWith).  La suite utilise un appel syst√®me synchrone r√©gulier.  Lorsque le tampon est plein, il est √©crit sur le disque de mani√®re synchrone. <br>  Pour la lecture - il est v√©rifi√© s'il y a suffisamment de donn√©es dans le tampon afin de renvoyer toutes les donn√©es n√©cessaires.  Sinon, alors, encore une fois, une continuation (Task.ContinueWith) avec un appel syst√®me synchrone. <br><br>  Au fait, il y a un d√©tail int√©ressant.  Si une donn√©e occupe la totalit√© du tampon, elles seront √©crites directement dans le fichier, sans la participation du tampon.  Dans le m√™me temps, il y a une situation o√π il y aura plus de donn√©es que la taille de la m√©moire tampon, mais elles passeront toutes par elle.  Cela se produit s'il y a d√©j√† quelque chose dans le tampon.  Ensuite, nos donn√©es seront divis√©es en 2 parties, l'une remplira le tampon jusqu'√† la fin et les donn√©es seront √©crites dans le fichier, la seconde sera √©crite dans le tampon si elle y p√©n√®tre ou directement dans le fichier si ce n'est pas le cas.  Donc, si nous cr√©ons un flux et y √©crivons 4097 octets, ils appara√Ætront imm√©diatement dans le fichier, sans appeler Dispose.  Si nous √©crivons 4095, alors rien ne sera dans le fichier. <br><br>  <b>Windows</b> <br><br>  Sous Windows, l'algorithme pour utiliser le tampon et √©crire directement est tr√®s similaire.  Mais une diff√©rence significative est observ√©e directement dans les appels d'√©criture et de lecture du syst√®me asynchrone.  Parlant sans approfondir les appels syst√®me, il existe une telle structure chevauch√©e.  Il a un domaine important pour nous - HANDLE hEvent.  Il s'agit d'un √©v√©nement de r√©initialisation manuelle qui passe en √©tat d'alarme √† la fin d'une op√©ration.  Retour √† l'impl√©mentation.  L'√©criture directe, ainsi que l'√©criture dans le tampon, utilise des appels syst√®me asynchrones, qui utilisent la structure ci-dessus comme param√®tre.  Lors de l'enregistrement, un objet FileStreamCompletionSource est cr√©√© - un h√©ritier de TaskCompletionSource, dans lequel IOCallback est sp√©cifi√©.  Il est appel√© par le thread libre du pool une fois l'op√©ration termin√©e.  Dans le rappel, la structure chevauch√©e est analys√©e et l'objet Task est mis √† jour en cons√©quence.  C‚Äôest de la magie. <br><br><h3>  R√©seau </h3><br>  Il est difficile de d√©crire tout ce que j'ai vu comprendre la source.  Mon chemin √©tait de HttpClient √† Socket et √† SocketAsyncContext pour Unix.  Le sch√©ma g√©n√©ral est le m√™me que pour les fichiers.  Pour Windows, la structure chevauch√©e mentionn√©e est utilis√©e et l'op√©ration est effectu√©e de mani√®re asynchrone.  Sous Unix, les op√©rations r√©seau utilisent √©galement des fonctions de rappel. <br><br>  Et une petite explication.  Un lecteur attentif remarquera que lors de l'utilisation d'appels asynchrones entre un appel et un rappel, il existe un certain vide qui fonctionne d'une mani√®re ou d'une autre avec les donn√©es.  Ici, il vaut la peine d'√™tre clarifi√© pour √™tre complet.  Sur l'exemple des fichiers, le contr√¥leur de disque effectue des op√©rations directes avec le disque par le contr√¥leur de disque, c'est lui qui donne les signaux de d√©placement des t√™tes vers le secteur souhait√©, etc.  Le processeur est libre pour le moment.  La communication avec le disque s'effectue via les ports d'entr√©e / sortie.  Ils indiquent le type d'op√©ration, l'emplacement des donn√©es sur le disque, etc.  Ensuite, le contr√¥leur et le disque sont engag√©s dans cette op√©ration et √† la fin du travail, ils g√©n√®rent une interruption.  En cons√©quence, un appel syst√®me asynchrone fournit uniquement des informations aux ports d'entr√©e / sortie, tandis que l'appel synchrone attend √©galement les r√©sultats, mettant le flux dans un √©tat de blocage.  Ce sch√©ma ne pr√©tend pas √™tre absolument exact (pas √† propos de cet article), mais donne une compr√©hension conceptuelle du travail. <br><br>  Maintenant, la nature du processus est claire.  Mais quelqu'un peut demander, que faire de l'asynchronie?  Il est impossible d'√©crire asynchrone sur une m√©thode pour toujours. <br><br>  Tout d'abord.  Une demande peut √™tre faite en tant que service.  Dans ce cas, le point d'entr√©e - Principal - est √©crit √† partir de z√©ro par vous.  Jusqu'√† r√©cemment, Main ne pouvait pas √™tre asynchrone; dans la version 7 de la langue, cette fonctionnalit√© a √©t√© ajout√©e.  Mais cela ne change rien radicalement, juste le compilateur g√©n√®re le Main habituel, et √† partir de la m√©thode asynchrone, une m√©thode statique est cr√©√©e, qui est appel√©e dans Main et son ach√®vement est attendu de mani√®re synchrone.  Donc, tr√®s probablement, vous avez des actions de longue dur√©e.  Pour une raison quelconque, en ce moment, beaucoup de gens commencent √† r√©fl√©chir √† la fa√ßon de cr√©er des threads pour cette entreprise: via Task, ThreadPool ou Thread en g√©n√©ral manuellement, car il devrait y avoir une diff√©rence dans quelque chose.  La r√©ponse est simple - bien s√ªr Task.  Si vous utilisez l'approche TAP, n'interf√©rez pas avec la cr√©ation manuelle de threads.  Cela s'apparente √† l'utilisation de HttpClient pour presque toutes les demandes, et le POST se fait ind√©pendamment via Socket. <br><br>  Deuxi√®mement.  Applications Web.  Chaque demande entrante entra√Æne l'extraction d'un nouveau thread de ThreadPool pour traitement.  La piscine, bien s√ªr, est grande, mais pas infinie.  Dans le cas o√π il y a beaucoup de demandes, il se peut qu'il n'y ait pas assez de threads du tout et toutes les nouvelles demandes seront mises en file d'attente pour le traitement.  Cette situation s'appelle la famine.  Mais dans le cas de l'utilisation de contr√¥leurs asynchrones, comme indiqu√© pr√©c√©demment, le flux retourne au pool et peut √™tre utilis√© pour traiter de nouvelles demandes.  Ainsi, le d√©bit du serveur est consid√©rablement augment√©. <br><br>  Nous avons examin√© le processus asynchrone du tout d√©but √† la fin.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et arm√©s d'une compr√©hension de toute cette asynchronie, qui contredit la nature humaine, nous consid√©rerons quelques astuces utiles lorsque vous travaillez avec du code asynchrone. </font></font><br><a name="api"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cours et astuces utiles lorsque vous travaillez avec TAP </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La diversit√© statique de la classe Task. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La classe Task poss√®de plusieurs m√©thodes statiques utiles. </font><font style="vertical-align: inherit;">Voici les principaux.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.WhenAny (..) est un combinateur qui prend IEnumerable / params des objets de t√¢che et renvoie un objet de t√¢che qui se terminera lorsque la premi√®re t√¢che qui se termine est termin√©e. </font><font style="vertical-align: inherit;">Autrement dit, il vous permet d'attendre l'une des nombreuses t√¢ches en cours d'ex√©cution</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task.WhenAll (..) - combinateur, accepte IEnumerable / params des objets de t√¢che et renvoie un objet de t√¢che, qui sera termin√© √† la fin de toutes les t√¢ches transf√©r√©es </font></font></li><li> Task.FromResult&lt;T&gt;(T value) ‚Äî    ,    .          </li><li> Task.Delay(..) ‚Äî     </li><li> Task.Yield() ‚Äî  .   ,      .  ,    ,      </li></ol><br><h3> ConfigureAwait </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturellement, la fonction ¬´avanc√©e¬ª la plus populaire. Cette m√©thode appartient √† la classe Task et vous permet de sp√©cifier si nous devons continuer dans le m√™me contexte o√π l'op√©ration asynchrone a √©t√© appel√©e. Par d√©faut, sans utiliser cette m√©thode, le contexte est m√©moris√© et poursuivi en utilisant la m√©thode Post mentionn√©e. Cependant, comme nous l'avons dit, la poste est un plaisir tr√®s cher. Par cons√©quent, si les performances sont √† la premi√®re place et que nous constatons que la poursuite ne mettra pas √† jour l'interface utilisateur, vous pouvez la sp√©cifier sur l'objet d'attente </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.ConfigureAwait (false)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela signifie que peu importe o√π la suite sera effectu√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant sur le probl√®me. Comme on dit, effrayant n'est pas l'ignorance, mais la fausse connaissance.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il m'est arriv√© d'observer le code d'une application web, o√π chaque appel asynchrone √©tait d√©cor√© de cet acc√©l√©rateur. </font><font style="vertical-align: inherit;">Cela n'a d'autre effet que le d√©go√ªt visuel. </font><font style="vertical-align: inherit;">L'application Web ASP.NET Core standard n'a pas de contexte unique (sauf si vous les √©crivez vous-m√™me, bien s√ªr). </font><font style="vertical-align: inherit;">Ainsi, la m√©thode Post n'y est pas appel√©e de toute fa√ßon.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TaskCompletionSource &lt;T&gt; </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une classe qui facilite la gestion d'un objet Task. </font><font style="vertical-align: inherit;">Une classe a de nombreuses opportunit√©s, mais est plus utile lorsque nous voulons terminer une t√¢che avec une action, dont la fin se produit sur un √©v√©nement. </font><font style="vertical-align: inherit;">En g√©n√©ral, la classe a √©t√© cr√©√©e pour adapter les anciennes m√©thodes asynchrones √† TAP, mais comme nous l'avons vu, elle n'est pas seulement utilis√©e pour cela. </font><font style="vertical-align: inherit;">Un petit exemple de travail avec cette classe:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Exemple</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); FileSystemWatcher watcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileSystemWatcher { Path = Directory.GetCurrentDirectory(), NotifyFilter = NotifyFilters.LastAccess, EnableRaisingEvents = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; watcher.Changed += (o, e) =&gt; tcs.SetResult(e.FullPath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tcs.Task; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cette classe cr√©e un wrapper asynchrone pour obtenir le nom du fichier auquel on a acc√©d√© dans le dossier actuel. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CancellationTokenSource </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous permet d'annuler une op√©ration asynchrone. </font><font style="vertical-align: inherit;">Le plan g√©n√©ral ressemble √† l'utilisation d'un TaskCompletionSource. </font><font style="vertical-align: inherit;">Tout d'abord, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var cts = new CancellationTokenSource () est cr√©√©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui, soit dit en passant, est IDisposable, puis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cts.Token</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est transmis aux op√©rations asynchrones </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De plus, suivant une certaine logique, dans certaines conditions, la m√©thode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cts.Cancel ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><i><font style="vertical-align: inherit;">appel√©e</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il peut √©galement s'abonner √† un √©v√©nement ou √† toute autre chose. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisation d'un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une bonne pratique. </font><font style="vertical-align: inherit;">Lorsque vous √©crivez votre m√©thode asynchrone qui fonctionne en arri√®re-plan, disons dans un temps infini, vous pouvez simplement ins√©rer une ligne dans le corps de la boucle: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cancelToken.ThrowIfCancellationRequested ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui l√®vera une exception</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cette exception est trait√©e comme une annulation de l'op√©ration et n'est pas enregistr√©e en tant qu'exception dans l'objet de t√¢che. </font><font style="vertical-align: inherit;">En outre, la propri√©t√© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsCanceled</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur l'objet Task deviendra vraie.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Longue course </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a souvent des situations, en particulier lors de l'√©criture de services, lorsque vous cr√©ez plusieurs t√¢ches qui fonctionneront tout au long de la dur√©e de service ou tout simplement pendant une tr√®s longue p√©riode. </font><font style="vertical-align: inherit;">Comme nous nous en souvenons, l'utilisation d'un pool de threads est √† juste titre la surcharge de cr√©ation d'un thread. </font><font style="vertical-align: inherit;">Cependant, si un flux est rarement cr√©√© (m√™me une fois par heure), ces co√ªts sont nivel√©s et vous pouvez cr√©er en toute s√©curit√© des flux distincts. </font><font style="vertical-align: inherit;">Pour ce faire, lors de la cr√©ation d'une t√¢che, vous pouvez sp√©cifier une option sp√©ciale: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.Factory.StartNew (action, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCreationOptions.LongRunning</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quoi qu'il en soit, je vous conseille de regarder toutes les surcharges </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.Factory.StartNew</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il existe de nombreuses fa√ßons de configurer de mani√®re flexible la t√¢che pour r√©pondre √† des besoins sp√©cifiques.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exceptions </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison de la nature non d√©terministe de l'ex√©cution de code asynchrone, la question des exceptions est tr√®s pertinente. Ce serait dommage si vous ne pouviez pas attraper l'exception et qu'elle a √©t√© jet√©e dans le fil de gauche, tuant le processus. Une classe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √©t√© cr√©√©e pour intercepter une exception dans un thread et la jeter dedans </font><font style="vertical-align: inherit;">. Pour intercepter l'exception, la m√©thode statique </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo.Capture (ex) est utilis√©e, qui</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> renvoie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un lien vers cet objet peut √™tre transmis √† n'importe quel thread, qui appelle ensuite la m√©thode Throw () pour le jeter. </font><font style="vertical-align: inherit;">Le lancement lui-m√™me ne se produit PAS √† l'endroit de l'appel d'op√©ration asynchrone, mais au lieu d'utilisation de l'op√©rateur d'attente. </font><font style="vertical-align: inherit;">Et comme vous le savez, l'attente ne peut √™tre appliqu√©e √† l'annulation. </font><font style="vertical-align: inherit;">Ainsi, si le contexte existait, il lui sera transmis par la m√©thode Post. </font><font style="vertical-align: inherit;">Sinon, il sera excit√© dans le flux de la piscine. </font><font style="vertical-align: inherit;">Et c'est presque 100% bonjour √† l'effondrement de l'application. </font><font style="vertical-align: inherit;">Et nous arrivons ici √† la pratique du fait que nous devons utiliser la t√¢che ou la t√¢che &lt;T&gt;, mais pas nul. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et encore une chose. </font><font style="vertical-align: inherit;">Le planificateur a un √©v√©nement </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskScheduler.UnobservedTaskException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui se d√©clenche lorsqu'une </font><i><font style="vertical-align: inherit;">exception UnobservedTaskException </font></i><i><font style="vertical-align: inherit;">est</font></i><font style="vertical-align: inherit;"> lev√©e</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cette exception est lev√©e lors de la r√©cup√©ration de place lorsque le GC essaie de collecter un objet de t√¢che qui a une exception non g√©r√©e.</font></font><br><br><h3> IAsyncEnumerable </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant C # 8 et .NET Core 3.0, il n'√©tait pas possible d'utiliser un it√©rateur de rendement dans une m√©thode asynchrone, ce qui compliquait la vie et lui faisait renvoyer la t√¢che &lt;IEnumerable &lt;T&gt;&gt; de cette m√©thode, c'est-√†-dire il n'y avait aucun moyen de parcourir la collection jusqu'√† ce qu'elle soit enti√®rement re√ßue. Maintenant, il y a une telle opportunit√©. Apprenez-en plus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pour cela, le type de retour doit √™tre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerable &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ou </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerator &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Pour parcourir une telle collection, vous devez utiliser la boucle foreach avec le mot-cl√© wait. En outre, les m√©thodes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WithCancellation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peuvent √™tre appel√©es sur le r√©sultat de l'op√©ration </font><font style="vertical-align: inherit;">, indiquant le CancelationToken utilis√© et la n√©cessit√© de continuer dans le m√™me contexte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme pr√©vu, tout se fait le plus paresseusement possible. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici un exemple et la conclusion qu'il donne.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Exemple</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); sw.Start(); IAsyncEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; enumerable = AsyncYielding(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time after calling: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerable.WithCancellation(..).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"element: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{element}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds}</span></span></span><span class="hljs-string">"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> IAsyncEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncYielding</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uselessElement <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) { Task task = Task.Delay(TimeSpan.FromSeconds(uselessElement)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Task run: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{uselessElement}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> task; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uselessElement; } } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temps apr√®s l'appel: 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ex√©cution de la t√¢che: 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©l√©ment: 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heure: 1033 Ex√©cution de la </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t√¢che: 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©l√©ment: 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heure: 3034 Ex√©cution de la </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t√¢che: 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©l√©ment: 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heure: 6035</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Threadpool </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette classe est activement utilis√©e lors de la programmation avec TAP. Par cons√©quent, je donnerai les d√©tails minimum de sa mise en ≈ìuvre. √Ä l'int√©rieur, ThreadPool a un tableau de files d'attente: une pour chaque thread + une globale. Lors de l'ajout d'un nouveau travail au pool, le thread qui a initi√© l'ajout est pris en compte. Dans le cas o√π il s'agit d'un thread du pool, le travail est plac√© dans sa propre file d'attente de ce thread, s'il s'agissait d'un autre thread - dans le global. Lorsqu'un thread est s√©lectionn√© pour fonctionner, sa file d'attente locale appara√Æt en premier. S'il est vide, le thread prend les travaux du global. S'il est vide, il commence √† voler aux autres. De plus, vous ne devriez jamais vous fier √† l'ordre du travail, car, en fait, il n'y a pas d'ordre. Le nombre par d√©faut de threads dans un pool d√©pend de nombreux facteurs, notamment la taille de l'espace d'adressage. S'il y a plus de demandes d'ex√©cution,que le nombre de threads disponibles, les demandes sont mises en file d'attente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les threads d'un pool de threads sont des threads d'arri√®re-plan (propri√©t√© isBackground = true). </font><font style="vertical-align: inherit;">Ce type de thread ne prend pas en charge la dur√©e de vie du processus si tous les threads de premier plan sont termin√©s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le thread syst√®me surveille l'√©tat du descripteur d'attente. </font><font style="vertical-align: inherit;">Lorsque l'op√©ration d'attente se termine, le rappel transf√©r√© est ex√©cut√© par le thread du pool (rappelez-vous les fichiers dans Windows).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Type de t√¢che </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mentionn√© pr√©c√©demment, ce type (structure ou classe) peut √™tre utilis√© comme valeur de retour de la m√©thode asynchrone. </font><font style="vertical-align: inherit;">Un type de g√©n√©rateur doit √™tre associ√© √† ce type √† l'aide de l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attribut [AsyncMethodBuilder (..)]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ce type doit avoir les caract√©ristiques mentionn√©es ci-dessus afin de pouvoir lui appliquer le mot-cl√© wait. </font><font style="vertical-align: inherit;">Il peut √™tre param√©tr√© pour les m√©thodes qui ne renvoient pas de valeur et param√©tr√© pour celles qui retournent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le g√©n√©rateur lui-m√™me est une classe ou une structure dont le cadre est illustr√© dans l'exemple ci-dessous. </font><font style="vertical-align: inherit;">La m√©thode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetResult</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a un param√®tre de type T pour un type de t√¢che param√©tr√© par T. Pour les types non param√©tr√©s, la m√©thode n'a pas de param√®tres.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface Builder requise</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyTaskMethodBuilder</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MyTaskMethodBuilder&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start&lt;TStateMachine&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetStateMachine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAsyncStateMachine stateMachine</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception exception</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T result</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : INotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : ICriticalNotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyTask&lt;T&gt; Task { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le principe du travail du point de vue de l'√©criture de votre type de t√¢che sera d√©crit ci-dessous. La plupart de cela a d√©j√† √©t√© d√©crit lors de l'analyse du code g√©n√©r√© par le compilateur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le compilateur utilise tous ces types pour g√©n√©rer une machine √† √©tats. Le compilateur sait quels constructeurs utiliser pour les types qu'il conna√Æt, nous sp√©cifions ici ce qui sera utilis√© lors de la g√©n√©ration du code. Si la machine d'√©tat est une structure, elle sera compress√©e lors de l'appel √† </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetStateMachine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le g√©n√©rateur peut mettre en cache la copie compress√©e si n√©cessaire. Le g√©n√©rateur doit appeler </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateMachine.MoveNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans la m√©thode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou apr√®s son appel afin de d√©marrer l'ex√©cution et de faire avancer la machine d'√©tat. Apr√®s avoir appel√© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la propri√©t√© Task sera renvoy√©e par la m√©thode. Je vous recommande de revenir √† la m√©thode stub et d'afficher ces √©tapes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la machine d'√©tat se termine avec succ√®s, la m√©thode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetResult</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><i><font style="vertical-align: inherit;">appel√©e</font></i><font style="vertical-align: inherit;"> , sinon </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si la machine d'√©tat atteint </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , la m√©thode </font><i><font style="vertical-align: inherit;">GetAwaiter ()</font></i><font style="vertical-align: inherit;"> du </font><font style="vertical-align: inherit;">type de t√¢che </font><font style="vertical-align: inherit;">est ex√©cut√©e </font><font style="vertical-align: inherit;">. Si l'objet d'attente impl√©mente l'interface </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICriticalNotifyCompletion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et IsCompleted = false, la machine d'√©tat utilise </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitUnsafeOnCompleted (ref waiter, ref stateMachine)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La m√©thode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AwaitUnsafeOnCompleted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doit appeler </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">waiter.OnCompleted (action)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , l'action doit appeler </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateMachine.MoveNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque l'objet d'attente se termine. </font><font style="vertical-align: inherit;">De m√™me pour l'interface </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INotifyCompletion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et la m√©thode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitOnCompleted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est √† vous de d√©cider comment l'utiliser. </font><font style="vertical-align: inherit;">Mais je vous conseille de penser √† 514 fois avant de l'appliquer en production, et non de vous faire dorloter. </font><font style="vertical-align: inherit;">Ce qui suit est un exemple d'utilisation. </font><font style="vertical-align: inherit;">J'ai esquiss√© juste un proxy pour un constructeur standard qui affiche √† la console quelle m√©thode a √©t√© appel√©e et √† quelle heure. </font><font style="vertical-align: inherit;">Soit dit en passant, l'asynchrone Main () ne veut pas prendre en charge un type d'attente personnalis√© (je crois que plus d'un projet de production a √©t√© d√©sesp√©r√©ment corrompu en raison de cette absence de Microsoft). </font><font style="vertical-align: inherit;">Si vous le souhaitez, vous pouvez modifier l'enregistreur proxy en utilisant un enregistreur normal et en enregistrant plus d'informations.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T√¢che de proxy de journalisation</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Start"</span></span>); JustMethod().Task.Wait(); <span class="hljs-comment"><span class="hljs-comment">//   Console.WriteLine("Stop"); } public static async LogTask JustMethod() { await DelayWrapper(1000); } public static LogTask DelayWrapper(int milliseconds) =&gt; new LogTask { Task = Task.Delay(milliseconds)}; } [AsyncMethodBuilder(typeof(LogMethodBuilder))] public class LogTask { public Task Task { get; set; } public TaskAwaiter GetAwaiter() =&gt; Task.GetAwaiter(); } public class LogMethodBuilder { private AsyncTaskMethodBuilder _methodBuilder = AsyncTaskMethodBuilder.Create(); private LogTask _task; public static LogMethodBuilder Create() { Console.WriteLine($"Method: Create; {DateTime.Now :O}"); return new LogMethodBuilder(); } public void Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: Start; {DateTime.Now :O}"); _methodBuilder.Start(ref stateMachine); } public void SetStateMachine(IAsyncStateMachine stateMachine) { Console.WriteLine($"Method: SetStateMachine; {DateTime.Now :O}"); _methodBuilder.SetStateMachine(stateMachine); } public void SetException(Exception exception) { Console.WriteLine($"Method: SetException; {DateTime.Now :O}"); _methodBuilder.SetException(exception); } public void SetResult() { Console.WriteLine($"Method: SetResult; {DateTime.Now :O}"); _methodBuilder.SetResult(); } public void AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: AwaitOnCompleted; {DateTime.Now :O}"); _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine); } public void AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: AwaitUnsafeOnCompleted; {DateTime.Now :O}"); _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine); } public LogTask Task { get { Console.WriteLine($"Property: Task; {DateTime.Now :O}"); return _task ??= new LogTask {Task = _methodBuilder.Task}; } set =&gt; _task = value; } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion: </font><i><font style="vertical-align: inherit;">M√©thode de </font></i></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©marrage </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Cr√©er; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7152733 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©thode: D√©marrer; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7262226 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©thode: AwaitUnsafeOnCompleted; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7275206 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propri√©t√©: t√¢che; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7292005 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©thode: SetResult; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 14.7297967 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stop</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C'est tout, merci √† tous.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470830/">https://habr.com/ru/post/fr470830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470820/index.html">Un test rapide de dizaines d'hypoth√®ses: comment sortir de la routine et discuter dans une autre ville</a></li>
<li><a href="../fr470822/index.html">Surveillance de la temp√©rature dans l'entreprise</a></li>
<li><a href="../fr470824/index.html">Dialogues sur promesse</a></li>
<li><a href="../fr470826/index.html">Mineurs, plongeurs et cobalt: comment nous fournissons aux clients un acc√®s Internet s√©curis√©</a></li>
<li><a href="../fr470828/index.html">Liste li√©e Python: chats dans des bo√Ætes</a></li>
<li><a href="../fr470834/index.html">Mod√®les de surinfection, d'antibiotiques et d'apocalypse zombie</a></li>
<li><a href="../fr470838/index.html">S√©curit√© des conteneurs dans CI / CD</a></li>
<li><a href="../fr470844/index.html">Le nouveau projet des fr√®res Durov: Telegram Open Network</a></li>
<li><a href="../fr470852/index.html">Traitement de 40 To de code √† partir de 10 millions de projets sur un serveur d√©di√© avec Go pour 100 $</a></li>
<li><a href="../fr470856/index.html">Telegram GRAM Wallet: conditions d'utilisation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>