<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤷🏾 🏟️ 🛀🏾 Buch "{Sie kennen JS nicht} Typen und Grammatikkonstruktionen" 🧖🏼 ✍🏻 📦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unabhängig von Ihrer JavaScript-Programmiererfahrung verstehen Sie die Sprache höchstwahrscheinlich nicht vollständig. In diesem kurzen Handbuch werde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buch "{Sie kennen JS nicht} Typen und Grammatikkonstruktionen"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/456730/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/un/r1/ll/unr1llifhhvkguhuc2sq4tll6ly.jpeg" align="left" alt="Bild"></a>  Unabhängig von Ihrer JavaScript-Programmiererfahrung verstehen Sie die Sprache höchstwahrscheinlich nicht vollständig.  In diesem kurzen Handbuch werden Typen ausführlicher behandelt als in allen vorhandenen Büchern: Sie erfahren, wie Typen funktionieren, welche Probleme bei der Konvertierung auftreten und wie Sie neue Funktionen verwenden. <br><br>  Wie andere Bücher in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe „Sie kennen JS nicht“</a> zeigt es nicht triviale Aspekte der Sprache, von denen JavaScript-Programmierer sich lieber fernhalten (oder davon ausgehen, dass sie nicht existieren).  Mit diesem Wissen erreichen Sie eine echte JavaScript-Meisterschaft. <br><a name="habracut"></a><br><h3>  Auszug.  Gleichheit ist streng und nicht streng. </h3><br>  Die nicht strikte Gleichheit wird vom Operator == und die strikte Gleichheit vom Operator === überprüft.  Beide Operatoren werden verwendet, um zwei Werte für „Gleichheit“ zu vergleichen, aber die Wahl der Form (streng / nicht streng) führt zu sehr wichtigen Verhaltensunterschieden, insbesondere in der Art und Weise, wie die Entscheidung über Gleichheit getroffen wird. <br><br>  Es gibt ein weit verbreitetes Missverständnis über diese beiden Operatoren: "== prüft auf Wertgleichheit und === prüft auf Gleichheit von Werten und Typen."  Klingt vernünftig <br>  aber ungenau.  Unzählige seriöse JavaScript-Bücher und -Blogs sagen genau das, aber leider sind sie alle falsch. <br><br>  Die korrekte Beschreibung lautet: "== ermöglicht die Typkonvertierung bei der Überprüfung der Gleichheit und === verbietet die Typkonvertierung." <br><br><h3>  Leistung zur Überprüfung der Gleichstellung </h3><br>  Halten Sie inne und überlegen Sie, wie sich die erste (ungenaue) Erklärung von der zweiten (genauen) unterscheidet. <br>  In der ersten Erklärung scheint es offensichtlich, dass der Operator === mehr Arbeit leistet als ==, da er auch den Typ überprüfen muss. <br><br>  In der zweiten Erklärung erledigt der Operator == mehr Arbeit, da er bei verschiedenen Typen eine Typkonvertierung durchlaufen muss. <br><br>  Fallen Sie nicht in die Falle, in die viele fallen.  Denken Sie nicht, dass dies die Geschwindigkeit des Programms beeinflusst und == wesentlich langsamer ist ===.  Obwohl die Konvertierung einige Zeit in Anspruch nimmt, dauert es einige Mikrosekunden (ja, Millionstelsekunden). <br><br>  Wenn Sie zwei Werte desselben Typs vergleichen, verwenden == und === denselben Algorithmus. Wenn Sie also kleine Unterschiede bei der Implementierung der Engine nicht berücksichtigen, müssen sie einen ausführen <br>  und der gleiche Job. <br><br>  Wenn Sie zwei Werte unterschiedlichen Typs vergleichen, ist die Leistung kein wichtiger Faktor.  Sie müssen sich noch etwas fragen: Wenn ich zwei Werte vergleiche, möchte ich, dass die Typkonvertierung erfolgt oder nicht? <br><br>  Wenn Sie eine Konvertierung benötigen, verwenden Sie nicht strikte Gleichheit ==, und wenn die Konvertierung unerwünscht ist, verwenden Sie strikte Gleichheit ===. <br><br><blockquote>  Beide Operatoren == und === überprüfen die Typen ihrer Operanden.  Der Unterschied besteht darin, wie sie auf Typinkongruenzen reagieren. </blockquote><br><h3>  Abstrakte Gleichstellungsprüfung </h3><br>  Das Verhalten des Operators == ist in Abschnitt 11.9.3 der ES5-Spezifikation („Abstract Equality Checker Algorithm“) definiert.  Hier ist ein detaillierter, aber einfacher Algorithmus mit einer expliziten Auflistung aller möglichen Kombinationen von Typen und Typkonvertierungsmethoden (falls erforderlich), die in jeder Kombination angewendet werden sollten. <br><br><blockquote> Wenn jemand die (implizite) Typkonvertierung als zu komplex verurteilt und zu viele Fehler für den praktischen Gebrauch enthält, verurteilt er die Regeln der "abstrakten Gleichheitsprüfung".  Es wird normalerweise gesagt, dass dieser Mechanismus für das praktische Studium und die Verwendung zu kompliziert und unnatürlich ist und dass er Fehler in JS-Programmen erzeugt, anstatt das Lesen von Code zu vereinfachen. <br><br>  Ich glaube, dass dies eine falsche Annahme ist - Sie Leser sind kompetente Entwickler, die den ganzen Tag über Algorithmen schreiben, dh Code (und ihn auch lesen und verstehen).  Aus diesem Grund werde ich versuchen, den "abstrakten Gleichheitstest" in einfachen Worten zu erklären.  Ich empfehle jedoch auch, Abschnitt 11.9.3 der ES5-Spezifikation zu lesen.  Ich denke, es wird Sie überraschen, wie logisch alles da ist. </blockquote><br>  Tatsächlich heißt es im ersten Abschnitt (11.9.3.1), dass zwei verglichene Werte, die vom gleichen Typ sind, auf einfache und natürliche Weise verglichen werden.  Zum Beispiel ist 42 nur 42 und die Zeichenfolge "abc" ist nur "abc". <br><br>  Ein paar kleine Ausnahmen zu beachten: <br><br><ul><li>  Der Wert von NaN ist niemals gleich sich selbst (siehe Kapitel 2). </li><li>  +0 und -0 sind gleich (siehe Kapitel 2). </li></ul><br>  Der letzte Abschnitt in Abschnitt 11.9.3.1 ist einem strengen Test der Gleichheit mit Objekten (einschließlich Funktionen und Arrays) gewidmet.  Zwei solche Werte sind <i>nur</i> dann gleich <i>,</i> wenn sich beide auf genau <i>denselben Wert</i> beziehen.  Es wird keine Typkonvertierung durchgeführt. <br><br><blockquote>  Eine strikte Gleichheitsprüfung === ist identisch mit 11.9.3.1 definiert, einschließlich der Bereitstellung von zwei Objektwerten.  Diese Tatsache ist sehr wenig bekannt, aber == und === verhalten sich beim Vergleich zweier Objekte völlig identisch! </blockquote><br>  Der Rest des Algorithmus in 11.9.3 zeigt an, dass nicht strenge Gleichheit == verwendet werden kann, um zwei verschiedene Arten von Werten zu vergleichen, von denen einer oder beide erforderlich sind <br>  implizite Konvertierung.  Durch die Konvertierung werden die Bezeichnungen auf einen Typ reduziert, wonach sie durch einfache Identität direkt auf Gleichheit verglichen werden können <br>  Werte. <br><br><blockquote>  Die Operation einer schwachen Ungleichheitsprüfung! = Wird genau so bestimmt, wie man es erwarten würde;  Tatsächlich ist die Operation == vollständig implementiert, gefolgt von einer Berechnung <br>  Verweigerung des Ergebnisses.  Gleiches gilt für die strikte Überprüfung der Ungleichung! ==. </blockquote><br><h3>  Vergleich: Zeichenfolgen und Zahlen </h3><br>  Um die Konvertierung von == zu demonstrieren, erstellen Sie zunächst Beispiele für Zeichenfolgen und Zahlen, die weiter oben in diesem Kapitel ausgeführt wurden: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; a === b; <span class="hljs-comment"><span class="hljs-comment">// false a == b; // true</span></span></code> </pre> <br>  Wie erwartet schlägt die Prüfung a === b fehl, da die Konvertierung nicht zulässig ist und die Werte 42 und "42" unterschiedlich sind. <br><br>  Im zweiten Vergleich a == b wird jedoch eine nicht strenge Gleichheit verwendet;  Dies bedeutet, dass der Vergleichsalgorithmus bei unterschiedlichen Typen eine implizite Konvertierung von eins durchführt <br>  oder beides. <br><br>  Aber welche Art von Konvertierung wird hier durchgeführt?  Wird der Wert a, dh 42, eine Zeichenfolge oder wird der Wert b „42“ eine Zahl?  Die ES5-Spezifikation in den Abschnitten 11.9.3.4–5 lautet: <br><br><ol><li>  Wenn Typ (x) vom Typ Nummer und Typ (y) vom Typ String ist, geben Sie das Ergebnis des Vergleichs x == ToNumber (y) zurück. </li><li>  Wenn Typ (x) vom Typ String und Typ (y) vom Typ Number ist, geben Sie das Ergebnis des Vergleichs ToNumber (x) == y zurück. </li></ol><br><blockquote>  In der Spezifikation werden formale Namen der Typen Number und String verwendet, während im Buch für primitive Typen normalerweise die Notationsnummer und der String verwendet werden.  Verwechseln Sie den Fall des Zahlensymbols in der Spezifikation nicht mit der integrierten Funktion Number ().  Für unsere Zwecke spielt der Fall von Zeichen im Namen des Typs keine Rolle - sie bedeuten dasselbe. </blockquote><br>  Die Spezifikation besagt, dass der Wert "42" zum Vergleich in eine Zahl umgewandelt wird.  Wie die Konvertierung durchgeführt wird, wurde bereits zuvor beschrieben, insbesondere bei der Beschreibung der abstrakten Operation ToNumber.  In diesem Fall ist es ziemlich offensichtlich <br>  dass die resultierenden zwei Werte von 42 gleich sind. <br><br><h3>  Vergleich: alles mit Booleschen Werten </h3><br>  Eine der gefährlichsten Fallen bei der impliziten Konvertierung vom Typ == tritt auf, wenn versucht wird, Werte direkt mit wahr oder falsch zu vergleichen. <br><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; a == b; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Warten Sie, was ist hier los?  Wir wissen, dass „42“ die wahre Bedeutung ist (siehe weiter oben in diesem Kapitel).  Wie stellt sich heraus, dass ein Vergleich mit true mit der Aussage der strengen Gleichheit == <br>  gibt nicht wahr? <br><br>  Der Grund ist einfach und gleichzeitig täuschend gerissen.  Es ist leicht zu missverstehen, viele JS-Entwickler bemühen sich nicht, es vollständig zu verstehen. <br><br>  Wir zitieren noch einmal die Spezifikation, Abschnitte 11.9.3.6–7: <br><br><ol><li>  Wenn Typ (x) vom Typ Boolean ist, geben Sie das Ergebnis des Vergleichs ToNumber (x) == y zurück. </li><li>  Wenn Typ (y) vom Typ Boolean ist, geben Sie das Ergebnis des Vergleichs x == ToNumber (y) zurück. </li></ol><br>  Mal sehen, was hier ist.  Erster Schritt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; x == y; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Typ (x) gehört wirklich zum Booleschen Typ, daher wird die ToNumber (x) -Operation ausgeführt, die true in 1 konvertiert. Nun wird Bedingung 1 == "42" berechnet.  Die Typen sind immer noch unterschiedlich, daher wiederholt sich der Algorithmus (fast rekursiv).  Wie im vorherigen Fall wird "42" in 42 umgewandelt, und Bedingung 1 == 42 ist offensichtlich falsch. <br><br>  Wenn Sie Operanden austauschen, bleibt das Ergebnis gleich: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; x == y; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Diesmal ist Typ (y) vom Typ Boolean, daher gibt ToNumber (y) 0 an. Die Bedingung "42" == 0 wird rekursiv zu 42 == 0, was natürlich falsch ist. <br><br>  Mit anderen Worten, der Wert "42" ist weder == wahr noch == falsch.  Diese Aussage erscheint auf den ersten Blick völlig undenkbar.  Wie kann Bedeutung weder wahr noch falsch sein? <br><br>  Aber das ist das Problem!  Sie stellen die falsche Frage.  Obwohl es in der Tat nicht deine Schuld ist, ist es das Gehirn, das dich täuscht. <br><br>  Der Wert "42" ist zwar wahr, aber die Konstruktion "42" == wahr führt überhaupt keinen Booleschen / Transformationstest durch, was auch immer Ihr Gehirn sagt.  "42" konvertiert nicht in boolesch (true);  Stattdessen wird true in 1 konvertiert und dann wird „42“ in 42 konvertiert. <br><br>  Ob Sie es mögen oder nicht, ToBoolean wird hier überhaupt nicht verwendet, daher ist die Wahrheit oder Falschheit von „42“ für die == -Operation überhaupt nicht wichtig!  Es ist wichtig zu verstehen, wie sich der == Vergleichsalgorithmus in allen verschiedenen Typkombinationen verhält.  Wenn der boolesche Wert einseitig ist, wird er immer zuerst in eine Zahl konvertiert. <br><br>  Wenn Ihnen das seltsam vorkommt, sind Sie nicht allein.  Persönlich empfehle ich, unter keinen Umständen == true oder == false zu verwenden.  Niemals. <br><br>  Aber denken Sie daran, dass ich hier nur von == spreche.  Die Konstruktionen === true und === false erlauben keine Typkonvertierung, daher sind sie vor der versteckten ToNumber-Konvertierung geschützt. <br><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  (  !): if (a == true) { // .. } //   (  !): if (a === true) { // .. } //   ( ): if (a) { // .. } //  ( ): if (!!a) { // .. } //   ( ): if (Boolean( a )) { // .. }</span></span></code> </pre> <br>  Wenn Sie in Ihrem Code == true oder == false (lose Gleichheit mit Booleschen Werten) vermeiden, müssen Sie sich niemals um diese Wahrheits- / Falschheitsfalle sorgen. <br><br><h3>  Vergleich: null mit undefiniert </h3><br>  Ein weiteres Beispiel für eine implizite Konvertierung tritt auf, wenn Sie die lax == -Gleichheit zwischen null und undefinierten Werten verwenden.  Ich werde wieder die ES5-Spezifikation zitieren, <br>  Abschnitte 11.9.3.2–3: <br><br><ol><li>  Wenn x null und y undefiniert enthält, geben Sie true zurück. </li><li>  Wenn x undefiniert und y null enthält, geben Sie true zurück. </li></ol><br>  Null und undefiniert im Vergleich zum nicht strengen Operator == sind gleich (dh sie werden ineinander konvertiert) und keine anderen Werte in der gesamten Sprache. <br><br>  Für uns bedeutet dies, dass null und undefiniert zu Vergleichszwecken als nicht unterscheidbar angesehen werden können, wenn Sie den nicht strengen Gleichheitstestoperator == verwenden, der ihre gegenseitige implizite Konvertierung ermöglicht: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b; a == b; <span class="hljs-comment"><span class="hljs-comment">// true a == null; // true b == null; // true a == false; // false b == false; // false a == ""; // false b == ""; // false a == 0; // false b == 0; // false</span></span></code> </pre> <br>  Die Konvertierung zwischen null und undefiniert ist sicher und vorhersehbar, und kein anderer Wert kann für eine solche Prüfung falsch positive Ergebnisse liefern.  Ich empfehle diese Konvertierung, damit sich null und undefined im Programm nicht unterscheiden und als ein einziger Wert interpretiert werden. <br><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. }</span></span></code> </pre> <br>  Die Prüfung a == null wird nur bestanden, wenn doSomething () null oder undefiniert zurückgibt und für einen anderen Wert (einschließlich 0, false und "") fehlschlägt. <br><br>  Die explizite Form dieser Prüfung, die solche Typkonvertierungen verbietet, sieht (meiner Meinung nach) viel hässlicher aus und funktioniert möglicherweise etwas weniger effizient! <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> || a === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. }</span></span></code> </pre> <br>  Ich glaube, dass die Form a == null ein weiteres Beispiel für eine Situation ist, in der eine implizite Konvertierung das Lesen des Codes erleichtert, dies jedoch zuverlässig und sicher tut. <br><br><h3>  Vergleich: Objekte und Nichtobjekte </h3><br>  Wenn ein Objekt / eine Funktion / ein Array mit einem einfachen skalaren Grundelement (Zeichenfolge, Zahl oder Boolescher Wert) verglichen wird, lautet die ES5-Spezifikation Folgendes (Abschnitt 11.9.3.8–9): <br><br><ol><li>  Wenn Typ (x) vom Typ String oder Number und Typ (y) vom Typ Object ist, geben Sie das Ergebnis des Vergleichs x == ToPrimitive (y) zurück. </li><li>  Wenn Typ (x) vom Typ Objekt und Typ (y) vom Typ Zeichenfolge oder Zahl ist, geben Sie das Ergebnis des Vergleichs ToPrimitive (x) == y zurück. </li></ol><br><blockquote>  Möglicherweise haben Sie bemerkt, dass in diesen Abschnitten der Spezifikation nur String und Number erwähnt werden, nicht jedoch Boolean.  Tatsache ist, dass, wie oben erwähnt, in den Abschnitten 11.9.3.6–7 sichergestellt wird, dass jeder boolesche Operand zuerst als Zahl dargestellt wird. </blockquote><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = [ <span class="hljs-number"><span class="hljs-number">42</span></span> ]; a == b; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Für den Wert [42] wird die abstrakte Operation ToPrimitive aufgerufen (siehe "Abstrakte Operationen"), die das Ergebnis "42" ergibt.  Von diesem Moment an bleibt die einfache Bedingung „42“ == 42 bestehen, die sich, wie wir bereits herausgefunden haben, in 42 == 42 verwandelt, so dass a und b bis zur Typkonvertierung gleich sind. <br><br><blockquote>  Wie zu erwarten, sind auch in diesem Fall alle Funktionen der abstrakten ToPrimitive-Operation ((toString (), valueOf ())) anwendbar. Dies kann sehr nützlich sein, wenn Sie eine komplexe Datenstruktur haben und dies möchten Definieren Sie dafür eine spezielle Methode valueOf (), die einen einfachen Wert für die Überprüfung der Gleichheit bereitstellen muss. </blockquote><br>  In Kapitel 3 wurde das „Entpacken“ eines Objekt-Wrappers um einen Grundwert (wie z. B. in einem neuen String („abc“)) untersucht, was zur Rückgabe des zugrunde liegenden Grundelements führte <br>  Wert ("abc").  Dieses Verhalten hängt mit der ToPrimitive-Transformation im == -Algorithmus zusammen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>( a ); <span class="hljs-comment"><span class="hljs-comment">//  ,  `new String( a )` a === b; // false a == b; // true</span></span></code> </pre> <br>  a == b gibt true an, weil b durch die ToPrimitive-Operation in den einfachen skalaren Grundprimitivwert "abc" konvertiert (oder "entpackt") wird, der dem Wert von a entspricht. <br><br>  Es gibt einige Werte, für die dies aufgrund anderer übergeordneter Regeln im == Algorithmus nicht der Fall ist.  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>( a ); <span class="hljs-comment"><span class="hljs-comment">//  ,  `Object()` a == b; // false var c = undefined; var d = Object( c ); //  ,  `Object()` c == d; // false var e = NaN; var f = Object( e ); //  ,  `new Number( e )` e == f; // false</span></span></code> </pre> <br>  Die Werte null und undefiniert können nicht gepackt werden (sie haben keinen äquivalenten Objekt-Wrapper), daher unterscheidet sich Object (null) nicht grundlegend von Object (): Beide Aufrufe erstellen das Übliche <br>  ny Objekt. <br><br>  NaN kann in den entsprechenden Number-Objekt-Wrapper gepackt werden. Wenn == jedoch das Entpacken verursacht, schlägt der NaN == NaN-Vergleich fehl, da der NaN-Wert niemals gleich sich selbst ist (siehe Kapitel 2). <br><br>  »Weitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  25% Rabatt auf Gutschein für Händler - <b>JavaScript</b> <br><br>  Nach Bezahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456730/">https://habr.com/ru/post/de456730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456710/index.html">Was ist eine Low-Code / No-Code-Plattform und CRM, CRM +, ERP</a></li>
<li><a href="../de456712/index.html">Selektive Verkehrsprotokollierung für SOAP-Dienste</a></li>
<li><a href="../de456714/index.html">Gleitkommazahlen verstehen (Teil 0)</a></li>
<li><a href="../de456716/index.html">Nicht sehr große Datenmengen</a></li>
<li><a href="../de456722/index.html">PostgreSQL-Rezepte: Asynchroner Taskplaner</a></li>
<li><a href="../de456736/index.html">PostgreSQL-Rezepte: cURL: Abrufen, Veröffentlichen und ... E-Mail</a></li>
<li><a href="../de456738/index.html">Neuronale Netze und tiefes Lernen, Kapitel 1: Verwenden neuronaler Netze zum Erkennen handgeschriebener Zahlen</a></li>
<li><a href="../de456744/index.html">10 Probleme, die ich mit Erinnerungen auf meinem Smartphone gelöst habe</a></li>
<li><a href="../de456746/index.html">Big Data - große Verantwortung, großer Stress und viel Geld</a></li>
<li><a href="../de456748/index.html">2003 Thermodrucker von einem Flohmarkt: Was kann er 2019 tun?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>