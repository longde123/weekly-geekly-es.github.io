<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑üèæ üèüÔ∏è üõÄüèæ Buch "{Sie kennen JS nicht} Typen und Grammatikkonstruktionen" üßñüèº ‚úçüèª üì¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unabh√§ngig von Ihrer JavaScript-Programmiererfahrung verstehen Sie die Sprache h√∂chstwahrscheinlich nicht vollst√§ndig. In diesem kurzen Handbuch werde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buch "{Sie kennen JS nicht} Typen und Grammatikkonstruktionen"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/456730/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/un/r1/ll/unr1llifhhvkguhuc2sq4tll6ly.jpeg" align="left" alt="Bild"></a>  Unabh√§ngig von Ihrer JavaScript-Programmiererfahrung verstehen Sie die Sprache h√∂chstwahrscheinlich nicht vollst√§ndig.  In diesem kurzen Handbuch werden Typen ausf√ºhrlicher behandelt als in allen vorhandenen B√ºchern: Sie erfahren, wie Typen funktionieren, welche Probleme bei der Konvertierung auftreten und wie Sie neue Funktionen verwenden. <br><br>  Wie andere B√ºcher in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe ‚ÄûSie kennen JS nicht‚Äú</a> zeigt es nicht triviale Aspekte der Sprache, von denen JavaScript-Programmierer sich lieber fernhalten (oder davon ausgehen, dass sie nicht existieren).  Mit diesem Wissen erreichen Sie eine echte JavaScript-Meisterschaft. <br><a name="habracut"></a><br><h3>  Auszug.  Gleichheit ist streng und nicht streng. </h3><br>  Die nicht strikte Gleichheit wird vom Operator == und die strikte Gleichheit vom Operator === √ºberpr√ºft.  Beide Operatoren werden verwendet, um zwei Werte f√ºr ‚ÄûGleichheit‚Äú zu vergleichen, aber die Wahl der Form (streng / nicht streng) f√ºhrt zu sehr wichtigen Verhaltensunterschieden, insbesondere in der Art und Weise, wie die Entscheidung √ºber Gleichheit getroffen wird. <br><br>  Es gibt ein weit verbreitetes Missverst√§ndnis √ºber diese beiden Operatoren: "== pr√ºft auf Wertgleichheit und === pr√ºft auf Gleichheit von Werten und Typen."  Klingt vern√ºnftig <br>  aber ungenau.  Unz√§hlige seri√∂se JavaScript-B√ºcher und -Blogs sagen genau das, aber leider sind sie alle falsch. <br><br>  Die korrekte Beschreibung lautet: "== erm√∂glicht die Typkonvertierung bei der √úberpr√ºfung der Gleichheit und === verbietet die Typkonvertierung." <br><br><h3>  Leistung zur √úberpr√ºfung der Gleichstellung </h3><br>  Halten Sie inne und √ºberlegen Sie, wie sich die erste (ungenaue) Erkl√§rung von der zweiten (genauen) unterscheidet. <br>  In der ersten Erkl√§rung scheint es offensichtlich, dass der Operator === mehr Arbeit leistet als ==, da er auch den Typ √ºberpr√ºfen muss. <br><br>  In der zweiten Erkl√§rung erledigt der Operator == mehr Arbeit, da er bei verschiedenen Typen eine Typkonvertierung durchlaufen muss. <br><br>  Fallen Sie nicht in die Falle, in die viele fallen.  Denken Sie nicht, dass dies die Geschwindigkeit des Programms beeinflusst und == wesentlich langsamer ist ===.  Obwohl die Konvertierung einige Zeit in Anspruch nimmt, dauert es einige Mikrosekunden (ja, Millionstelsekunden). <br><br>  Wenn Sie zwei Werte desselben Typs vergleichen, verwenden == und === denselben Algorithmus. Wenn Sie also kleine Unterschiede bei der Implementierung der Engine nicht ber√ºcksichtigen, m√ºssen sie einen ausf√ºhren <br>  und der gleiche Job. <br><br>  Wenn Sie zwei Werte unterschiedlichen Typs vergleichen, ist die Leistung kein wichtiger Faktor.  Sie m√ºssen sich noch etwas fragen: Wenn ich zwei Werte vergleiche, m√∂chte ich, dass die Typkonvertierung erfolgt oder nicht? <br><br>  Wenn Sie eine Konvertierung ben√∂tigen, verwenden Sie nicht strikte Gleichheit ==, und wenn die Konvertierung unerw√ºnscht ist, verwenden Sie strikte Gleichheit ===. <br><br><blockquote>  Beide Operatoren == und === √ºberpr√ºfen die Typen ihrer Operanden.  Der Unterschied besteht darin, wie sie auf Typinkongruenzen reagieren. </blockquote><br><h3>  Abstrakte Gleichstellungspr√ºfung </h3><br>  Das Verhalten des Operators == ist in Abschnitt 11.9.3 der ES5-Spezifikation (‚ÄûAbstract Equality Checker Algorithm‚Äú) definiert.  Hier ist ein detaillierter, aber einfacher Algorithmus mit einer expliziten Auflistung aller m√∂glichen Kombinationen von Typen und Typkonvertierungsmethoden (falls erforderlich), die in jeder Kombination angewendet werden sollten. <br><br><blockquote> Wenn jemand die (implizite) Typkonvertierung als zu komplex verurteilt und zu viele Fehler f√ºr den praktischen Gebrauch enth√§lt, verurteilt er die Regeln der "abstrakten Gleichheitspr√ºfung".  Es wird normalerweise gesagt, dass dieser Mechanismus f√ºr das praktische Studium und die Verwendung zu kompliziert und unnat√ºrlich ist und dass er Fehler in JS-Programmen erzeugt, anstatt das Lesen von Code zu vereinfachen. <br><br>  Ich glaube, dass dies eine falsche Annahme ist - Sie Leser sind kompetente Entwickler, die den ganzen Tag √ºber Algorithmen schreiben, dh Code (und ihn auch lesen und verstehen).  Aus diesem Grund werde ich versuchen, den "abstrakten Gleichheitstest" in einfachen Worten zu erkl√§ren.  Ich empfehle jedoch auch, Abschnitt 11.9.3 der ES5-Spezifikation zu lesen.  Ich denke, es wird Sie √ºberraschen, wie logisch alles da ist. </blockquote><br>  Tats√§chlich hei√üt es im ersten Abschnitt (11.9.3.1), dass zwei verglichene Werte, die vom gleichen Typ sind, auf einfache und nat√ºrliche Weise verglichen werden.  Zum Beispiel ist 42 nur 42 und die Zeichenfolge "abc" ist nur "abc". <br><br>  Ein paar kleine Ausnahmen zu beachten: <br><br><ul><li>  Der Wert von NaN ist niemals gleich sich selbst (siehe Kapitel 2). </li><li>  +0 und -0 sind gleich (siehe Kapitel 2). </li></ul><br>  Der letzte Abschnitt in Abschnitt 11.9.3.1 ist einem strengen Test der Gleichheit mit Objekten (einschlie√ülich Funktionen und Arrays) gewidmet.  Zwei solche Werte sind <i>nur</i> dann gleich <i>,</i> wenn sich beide auf genau <i>denselben Wert</i> beziehen.  Es wird keine Typkonvertierung durchgef√ºhrt. <br><br><blockquote>  Eine strikte Gleichheitspr√ºfung === ist identisch mit 11.9.3.1 definiert, einschlie√ülich der Bereitstellung von zwei Objektwerten.  Diese Tatsache ist sehr wenig bekannt, aber == und === verhalten sich beim Vergleich zweier Objekte v√∂llig identisch! </blockquote><br>  Der Rest des Algorithmus in 11.9.3 zeigt an, dass nicht strenge Gleichheit == verwendet werden kann, um zwei verschiedene Arten von Werten zu vergleichen, von denen einer oder beide erforderlich sind <br>  implizite Konvertierung.  Durch die Konvertierung werden die Bezeichnungen auf einen Typ reduziert, wonach sie durch einfache Identit√§t direkt auf Gleichheit verglichen werden k√∂nnen <br>  Werte. <br><br><blockquote>  Die Operation einer schwachen Ungleichheitspr√ºfung! = Wird genau so bestimmt, wie man es erwarten w√ºrde;  Tats√§chlich ist die Operation == vollst√§ndig implementiert, gefolgt von einer Berechnung <br>  Verweigerung des Ergebnisses.  Gleiches gilt f√ºr die strikte √úberpr√ºfung der Ungleichung! ==. </blockquote><br><h3>  Vergleich: Zeichenfolgen und Zahlen </h3><br>  Um die Konvertierung von == zu demonstrieren, erstellen Sie zun√§chst Beispiele f√ºr Zeichenfolgen und Zahlen, die weiter oben in diesem Kapitel ausgef√ºhrt wurden: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; a === b; <span class="hljs-comment"><span class="hljs-comment">// false a == b; // true</span></span></code> </pre> <br>  Wie erwartet schl√§gt die Pr√ºfung a === b fehl, da die Konvertierung nicht zul√§ssig ist und die Werte 42 und "42" unterschiedlich sind. <br><br>  Im zweiten Vergleich a == b wird jedoch eine nicht strenge Gleichheit verwendet;  Dies bedeutet, dass der Vergleichsalgorithmus bei unterschiedlichen Typen eine implizite Konvertierung von eins durchf√ºhrt <br>  oder beides. <br><br>  Aber welche Art von Konvertierung wird hier durchgef√ºhrt?  Wird der Wert a, dh 42, eine Zeichenfolge oder wird der Wert b ‚Äû42‚Äú eine Zahl?  Die ES5-Spezifikation in den Abschnitten 11.9.3.4‚Äì5 lautet: <br><br><ol><li>  Wenn Typ (x) vom Typ Nummer und Typ (y) vom Typ String ist, geben Sie das Ergebnis des Vergleichs x == ToNumber (y) zur√ºck. </li><li>  Wenn Typ (x) vom Typ String und Typ (y) vom Typ Number ist, geben Sie das Ergebnis des Vergleichs ToNumber (x) == y zur√ºck. </li></ol><br><blockquote>  In der Spezifikation werden formale Namen der Typen Number und String verwendet, w√§hrend im Buch f√ºr primitive Typen normalerweise die Notationsnummer und der String verwendet werden.  Verwechseln Sie den Fall des Zahlensymbols in der Spezifikation nicht mit der integrierten Funktion Number ().  F√ºr unsere Zwecke spielt der Fall von Zeichen im Namen des Typs keine Rolle - sie bedeuten dasselbe. </blockquote><br>  Die Spezifikation besagt, dass der Wert "42" zum Vergleich in eine Zahl umgewandelt wird.  Wie die Konvertierung durchgef√ºhrt wird, wurde bereits zuvor beschrieben, insbesondere bei der Beschreibung der abstrakten Operation ToNumber.  In diesem Fall ist es ziemlich offensichtlich <br>  dass die resultierenden zwei Werte von 42 gleich sind. <br><br><h3>  Vergleich: alles mit Booleschen Werten </h3><br>  Eine der gef√§hrlichsten Fallen bei der impliziten Konvertierung vom Typ == tritt auf, wenn versucht wird, Werte direkt mit wahr oder falsch zu vergleichen. <br><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; a == b; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Warten Sie, was ist hier los?  Wir wissen, dass ‚Äû42‚Äú die wahre Bedeutung ist (siehe weiter oben in diesem Kapitel).  Wie stellt sich heraus, dass ein Vergleich mit true mit der Aussage der strengen Gleichheit == <br>  gibt nicht wahr? <br><br>  Der Grund ist einfach und gleichzeitig t√§uschend gerissen.  Es ist leicht zu missverstehen, viele JS-Entwickler bem√ºhen sich nicht, es vollst√§ndig zu verstehen. <br><br>  Wir zitieren noch einmal die Spezifikation, Abschnitte 11.9.3.6‚Äì7: <br><br><ol><li>  Wenn Typ (x) vom Typ Boolean ist, geben Sie das Ergebnis des Vergleichs ToNumber (x) == y zur√ºck. </li><li>  Wenn Typ (y) vom Typ Boolean ist, geben Sie das Ergebnis des Vergleichs x == ToNumber (y) zur√ºck. </li></ol><br>  Mal sehen, was hier ist.  Erster Schritt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; x == y; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Typ (x) geh√∂rt wirklich zum Booleschen Typ, daher wird die ToNumber (x) -Operation ausgef√ºhrt, die true in 1 konvertiert. Nun wird Bedingung 1 == "42" berechnet.  Die Typen sind immer noch unterschiedlich, daher wiederholt sich der Algorithmus (fast rekursiv).  Wie im vorherigen Fall wird "42" in 42 umgewandelt, und Bedingung 1 == 42 ist offensichtlich falsch. <br><br>  Wenn Sie Operanden austauschen, bleibt das Ergebnis gleich: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; x == y; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Diesmal ist Typ (y) vom Typ Boolean, daher gibt ToNumber (y) 0 an. Die Bedingung "42" == 0 wird rekursiv zu 42 == 0, was nat√ºrlich falsch ist. <br><br>  Mit anderen Worten, der Wert "42" ist weder == wahr noch == falsch.  Diese Aussage erscheint auf den ersten Blick v√∂llig undenkbar.  Wie kann Bedeutung weder wahr noch falsch sein? <br><br>  Aber das ist das Problem!  Sie stellen die falsche Frage.  Obwohl es in der Tat nicht deine Schuld ist, ist es das Gehirn, das dich t√§uscht. <br><br>  Der Wert "42" ist zwar wahr, aber die Konstruktion "42" == wahr f√ºhrt √ºberhaupt keinen Booleschen / Transformationstest durch, was auch immer Ihr Gehirn sagt.  "42" konvertiert nicht in boolesch (true);  Stattdessen wird true in 1 konvertiert und dann wird ‚Äû42‚Äú in 42 konvertiert. <br><br>  Ob Sie es m√∂gen oder nicht, ToBoolean wird hier √ºberhaupt nicht verwendet, daher ist die Wahrheit oder Falschheit von ‚Äû42‚Äú f√ºr die == -Operation √ºberhaupt nicht wichtig!  Es ist wichtig zu verstehen, wie sich der == Vergleichsalgorithmus in allen verschiedenen Typkombinationen verh√§lt.  Wenn der boolesche Wert einseitig ist, wird er immer zuerst in eine Zahl konvertiert. <br><br>  Wenn Ihnen das seltsam vorkommt, sind Sie nicht allein.  Pers√∂nlich empfehle ich, unter keinen Umst√§nden == true oder == false zu verwenden.  Niemals. <br><br>  Aber denken Sie daran, dass ich hier nur von == spreche.  Die Konstruktionen === true und === false erlauben keine Typkonvertierung, daher sind sie vor der versteckten ToNumber-Konvertierung gesch√ºtzt. <br><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  (  !): if (a == true) { // .. } //   (  !): if (a === true) { // .. } //   ( ): if (a) { // .. } //  ( ): if (!!a) { // .. } //   ( ): if (Boolean( a )) { // .. }</span></span></code> </pre> <br>  Wenn Sie in Ihrem Code == true oder == false (lose Gleichheit mit Booleschen Werten) vermeiden, m√ºssen Sie sich niemals um diese Wahrheits- / Falschheitsfalle sorgen. <br><br><h3>  Vergleich: null mit undefiniert </h3><br>  Ein weiteres Beispiel f√ºr eine implizite Konvertierung tritt auf, wenn Sie die lax == -Gleichheit zwischen null und undefinierten Werten verwenden.  Ich werde wieder die ES5-Spezifikation zitieren, <br>  Abschnitte 11.9.3.2‚Äì3: <br><br><ol><li>  Wenn x null und y undefiniert enth√§lt, geben Sie true zur√ºck. </li><li>  Wenn x undefiniert und y null enth√§lt, geben Sie true zur√ºck. </li></ol><br>  Null und undefiniert im Vergleich zum nicht strengen Operator == sind gleich (dh sie werden ineinander konvertiert) und keine anderen Werte in der gesamten Sprache. <br><br>  F√ºr uns bedeutet dies, dass null und undefiniert zu Vergleichszwecken als nicht unterscheidbar angesehen werden k√∂nnen, wenn Sie den nicht strengen Gleichheitstestoperator == verwenden, der ihre gegenseitige implizite Konvertierung erm√∂glicht: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b; a == b; <span class="hljs-comment"><span class="hljs-comment">// true a == null; // true b == null; // true a == false; // false b == false; // false a == ""; // false b == ""; // false a == 0; // false b == 0; // false</span></span></code> </pre> <br>  Die Konvertierung zwischen null und undefiniert ist sicher und vorhersehbar, und kein anderer Wert kann f√ºr eine solche Pr√ºfung falsch positive Ergebnisse liefern.  Ich empfehle diese Konvertierung, damit sich null und undefined im Programm nicht unterscheiden und als ein einziger Wert interpretiert werden. <br><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. }</span></span></code> </pre> <br>  Die Pr√ºfung a == null wird nur bestanden, wenn doSomething () null oder undefiniert zur√ºckgibt und f√ºr einen anderen Wert (einschlie√ülich 0, false und "") fehlschl√§gt. <br><br>  Die explizite Form dieser Pr√ºfung, die solche Typkonvertierungen verbietet, sieht (meiner Meinung nach) viel h√§sslicher aus und funktioniert m√∂glicherweise etwas weniger effizient! <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> || a === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. }</span></span></code> </pre> <br>  Ich glaube, dass die Form a == null ein weiteres Beispiel f√ºr eine Situation ist, in der eine implizite Konvertierung das Lesen des Codes erleichtert, dies jedoch zuverl√§ssig und sicher tut. <br><br><h3>  Vergleich: Objekte und Nichtobjekte </h3><br>  Wenn ein Objekt / eine Funktion / ein Array mit einem einfachen skalaren Grundelement (Zeichenfolge, Zahl oder Boolescher Wert) verglichen wird, lautet die ES5-Spezifikation Folgendes (Abschnitt 11.9.3.8‚Äì9): <br><br><ol><li>  Wenn Typ (x) vom Typ String oder Number und Typ (y) vom Typ Object ist, geben Sie das Ergebnis des Vergleichs x == ToPrimitive (y) zur√ºck. </li><li>  Wenn Typ (x) vom Typ Objekt und Typ (y) vom Typ Zeichenfolge oder Zahl ist, geben Sie das Ergebnis des Vergleichs ToPrimitive (x) == y zur√ºck. </li></ol><br><blockquote>  M√∂glicherweise haben Sie bemerkt, dass in diesen Abschnitten der Spezifikation nur String und Number erw√§hnt werden, nicht jedoch Boolean.  Tatsache ist, dass, wie oben erw√§hnt, in den Abschnitten 11.9.3.6‚Äì7 sichergestellt wird, dass jeder boolesche Operand zuerst als Zahl dargestellt wird. </blockquote><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = [ <span class="hljs-number"><span class="hljs-number">42</span></span> ]; a == b; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  F√ºr den Wert [42] wird die abstrakte Operation ToPrimitive aufgerufen (siehe "Abstrakte Operationen"), die das Ergebnis "42" ergibt.  Von diesem Moment an bleibt die einfache Bedingung ‚Äû42‚Äú == 42 bestehen, die sich, wie wir bereits herausgefunden haben, in 42 == 42 verwandelt, so dass a und b bis zur Typkonvertierung gleich sind. <br><br><blockquote>  Wie zu erwarten, sind auch in diesem Fall alle Funktionen der abstrakten ToPrimitive-Operation ((toString (), valueOf ())) anwendbar. Dies kann sehr n√ºtzlich sein, wenn Sie eine komplexe Datenstruktur haben und dies m√∂chten Definieren Sie daf√ºr eine spezielle Methode valueOf (), die einen einfachen Wert f√ºr die √úberpr√ºfung der Gleichheit bereitstellen muss. </blockquote><br>  In Kapitel 3 wurde das ‚ÄûEntpacken‚Äú eines Objekt-Wrappers um einen Grundwert (wie z. B. in einem neuen String (‚Äûabc‚Äú)) untersucht, was zur R√ºckgabe des zugrunde liegenden Grundelements f√ºhrte <br>  Wert ("abc").  Dieses Verhalten h√§ngt mit der ToPrimitive-Transformation im == -Algorithmus zusammen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>( a ); <span class="hljs-comment"><span class="hljs-comment">//  ,  `new String( a )` a === b; // false a == b; // true</span></span></code> </pre> <br>  a == b gibt true an, weil b durch die ToPrimitive-Operation in den einfachen skalaren Grundprimitivwert "abc" konvertiert (oder "entpackt") wird, der dem Wert von a entspricht. <br><br>  Es gibt einige Werte, f√ºr die dies aufgrund anderer √ºbergeordneter Regeln im == Algorithmus nicht der Fall ist.  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>( a ); <span class="hljs-comment"><span class="hljs-comment">//  ,  `Object()` a == b; // false var c = undefined; var d = Object( c ); //  ,  `Object()` c == d; // false var e = NaN; var f = Object( e ); //  ,  `new Number( e )` e == f; // false</span></span></code> </pre> <br>  Die Werte null und undefiniert k√∂nnen nicht gepackt werden (sie haben keinen √§quivalenten Objekt-Wrapper), daher unterscheidet sich Object (null) nicht grundlegend von Object (): Beide Aufrufe erstellen das √úbliche <br>  ny Objekt. <br><br>  NaN kann in den entsprechenden Number-Objekt-Wrapper gepackt werden. Wenn == jedoch das Entpacken verursacht, schl√§gt der NaN == NaN-Vergleich fehl, da der NaN-Wert niemals gleich sich selbst ist (siehe Kapitel 2). <br><br>  ¬ªWeitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  25% Rabatt auf Gutschein f√ºr H√§ndler - <b>JavaScript</b> <br><br>  Nach Bezahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456730/">https://habr.com/ru/post/de456730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456710/index.html">Was ist eine Low-Code / No-Code-Plattform und CRM, CRM +, ERP</a></li>
<li><a href="../de456712/index.html">Selektive Verkehrsprotokollierung f√ºr SOAP-Dienste</a></li>
<li><a href="../de456714/index.html">Gleitkommazahlen verstehen (Teil 0)</a></li>
<li><a href="../de456716/index.html">Nicht sehr gro√üe Datenmengen</a></li>
<li><a href="../de456722/index.html">PostgreSQL-Rezepte: Asynchroner Taskplaner</a></li>
<li><a href="../de456736/index.html">PostgreSQL-Rezepte: cURL: Abrufen, Ver√∂ffentlichen und ... E-Mail</a></li>
<li><a href="../de456738/index.html">Neuronale Netze und tiefes Lernen, Kapitel 1: Verwenden neuronaler Netze zum Erkennen handgeschriebener Zahlen</a></li>
<li><a href="../de456744/index.html">10 Probleme, die ich mit Erinnerungen auf meinem Smartphone gel√∂st habe</a></li>
<li><a href="../de456746/index.html">Big Data - gro√üe Verantwortung, gro√üer Stress und viel Geld</a></li>
<li><a href="../de456748/index.html">2003 Thermodrucker von einem Flohmarkt: Was kann er 2019 tun?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>