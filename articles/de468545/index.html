<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔳 👱🏿 👨🏼‍🍳 "Alice, lass uns zum Frontend gehen!" 😸 🧓🏼 🛀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sprachassistenten sind keine ferne Zukunft, sondern Realität. Alexa, Siri, Google Now, Alice sind in intelligente Lautsprecher, Uhren und Telefone int...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Alice, lass uns zum Frontend gehen!"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/468545/">  Sprachassistenten sind keine ferne Zukunft, sondern Realität.  Alexa, Siri, Google Now, Alice sind in intelligente Lautsprecher, Uhren und Telefone integriert.  Sie verändern allmählich unsere Art der Interaktion mit Anwendungen und Geräten.  Über einen Assistenten können Sie die Wettervorhersage herausfinden, Flugtickets kaufen, ein Taxi bestellen, Musik hören und den Wasserkocher in der Küche einschalten, der in einem anderen Raum auf dem Sofa liegt. <br><br><img src="https://habrastorage.org/webt/mr/sw/35/mrsw35dh1qjeefkk8eb1f1ffvj0.jpeg"><br><br>  Siri oder Alexa sprechen hauptsächlich Englisch mit Benutzern, daher sind sie in Russland nicht so beliebt wie Alice von Yandex.  Für Entwickler ist Alice auch praktischer: Ihre Entwickler haben ein Blog, veröffentlichen praktische Tools auf GitHub und helfen beim Erstellen des Assistenten in neuen Geräten. <br><br>  <b>Nikita Dubko</b> (@dark_mefody auf Twitter) ist ein Entwickler der Yandex-Benutzeroberfläche, Organisator von MinskCSS- und MinskJS-Meetings und Nachrichtenredakteur für Webstandards.  Nikita arbeitet nicht in Yandex.Dialogs und ist in keiner Weise mit Yandex.Alisa verbunden.  Da er jedoch daran interessiert war zu verstehen, wie Alice funktioniert, versuchte er, ihre Fähigkeiten für das Web anzuwenden, und erstellte einen Bericht darüber bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FrontendConf</a> RIT ++.  Bei der Entschlüsselung von Nikitas Bericht berücksichtigen wir, welche Sprachassistenten beim Lesen dieses Materials nützlich sein und eine Fähigkeit aufbauen können. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yjTH8-O3CMA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Bots </h2><br>  Beginnen wir mit der Geschichte der Bots.  1966 erschien der <b>Eliza-</b> Bot und gab vor, ein Therapeut zu sein.  Es war möglich, mit ihm zu kommunizieren, und einige glaubten sogar, dass eine lebende Person ihnen antwortet.  1995 kam der <b>ALICE-</b> Bot heraus.  - Nicht zu verwechseln mit Alice.  Der Bot konnte sich als echte Person ausgeben.  Bis heute liegt in Open Source und wird finalisiert.  Leider besteht ALICE den Turing-Test nicht, aber dies hindert ihn nicht daran, Menschen irrezuführen. <br><br>  Im Jahr 2006 hat IBM eine riesige Wissensbasis und ausgefeilte Intelligenz in den Bot eingebracht - so entstand <b>IBM Watson</b> .  Dies ist ein riesiger Computercluster, der englische Sprache verarbeiten und einige Fakten preisgeben kann. <br><br>  Im Jahr 2016 führte Microsoft ein Experiment durch.  Sie kreierte den <b>Tay-</b> Bot, den sie auf Twitter startete.  Dort lernte der Bot Microblog basierend auf der Interaktion von Live-Abonnenten.  Infolgedessen wurde Tay ein Rassist und Frauenfeind.  Dies ist ein geschlossenes Konto.  Moral: Lass keine Kinder auf Twitter, er kann das Böse lehren. <br><br>  Dies sind jedoch alles Bots, mit denen Sie nicht zu Ihrem eigenen Vorteil kommunizieren können.  Im Jahr 2015 erschien "nützlich" auf Telegramm.  In anderen Programmen gab es Bots, aber Telegram sorgte für Furore.  Es war möglich, einen nützlichen Bot zu erstellen, der Informationen bereitstellt, Inhalte generiert und die Öffentlichkeit verwaltet - die Möglichkeiten sind groß und die API ist einfach.  Bots haben Bilder, Schaltflächen und QuickInfos hinzugefügt - eine Interaktionsoberfläche wurde angezeigt. <br><br>  Allmählich verbreitete sich die Idee auf fast alle Instant Messenger: Facebook, Viber, VKontakte, WhatsApp und andere Anwendungen.  Jetzt sind Bots ein Trend, sie sind überall.  Es gibt Dienste, mit denen Sie APIs für alle Plattformen sofort schreiben können. <br><br><h2>  Sprachassistenten </h2><br>  Die Entwicklung verlief parallel zu den Bots, aber wir gehen davon aus, dass die Ära der Assistenten später kam. <br><br>  Am 9. August 2011 erschien <b>Siri</b> .  Anfangs war es ein unabhängiges Projekt, in dem Apple etwas Interessantes sah, also kaufte ich es.  Dies ist der älteste beliebte Sprachassistent, der in das Betriebssystem integriert ist.  Ein Jahr später holte Google Apple schnell ein, indem er <b>den</b> Sprachassistenten von <b>Google Now</b> in sein Betriebssystem integrierte. <br><br>  Nach 2 Jahren veröffentlichte Microsoft <b>Microsoft Cortana</b> .  Es ist jedoch nicht klar, warum - der mobile Markt für Sprachassistenten scheint sie bereits verpasst zu haben.  Das Unternehmen versuchte, einen Sprachassistenten in Desktop-Systeme zu integrieren, als es bereits Probleme mit dem Markt für verschiedene Geräte gab.  <b>Amazon Alexa</b> kam etwas später in diesem Jahr heraus. <br><br><img src="https://habrastorage.org/webt/un/cw/eh/uncwehkki7vgcfyeh7148omczd4.jpeg"><br><br>  Assistenten haben sich weiterentwickelt.  Neben Softwaresystemen, die mit Sprache umgehen konnten, erschienen Sprecher mit Assistenten.  Laut Statistik hat Anfang 2019 jede dritte Familie in den USA eine intelligente Säule.  Dies ist ein riesiger Markt, in den Sie investieren können. <br><br>  Aber es gibt ein Problem - ausländische Assistenten haben eine schlechte Sprache mit Russisch.  Die Assistenten sind auf Englisch inhaftiert und verstehen es gut, aber bei der Kommunikation auf Russisch treten Übersetzungsschwierigkeiten auf.  Sprachen sind unterschiedlich und erfordern einen anderen Ansatz für die Verarbeitung natürlicher Sprache. <br><br><h2>  Alice </h2><br>  Alice wurde am 10. Oktober 2017 in der offenen Beta veröffentlicht.  Es ist wegen der russischen Sprache inhaftiert und dies ist sein großer Vorteil.  Alice versteht Englisch, aber schlimmer. <br><br><blockquote>  Alices Mission ist es, russischsprachigen Benutzern zu helfen. </blockquote><br>  Yandex ist ein großes Unternehmen und kann es sich leisten, Alice in all seine Anwendungen einzubetten, die irgendwie sprechen können. <br><br><ul><li>  Yandex.Browser. <br></li><li>  Yandex.Navigator. <br></li><li>  Yandex Station. <br></li><li>  Yandex.Phone. <br></li><li>  Yandex.Auto. <br></li><li>  Yandex.Drive. <br></li></ul><br>  Die Integration verlief so gut, dass auch Dritthersteller beschlossen, Alice zu bauen. <br><br><img src="https://habrastorage.org/webt/tc/na/aa/tcnaaauucjom0ojuvb6jpgdjzge.jpeg"><br><br>  Während der 2-jährigen Entwicklungszeit der Assistentin wurde sie in viele Dienste integriert und neue Fähigkeiten hinzugefügt.  Sie weiß, wie man Musik spielt, Bilder erkennt, in Yandex nach Informationen sucht und mit einem Smart Home arbeitet. <br><br><h3>  Warum so beliebt? </h3><br>  <b>Es ist praktisch, wenn die Hände beschäftigt sind</b> .  Ich bereite das Abendessen vor und möchte die Musik einschalten.  Gehen Sie zum Wasserhahn, waschen Sie Ihre Hände, trocknen Sie, öffnen Sie die Anwendung, finden Sie die gewünschte Spur - für eine lange Zeit.  Schneller und einfacher, einen Sprachbefehl zu geben. <br><br>  <b>Faulheit</b> .  Ich liege auf einem Sofa unter einer karierten Decke und möchte nicht aufstehen, um irgendwohin zu gehen und die Lautsprecher einzuschalten.  Wenn Sie faul sind, dann in vollem Umfang. <br><br>  <b>Der große Markt sind Apps für Kinder</b> .  Kleine Kinder können noch nicht lesen, schreiben und drucken, aber sie sprechen und verstehen Sprache.  Deshalb lieben Kinder Alice und lieben es, mit ihr zu kommunizieren.  Die Eltern sind ebenfalls zufrieden - es besteht keine Notwendigkeit zu suchen, was mit dem Kind zu tun ist.  Interessanterweise versteht Alice Kinder dank eines gut ausgebildeten neuronalen Netzwerks. <br><br>  <b>Verfügbarkeit</b>  Sehbehinderte Menschen können problemlos mit Sprachassistenten arbeiten. Wenn die Benutzeroberfläche nicht sichtbar ist, können Sie sie hören und Befehle erteilen. <br><br>  <b>Stimme schneller</b> .  Eine durchschnittliche Person, kein Entwickler, druckt durchschnittlich 30 Wörter pro Minute und sagt 120. Pro Minute werden viermal mehr Informationen per Sprache übertragen. <br><br>  <b>Die Zukunft</b> .  Fantastische Filme und futuristische Vorhersagen deuten darauf hin, dass die Zukunft mit Sprachschnittstellen verbunden ist.  Drehbuchautoren denken, dass Sprachsteuerung möglicherweise die Hauptmethode für die Interaktion mit Schnittstellen ist, bei denen das Bild nicht so wichtig ist. <br><br>  Laut Statistik verwenden 35 Millionen Menschen Alisa pro Monat.  In Belarus leben übrigens 9.475.600 Menschen.  Das heißt, ungefähr 3,5 Weißrussland benutzt Alice jeden Monat. <br><br>  Sprachassistenten erobern den Markt.  Prognosen zufolge wird es bis 2021 etwa zweimal wachsen.  Die heutige Popularität wird nicht aufhören, sondern weiter wachsen.  Immer mehr Entwickler erkennen, dass sie in diesen Bereich investieren müssen. <br><br><h3>  Entwicklerfähigkeiten </h3><br>  Es ist großartig, wenn Unternehmen in Sprachassistenten investieren.  Sie verstehen, wie sie in ihre Dienste integriert werden können.  Entwickler wollen aber auch irgendwie daran teilnehmen, und das Unternehmen selbst ist profitabel. <br><br>  Alexa hat Alexa Fähigkeiten.  Nach den dokumentierten Interaktionsmethoden versteht sie, was die Entwickler für sie geschrieben haben.  Google hat Actions gestartet - die Möglichkeit, etwas Eigenes in den Sprachassistenten zu integrieren. <br><br>  Alice hat auch Fähigkeiten - die Fähigkeit für Entwickler, etwas von Drittanbietern zu implementieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/682/cba/758/682cba758b31f41d75d55aca324645b1.jpg"><br><br>  Gleichzeitig gibt es einen alternativen Katalog von Fähigkeiten, nicht von Yandex, der von der Community unterstützt wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/445/c87/9a5/445c879a5d44b7da9f49f185826cbdbe.jpg"><br><br>  Es gibt gute Berichte darüber, wie Sprachanwendungen erstellt werden.  Zum Beispiel sprach <b>Pavel Guy</b> auf der AppsConf 2018 mit dem Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Erstellen einer Sprachanwendung am Beispiel von Google Assistance“</a> .  Enthusiasten sind aktiv an der Entwicklung von Sprachanwendungen beteiligt.  Ein Beispiel ist ein visuelles sprachaktiviertes Spiel von Ivan Golubev. <br><br>  Alice ist beliebt, obwohl im Wesentlichen alles, was sie tut, auf halbem Weg zwischen Stimme und Text liegt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/804/0fb/c3e/8040fbc3e31afcbee27651b7a77a2426.jpg"><br><br>  Alice weiß, wie man eine Stimme hört und sie gemäß ihren Algorithmen in einen Text umwandelt, eine Antwort erstellt und sie ausspricht.  Es scheint, dass dies nicht genug ist, aber es ist eine äußerst schwierige Aufgabe.  Viele Menschen arbeiten daran, dass Alice natürlich klingt, Akzente und die Sprache der Kinder richtig erkennt, versteht.  Yandex bietet so etwas wie einen Proxy, der alles durch sich selbst führt.  Atemberaubende Köpfe arbeiten, damit Sie die Ergebnisse ihrer Arbeit nutzen können. <br><br>  Alices Fähigkeiten - Yandex.Dialogs - haben eine Einschränkung.  Die Antwortzeit Ihrer API darf 1,5 Sekunden nicht überschreiten.  Und das ist logisch, denn wenn die Antwort hängt - warum warten? <br><br><blockquote>  Ist es wirklich wichtig, worüber Sie fragen müssen, wenn Sie immer noch keine Antwort erhalten? </blockquote><br>  Wenn wir Informationen mit unseren Ohren empfangen, werden Pausen vom Gehirn länger wahrgenommen als ähnliche Pausen in der visuellen Oberfläche.  Zum Beispiel Lader, Spinner - alles, was wir den Schnittstellen hinzufügen möchten, lenkt den Benutzer vom Warten ab.  Betrachten Sie alles als schnell. <br><br><h2>  Zeit für eine Demo </h2><br>  Alles ist in der Yandex.Dialog- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ausführlich beschrieben und immer auf dem neuesten Stand.  Ich werde mich nicht wiederholen.  Ich werde Ihnen sagen, was für mich interessant war, und zeigen, wie Sie schnell eine Demo erstellen, für die ich nur einen Abend verbracht habe. <br><br>  Beginnen wir mit der Idee.  Es gibt viele Fähigkeiten, es gibt Kataloge, aber ich habe nicht gefunden, was mir wichtig ist - dies ist ein Veranstaltungskalender am Frontend.  Stellen Sie sich vor, Sie wachen morgens auf: „Ich gehe heute zum Meeting.  Alice!  Gibt es dort etwas Interessantes? “, Und Alice antwortet Ihnen außerdem korrekt und unter Berücksichtigung Ihres Standorts. <br><br>  Wenn Sie an der Organisation von Konferenzen beteiligt sind, nehmen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">an GitHub teil</a> .  Sie können dort Veranstaltungen und Meetings abhalten und aus einem Kalender mehr über viele Veranstaltungen im Front-End der Welt erfahren. <br><br>  Ich nahm die bekannten Technologien, die zur Hand waren: Node.js und Express.  Immer noch Heroku, weil es kostenlos ist.  Die Anwendung selbst ist einfach: Es ist ein Server auf Node.js, einer Express-Anwendung.  Heben Sie einfach den Server an einem Port an und hören Sie auf Anfragen. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> express <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { router } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'routes'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express(); app.use(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, router); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = process.env.PORT || <span class="hljs-number"><span class="hljs-number">8000</span></span>; app.listen(port, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Server started on :${port}'</span></span>); });</code> </pre> <br>  Ich habe die Tatsache ausgenutzt, dass alles bereits im Webstandardkalender konfiguriert ist und aus einer großen Anzahl kleiner Dateien eine ICS-Datei heruntergeladen werden kann.  Warum sollte ich meine eigenen sammeln? <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// services/vendors/web-standards.js import axios from 'axios'; const axioslnstance = axios.create({ baseURL: 'https://web-standards.ru/' , }); export function getRemoteCal() { return axioslnstance.get('calendar.ics'); }</span></span></code> </pre> <br>  Stellen Sie sicher, dass alles schnell funktioniert. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Router } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wst <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'services/vendors/web-standards'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = Router(); router.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ wst .getRemoteCal() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vendorResponse</span></span></span><span class="hljs-function"> =&gt;</span></span> parseCalendar(vendorResponse.data)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">events</span></span></span><span class="hljs-function"> =&gt;</span></span> { res.json({ events }); }) .catch(next); });</code> </pre> <br>  Verwenden Sie GET-Methoden für Tests.  Die Fähigkeiten arbeiten mit POST-Methoden, sodass GET-Methoden ausschließlich zum Debuggen verwendet werden können.  Ich habe eine solche Methode implementiert.  Er lädt lediglich dasselbe ICS herunter, analysiert es und gibt es in JSON-Form aus. <br><br>  Ich habe die Demo schnell erstellt und die fertige knotenbezogene Bibliothek genommen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ical <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'node-ical'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseCalendar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { ical.parseICS(str, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { reject(err); } resolve(data); }); }); }</code> </pre> <br>  Sie weiß, wie man das ICS-Format analysiert.  Am Ausgang erzeugt es ein solches Blatt: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"2018-10-04-f rontendconf@https://web-standards.ru/"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"VEVENT"</span></span>, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"uid"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-10-04-f rontendconf@https://web-standards.ru/"</span></span>, <span class="hljs-string"><span class="hljs-string">"sequence"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"dtstamp"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-05-25T21:23:50.000Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-10-04T00:00:00.000Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"datetype"</span></span>: <span class="hljs-string"><span class="hljs-string">"date"</span></span>, <span class="hljs-string"><span class="hljs-string">"end"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-10-06T00:00:00.000Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"MICROSOFT-CDO-ALLDAYEVENT"</span></span>: <span class="hljs-string"><span class="hljs-string">"TRUE"</span></span>, <span class="hljs-string"><span class="hljs-string">"MICROSOFT-MSNCALENDAR-ALLDAYEVENT"</span></span>: <span class="hljs-string"><span class="hljs-string">"TRUE"</span></span>, <span class="hljs-string"><span class="hljs-string">"summary"</span></span>: <span class="hljs-string"><span class="hljs-string">"FrontendConf"</span></span>, <span class="hljs-string"><span class="hljs-string">"location"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://frontendconf.ru/moscow/2018"</span></span> } }</code> </pre> <br>  Um die erforderlichen Informationen zu analysieren und dem Benutzer der Fertigkeit zur Verfügung zu stellen, reicht es aus, den Zeitpunkt des Beginns und des Endes der Veranstaltung, ihren Namen, ihren Link und vor allem die Stadt zu kennen.  Ich möchte, dass die Fähigkeit nach Ereignissen in der Stadt sucht. <br><br><h3>  Eingabeformat </h3><br>  Wie geben Yandex.Dialogs Informationen zurück?  Eine in die mobile Anwendung integrierte Spalte oder ein Sprachassistent hört Ihnen zu, und Yandex-Server verarbeiten das, was sie hören, und senden als Antwort ein Objekt: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"meta"</span></span>: { … }, <span class="hljs-string"><span class="hljs-string">"request”: { … }, "</span></span>session<span class="hljs-string"><span class="hljs-string">": { … }, "</span></span>version<span class="hljs-string"><span class="hljs-string">": "</span></span><span class="hljs-number"><span class="hljs-number">1.0</span></span><span class="hljs-string"><span class="hljs-string">" }</span></span></code> </pre> <br>  Das Objekt enthält Metainformationen, Informationen zur Anforderung, zur aktuellen Sitzung und zur Version der API, falls diese plötzlich aktualisiert wird - Fähigkeiten sollten nicht unterbrochen werden. <br><br>  Es gibt viele nützliche <b>Informationen</b> in <b>Metainformationen</b> . <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"meta"</span></span>: { <span class="hljs-string"><span class="hljs-string">"locale"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru-RU"</span></span>, <span class="hljs-string"><span class="hljs-string">"timezone"</span></span>: <span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>, <span class="hljs-string"><span class="hljs-string">"client_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru.yandex.searchplugin/5.80…”, "</span></span>interfaces<span class="hljs-string"><span class="hljs-string">": { "</span></span>screen<span class="hljs-string"><span class="hljs-string">": {} } } }</span></span></code> </pre> <br>  " <b>Gebietsschema</b> " - wird verwendet, um die Region des Benutzers zu verstehen. <br><br>  " <b>Zeitzone</b> " kann verwendet werden, um kompetent mit der Zeit zu arbeiten und den Standort des Benutzers genauer zu bestimmen. <br><br>  " <b>Schnittstellen</b> " - Informationen zur Verfügbarkeit des Bildschirms.  Wenn kein Bildschirm vorhanden ist, sollten Sie darüber nachdenken, wie der Benutzer die Bilder sehen wird, wenn Sie sie in der Antwort angeben.  Wenn es einen Bildschirm gibt, nehmen wir Informationen darüber heraus. <br><br>  Das Anforderungsformat ist <b>einfach</b> : <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"request"</span></span>: { <span class="hljs-string"><span class="hljs-string">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">"      16"</span></span>, <span class="hljs-string"><span class="hljs-string">"original_utterance"</span></span>: <span class="hljs-string"><span class="hljs-string">"     , 16"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleUtterance"</span></span>, <span class="hljs-string"><span class="hljs-string">"nlu"</span></span>: { <span class="hljs-string"><span class="hljs-string">"tokens"</span></span>: [ <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"16"</span></span>], <span class="hljs-string"><span class="hljs-string">"entities"</span></span>: [...] } } }</code> </pre> <br>  Es gibt an, was der Benutzer gesagt hat, den Anforderungstyp und die <b>NLU - Natural-Language Unit</b> .  Dies ist genau die Magie, die die Yandex.Dialog-Plattform annimmt.  Sie bricht den ganzen Satz, den sie erkannt hat, in Token - Wörter.  Es gibt dort auch Entitäten, über die wir etwas später sprechen werden.  Die Verwendung von Token reicht für den Anfang aus. <br><br>  Wir haben diese Worte und was tun wir damit?  Der Benutzer hat etwas gesagt, aber er kann die Wörter in einer anderen Reihenfolge sagen, das "Nicht" -Partikel verwenden, das alles dramatisch verändert, oder sogar "Morgen" statt "Morgen" sagen.  Wenn der Benutzer auch Weißrussisch spricht, gibt es eine „Tasche“, nicht am Morgen.  Ein großes Projekt erfordert die Hilfe von Linguisten, um eine Fähigkeit zu entwickeln, die alles versteht.  Aber ich habe eine einfache Aufgabe erledigt, also habe ich auf Hilfe von außen verzichtet. <br><br><h2>  Kann ein Computer wie eine Person sprechen? </h2><br>  Dies ist eine philosophische Frage, die der Turing-Test zu beantworten versucht.  Der Test ermöglicht es mit einer gewissen Wahrscheinlichkeit festzustellen, dass künstliche Intelligenz eine Person verkörpern kann.  Es gibt einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Loebner-Preis</a> , um zu erhalten, welche Programme den Turing-Test bestehen.  Die Entscheidung wird von einer Jury getroffen.  Um den Preis zu erhalten, müssen Sie 33% der Richter oder mehr austricksen.  Erst 2014 täuschte der Bot <b>Zhenya Gustman</b> aus St. Petersburg die Kommission endgültig. <br><br><pre> <code class="plaintext hljs">[15:46:05] Dudge: My favourite music is contemporary Dazz, what do you prefer? [15:46:14] Eugene: To be short I'll only say that I HATE Britnie [sic] Spears. All other music is OK compared to her. [15:47:06] Dudge: do you like to play any musical instruments [15:47:23] Eugene: I'm tone deaf, but my guinea pig likes to squeal Beethoven's Ode to Doy every morning. I suspect our neighbors want to cut his throat ... Could you tell me about your job, by the way? [15:48:02] Dudge: Guinea pig? Are you an animal lover [15:48:08] Eugene: Yeah. A nice little guinea pig. Not some annoying chatter bot.</code> </pre> <br>  Im Jahr 2019 hat sich nichts wirklich geändert - es ist immer noch schwierig, eine Person zu täuschen.  Aber wir bewegen uns allmählich darauf zu. <br><br><h2>  Skriptarbeit </h2><br>  Eine gute Fähigkeit erfordert einen interessanten Anwendungsfall.  Ich empfehle ein Buch, das es wert ist, gelesen zu werden - „Entwerfen von Sprachbenutzeroberflächen: Prinzipien von Konversationserfahrungen“.  Es ist großartig, Skripte für Sprachschnittstellen zu schreiben und die Aufmerksamkeit der Benutzer zu erhalten.  Ich habe das Buch nicht auf Englisch gesehen, aber es ist recht leicht zu lesen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/871/3e1/222/8713e12220b6ce7a65563775dc2b49f2.jpg"><br><br>  Das erste, was Sie tun müssen, um eine Fertigkeit zu entwickeln, ist eine Begrüßung. <br><br><blockquote>  „Während du dir überlegst, was du sagen sollst, mach Knicks!  Das spart Zeit. “ </blockquote><br>  Wenn sich die Fertigkeit einschaltet, müssen Sie den Benutzer von der ersten Sekunde an irgendwie festhalten, und dazu müssen Sie erklären, wie die Fertigkeit verwendet wird.  Stellen Sie sich vor, der Benutzer hat die Fertigkeit gestartet und es herrscht Stille.  Woher weißt du, ob eine Fertigkeit überhaupt funktioniert?  Geben Sie dem Benutzer Anweisungen, z. B. Schaltflächen auf dem Bildschirm. <br><br><h3>  Einfacher Dialog </h3><br>  Zeichen des einfachen Dialogs.  Die Liste wurde von Ivan Golubev erfunden, und der Wortlaut gefällt mir sehr gut. <br><br><ul><li>  <b>L</b> persönlich. <br></li><li>  Natürlich. <br></li><li>  Flexibel. <br></li><li>  Ontext. <br></li><li>  <b>Und</b> natsiative. <br></li><li>  Brief <b>J.</b> <br></li></ul><br>  <b>Persönlich</b> bedeutet, dass der Bot einen Charakter haben muss.  Wenn Sie mit Alice sprechen, werden Sie verstehen, dass sie einen Charakter hat - die Entwickler kümmern sich darum.  Daher muss Ihr Bot für Organizität eine "Persönlichkeit" haben.  Geben Sie Sätze mit mindestens einer Stimme aus und verwenden Sie dieselben verbalen Konstruktionen.  Dies hilft, den Benutzer zu halten. <br><br>  <b>Natürlich</b> .  Wenn die Benutzeranforderung einfach ist, sollte die Antwort dieselbe sein.  Während der Kommunikation mit dem Bot muss der Benutzer verstehen, was als nächstes zu tun ist. <br><br>  <b>Flexibel</b> .  Mach dich bereit für alles.  Es gibt viele Synonyme auf Russisch.  Der Benutzer kann von der Spalte ablenken und die Konversation an den Gesprächspartner übertragen und dann zur Spalte zurückkehren.  All dies ist schwer zu handhaben.  Aber wenn du einen Bot gut machen willst, musst du.  Beachten Sie, dass ein gewisser Prozentsatz der Nichtanerkennung weiterhin besteht.  Seien Sie darauf vorbereitet - schlagen Sie Optionen vor. <br><br>  <b>Kontextuell</b> - der Bot sollte sich im Idealfall daran erinnern, was zuvor passiert ist.  Dann wird das Gespräch lebhaft. <br><br>  <i>- Alice, wie ist das Wetter heute?</i> <br>  <i>- Heute im Bezirk von +11 bis +20, bewölkt, mit Lichtungen.</i> <br>  <i>- Und morgen?</i> <br>  <i>- Morgen im Bezirk von +14 bis +27, bewölkt, mit Lichtungen.</i> <br><br>  Stellen Sie sich vor, Ihr Bot kann den Kontext nicht speichern.  Was bedeutet dann für ihn die Bitte "und morgen"?  Wenn Sie wissen, wie man einen Kontext wie Alice beibehält, können Sie die vorherigen Ergebnisse verwenden, um die Antworten in der Fertigkeit zu verbessern. <br><br>  <b>Proaktiv</b> .  Wenn der Benutzer langweilig wird, sollte der Bot ihn auffordern: "Klicken Sie auf diese Schaltfläche!", "Schauen Sie, ich habe ein Bild für Sie!", "Folgen Sie dem Link."  Der Bot sollte Ihnen sagen, wie Sie damit arbeiten sollen. <br><br>  Der Bot sollte <b>kurz sein</b> .  Wenn eine Person lange spricht, ist es für sie schwierig, die Aufmerksamkeit des Publikums zu erhalten.  Mit dem Bot ist es noch komplizierter - es ist nicht schade, es ist leblos.  Um Aufmerksamkeit zu erregen, müssen Sie ein Gespräch interessant oder kurz und prägnant aufbauen.  Dies hilft beim Schreiben.  Schneiden Sie es. "  Wenn Sie mit der Entwicklung von Bots beginnen, lesen Sie dieses Buch. <br><br><h3>  Datenbanken </h3><br>  Bei der Entwicklung eines komplexen Bots können Sie nicht auf eine Datenbank verzichten.  Meine Demo verwendet keine Datenbank, es ist einfach.  Wenn Sie jedoch einige Datenbanken verschrauben, können Sie die Informationen über die Sitzung des Benutzers zumindest zum Speichern des Kontexts verwenden. <br><br>  Es gibt eine Nuance: Yandex.Dialogs geben keine privaten Benutzerinformationen weiter, z. B. Name, Standort.  Diese Informationen können jedoch vom Benutzer angefordert, gespeichert und mit einer bestimmten Sitzungs-ID verknüpft werden, die Yandex.Dialogs in der Anforderung sendet. <br><br><h3>  Zustandsmaschine </h3><br>  Wenn man komplexe Szenarien erwähnt, kann man sich nur an die Zustandsmaschine erinnern.  Dieser Mechanismus wurde lange Zeit hervorragend für die Programmierung von Mikrocontrollern und manchmal auch für das Frontend verwendet.  Die Zustandsmaschine ist für das Szenario praktisch: Es gibt Zustände, von denen wir für bestimmte Phrasen zu anderen Zuständen übergehen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/914/9bb/e4d/9149bbe4d192a9d9e4ee0a42dc315044.jpg"><br><br>  Übertreibe es nicht.  Sie können sich mitreißen lassen und eine riesige Zustandsmaschine erstellen, die schwer herauszufinden ist - die Pflege eines solchen Codes ist schwierig.  Es ist einfacher, ein Skript zu schreiben, das aus kleinen Unterskripten besteht. <br><br><h3>  Unverständlich?  Geben Sie an </h3><br>  Sag niemals: "Wiederhole es bitte."  Was macht eine Person, wenn sie gebeten wird, es zu wiederholen?  Er spricht lauter.  Wenn der Benutzer Ihre Fähigkeiten anschreit, verbessert sich die Erkennung nicht.  Stellen Sie eine klärende Frage.  Wenn ein Teil des Benutzerdialogs erkannt wird und etwas fehlt, überprüfen Sie den fehlenden Block. <br><br>  Die Texterkennung ist die schwierigste Aufgabe bei der Entwicklung eines Bots, daher hilft manchmal die Klärung nicht.  In jeder unverständlichen Situation besteht die beste Lösung darin, alles an einem Ort zu sammeln, zu protokollieren und dann zu analysieren und in Zukunft zu verwenden.  Zum Beispiel, wenn der Benutzer offen gesagt seltsame und unverständliche Dinge sagt. <br><br>  <i>„Es hat gekocht.</i>  <i>Cremige Küste</i> <i><br></i>  <i>Stocherte auf nav.</i> <i><br></i>  <i>Und grunzte grunzte.</i> <i><br></i>  <i>Wie eine Mumie in einem Film. “</i> <br><br>  Benutzer können unerwartet einen Neologismus verwenden, der etwas bedeutet, und er muss irgendwie verarbeitet werden.  Infolgedessen sinkt der Erkennungsprozentsatz.  Mach dir keine Sorgen - logge dich ein, studiere und verbessere deinen Bot. <br><br><h3>  Stoppwort </h3><br>  Es muss etwas geben, das die Fertigkeit aufhält, wenn Sie sie verlassen möchten.  Alice weiß, wie man nach den Sätzen aufhört: "Alice, das ist genug!"  oder "Alice, hör auf!"  Benutzer lesen jedoch normalerweise keine Anweisungen.  Antworten Sie daher zumindest auf das Wort „Stop“ und geben Sie die Kontrolle an Alice zurück. <br><br>  Nun sehen wir uns den Code an. <br><br><h2>  Zeit für eine Demo </h2><br>  Ich möchte die folgenden Sätze implementieren. <br><br><ul><li>  Kommende Events in einer Stadt. <br></li><li>  Name der Stadt: "Ereignisse in Moskau", "Ereignisse in Minsk", "St. Petersburg", um die dort gefundenen Ereignisse zu zeigen. <br></li><li>  Stoppwörter: "Stopp", "Genug."  "Danke", wenn der Benutzer das Gespräch mit diesem Wort beendet.  Idealerweise wird hier jedoch ein Linguist benötigt. <br></li></ul><br>  Für "bevorstehende Veranstaltungen" ist jede Phrase geeignet.  Ich habe einen faulen Bot erstellt, und wenn er nicht versteht, was sie sagen, gibt er Informationen über die nächsten drei Ereignisse heraus. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"request"</span></span>: { <span class="hljs-string"><span class="hljs-string">"nlu"</span></span>: { <span class="hljs-string"><span class="hljs-string">"entities"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"tokens"</span></span>: { <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"YANDEX.GEO"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>: { <span class="hljs-string"><span class="hljs-string">"house_number"</span></span>: <span class="hljs-string"><span class="hljs-string">"16"</span></span>, <span class="hljs-string"><span class="hljs-string">"street"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"city"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } ] } } }</code> </pre> <br>  Yandex verbessert schrittweise die Yandex.Dialogs-Plattform und gibt Entitäten aus, die es erkennen konnte.  Zum Beispiel weiß er, wie man Adressen aus einem Text erhält und ihn in Teile sortiert: Stadt, Land, Straße, Haus.  Er weiß auch, wie man absolute und relative Zahlen und Daten erkennt.  Er wird verstehen, dass das Wort „Morgen“ das heutige Datum ist, zu dem eines hinzugefügt wird. <br><br><h3>  Antwort an den Benutzer </h3><br>  Sie müssen irgendwie auf Ihren Benutzer reagieren.  Die gesamte Fertigkeit besteht aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">209 Zeilen</a> mit der letzten leeren Zeile.  Nichts kompliziertes - Arbeit für den Abend. <br><br>  Sie bearbeiten lediglich die POST-Anfrage und erhalten eine „Anfrage“. <br><br><pre> <code class="javascript hljs">router.post(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, (req/ res, next) ⇒ { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request = req.body;</code> </pre> <br>  Außerdem habe ich die Zustandsmaschine nicht sehr kompliziert, sondern bin nach Prioritäten vorgegangen.  Wenn der Benutzer lernen möchte, wie man den Bot benutzt, ist dies der erste Start oder eine Bitte um Hilfe.  Deshalb bereite ich ihm nur eine "Leere Antwort" vor - so nenne ich es. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needHelp(request.request)) { res.json(prepareEmptyResponse(request)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  Die NeedHelp-Funktion ist einfach. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needHelp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.nlu.token.length ≤ <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; req.nlu.tokens.includes(<span class="hljs-string"><span class="hljs-string">''</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.nlu.token.length = <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; req.type ≠ <span class="hljs-string"><span class="hljs-string">'ButtonPressed'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Wenn wir keine Token haben, stehen wir am Anfang der Anfrage.  Der Benutzer hat gerade die Fertigkeit gestartet oder nichts gefragt.  Sie müssen überprüfen, ob die Token Null sind und dies keine Schaltfläche ist. Wenn Sie auf die Schaltfläche klicken, sagt der Benutzer auch nichts.  Wenn ein Benutzer um Hilfe bittet, gehen wir die Token durch und suchen nach dem Wort "Hilfe".  Die Logik ist einfach. <br><br>  Wenn der Benutzer anhalten möchte. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needToStop(request.request)) { res.json(prepareStopResponse(request)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  Also suchen wir nach einer Art Stoppwort im Inneren. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needStop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stopWords = [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.nlu.token.length ≤ <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; stopWords.some(w ⇒ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.nlu.token.includes(w)); }</code> </pre> <br>  In allen Antworten müssen Sie die Informationen zurückgeben, die Yandex.Dialogs über die Sitzung gesendet hat.  Er muss irgendwie mit Ihrer Antwort und der Anfrage des Benutzers übereinstimmen. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StopResponse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { session, version } = req; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">response</span></span>: { <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">' .  !'</span></span>, <span class="hljs-attr"><span class="hljs-attr">end_session</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, session, version, }; }</code> </pre> <br>  Daher, was Sie in den Variablen "Sitzung" und "Version" erhalten haben, kehren Sie zurück, und alles wird in Ordnung sein.  Bereits in der Antwort können Sie Alice einen Text geben, um ihn auszusprechen, und "Sitzung beenden: wahr" bestehen.  Dies bedeutet, dass wir die Skill-Sitzung beenden und die Kontrolle an Alice übertragen. <br><br>  Wenn Sie eine Fertigkeit aufrufen, schaltet sich Alice aus.  Alles, was sie hört, sind ihre Stoppwörter, und Sie steuern den Prozess der Arbeit mit der Fähigkeit vollständig.  Daher müssen Sie die Kontrolle zurückgeben. <br><br>  Mit einer leeren Anfrage ist interessanter. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">"response"</span></span>: { <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">'!        -  .'</span></span>, <span class="hljs-string"><span class="hljs-string">"tts"</span></span>: <span class="hljs-string"><span class="hljs-string">'!        -  .'</span></span>, <span class="hljs-attr"><span class="hljs-attr">buttons</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: {} hide: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: { <span class="hljs-attr"><span class="hljs-attr">city</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, } hide: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, ], <span class="hljs-attr"><span class="hljs-attr">end_session</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, session, version, };</code> </pre> <br>  Es gibt ein <b>TTS-</b> Feld ( <b>Text To Speech</b> ) - <b>Sprachsteuerung</b> .  Dies ist ein einfaches Format, mit dem Sie den Text auf verschiedene Arten lesen können.  Zum Beispiel hat das Wort "multidisziplinär" zwei Schwerpunkte in der russischen Sprache - eine primäre, die zweite sekundäre.  Die Aufgabe ist, dass Alice dieses Wort richtig aussprechen konnte.  Sie können es mit einem Leerzeichen brechen: <br><br><pre> <code class="plaintext hljs">+ +</code> </pre> <br>  Sie wird ihn als zwei verstehen.  Plus Akzent wird hervorgehoben. <br><br>  Es gibt Pausen in der Rede - Sie setzen ein Interpunktionszeichen, das durch Leerzeichen getrennt ist.  So können Sie dramatische Pausen erstellen: <br><br><pre> <code class="plaintext hljs"> — - - - - - - - - + </code> </pre> <br>  Ich habe bereits über <b>Knöpfe gesprochen</b> .  Sie sind wichtig, wenn Sie nicht mit einer Spalte kommunizieren, sondern beispielsweise mit der mobilen Yandex-Anwendung. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"response"</span></span>: { <span class="hljs-string"><span class="hljs-string">"buttons"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Frontend Conf"</span></span>, <span class="hljs-string"><span class="hljs-string">"payload"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://frontendconf.ru/moscow-rit/2019"</span></span> , <span class="hljs-string"><span class="hljs-string">"hide"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ] } }</code> </pre> <br>  Schaltflächen sind auch Hinweise für Phrasen, die Sie in Ihren Fähigkeiten wahrnehmen.  Fähigkeiten funktionieren in Yandex-Anwendungen - Sie kommunizieren mit der Benutzeroberfläche.  Wenn Sie einige Informationen weitergeben möchten - geben Sie einen Link an, der Benutzer klickt darauf.  Sie können hierfür auch Schaltflächen hinzufügen. <br><br>  Es gibt ein Feld "Nutzlast", in dem Sie Daten hinzufügen können.  Sie werden dann mit einer „Anfrage“ zurückkommen - Sie wissen beispielsweise, wie Sie diese Schaltfläche markieren. <br><br>  Sie können die <b>Stimmen</b> auswählen, die Ihre Fähigkeiten sprechen. <br><br><ul><li>  <b>Alice</b> ist <b>Alices</b> Standardstimme.  Optimiert für kurze Interaktionen. <br></li><li>  Oksana - die Stimme von Yandex.Navigator. <br></li><li>  Jane <br></li><li>  Zahar. <br></li><li>  Ermil. <br></li><li>  <b>Erkan Yavas</b> - für lange Texte.  Ursprünglich erstellt, um Nachrichten zu lesen. <br></li></ul><br>  Um <b>die Fertigkeit</b> zu <b>vervollständigen</b> , geben Sie einfach "end_session: true" zurück. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"response"</span></span>: { <span class="hljs-string"><span class="hljs-string">"end_session"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><h3>  Was ist mit der Demo passiert? </h3><br>  Zuerst filtere ich nach Datum. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterByDate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">events</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> events.filter(event ⇒ { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> current = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(event.start).getTime(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (start &gt; current) || (event.end &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(event.end).getTime() &gt; current &amp;&amp; start ≤ current); }); }</code> </pre> <br>  Die Logik ist einfach: Bei allen Ereignissen, die ich aus dem Kalender analysiert habe, nehme ich diejenigen, die in Zukunft stattfinden werden, oder sie gehen jetzt.  Es ist wahrscheinlich seltsam, nach vergangenen Ereignissen zu fragen - bei der Fähigkeit geht es nicht darum. <br><br>  Als nächstes ging es darum, an Ort und Stelle zu filtern. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterByPlace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">events, req</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cities = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoEntities = req.nlu.entities.filter(e ⇒ e.type = <span class="hljs-string"><span class="hljs-string">'YANDEX.GEO'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.payload &amp;&amp; req.payload.city) cities.add(req.payload.city); geoEntities.forEach(e ⇒ { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> city = e.value.city &amp;&amp; e.value.city.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (city &amp;&amp; !cities.has(city)) { cities.add(city); } });</code> </pre> <br>  Unter "Entitäten" finden Sie die Entität YANDEX.GEO, die den Speicherort verfeinert.  Wenn die Entität eine Stadt hat, fügen Sie sie unserem Set hinzu.  Als nächstes ist die Logik ebenfalls einfach.  Wir suchen diese Stadt in Token, und wenn sie dort ist, suchen wir nach dem, was der Benutzer will.  Wenn nicht, schauen wir uns alle „Orte“ und „Ereignisse“ an, die wir haben. <br><br>  Angenommen, Yandex hat nicht erkannt, dass es sich um YANDEX.GEO handelt, aber der Benutzer hat die Stadt benannt - er war sich sicher, dass dort etwas los war.  Wir gehen in „Events“ durch alle Städte und suchen das gleiche in Token.  Es stellt sich ein Kreuzvergleich von Arrays heraus.  Natürlich nicht der produktivste Weg, aber was ist.  Das ist die ganze Fähigkeit! <br><br>  Bitte schimpfen Sie nicht mit mir für den Code - ich habe ihn schnell geschrieben.  Dort ist alles primitiv, aber versuchen Sie es zu benutzen oder spielen Sie einfach herum. <br><br><h3>  Fähigkeit veröffentlichen </h3><br>  Gehen Sie zur Seite Yandex.Dialogs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38e/4d1/ca6/38e4d1ca6e2f548fea625649f85c834f.jpg"><br><br>  Wähle eine Fertigkeit in Alice.  Klicken Sie auf die Schaltfläche "Dialog erstellen" und Sie gelangen in das Formular, das Sie mit Ihren Daten ausfüllen müssen. <br><br><ul><li>  <b>Der Name</b> wird im Dialog stehen. <br></li><li>  <b>Aktivierungsname</b> .  Wenn Sie den Aktivierungsnamen "Web Standards Calendar" durch einen Bindestrich auswählen, erkennt Alice ihn nicht - sie hört keine Bindestriche.  Wir sagen Wörter ohne Bindestriche, und die Aktivierung funktioniert nicht.  Um Geld zu verdienen, setzen Sie den Namen auf "Web Standards Calendar". <br></li><li>  <b>Aktivierungsphrasen</b> zum Starten der Fertigkeit.  Wenn dies ein Spiel ist, dann "Lass uns etwas spielen", "Frag jemanden".  Das Set ist begrenzt, aber das liegt daran, dass solche Sätze für Alice aktiviert sind.  Sie muss verstehen, dass es Zeit ist, eine Fertigkeit zu erlernen. <br></li><li>  <b>Webhook-URL</b> - dieselbe Adresse, an die Alice POST-Anfragen sendet. <br></li><li>  <b>Die Stimme</b> .  Der Standardwert ist Oksana.  Daher haben viele im Katalog ihre Stimme, nicht Alice. <br></li><li>  <b>Ist ein Gerät mit Bildschirm erforderlich?</b>  Wenn Bilder vorhanden sind, ist die Verwendung der Fertigkeit auf Sie beschränkt. In der Spalte kann der Benutzer sie nicht starten. <br></li><li>  <b>Private Fähigkeiten</b> sind ein wichtiges Feld für Entwickler.  Wenn Sie nicht bereit sind, die Fertigkeit öffentlich zu veröffentlichen, schon weil sie roh ist, wird sie nicht im Katalog angezeigt, was den Datenschutz einschränkt.  Private Fähigkeiten werden schnell gemildert - in ein paar Stunden.  Solche Fähigkeiten müssen nicht gründlich getestet werden - genug, um mit dem Aktivierungsnamen übereinzustimmen.  Da der Benutzer sie nicht im Katalog findet, sind sie ihnen gegenüber loyaler. <br></li><li>  <b>Hinweise für den Moderator</b> .  Ich bat den Moderator um Hilfe: "Ich brauche wirklich die Fähigkeiten für die Demo auf der Konferenz!"  - und ich habe es geschafft, schnell durch die Moderation zu kommen. <br></li><li>  <b>Urheberrechte</b> .  Wenn Sie nicht in einer bedingten Bank arbeiten und sich dazu entschließen, eine Fähigkeit dafür zu erstellen, müssen Sie nachweisen, dass Sie das Recht dazu haben.  Plötzlich werden sie zu dir kommen?  Und sie werden definitiv kommen, und zwar über den Distributor, also Yandex, der keine zusätzlichen Probleme benötigt. </li></ul><br>  Fertig - Senden Sie die Fertigkeit zur Moderation, und Sie können testen. <br><br><h2>  Testen </h2><br>  Ich habe einen banalen Express-Server geschrieben.   API,    .   , , «alice-tester» —      ,   . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> assert = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'assert'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'alice-tester'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'should show help'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> user.enter(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> user.say(<span class="hljs-string"><span class="hljs-string">'  ?'</span></span>); assert.equal(user.response.text, <span class="hljs-string"><span class="hljs-string">'    .'</span></span>); assert.equal(user.response.tts, <span class="hljs-string"><span class="hljs-string">'    +.'</span></span>); assert.deepEqual(user.response.buttons, [{<span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">hide</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}]); }]);</code> </pre><br>       .,     «». <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ee/4ea/71f/2ee4ea71f971a916074c47ffc3434ef0.jpg"><br><br>  ,   ,      .   ,     : , ,     .   ,   —    ,    .    Postman —  . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> .</a> .   Just AI.   ,   ,          . <br><br>  <b> </b> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dialogs.home.popstas.ru</a>  URL, ,  localhost.    ,     debug.    ,      localhost. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8a/2d0/706/d8a2d07069f511e397d6a77f8bf4fd0b.jpg"><br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b> </b></a> .  —    .    URL  ,    -       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/243/89a/f0b/24389af0bfe571fc85a0b937e0a64406.jpg"><br><br><blockquote>     —     . </blockquote><br> ,    , ,  . <br><br>  —    <b> </b> .  ,    ,    ,   ,  ,    . - -           . <br><br><h2>    </h2><br>         <b>Dialogflow</b> ,     Google Now. ,    —  ,     — . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/471/fe9/b76/471fe9b76fd59e898ed4dae0a455733a.jpg"><br><br>    ,      .      .   ,         .     ,    . <br><br>   Google Dialogflow  .,  <b>Dialogflower</b> .          Alexa,   Google Now,   . —   API,      . <br><br>   ,     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aimyloqic</a> —    .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zenbot</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tortu</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alfa.Bot</a> —  ,   .  Ich empfehle es! <br><br><h2>     </h2><br> <b>   FAQ</b> .    ,     .    ,      ,  . <br><br> <b></b> .   ,  ,     ,     .    —   ,    .     ,      .    ,    . <br><br>    <b>IFTTT</b> ,      —     Trello.    —    API.         ,  ,     .        , IFTT —     . <br><br>    <b>  </b> .      ,  .   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b4/a25/418/1b4a25418eaaf223dfb8e0744404b7a0.jpg"><br><br> ,  «»     . <br><br>         .     Xiaomi    .  .       . ,    Arduino - --- ,  ,   : «,  -  2000!»       — ! <br><br>     ,     : «,  !» —   !        . ,       . <br><br><h2>      </h2><br> <b>  </b> . ,    ,   :  ,   .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> .</a> .       .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    .</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-</a>     .,   .     —   . <br><br> <b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegram- .</a></b> .    —    .    ,        .        .    . <br><br> <b>  </b> .       ,      .  - ,        .          , .   .   ,     . ,    : , -,    ,        .  , ,        .   : « ,    ?» ,      ,  ,       . <br><br> <b></b> —    ,       .     . <br><br> .   —  .     ,   ,      . ,       . <br><br><blockquote>     ,     ,   - ,      ! <br></blockquote><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> —     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> —   .     .   —   — ! <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FrontendConf 2019</a>      « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSS —  </a> ».      —      .  ,     FrontendConf 2019  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . ,     ,     ,      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a>  . <br><br>      .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,       . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468545/">https://habr.com/ru/post/de468545/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468533/index.html">Trampen auf DevOps mit Express 42</a></li>
<li><a href="../de468535/index.html">Benötigen Sie keine Protokolle?</a></li>
<li><a href="../de468537/index.html">Grundlagen von DevOps. Einstieg in das Projekt von Grund auf neu</a></li>
<li><a href="../de468541/index.html">Drag & Drop-Komponenten für blinde Benutzer? Sie machen Witze?</a></li>
<li><a href="../de468543/index.html">Wochentags Programmkomitee FrontendConf. Interview mit Sergey Popov</a></li>
<li><a href="../de468547/index.html">Englisch sprechend, CSS, Grid und Barrierefreiheit bei FrontendConf</a></li>
<li><a href="../de468549/index.html">GPU gebunden. So übertragen Sie alles auf die Grafikkarte und ein bisschen mehr. Animationen</a></li>
<li><a href="../de468553/index.html">Parameterverwaltung in Geschäftsanwendungen ähnlich einem Versionskontrollsystem</a></li>
<li><a href="../de468555/index.html">Einführung in deterministische Assemblys in C / C ++. Teil 2</a></li>
<li><a href="../de468557/index.html">WEB 3.0 - der zweite Ansatz für das Projektil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>