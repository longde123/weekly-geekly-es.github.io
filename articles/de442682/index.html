<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧢 😃 🕺🏿 Was Sie eingeben und wie Sie ein C ++ - Projekt zusammenstellen 👊🏽 🕵🏼 🧑🏽‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem ich diese Frage gestellt hatte, formulierte ich zunächst die Anforderungen: starr und optional (aber wünschenswert) für das Montagesystem und ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was Sie eingeben und wie Sie ein C ++ - Projekt zusammenstellen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442682/">  Nachdem ich diese Frage gestellt hatte, formulierte ich zunächst die Anforderungen: starr und optional (aber wünschenswert) für das Montagesystem und die grafische Entwicklungsumgebung. <br>  Ich möchte sofort darauf hinweisen, dass es nicht darum geht, C ++ - Code für eine bestimmte Plattform wie Android oder ein Framework zu schreiben, zum Beispiel Qt, wo alles fertig ist, sowohl beim Erstellen als auch beim Bearbeiten von Code, sondern um generischen Code, der nicht an eine bestimmte Plattform gebunden ist oder zum Rahmen. <br><a name="habracut"></a><br><h3>  Allgemein: </h3><br><ul><li>  Kostenlos. </li><li>  Plattformübergreifend (mindestens Windows und Linux). </li></ul><br><h3>  Build-System: </h3><br><ul><li>  Ein einziges Team, das auf verschiedenen Plattformen aufbaut. </li><li>  Inkrementelle Assembly mit der korrekten Berücksichtigung aller Abhängigkeiten: Header-Dateien und Komponenten von Drittanbietern, die für die Assembly verwendet werden. </li><li>  Das Assemblerskript sollte nur die für ein bestimmtes Projekt erforderliche Mindestkonfiguration enthalten.  Die allgemeine Logik des Builds sollte nicht von Skript zu Skript wechseln, sondern befindet sich im Build-System oder seinen Plugins. </li><li>  Eingebaute Parallelmontage. </li><li>  Unterstützung für verschiedene Toolchains (mindestens gcc, Visual C ++, CLang). </li><li>  Die Möglichkeit, die Toolchain mit minimalen Kosten zu ändern, ohne das gesamte Build-Skript neu schreiben zu müssen. </li><li>  Leicht umschaltbare Build-Optionen: Debug und Release. </li><li>  Abhängigkeiten von einigen zusätzlichen Low-Level-Tools wie make sind völlig unerwünscht.  Mit einem Wort, das Montagesystem sollte autark sein. </li><li>  Die Integration des Build-Systems in Repositorys von Komponenten von Drittanbietern wie pkg-config oder Maven Central für die JVM ist äußerst wünschenswert. </li><li>  Das Build-System muss durch Plugins erweiterbar sein  Das Montageverfahren für jedes spezifische Projekt kann komplizierter sein als das Standardkonstruktionskonzept (z. B. Codegenerierung oder Montage eines nicht standardmäßigen Bildes). </li><li>  Dies ist praktisch, wenn das Build-Skript eine Programmiersprache auf hoher Ebene oder sogar noch besser DSL ist.  Auf diese Weise können Sie das Verhalten der Konstruktion nicht sehr kostspielig und ausdrücklich direkt im Skript ändern. </li><li>  Wenn Sie den Compiler und den Linker über das Build-Skript konfigurieren, ist es sehr praktisch, wenn das System zumindest grundlegende Abstraktionen bereitstellt: Ich möchte beispielsweise ein Makro hinzufügen - warum sollte man sich überlegen, welcher Compiler-Befehlszeilenparameter dafür verantwortlich ist?  / D unter MSVC oder -D unter gcc - Lassen Sie das Build-System diese unwichtigen Details selbst auflösen. </li><li>  Gute Integration in grafische Entwicklungsumgebungen (IDEs). </li></ul><br><h3>  IDE: </h3><br><ul><li>  Die Fähigkeit der IDE, C ++ - Code richtig zu "verstehen".  Die IDE muss in der Lage sein, alle Projektdateien sowie alle Header-Dateien und Definitionen von Drittanbietern und Systemen (Definitionen, Makros) zu indizieren. </li><li>  Die IDE sollte die Möglichkeit bieten, Befehle zum Erstellen eines Projekts anzupassen sowie nach Header-Dateien und Definitionen zu suchen. </li><li>  Es sollte effektiv bei der Eingabe von Code helfen, d. H.  bieten die am besten geeigneten Abschlussoptionen, warnen vor Syntaxfehlern usw. </li><li>  Das Navigieren in einem großen Projekt sollte bequem sein und schnell und einfach Verwendung finden. </li><li>  Bieten Sie ausreichend Möglichkeiten für das Refactoring: Umbenennen usw. </li><li>  Außerdem wird die Möglichkeit benötigt, Boilerplate-Code zu generieren - ein neues Klassenframework, eine neue Headerdatei und eine neue Implementierungsdatei zu erstellen.  Generierung von Gettern / Setzern, Methodendefinitionen, Überladen virtueller Methoden, Implementierungsmuster rein virtueller Klassen (Schnittstellen) usw. </li><li>  Hervorheben und Unterstützen von Code-Dokumentations-Tags wie Doxygen. </li></ul><br>  Im Lichte dieser "Wunschliste" habe ich verschiedene Montagesysteme und grafische Entwicklungsumgebungen betrachtet.  Diese kurze Rezension gibt in keiner Weise vor, vollständig zu sein, und enthält meine subjektiven Einschätzungen, aber vielleicht erscheint sie jemandem als ersten Schritt nützlich. <br><br>  <b>Machen Sie</b> - <i>[die Antike] zu einem</i> Mastodon und einem wohlverdienten Veteranen der Montagesysteme, die immer noch nicht in den Ruhestand gehen wollen, sondern immer mehr neue Projekte annehmen müssen.  Dies ist ein sehr einfaches Tool mit einer eigenen Sprache, bei dem für ein Leerzeichen anstelle eines Tabs sofort die Ausführung vor Ort droht.  Mit make können Sie alles tun, was Sie wollen - einen Build beliebiger Komplexität, aber Sie müssen dafür bezahlen, um ein Skript zu schreiben und es auf dem neuesten Stand zu halten.  Es wird auch teuer sein, die Logik des Builds von Projekt zu Projekt zu übertragen.  Es gibt einige moderne Make-up-Ersatzstoffe wie Ninja und Marmelade, aber sie ändern nichts an der Essenz - dies sind sehr einfache Werkzeuge.  Genau wie im Assembler können Sie alles schreiben, was Sie möchten, aber lohnt es sich? <br><br>  <b>CMake</b> - <i>[Mittelalter] der</i> erste Versuch, sich von den Details der Marke auf niedriger Ebene zu lösen.  Leider war es nicht möglich, weit zu gehen - die Engine hier ist dieselbe Marke, für die CMake riesige Make-Dateien basierend auf einer anderen Textdatei mit einer höheren Build-Beschreibung generiert.  Qmake funktioniert ähnlich.  Dieser Ansatz erinnert mich an die schöne Fassade eines alten Holzhauses, das sorgfältig mit frischem Kunststoff ummantelt wurde.  CMake ist ein stabiles und bewährtes System, es gibt sogar eine integrierte Integration in Eclipse, aber leider hat es mir nicht gepasst, da es einem Teil der am Anfang des Artikels festgelegten Anforderungen widerspricht.  Unter Linux scheint alles in Ordnung zu sein, aber wenn Sie dasselbe Projekt unter Windows mit MSVC erstellen müssen - und ich den nativen Compiler MinGW vorziehe, werden die Dateien für NMake generiert.  Das heißt,  Abhängigkeiten von einem anderen Tool und andere Build-Befehle für eine andere Plattform.  Und all dies ist eine Folge einer etwas krummen Architektur, wenn der Großteil der Arbeit von anderen "Helfern" erledigt wird. <br><br>  <b>Ant</b> - <i>[Renaissance] eine</i> Art Make-Klon für Java.  Ehrlich gesagt habe ich ziemlich viel Zeit damit verbracht, Ant (sowie Maven) als Build-System für C ++ zu überprüfen.  Und ich hatte sofort das Gefühl, dass die C ++ - Unterstützung hier nur "zur Schau" und nicht ausreichend entwickelt ist.  Darüber hinaus wird Ant auch in Java-Projekten bereits selten eingesetzt.  Als Skriptsprache (sowie für Maven) wird hier XML gewählt - diese abscheuliche Vogelsprache :).  Diese Tatsache des Optimismus hat mich überhaupt nicht dazu gebracht, weiter in das Thema einzutauchen. <br><br>  <b>SCons</b> ist ein eigenständiges, plattformübergreifendes Build-System, das in Python geschrieben wurde.  SCons funktioniert sowohl mit Java- als auch mit C ++ - Builds gleich gut.  Die Abhängigkeiten der Header für die inkrementelle Assembly werden korrekt ausgearbeitet (nach meinem Verständnis wird eine bestimmte Datenbank mit den Build-Metadaten erstellt), und unter Windows funktioniert MSVC ohne Tamburin.  Die Build-Skriptsprache ist Python.  Ein sehr anständiges System, und ich wollte sogar meine Forschung darüber beenden, aber wie Sie wissen, gibt es keine Grenzen für die Perfektion, und eine detailliertere Untersuchung ergab einige Nachteile im Lichte der oben genannten Anforderungen. <br><br>  Es gibt keine abstrakten Einstellungen für den Compiler. Wenn Sie beispielsweise die Toolchain ändern müssen, müssen Sie möglicherweise nach Stellen im Build-Skript suchen, um Änderungen vorzunehmen.  Dieselben Makros müssen mit verschachtelten Bedingungen geschrieben werden - wenn es Windows ist, dann mach es, wenn es GCC ist, mach es usw. <br><br>  Remote-Artefakte und die Abhängigkeit eines Builds von einem anderen auf hoher Ebene werden nicht unterstützt. <br><br>  Die allgemeine Architektur ist so aufgebaut, dass die sogenannten benutzerdefinierten Builder fast isoliert existieren und es keine Möglichkeit gibt, die bereits vorhandene Build-Logik zu verwenden, um sie durch ein einfaches Plug-In durch Ihre eigene zu ergänzen.  Insgesamt ist es jedoch eine gute Wahl für kleine Projekte. <br><br>  <b>Gradle</b> <i>[anwesend]</i> - Ich hatte bereits positive Erfahrungen mit Gradle für Java- und Kotlin-Projekte und hatte große Hoffnungen darauf. <br><br>  Für JVM-Sprachen hat Gradle ein sehr praktisches Konzept für die Arbeit mit den Bibliotheken, die zum Erstellen eines Projekts erforderlich sind (Build-Abhängigkeiten): <br><br><ul><li>  Das Skript registriert die Adressen von Repositorys mit Artefakten: Maven oder Ivy - zum Beispiel.  Es kann auch ein Repository eines anderen Typs / Formats sein - wenn es nur ein Plugin dafür gäbe.  Dies kann ein Remote-Repository, ein Maven Central oder Ihr persönliches Hosting irgendwo im Netzwerk oder nur ein lokaler Mitarbeiter im Dateisystem sein. </li><li>  In einem speziellen Abschnitt des Skripts werden die Abhängigkeiten für die Erstellung direkt angegeben - eine Liste der erforderlichen binären Artefakte mit Versionen. </li><li>  Vor dem Erstellen versucht Gradle, alle Abhängigkeiten aufzulösen, und sucht in allen Repositorys nach Artefakten mit den angegebenen Versionen.  Binärdateien werden in den Cache geladen und automatisch zum Build hinzugefügt.  Das ist sehr praktisch und ich hatte gehofft, dass sie für C ++ vielleicht etwas Ähnliches gemacht haben. </li></ul><br>  Zuerst habe ich das "alte" Plugin für die C ++ - Unterstützung - "cpp" - ausgecheckt und war enttäuscht - die Skriptstruktur ist nicht intuitiv: Modell, Komponente, Nativespec - und eine Art Mischmasch aus verschiedenen Arten von Binärdateien: sowohl ausführbare Dateien als auch Bibliotheken in einem Skript.  Es ist nicht klar, wo Unit-Tests platziert werden sollen.  Diese Struktur war sehr unterschiedlich zu dem, was ich für Java verwendet habe. <br><br>  Es stellte sich jedoch heraus, dass es auch "neue" Plugins für die C ++ - Unterstützung gibt: "cpp-application" - für Anwendungen, "cpp-library" für Bibliotheken: statisch und dynamisch und schließlich "cpp-unit-test" für Unit-Tests.  Und das war es, wonach ich gesucht habe!  :) :) <br><br>  Die Standardstruktur des Projektordners ähnelt dem Java-Projekt: <br><br><ul><li>  <i>src / main / cpp</i> - der Stammordner für die Hauptprojektdateien <i>* .cpp</i> . </li><li>  <i>src / main / headers</i> - Ordner für interne Header-Dateien. </li><li>  <i>src / main / public</i> - Ordner für exportierte Header - für Bibliotheken. </li><li>  <i>src / test / cpp</i> - Ordner für <i>* .cpp-</i> Dateien der Testeinheit. </li></ul><br>  Eine solche Struktur ist nicht starr - sie kann immer im Skript geändert werden, aber es ist nicht notwendig, dies ohne besondere Notwendigkeit zu tun, es ist durchaus vernünftig. <br><br>  Übrigens ist das Build-Skript normalerweise <i>build.gradle</i> . Dies sind die DSLs von Groovy oder Kotlin ( <i>build.gradle.kts</i> ) zur Auswahl.  Innerhalb des Skripts sind die Gradle-API und die APIs der dem Skript hinzugefügten Plugins immer verfügbar. <br><br>  Für Bibliotheken können Sie den Typ auswählen: statisch oder dynamisch (oder beide Optionen erfassen). <br>  Standardmäßig sind zwei Build-Optionen konfiguriert: Debug ( <i>Gradle Assemble</i> ) und Release ( <i>Gradle AssembleRelease</i> ). <br><br>  Das Prinzip des Ausführens von Unit-Tests ist dasselbe wie in Java: Gradle Test erstellt die Hauptkomponente und dann die Tests, sofern sie sich im Ordner <i>src / test / cpp befinden</i> , und führt dann die Testanwendung aus. <br><br>  Die berüchtigten Definitionen können abstrakt festgelegt werden - Gradle selbst generiert die erforderlichen Compileroptionen.  Es gibt mehrere abstraktere Einstellungen wie Optimierung, Debugging-Informationen usw. <br><br>  Standardmäßig werden GCC, Microsoft Visual C ++ und CLang unterstützt. <br><br>  Das Plug-In-System ist sehr entwickelt und die Erweiterungsarchitektur ist praktisch - Sie können vorgefertigte Logik verwenden und sie dekorieren / erweitern.  Es gibt zwei Arten von Plugins: Dynamic, die direkt in Groovy geschrieben und in ein Skript eingebettet oder in Java (oder in einer anderen Sprache mit der JVM) geschrieben und zu binären Artefakten kompiliert werden.  Für Plugins gibt es eine kostenlose Gradle-Artifactory, in der jeder sein Plugin posten kann, das jedem zur Verfügung steht.  Was vom Autor dieses Artikels erfolgreich gemacht wurde :) aber dazu später mehr. <br>  Ich möchte näher auf das System der Arbeit mit Binärkomponenten in Gradle für C ++ eingehen: Es ist fast das gleiche wie in Java!  Builds von Abhängigkeiten funktionieren fast genauso wie oben beschrieben. <br><br>  Nehmen Sie zum Beispiel einen zusammengesetzten Build: <br><br><ul><li>  utils - Bibliotheksordner </li><li>  App ist der Ordner mit der Anwendung, die Utils verwendet. </li><li>  settings.gradle - Gradle-Datei zum Kombinieren dieser beiden Komponenten zu einem zusammengesetzten Build. </li></ul><br>  In der Datei <i>build.gradle</i> aus dem App-Ordner reicht es aus, die folgende Abhängigkeit zu schreiben: <br><br><pre><code class="java hljs">dependencies { <span class="hljs-function"><span class="hljs-function">implementation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">':utils'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br>  Gradle erledigt den Rest!  Fügen Sie dem Compiler einen Pfad hinzu, um nach Utils-Header-Dateien zu suchen und die Bibliotheks-Binärdatei zu verknüpfen. <br><br>  Und das alles funktioniert sowohl unter Linux GCC als auch unter Windows MSVC gleich gut. <br>  Inkrementelle Builds funktionieren natürlich auch hervorragend. Wenn Sie die Header in Utils ändern, wird die App neu erstellt. <br><br>  Wie sich herausstellte, ging Gradle noch weiter und erkannte die Möglichkeit, C ++ - Artefakte in das Maven-Repository hochzuladen!  Verwenden Sie dazu das Standard-Plugin "Maven-Publish". <br><br>  Im Skript müssen Sie das Repository angeben, in dem Sie Ihr Artefakt ablegen und Gradle veröffentlichen möchten (oder Gradle PublishToMavenLocal für die lokale Veröffentlichung).  Gradle wird das Projekt stürzen und <br>  Layout in einem speziellen Format - unter Berücksichtigung der Version, Plattform, Architektur und Build-Option. <br><br>  Die binären Bibliotheksdateien selbst und die öffentlichen Header-Dateien werden aus dem Ordner <i>src / main / public angelegt</i> . <br><br>  Es ist klar, dass Sie keine C ++ - Artefakte auf Maven Cental hochladen können - die obligatorischen Systemprüfungen werden nicht bestanden.  Das Erhöhen des Maven-Repositorys im Netzwerk ist jedoch überhaupt nicht schwierig, und Sie müssen nichts für das lokale Repository tun - es ist nur ein Ordner auf der Festplatte. <br><br>  Wenn Sie nun die Bibliothek einer anderen Person in Ihrem Projekt verwenden möchten, können Sie Folgendes in das Build-Skript schreiben: <br><br><pre> <code class="java hljs"> repositories { maven { url = <span class="hljs-string"><span class="hljs-string">'https://akornilov.bitbucket.io/maven'</span></span> } } unitTest { dependencies { implementation <span class="hljs-string"><span class="hljs-string">'org.bitbucket.akornilov.tools:gtest:1.8.1'</span></span> } }</code> </pre><br>  Hier heißt es, dass Sie für Unit-Tests das gtest-Artefakt Version 1.8.1 aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Maven-Repository verwenden müssen</a> . <br><br>  Übrigens ist dies ein sehr reales Repository, in dem mein Testbuild Google Test v1.8.1 veröffentlicht wird, der mit Gradle für Windows und Linux x86_64 erstellt wurde. <br><br>  Natürlich werden alle einfachen Arbeiten zur Konfiguration des Compilers und Linkers für die Arbeit mit der externen Komponente von Gradle durchgeführt.  Es reicht aus, wenn Sie Ihre Absicht erklären, eine solche und eine solche Bibliothek mit einer solchen und einer solchen Version aus einem solchen und einem solchen Repository zu verwenden. <br><br>  Für die Integration in die IDE verfügt Gradle über zwei integrierte Plugins für Visual Studio und Xcode.  Sie funktionieren gut, außer dass das Visual Studio-Plugin den Unit-Test-Code aus dem Ordner <i>src / test / cpp</i> ignoriert und ein Projekt nur für den Hauptcode generiert. <br><br><h3>  Jetzt ist es Zeit, über die IDE zu sprechen und wie man sie mit Gradle befreundet </h3><br>  <b>Eclipse CDT (2018-12R)</b> ist ein ausgereiftes und qualitativ hochwertiges Produkt.  Wenn er es geschafft hat, Ihr Projekt erfolgreich zu analysieren, haben Sie Glück - es ist bequem zu bearbeiten.  Höchstwahrscheinlich wird er sogar die verwirrendsten Arten von Autos "verstehen".  Aber wenn nicht ... Dann wird er alles in einer Reihe mit einer rot gepunkteten Linie heftig betonen und in schlechten Worten schwören.  Beispielsweise werden Standard-MSVC- und Windows SDK-Headerdateien nicht verarbeitet.  Selbst ein völlig harmloser Ausdruck wird mit einer rot gepunkteten Linie unterstrichen und nicht als etwas Sinnvolles wahrgenommen.  Es gab auch std :: string.  Unter Linux mit seinem nativen gcc ist alles in Ordnung.  Aber selbst als er versuchte, ihn dazu zu bringen, das Projekt von einer Schwester Android Native zu indizieren, begannen Probleme.  In bionischen Headern weigerte er sich aus nächster Nähe, die Definition von size_t und alle Funktionen, die sie verwendeten, zu sehen.  Wahrscheinlich können Sie unter Windows die Situation korrigieren, wenn ihm anstelle von Microsoft-Header-Dateien beispielsweise Cygwin oder MinGW SDK ausfallen, aber diese Tricks sind für mich nicht sehr interessant. Ich möchte immer noch, dass Software dieser Stufe „isst, was sie gibt“ und nicht nur dass er "liebt". <br>  Die Möglichkeiten zum Navigieren, Refactoring und Generieren von Vorlagencode sind wunderbar, aber es gibt Fragen an den Helfer beim Eingeben von Buchstaben: Nehmen wir an, wir geben ein paar Zeichen aus einem langen Namen ein. Warum bieten wir keine Vervollständigungsoptionen an?  Nein, der Assistent wartet geduldig, bis der Benutzer dazu kommt.  oder -&gt; oder ::.  Ich muss ständig Strg + Leertaste drücken - nervig.  In Java konnte dieser lästige Mangel behoben werden, indem das gesamte Alphabet im CDT als Auslöser ausgewählt wurde, aber ich fand keine einfache Lösung. <br><br><img src="https://habrastorage.org/webt/1t/bx/ue/1tbxue1gaib5bhyo7xbofdxrapq.png"><br><br><img src="https://habrastorage.org/webt/yh/zi/vp/yhzivpjrupaijmjbfzz7qwefmaq.png"><br><br>  <b>NetBeans 8.1 / 10.0</b> - Ich habe diese IDE für Java verwendet. Ich wurde als gute und leichte Software mit allen erforderlichen Funktionen in Erinnerung behalten.  Für C ++ gibt es ein Plugin, das nicht von der Community, sondern direkt von NetBeans entwickelt wurde.  Bei C ++ - Projekten besteht eine ziemlich starke Abhängigkeit von make und gcc.  Der Code-Editor ist gemächlich.  Ich habe im Vorlagencode-Generator keine sehr einfache Sache gefunden: Wir fügen der Klassen-Header-Datei eine neue Methode hinzu - Sie müssen den Methodenkörper in einer CPP-Datei generieren - sie weiß nicht wie.  Der Grad des "Verstehens" des Codes ist durchschnittlich, es scheint, dass etwas analysiert wird, aber etwas nicht.  Zum Beispiel ist es für ihn bereits schwierig, auf einer Karte mit einem Auto-Iterator zu iterieren.  Er schwört auf Makros von Google Test.  Das Anpassen des Build-Befehls ist problematisch - unter Linux mit gcc und verfügbar machen (dies trotz der Tatsache, dass bereits ein anderes Build-System verwendet wird) funktioniert es, unter Windows wird MinGW benötigt, aber selbst wenn dies der Fall ist, wird das Erstellen abgelehnt.  Im Allgemeinen ist das Arbeiten in NetBeans mit C ++ möglich, aber ich würde es nicht als komfortabel bezeichnen. Ich muss diese Umgebung wahrscheinlich wirklich lieben, um die verschiedenen Wunden nicht zu bemerken. <br><br><img src="https://habrastorage.org/webt/bi/dh/h4/bidhh4mda-r7cqkqd6q9vnu4t4o.png"><br><br><img src="https://habrastorage.org/webt/ze/yp/j1/zeypj1bdofeuljkgfp9wyfdxebc.png"><br><br>  <b>KDevelop 5.3.1</b> - wurde früher als Entwicklertool für KDE (Linux) konzipiert, jetzt gibt es eine Version für Windows.  Es hat einen schnellen und unterhaltsamen Code-Editor mit wunderschöner Syntaxhervorhebung (basierend auf Kate).  Es wird nicht funktionieren, das linke Build-System zu manipulieren - für ihn ist das Haupt-Build-System CMake.  Es ist tolerant gegenüber MSVC- und Windows SDK-Headern, auf jeden Fall führen printf und std :: string nicht gerade zu einem Stupor wie einem Eclipse CDT.  Ein sehr schneller Helfer zum Schreiben von Code - er bietet fast sofort während der Eingabe gute Vervollständigungsoptionen.  Es bietet eine interessante Möglichkeit, Vorlagencode zu generieren: Sie können Ihre eigene Vorlage schreiben und online stellen.  Wenn Sie aus einer Vorlage erstellen, können Sie eine Verbindung zur Datenbank mit vorgefertigten Vorlagen herstellen und die gewünschte herunterladen.  Das einzige, was Sie verärgert hat: Die integrierte Vorlage zum Erstellen einer neuen Klasse funktioniert sowohl unter Windows als auch unter Linux schief.  Der Assistent zum Erstellen einer Klasse verfügt über mehrere Fenster, in denen Sie viele Dinge konfigurieren können: Welche Konstruktoren werden benötigt, welche Mitglieder der Klasse usw.  In der letzten Phase unter Windows tritt jedoch rechtzeitig ein Fehler auf, um den Text zu erkennen, der unmöglich ist, und zwei Dateien h und cpp werden in der Größe von 1 Byte erstellt.  Unter Linux können Sie aus irgendeinem Grund keine Konstruktoren auswählen. Die Registerkarte ist leer und nur die Header-Datei wird in der Ausgabe korrekt generiert.  Im Allgemeinen sehen Kinderkrankheiten für ein so ausgereiftes Produkt irgendwie leichtfertig aus. <br><br><img src="https://habrastorage.org/webt/gb/e_/dt/gbe_dtwtphcqqvxpankzo5k8oqy.png"><br><br><img src="https://habrastorage.org/webt/kp/ap/hf/kpaphf1yrtwflj68xusgqlh2ppa.png"><br><br>  <b>QtCreator 4.8.1 (Open Source Edition)</b> - Nachdem Sie diesen Namen gehört haben, sind Sie wahrscheinlich ratlos darüber, wie dieses Monster hier unter Qt mit einem Gigabyte-Distributionskit mit Haken eingesperrt wurde.  Dies ist jedoch eine "leichte" Version der Umgebung für generische Projekte.  Das Distributionskit wiegt nur etwa 150 MB und enthält keine Qt-spezifischen Dinge: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">download.qt.io/official_releases/qtcreator/4.8</a> . <br>  Eigentlich kann er fast alles, worüber ich in meinen Anforderungen geschrieben habe, schnell und richtig machen.  Es analysiert die Standard-Header von Windows und Linux, passt sie an jedes Build-System an, schlägt Abschlussoptionen vor, generiert bequem neue Klassen, Methodenkörper, ermöglicht Refactoring und Code-Navigation.  Wenn Sie nur bequem arbeiten möchten, ohne ständig darüber nachzudenken, wie Sie dieses oder jenes Problem lösen können, ist es sinnvoll, sich QtCreator anzusehen. <br><br><img src="https://habrastorage.org/webt/w-/6j/ei/w-6jeizzjkklvumkpdjl5oe_mou.png"><br><br><img src="https://habrastorage.org/webt/au/zb/ot/auzbot8u_iam14q88qjedkdmzvu.png"><br><br>  Eigentlich bleibt es zu besprechen, was ich in Gradle nicht genug hatte, um vollständig zu arbeiten: Integration in die IDE.  Damit das System Projektdateien für die IDE selbst generieren kann, in die die Befehle zum Erstellen des Projekts bereits geschrieben wurden, werden alle Quelldateien aufgelistet, Pfade werden benötigt, um nach Header-Dateien zu suchen und zu bestimmen. <br><br>  Zu diesem Zweck habe ich ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin für Gradle `cpp-ide-generator` geschrieben</a> und im Gradle Plugin Portal veröffentlicht. <br><br>  Das Plugin kann nur mit "cpp-application", "cpp-library" und "cpp-unit-test" verwendet werden. <br>  Hier ist ein Beispiel für die Verwendung in <i>build.gradle</i> : <br><br><pre> <code class="java hljs"> plugins { id <span class="hljs-string"><span class="hljs-string">'cpp-library'</span></span> id <span class="hljs-string"><span class="hljs-string">'maven-publish'</span></span> id <span class="hljs-string"><span class="hljs-string">'cpp-unit-test'</span></span> id <span class="hljs-string"><span class="hljs-string">'org.bitbucket.akornilov.cpp-ide-generator'</span></span> version <span class="hljs-string"><span class="hljs-string">'0.3'</span></span> } library { <span class="hljs-comment"><span class="hljs-comment">// Library specific parameters } // Configuration block of plugin: ide { autoGenerate = false eclipse = true qtCreator = true netBeans = true kdevelop = true }</span></span></code> </pre><br>  Das Plugin unterstützt die Integration in alle oben genannten grafischen Entwicklungsumgebungen. Im Plugin-Konfigurationsblock können Sie jedoch die Unterstützung für unnötige IDEs deaktivieren: <br><br><pre> <code class="java hljs"> kdevelop = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br>  Wenn der Parameter <i>autoGenerate</i> auf true gesetzt ist, werden Projektdateien für alle zulässigen IDEs direkt während des <i>Builds</i> automatisch generiert.  Im automatischen Generierungsmodus werden Projektdateien auch gelöscht, wenn der Build bereinigt wird: <i>gradle clean</i> . <br><br>  Inkrementelle Erzeugung wird unterstützt, d.h.  Es werden nur die Dateien aktualisiert, für die ein echtes Update erforderlich ist. <br><br>  Hier ist eine Liste der Ziele, die das Plugin hinzufügt: <br><br><ul><li>  generateIde - Generiert Projektdateien für alle zulässigen IDEs. </li><li>  cleanIde - Löscht Projektdateien für alle zulässigen IDEs. </li><li>  generateIde [name] - Generiert Projektdateien für die IDE mit dem angegebenen Namen (IDE muss zulässig sein), z. B. generateIdeQtCreator. </li><li>  Verfügbare Namen: Eclipse, NetBeans, QtCreator, KDevelop. </li><li>  cleanIde [Name] - Löscht Projektdateien für die IDE mit dem angegebenen Namen, z. B. cleanIdeQtCreator. </li></ul><br>  Während der Generierung „schnüffelt“ das Plugin am Build und extrahiert daraus alle erforderlichen Informationen, um Projektdateien zu erstellen.  Nach dem Öffnen des Projekts in der IDE sollten alle Quelldateien sichtbar sein, die Pfade zu allen Headern sollten registriert sein und die grundlegenden Build-Befehle - build / clear - sind konfiguriert. <br><br>  Das zweite Plugin, das ich machen musste, heißt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"cpp-build-tuner"</a> und funktioniert auch zusammen mit "cpp-application", "cpp-library" und "cpp-unit-test". <br><br>  Das Plugin hat keine Einstellungen, es reicht gerade aus, um es hochzuladen: <br><br><pre> <code class="java hljs"> plugins { id <span class="hljs-string"><span class="hljs-string">'cpp-library'</span></span> id <span class="hljs-string"><span class="hljs-string">'maven-publish'</span></span> id <span class="hljs-string"><span class="hljs-string">'cpp-unit-test'</span></span> id <span class="hljs-string"><span class="hljs-string">'org.bitbucket.akornilov.cpp-build-tuner'</span></span> version <span class="hljs-string"><span class="hljs-string">'0.5'</span></span> }</code> </pre><br>  Das Plugin führt kleine Manipulationen mit den Einstellungen der Toolchains (Compiler und Linker) für verschiedene Build-Optionen durch - Debug und Release.  MSVC, gcc, CLang werden unterstützt. <br><br>  Dies gilt insbesondere für MSVC, da Sie als Ergebnis des Release-Builds standardmäßig eine "fette", nicht ästhetische Binärdatei mit Bazhdash-Informationen und einer statisch verknüpften Standardbibliothek erhalten.  Ich habe einen Teil der Einstellungen für MSVC in Visual Studio selbst "ausspioniert", das standardmäßig zu seinen C ++ - Projekten hinzugefügt wird.  Sowohl für gcc / CLang als auch für MSVC sind Verbindungszeitoptimierungen im Release-Profil enthalten. <br><br>  <i>Hinweis: Plugins wurden mit der neuesten Version von Gradle v5.2.1 getestet und nicht auf Kompatibilität mit früheren Versionen getestet.</i> <br><br>  Die Quellcodes der Plugins sowie einfache Beispiele für die Verwendung von Gradle für Bibliotheken: statisch und dynamisch sowie die Anwendung, die sie verwendet, können angezeigt werden: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bitbucket.org/akornilov/tools</a> next gradle / cpp. <br><br>  Die Beispiele zeigen auch, wie Sie Google Test für Unit-Test-Bibliotheken verwenden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Maven Repository mit Google Test v1.8.1 in Gradle (ohne Mock).</a> <br><br>  <b>UPD:</b> <br><br>  Windows-Versionen von <b>QtCreato</b> r, die älter als <b>4.6.2 sind</b> (und zumindest zum Zeitpunkt des Schreibens dieser Zeilen bis einschließlich <b>4.10</b> ), haben „vergessen“, wie das MSVC SDK zu verstehen ist.  Der gesamte std :: space ist rot unterstrichen und weigert sich zu indizieren.  Daher ist Version 4.6.2 derzeit am besten für die Arbeit unter Windows geeignet. <br><br>  Eine neue Version des Plugins <code>cpp-build-tuner</code> <b>v1.0</b> wurde veröffentlicht (und <code>cpp-ide-generator</code> <b>v0.5</b> sind geringfügige Verbesserungen). <br>  1) Konfigurationsblock zum <code>cpp-build-tuner</code> hinzugefügt. <br><pre> <code class="javascript hljs">buildTuner { lto = <span class="hljs-literal"><span class="hljs-literal">false</span></span> gtest = <span class="hljs-string"><span class="hljs-string">'1.8.1'</span></span> libraries { common = [<span class="hljs-string"><span class="hljs-string">'cutils.lib'</span></span>] windows = [<span class="hljs-string"><span class="hljs-string">'ole32'</span></span>, <span class="hljs-string"><span class="hljs-string">'user32'</span></span>] linux = [<span class="hljs-string"><span class="hljs-string">'pthread'</span></span>, <span class="hljs-string"><span class="hljs-string">'z'</span></span>] } libDirs.common = [<span class="hljs-string"><span class="hljs-string">'../build/debug'</span></span>, <span class="hljs-string"><span class="hljs-string">'../release'</span></span>] }</code> </pre><br>  <b>lto</b> (boolean) - Aktiviert oder deaktiviert LTO für den Release-Build.  Standardmäßig aktiviert. <br><br>  <b>gtest</b> (Zeichenfolge) - Fügt Google Test-Unterstützung für <b>Komponententests hinzu</b> .  Derzeit wird nur Version 1.8.1 für GCC, MinGW-W64 und MSVC unterstützt. <br><br>  <b>Bibliotheken</b> (Container) - Eine Liste von Bibliotheken zum Verknüpfen.  Innerhalb des Containers gibt es drei Felder (Liste der Zeilen): <code>common</code> - Bibliotheken für jede Plattform, <code>windows</code> - nur für Windows und <code>linux</code> - nur für Linux. <br><br>  <b>libDirs</b> (Container) - Eine Liste von Ordnern zum Durchsuchen von Bibliotheken mit einem Linker.  Die Container-Struktur entspricht der Bibliotheksliste. <br><br>  2) Es wurde die Möglichkeit hinzugefügt, Anwendungen für <code>cpp-application</code> auszuführen.  Das Plugin fügt dem Projekt zusätzliche Aufgaben hinzu: <code>run</code> , <code>runDebug</code> (wie <code>run</code> ) und <code>runRelease</code> .  Aufgaben hängen von <code>assemble</code> , <code>assembleDebug</code> bzw. <code>assembleRelease</code> ab. <br>  Wie beim Standard-Java-Anwendungs-Plugin können Sie beim Start <code>gradle run --args="arg1 arg2 ..."</code> : <code>gradle run --args="arg1 arg2 ..."</code> . <br><br>  <b>UPD</b> <br><br>  Im Zusammenhang mit der Änderung der Hosting-Plugins wurde die Gruppe geändert: <br><pre> <code class="javascript hljs">plugins { id <span class="hljs-string"><span class="hljs-string">'loggersoft.cpp-build-tuner'</span></span> version <span class="hljs-string"><span class="hljs-string">'1.1'</span></span> id <span class="hljs-string"><span class="hljs-string">'loggersoft.cpp-ide-generator'</span></span> version <span class="hljs-string"><span class="hljs-string">'0.5'</span></span> }</code> </pre><br><br>  Neue Projektadresse: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gradle-cpp.sourceforge.io</a> <br><br>  Dokumentation: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sourceforge.net/p/gradle-cpp/wiki/cpp-build-tuner</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sourceforge.net/p/gradle-cpp/wiki/cpp-ide-generator</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442682/">https://habr.com/ru/post/de442682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442672/index.html">So geben Sie Feedback: 9 Regeln</a></li>
<li><a href="../de442674/index.html">Informationssicherheitsinstanzen auf der Plattform attackdefense.com</a></li>
<li><a href="../de442676/index.html">Wohin Träume führen: Untergrund</a></li>
<li><a href="../de442678/index.html">Größtes Projekt in der Stereolithographie: Mammutskelett auf einem 3D-Drucker gedruckt</a></li>
<li><a href="../de442680/index.html">Mit sensorischen Ersatztechnologien können Sie die Welt mithilfe von Geräuschen sehen: Wie die Neuroplastizität des menschlichen Gehirns funktioniert</a></li>
<li><a href="../de442684/index.html">Ausgewogene Site-Leistung. Teil 3: Inhalt</a></li>
<li><a href="../de442686/index.html">DataPower-Lernprogramm</a></li>
<li><a href="../de442688/index.html">Scala-Datenanalyse - ein dringender Bedarf oder eine angenehme Gelegenheit?</a></li>
<li><a href="../de442690/index.html">Mondmission "Bereshit" - Selfie auf dem Hintergrund der Erde</a></li>
<li><a href="../de442692/index.html">Blockchain ohne Zwischenhändler: Wie wir Wertpapiere an eine verteilte Registrierung gesendet haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>