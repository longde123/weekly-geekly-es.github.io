<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🎤 👩🏻‍🏫 👩🏾‍⚖️ Representación de archivos HTML: un capítulo del libro ReactPHP para principiantes de Skyeng 👨🏼‍🎨 🔯 📼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El desarrollador backend de la aplicación móvil Skyeng Sergey Zhuk continúa escribiendo buenos libros. Esta vez lanzó un libro de texto en ruso para u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Representación de archivos HTML: un capítulo del libro ReactPHP para principiantes de Skyeng</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/416003/"><p><img src="https://habrastorage.org/webt/6v/oi/xx/6voixx5vd9au0asabvgmnckfj90.png"></p><br><p>  El desarrollador backend de la aplicación móvil Skyeng Sergey Zhuk continúa escribiendo buenos libros.  Esta vez lanzó un libro de texto en ruso para una audiencia de dominio de PHP.  Le pedí a Sergey que compartiera un capítulo útil y autosuficiente de su libro, y que les diera a los lectores de Habra un código de descuento.  Debajo están los dos. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Primero, le diremos lo que detuvimos en los capítulos anteriores.</b> <div class="spoiler_text"><p> Hemos escrito nuestro servidor HTTP simple en PHP.  Tenemos el archivo <code>index.php</code> principal: el script que inicia el servidor.  Aquí está el código de nivel más alto: creamos un bucle de eventos, configuramos el comportamiento del servidor HTTP e iniciamos el bucle: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Server</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; $loop = React\EventLoop\Factory::create(); $router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); $router-&gt;load(<span class="hljs-string"><span class="hljs-string">'routes.php'</span></span>); $server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Server( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($router)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $router($request); } ); $socket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> React\Socket\Server(<span class="hljs-number"><span class="hljs-number">8080</span></span>, $loop); $server-&gt;listen($socket); $loop-&gt;run();</code> </pre> <br><p>  Para enrutar solicitudes, el servidor usa un enrutador: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// src/Router.php use Psr\Http\Message\ServerRequestInterface; use React\Http\Response; class Router { private $routes = []; public function __invoke(ServerRequestInterface $request) { $path = $request-&gt;getUri()-&gt;getPath(); echo "Request for: $path\n"; $handler = $this-&gt;routes[$path] ?? $this-&gt;notFound($path); return $handler($request); } public function load($filename) { $routes = require $filename; foreach ($routes as $path =&gt; $handler) { $this-&gt;add($path, $handler); } } public function add($path, callable $handler) { $this-&gt;routes[$path] = $handler; } private function notFound($path) { return function () use ($path) { return new Response( 404, ['Content-Type' =&gt; 'text/html; charset=UTF-8'], "No request handler found for $path" ); }; } }</span></span></code> </pre> <br><p>  Las rutas del archivo <code>routes.php</code> se cargan en el <code>routes.php</code> .  Ahora solo se han anunciado dos rutas aquí: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Response</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'/'</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">'Main page'</span></span> ); }, <span class="hljs-string"><span class="hljs-string">'/upload'</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">'Upload page'</span></span> ); }, ];</code> </pre> <br><p>  Hasta ahora, todo es simple, y nuestra aplicación asincrónica cabe en varios archivos. </p></div></div><br><p>  Pasamos a cosas más "útiles".  Las respuestas de un par de palabras de un texto simple que aprendimos a derivar en capítulos anteriores no parecen muy atractivas.  Necesitamos devolver algo real, como una página HTML. </p><br><p>  Entonces, ¿dónde ponemos este HTML?  Por supuesto, puede codificar los contenidos de la página web directamente dentro del archivo de rutas: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php return [ '/' =&gt; function (ServerRequestInterface $request) { $html = &lt;&lt;&lt;HTML &lt;!DOCTYPE html&gt; &lt;html lang=”en”&gt; &lt;head&gt; &lt;meta charset=”UTF-8”&gt; &lt;title&gt;ReactPHP App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello, world &lt;/body&gt; &lt;/html&gt; HTML; return new Response( 200, ['Content-Type' =&gt; 'text/html'], $html ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  ¡Pero no hagas eso!  No puede mezclar lógica empresarial (enrutamiento) con presentación (página HTML).  Por qué  Imagine que necesita cambiar algo en el código HTML, por ejemplo, el color del botón.  ¿Y qué archivo necesitará ser cambiado?  Archivo con rutas <code>router.php</code> ?  Suena raro, ¿verdad?  Realice cambios en la ruta para cambiar el color del botón ... </p><br><p>  Por lo tanto, dejaremos las rutas en paz, y para las páginas HTML crearemos un directorio separado.  En la raíz del proyecto, agregue un nuevo directorio llamado páginas.  Luego dentro de él creamos el archivo <code>index.html</code> .  Esta será nuestra página principal.  Aquí están sus contenidos: </p><br><pre> <code class="php hljs">&lt;!DOCTYPE html&gt; &lt;html lang=<span class="hljs-string"><span class="hljs-string">"en"</span></span>&gt; &lt;head&gt; &lt;meta charset=<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>&gt; &lt;title&gt;ReactPHP App&lt;/title&gt; &lt;link rel=<span class="hljs-string"><span class="hljs-string">"stylesheet"</span></span> href=<span class="hljs-string"><span class="hljs-string">"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css"</span></span> &gt; &lt;/head&gt; &lt;body&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">row</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">action</span></span></span><span class="hljs-class">="/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">upload</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">method</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">POST</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">justify</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">content</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">center</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">group</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">label</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">"&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Text</span></span></span><span class="hljs-class">&lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">label</span></span></span><span class="hljs-class">&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">textarea</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">control</span></span></span><span class="hljs-class">"&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class">&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">button</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">submit</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">btn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">btn</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">primary</span></span></span><span class="hljs-class">"&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Submit</span></span></span><span class="hljs-class">&lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">button</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">body</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">html</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br><p>  La página es bastante simple, contiene solo un elemento: el formulario.  El formulario dentro tiene un cuadro de texto y un botón para enviar.  También agregué estilos Bootstrap para que nuestra página se vea mejor. </p><br><h4 id="chtenie-faylov-kak-ne-nado-delat">  Lectura de archivos.  Cómo no hacer </h4><br><p>  El enfoque más directo es leer el contenido del archivo dentro del controlador de solicitud y devolver ese contenido como el cuerpo de la respuesta.  Algo como esto: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php return [ '/' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, // ... ];</span></span></code> </pre> <br><p>  Y, por cierto, funcionará.  Puede probarlo usted mismo: reinicie el servidor y vuelva a cargar la página <code>http://127.0.0.1:8080/</code> en su navegador. </p><br><p><img src="https://habrastorage.org/webt/zq/dc/91/zqdc91cvy7a971jkniyw8hpxgzi.png"></p><br><p>  Entonces, ¿qué pasa aquí?  ¿Y por qué no hacer eso?  En resumen, porque habrá problemas si el sistema de archivos comienza a ralentizarse. </p><br><h4 id="blokiruyuschie-i-neblokiruyuschie-vyzovy">  Bloqueo y no bloqueo de llamadas </h4><br><p>  Permítame mostrarle lo que quiero decir con "bloqueo" de llamadas y lo que puede suceder cuando uno de los manejadores de solicitudes contiene código de bloqueo.  Antes de devolver el objeto de respuesta, agregue una llamada a la función <code>sleep()</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php return [ '/' =&gt; function (ServerRequestInterface $request) { sleep(10); return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Esto hará que el controlador de solicitudes se congele durante 10 segundos antes de que pueda devolver una respuesta con el contenido de la página HTML.  Tenga en cuenta que no tocamos el controlador de la dirección <code>/upload</code> .  Al llamar a la función <code>sleep(10)</code> , emulo la ejecución de algún tipo de operación de bloqueo. </p><br><p>  Entonces, ¿qué tenemos?  Cuando el navegador solicita la página <code>/</code> , el controlador espera 10 segundos y luego devuelve la página HTML.  Cuando abrimos la dirección <code>/upload</code> , su controlador debe devolver inmediatamente una respuesta con la cadena 'Página de <code>/upload</code> '. </p><br><p>  Ahora veamos qué sucede en la realidad.  Como siempre, reiniciamos el servidor.  Ahora, abra otra ventana en su navegador.  En la barra de direcciones, ingrese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://127.0.0.1:8080/upload</a> , pero no abra esta página de inmediato.  Solo deje esta dirección en la barra de direcciones por ahora.  Luego vaya a la primera ventana del navegador y abra la página <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://127.0.0.1:8080/</a> en ella.  Mientras se carga esta página (recuerde que tomará 10 segundos hacer esto), vaya rápidamente a la segunda ventana y presione “Entrar” para cargar la dirección que quedó en la barra de direcciones ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://127.0.0.1:8080/upload</a> ) . </p><br><p>  Que conseguimos  Sí, la dirección /, como se esperaba, tarda 10 segundos en cargarse.  Pero, sorprendentemente, la segunda página tardó la misma cantidad de tiempo en cargarse, aunque no le agregamos ninguna llamada <code>sleep()</code> .  ¿Alguna idea de por qué sucedió esto? </p><br><p>  ReactPHP se ejecuta en un solo hilo.  Puede parecer que en una aplicación asincrónica, las tareas se ejecutan en paralelo, pero en realidad esto no es así.  La ilusión de paralelismo es creada por un ciclo de eventos que cambia constantemente entre varias tareas y las realiza.  Pero en cierto momento, solo se realiza una tarea.  Esto significa que si una de estas tareas lleva demasiado tiempo, bloqueará el bucle de eventos, lo que no podrá registrar nuevos eventos y controladores de llamadas para ellos.  Y eso finalmente conduce a la "congelación" de toda la aplicación, simplemente perderá la asincronía. </p><br><p>  Bien, pero ¿qué tiene esto que ver con llamar a <code>file_get_contents('pages/index.h')</code> ?  El problema aquí es que estamos accediendo al sistema de archivos directamente.  En comparación con otras operaciones, como trabajar con memoria o informática, trabajar con el sistema de archivos puede ser extremadamente lento.  Por ejemplo, si el archivo resultó ser demasiado grande o el disco en sí es lento, entonces leer el archivo puede tomar un tiempo y, como resultado, bloquear el bucle de eventos. </p><br><p>  En el modelo síncrono estándar, la solicitud-respuesta no es un problema.  Si el cliente solicitó un archivo que es demasiado pesado, esperará hasta que se descargue este archivo.  Una solicitud tan pesada no afecta a otros clientes.  Pero en nuestro caso, estamos tratando con un modelo asíncrono orientado a eventos.  Hemos lanzado un servidor HTTP que debe procesar constantemente las solicitudes entrantes.  Si una solicitud tarda demasiado en completarse, esto afectará a todos los demás clientes del servidor. </p><br><p>  Como regla, recuerde: </p><br><ul><li>  Nunca puedes bloquear un bucle de eventos. </li></ul><br><p>  Entonces, ¿cómo leemos el archivo asincrónicamente?  Y aquí llegamos a la segunda regla: </p><br><ul><li>  Cuando no se puede evitar una operación de bloqueo, se debe bifurcar en el proceso secundario y continuar la ejecución asincrónica en el hilo principal. </li></ul><br><p>  Entonces, después de que aprendamos cómo no hacerlo, analicemos la solución correcta sin bloqueo. </p><br><h4 id="docherniy-process">  Proceso hijo </h4><br><p>  Toda comunicación con el sistema de archivos en una aplicación asincrónica debe realizarse en procesos secundarios.  Para administrar procesos secundarios en una aplicación ReactPHP, necesitamos instalar otro componente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Proceso</a> secundario <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"</a> .  Este componente le permite acceder a las funciones del sistema operativo para ejecutar cualquier comando del sistema dentro del proceso secundario.  Para instalar este componente, abra una terminal en la raíz del proyecto y ejecute el siguiente comando: </p><br><p> <code>composer require react/child-process</code> </p> <br><h4 id="sovmestimost-s-windows">  <em>Compatibilidad con Windows</em> </h4><br><p>  <em>En el sistema operativo Windows, los subprocesos STDIN, STDOUT y STDERR están bloqueados, lo que significa que el componente Proceso secundario no podrá funcionar correctamente.</em>  <em>Por lo tanto, este componente está diseñado principalmente para funcionar solo en sistemas nix.</em>  <em>Si intenta crear un objeto de la clase Process en un sistema Windows, se generará una excepción.</em>  <em>Pero el componente puede funcionar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el subsistema de Windows para Linux (WSL)</a> .</em>  <em>Si tiene la intención de utilizar este componente en Windows, deberá instalar WSL.</em> </p><br><p>  Ahora podemos ejecutar cualquier comando de shell dentro del proceso hijo.  Abra el archivo <code>routes.php</code> y luego cambiemos el controlador para la ruta <code>/</code> .  Cree un objeto de la clase <code>React\ChildProcess\Process</code> y, como comando, páselo <code>ls</code> para obtener el contenido del directorio actual: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php use Psr\Http\Message\ServerRequestInterface; use React\ChildProcess\Process; use React\Http\Response; return [ '/' =&gt; function (ServerRequestInterface $request) { $childProcess = new Process('ls'); return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, // ... ];</span></span></code> </pre> <br><p>  Entonces necesitamos comenzar el proceso llamando al método <code>start()</code> .  El problema es que el método <code>start()</code> necesita un objeto de bucle de eventos.  Pero en el archivo <code>routes.php</code> no tenemos este objeto.  ¿Cómo pasamos el bucle de eventos de <code>index.php</code> a rutas directamente al controlador de solicitudes?  La solución a este problema es la "inyección de dependencia". </p><br><h4 id="inekciya-zavisimostey">  Inyección de dependencia </h4><br><p>  Entonces, una de nuestras rutas necesita un bucle de eventos para funcionar.  En nuestra aplicación, solo un componente conoce la existencia de rutas: la clase <code>Router</code> .  Resulta que es su responsabilidad proporcionar un circuito de eventos para las rutas.  En otras palabras, el enrutador necesita un bucle de eventos, o depende del bucle de eventos.  ¿Cómo expresamos explícitamente esta dependencia en el código?  ¿Cómo hacer imposible incluso crear un enrutador sin pasarle un bucle de eventos?  Por supuesto, a través del constructor de la clase <code>Router</code> .  Abra <code>Router.php</code> y agregue el constructor a la clase <code>Router</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">EventLoop</span></span>\<span class="hljs-title"><span class="hljs-title">LoopInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Response</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Router</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $routes = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> LoopInterface */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $loop; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LoopInterface $loop)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;loop = $loop; } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Dentro del constructor, guarde el bucle de evento pasado en la propiedad privada <code>$loop</code> .  Esta es una inyección de dependencia cuando proporcionamos a la clase los objetos que necesita para funcionar en el exterior. </p><br><p>  Ahora que tenemos este nuevo constructor, necesitamos actualizar la creación del enrutador.  Abra el archivo <code>index.php</code> y corrija la línea donde creamos el objeto de la clase <code>Router</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// index.php $loop = React\EventLoop\Factory::create(); $router = new Router($loop); $router-&gt;load('routes.php');</span></span></code> </pre> <br><p>  Listo  Volver a las <code>routes.php</code> .  Como probablemente ya haya adivinado, aquí podemos usar la misma idea con <strong>la inyección de dependencia</strong> y agregar un bucle de eventos como segundo parámetro a nuestros manejadores de consultas.  Cambie la primera devolución de llamada y agregue el segundo argumento: un objeto que implementa <code>LoopInterface</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php use Psr\Http\Message\ServerRequestInterface; use React\EventLoop\LoopInterface; use React\ChildProcess\Process; use React\Http\Response; return [ '/' =&gt; function (ServerRequestInterface $request, LoopInterface $loop) { $childProcess = new Process('ls'); $childProcess-&gt;start($loop); return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  A continuación, debemos pasar el bucle de eventos al método <code>start()</code> del proceso secundario.  ¿Y de dónde obtiene el controlador el bucle de eventos?  Y ya está almacenado dentro del enrutador en la propiedad privada <code>$loop</code> .  Solo tenemos que pasarlo cuando se llama al controlador. </p><br><p>  <code>__invoke()</code> abrir la clase <code>Router</code> y actualizar el método <code>__invoke()</code> , agregando el segundo argumento a la llamada del manejador de solicitudes: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ $path = $request-&gt;getUri()-&gt;getPath(); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Request for: $path\n"</span></span>; $handler = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;routes[$path] ?? <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;notFound($path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $handler($request, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;loop); }</code> </pre> <br><p>  Eso es todo!  Probablemente sea suficiente <strong>inyección de dependencia</strong> .  Un gran viaje del ciclo de eventos sucedió, ¿verdad?  Desde el archivo <code>index.php</code> a la clase <code>Router</code> , y luego desde la clase <code>Router</code> al archivo <code>routes.php</code> dentro de las devoluciones de llamada. </p><br><p>  Entonces, para confirmar que el proceso secundario hará su magia sin bloqueo, reemplacemos el <code>ls</code> simple con el <code>ping 8.8.8.8</code> más pesado <code>ping 8.8.8.8</code> .  Reinicie el servidor e intente nuevamente abrir dos páginas en dos ventanas diferentes.  Primero, <code>http://127.0.0.1:8080/</code> , y luego <code>/upload</code> .  Ambas páginas se abren rápidamente, sin demora, aunque el comando <code>ping</code> se ejecuta en el primer controlador en segundo plano.  Esto, por cierto, significa que podemos bifurcar cualquier operación costosa (por ejemplo, procesar archivos grandes), sin bloquear la aplicación principal. </p><br><h4 id="svyazyvaem-docherniy-process-i-otvet-s-pomoschyu-potokov">  Vincula el proceso secundario y la respuesta usando hilos </h4><br><p>  Volvamos a nuestra aplicación.  Entonces, creamos un proceso hijo, lo iniciamos, pero nuestro navegador no muestra los resultados de una operación bifurcada de ninguna manera.  Vamos a arreglarlo </p><br><p>  ¿Cómo podemos comunicarnos con el proceso secundario?  En nuestro caso, tenemos un <code>ls</code> ejecución que muestra el contenido del directorio actual.  ¿Cómo obtenemos esta conclusión y luego la enviamos al cuerpo de la respuesta?  La respuesta corta es: hilos. </p><br><p>  Hablemos un poco sobre los procesos.  Cualquier comando de shell que ejecute tiene tres flujos de datos: STDIN, STDOUT y STDERR.  Transmita a la salida y entrada estándar, además de la transmisión de errores.  Por ejemplo, cuando ejecutamos el <code>ls</code> , el resultado de este comando se envía directamente a STDOUT (en la pantalla del terminal).  Entonces, si necesitamos obtener la salida de un proceso, se requiere acceso a la secuencia de salida.  Y esto es tan simple como eso.  Al crear el objeto de respuesta, reemplace la llamada <code>file_get_contents()</code> con <code>$childProcess-&gt;stdout</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], $childProcess-&gt;stdout );</code> </pre> <br><p>  Todos los procesos secundarios tienen tres propiedades que se relacionan con <code>stdio</code> secuencias <code>stdio</code> : <code>stdout</code> , <code>stdin</code> y <code>stderr</code> .  En nuestro caso, queremos mostrar el resultado del proceso en una página web.  En lugar de una cadena en el constructor de la clase <code>Response</code> , pasamos una secuencia como tercer argumento.  La clase <code>Response</code> es lo suficientemente inteligente como para darse cuenta de que recibió la secuencia y procesarla en consecuencia. </p><br><p>  Entonces, como siempre, reiniciamos el servidor y vemos lo que hemos hecho.  Abramos la página <code>http://127.0.0.1:8080/</code> en el navegador: debería ver una lista de archivos de la carpeta raíz del proyecto. </p><br><p><img src="https://habrastorage.org/webt/mm/ui/za/mmuizadmcw-fzg1cekm0d1jpz3e.png"></p><br><p>  El último paso es reemplazar el <code>ls</code> con algo más útil.  Comenzamos este capítulo renderizando el archivo <code>pages/index.html</code> usando la función <code>file_get_contents()</code> .  Ahora, podemos leer este archivo absolutamente asincrónicamente, sin preocuparnos de que bloquee nuestra aplicación.  Reemplace el <code>ls</code> con <code>cat pages/index.html</code> . </p><br><p>  Si no está familiarizado con el <code>cat</code> , se utiliza para concatenar y generar archivos.  Muy a menudo, este comando se usa para leer un archivo y enviar su contenido a la salida estándar.  El comando <code>cat pages/index.html</code> lee el archivo <code>cat pages/index.html</code> e imprime su contenido en STDOUT.  Y ya estamos enviando <code>stdout</code> como el cuerpo de respuesta.  Aquí está la versión final del archivo <code>routes.php</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php use Psr\Http\Message\ServerRequestInterface; use React\EventLoop\LoopInterface; use React\ChildProcess\Process; use React\Http\Response; return [ '/' =&gt; function (ServerRequestInterface $request, LoopInterface $loop) { $childProcess = new Process('cat pages/index.html'); $childProcess-&gt;start($loop); return new Response( 200, ['Content-Type' =&gt; 'text/html'], $childProcess-&gt;stdout ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Como resultado, todo este código era necesario solo para reemplazar una llamada a la función <code>file_get_contents()</code> .  Inyección de dependencias, pasar un objeto de bucle de eventos, agregar procesos secundarios y trabajar con subprocesos.  Todo esto es solo para reemplazar una llamada de función.  ¿Valió la pena?  Respuesta: sí, valió la pena.  Cuando algo puede bloquear el bucle de eventos, y el sistema de archivos puede definitivamente, asegúrese de que eventualmente se bloqueará, y en el momento más inoportuno. </p><br><p>  Crear un proceso secundario cada vez que necesitemos acceder al sistema de archivos puede parecer una sobrecarga adicional que afectará la velocidad y el rendimiento de nuestra aplicación.  Desafortunadamente, en PHP no hay otra forma de trabajar con el sistema de archivos de forma asincrónica.  Todas las bibliotecas asíncronas de PHP usan procesos secundarios (o extensiones que los abstraen). </p><br><p>  Los lectores de Habra pueden comprar el libro completo con un descuento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en este enlace</a> . </p><br><p>  ¡Y le recordamos que siempre estamos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">busca de desarrolladores geniales</a> !  ¡Ven, nos divertimos! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416003/">https://habr.com/ru/post/es416003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415993/index.html">Remot, tu harina despiadada</a></li>
<li><a href="../es415995/index.html">Desarrollo de CROC desde adentro: personas, patos y mucho trabajo.</a></li>
<li><a href="../es415997/index.html">Software de aprendizaje automático de Python</a></li>
<li><a href="../es415999/index.html">¿Qué es la beca de Apple y por qué es más que un simple boleto de WWDC?</a></li>
<li><a href="../es416001/index.html">Mensajes de un sitio en VK - simple y efectivo - PHP + CUrl</a></li>
<li><a href="../es416005/index.html">16 herramientas de reacción para desarrolladores de interfaces</a></li>
<li><a href="../es416007/index.html">Casi complicado. El comienzo de la creación de un "hogar inteligente" inalámbrico. Basado en tecnología Linux, software Z-Wave y MajorDoMo</a></li>
<li><a href="../es416009/index.html">Pruebe los excrementos de conejo, es vigoroso, atrapará - extractos en farmacología</a></li>
<li><a href="../es416011/index.html">Patrón BIF: código frontal limpio y trabajo conveniente con datos del servidor</a></li>
<li><a href="../es416013/index.html">Cómo comenzar a invertir y ahorrar dinero: los expertos de Dow Jones mencionaron los cinco errores principales de los operadores novatos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>