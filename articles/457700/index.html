<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜüèª üî¨ ‚û°Ô∏è Gu√≠a de autenticaci√≥n de Node.js sin passport.js y servicios de terceros üöΩ üîù ü§ï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El autor del art√≠culo, cuya traducci√≥n publicamos hoy, dice que ahora puede observar la creciente popularidad de los servicios de autenticaci√≥n como G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gu√≠a de autenticaci√≥n de Node.js sin passport.js y servicios de terceros</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/457700/">  El autor del art√≠culo, cuya traducci√≥n publicamos hoy, dice que ahora puede observar la creciente popularidad de los servicios de autenticaci√≥n como Google Firebase Authentication, AWS Cognito y Auth0.  Las soluciones gen√©ricas como passport.js se han convertido en el est√°ndar de la industria.  Pero, dada la situaci√≥n actual, se ha convertido en un lugar com√∫n que los desarrolladores nunca entiendan completamente qu√© mecanismos est√°n involucrados en la operaci√≥n de los sistemas de autenticaci√≥n. <br><br>  Este material est√° dedicado al problema de organizar la autenticaci√≥n de usuarios en Node.js.  En √©l, en un ejemplo pr√°ctico, se considera la organizaci√≥n del registro de usuarios en el sistema y la organizaci√≥n de su entrada en el sistema.  Plantear√° problemas como trabajar con la tecnolog√≠a JWT y la suplantaci√≥n del usuario. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/8q/s0/uv/8qs0uvft-oqo_nmhu1vwlpf4rjw.jpeg"></a> <br><br>  Adem√°s, preste atenci√≥n a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> repositorio de GitHub, que contiene el c√≥digo para el proyecto Node.js, algunos ejemplos de los cuales se dan en este art√≠culo.  Puede usar este repositorio como base para sus propios experimentos. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Requisitos del proyecto</font> </h2><br>  Aqu√≠ est√°n los requisitos para el proyecto que trataremos aqu√≠: <br><br><ul><li>  La presencia de una base de datos en la que se almacenar√°n la direcci√≥n de correo electr√≥nico y la contrase√±a del usuario, ya sea clientId y clientSecret, o una especie de combinaci√≥n de claves privadas y p√∫blicas. </li><li>  Usando un algoritmo criptogr√°fico fuerte y eficiente para encriptar una contrase√±a. </li></ul><br>  En el momento en que escribo este material, creo que el mejor de los algoritmos criptogr√°ficos existentes es Argon2.  Le pido que no use algoritmos criptogr√°ficos simples como SHA256, SHA512 o MD5. <br><br>  Adem√°s, le sugiero que eche un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> maravilloso material, en el que puede encontrar detalles sobre c√≥mo elegir un algoritmo para contrase√±as hash. <br><br><h2>  <font color="#3AC1EF">Registro de usuarios en el sistema.</font> </h2><br>  Cuando se crea un nuevo usuario en el sistema, su contrase√±a debe ser cifrada y almacenada en la base de datos.  La contrase√±a se almacena en la base de datos junto con la direcci√≥n de correo electr√≥nico y otra informaci√≥n sobre el usuario (por ejemplo, entre ellos puede haber un perfil de usuario, tiempo de registro, etc.). <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> argon2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{   public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> SignUp(email, password, name): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;any&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> passwordHashed = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> argon2.hash(password);     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.create({       <span class="hljs-attr"><span class="hljs-attr">password</span></span>: passwordHashed,       email,       name,     });     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       <span class="hljs-comment"><span class="hljs-comment">//    - !!!       user: {         email: userRecord.email,         name: userRecord.name,       },       }</span></span></code> </pre> <br>  La informaci√≥n de la cuenta de usuario deber√≠a verse como la siguiente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b3/df3/027/2b3df30272e36e256f719b93ddf1197c.jpg"></div><br>  <i><font color="#999999">Datos de usuario recuperados de MongoDB usando Robo3T</font></i> <br><br><h2>  <font color="#3AC1EF">Inicio de sesi√≥n de usuario</font> </h2><br>  Aqu√≠ hay un diagrama de las acciones realizadas cuando un usuario intenta iniciar sesi√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/449/370/7e2/4493707e27d80de68619e12f8e7a8639.png"></div><br>  <i><font color="#999999">Inicio de sesi√≥n de usuario</font></i> <br><br>  Esto es lo que sucede cuando un usuario inicia sesi√≥n: <br><br><ul><li>  El cliente env√≠a al servidor una combinaci√≥n del identificador p√∫blico y la clave privada del usuario.  Esta suele ser una direcci√≥n de correo electr√≥nico y una contrase√±a. </li><li>  El servidor busca al usuario en la base de datos por direcci√≥n de correo electr√≥nico. </li><li>  Si el usuario existe en la base de datos, el servidor codifica la contrase√±a que se le envi√≥ y compara lo que sucedi√≥ con el hash de contrase√±a almacenado en la base de datos. </li><li>  Si la verificaci√≥n es exitosa, el servidor genera un llamado token o token de autenticaci√≥n: JSON Web Token (JWT). </li></ul><br>  JWT es una clave temporal.  El cliente debe enviar esta clave al servidor con cada solicitud al punto final autenticado. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> argon2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{  public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Login(email, password): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;any&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ email });    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!userRecord) {      <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>)    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> correctPassword = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> argon2.verify(userRecord.password, password);      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!correctPassword) {        <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Incorrect password'</span></span>)            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {      <span class="hljs-attr"><span class="hljs-attr">user</span></span>: {        <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userRecord.email,        <span class="hljs-attr"><span class="hljs-attr">name</span></span>: userRecord.name,      },      <span class="hljs-attr"><span class="hljs-attr">token</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generateJWT(userRecord),    }</code> </pre> <br>  La verificaci√≥n de contrase√±a se realiza utilizando la biblioteca argon2.  Esto es para prevenir los llamados " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ataques de tiempo</a> ".  Al realizar dicho ataque, un atacante intenta descifrar la contrase√±a por la fuerza bruta, bas√°ndose en un an√°lisis de cu√°nto tiempo necesita el servidor para formar una respuesta. <br><br>  Ahora hablemos sobre c√≥mo generar JWT. <br><br><h2>  <font color="#3AC1EF">¬øQu√© es un JWT?</font> </h2><br>  JSON Web Token (JWT) es un objeto JSON codificado en forma de cadena.  Los tokens se pueden tomar como un sustituto de las cookies, lo que tiene varias ventajas sobre ellas. <br><br>  El token consta de tres partes.  Este es el encabezado, la carga √∫til y la firma.  La siguiente figura muestra su apariencia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f16/a11/08d/f16a1108de7e0a5d8e4754725aacc830.jpg"></div><br>  <i><font color="#999999">Jwt</font></i> <br><br>  Los datos de token se pueden decodificar en el lado del cliente sin el uso de una clave secreta o firma. <br><br>  Esto puede ser √∫til para transferir, por ejemplo, metadatos codificados dentro del token.  Dichos metadatos pueden describir la funci√≥n del usuario, su perfil, la duraci√≥n del token, etc.  Se pueden utilizar en aplicaciones de front-end. <br><br>  As√≠ es como se ver√≠a una ficha decodificada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/734/5fa/3e57345fafedf8eaa0d326190aa03b47.jpg"></div><br>  <i><font color="#999999">Token Decodificado</font></i> <br><br><h2>  <font color="#3AC1EF">Generando JWT en Node.js</font> </h2><br>  Creemos la funci√≥n <code>generateToken</code> que necesitamos para completar el trabajo en el servicio de autenticaci√≥n de usuario. <br><br>  Puede crear JWT utilizando la biblioteca jsonwebtoken.  Puedes encontrar esta biblioteca en npm. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'jsonwebtoken'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{  private generateToken(user) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = {      <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: user._id,      <span class="hljs-attr"><span class="hljs-attr">name</span></span>: user.name,      <span class="hljs-attr"><span class="hljs-attr">email</span></span>: user.email    };    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signature = <span class="hljs-string"><span class="hljs-string">'MySuP3R_z3kr3t'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> expiration = <span class="hljs-string"><span class="hljs-string">'6h'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jwt.sign({ data, }, signature, { <span class="hljs-attr"><span class="hljs-attr">expiresIn</span></span>: expiration }); }</code> </pre> <br>  Lo m√°s importante aqu√≠ son los datos codificados.  No env√≠e informaci√≥n secreta del usuario en tokens. <br><br>  Una firma (aqu√≠ es la constante de <code>signature</code> ) son los datos secretos que se utilizan para generar el JWT.  Es muy importante asegurarse de que la firma no caiga en las manos equivocadas.  Si la firma se ve comprometida, el atacante podr√° generar tokens en nombre de los usuarios y robar sus sesiones. <br><br><h2>  <font color="#3AC1EF">Endpoint Protection y JWT Validation</font> </h2><br>  Ahora el c√≥digo del cliente debe enviar un JWT en cada solicitud a un punto final seguro. <br><br>  Se recomienda que incluya JWT en los encabezados de solicitud.  Generalmente se incluyen en el encabezado de Autorizaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/4dd/19d/b5c4dd19dfd705c210c9b4f5ce5212cf.jpg"></div><br>  <i><font color="#999999">Encabezado de autorizaci√≥n</font></i> <br><br>  Ahora, en el servidor, debe crear c√≥digo que sea middleware para rutas express.  Pon este c√≥digo en el archivo <code>isAuth.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express-jwt'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      ,  JWT      Authorization,        req.body,    ,      ,     . const getTokenFromHeader = (req) =&gt; {  if (req.headers.authorization &amp;&amp; req.headers.authorization.split(' ')[0] === 'Bearer') {    return req.headers.authorization.split(' ')[1]; } export default jwt({  secret: 'MySuP3R_z3kr3t', //      ,     JWT  userProperty: 'token', //       ,     services/auth:generateToken -&gt; 'req.token'  getToken: getTokenFromHeader, //        })</span></span></code> </pre> <br>  Es √∫til poder obtener informaci√≥n completa sobre la cuenta de usuario de la base de datos y adjuntarla a la solicitud.  En nuestro caso, esta caracter√≠stica se implementa utilizando middleware del archivo <code>attachCurrentUser.ts</code> .  Aqu√≠ est√° su c√≥digo simplificado: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (req, res, next) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> decodedTokenData = req.tokenData; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: decodedTokenData._id })  req.currentUser = userRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!userRecord) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">401</span></span>).end(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next(); }</code> </pre> <br>  Despu√©s de implementar este mecanismo, las rutas podr√°n recibir informaci√≥n sobre el usuario que est√° ejecutando la solicitud: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> isAuth <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/isAuth'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> attachCurrentUser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/attachCurrentUser'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ItemsModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/items'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (app) =&gt; {    app.get(<span class="hljs-string"><span class="hljs-string">'/inventory/personal-items'</span></span>, isAuth, attachCurrentUser, (req, res) =&gt; {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = req.currentUser;      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userItems = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ItemsModel.find({ <span class="hljs-attr"><span class="hljs-attr">owner</span></span>: user._id });      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.json(userItems).status(<span class="hljs-number"><span class="hljs-number">200</span></span>);    })</code> </pre> <br>  La ruta de <code>inventory/personal-items</code> ahora est√° protegida.  Para acceder a √©l, el usuario debe tener un JWT v√°lido.  Adem√°s, una ruta puede utilizar la informaci√≥n del usuario para buscar en la base de datos la informaci√≥n que necesita. <br><br><h2>  <font color="#3AC1EF">¬øPor qu√© se protegen los tokens de los intrusos?</font> </h2><br>  Despu√©s de leer sobre el uso de JWT, puede hacerse la siguiente pregunta: "Si los datos de JWT pueden decodificarse en el lado del cliente, ¬øes posible procesar el token de tal manera que cambie la identificaci√≥n del usuario u otros datos?". <br><br>  Decodificaci√≥n de tokens: la operaci√≥n es muy simple.  Sin embargo, no puede "rehacer" este token sin tener esa firma, esos datos secretos que se usaron al firmar el JWT en el servidor. <br><br>  Es por eso que la protecci√≥n de estos datos sensibles es tan importante. <br><br>  Nuestro servidor verifica la firma en el middleware isAuth.  La biblioteca express-jwt es responsable de verificar. <br><br>  Ahora, despu√©s de descubrir c√≥mo funciona la tecnolog√≠a JWT, hablemos de algunas caracter√≠sticas adicionales interesantes que nos brinda. <br><br><h2>  <font color="#3AC1EF">¬øC√≥mo hacerse pasar por un usuario?</font> </h2><br>  La suplantaci√≥n de usuario es una t√©cnica utilizada para iniciar sesi√≥n en un sistema como un usuario espec√≠fico sin conocer su contrase√±a. <br><br>  Esta caracter√≠stica es muy √∫til para superadministradores, desarrolladores o personal de soporte.  La suplantaci√≥n les permite resolver problemas que aparecen solo en el curso de los usuarios que trabajan con el sistema. <br><br>  Puede trabajar con la aplicaci√≥n en nombre del usuario sin conocer su contrase√±a.  Para hacer esto, es suficiente generar un JWT con la firma correcta y con los metadatos necesarios que describen al usuario. <br><br>  Cree un punto final que pueda generar tokens para ingresar al sistema bajo la apariencia de usuarios espec√≠ficos.  Solo el superadministrador del sistema puede usar este punto final. <br><br>  Para empezar, debemos asignar a este usuario un rol con un nivel de privilegio m√°s alto que otros usuarios.  Esto se puede hacer de muchas maneras diferentes.  Por ejemplo, simplemente agregando el campo de <code>role</code> a la informaci√≥n del usuario almacenada en la base de datos. <br><br>  Puede parecerse al que se muestra a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/c19/30e/f69c1930ec89fdf649d73772cc7754bc.jpg"></div><br>  <i><font color="#999999">Nuevo campo en la informaci√≥n del usuario</font></i> <br><br>  El valor del campo de <code>role</code> superadministrador es <code>super-admin</code> . <br><br>  A continuaci√≥n, debe crear un nuevo middleware que verifique el rol del usuario: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (requiredRole) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(req.currentUser.role === requiredRole) {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next();    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">401</span></span>).send(<span class="hljs-string"><span class="hljs-string">'Action not allowed'</span></span>);    }</code> </pre> <br>  Debe colocarse despu√©s de isAuth y attachCurrentUser.  Ahora cree el punto final que genera el JWT para el usuario en nombre del cual el s√∫per administrador desea iniciar sesi√≥n: <br><br><pre> <code class="javascript hljs">  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> isAuth <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/isAuth'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> attachCurrentUser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/attachCurrentUser'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> roleRequired <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlwares/roleRequired'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UserModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/user'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (app) =&gt; {    app.post(<span class="hljs-string"><span class="hljs-string">'/auth/signin-as-user'</span></span>, isAuth, attachCurrentUser, roleRequired(<span class="hljs-string"><span class="hljs-string">'super-admin'</span></span>), (req, res) =&gt; {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userEmail = req.body.email;      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userEmail });      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!userRecord) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">404</span></span>).send(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>);           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.json({        <span class="hljs-attr"><span class="hljs-attr">user</span></span>: {          <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userRecord.email,          <span class="hljs-attr"><span class="hljs-attr">name</span></span>: userRecord.name        },        <span class="hljs-attr"><span class="hljs-attr">jwt</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generateToken(userRecord)      })      .status(<span class="hljs-number"><span class="hljs-number">200</span></span>);    })</code> </pre> <br>  Como puede ver, no hay nada misterioso.  El superadministrador conoce la direcci√≥n de correo electr√≥nico del usuario en nombre de quien desea iniciar sesi√≥n.  La l√≥gica del c√≥digo anterior recuerda mucho c√≥mo funciona el c√≥digo, proporcionando una entrada al sistema de los usuarios comunes.  La principal diferencia es que la contrase√±a no est√° marcada aqu√≠. <br>  La contrase√±a no se verifica aqu√≠ debido al hecho de que simplemente no se necesita aqu√≠.  La seguridad del punto final es proporcionada por middleware. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  No hay nada de malo en confiar en servicios y bibliotecas de autenticaci√≥n de terceros.  Esto ayuda a los desarrolladores a ahorrar tiempo.  Pero tambi√©n deben conocer los principios en los que se basa el funcionamiento de los sistemas de autenticaci√≥n y qu√© garantiza el funcionamiento de dichos sistemas. <br><br>  En este art√≠culo, exploramos las posibilidades de autenticaci√≥n JWT, hablamos sobre la importancia de elegir un buen algoritmo criptogr√°fico para contrase√±as hash.  Examinamos la creaci√≥n de un mecanismo de suplantaci√≥n de usuario. <br><br>  Hacer lo mismo con algo como passport.js est√° lejos de ser f√°cil.  La autenticaci√≥n es un gran tema.  Quiz√°s volvamos a ella. <br><br>  <b>Estimados lectores!</b>  ¬øC√≥mo se crean sistemas de autenticaci√≥n para sus proyectos Node.js? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457700/">https://habr.com/ru/post/457700/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457690/index.html">Video paranoico de Yandex.Money metap</a></li>
<li><a href="../457692/index.html">Reflexiones sobre los est√°ndares nacionales de NB-Fi y los sistemas de facturaci√≥n</a></li>
<li><a href="../457694/index.html">Los peligros de usar constantes de varios caracteres</a></li>
<li><a href="../457696/index.html">Los peligros de usar constantes de varios caracteres</a></li>
<li><a href="../457698/index.html">Experimento: utilizamos proxies como herramienta para combatir ataques DoS</a></li>
<li><a href="../457702/index.html">Trabajar con la API de KOMPAS-3D ‚Üí Lecci√≥n 16 ‚Üí Caracteres de control</a></li>
<li><a href="../457704/index.html">C√≥mo las GPU manejan la ramificaci√≥n</a></li>
<li><a href="../457706/index.html">Robot prueba SAP ERP</a></li>
<li><a href="../457710/index.html">Las incre√≠bles caracter√≠sticas de las redes neuronales 2019</a></li>
<li><a href="../457712/index.html">C√≥mo Verizon y BGP Optimizer configuran una excelente conexi√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>