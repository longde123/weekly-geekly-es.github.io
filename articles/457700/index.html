<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆🏻 🔬 ➡️ Guía de autenticación de Node.js sin passport.js y servicios de terceros 🚽 🔝 🤕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El autor del artículo, cuya traducción publicamos hoy, dice que ahora puede observar la creciente popularidad de los servicios de autenticación como G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guía de autenticación de Node.js sin passport.js y servicios de terceros</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/457700/">  El autor del artículo, cuya traducción publicamos hoy, dice que ahora puede observar la creciente popularidad de los servicios de autenticación como Google Firebase Authentication, AWS Cognito y Auth0.  Las soluciones genéricas como passport.js se han convertido en el estándar de la industria.  Pero, dada la situación actual, se ha convertido en un lugar común que los desarrolladores nunca entiendan completamente qué mecanismos están involucrados en la operación de los sistemas de autenticación. <br><br>  Este material está dedicado al problema de organizar la autenticación de usuarios en Node.js.  En él, en un ejemplo práctico, se considera la organización del registro de usuarios en el sistema y la organización de su entrada en el sistema.  Planteará problemas como trabajar con la tecnología JWT y la suplantación del usuario. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/8q/s0/uv/8qs0uvft-oqo_nmhu1vwlpf4rjw.jpeg"></a> <br><br>  Además, preste atención a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> repositorio de GitHub, que contiene el código para el proyecto Node.js, algunos ejemplos de los cuales se dan en este artículo.  Puede usar este repositorio como base para sus propios experimentos. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Requisitos del proyecto</font> </h2><br>  Aquí están los requisitos para el proyecto que trataremos aquí: <br><br><ul><li>  La presencia de una base de datos en la que se almacenarán la dirección de correo electrónico y la contraseña del usuario, ya sea clientId y clientSecret, o una especie de combinación de claves privadas y públicas. </li><li>  Usando un algoritmo criptográfico fuerte y eficiente para encriptar una contraseña. </li></ul><br>  En el momento en que escribo este material, creo que el mejor de los algoritmos criptográficos existentes es Argon2.  Le pido que no use algoritmos criptográficos simples como SHA256, SHA512 o MD5. <br><br>  Además, le sugiero que eche un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> maravilloso material, en el que puede encontrar detalles sobre cómo elegir un algoritmo para contraseñas hash. <br><br><h2>  <font color="#3AC1EF">Registro de usuarios en el sistema.</font> </h2><br>  Cuando se crea un nuevo usuario en el sistema, su contraseña debe ser cifrada y almacenada en la base de datos.  La contraseña se almacena en la base de datos junto con la dirección de correo electrónico y otra información sobre el usuario (por ejemplo, entre ellos puede haber un perfil de usuario, tiempo de registro, etc.). <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> argon2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{   public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> SignUp(email, password, name): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;any&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> passwordHashed = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> argon2.hash(password);     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.create({       <span class="hljs-attr"><span class="hljs-attr">password</span></span>: passwordHashed,       email,       name,     });     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       <span class="hljs-comment"><span class="hljs-comment">//    - !!!       user: {         email: userRecord.email,         name: userRecord.name,       },       }</span></span></code> </pre> <br>  La información de la cuenta de usuario debería verse como la siguiente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b3/df3/027/2b3df30272e36e256f719b93ddf1197c.jpg"></div><br>  <i><font color="#999999">Datos de usuario recuperados de MongoDB usando Robo3T</font></i> <br><br><h2>  <font color="#3AC1EF">Inicio de sesión de usuario</font> </h2><br>  Aquí hay un diagrama de las acciones realizadas cuando un usuario intenta iniciar sesión. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/449/370/7e2/4493707e27d80de68619e12f8e7a8639.png"></div><br>  <i><font color="#999999">Inicio de sesión de usuario</font></i> <br><br>  Esto es lo que sucede cuando un usuario inicia sesión: <br><br><ul><li>  El cliente envía al servidor una combinación del identificador público y la clave privada del usuario.  Esta suele ser una dirección de correo electrónico y una contraseña. </li><li>  El servidor busca al usuario en la base de datos por dirección de correo electrónico. </li><li>  Si el usuario existe en la base de datos, el servidor codifica la contraseña que se le envió y compara lo que sucedió con el hash de contraseña almacenado en la base de datos. </li><li>  Si la verificación es exitosa, el servidor genera un llamado token o token de autenticación: JSON Web Token (JWT). </li></ul><br>  JWT es una clave temporal.  El cliente debe enviar esta clave al servidor con cada solicitud al punto final autenticado. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> argon2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{  public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Login(email, password): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;any&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ email });    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!userRecord) {      <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>)    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> correctPassword = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> argon2.verify(userRecord.password, password);      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!correctPassword) {        <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Incorrect password'</span></span>)            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {      <span class="hljs-attr"><span class="hljs-attr">user</span></span>: {        <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userRecord.email,        <span class="hljs-attr"><span class="hljs-attr">name</span></span>: userRecord.name,      },      <span class="hljs-attr"><span class="hljs-attr">token</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generateJWT(userRecord),    }</code> </pre> <br>  La verificación de contraseña se realiza utilizando la biblioteca argon2.  Esto es para prevenir los llamados " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ataques de tiempo</a> ".  Al realizar dicho ataque, un atacante intenta descifrar la contraseña por la fuerza bruta, basándose en un análisis de cuánto tiempo necesita el servidor para formar una respuesta. <br><br>  Ahora hablemos sobre cómo generar JWT. <br><br><h2>  <font color="#3AC1EF">¿Qué es un JWT?</font> </h2><br>  JSON Web Token (JWT) es un objeto JSON codificado en forma de cadena.  Los tokens se pueden tomar como un sustituto de las cookies, lo que tiene varias ventajas sobre ellas. <br><br>  El token consta de tres partes.  Este es el encabezado, la carga útil y la firma.  La siguiente figura muestra su apariencia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f16/a11/08d/f16a1108de7e0a5d8e4754725aacc830.jpg"></div><br>  <i><font color="#999999">Jwt</font></i> <br><br>  Los datos de token se pueden decodificar en el lado del cliente sin el uso de una clave secreta o firma. <br><br>  Esto puede ser útil para transferir, por ejemplo, metadatos codificados dentro del token.  Dichos metadatos pueden describir la función del usuario, su perfil, la duración del token, etc.  Se pueden utilizar en aplicaciones de front-end. <br><br>  Así es como se vería una ficha decodificada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/734/5fa/3e57345fafedf8eaa0d326190aa03b47.jpg"></div><br>  <i><font color="#999999">Token Decodificado</font></i> <br><br><h2>  <font color="#3AC1EF">Generando JWT en Node.js</font> </h2><br>  Creemos la función <code>generateToken</code> que necesitamos para completar el trabajo en el servicio de autenticación de usuario. <br><br>  Puede crear JWT utilizando la biblioteca jsonwebtoken.  Puedes encontrar esta biblioteca en npm. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'jsonwebtoken'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{  private generateToken(user) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = {      <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: user._id,      <span class="hljs-attr"><span class="hljs-attr">name</span></span>: user.name,      <span class="hljs-attr"><span class="hljs-attr">email</span></span>: user.email    };    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signature = <span class="hljs-string"><span class="hljs-string">'MySuP3R_z3kr3t'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> expiration = <span class="hljs-string"><span class="hljs-string">'6h'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jwt.sign({ data, }, signature, { <span class="hljs-attr"><span class="hljs-attr">expiresIn</span></span>: expiration }); }</code> </pre> <br>  Lo más importante aquí son los datos codificados.  No envíe información secreta del usuario en tokens. <br><br>  Una firma (aquí es la constante de <code>signature</code> ) son los datos secretos que se utilizan para generar el JWT.  Es muy importante asegurarse de que la firma no caiga en las manos equivocadas.  Si la firma se ve comprometida, el atacante podrá generar tokens en nombre de los usuarios y robar sus sesiones. <br><br><h2>  <font color="#3AC1EF">Endpoint Protection y JWT Validation</font> </h2><br>  Ahora el código del cliente debe enviar un JWT en cada solicitud a un punto final seguro. <br><br>  Se recomienda que incluya JWT en los encabezados de solicitud.  Generalmente se incluyen en el encabezado de Autorización. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/4dd/19d/b5c4dd19dfd705c210c9b4f5ce5212cf.jpg"></div><br>  <i><font color="#999999">Encabezado de autorización</font></i> <br><br>  Ahora, en el servidor, debe crear código que sea middleware para rutas express.  Pon este código en el archivo <code>isAuth.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express-jwt'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      ,  JWT      Authorization,        req.body,    ,      ,     . const getTokenFromHeader = (req) =&gt; {  if (req.headers.authorization &amp;&amp; req.headers.authorization.split(' ')[0] === 'Bearer') {    return req.headers.authorization.split(' ')[1]; } export default jwt({  secret: 'MySuP3R_z3kr3t', //      ,     JWT  userProperty: 'token', //       ,     services/auth:generateToken -&gt; 'req.token'  getToken: getTokenFromHeader, //        })</span></span></code> </pre> <br>  Es útil poder obtener información completa sobre la cuenta de usuario de la base de datos y adjuntarla a la solicitud.  En nuestro caso, esta característica se implementa utilizando middleware del archivo <code>attachCurrentUser.ts</code> .  Aquí está su código simplificado: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (req, res, next) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> decodedTokenData = req.tokenData; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: decodedTokenData._id })  req.currentUser = userRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!userRecord) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">401</span></span>).end(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next(); }</code> </pre> <br>  Después de implementar este mecanismo, las rutas podrán recibir información sobre el usuario que está ejecutando la solicitud: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> isAuth <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/isAuth'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> attachCurrentUser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/attachCurrentUser'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ItemsModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/items'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (app) =&gt; {    app.get(<span class="hljs-string"><span class="hljs-string">'/inventory/personal-items'</span></span>, isAuth, attachCurrentUser, (req, res) =&gt; {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = req.currentUser;      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userItems = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ItemsModel.find({ <span class="hljs-attr"><span class="hljs-attr">owner</span></span>: user._id });      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.json(userItems).status(<span class="hljs-number"><span class="hljs-number">200</span></span>);    })</code> </pre> <br>  La ruta de <code>inventory/personal-items</code> ahora está protegida.  Para acceder a él, el usuario debe tener un JWT válido.  Además, una ruta puede utilizar la información del usuario para buscar en la base de datos la información que necesita. <br><br><h2>  <font color="#3AC1EF">¿Por qué se protegen los tokens de los intrusos?</font> </h2><br>  Después de leer sobre el uso de JWT, puede hacerse la siguiente pregunta: "Si los datos de JWT pueden decodificarse en el lado del cliente, ¿es posible procesar el token de tal manera que cambie la identificación del usuario u otros datos?". <br><br>  Decodificación de tokens: la operación es muy simple.  Sin embargo, no puede "rehacer" este token sin tener esa firma, esos datos secretos que se usaron al firmar el JWT en el servidor. <br><br>  Es por eso que la protección de estos datos sensibles es tan importante. <br><br>  Nuestro servidor verifica la firma en el middleware isAuth.  La biblioteca express-jwt es responsable de verificar. <br><br>  Ahora, después de descubrir cómo funciona la tecnología JWT, hablemos de algunas características adicionales interesantes que nos brinda. <br><br><h2>  <font color="#3AC1EF">¿Cómo hacerse pasar por un usuario?</font> </h2><br>  La suplantación de usuario es una técnica utilizada para iniciar sesión en un sistema como un usuario específico sin conocer su contraseña. <br><br>  Esta característica es muy útil para superadministradores, desarrolladores o personal de soporte.  La suplantación les permite resolver problemas que aparecen solo en el curso de los usuarios que trabajan con el sistema. <br><br>  Puede trabajar con la aplicación en nombre del usuario sin conocer su contraseña.  Para hacer esto, es suficiente generar un JWT con la firma correcta y con los metadatos necesarios que describen al usuario. <br><br>  Cree un punto final que pueda generar tokens para ingresar al sistema bajo la apariencia de usuarios específicos.  Solo el superadministrador del sistema puede usar este punto final. <br><br>  Para empezar, debemos asignar a este usuario un rol con un nivel de privilegio más alto que otros usuarios.  Esto se puede hacer de muchas maneras diferentes.  Por ejemplo, simplemente agregando el campo de <code>role</code> a la información del usuario almacenada en la base de datos. <br><br>  Puede parecerse al que se muestra a continuación. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/c19/30e/f69c1930ec89fdf649d73772cc7754bc.jpg"></div><br>  <i><font color="#999999">Nuevo campo en la información del usuario</font></i> <br><br>  El valor del campo de <code>role</code> superadministrador es <code>super-admin</code> . <br><br>  A continuación, debe crear un nuevo middleware que verifique el rol del usuario: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (requiredRole) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(req.currentUser.role === requiredRole) {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next();    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">401</span></span>).send(<span class="hljs-string"><span class="hljs-string">'Action not allowed'</span></span>);    }</code> </pre> <br>  Debe colocarse después de isAuth y attachCurrentUser.  Ahora cree el punto final que genera el JWT para el usuario en nombre del cual el súper administrador desea iniciar sesión: <br><br><pre> <code class="javascript hljs">  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> isAuth <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/isAuth'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> attachCurrentUser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/attachCurrentUser'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> roleRequired <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlwares/roleRequired'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UserModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/user'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (app) =&gt; {    app.post(<span class="hljs-string"><span class="hljs-string">'/auth/signin-as-user'</span></span>, isAuth, attachCurrentUser, roleRequired(<span class="hljs-string"><span class="hljs-string">'super-admin'</span></span>), (req, res) =&gt; {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userEmail = req.body.email;      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userEmail });      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!userRecord) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">404</span></span>).send(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>);           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.json({        <span class="hljs-attr"><span class="hljs-attr">user</span></span>: {          <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userRecord.email,          <span class="hljs-attr"><span class="hljs-attr">name</span></span>: userRecord.name        },        <span class="hljs-attr"><span class="hljs-attr">jwt</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generateToken(userRecord)      })      .status(<span class="hljs-number"><span class="hljs-number">200</span></span>);    })</code> </pre> <br>  Como puede ver, no hay nada misterioso.  El superadministrador conoce la dirección de correo electrónico del usuario en nombre de quien desea iniciar sesión.  La lógica del código anterior recuerda mucho cómo funciona el código, proporcionando una entrada al sistema de los usuarios comunes.  La principal diferencia es que la contraseña no está marcada aquí. <br>  La contraseña no se verifica aquí debido al hecho de que simplemente no se necesita aquí.  La seguridad del punto final es proporcionada por middleware. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  No hay nada de malo en confiar en servicios y bibliotecas de autenticación de terceros.  Esto ayuda a los desarrolladores a ahorrar tiempo.  Pero también deben conocer los principios en los que se basa el funcionamiento de los sistemas de autenticación y qué garantiza el funcionamiento de dichos sistemas. <br><br>  En este artículo, exploramos las posibilidades de autenticación JWT, hablamos sobre la importancia de elegir un buen algoritmo criptográfico para contraseñas hash.  Examinamos la creación de un mecanismo de suplantación de usuario. <br><br>  Hacer lo mismo con algo como passport.js está lejos de ser fácil.  La autenticación es un gran tema.  Quizás volvamos a ella. <br><br>  <b>Estimados lectores!</b>  ¿Cómo se crean sistemas de autenticación para sus proyectos Node.js? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457700/">https://habr.com/ru/post/457700/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457690/index.html">Video paranoico de Yandex.Money metap</a></li>
<li><a href="../457692/index.html">Reflexiones sobre los estándares nacionales de NB-Fi y los sistemas de facturación</a></li>
<li><a href="../457694/index.html">Los peligros de usar constantes de varios caracteres</a></li>
<li><a href="../457696/index.html">Los peligros de usar constantes de varios caracteres</a></li>
<li><a href="../457698/index.html">Experimento: utilizamos proxies como herramienta para combatir ataques DoS</a></li>
<li><a href="../457702/index.html">Trabajar con la API de KOMPAS-3D → Lección 16 → Caracteres de control</a></li>
<li><a href="../457704/index.html">Cómo las GPU manejan la ramificación</a></li>
<li><a href="../457706/index.html">Robot prueba SAP ERP</a></li>
<li><a href="../457710/index.html">Las increíbles características de las redes neuronales 2019</a></li>
<li><a href="../457712/index.html">Cómo Verizon y BGP Optimizer configuran una excelente conexión</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>