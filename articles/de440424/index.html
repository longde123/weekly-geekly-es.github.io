<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏾 🌓 📁 Algorithmus des Denkens und des Bewusstseins 🍸 ⚖️ 🌅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel beschreibt einen Algorithmus für Denken und Bewusstsein. Ich biete meine Antwort auf die Frage, wie Denken und Bewusstsein funktioniere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithmus des Denkens und des Bewusstseins</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440424/">  Dieser Artikel beschreibt einen Algorithmus für Denken und Bewusstsein.  Ich biete meine Antwort auf die Frage, wie Denken und Bewusstsein funktionieren.  Und ich demonstriere einen Algorithmus, der wirklich, kreativ denken und echtes Bewusstsein besitzen kann.  Der Artikel richtet sich an Programmierer und besteht aus zwei Hauptteilen.  Der erste Teil ist rein technisch und enthält eine Beschreibung des Algorithmus, eine Liste seiner Eigenschaften und ein Beispiel für die praktische Anwendung.  Der zweite Teil enthält erklärende Thesen und eine Lösung für die Frage der konstruktiven Axiomatisierung des Bewusstseins.  Ein Algorithmus ist ein aussagekräftiger Text, der für sich selbst spricht, und daher gibt es nur praktisch notwendige Mindestkommentare. <br><a name="habracut"></a><br><h2>  Beschreibung des Algorithmus </h2><br>  Die Beschreibung des Algorithmus erfolgt in einem selbst erstellten mathematisierten Formalismus nach dem "Top-Down" -Prinzip, dh es wird zuerst eine endgültige, abstrakte Aufzeichnung gegeben, und dann wird der Algorithmus auf Teile in der Reihenfolge analysiert, in der Aufrufe und Kommentare gegeben werden.  Der "zusammengesetzte" Algorithmus ist also eine rekursive Funktion der folgenden Form: <br><br>  <font color="#0000ff">t <sub>n + 1</sub> = <b>Zusammensetzung</b> [ <b>Abstraktion</b> [ <b>Abzug</b> [t <sub>n</sub> ]]];</font>  <font color="#0000ff">t <sub>0</sub> = s;</font>  <font color="#0000ff">t <sub>n</sub> , s ∈ <b>S</b> ;</font>  <font color="#0000ff">n ∈ <b>N.</b></font> <br><br>  Die Berechnung dieser Funktion ist Denken.  Wie Sie sehen können, erscheinen drei Operatoren im Datensatz: <br>  <font color="#0000ff"><b>Komposition</b> []</font> , <font color="#0000ff"><b>Abstraktion</b> []</font> , <font color="#0000ff"><b>Abzug</b> []</font> ;  es gibt auch: die Startvariable <font color="#0000ff">s ∈ <b>S</b></font> , die Menge der Zeilen einer speziellen Form <font color="#0000ff"><b>S</b></font> und die Schrittnummer <font color="#0000ff">n ∈ <b>N.</b></font>  Als nächstes betrachten wir jedes Ersatzteil im Detail.  Wir beginnen mit der Menge <font color="#0000ff"><b>S</b></font> und ihren Elementen. <br><br>  Um die Menge <font color="#0000ff"><b>S</b></font> anzugeben <font color="#0000ff"><b>,</b></font> muss die Syntax festgelegt werden, in die die Elemente dieser Menge geschrieben werden.  Elemente der Menge <font color="#0000ff"><b>S</b></font> werden Strings genannt.  Jede Zeile in <font color="#0000ff"><b>S</b></font> besteht aus einer Hierarchie von Klammern "(", ")", und in die Klammern sind beliebige Zeichenbezeichner geschrieben.  Um die Verwendung des Begriffs "Bezeichner" zu vermeiden, wie er für andere Zwecke erforderlich sein kann, werden symbolische Bezeichner in den Klammern als "Mnemonik" bezeichnet.  Jede Mnemonik ist in lateinischen Zeichen „A - z“ geschrieben.  Mnemonik in Klammern kann durch ein Komma "," getrennt werden.  Wenn die Länge der Mnemonik festgelegt ist, die separat angegeben wird, wird das Trennzeichen nicht festgelegt.  Mnemonics werden nur in Klammern geschrieben.  Eine Zeile kann verschachtelte Klammern enthalten.  Die Hierarchie der Klammern in der Zeichenfolge ist beliebig, es muss jedoch für jede öffnende Klammer eine schließende Klammer vorhanden sein.  In diesem Artikel werde ich nur kleine Buchstaben des lateinischen Alphabets zum Schreiben von Mnemonics verwenden, und die Länge der Mnemonics wird festgelegt. Ein Buchstabe entspricht einer Mnemonik. Ich setze kein Trennzeichen.  Beispiele für Zeilen: <br><br>  <font color="#0000ff">() ≡ ≡</font> ist eine leere Zeichenfolge. <br>  <font color="#0000ff">(a)</font> - eine Zeichenfolge, die eine Mnemonik " <font color="#0000ff">a</font> " enthält. <br>  <font color="#0000ff">(aa)</font> - eine Zeichenfolge, die zwei Kopien der Mnemonik „ <font color="#0000ff">a</font> “ enthält. <br>  <font color="#0000ff">(ab)</font> ist eine Zeichenfolge, die zwei Mnemoniken " <font color="#0000ff">a</font> " und " <font color="#0000ff">b</font> " enthält. <br>  <font color="#0000ff">((a) (a))</font> - Die Zeile enthält zwei Kopien der Mnemonik „ <font color="#0000ff">a</font> “ und verschachtelte Ebenen von Klammern. <br><br>  Die beiliegenden Klammern werden zusammen mit ihrem Inhalt sowie den einzelnen Mnemoniken manchmal als "Zeichenfolgenkomponenten" bezeichnet, wenn eine entsprechende Verallgemeinerung erforderlich ist.  Beispielsweise enthält Zeile <font color="#0000ff">((a) ab)</font> vier Komponenten, darunter zwei Komponenten " <font color="#0000ff">a</font> ", eine Komponente " <font color="#0000ff">(a)</font> " und eine Komponente " <font color="#0000ff">b</font> ". <br><br>  Aufzeichnungen von Zeichenfolgen, die mit einer Neuanordnung der Komponenten innerhalb der Zeichenfolge übereinstimmen, werden als identisch betrachtet.  Beispiele für identische Zeilen: <br><br>  <font color="#0000ff">(ab) ≡ (ba)</font> . <br>  <font color="#0000ff">((a) (b)) ≡ ((b) (a))</font> . <br>  <font color="#0000ff">(abc) ≡ (bac) ≡ (cba) ≡ (acb) ≡ (bca) ≡ (cab)</font> . <br>  <font color="#0000ff">((a) (ab)) ≡ ((a) (ba)) ≡ ((ab) (a)) ≡ ((ba) (a))</font> . <br><br>  Zeilen können eine beliebige Anzahl identischer, sich wiederholender Komponenten enthalten. In diesem Fall ist eine kürzere Aufzeichnung möglich, indem der Wiederholungsindex, der links vor der Komponente steht, ohne Trennzeichen verwendet wird.  Beispiele: <br><br>  <font color="#0000ff">(aa) ≡ (2a)</font> . <br>  <font color="#0000ff">(aabb) ≡ (2a2b)</font> . <br>  <font color="#0000ff">((a) (a)) ≡ (2 (a))</font> . <br>  <font color="#0000ff">((aa) (aa)) ≡ (2 (2a))</font> . <br>  <font color="#0000ff">(aa (bb) (bb) (ccc) (ccc) (ccc)) ≡ (2a2 (2b) 3 (3c))</font> . <br><br>  In den Fällen, in denen die Zeichenfolge leere Komponenten enthält, z. B. <font color="#0000ff">(a ())</font> , <font color="#0000ff">(a () () (b)), gelten folgende</font> Identitäten: <font color="#0000ff">(a ()) ≡ (a)</font> , <font color="#0000ff">(a () () (b )) ≡ (a (b))</font> , d. H. Leere Komponenten werden weggeworfen. <br><br>  <b>Definition</b>  Die Menge <font color="#0000ff"><b>S</b></font> besteht aus allen möglichen Zeichenfolgen, die die obigen Syntaxkriterien erfüllen, einschließlich einer leeren Zeichenfolge. <br><br>  Die Abzugs-, Abstraktions- und Kompositionsoperatoren sind in der Menge <font color="#0000ff"><b>S</b></font> definiert <font color="#0000ff"><b>.</b></font>  Operatorargumente werden in eckigen Klammern <font color="#0000ff">[] angegeben</font> , da Klammern für die Zeichenfolgensyntax reserviert sind.  Der Begriff "Operator" ist gleichbedeutend mit dem Begriff "Funktion". <br><br>  <b>Abzugsoperator</b> .  Definition  <font color="#0000ff">∀s ∈ <b>S</b> , <b>Abzug</b> <sup>k</sup> [s] ∈ <b>S</b> , k ∈ <b>N</b> , k&gt; 1, <b>Abzug</b> [s] ≝ <b>Abzug</b> <sup>2</sup> [s]</font> .  Nimmt die Zeichenfolge <font color="#0000ff">s</font> von <font color="#0000ff"><b>S</b></font> als Argument.  Gibt als Ergebnis eine Zeichenfolge von <font color="#0000ff"><b>S zurück.</b></font>  Aktion.  Der Operator dupliziert <font color="#0000ff">k-</font> mal jede Komponente der Zeichenfolge und die gesamte Zeichenfolge.  Die resultierende Struktur wird von gemeinsamen äußeren Klammern eingerahmt.  Die Vervielfältigung beginnt mit den tiefsten in Bezug auf die Verschachtelung von Komponenten.  Die gesamte Zeile wird zuletzt dupliziert.  Für unmittelbare praktische Zwecke reicht es aus, dass <font color="#0000ff">k = 2 ist</font> , also habe ich einen Sonderfall von <font color="#0000ff"><b>Abzug</b> [s] ≝ <b>Abzug</b> <sup>2</sup> [s] definiert</font> .  Die Verwendung von <font color="#0000ff"><b>deduction</b> []</font> impliziert, dass <font color="#0000ff">k = 2</font> ist, dh als Ergebnis des <font color="#0000ff"><b>deduction</b> [s]</font> -Operators werden alle Komponenten der Zeichenfolge <font color="#0000ff">s</font> verdoppelt.  Beispiele: <br><br>  <font color="#0000ff"><b>Abzug</b> [(a)] = ((aa) (aa)).</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>Abzug</b> [(aa)] = ((aaaa) (aaaa))</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>Abzug</b> [(ab)] = ((aabb) (aabb)).</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>Abzug</b> [(a (b))] = ((aa (bb) (bb)) (aa (bb) (bb))).</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>Abzug</b> [((a) (b))] = (((aa) (aa) (bb) (bb)) ((aa) (aa) (bb) (bb))).</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>Abzug</b> [((a) (b (cc)))] = (((aa) (aa) (bb (cccc) (cccc)) (bb (cccc) (cccc))) ((aa) (aa) ( bb (cccc) (cccc)) (bb (cccc) (cccc))))</font> . <br><br>  <b>Abstraktionsoperator</b> .  Definition  <font color="#0000ff">∀s ∈ <b>S</b> , <b>Abstraktion</b> [s] ⊂ <b>S.</b></font>  Nimmt die Zeichenfolge <font color="#0000ff">s</font> von <font color="#0000ff"><b>S</b></font> als Argument.  Infolgedessen werden viele Zeilen zurückgegeben.  Handlungsprinzip.  Ein Abstraktionsoperator erstellt viele Zeilen aus einer Quellzeile mithilfe einer speziellen Operation - Klammern identischer Komponenten.  Die Operation der Belichtungsreihe gilt nur für verschachtelte Belichtungsreihen, die sich auf derselben Verschachtelungsebene befinden.  Das allgemeine Prinzip der Klammerung.  Befinden sich in einer Kombination von Klammern auf derselben Ebene dieselben Komponenten in den Klammern, kann jeder Satz derselben Komponenten in Klammern gesetzt werden, und die intakten Komponenten sollten unter denselben allgemeinen Klammern derselben Ebene kombiniert werden.  Betrachten Sie ein Beispiel.  String <font color="#0000ff">((ab) (ac))</font> .  In dieser Zeile befinden sich zwei Teilzeichenfolgen auf derselben Ebene: <font color="#0000ff">(ab)</font> und <font color="#0000ff">(ac)</font> , in denen sich die gleichen Mnemoniken " <font color="#0000ff">a</font> " befinden. Diese Mnemoniken können in Klammern gesetzt werden und das Ergebnis ist <font color="#0000ff">(a (bc))</font> .  Wie Sie sehen können, werden die verbleibenden Mnemoniken " <font color="#0000ff">b</font> " und " <font color="#0000ff">c</font> " in gemeinsamen Klammern zusammengefasst.  Betrachten Sie ein weniger offensichtliches Beispiel.  Die Zeichenfolge <font color="#0000ff">((aa) (aa))</font> enthält die Teilzeichenfolgen <font color="#0000ff">(aa)</font> und <font color="#0000ff">(aa)</font> . In diesem Fall gibt es zwei verschiedene Optionen zum Löschen von Klammern.  In der ersten Variante kann nur eine Mnemonik " <font color="#0000ff">a</font> " aus Klammern von jedem Teilstring entfernt werden, und in der zweiten Variante kann eine Gruppe von Mnemoniken " <font color="#0000ff">aa</font> " herausgenommen werden.  Lassen Sie uns beide Optionen genauer betrachten. <br><br>  Erste Option, Schritt für Schritt Demonstration: <br><br><ol><li>  Schritt eins, wählen Sie ( <font color="#ff0000">rot</font> ), was Sie herausnehmen möchten <font color="#0000ff">(( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> a))</font> . </li><li>  Schritt zwei, machen Sie die Auswahl <font color="#0000ff">( <font color="#ff0000">a</font> (... a) (... a))</font> . </li><li>  Schritt drei, kombinieren Sie die Reste in gemeinsamen Klammern <font color="#0000ff">( <font color="#ff0000">a</font> (... a ... a))</font> . </li><li>  Ergebnis <font color="#0000ff">(a (aa))</font> . </li></ol><br>  Die zweite Option in Schritten: <br><br><ol><li>  Schritt eins, wählen Sie, was Sie <font color="#0000ff"><font color="#ff0000">herausnehmen</font> <font color="#ff0000">möchten</font> (( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> ))</font> . </li><li>  Schritt zwei, machen Sie die Auswahl <font color="#0000ff">( <font color="#ff0000">aa</font> (...) (...))</font> . </li><li>  Schritt drei, kombinieren Sie die Reste in gemeinsamen Klammern <font color="#0000ff">( <font color="#ff0000">aa</font> (...))</font> . </li><li>  Vierter Schritt, wirf die leeren Komponenten weg <font color="#0000ff">( <font color="#ff0000">aa</font> )</font> . </li><li>  Ergebnis <font color="#0000ff">(aa)</font> . </li></ol><br>  Lassen Sie uns das Beispiel komplizieren.  Es sei die Zeichenfolge <font color="#0000ff">((aa) (aab) (aab)) gegeben</font> , sie hat drei Teilzeichenfolgen auf derselben Ebene: <font color="#0000ff">(aa)</font> , <font color="#0000ff">(aab)</font> , <font color="#0000ff">(aab)</font> , alle drei haben den gleichen Inhalt.  Die Klammerregel verpflichtet uns nicht, die Operation für alle drei Teilzeichenfolgen gleichzeitig auszuführen.  Für den Absteckvorgang können Sie eine beliebige Gruppe von Teilzeichenfolgen auswählen. <br><br>  In diesem Fall gibt es drei nicht identische Optionen zum Gruppieren von Teilzeichenfolgen: <br><br><ol><li>  <font color="#0000ff">(aa), (aab)</font> . </li><li>  <font color="#0000ff">(aab), (aab)</font> . </li><li>  <font color="#0000ff">(aa), (aab), (aab)</font> . </li></ol><br>  Wir führen Schritt für Schritt alle möglichen Anweisungen für jede der Gruppierungsoptionen aus. <br><br>  Gruppierung <font color="#0000ff">(aa)</font> , <font color="#0000ff">(aab)</font> .  Zeichenfolge <font color="#0000ff">((aa) (aab) (aab))</font> . <br><br>  Die erste Option: <br><br><ol><li>  Wählen Sie den Inhalt <font color="#0000ff">(( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> ab) (aab))</font> . </li><li>  Wir nehmen <font color="#0000ff">( <font color="#ff0000">a</font> (... a) (... ab) (aab)) heraus</font> . </li><li>  Kombiniere <font color="#0000ff">( <font color="#ff0000">a</font> (... a ... ab) (aab))</font> . </li><li>  Ergebnis Nr. 1 <font color="#0000ff">(a (aab) (aab))</font> . </li></ol><br>  Die zweite Option: <br><br><ol><li>  Wählen Sie den Inhalt <font color="#0000ff">(( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> b) (aab))</font> . </li><li>  Wir nehmen <font color="#0000ff">( <font color="#ff0000">aa</font> (...) (... b) (aab)) heraus</font> . </li><li>  Kombiniere <font color="#0000ff">( <font color="#ff0000">aa</font> (... b) (aab))</font> . </li><li>  Ergebnis Nr. 2 <font color="#0000ff">(a (b) (aab))</font> . </li></ol><br>  Gruppierung <font color="#0000ff">(aab)</font> , <font color="#0000ff">(aab)</font> .  Zeichenfolge <font color="#0000ff">((aa) (aab) (aab))</font> . <br><br>  Die erste Option: <br><br><ol><li>  Wählen Sie den Inhalt <font color="#0000ff">((aa) ( <font color="#ff0000">a</font> ab) ( <font color="#ff0000">a</font> ab))</font> . </li><li>  Wir nehmen <font color="#0000ff">((aa) <font color="#ff0000">a</font> (... ab) (... ab)) heraus</font> . </li><li>  Kombiniere <font color="#0000ff">((aa) <font color="#ff0000">a</font> (... ab ... ab))</font> . </li><li>  Ergebnis Nr. 3 <font color="#0000ff">(a (aa) (aabb))</font> . </li></ol><br>  Die zweite Option: <br><br><ol><li>  Wählen Sie den Inhalt <font color="#0000ff">((aa) ( <font color="#ff0000">aa</font> b) ( <font color="#ff0000">aa</font> b))</font> . </li><li>  Wir nehmen <font color="#0000ff">((aa) <font color="#ff0000">aa</font> (... b) (... b)) heraus</font> . </li><li>  Kombiniere <font color="#0000ff">((aa) <font color="#ff0000">aa</font> (... b ... b))</font> . </li><li>  Ergebnis Nr. 4 <font color="#0000ff">(aa (aa) (bb))</font> . </li></ol><br>  Die dritte Option: <br><br><ol><li>  Wählen Sie den Inhalt <font color="#0000ff">((aa) (a <font color="#ff0000">ab</font> ) (a <font color="#ff0000">ab</font> ))</font> . </li><li>  Wir nehmen <font color="#0000ff">((aa) <font color="#ff0000">ab</font> (... a) (... a)) heraus</font> . </li><li>  Kombiniere <font color="#0000ff">((aa) <font color="#ff0000">ab</font> (... a ... a))</font> . </li><li>  Ergebnis Nr. 5 <font color="#0000ff">(ab (aa) (aa))</font> . </li></ol><br>  Vierte Option: <br><br><ol><li>  Wählen Sie den Inhalt <font color="#0000ff">((aa) (aa <font color="#ff0000">b</font> ) (aa <font color="#ff0000">b</font> ))</font> . </li><li>  Wir nehmen <font color="#0000ff">((aa) <font color="#ff0000">b</font> (... aa) (... aa)) heraus</font> . </li><li>  Kombiniere <font color="#0000ff">((aa) <font color="#ff0000">b</font> (... aa ... aa))</font> . </li><li>  Ergebnis Nr. 6 <font color="#0000ff">(b (aa) (aaaa))</font> . </li></ol><br>  Fünfte Option: <br><br><ol><li>  Wählen Sie den Inhalt <font color="#0000ff">((aa) ( <font color="#ff0000">aab</font> ) ( <font color="#ff0000">aab</font> ))</font> . </li><li>  Wir nehmen <font color="#0000ff">((aa) <font color="#ff0000">aab</font> (...) (...)) heraus</font> . </li><li>  Kombiniere <font color="#0000ff">((aa) <font color="#ff0000">aab</font> (...))</font> . </li><li>  Ergebnis Nr. 7 <font color="#0000ff">(aab (aa))</font> . </li></ol><br>  Gruppierung <font color="#0000ff">(aa)</font> , <font color="#0000ff">(aab)</font> , <font color="#0000ff">(aab)</font> .  Zeichenfolge <font color="#0000ff">((aa) (aab) (aab))</font> . <br><br>  Die erste Option: <br><br><ol><li>  Wählen Sie den Inhalt <font color="#0000ff">(( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> ab) ( <font color="#ff0000">a</font> ab))</font> . </li><li>  Wir nehmen <font color="#0000ff">( <font color="#ff0000">a</font> (... a) (... ab) (... ab)) heraus</font> . </li><li>  Kombiniere <font color="#0000ff">( <font color="#ff0000">a</font> (... a ... ab ... ab))</font> . </li><li>  Ergebnis Nr. 8 <font color="#0000ff">(a (aaabb))</font> . </li></ol><br>  Die zweite Option: <br><br><ol><li>  Wählen Sie den Inhalt <font color="#0000ff">(( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> b) ( <font color="#ff0000">aa</font> b))</font> . </li><li>  Wir nehmen heraus <font color="#0000ff">( <font color="#ff0000">aa</font> (...) (... b) (... b))</font> . </li><li>  Kombiniere <font color="#0000ff">( <font color="#ff0000">aa</font> (... b ... b))</font> . </li><li>  Ergebnis Nr. 9 <font color="#0000ff">(aa (bb))</font> . </li></ol><br>  <b>Die Aktion des Abstraktionsoperators</b> .  Wie Sie dem Beispiel <font color="#0000ff">entnehmen können,</font> gibt es für die ursprüngliche Zeile <font color="#0000ff">((aa) (aab) (aab)</font> neun verschiedene Optionen, um etwas aus den Klammern zu setzen, und neun resultierende Zeilen entsprechen diesen Optionen.  So verhält sich der Abstraktionsoperator - iteriert über alle möglichen Optionen zum Löschen von Klammern und erstellt die entsprechende Menge der resultierenden Zeilen.  Darüber hinaus sucht der Abstraktionsoperator nach Optionen, um nicht nur in der Quellzeile, sondern auch in allen resultierenden Ergebniszeilen zu erkennen.  Mit anderen Worten, der Abstraktionsoperator wird rekursiv auf seine Ergebnisse usw. angewendet, bis alle möglichen Optionen ausgeschöpft sind.  Aus offensichtlichen Gründen ist für jede letzte Zeile auch die Anzahl der möglichen Entfernungsoptionen begrenzt. <br><br>  Kehren wir zum vorherigen Beispiel zurück.  Im betrachteten Beispiel habe ich nicht alle möglichen Optionen aufgeschrieben, sondern nur neun Teile der ersten Ebene.  Um die volle Wirkung des Abstraktionsoperators zu veranschaulichen, müssen für jedes der neun vorherigen Ergebnisse alle Optionen zum Löschen von Klammern erstellt werden.  Wir werden alle Optionen aufschreiben, aber auf eine präzisere Art und Weise. <br><br>  Ergebnis Nr. 1 <font color="#0000ff">(a (aab) (aab))</font> : <br><br>  1.1.  <font color="#0000ff">(a ( <font color="#ff0000">a</font> ab) ( <font color="#ff0000">a</font> ab)) =&gt; (a <font color="#ff0000">a</font> (aabb))</font> . <br>  1.2.  <font color="#0000ff">(a ( <font color="#ff0000">aa</font> b) ( <font color="#ff0000">aa</font> b)) =&gt; (a <font color="#ff0000">aa</font> (bb))</font> . <br>  1.3.  <font color="#0000ff">(a (a <font color="#ff0000">ab</font> ) (a <font color="#ff0000">ab</font> )) =&gt; (a <font color="#ff0000">ab</font> (aa))</font> .  * Nr. 7 <br>  1.4.  <font color="#0000ff">(a ( <font color="#ff0000">aab</font> ) ( <font color="#ff0000">aab</font> )) =&gt; ( <font color="#ff0000">aab</font> )</font> . <br>  1.5.  <font color="#0000ff">(a (aa <font color="#ff0000">b</font> ) (aa <font color="#ff0000">b</font> )) =&gt; (a <font color="#ff0000">b</font> (aaaa))</font> . <br>  Ergebnis Nr. 2 <font color="#0000ff">(a (b) (aab))</font> : <br>  2.1.  <font color="#0000ff">(a ( <font color="#ff0000">b</font> ) (aa <font color="#ff0000">b</font> )) =&gt; (a <font color="#ff0000">b</font> (aa))</font> . <br>  Ergebnis Nr. 3 <font color="#0000ff">(a (aa) (aabb))</font> : <br>  3.1.  <font color="#0000ff">(a ( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> abb)) =&gt; (a <font color="#ff0000">a</font> (aabb))</font> .  * Nr. 1.1 <br>  3.2.  <font color="#0000ff">(a ( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> bb)) =&gt; (a <font color="#ff0000">aa</font> (bb))</font> .  * Nr. 1.2 <br>  Ergebnis Nr. 4 <font color="#0000ff">(aa (aa) (bb))</font> . <br>  Ergebnis Nr. 5 <font color="#0000ff">(ab (aa) (aa))</font> : <br>  5.1.  <font color="#0000ff">(ab ( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> a)) =&gt; ( <font color="#ff0000">a</font> ab (aa))</font> .  * Nr. 7, * Nr. 1.3 <br>  5.2.  <font color="#0000ff">(ab ( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> )) =&gt; ( <font color="#ff0000">aa</font> ab)</font> .  * Nr. 1.4 <br>  Ergebnis Nr. 6 <font color="#0000ff">(b (aa) (aaaa))</font> : <br>  6.1.  <font color="#0000ff">(b ( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> aaa)) =&gt; ( <font color="#ff0000">a</font> b (aaaa))</font> .  * Nr. 1.5 <br>  6.2.  <font color="#0000ff">(b ( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> aa)) =&gt; ( <font color="#ff0000">aa</font> b (aa))</font> .  * Nr. 7, * Nr. 1.3, * Nr. 5.1 <br>  Ergebnis Nr. 7 <font color="#0000ff">(aab (aa))</font> . <br>  Ergebnis Nr. 8 <font color="#0000ff">(a (aaabb))</font> . <br>  Ergebnis Nr. 9 <font color="#0000ff">(aa (bb))</font> . <br><br>  Ein Sternchen kennzeichnet Optionen, die wiederholt werden.  Das Ergebnis der Abstraktion enthält nur eindeutige Variationen.  Im analysierten Beispiel gibt es vierzehn eindeutige Ergebniszeilen.  Gesamt: <br><br>  <font color="#0000ff"><b>Abstraktion</b> [((aa) (aab) (aab))] =</font> <font color="#0000ff"><br></font>  <font color="#0000ff">{</font> <font color="#0000ff"><br></font>  <font color="#0000ff">(a (aab) (aab)), (aa (aabb)), (aaa (bb)), (aaab), (a (b) (aab)), (ab (aa)), (a (aa) (aabb)), (aa (aa) (bb)), (ab (aa) (aa)), (b (aa) (aaaa)), (ab (aaaa)), (aab (aa)), ( a (aaabb)), (aa (bb))</font> <font color="#0000ff"><br></font>  <font color="#0000ff">}}</font> <br><br>  Betrachten Sie zur Verdeutlichung noch einige Beispiele. <br><br>  Zeichenfolge <font color="#0000ff">((a (b)) (a (b)))</font> .  Optionen in Klammern.  Erste Iteration: <br><br>  <font color="#0000ff">(( <font color="#ff0000">a</font> (b)) ( <font color="#ff0000">a</font> (b))) =&gt; ( <font color="#ff0000">a</font> ((b) (b)))</font> , Ergebnis Nr. 1. <br>  <font color="#0000ff">((a <font color="#ff0000">(b)</font> ) (a <font color="#ff0000">(b)</font> )) =&gt; ( <font color="#ff0000">(b)</font> (aa))</font> , Ergebnis Nr. 2. <br>  <font color="#0000ff">(( <font color="#ff0000">a (b)</font> ) ( <font color="#ff0000">a (b)</font> )) =&gt; ( <font color="#ff0000">a (b)</font> )</font> , Ergebnis Nr. 3. <br>  Im ersten Ergebnis kann eine weitere Entscheidung getroffen werden.  Zweite Iteration: <br>  <font color="#0000ff">(a (( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> ))) =&gt; (a ( <font color="#ff0000">b</font> ))</font> , Ergebnis Nr. 1.2 stimmt mit Ergebnis Nr. 3 überein. <br><br>  Gesamt: <font color="#0000ff"><b>Abstraktion</b> [((a (b)) (a (b)))] = {(a ((b) (b))), ((b) (aa)), (a (b))}</font> <br><br><div class="spoiler">  <b class="spoiler_title">Tolles Beispiel:</b> <div class="spoiler_text">  <font color="#0000ff"><b>Abstraktion</b> [ <b>Abzug</b> [(a (b))]] = <b>Abstraktion</b> [((aa (bb) (bb)) (aa (bb) (bb))] =&gt;</font> <br>  1. <font color="#0000ff">((aa (bb) (bb)) (aa (bb) (bb))) =&gt; ((aab (b)) (aa (bb) (bb)))</font> . <br>  1.1.  <font color="#0000ff">(( <font color="#ff0000">a</font> ab (b)) ( <font color="#ff0000">a</font> a (bb) (bb))) =&gt; ( <font color="#ff0000">a</font> (aab (b) (bb) (bb)))</font> . <br>  1.1.1.  <font color="#0000ff">(a (aab ( <font color="#ff0000">b</font> ) (bb) (bb))) =&gt; (a (aabb (b) (bb)))</font> . <br>  1.1.1.1.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (b)))</font> . <br>  1.1.2.  <font color="#0000ff">(a (aab ( <font color="#ff0000">b</font> ) (bb) (bb))) =&gt; (a (aabb (bb)))</font> . <br>  1.1.3.  <font color="#0000ff">(a (aab (b) (bb) (bb))) =&gt; (a (aabb (b) (bb)))</font> . <br>  1.1.3.1.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (b)))</font> . <br>  1.1.4.  <font color="#0000ff">(a (aab (b) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aab <font color="#ff0000">bb</font> (b)))</font> . <br>  1.2.  <font color="#0000ff">(( <font color="#ff0000">aa</font> b (b)) ( <font color="#ff0000">aa</font> (bb) (bb))) =&gt; ( <font color="#ff0000">aa</font> (b (b) (bb) (bb)))</font> . <br>  1.2.1.  <font color="#0000ff">(aa (b ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b) (bb))) =&gt; (aa (b <font color="#ff0000">b</font> (b) (bb)))</font> . <br>  1.2.1.1.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> ) (bb))) =&gt; (aa (bbb (b)))</font> . <br>  1.2.2.  <font color="#0000ff">(aa (b ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (b <font color="#ff0000">b</font> (bb)))</font> . <br>  1.2.3.  <font color="#0000ff">(aa (b (b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (b <font color="#ff0000">b</font> (b) (bb)))</font> . <br>  1.2.3.1.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> ) (bb))) =&gt; (aa (bbb (b)))</font> . <br>  1.2.4.  <font color="#0000ff">(aa (b (b) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa ( <font color="#ff0000">bbb</font> (b)))</font> . <br>  1.3.  <font color="#0000ff">((aab (b)) (aa (bb) (bb))) =&gt; ((aab (b)) (aab (bb)))</font> . <br>  1.3.1.  <font color="#0000ff">(( <font color="#ff0000">a</font> ab (b)) ( <font color="#ff0000">a</font> ab (bb))) =&gt; ( <font color="#ff0000">a</font> (aabb (b) (bb)))</font> . <br>  1.3.1.1.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (b)))</font> . <br>  1.3.2.  <font color="#0000ff">(( <font color="#ff0000">aa</font> b (b)) ( <font color="#ff0000">aa</font> b (bb))) =&gt; ( <font color="#ff0000">aa</font> (bb (b) (bb)))</font> . <br>  1.3.2.1.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> ) (bb))) =&gt; (aa (bbb (b)))</font> . <br>  1.3.3.  <font color="#0000ff">(( <font color="#ff0000">aab</font> (b)) ( <font color="#ff0000">aab</font> (bb))) =&gt; ( <font color="#ff0000">aab</font> ((b) (bb)))</font> . <br>  1.3.3.1.  <font color="#0000ff">(aab (( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (aab ( <font color="#ff0000">b</font> (b)))</font> . <br>  1.3.4.  <font color="#0000ff">((a <font color="#ff0000">ab</font> (b)) (a <font color="#ff0000">ab</font> (bb))) =&gt; ( <font color="#ff0000">ab</font> (aa (b) (bb)))</font> . <br>  1.3.4.1.  <font color="#0000ff">(ab (aa ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (ab (aa <font color="#ff0000">b</font> (b)))</font> . <br>  1.3.5.  <font color="#0000ff">((aa <font color="#ff0000">b</font> (b)) (aa <font color="#ff0000">b</font> (bb))) =&gt; ( <font color="#ff0000">b</font> (aaaa (b) (bb)))</font> . <br>  1.3.5.1.  <font color="#0000ff">(b (aaaa ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (b (aaaa <font color="#ff0000">b</font> (b)))</font> . <br>  1.4.  <font color="#0000ff">((aab (b)) (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; ((aab (b)) (aa <font color="#ff0000">bb</font> ))</font> . <br>  1.4.1.  <font color="#0000ff">(( <font color="#ff0000">a</font> ab (b)) ( <font color="#ff0000">a</font> abb)) =&gt; ( <font color="#ff0000">a</font> (aabbb (b)))</font> . <br>  1.4.2.  <font color="#0000ff">(( <font color="#ff0000">aa</font> b (b)) ( <font color="#ff0000">aa</font> bb)) =&gt; ( <font color="#ff0000">aa</font> (bbb (b)))</font> . <br>  1.4.3.  <font color="#0000ff">(( <font color="#ff0000">aab</font> (b)) ( <font color="#ff0000">aab</font> b)) =&gt; ( <font color="#ff0000">aab</font> (b (b)))</font> . <br>  1.4.4.  <font color="#0000ff">((a <font color="#ff0000">ab</font> (b)) (a <font color="#ff0000">ab</font> b)) =&gt; ( <font color="#ff0000">ab</font> (aab (b)))</font> . <br>  1.4.5.  <font color="#0000ff">((aa <font color="#ff0000">b</font> (b)) (aa <font color="#ff0000">b</font> b)) =&gt; ( <font color="#ff0000">b</font> (aaaab (b)))</font> . <br>  2. <font color="#0000ff">((aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> )) (aa (bb) (bb)) =&gt; ((aa <font color="#ff0000">bb</font> ) (aa (bb) (bb)))</font> . <br>  2.1.  <font color="#0000ff">((aabb) (aa (bb) (bb))) =&gt; ((aabb) (aab (bb)))</font> . <br>  2.1.1.  <font color="#0000ff">(( <font color="#ff0000">a</font> abb) ( <font color="#ff0000">a</font> ab (bb))) =&gt; ( <font color="#ff0000">a</font> (aabbb (bb)))</font> . <br>  2.1.2.  <font color="#0000ff">(( <font color="#ff0000">aa</font> bb) ( <font color="#ff0000">aa</font> b (bb))) =&gt; ( <font color="#ff0000">aa</font> (bbb (bb)))</font> . <br>  2.1.3.  <font color="#0000ff">(( <font color="#ff0000">aab</font> b) ( <font color="#ff0000">aab</font> (bb))) =&gt; ( <font color="#ff0000">aab</font> (b (bb)))</font> . <br>  2.1.4.  <font color="#0000ff">((a <font color="#ff0000">ab</font> b) (a <font color="#ff0000">ab</font> (bb))) =&gt; ( <font color="#ff0000">ab</font> (aab (bb)))</font> . <br>  2.1.5.  <font color="#0000ff">((aa <font color="#ff0000">b</font> b) (aa <font color="#ff0000">b</font> (bb))) =&gt; ( <font color="#ff0000">b</font> (aaaab (bb)))</font> . <br>  2.2.  <font color="#0000ff">((aabb) (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; ((aabb) (aa <font color="#ff0000">bb</font> ))</font> . <br>  2.2.1.  <font color="#0000ff">(( <font color="#ff0000">a</font> abb) ( <font color="#ff0000">a</font> abb)) =&gt; ( <font color="#ff0000">a</font> (aabbbb))</font> . <br>  2.2.2.  <font color="#0000ff">(( <font color="#ff0000">aa</font> bb) ( <font color="#ff0000">aa</font> bb)) =&gt; ( <font color="#ff0000">aa</font> (bbbb))</font> . <br>  2.2.3.  <font color="#0000ff">(( <font color="#ff0000">aab</font> b) ( <font color="#ff0000">aab</font> b)) =&gt; ( <font color="#ff0000">aab</font> (bb))</font> . <br>  2.2.4.  <font color="#0000ff">((a <font color="#ff0000">abb</font> ) (a <font color="#ff0000">abb</font> )) =&gt; ( <font color="#ff0000">abb</font> (aa))</font> . <br>  2.2.5.  <font color="#0000ff">(( <font color="#ff0000">aabb</font> ) ( <font color="#ff0000">aabb</font> )) =&gt; ( <font color="#ff0000">aabb</font> )</font> . <br>  2.2.6.  <font color="#0000ff">((a <font color="#ff0000">ab</font> b) (a <font color="#ff0000">ab</font> b)) =&gt; ( <font color="#ff0000">ab</font> (aabb))</font> . <br>  2.2.7.  <font color="#0000ff">((aa <font color="#ff0000">b</font> b) (aa <font color="#ff0000">b</font> b)) =&gt; ( <font color="#ff0000">b</font> (aaaabb))</font> . <br>  2.2.8.  <font color="#0000ff">((aa <font color="#ff0000">bb</font> ) (aa <font color="#ff0000">bb</font> )) =&gt; ( <font color="#ff0000">bb</font> (aaaa))</font> . <br>  2.3.  <font color="#0000ff">(( <font color="#ff0000">a</font> abb) ( <font color="#ff0000">a</font> a (bb) (bb))) =&gt; ( <font color="#ff0000">a</font> (aabb (bb) (bb)))</font> . <br>  2.3.1.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (bb)))</font> . <br>  2.3.2.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aabb <font color="#ff0000">bb</font> ))</font> . <br>  2.4.  <font color="#0000ff">(( <font color="#ff0000">aa</font> bb) ( <font color="#ff0000">aa</font> (bb) (bb))) =&gt; ( <font color="#ff0000">aa</font> (bb (bb) (bb)))</font> . <br>  2.4.1.  <font color="#0000ff">(aa (bb (bb) (bb))) =&gt; (aa (bbb (bb)))</font> . <br>  2.4.2.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (bb <font color="#ff0000">bb</font> ))</font> . <br>  3. <font color="#0000ff">(( <font color="#ff0000">a</font> a (bb) (bb)) ( <font color="#ff0000">a</font> a (bb) (bb))) =&gt; ( <font color="#ff0000">a</font> (aa (bb) (bb) (bb) (bb)))</font> . <br>  3.1.  <font color="#0000ff">(a (aa (bb) (bb) (bb) (bb)) =&gt; (a (aab (bb) (bb) (bb)))</font> . <br>  3.1.1.  <font color="#0000ff">(a (aab (bb) (bb) (bb))) =&gt; (a (aabb (bb) (bb)))</font> . <br>  3.1.1.1.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (bb)))</font> . <br>  3.1.1.2.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aabb <font color="#ff0000">bb</font> ))</font> . <br>  3.1.2.  <font color="#0000ff">(a (aab (bb) (bb) (bb))) =&gt; (a (aabb (bbb)))</font> . <br>  3.1.3.  <font color="#0000ff">(a (aab ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb))) =&gt; (a (aab <font color="#ff0000">bb</font> (bb)))</font> . <br>  3.1.4.  <font color="#0000ff">(a (aab ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aab <font color="#ff0000">bb</font> ))</font> . <br>  3.2.  <font color="#0000ff">(a (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb) (bb)) =&gt; (a (aa <font color="#ff0000">bb</font> (bb) (bb)))</font> . <br>  3.2.1.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (bb)))</font> . <br>  3.2.2.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aabb <font color="#ff0000">bb</font> ))</font> . <br>  3.3.  <font color="#0000ff">(a (aa (bb) (bb) (bb) (bb)) =&gt; (a (aab (bbb) (bb)))</font> . <br>  3.3.1.  <font color="#0000ff">(a (aab (bbb) (bb))) =&gt; (a (aabb (bbb)))</font> . <br>  3.3.2.  <font color="#0000ff">(a (aab ( <font color="#ff0000">bb</font> b) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aab <font color="#ff0000">bb</font> (b)))</font> . <br>  3.4.  <font color="#0000ff">(a (aa (bb) (bb) (bb) (bb)) &gt;&gt; ( <font color="#ff0000">a</font> (aab (bbbb)))</font> . <br>  3.5.  <font color="#0000ff">(a (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb)) =&gt; (a (aa <font color="#ff0000">bb</font> (bb)))</font> . <br>  3.6.  <font color="#0000ff">(a (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aa <font color="#ff0000">bb</font> ))</font> . <br>  4. <font color="#0000ff">(( <font color="#ff0000">aa</font> (bb) (bb)) ( <font color="#ff0000">aa</font> (bb) (bb))) &gt;&gt; ( <font color="#ff0000">aa</font> ((bb) (bb) (bb) (bb)))</font> . <br>  4.1.  <font color="#0000ff">(aa ((bb) (bb) (bb) (bb)) =&gt; (aa ( <font color="#ff0000">b</font> (bb) (bb) (bb)))</font> . <br>  4.1.1.  <font color="#0000ff">(aa (b (bb) (bb) (bb))) =&gt; (aa (bb (bb) (bb)))</font> . <br>  4.1.1.1.  <font color="#0000ff">(aa (bb (bb) (bb))) =&gt; (aa (bbb (bb)))</font> . <br>  4.1.1.2.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (bb <font color="#ff0000">bb</font> ))</font> . <br>  4.1.2.  <font color="#0000ff">(aa (b (bb) (bb) (bb)) =&gt; (aa ( <font color="#ff0000">bb</font> (bbb)))</font> . <br>  4.1.3.  <font color="#0000ff">(aa (b ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb))) =&gt; (aa ( <font color="#ff0000">bbb</font> (bb)))</font> . <br>  4.1.4.  <font color="#0000ff">(aa (b ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa ( <font color="#ff0000">bbb</font> ))</font> . <br>  4.2.  <font color="#0000ff">(aa (( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb) (bb))) =&gt; (aa ( <font color="#ff0000">bb</font> (bb) (bb)))</font> . <br>  4.2.1.  <font color="#0000ff">(aa (bb (bb) (bb))) =&gt; (aa (bbb (bb)))</font> . <br>  4.2.2.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (bb <font color="#ff0000">bb</font> ))</font> . <br>  4.3.  <font color="#0000ff">(aa ((bb) (bb) (bb) (bb)) =&gt; (aa ( <font color="#ff0000">b</font> (bbb) (bb)))</font> . <br>  4.3.1.  <font color="#0000ff">(aa (b (bbb) (bb))) =&gt; (aa (bb (bbb)))</font> . <br>  4.3.2.  <font color="#0000ff">(aa (b ( <font color="#ff0000">bb</font> b) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (b <font color="#ff0000">bb</font> (b)))</font> . <br>  4.4.  <font color="#0000ff">(aa ((bb) (bb) (bb) (bb)) &gt;&gt; (aa ( <font color="#ff0000">b</font> (bbbb)))</font> . <br>  4.5.  <font color="#0000ff">(aa (( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb)) =&gt; (aa ( <font color="#ff0000">bb</font> (bb)))</font> . <br>  4.6.  <font color="#0000ff">(aa (( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> )) =&gt; (aa ( <font color="#ff0000">bb</font> ))</font> . <br>  5. <font color="#0000ff">((aa <font color="#ff0000">(bb)</font> (bb)) (aa <font color="#ff0000">(bb)</font> (bb)) =&gt; ( <font color="#ff0000">(bb)</font> (aaaa (bb) (bb)))</font> . <br>  5.1.  <font color="#0000ff">((bb) (aaaa (bb) (bb))) =&gt; ((bb) (aaaab (bb)))</font> . <br>  5.1.1.  <font color="#0000ff">(( <font color="#ff0000">b</font> b) (aaaa <font color="#ff0000">b</font> (bb))) =&gt; ( <font color="#ff0000">b</font> (aaaab (bb)))</font> . <br>  5.2.  <font color="#0000ff">((bb) (aaaa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; ((bb) (aaaa <font color="#ff0000">bb</font> ))</font> . <br>  5.2.1.  <font color="#0000ff">(( <font color="#ff0000">b</font> b) (aaaa <font color="#ff0000">b</font> b)) =&gt; ( <font color="#ff0000">b</font> (aaaabb))</font> . <br>  5.2.2.  <font color="#0000ff">(( <font color="#ff0000">bb</font> ) (aaaa <font color="#ff0000">bb</font> )) =&gt; ( <font color="#ff0000">bb</font> (aaaa))</font> . <br>  6. <font color="#0000ff">((aa <font color="#ff0000">(bb) (bb)</font> ) (aa <font color="#ff0000">(bb) (bb)</font> )) =&gt; ( <font color="#ff0000">(bb) (bb)</font> (aaaa))</font> . <br>  6.1.  <font color="#0000ff">(( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (aaaa)) =&gt; ( <font color="#ff0000">b</font> (bb) (aaaa))</font> . <br>  6.2.  <font color="#0000ff">(( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (aaaa)) =&gt; ( <font color="#ff0000">bb</font> (aaaa))</font> . <br>  7. <font color="#0000ff">((a <font color="#ff0000">a (bb)</font> (bb)) (a <font color="#ff0000">a (bb)</font> (bb))) =&gt; ( <font color="#ff0000">a (bb)</font> (aa (bb) (bb)))</font> . <br>  7.1.  <font color="#0000ff">(a (bb) (aa (bb) (bb))) =&gt; (a (bb) (aab (bb)))</font> . <br>  7.1.1.  <font color="#0000ff">(a ( <font color="#ff0000">b</font> b) (aa <font color="#ff0000">b</font> (bb))) =&gt; (a <font color="#ff0000">b</font> (aab (bb)))</font> . <br>  7.2.  <font color="#0000ff">(a (bb) (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (bb) (aa <font color="#ff0000">bb</font> ))</font> . <br>  7.2.1.  <font color="#0000ff">(a ( <font color="#ff0000">b</font> b) (aa <font color="#ff0000">b</font> b)) =&gt; (a <font color="#ff0000">b</font> (aabb))</font> . <br>  7.2.2.  <font color="#0000ff">(a ( <font color="#ff0000">bb</font> ) (aa <font color="#ff0000">bb</font> )) =&gt; (a <font color="#ff0000">bb</font> (aa))</font> . <br>  8. <font color="#0000ff">(( <font color="#ff0000">aa (bb)</font> (bb)) ( <font color="#ff0000">aa (bb)</font> (bb)) =&gt; ( <font color="#ff0000">aa (bb)</font> ((bb) (bb)))</font> . <br>  8.1.  <font color="#0000ff">(aa (bb) ((bb) (bb))) =&gt; (aa (bb) ( <font color="#ff0000">b</font> (bb)))</font> . <br>  8.1.1.  <font color="#0000ff">(aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> (bb))) =&gt; (aa <font color="#ff0000">b</font> (b (bb)))</font> . <br>  8.2.  <font color="#0000ff">(aa (bb) (( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (bb) ( <font color="#ff0000">bb</font> ))</font> . <br>  8.2.1.  <font color="#0000ff">(aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b)) =&gt; (aa <font color="#ff0000">b</font> (bb))</font> . <br>  8.2.2.  <font color="#0000ff">(aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> )) =&gt; (aa <font color="#ff0000">bb</font> )</font> . <br>  9. <font color="#0000ff">((a <font color="#ff0000">a (bb) (bb)</font> ) (a <font color="#ff0000">a (bb) (bb)</font> )) =&gt; ( <font color="#ff0000">a (bb) (bb)</font> (aa))</font> . <br>  9.1.  <font color="#0000ff">(a (aa) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b)) =&gt; (a <font color="#ff0000">b</font> (aa) (bb))</font> . <br>  9.2.  <font color="#0000ff">(a (aa) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> )) =&gt; (a <font color="#ff0000">bb</font> (aa))</font> . <br>  10. <font color="#0000ff">(( <font color="#ff0000">aa (bb) (bb)</font> ) ( <font color="#ff0000">aa (bb) (bb)</font> )) =&gt; ( <font color="#ff0000">a (bb) (bb)</font> )</font> . <br>  10.1.  <font color="#0000ff">(a ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b)) =&gt; (a <font color="#ff0000">b</font> (bb))</font> . <br>  10.2.  <font color="#0000ff">(a ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> )) =&gt; (a <font color="#ff0000">bb</font> )</font> . <br><br>  Aus der obigen Liste der resultierenden Zeilen (rechts neben dem Pfeil) müssen Sie alle eindeutigen Zeilen auswählen. Diese Gruppe eindeutiger Zeilen ist das Ergebnis der <font color="#0000ff"><b>Abstraktion</b> [((aa (bb) (bb)) (aa (bb) (bb))]</font> .  Ich werde keine eindeutigen Zeilen schreiben, da dies der Erklärung nichts hinzufügt.  Wenn ich die Optimierung und praktische Anwendung des Algorithmus betrachte, werde ich im Folgenden auf dieses Beispiel verweisen. </div></div><br><br>  <b>Kompositionsoperator</b> .  Definition  <font color="#0000ff">∀U ⊂ <b>S</b> , U ≠ ≠, <b>Zusammensetzung</b> [U] ≠ ≠, <b>Zusammensetzung</b> [U] ∈ <b>S.</b></font>  Es akzeptiert viele Eingabezeilen und gibt eine Zeile zurück.  Aktion.  Der Bediener bereitet den Inhalt für die nächste Iteration des Algorithmus vor.  Nach der Aktion des Abstraktionsoperators erscheinen viele Zeilen, und im Stadium der Komposition erfolgt die Auswahl und Verkettung von Zeilen für die nächste Iteration des Algorithmus.  Im Detail werde ich dieses Problem in den Abschnitten Optimierung und praktische Anwendung behandeln.  Im einfachsten Fall führt der Kompositionsoperator eine einfache Verkettung aller Abstraktionsergebnisse durch.  Also definieren wir es.  Beispiel: <font color="#0000ff"><b>Zusammensetzung</b> [ <b>Abstraktion</b> [((a (b)) (a (b))]] = <b>Zusammensetzung</b> [{(a ((b) (b))), ((b) (aa)), (a ( b))}] = ((a ((b) (b))) ((b) (aa)) (a (b)))</font> . <br><br><h2>  Algorithmus-Eigenschaften </h2><br>  Der Algorithmus erzeugt Strings.  Die Menge aller Linien, die als Ergebnis der iterativen Operation des Algorithmus gebildet werden, wird als "Algorithmusausgabe" oder einfach "Ausgabe" bezeichnet.  Definition der Folgerung.  <font color="#0000ff"><b>T</b> <sup>s</sup> ≝ {t <sub>n</sub> | t <sub>n + 1</sub> = <b>Zusammensetzung</b> [ <b>Abstraktion</b> [ <b>Abzug</b> [t <sub>n</sub> ]]];</font>  <font color="#0000ff">t <sub>0</sub> = s;</font>  <font color="#0000ff">t <sub>n</sub> , s ∈ <b>S</b> ;</font>  <font color="#0000ff">n ∈ <b>N</b> }.</font>  <font color="#0000ff"><b>T</b> <sup>s</sup></font> ist die Ausgabe für den Startwert <font color="#0000ff">s</font> .  In den Fällen, in denen <font color="#0000ff"><b>T</b></font> keinen Parameter hat, sprechen wir über die Schlussfolgerung eines beliebigen Samens.  Inferenz-Eigenschaft: <font color="#0000ff">∀s, e ∈ <b>S</b> , s ≠ ≠, e ≠ ≠, s ≠ e, <b>T</b> <sup>s</sup> ∩ <b>T</b> <sup>e</sup> = ∅</font> .  Dies bedeutet, dass jedes Ausgabeelement eindeutig dem Startwert entspricht.  Infolgedessen ist die Schlussfolgerung für jeden Samen eindeutig. <br><br>  <b>Eine sinnvolle Interpretation von Deduktion und Abstraktion</b> .  Die physikalische Bedeutung des Abzugsoperators ist wie folgt.  Aus der ursprünglichen Zeile erstellt der Abzugsoperator auf universelle Weise ein grundlegend neues konstruktives Objekt mit grundlegend neuen und komplexeren internen Eigenschaften.  In einer intuitiven Annäherung können wir sagen, dass der Abzug qualitativ neue Informationen hinzufügt.  Der Abstraktionsoperator analysiert seinerseits das neue Objekt in Teile und drückt somit Informationen, die in der Ableitungsphase hinzugefügt wurden, in einem konstruktiven Äquivalent aus.  Möglicherweise stellen Sie fest, dass durch das Löschen von Klammern Informationen verloren gehen.  Darüber hinaus ist das Löschen von Klammern für diese Syntax ein universeller Weg, um Informationen sinnvoll zu verlieren, wenn keine A-priori-Daten über den Wert von Zeichenfolgen vorliegen.  Das heißt, aus Sicht des Algorithmus sind alle möglichen Optionen für den Informationsverlust, die im Stadium der Abstraktion berechnet werden, tatsächlich der Wert der Linien.  Somit erstellt der Algorithmus bei jedem Schritt eine neue, eindeutige syntaktische Heuristik.  Und jede nachfolgende Heuristik ist grundlegend komplexer und umfangreicher als die vorherige.  Bei jeder Iteration des Algorithmus erscheint neues Wissen. <br><br><h2>  Praktische Anwendung </h2><br>  Der Algorithmus ist ein "Ding für sich".  Er denkt, aber das ist das Denken eines „Außerirdischen“.  Um praktische Vorteile aus dem Denken von Außerirdischen zu ziehen, müssen Sie eine gemeinsame Sprache mit ihm finden.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einerseits ist es erforderlich, einen Außerirdischen auszubilden und andererseits zu lernen, ihn zu verstehen, um letztendlich eine sinnvolle Kommunikation herzustellen. </font><font style="vertical-align: inherit;">Im Allgemeinen ähnelt das Paradigma der Interaktion mit dem Algorithmus den bekannten Prinzipien der Interaktion mit der „Black Box“. </font><font style="vertical-align: inherit;">Zur Vereinfachung werde ich den Denkalgorithmus den Alien Kohl nennen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie den Idealfall. </font><font style="vertical-align: inherit;">Angenommen, wir verfügen über unbegrenzte Rechenleistung und können es uns leisten, eine beliebige Anzahl von Iterationen von Kolyas Denken zu berechnen, ohne uns um Optimierungsprobleme kümmern zu müssen. </font><font style="vertical-align: inherit;">In diesem Fall sind die folgenden Zutaten erforderlich, um mit Kolya zu interagieren:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein digitales Modell einer interaktiven Umgebung, deren Bedeutung von Aktivität bekannt ist. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein digitales Modell eines Werkzeugs, das sich auf die Umwelt auswirken kann. </font></font></li><li>  ,        <font color="#0000ff"><b>S</b></font> . </li><li>  ,   - ,          <font color="#0000ff"><b>S</b></font>       . </li></ol><br>           ,       .  . <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextThought</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S prevThought, S ExternalSignal, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> exposure = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ S t = composition[prevThought, ExternalSignal]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; exposure; i++) t = composition[abstraction[deduction[t]]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; } EnvironmentModel e; S s = encode(e.GetState()); S o = ∅; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>) { S o = NextThought(o, s); e.ImpactTool.perform(decode(o)); s = encode(e.GetState()); }</code> </pre> <br>  <b>Rückkopplungsschaltung</b> .  Am Anfang hat Kolya keine Gedanken.  Kolyas erster Gedanke ist der verschlüsselte Ausgangszustand des Mediums.  Bei jeder Iteration wird ein externes Signal in Kolyas Gedanken eingegossen.  Danach denkt Kolya während der Belichtungszeit.  Die Ergebnisse des Denkens werden dekodiert und an das Tool gesendet.  Die Aktion des Tools ändert wiederum irgendwie den Zustand der Umgebung.  Und alles wiederholt sich noch einmal.  Mit der Zeit wird sich Kolyas Denken an die Umwelt anpassen und er wird Anzeichen von hoch organisiertem, subjektiv motiviertem Verhalten zeigen.  Die Motivation von Kolya wird jedoch unbekannt bleiben.  Um seine Motivation zu verstehen, müssen in der nächsten Ausbildungsphase Experimente durchgeführt werden, dh die Umgebung gezielt verändert und Kolyas Reaktionen auf Veränderungen untersucht werden.  Wenn es möglich ist, das gewünschte äußere Verhalten von Kolya anhand einer objektiven Funktion zu beschreiben, kann der Lernprozess beispielsweise mithilfe eines genetischen Algorithmus automatisiert werden. <br><br>  <b>Dekodierungsproblem</b> .  Es ist notwendig, Kolyas Gedanken zu entschlüsseln, um ein Signal für das Instrument zu synthetisieren.  Die Schwierigkeit besteht darin, dass jeder Gedanke, wie ich im vorherigen Abschnitt festgestellt habe, ein grundlegend neues Design ist.  Das heißt, ein hypothetischer Forscher kann den Inhalt von Kolyas Gedanken niemals vollständig verstehen.  Ein Teil des Inhalts, der durch Kolyas Denken erzeugt wird, egal für wie viel es studiert wird, wird für immer etwas völlig Dunkles bleiben.  Nur einige der am besten organisierten Denkfragmente können sinnvoll erkannt werden, und dies ist eine grundlegende und unüberwindbare Einschränkung in der Kommunikation mit Kolya.  In der Praxis ist diese Einschränkung jedoch nicht grundlegend.  Da man erstens die sinnvolle Seite von Kolyas Gedanken unendlich spezifizieren kann und zweitens es nicht notwendig ist, Kolya vollständig zu verstehen.  Es reicht aus, eine gemeinsame Sprache zu entwickeln, in der Sie praktische Fragen erläutern können.  Aus technischer Sicht ist die Situation wie folgt.  Das eingehende Signal, das den Zustand des Mediums beschreibt, ist in einer Sprache codiert.  Wörter und Sprachaussagen sind Zeichenfolgen von <font color="#0000ff"><b>S.</b></font>  Die Sprache hat ihren eigenen Wortschatz, ihre eigene Syntax und Semantik.  Der Inhalt jeder Iteration des Denkens nach grammatikalischen Kriterien wird in mehrere Kategorien unterteilt: <br><br>  1. Fragmente mit unbekanntem Wortschatz. <br>  2. Unbekannte Syntax. <br>  3. Unbekannte Semantik. <br>  4. Grammatisch und semantisch korrekte Fragmente. <br><br>  Der Inhalt all dieser Kategorien ist je nach Art des Auftretens beliebig.  Das heißt, selbst bei grammatikalisch korrekten Fragmenten - dies ist ein Unfall und es ist nicht bekannt, welche Bedeutung Kolya in sie legt, da seine innere Bedeutung nur für sich selbst zugänglich ist.  A priori gibt es keine Kriterien, um Kolyas Gedanken und die entsprechenden Handlungen des Instruments richtig zu verbinden.  Und in dieser Angelegenheit bleibt es, sich ausschließlich auf Kolya selbst zu verlassen.  Sein Verhalten ist willkürlich und nur er kann seine Motivation verstehen, wenn der Organisationsgrad seines Denkens zunimmt.  In diesem Fall ist jedes rationale Schema zur Beantwortung von Kolyas Gedanken akzeptabel und produktiv. Die einzige Frage ist die relative Wirksamkeit der verschiedenen Schemata.  Die grundlegende Option besteht darin, auf alle grammatikalisch korrekten Fragmente zu antworten, auch wenn sie inhaltlich absurd sind.  Im Allgemeinen muss alles, was in die ursprüngliche Codierung konvertiert werden kann, transformiert und umgesetzt werden.  Und so weiter, bis Kohl zu sinnvollen Reaktionen „weise“ wurde.  Und natürlich wird das plastischste Modell der Umgebung mit einer großen Anzahl von Freiheitsgraden nützlich sein.  Das Medium wird in gewisser Weise zu Kolyas Körper. <br><br>  <b>Das Problem der begrenzten Rechenleistung</b> .  In Bezug auf den Rechenaufwand ist der Algorithmus schwer.  Es ist klar, dass mehrere Dutzend Iterationen die gesamte Rechenleistung des Planeten erschöpfen werden.  Wir können uns auf Quantengeräte und die Tatsache verlassen, dass es ein Quantenanalogon des Algorithmus gibt, aber bisher gab es nur einen Ausweg: Statt eines enorm komplexen Gedankens denken Sie viele kleine und einfache Gedanken parallel.  Hierfür gibt es mehrere technische Tricks: <br><br>  <b>1.</b> In der Phase der Komposition ist es nicht erforderlich, alle vielen Abstraktionen in das Ergebnis aufzunehmen.  Damit der Algorithmus seine grundlegenden Eigenschaften beibehält, reicht es aus, nur zwei unabhängige resultierende Zeilen aus der Menge auszuwählen.  Das Unabhängigkeitskriterium ist die Differenz der ersten Ziffern ungleich Null in der hierarchischen Nummerierung der Abstraktionsergebnisse.  Wir wenden uns dem großartigen Beispiel zu, das unter dem Spoiler höher liegt.  Alle Zeilen sind nach dem Prinzip von <font color="#0000ff">abcd</font> nummeriert <font color="#0000ff">.</font> Ein Zeilenpaar mit den Indizes <font color="#0000ff">a1.b1.c1.d1 ...</font> , <font color="#0000ff">a2.b2.c2.d2 ...</font> heißt unabhängig, wenn <font color="#0000ff">a1 ≠ a2</font> .  Dies bedeutet, dass es möglich ist, das gesamte Abstraktionsergebnis in unabhängige Paare aufzuteilen und für jedes Paar im nächsten Schritt einen eigenen Rechenzweig zu starten.  Darüber hinaus müssen nicht alle Ergebnisse der Abstraktion verwendet werden.  Im Mindestfall können Sie nur ein Zeilenpaar auswählen und den Rest verwerfen (unwiderruflich verlieren), und alle Denkprinzipien bleiben erhalten.  Aufgrund der Fähigkeit, Ergebnisse zu verlieren, ist es möglich, eine zusätzliche Auswahlphase zu organisieren, in der auf rationale Weise, beispielsweise entsprechend der statistischen Signifikanz, Inhalte für weitere Berechnungen ausgewählt werden. <br><br>  <b>2. Der</b> zweite Trick basiert auf der Annahme, dass der Inhalt umso weniger organisiert ist, je tiefer die Klammern in der Zeile platziert sind.  Dementsprechend ist der Inhalt „Popup“ als Ergebnis der Klammerung in Bezug auf die internen Bedeutungen von Kolya organisierter und abstrakter, was bedeutet, dass tiefe Verschachtelungsebenen entfernt werden können.  Somit nimmt der Rechenaufwand bei der nächsten Iteration exponentiell ab.  In einem intuitiven Sinne können Sie mit diesem Verfahren nur den abstraktesten Teil des Denkens approximieren. <br><br>  <b>3.</b> Durch die Parallelisierung zu vielen kleineren Zweigen werden die Berechnungen „breiter“.  Diese Breite kann durch Auswahl nicht nur auf der Ebene einzelner Rechenzweige, sondern auch in der gesamten Anordnung paralleler Zweige absolut begrenzt werden.  Dies kann über einen gemeinsamen Pool fester Größe erfolgen, von dem aus jeder Zweig Linien für die nächste Iteration zeichnet und dementsprechend die Ergebnisse ausgibt.  Und für Zeichenfolgen können Sie die zulässige Verschachtelung von Klammern absolut begrenzen.  Ein solcher kombinierter Ansatz wird dazu beitragen, das Wachstum des Rechenvolumens einzudämmen und zu regulieren. <br><br><h2>  Interpretation und Kommentar </h2><br>  <b>Beweise</b> .  Es gibt keine Beweise und kann nicht sein.  Jede Theorie des Denkens ist eine Frage der Definition.  Der vorgestellte Algorithmus ist eine konstruktive Theorie des Denkens.  Und deshalb ist er ein Axiom.  Der Denkalgorithmus ist für das Thema Denken apodiktisch erkennbar.  Das Erkennen kann erleichtert werden, indem zunächst auf eine nicht konstruktive Axiomatik zurückgegriffen wird, die intuitiver ist, und dann die Übereinstimmung der Eigenschaften konstruktiver und nicht konstruktiver Definitionen gefunden wird. <br><br>  <b>Unkonstruktive Definition des Denkens</b> .  Denken ist keine algorithmische Produktion von Inhalten.  In einem intuitiven Verständnis weisen nicht-algorithmische Phänomene die folgenden spezifischen Merkmale auf: Unabhängigkeit, Spontaneität, Einzigartigkeit, Selbstorganisation, Willkür, Subjektivität, Komplexität, fundamentale Unvorhersehbarkeit und Unsicherheit, das Fehlen konzeptioneller Barrieren und im weitesten Sinne eine inhärente und dauerhafte Möglichkeit grundlegender Neuheit.  Alle aufgelisteten Merkmale sind dem beschriebenen Denkalgorithmus irgendwie inhärent.  Obwohl die Kombination eines Algorithmus und nichtalgorithmischer Eigenschaften nicht intuitiv und auf den ersten Blick widersprüchlich ist, gibt es tatsächlich keinen Widerspruch.  Der Algorithmus stellt Inhalte mithilfe genau definierter algorithmischer Verfahren bereit. Während der Bereitstellung ist der Inhalt jedoch nicht algorithmisch organisiert.  Angesichts der Entwurfsspezifikationen des Algorithmus ergeben sich nichtalgorithmische Eigenschaften bei der Organisation von Inhalten aus den eigenen internen, nichtalgorithmischen Eigenschaften des Inhalts selbst. <br><br>  <b>Zusätzliche Gesichtspunkte zum Algorithmus</b> .  Der Denkalgorithmus umfasst: <br><br>  <b>1.</b> Konstruktive Umsetzung einer Metapher.  Denken ist im Wesentlichen metaphorisch.  Es gibt keine anderen Bedeutungen als bildlich (möglich).  Im übertragenen Sinne sind jedoch wörtliche Bedeutungen (Algorithmen) möglich. <br>  <b>2.</b> Selbstorganisationsmodell des absoluten Chaos.  Ein Modell konzeptioneller Spontanität. <br>  <b>3.</b> Ein Modell völlig unabhängigen, subjektiv motivierten Verhaltens.  Modell der Kreativität. <br>  <b>4.</b> Selbstorganisierende Sprache. <br>  <b>5.</b> Das Modell der konstruktiven Approximation für nichtkonstruktive, rein mögliche Semantik. <br><br>  <b>Bewusstsein</b>  Die Frage des Bewusstseins wird auch auf der Ebene der Definition gelöst.  Bewusstsein ist etwas, das jenseits jeglicher konzeptioneller Grenzen liegt.  Im Lichte dieser Definition kann man nur mehr oder weniger komplizierte Geschichten über das Bewusstsein vergiften, von denen jede einige Möglichkeiten des Bewusstseins widerspiegelt, aber keine davon wird wahr sein.  Gleichzeitig haben Bewusstseinsgeschichten unterschiedliche heuristische Potenziale.  Von allen Geschichten sind diejenigen, die schwieriger sind, nützlicher.  Aus der Sicht von Algorithmen ist Bewusstsein ein transalgorithmisches, unendlich komplexes (oder einfach - komplexes) Objekt.  Eine Geschichte des Bewusstseins kann unter Verwendung eines Algorithmus aufgezeichnet werden.  Es klingt so: <br><br>  <font color="#0000ff">lim <sub>n → ∞</sub> [t <sub>n + 1</sub> = <b>Zusammensetzung</b> [ <b>Abstraktion</b> [ <b>Abzug</b> [t <sub>n</sub> ]]];</font>  <font color="#0000ff">t <sub>0</sub> = s;</font>  <font color="#0000ff">t <sub>n</sub> , s ∈ <b>S</b> ;</font>  <font color="#0000ff">n ∈ <b>N.</b></font> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440424/">https://habr.com/ru/post/de440424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440412/index.html">Zimbra Collaboration Suite und MS Exchange in derselben Domäne</a></li>
<li><a href="../de440414/index.html">Über Linter, Codequalität, Qualität im Allgemeinen und Qualitätsmanagement</a></li>
<li><a href="../de440416/index.html">Kolonie. Kapitel 25: Ausgehen</a></li>
<li><a href="../de440420/index.html">Willkommen zum Devleads Meetup am 21. Februar</a></li>
<li><a href="../de440422/index.html">Wenn Sie für die Qualität des Geschenks verantwortlich sind. Die Geschichte eines Blockchain-Experiments</a></li>
<li><a href="../de440426/index.html">Ein neuer Ansatz zum Verständnis des maschinellen Denkens</a></li>
<li><a href="../de440428/index.html">SMAA: Verbesserte morphologische Glättung von Subpixeln</a></li>
<li><a href="../de440430/index.html">Woher kommt der Slogan „Sei nicht böse“?</a></li>
<li><a href="../de440432/index.html">Freitag SciFi über die Berufe der Zukunft: "Real Girls"</a></li>
<li><a href="../de440434/index.html">Russische Autoindustrie: Der Weg zu additiven Technologien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>