<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∂üèæ üè≥Ô∏è üè¢ Ist ein Automat eine Ereignissache? üíπ üë©üèª üöé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Einleitung 
 Nachdem ich von ma√ügeblichen Lippen geh√∂rt hatte, dass ‚ÄûAutomaten eine Ereignissache sind‚Äú [3], wurde mir klar, dass endliche Automate...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ist ein Automat eine Ereignissache?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483610/"><h3>  1. Einleitung </h3><br>  Nachdem ich von ma√ügeblichen Lippen geh√∂rt hatte, dass ‚ÄûAutomaten eine Ereignissache sind‚Äú [3], wurde mir klar, dass endliche Automaten vollst√§ndig gebrandmarkt sind.  √úberzeugen Sie sich selbst: In der Qt-Bibliothek ist ein Ereignismodell von Automaten [1] implementiert, in UML sind sie auch [2], wir betrachten die Automaten des Simulink-Stateflow-Erweiterungspakets des MATLAB-Systems [4] (im Folgenden einfach Stateflow) und dort Ereignisse usw.  usw.  In diesem Zusammenhang ist die Erkl√§rung von Ph.D.  A.A.  Es ist ungezogen, anders zu interpretieren, weil  nichts anderes kann sein, weil es nicht sein kann. <br><br>  Aber wenn Sie sich an die Theorie der endlichen Automaten (TCA) erinnern, dann ist kein Wort √ºber Ereignisautomaten drin!  Um jedoch der Theorie zu widersprechen, sind gewichtige Argumente erforderlich.  Gibt es einen Grund, die Professionalit√§t von D. Harell als Sch√∂pfer der Notation zu bezweifeln, auf die die UML-Sprache, das Stateflow-Paket, ihre Ideen st√ºtzt, die A.A.  Frech?  In der Tat gibt es UML, Stateflow, SWITCH-Programmierung und andere automatische Programmieroptionen, die in gewissem Ma√üe erfolgreich funktionieren. <br><br>  Ist es also m√∂glich, das "Stigma der Ereignisse" aus dem Finite-State-Machine-Modell zu entfernen, indem die "Schnitzel von den Fliegen" getrennt werden?  Das hei√üt  trennen die Theorie der Automaten und Rechenmodelle √§hnlich wie D. Harels Modelle.  Und zu bedenken, dass letztere, obwohl sie die Terminologie der Automatentheorie verwenden, nach ihrer Implementierung die Entwicklung eines Modells f√ºr Blockdiagramme von Programmen darstellen. <br><a name="habracut"></a><br>  <i>Anmerkung 1. In diesem Fall handelt es sich um das Programmverwaltungsmodell und nicht um das Programmmodell selbst (weitere Einzelheiten zu den Modellen finden Sie in [5]).</i> <br><br>  Denken Sie daran, dass die Qt-Bibliothek ein Ereignismodell einer Finite-State-Maschine implementiert, das aus der UML entlehnt wurde.  Dasselbe Modell wird von Stateflow implementiert.  Das hei√üt  Die Quelle der Ereignisse ist UML, wo die Automaten auf der von D. Harel vorgeschlagenen Notation basieren.  Letztere f√ºr die Erstellung einer solchen automatischen Programmierung zu beschuldigen, w√§re aber auch nicht wahr, weil  "Eventfulness" ist eine Tendenz moderner Ans√§tze zur Implementierung von Softwaremodellen.  Es basiert auf ma√ügeblichen Meinungen wie den erw√§hnten ‚ÄûMaschinen sind ein Ereignis‚Äú und der hohen Popularit√§t von Sprachen und Technologien wie UML.  Dies ist zweifelsohne das Ergebnis der Nachahmung von Maschinen gem√§√ü den bestehenden Grunds√§tzen f√ºr den Betrieb von Betriebssystemen. <br><br>  Aber wir wiederholen, wie es nicht seltsam erscheint, aber f√ºr einige kann es sogar zu Nachrichten werden, in der Theorie der Automaten gibt es kein Ereignismodell eines endlichen Automaten.  Zumindest in dem Teil, der als klassisch angesehen wird (siehe f√ºr weitere Einzelheiten beispielsweise [6] oder [7]).  Es gibt einen klaren Widerspruch zwischen Theorie und Praxis.  In einer solchen Situation muss man etwas mit der Theorie anfangen oder die Praxis irgendwie beeinflussen.  Aber vielleicht haben Programmierer Recht mit ihrem Wunsch, das Modell einer endlichen Zustandsmaschine zu finalisieren, indem sie das Konzept des ‚ÄûEreignisses‚Äú einbeziehen [8, 9]? <br><br>  Aber wie lassen sich die W√ºnsche der Programmierer mit der Tatsache verbinden, dass ‚Äûdie gr√∂√üten Schwierigkeiten bei der Verwendung des Automatisierungsansatzes mit dem Verst√§ndnis der Funktionsmerkmale von Automaten in Ereignissystemen verbunden sind‚Äú (siehe [8]).  Ich m√∂chte die Ursachen solcher Probleme verstehen und in diesem Zusammenhang Event-Maschinen und / oder deren Analoge implementieren.  Zu diesem Zweck nehmen wir die Implementierung von Automaten in Qt und wiederholen sie unter Verwendung des Modells eines klassischen endlichen Automaten. <br><br>  Eine solche Implementierung von Ereignisautomaten ist notwendig, um die genannten "Merkmale" zu bewerten und / oder zu √ºberwinden.  Die Anwendung des klassischen Modells wird die Theorie der Automaten auch auf die Praxis der "Ereignisprogrammierung" ausweiten.  Und letztendlich wird ein Analogon, das auf einem anderen Modell basiert, nur den Anwendungsbereich von Finite-State-Machine-Modellen erweitern. <br><br><h3>  2. Ereignisse, Signale und Geschlechtsidentit√§t von Automaten </h3><br>  In der UML ist ein Ereignis ‚Äûein signifikantes Ph√§nomen, das eine bestimmte zeitliche und r√§umliche Position einnimmt und bestimmte Konsequenzen hat‚Äú [10].  Ein Ereignis in der Theorie der Automaten ist eine Teilmenge der eingegebenen Zeichen, die durch die Zeichen des ausgegebenen Alphabets dargestellt werden (es gibt sogar das Konzept der Ereignisalgebra in der TCA) [6].  Dasselbe, was den √úbergang eines Automaten verursacht, nennt man Eingangssignale in der Theorie der Automaten.  Sie sind die Konsequenzen und ‚Äûder Grund, der √úbergang des Automaten von einem Zustand in einen anderen.  In diesem Fall sind die Ausgangssignale die ‚ÄûAntwort des Automaten auf die Eingangssignale‚Äú. Beide ‚Äûbeziehen sich auf Zeitmomente, die durch die entsprechenden √úberg√§nge des Automaten bestimmt werden.‚Äú [6] In der UML ist das Signal ‚Äûeine benannte Entit√§t, die als Kommunikationsmittel dient zwischen Objekten ‚Äú[10]. <br><br>  Die Bezeichnungen der Begriffe sind also gleich, aber die Bedeutung, die in sie investiert wird, ist unterschiedlich.  Wenn Sie sie jedoch neu anordnen, k√∂nnen Sie eine √Ñhnlichkeit feststellen: Es wird deutlich, dass die Ereignisse in UML den Signalen von Zustandsautomaten in der TCA entsprechen.  Aber vielleicht sind unter dem Begriff ‚ÄûFinite-State-Machine‚Äú auch verschiedene Entit√§ten verborgen?  Lassen Sie uns versuchen, es herauszufinden, beginnend mit Ereignissen ... <br><br>  Der Ereignisautomat ist ein passiver Automat, weil  funktioniert nur im Moment der Ankunft von Ereignissen.  Im Gegensatz dazu repr√§sentiert der klassische Automat das aktive Modell.  Es funktioniert ohne Bezug auf irgendetwas (f√ºr weitere Details zu passiven und aktiven Automaten siehe [9]).  Hier bettelt die Assoziation mit zwei L√§ufern, wobei der erste von Tritten (Events) angetrieben wird und der zweite von alleine l√§uft. <br><br>  Im Gegensatz zu [8] werden wir die Momente des Auftretens von Ereignissen zun√§chst nicht mit dem Start des Automaten verkn√ºpfen.  Wir bleiben also im Rahmen der Automatentheorie, die die asynchrone Funktionsweise von Automaten in Bezug auf die √§u√üere Umgebung bestimmt.  Es spricht nur von diskreter Zeit, in der der Zustandswechsel f√ºr eine beliebig kleine, aber nicht gleich Null liegende Echtzeitperiode durchgef√ºhrt wird.  Und der Grund f√ºr die √úberg√§nge ist der aktuelle Zustand und die Eingangssignale der Maschine, wobei die Konsequenzen die Installation eines neuen Zustands und die Werte der Ausgangssignale der Maschine sind (Einzelheiten zur Definition von Maschinen siehe [6]). <br><br>  Die Automatentheorie ist flexibel bei der Bestimmung der diskreten Zeit, bei der es sich um ein Echtzeitmodell handelt.  Ein diskreter Zeitzyklus kann also einen festen oder gleitenden Wert eines Echtzeitintervalls haben, und dementsprechend werden Maschinen als synchron oder asynchron bezeichnet.  Gleichzeitig kann das der Uhr zugeordnete Zeitintervall einen beliebigen Wert haben, einschlie√ülich eines unendlich kleinen Werts, der jedoch nicht gleich Null ist. <br><br>  <i>Bemerkung 2. Ein Finite-State-Machine-Modell ist eines der wenigen formalen Modelle, das in seiner Definition ein Echtzeitmodell in expliziter Form enth√§lt.</i> <br><br>  Infolgedessen erlaubt die formal ‚Äûunendliche‚Äú Geschwindigkeit des aktiven Automaten, dass jedes Ereignis als potentielles Eingangssignal behandelt wird (im Sinne von UML entspricht Bedingung [11] diesem).  Die Maschine muss nur solche Ereignisse / Signale und Pausen zwischen ihnen ‚Äûerfassen‚Äú.  All dies definiert tats√§chlich das Protokoll f√ºr die gemeinsame Arbeit von Medium und Automat.  Das Protokoll sollte auch das Problem des Erkennens nacheinander empfangener identischer Ereignisse l√∂sen.  Ohne dies k√∂nnen beispielsweise zwei identische Symbole, die nacheinander empfangen werden, als eins wahrgenommen werden. <br><br>  Formal sind die Nuancen der Ereignisverarbeitung nicht signifikant (siehe dieselben abstrakten Automaten), aber bei der praktischen Implementierung von Algorithmen, die nach dem Typ des Ereignismodells aufgebaut sind, m√ºssen sie ber√ºcksichtigt werden.  Bei der Qt-Bibliothek ist ihre Abrechnung in den Implementierungsklassen des Automaten verborgen.  Des Weiteren werden wir die Unterschiede zwischen Ereignis- und klassischen Automaten am Beispiel der Implementierung des einfachsten Rechners aus [1] ber√ºcksichtigen, wo dessen ‚ÄûEreignisimplementierung‚Äú angegeben ist.  Im Gegensatz zu dieser L√∂sung werden √§quivalente Modelle erstellt, die auf der klassischen Finite-State-Maschine basieren. <br><br><h3>  3. Rechnermodelle </h3><br>  Fangen wir also an ... Wir nennen Ereignissignale, gew√∂hnliche Automatenereignisse ... oder in umgekehrter Reihenfolge und / oder umgekehrt?  Ugh!  Verwirrt.  Kurz gesagt, die komplette "glockige Cuzdra Shteko Budlanula" und etwas "Locken".  Um herauszufinden, wer wer ist, was und wie man es nennt, ist es am sichersten, ein bestimmtes ‚ÄûBokra‚Äú auszuw√§hlen und es zu ‚Äûsto√üen‚Äú ... Das Programm ‚Äûautomatischer Taschenrechner‚Äú wird weiterhin eine solche ‚ÄûSeite‚Äú sein. <br><br><h4>  3.1.  Aktives Rechnermodell </h4><br>  In Abb.  1 zeigt das Originalmodell der Klasse Calculator aus [1].  In der Erscheinung sieht es aus wie eine klassische abstrakte Maschine ohne Ausweg.  Der Unterschied besteht darin, dass Qt Aktionen verkn√ºpft, wenn es in einen Zustand eintritt und diesen verl√§sst.  Am Ausgang werden sie durch das Signal exit () und beim Eintritt in den Zustand durch das Signal enter () ausgel√∂st.  Wir stellen jedoch fest, dass diese Aktionen in der Grafik in keiner Weise dargestellt werden. <br><br>  Wenn wir das Modell in Abb.  1 mit einem Automaten mit einem abstrakten Zustand (seine anderen Namen sind struktureller, logischer Automat), kann man leicht sehen, dass die Aktionen am Ausgang des Zustands den Signalen des Mealy-Automaten entsprechen und die Aktionen am Eingang zu ihm den Signalen des Moore-Automaten entsprechen. <br>  Bemerkung 3. In Anbetracht der Software-Implementierung des Modells werden wir nicht √ºber Signale, Ereignisse, Bedingungen usw. sprechen, sondern √ºber die Aktionen von Automaten, vorausgesetzt, dass sie auf Programmebene bestimmten Programmaktionen zugeordnet sind, die im Allgemeinen der Fall sind dargestellt durch Softwarefunktionen. <br><br>  Der sogenannte kombinierte Mili-Moore-Automat (oder ein anders gemischter Automat [12]), der dem Automaten in Abb.  Fig. 2 zeigt die Funktionen, die den Eingangs- und Ausgangssignalen des Automaten entsprechen. <br><br><img src="https://habrastorage.org/webt/dq/ki/ps/dqkipszttmbkgyexe9labqsio9e.jpeg" alt="Bild"><br>  <i>1.</i>  <i>Rechner-Ereignis-Maschinendiagramm</i> <br><br><img src="https://habrastorage.org/webt/c3/la/ue/c3laueqyd9oiwdf9aiu5gpyi_yk.jpeg" alt="Bild"><br>  <i>2.</i>  <i>Z√§hlen Sie den Rechner der Miley-Moore-Automatenklasse</i> <br><br>  F√ºr ein Modell √§hnlich einem Automaten in Fig. 2 meinen wir mit Eingabe / Ausgabe-Aktionen Pr√§dikate und Aktionen, die Programmfunktionsmethoden von [Automaten] -Klassen sind.  Pr√§dikate analysieren den aktuellen Status von Speicherelementen (Variablen, Klasseneigenschaften) in keiner Weise (dies ist wichtig!). Sie haben keine Auswirkungen darauf, geben jedoch abh√§ngig von ihrem Wert einen Booleschen Wert zur√ºck.  Aktionen eines Wertes werden nicht zur√ºckgegeben, sondern √§ndern Speicherelemente. <br>  Aus Abb.  2 Daraus folgt, dass das Rechnermodell wie die ‚ÄûBlack Box‚Äú vier Eingangskan√§le und sieben Ausgangskan√§le in Bezug auf die Anzahl der Pr√§dikate und Aktionen aufweist.  Es ist leicht zu erkennen, dass im Vergleich zu einem abstrakten Automaten, der per Definition nicht mehr als einen Eingangs- und einen Ausgangskanal hat, ein struktureller Automat mit vielen Kan√§len universeller, flexibler und praktischer ist. <br><br>  Das Modell in Abb.  2 kann durch ‚ÄûKleben‚Äú der Zust√§nde 1 und 2 vereinfacht werden. Dazu m√ºssen Sie zuerst den Originalautomaten in einen mehligen Automaten verwandeln.  Wir erhalten es durch Laden der B√∂gen, die in den Zustand der Signale eintreten, mit den Signalen, die durch die Signale der Eckpunkte des Moore-Automaten dargestellt werden.  Danach wird der Klebevorgang ersichtlich.  Das Ergebnis der Verklebung von Zust√§nden zu Zustand 2, der nun anf√§nglich wird, ist in Fig. 2 gezeigt.  3. <br><br><img src="https://habrastorage.org/webt/qa/en/yw/qaenywlioaky3gizvfju27faxmm.jpeg" alt="Bild"><br>  <i>3.</i>  <i>Das Ergebnis der Transformation und Verklebung der Zust√§nde des Automaten in Fig. 2</i> <br><br>  Erl√§utern Sie die Aktion y1 und die Variable nTypeButtons.  Insgesamt implementieren sie ein Protokoll, das Ereignisse simuliert.  Die Variable nTypeButtons bestimmt die Art der Eingabesymbole des Automaten, indem sie in digitale Symbole, Operationssymbole, das Symbol "Zur√ºcksetzen" und das Symbol "Gleich" unterteilt wird.  Sein Wert gleich Null bedeutet das Fehlen von Eingabezeichen (keine der Rechnertasten wird gedr√ºckt).  Nach der Bearbeitung des Symbols bedeutet dies auch, dass das Eingabesymbol automatisch wahrgenommen wird.  Dies blockiert die Antwort auf das eingegebene Zeichen. <br><br>  Der Code f√ºr die Klasse des Rechners, der im Rahmen der automatischen visuellen Komponentenprogrammierung (VKPa) [5] erstellt wurde, ist in den Auflistungen 1, 2 aufgef√ºhrt. <br><br><div class="spoiler">  <b class="spoiler_title">Listing 1. Header der FCalculator-Klasse</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"lfsaappl.h"</span></span></span><span class="hljs-meta"> enum Buttons { digit0 = 0, digit1, digit2, digit3, digit4, digit5, digit6, digit7, digit8, digit9, opPlus, opMinus, opCancel, opEqual, opNone }; class FCalculator : public LFsaAppl { public: void MooreAction(); LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FCalculator(pTAppCore, nameFsa, pCVarFsaLibrary); } FCalculator(TAppCore *pInfo, string strNam, CVarFsaLibrary *pCVFL); virtual ~FCalculator(void); public: void digitButtonPressed(int button); void operationButtonPressed(int button); private: void s1Entered(); void s2Entered(); void s3Entered(); void s3Exited(); void s5Entered(); void s5Exited(); private: int Rf, Rb; Buttons transitionButton, Op; int nTypeButtons; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 0 - none; 1 - digit button; 2 - operation button; void doOp(Buttons op); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y3(); void y5(); void y6(); void y7(); void y8(); void y9(); void y10(); int nState{2}; };</span></span></span></span></code> </pre> <br><br></div></div><br>  Lassen Sie uns erkl√§ren.  In VKPa erbt jede Automatenklasse die Eigenschaften der Basisautomatenklasse LFsaAppl.  Die Methode Create () erstellt Kopien der Klassen, die in den dynamischen Bibliotheken automatischer Prozesse enthalten sind.  Die virtuelle MooreAction () -Methode √ºberlappt sich, wenn ein Moore-Automatenmodell ausgew√§hlt wird, und definiert Aktionen, die den Zust√§nden des Automaten zugeordnet sind.  Die Methoden x [n] und y [n] sind die Pr√§dikate und Aktionen, die den Eingabe- / Ausgabekan√§len des Automaten zugeordnet sind.  Der Verhaltensalgorithmus der Klasse [automaton] wird durch die √úbergangstabelle (siehe Listing 2) dargestellt, die aus einem Array von Zeichenfolgen vom Typ LArc besteht.  Der Rest des Codes wiederholt den Code der Quellklasse Calculator. <br><br><div class="spoiler">  <b class="spoiler_title">Listing 2. Implementierung der FCalculator-Klasse</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FCalculator.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"DlgCalculator.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ui_cdlgcalculator.h"</span></span></span><span class="hljs-meta"> static LArc TBL_Calculator[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//* LArc("1", "2","x1", "y1"), // [0-9] LArc("2", "1","x3", "y1"), // [c] LArc("2", "2","x1", "y1"), // [0-9] LArc("2", "3","x2", "y1"), // [+][-] LArc("3", "1","x3", "y3"), // [c] LArc("3", "3","x2", "y3"), // [+][-] LArc("3", "4","x1", "y3"), // [0-9] LArc("3", "5","x4", "y3"), // [=] LArc("4", "1","x3", "y1"), // [c] LArc("4", "3","x2", "y1"), // [+][-] LArc("4", "4","x1", "y1"), // [0-9] LArc("4", "5","x4", "y1"), // [=] LArc("5", "1","x3", "y5"), // [c] LArc("5", "2","x1", "y5"), // [0-9] LArc("5", "3","x2", "y5"), // [+][-] //*/ /* LArc("2", "2","x1", "y1y7"), // [0-9] LArc("2", "2","x3", "y1y6"), // [c] LArc("2", "3","x2", "y1y8"), // [+][-] LArc("3", "2","x3", "y3y6"), // [c] LArc("3", "3","x2", "y3y8"), // [+][-] LArc("3", "4","x1", "y3y7"), // [0-9] LArc("3", "5","x4", "y3y9"), // [=] LArc("4", "2","x3", "y1y6"), // [c] LArc("4", "3","x2", "y1y8"), // [+][-] LArc("4", "4","x1", "y1y7"), // [0-9] LArc("4", "5","x4", "y1y9"), // [=] LArc("5", "2","x3", "y5y6"), // [c] LArc("5", "2","x1", "y5y7"), // [0-9] LArc("5", "3","x2", "y5y8"), // [+][-] */ // LArc("1", "1","--", "y10"), // SWITCH LArc() }; FCalculator::FCalculator(TAppCore *pInfo, string strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Calculator, strNam, nullptr, pCVFL) { pTAppCore = pInfo; Rf= 0; Rb = 0; Op = opNone; } FCalculator::~FCalculator(void) { } //   int FCalculator::x1() { if (nTypeButtons != 1) return false; else return true; } //   +, - int FCalculator::x2() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton != opCancel &amp;&amp; transitionButton != opEqual ) return true; else return false; } //  Cancel int FCalculator::x3() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton == opCancel) return true; else return false; } //  opEqual int FCalculator::x4() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton == opEqual) return true; else return false; } void FCalculator::y1() { nTypeButtons = 0; } void FCalculator::y3() { s3Exited(); } void FCalculator::y5() { s5Exited(); } void FCalculator::y6() { s1Entered(); } // 1 void FCalculator::y7() { s2Entered(); } // 2, 4 void FCalculator::y8() { s3Entered(); } // 3 void FCalculator::y9() { s5Entered(); } // 5 void FCalculator::y10() { switch(nState) { case 2: if (x1()) { y1();y7(); } if (x3()) { y1();y6(); } if (x2()) { y1();y8(); nState = 3; } break; case 3: if (x3()) { y3();y6(); nState = 2; } if (x2()) { y3();y8(); } if (x1()) { y3();y7(); nState = 4; } if (x4()) { y3();y9(); nState = 5; } break; case 4: if (x3()) { y1();y6(); nState = 2; } if (x2()) { y1();y8(); nState = 3; } if (x1()) { y1();y7(); } if (x4()) { y1();y9(); nState = 5; } break; case 5: if (x3()) { y5();y6(); nState = 2; } if (x1()) { y5();y7(); nState = 2; } if (x2()) { y5();y8(); nState = 3; } break; } } void FCalculator::MooreAction() { // return; string strState = FGetState(); if (strState=="1") { y6(); } else if (strState=="2") { y7(); } else if (strState=="3") { y8(); } else if (strState=="4") { y7(); } else if (strState=="5") { y9(); } } /////////////////////////////////////////////////////////////////////////// void FCalculator::digitButtonPressed(int button) { transitionButton = static_cast&lt;Buttons&gt;(button); nTypeButtons = 1; } void FCalculator::operationButtonPressed(int button) { transitionButton = static_cast&lt;Buttons&gt;(button); nTypeButtons = 2; } void FCalculator::s1Entered() { Rf = 0; Rb = 0; Op = opNone; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } void FCalculator::s2Entered() { if (Rf &lt; 9999999) { Rf = Rf*10 + transitionButton; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } } void FCalculator::s3Entered() { if (Rb != 0) { doOp(Op); static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } Rb = Rf; Op = transitionButton; } void FCalculator::s3Exited() { nTypeButtons = 0; if (transitionButton &gt; digit9 &amp;&amp; transitionButton &lt; opCancel ) { doOp(transitionButton); Rb = 0; Op = transitionButton; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } else { Rf = 0; } } void FCalculator::s5Entered() { doOp(Op); Op = opNone; Rb = Rf; // added by me static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } void FCalculator::s5Exited() { nTypeButtons = 0; if (transitionButton &lt;= 9) { Rb = 0; Rf = 0; } } void FCalculator::doOp(Buttons op) { switch (op) { case opPlus: Rf = Rf + Rb; break; case opMinus: Rf = Rb - Rf; break; default: break; } }</span></span></span></span></code> </pre><br><br></div></div><br>  Hinweis Listing 2 enth√§lt drei Sprungtabellen (zwei sind auskommentiert).  Auf diese Weise werden die Funktionen der dedizierten Steuerung realisiert, wenn das Verhalten der Klasse nach dem Entfernen des Kommentars "per Mausklick" ge√§ndert werden kann, ohne die Methoden und Eigenschaften zu beeintr√§chtigen.  F√ºr die Modellierung der SWITCH-Technologie (Details siehe [9]) im Rahmen der VKPA-Technologie wurden die y10-Methode und die entsprechende Zeile in der √úbergangstabelle (siehe die mit dem Kommentar SWICH gekennzeichnete Zeile) eingef√ºhrt.  In diesem Fall wird das Verhalten eines Automaten durch einen zyklischen Aufruf an den SWITCH-Operator modelliert, der das Verhalten des Automaten imitiert (hier fungiert der VKPa-Automat als externe Umgebung). <br><br><h4>  3.2.  Passives Rechnermodell </h4><br>  Das aktive Rechnermodell durchsucht st√§ndig die Eingangskan√§le.  Sobald der Wert der Variablen nTypeButtons ungleich Null wird, dient dies als Zeichen f√ºr das Eintreffen des n√§chsten Symbols am Eingang des Automaten.  Infolgedessen werden der √úbergang und die Aktion y1 ausgel√∂st, wodurch die Variable nTypeButtons zur√ºckgesetzt wird und die automatische Maschinenwiederausl√∂sung durch dasselbe Zeichen blockiert wird. <br>  Im Gegensatz zum Modell des ‚Äûaktiven Rechners‚Äú kann ein Ereignisautomat per Definition kein Eingabesymbol erneut verarbeiten.  Jetzt ist klar, dass "die gr√∂√üten Schwierigkeiten bei der Verwendung des Automatenansatzes ... in Ereignissystemen" darin zu bestehen scheinen, die Aktivit√§t eines aktiven Automaten zu unterdr√ºcken und seine Funktion mit Ereignissen zu verkn√ºpfen.  Wir zeigen am Beispiel des soeben erstellten ‚Äûaktiven Rechners‚Äú die Vorgehensweise zum Umschalten auf einen passiven Automaten. <br>  Die VKPa-Umgebung enth√§lt eine schrittweise Anleitung zum Debuggen automatischer Prozesse.  Es kann jedoch zur Simulation von Ereignismaschinen verwendet werden.  Dazu 1) stellen Sie den Automatenraum, in den der Automat gestellt wird, schrittweise ein (beachten Sie, dass es sich nicht um einen separaten Automaten handelt, sondern um den gesamten Automatenraum, der Automaten enth√§lt), und 2) beziehen Sie die Zeitpunkte des Auftretens von Ereignissen auf die Ausf√ºhrung eines einzelnen Schrittes der Operation des Raums.  Listing 3 zeigt, wie dies getan wird. Es werden nur die am Modell vorgenommenen √Ñnderungen wiedergegeben (der Klassenheader bleibt unver√§ndert). <br><br><div class="spoiler">  <b class="spoiler_title">Listing 3. Eine m√∂gliche Variante der FCalculator-Klasse</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> LArc TBL_Calculator[] = { LArc(<span class="hljs-string"><span class="hljs-string">"st"</span></span>, <span class="hljs-string"><span class="hljs-string">"st"</span></span>,<span class="hljs-string"><span class="hljs-string">"^x12"</span></span>, <span class="hljs-string"><span class="hljs-string">"y12"</span></span>), <span class="hljs-comment"><span class="hljs-comment">// LArc("st", "1","x12", "y11"), // // ... }; ... //   bool FCalculator::FCreationOfLinksForVariables() { pNet = GetPointerToNet(); //    if (pNet) { string str = pNet-&gt;strName; //    //  -  pSV = this-&gt;pTAppCore-&gt;pSetVarSetting-&gt;GetAddressVar(const_cast&lt;char*&gt;(str.c_str())); } return true; } ... // int FCalculator::x12() { if (!pNet) return false; if (!pSV) return false; return true; } ... //    step-by-step void FCalculator::y11() { pSV-&gt;bIfStepByStep = true; } //   void FCalculator::y12() { FCreationOfLinksForVariables(); } // ... ///////////////////////////////////////////////////////////////////////////////////////////////////////////////// void FCalculator::digitButtonPressed(int button) { ... pSV-&gt;bIfStopAllTasks = false; //     } void FCalculator::operationButtonPressed(int button) { ... pSV-&gt;bIfStopAllTasks = false; //     } ...</span></span></code> </pre><br><br></div></div><br>  Hier wird zun√§chst ein zus√§tzlicher [Ausgangs] -Zustand eingef√ºhrt, in dem ein Verweis auf den Raum, in dem sich die Maschine befindet, und eine Verkn√ºpfung zu einem Objekt, das die Eigenschaften des Raums (einschlie√ülich seines Betriebsmodus) definiert, √ºberpr√ºft werden.  Eh bildet die Handlung von y12.  Wenn die Verkn√ºpfungen gesetzt sind, erfolgt ein √úbergang in den [fr√ºheren] Ausgangszustand des Rechnermodells mit der Installation einer schrittweisen Betriebsart des Automatenraums. <br><br>  Ferner arbeitet das Modell in einer schrittweisen Weltraumbetriebsart.  Der Start eines Schritts implementiert den Code, der in die Ereignishandler f√ºr die Eingabe des n√§chsten Zeichens eingef√ºgt wurde (siehe Listing 3 f√ºr die √Ñnderungen an den Methoden digitButtonPressed und operationButtonPressed). <br><br><h3>  4. Warum? </h3><br>  Warum etwas erfinden, wenn es, wie anzunehmen ist, ein fortgeschritteneres Ereignismodell von D. Harel gibt.  Und wie man anders denkt, wenn es in UML, Stateflow, in der Qt-Bibliothek usw. ausgef√ºhrt wurde.  usw.  und es gibt nicht viel Panik √ºber seine M√§ngel.  Nun, sie nannten die Signale Ereignisse und verwandelten die aktive Maschine in eine passive ... Und wenn das Modell, wie sie sagen, auch formal den klassischen Mili / Moore-Maschinen entspricht, wie kann man dann nicht daran glauben?  Und so ist es, wenn all diese Aussagen nur auf den Glauben bezogen sind ... <br><br>  Nehmen Sie f√ºr den Beginn der Veranstaltung (das ist genau das, was wir oben gemacht haben).  Ein klassischer Strukturautomat hat zum Beispiel viele Eingangskan√§le, von denen jeder einem Signal zugeordnet ist, und sie k√∂nnen gleichzeitig / parallel verarbeitet werden.  Laut UML kann "jedes Objekt nur ein Ereignis gleichzeitig verarbeiten", und selbst wenn zwei Ereignisse gleichzeitig auftreten, verarbeitet das Objekt sie immer noch nacheinander "[10].  Auf der Definitionsebene sind Signale und Ereignisse also gleichwertig, aber die Idylle bricht bei der Implementierung von Modell√ºberg√§ngen zusammen. <br><br>  Betrachten Sie das Beispiel, mit dem ich anfange, eine Sprache oder Technologie zu testen / zu lernen.  Es geht um die Software-Implementierung des Elementmodells AND-NOT.  Auf der strukturellen Ebene entspricht es der ‚ÄûBlack Box‚Äú, die zwei Eingangskan√§le und einen Ausgang hat, und auf der algorithmischen Ebene dem in Abb.  4. <br><br><img src="https://habrastorage.org/webt/6q/7d/ve/6q7dve1toup6onrda9kkjsqzg2u.jpeg" alt="Bild"><br>  <i>Abb.</i>  <i>4. Das Automatenmodell des Elements AND NOT</i> <br><br>  Es ist verst√§ndlich, wie man ein regul√§res Vorgehensmodell erstellt (siehe Listing 4) oder wie man einen Automaten in VKPa implementiert (siehe Listing 5), aber wie man dies anhand des Ereignisautomaten der Qt-Bibliothek wiederholt, ist aufgrund des Problems der Implementierung des √úbergangs vom Zustand ‚Äû1‚Äú nicht sehr klar. auf "0" setzen, was die gleichzeitige Analyse mehrerer Ereignisse erfordert. <br><br>  Listing 4. Objektimplementierung des AND-NOT-Vorgehensmodells <br><br><div class="spoiler">  <b class="spoiler_title">Listing 4. Objektimplementierung des AND-NOT-Vorgehensmodells</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INE</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: INE() {} ~INE(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bX1, bX2, bY; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bY = !(bX1&amp;&amp;bX2); } };</code> </pre><br><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Listing 5. Objektimplementierung des AND-NOT-Automatenmodells</b> <div class="spoiler_text"><pre> <code class="cpp hljs">LArc T_INE[] = { LArc(<span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"x1x2"</span></span>, <span class="hljs-string"><span class="hljs-string">"y1"</span></span>), LArc(<span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"^x1"</span></span>, <span class="hljs-string"><span class="hljs-string">"y2"</span></span>), LArc(<span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"^x2"</span></span>, <span class="hljs-string"><span class="hljs-string">"y2"</span></span>), }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ine</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LFsaAppl { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Ine(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> strNam = <span class="hljs-string"><span class="hljs-string">"-"</span></span>): LFsaAppl(T_INE, strNam) {} ~Ine(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bX1, bX2; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bX1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bX2; } };</code> </pre><br><br></div></div>  So sei die Implementierung des Ereignismodells des NAND-Elements im Rahmen der Qt-Automatenklassen ‚ÄûHausaufgabe‚Äú f√ºr die Habrovaner.  Ich kann ihre Entscheidung in Stateflow nur als ‚ÄûKirsche auf dem Kuchen‚Äú bezeichnen.  Es ist in Abb. 2 dargestellt.  5. Hier wird das Stateflow-Relief verwendet, mit dem der √úbergang nicht mit einem Ereignis markiert werden kann: Wenn der Ereignisname nicht angegeben wird, erfolgt der √úbergang, wenn ein Ereignis eintritt (ein Beispiel finden Sie in der √úbergangsbezeichnung in [13]). <br><br><img src="https://habrastorage.org/webt/_9/j7/4e/_9j74efmsk0ema7itfdezvpmfca.jpeg" alt="Bild"><br>  <i>Abb.</i>  <i>5. Ein Automatenmodell eines AND-NOT-Elements in Stateflow</i> <br><br>  Zustandsmaschinen sind also ein hybrides (Aktiv-Passiv-) Modell einer Maschine.  Es ist zwar nicht klar, wie sich die Maschine verh√§lt, wenn √ºberhaupt keine Ereignisse eintreten.  Es ist davon auszugehen, dass es in Erwartung von Ereignissen ‚Äûeinfriert‚Äú.  Und wenn nicht?  Das hei√üt  Am Ende ist es wahrscheinlich eher ein passives als ein aktives Maschinenmodell.  Obwohl nur im Aussehen, ist es schwierig, sich von letzteren zu unterscheiden. <br><br><h3>  5. Fazit </h3><br>  In Bezug auf Ereignisse kann man sagen, dass die Implementierung des klassischen Automatenmodells aufgrund der Aktivit√§t dem Modell synchroner Automaten vorzuziehen ist.  Wenn wir allgemein von automatischer Programmierung sprechen, zeigt das Stateflow-Erweiterungspaket, was f√ºr eine v√∂llig andere Art der Programmierung sein kann.  Aber leider bisher nur perspektivisch, weil  Probleme bleiben aufgrund des Stateflow-Rechenmodells, das im Wesentlichen ein Blockdiagramm bleibt.  Genau aus diesen Gr√ºnden wird die visuelle Programmierung in Statefow zusammen mit den Automaten durch die Notation von Flussdiagrammen dargestellt. <br><br>  Herauszufinden, wo die echte automatische Programmierung ist und wo ihre Nachahmung ist, ist eines unserer Hauptziele.  Im vorigen Artikel [5] haben wir eine der grundlegenden Aufgaben gel√∂st - wir haben das Konzept der Automatenprogramme formuliert.  Als n√§chstes m√ºssen Sie sich mit der Definition eines Programmverwaltungsmodells befassen, das endlich automatisiert und f√ºr Programmierer effektiv und bequem sein sollte. <br><br>  Nachdem wir uns mit den Ereignissen befasst hatten, legten wir den Grundstein f√ºr diese Arbeit.  In weiteren Artikeln werden wir bereits die Details des von D. Harel vorgeschlagenen Modells verstehen.  Wir sagen, dass sie, wenn sie ein wenig voraus l√§uft, das Verst√§ndnis von Automaten verzerrt hat.  Auf der anderen Seite hat sie Probleme aufgedeckt, die es ohne sie nicht erlauben w√ºrden, eine effektive automatische Programmierung im Rahmen des klassischen Modells zu bilden, die Programmierer anziehen w√ºrde. <br><br>  Wir haben oben herausgefunden, dass zumindest auf der Ereignisebene klassische Automaten keine Probleme haben.  Wir werden weiter verstehen ... In der Zwischenzeit ist dies nur der Anfang.  Wir warten auf viele interessante Dinge und gehen nicht √ºber die klassische Theorie der Automaten hinaus.  Dies ist entscheidend, wenn wir eine wirklich automatisierte Programmierung w√ºnschen.  Wir w√ºnschen Ihnen viel Erfolg!  :) <br><br><h3>  Referenzliste </h3><br>  1. Borovsky A.N.  Qt4.7.  Praktische C ++ Programmierung.  - SPb .: BHV-Petersburg, 2012 .-- 496 p. <br>  2. Buch G., RAMBO J., Jacobson I. UML.  Benutzerhandbuch.  Zweite Auflage.  Akademiya IT: Moskau, 2007 .-- 493 p. <br>  3. Shalyto A. A. Eine neue Vorlesung √ºber automatische Programmierung.  2019, [Elektronische Ressource], Zugriffsmodus: <a href="https://www.youtube.com/watch%3Fv%3DPPWTxceMutk%26feature%3Dyoutu.be" rel="nofollow">www.youtube.com/watch?v=PPWTxceMutk&amp;feature=youtu.be</a> , kostenlos.  Yaz.  Russisch  (Datum der Behandlung 5. Dezember 2019). <br>  4. Stateflow.  <a href="https://www.mathworks.com/products/stateflow.html" rel="nofollow">www.mathworks.com/products/stateflow.html</a> , kostenlos.  Yaz.  Englisch  (Ausgabetag 7.01.2020). <br>  5. Turing-Maschine als Modell von Automatenprogrammen.  <a href="https://habr.com/ru/post/481998/">habr.com/de/post/481998</a> , kostenlos.  Yaz.  Russisch  (Ausgabetag 7.01.2020). <br>  6. Melikhov A.N.  Orientierte Graphen und Zustandsautomaten.  - M .: Nauka, 1971. - 416 p. <br>  7. KUDRYAVTSEV VB, Aleshin S.V., PODKOLZIN A.S.  Einf√ºhrung in die Theorie der Automaten - M .: Wissenschaft.  Ch.  ed.  Phys.-Math.  Lit. 1985 .-- 320 p. <br>  8. Tukkel N. I., Shalyto A.A.  Implementierung von Automaten bei der Programmierung von Ereignissystemen.  "Programmer", 2002. Nr. 4.  C.74-80. <br>  9. Polikarpova N., A. Shalyto A. Automatisierung.  2nd ed., St. Petersburg.: Peter, 2011 .-- 176 p. <br>  10. Rambo J., Jacobson A., Butch G. UML: spezielle Referenz.  - St. Petersburg: Peter, 2002 .-- 656 p. <br>  11. Goma H. ‚Äã‚ÄãUML.  Entwurf von Echtzeitsystemen, parallelen und verteilten Anwendungen: Per.  aus dem Englischen  - M .: DMK Press, 2002. - 2002. - 704 p. <br>  12. SHALYTO A.A.  SWITCH-Technologie.  Algorithmus und Programmierung von Logiksteuerungsaufgaben.  St. Petersburg: Nauka, 1998.628 s. <br>  13. Rogachev G.N.  Stateflow-Notationen.  <a href="http://bourabai.kz/cm/stateflow13.htm" rel="nofollow">bourabai.kz/cm/stateflow13.htm</a> , kostenlos.  Yaz.  Russisch  (Datum der Beschwerde 01.10.2020). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483610/">https://habr.com/ru/post/de483610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483598/index.html">Noch musikalischer Ostereier: Wir sprechen weiterhin √ºber Geschenke f√ºr aufmerksame Zuh√∂rer</a></li>
<li><a href="../de483600/index.html">Befreie dein Android</a></li>
<li><a href="../de483602/index.html">DefCon 27-Konferenz: Hinter den Kulissen der Erstellung elektronischer Ausweise Teil 2</a></li>
<li><a href="../de483604/index.html">Iridium: Empfang und Dekodierung von Satellitenkonstellationssignalen zu Hause</a></li>
<li><a href="../de483608/index.html">Visualisierung der Grenzen einer bildbasierten Klassifikatorl√∂sung</a></li>
<li><a href="../de483612/index.html">Tesla-Fahrer wegen Z√§hneputzens im Autopiloten bestraft</a></li>
<li><a href="../de483614/index.html">Methoden zur Bek√§mpfung von Diebstahl in einem Robotikclub</a></li>
<li><a href="../de483616/index.html">Lacmus-Projekt: Wie Computer Vision hilft, verlorene Menschen zu retten</a></li>
<li><a href="../de483624/index.html">Wettbewerb von Yandex.Taxi: Analyse des Backend-Tracks der Programmiermeisterschaft</a></li>
<li><a href="../de483626/index.html">Wie man einen 100-Gitlab-Job in 100 Zeilen auf Jsonnet beschreibt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>