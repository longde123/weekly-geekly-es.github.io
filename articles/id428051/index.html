<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âŒ¨ï¸ ğŸŒ„ ğŸŒ“ Cara membuat lebih banyak status tidak valid bahkan lebih tak terkatakan ğŸ“» ğŸ‘²ğŸ» â™‘ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Belum lama berselang, sebuah artikel diterjemahkan di Habr tentang cara menggunakan tipe data aljabar untuk memastikan bahwa kondisi yang salah tidak ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara membuat lebih banyak status tidak valid bahkan lebih tak terkatakan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428051/"><p>  Belum lama berselang, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel diterjemahkan</a> di Habr tentang cara menggunakan tipe data aljabar untuk memastikan bahwa kondisi yang salah tidak dapat diekspresikan.  Hari ini kita melihat cara yang sedikit lebih umum, scalable dan aman untuk mengekspresikan yang tak terungkapkan, dan Haskell akan membantu kita dalam hal ini. </p><a name="habracut"></a><br><p> Singkatnya, artikel itu membahas beberapa entitas dengan alamat surat dan alamat email, serta dengan syarat tambahan bahwa harus ada setidaknya salah satu dari alamat ini.  Bagaimana cara diusulkan untuk mengekspresikan kondisi ini pada level tipe?  Diusulkan untuk menulis alamat sebagai berikut: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ContactInfo = | EmailOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo | PostOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> PostalContactInfo | EmailAndPost <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo * PostalContactInfo</code> </pre> <br><p>  Masalah apa yang dimiliki pendekatan ini? </p><br><p>  Yang paling jelas (dan dicatat beberapa kali dalam komentar pada artikel itu) adalah bahwa pendekatan ini sama sekali tidak dapat diskalakan.  Bayangkan kita tidak memiliki dua jenis alamat, tetapi tiga atau lima, dan kondisi yang benar terlihat seperti "harus ada alamat surat, atau alamat email dan alamat kantor, dan seharusnya tidak ada beberapa alamat dengan jenis yang sama".  Mereka yang ingin dapat menulis jenis yang sesuai sebagai latihan untuk menguji diri.  Tugas dengan tanda bintang adalah untuk menulis ulang jenis ini dalam kasus ketika kondisi tentang tidak adanya duplikat telah hilang dari TOR. </p><br><h3>  Bagikan </h3><br><p>  Bagaimana cara mengatasi masalah ini?  Mari kita coba berfantasi.  Pertama-tama kami menguraikan dan memisahkan kelas alamat (misalnya, surat / email / nomor meja di kantor) dan konten yang sesuai dengan kelas ini: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Kami belum akan memikirkan kontennya, karena tidak ada apa-apa tentang hal itu dalam kerangka referensi untuk validitas daftar alamat. </p><br><p>  Jika kita memeriksa kondisi yang sesuai dalam runtime beberapa konstruktor dari beberapa bahasa OOP biasa, maka kita hanya akan menulis fungsi seperti </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">valid</span></span> :: [<span class="hljs-type"><span class="hljs-type">AddrType</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> valid xs = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasNoDups = nub xs == xs <span class="hljs-comment"><span class="hljs-comment">--      hasPost = Post `elem` xs hasEmail = Email `elem` xs hasOffice = Office `elem` xs in hasNoDups &amp;&amp; (hasPost || (hasEmail &amp;&amp; hasOffice))</span></span></code> </pre> <br><p>  dan akan membuang beberapa eksekusi jika mengembalikan <code>False</code> . </p><br><p>  Bisakah kita memeriksa kondisi yang sama dengan bantuan pengatur waktu, saat kompilasi?  Ternyata ya, kita bisa, jika jenis sistem bahasanya cukup ekspresif, dan sisa artikel kita akan memilih pendekatan ini. </p><br><p>  Di sini tipe dependen akan banyak membantu kita, dan karena cara paling memadai untuk menulis kode yang divalidasi di Haskell adalah dengan menuliskannya di Agde atau Idris terlebih dahulu, kita akan mengganti sepatu kita dan menulis di Idris.  Sintaks idris cukup dekat dengan Haskell: misalnya, dengan fungsi yang disebutkan di atas, Anda hanya perlu sedikit mengubah tanda tangan: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> : List AddrType -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span></code> </pre> <br><p>  Sekarang ingat bahwa selain kelas-kelas alamat, kita juga membutuhkan isinya, dan menyandikan ketergantungan bidang pada kelas alamat sebagai GADT: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PostFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">city</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">street</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OfficeFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">floor</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">desk</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Yaitu, jika kita diberi nilai <code>fields</code> tipe <code>AddrFields t</code> , maka kita tahu bahwa <code>t</code> adalah beberapa <code>AddrType</code> AddrType dan <code>fields</code> berisi kumpulan bidang yang sesuai dengan kelas khusus ini. </p><br><div class="spoiler">  <b class="spoiler_title">Tentang pos ini</b> <div class="spoiler_text"><p>  Ini bukan pengkodean yang paling aman, karena GADT tidak harus injeksi, dan akan lebih tepat untuk mendeklarasikan tiga tipe data terpisah <code>PostFields</code> , <code>EmailFields</code> , <code>OfficeFields</code> , dan menulis fungsi. </p><br><pre> <code class="hljs pgsql">addrFields : AddrType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> addrFields Post = PostFields addrFields Email = EmailFields addrFields Office = OfficeFields</code> </pre> <br><p>  tetapi ini terlalu banyak menulis, yang untuk prototipe tidak memberikan keuntungan yang signifikan, dan dalam Haskell untuk ini masih ada mekanisme yang lebih ringkas dan menyenangkan. </p></div></div><br><p>  Apa alamat lengkap dalam model ini?  Ini adalah sepasang kelas alamat dan bidang terkait: </p><br><pre> <code class="hljs pgsql">Addr : <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> Addr = (t : AddrType ** AddrFields t)</code> </pre> <br><p>  Penggemar teori tipe akan mengatakan bahwa ini adalah tipe dependen eksistensial: jika kita diberi nilai tipe <code>Addr</code> , maka ini berarti bahwa ada nilai <code>t</code> tipe <code>AddrType</code> dan seperangkat bidang <code>AddrFields t</code> sesuai.  Secara alami, alamat dari kelas yang berbeda memiliki tipe yang sama: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (Email ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (Office ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Selain itu, jika <code>EmailFields</code> diberikan kepada kami, maka satu-satunya kelas alamat yang cocok adalah <code>Email</code> , sehingga Anda dapat menghilangkannya, timer akan mencetaknya sendiri: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (_ ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (_ ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Kami menulis fungsi bantu yang memberikan daftar kelas alamat yang sesuai dari daftar alamat, dan segera menggeneralisasikannya untuk bekerja pada functor yang berubah-ubah: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">types</span></span> : Functor f =&gt; f Addr -&gt; f AddrType <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = map fst</code> </pre> <br><p>  Di sini, tipe <code>Addr</code> eksistensial berperilaku seperti pasangan yang akrab: khususnya, Anda dapat meminta komponen <code>AddrType</code> (tugas dengan tanda bintang: mengapa saya tidak bisa meminta komponen kedua?). </p><br><h4>  Angkat </h4><br><p>  Sekarang kita beralih ke bagian kunci dari cerita kita.  Jadi, kami memiliki daftar alamat <code>List Addr</code> dan beberapa predikat yang <code>valid : List AddrType -&gt; Bool</code> , yang pelaksanaannya untuk daftar ini kami ingin menjamin pada tingkat jenis.  Bagaimana kita menggabungkannya?  Tentu saja, tipe lain! </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Sekarang kita akan menganalisis apa yang kita tulis di sini. </p><br><p>  <code>data ValidatedAddrList : List Addr -&gt; Type where</code> berarti bahwa jenis <code>ValidatedAddrList</code> parameter, pada kenyataannya, oleh daftar alamat. </p><br><p>  Mari kita lihat tanda tangan dari satu-satunya konstruktor <code>MkValidatedAddrList</code> dari tipe ini: <code>(lst : List Addr) -&gt; (prf : valid (types lst) = True) -&gt; ValidatedAddrList lst</code> .  Artinya, dibutuhkan beberapa daftar alamat <code>lst</code> dan argumen lain dari tipe <code>valid (types lst) = True</code> .  Apa arti tipe ini?  Jadi itu berarti bahwa nilai di sebelah kiri <code>=</code> sama dengan nilai di sebelah kanan <code>=</code> , yaitu, <code>valid (types lst)</code> , pada kenyataannya, adalah Benar. </p><br><p>  Bagaimana cara kerjanya?  Tanda tangan <code>=</code> seperti <code>(x : A) -&gt; (y : B) -&gt; Type</code> .  Yaitu, <code>=</code> mengambil dua nilai arbitrer <code>x</code> dan <code>y</code> (mungkin bahkan dari tipe <code>A</code> dan <code>B</code> , yang berarti bahwa ketidaksetaraan dalam idris heterogen, dan agak ambigu dari sudut pandang teori jenis, tetapi ini adalah topik untuk diskusi lain).  Apa yang kemudian menunjukkan kesetaraan?  Dan karena fakta bahwa satu-satunya konstruktor <code>=</code> - <code>Refl</code> dengan tanda tangan <em>hampir</em> <code>(x : A) -&gt; x = x</code> .  Artinya, jika kita memiliki nilai tipe <code>x = y</code> , maka kita tahu bahwa itu dibangun menggunakan <code>Refl</code> (karena tidak ada konstruktor lain), yang berarti <code>x</code> sebenarnya sama dengan <code>y</code> . </p><br><p>  Perhatikan bahwa inilah mengapa dalam Haskell kita akan selalu berpura-pura bahwa kita sedang membuktikan sesuatu, karena Haskell telah <code>undefined</code> yang mendiami tipe apa pun, sehingga argumen di atas tidak bekerja di sana: untuk <code>x</code> , <code>y</code> istilah apa pun dari tipe <code>x = y</code> dapat dibuat melalui <code>undefined</code> (atau melalui rekursi tak terbatas, katakan bahwa pada umumnya sama dalam hal teori tipe). </p><br><p>  Kami juga mencatat bahwa persamaan di sini tidak dimaksudkan dalam arti Haskell's <code>Eq</code> atau <code>operator==</code> dalam C ++, tetapi secara substansial lebih ketat: struktural, yang, menyederhanakan, berarti bahwa kedua nilai memiliki <em>bentuk yang</em> sama.  Yaitu, untuk menipu dia sehingga tidak berfungsi.  Tetapi masalah kesetaraan secara tradisional ditarik ke artikel terpisah. </p><br><p>  Untuk mengkonsolidasikan pemahaman kita tentang kesetaraan, kami menulis unit test untuk fungsi yang <code>valid</code> : </p><br><pre> <code class="hljs powershell">testPostValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>] = True testPostValid = Refl testEmptyInvalid : valid [] = False testEmptyInvalid = Refl testDupsInvalid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Post</span></span>] = False testDupsInvalid = Refl testPostEmailValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Email</span></span>] = True testPostEmailValid = Refl</code> </pre> <br><p>  Tes-tes ini bagus karena Anda bahkan tidak perlu menjalankannya, sudah cukup bahwa taypcher memeriksanya.  Memang, mari kita ganti <code>True</code> dengan <code>False</code> , misalnya, di bagian paling pertama dari mereka dan lihat apa yang terjadi: </p><br><pre> <code class="hljs pgsql">testPostValid : <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> [Post] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> testPostValid = Refl</code> </pre> <br><p>  Typsekher bersumpah </p><br><p><img src="https://habrastorage.org/webt/l7/to/xm/l7toxmndt6lzzbpmjersntiujfg.png"></p><br><p>  seperti yang diharapkan.  Bagus </p><br><h4>  Sederhanakan </h4><br><p>  Sekarang mari kita refactor sedikit <code>ValidatedAddrList</code> kami. </p><br><p>  Pertama, pola membandingkan nilai tertentu dengan <code>True</code> sangat umum, jadi ada tipe khusus <code>So</code> dalam idris untuk ini: Anda dapat mengambil <code>So x</code> sebagai sinonim untuk <code>x = True</code> .  Mari kita perbaiki definisi <code>ValidatedAddrList</code> : </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Selain itu, <code>So</code> memiliki fungsi bantu yang nyaman <code>choose</code> , yang pada dasarnya meningkatkan pemeriksaan ke tingkat jenis: </p><br><pre> <code class="hljs pgsql">&gt; :doc choose Data.So.choose : (b : <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; Either (So b) (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> b)) <span class="hljs-keyword"><span class="hljs-keyword">Perform</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> analysis <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> a <span class="hljs-type"><span class="hljs-type">Boolean</span></span>, providing clients <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a So proof</code> </pre> <br><p>  Ini akan berguna bagi kita ketika kita menulis fungsi yang memodifikasi tipe ini. </p><br><p>  Kedua, kadang-kadang (terutama dalam pengembangan interaktif) idris dapat menemukan nilai <code>prf</code> sesuai sendiri.  Agar dalam kasus seperti itu tidak perlu membuatnya dengan tangan, ada gula sintaksis yang sesuai: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)} -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Kurung keriting berarti bahwa ini adalah argumen implisit bahwa idris akan mencoba menarik keluar dari konteks, dan <code>auto</code> berarti bahwa ia juga akan mencoba untuk membangunnya sendiri. </p><br><p>  Jadi, apa yang diberikan <code>ValidatedAddrList</code> baru ini kepada kami?  Dan itu memberikan rantai penalaran seperti itu: biarkan <code>val</code> menjadi nilai bertipe <code>ValidatedAddrList lst</code> .  Ini berarti bahwa <code>lst</code> adalah daftar alamat, dan di samping itu, <code>val</code> dibuat menggunakan konstruktor <code>MkValidatedAddrList</code> , yang kami lewati ini dulu dan nilai <code>prf</code> lain dari tipe <code>So (valid $ types lst)</code> , yang hampir <code>valid (types lst) = True</code> .  Dan agar kita dapat membangun <code>prf</code> , kita perlu, pada kenyataannya, untuk membuktikan bahwa kesetaraan ini berlaku. </p><br><p>  Dan hal yang paling indah adalah bahwa ini semua diperiksa oleh tympher.  Ya, pemeriksaan validitas harus dilakukan dalam runtime (karena alamat dapat dibaca dari file atau dari jaringan), tetapi timer akan memastikan bahwa pemeriksaan ini dilakukan: tanpa itu, tidak mungkin membuat <code>ValidatedAddrList</code> .  Setidaknya di idris.  Di Haskell, sayang. </p><br><h4>  Masukkan </h4><br><p>  Untuk memverifikasi verifikasi yang tidak terhindarkan, coba tulis fungsi untuk menambahkan alamat ke daftar.  Upaya pertama: </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) insert addr (MkValidatedAddrList lst) = MkValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Tidak, kesalahan ketik memberi pada jari (meskipun tidak terlalu mudah dibaca, biaya <code>valid</code> terlalu rumit): </p><br><p><img src="https://habrastorage.org/webt/au/oa/6j/auoa6jeo10ucav7rffetqmvylec.png"></p><br><p>  Bagaimana kita mendapatkan salinan dari <code>So</code> ini?  Tidak ada yang lain selain <code>choose</code> disebutkan di atas.  Upaya kedua: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; ?rhs</code> </pre> <br><p>  Hampir typechetsya.  "Hampir" karena tidak jelas apa yang harus diganti dengan <code>rhs</code> .  Sebaliknya, jelas: dalam hal ini, fungsi tersebut entah bagaimana harus melaporkan kesalahan.  Jadi, Anda perlu mengubah tanda tangan dan membungkus nilai kembali, misalnya, di <code>Maybe</code> : </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; Just $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Ini ubin dan berfungsi sebagaimana mestinya. </p><br><p>  Tetapi sekarang muncul masalah yang tidak terlalu jelas berikut ini, yang sebenarnya, dalam artikel aslinya.  Jenis fungsi ini tidak berhenti menulis implementasi seperti itu: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Artinya, kami selalu mengatakan bahwa kami tidak dapat membangun daftar alamat baru.  Typhechaetsya?  Ya  Apakah benar  Yah, hampir tidak.  Bisakah ini dihindari? </p><br><p>  Ternyata itu mungkin, dan kami memiliki semua alat yang diperlukan untuk ini.  Jika berhasil, <code>insert</code> mengembalikan <code>ValidatedAddrList</code> , yang berisi bukti keberhasilan ini.  Jadi tambahkan simetri elegan dan minta fungsi untuk mengembalikan juga bukti kegagalan! </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Either (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> $ valid $ types (addr :: lst))) (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> r</code> </pre> <br><p>  Sekarang kita tidak bisa mengambil dan selalu mengembalikan <code>Nothing</code> . </p><br><p>  Anda dapat melakukan hal yang sama untuk fungsi penghapusan alamat dan sejenisnya. </p><br><p>  Mari kita lihat bagaimana hasilnya pada akhirnya. </p><br><p>  Mari kita coba membuat daftar alamat kosong: </p><br><p><img src="https://habrastorage.org/webt/9l/pf/a_/9lpfa_ytfrgfsvxbvy4lkk0a8uy.png"></p><br><p>  Tidak mungkin, daftar kosong tidak valid. </p><br><p>  Bagaimana dengan daftar alamat surat saja? </p><br><p><img src="https://habrastorage.org/webt/au/d2/jq/aud2jqe2malfgrjg2txzsncdom4.png"></p><br><p>  Oke, mari kita coba memasukkan alamat surat ke dalam daftar yang sudah memiliki alamat surat: </p><br><p><img src="https://habrastorage.org/webt/xl/cx/ri/xlcxrimioc_dutfysgtdmr2srmc.png"></p><br><p>  Mari kita coba memasukkan email: </p><br><p><img src="https://habrastorage.org/webt/sn/1n/zw/sn1nzwqz5erm1vjnq59dkel3zzi.png"></p><br><p>  Pada akhirnya, semuanya bekerja persis seperti yang diharapkan. </p><br><p>  Fiuh.  Saya pikir itu akan menjadi tiga baris, tetapi ternyata sedikit lebih lama.  Jadi untuk mengeksplorasi sejauh mana kita bisa pergi di Haskell, kita akan berada di artikel selanjutnya.  Sementara itu, sedikit </p><br><h4>  Renungkan </h4><br><p>  Apa, pada akhirnya, keuntungan dari keputusan seperti itu dibandingkan dengan yang diberikan dalam artikel, yang kami rujuk di awal? </p><br><ol><li>  Sekali lagi, ini jauh lebih bisa diukur.  Fungsi validasi kompleks lebih mudah ditulis. </li><li>  Itu lebih terisolasi.  Kode klien tidak harus tahu apa yang ada di dalam fungsi validasi, sedangkan formulir <code>ContactInfo</code> dari artikel asli mengharuskannya untuk diikat. </li><li>  Logika validasi ditulis dalam bentuk fungsi biasa dan akrab, sehingga dapat segera diperiksa dengan bacaan yang bijaksana dan diuji dengan tes waktu kompilasi, daripada memperoleh makna validasi dari bentuk tipe data yang mewakili hasil yang sudah diverifikasi. </li><li>  Menjadi mungkin untuk menentukan lebih akurat perilaku fungsi yang bekerja dengan tipe data yang menarik bagi kami, terutama dalam kasus kegagalan untuk lulus tes.  Misalnya, <code>insert</code> ditulis sebagai hasilnya tidak mungkin ditulis secara <em>salah</em> .  Demikian pula, orang dapat menulis <code>insertOrReplace</code> , <code>insertOrIgnore</code> dan sejenisnya, yang perilakunya sepenuhnya ditentukan dalam tipe. </li></ol><br><p>  Apa untungnya dibandingkan dengan solusi OOP seperti itu? </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ValidatedAddrListClass</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">ValidatedAddrListClass</span></span>(std::vector&lt;Addr&gt; addrs) { if (!<span class="hljs-built_in"><span class="hljs-built_in">valid</span></span>(addrs)) throw ValidationError {}; } };</code> </pre> <br><ol><li>  Kode lebih termodulasi dan aman.  Dalam kasus di atas, cek adalah <em>tindakan</em> yang diperiksa sekali, dan tentang hal itu mereka kemudian lupa.  Semuanya didasarkan pada kejujuran dan pemahaman bahwa jika Anda memiliki <code>ValidatedAddrListClass</code> , maka implementasinya pernah melakukan pemeriksaan di sana.  Fakta cek ini dari kelas tidak dapat dipilih sebagai nilai tertentu.  Dalam hal <em>nilai dari</em> beberapa tipe, nilai ini dapat ditransfer antara bagian-bagian berbeda dari program, digunakan untuk membangun nilai yang lebih kompleks (misalnya, sekali lagi, tolak pemeriksaan ini), selidiki (lihat paragraf berikutnya), dan umumnya melakukan hal yang sama seperti yang biasa kita lakukan dengan nilai-nilai. </li><li>  Pemeriksaan semacam itu dapat digunakan dalam pencocokan pola (tergantung).  Benar, tidak dalam kasus fungsi ini <code>valid</code> dan tidak dalam kasus idris, itu sangat rumit, dan idris sangat membosankan sehingga informasi yang berguna untuk pola dapat diekstraksi dari struktur yang <code>valid</code> .  Meskipun demikian, <code>valid</code> dapat ditulis ulang dengan gaya pencocokan pola yang sedikit lebih ramah, tetapi ini berada di luar cakupan artikel ini dan umumnya tidak sepele. </li></ol><br><p>  Apa kerugiannya? </p><br><p>  Saya hanya melihat satu kelemahan mendasar yang serius: <code>valid</code> adalah fungsi yang terlalu bodoh.  Ini hanya mengembalikan sedikit informasi - apakah data telah lulus validasi atau tidak.  Dalam hal tipe yang lebih pintar, kita bisa mencapai sesuatu yang lebih menarik. </p><br><p>  Misalnya, bayangkan bahwa persyaratan untuk keunikan alamat telah hilang dari TK.  Dalam kasus ini, jelas bahwa menambahkan alamat baru ke daftar alamat yang ada tidak akan membuat daftar tidak valid, sehingga kita dapat <em>membuktikan teorema ini</em> dengan menulis fungsi dengan tipe <code>So (valid $ types lst) -&gt; So (valid $ types $ addr :: lst)</code> , dan menggunakannya, misalnya, untuk menulis tipe-aman selalu berhasil </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Tetapi, sayangnya, teorema seperti rekursi dan induksi, dan masalah kita tidak memiliki struktur induktif yang elegan, oleh karena itu, menurut pendapat saya, kode dengan oak Boolean yang <code>valid</code> juga tidak buruk. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428051/">https://habr.com/ru/post/id428051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428039/index.html">Pemerintah tidak berencana untuk mengadvokasi netralitas jaringan</a></li>
<li><a href="../id428041/index.html">Intisari bahan-bahan segar dari dunia frontend untuk minggu terakhir No. 336 (22 - 28 Oktober 2018)</a></li>
<li><a href="../id428043/index.html">Menunggu keenam, Winamp 5.8: "rahasia" asal, kemungkinan versi resmi</a></li>
<li><a href="../id428045/index.html">PHP Digest No. 142 (15 - 29 Oktober 2018)</a></li>
<li><a href="../id428047/index.html">Analisis kinerja server WSGI: pasang kembali uWSGI</a></li>
<li><a href="../id428053/index.html">Cara membuat strategi pengujian: versi insinyur nyata</a></li>
<li><a href="../id428055/index.html">Retrospektif dari startup teknologi. Z3 - komputer relay pertama</a></li>
<li><a href="../id428057/index.html">Pandangan baru mendokumentasikan API dan SDK di Yandex. Ceramah tentang Hyperbaton</a></li>
<li><a href="../id428059/index.html">Hubungkan Penyimpanan Multipath LUN ke VMware ESXi dan Debian GNU / Linux</a></li>
<li><a href="../id428061/index.html">Mengelola Biaya Proyek dengan Manajemen Nilai yang Diperoleh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>