<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíå üÄÑÔ∏è ‚òùüèº Crie um sombreador de √°gua de desenho animado para a web. Parte 2 üë©üèª‚Äçüî¨ ü§≤üèª üôç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na primeira parte, vimos como configurar o ambiente e a superf√≠cie da √°gua. Nesta parte, daremos flutuabilidade aos objetos, adicionaremos linhas de √°...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crie um sombreador de √°gua de desenho animado para a web. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416983/"> Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte,</a> vimos como configurar o ambiente e a superf√≠cie da √°gua.  Nesta parte, daremos flutuabilidade aos objetos, adicionaremos linhas de √°gua na superf√≠cie e criaremos linhas de espuma com um buffer de profundidade em torno dos limites dos objetos que se cruzam com a superf√≠cie. <br><br>  Para fazer a cena parecer um pouco melhor, fiz pequenas altera√ß√µes.  Voc√™ pode personalizar sua cena da maneira que quiser, mas eu fiz o seguinte: <br><br><ul><li>  Modelos adicionados de um farol e um polvo. </li><li> Adicionado um modelo de solo com a cor <code>#FFA457</code> . </li><li>  Adicionada uma cor do c√©u de <code>#6CC8FF</code> . </li><li>  Adicionada cor de luz de fundo <code>#FFC480</code> √† cena (esses par√¢metros podem ser encontrados nas configura√ß√µes de cena). </li></ul><br>  Minha cena original agora se parece com isso. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/2fa/0d5/bc22fa0d57b5120e75cced6f105bebd2.png"></div><a name="habracut"></a><br><h2>  Flutuabilidade </h2><br>  A maneira mais f√°cil de criar flutuabilidade √© usar um script para empurrar objetos para cima e para baixo.  Crie um novo script <strong>Buoyancy.js</strong> e defina o seguinte em sua inicializa√ß√£o: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getPosition().clone(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialRotation = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getEulerAngles().clone(); <span class="hljs-comment"><span class="hljs-comment">//     ,  //        //     this.time = Math.random() * 2 * Math.PI; };</span></span></code> </pre> <br>  Agora, na atualiza√ß√£o, executamos o incremento de tempo e giramos o objeto: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      var pos = this.entity.getPosition().clone(); pos.y = this.initialPosition.y + Math.cos(this.time) * 0.07; this.entity.setPosition(pos.x,pos.y,pos.z); //    var rot = this.entity.getEulerAngles().clone(); rot.x = this.initialRotation.x + Math.cos(this.time * 0.25) * 1; rot.z = this.initialRotation.z + Math.sin(this.time * 0.5) * 2; this.entity.setLocalEulerAngles(rot.x,rot.y,rot.z); };</span></span></code> </pre> <br>  Aplique esse script ao barco e veja como ele pula para cima e para baixo na √°gua!  Voc√™ pode aplicar esse script a v√°rios objetos (incluindo a c√¢mera - experimente)! <br><br><h2>  Textura da superf√≠cie </h2><br>  Enquanto podemos ver as ondas, olhamos para as bordas da superf√≠cie da √°gua.  A adi√ß√£o de textura tornar√° o movimento da superf√≠cie mais percept√≠vel.  Al√©m disso, √© uma maneira de baixo custo para simular reflex√µes e c√°usticos. <br><br>  Voc√™ pode tentar encontrar algumas texturas c√°usticas ou criar uma voc√™ mesmo.  Eu desenhei <a href="" rel="external">uma textura</a> no Gimp que voc√™ pode usar livremente.  Qualquer textura √© adequada, desde que possa ser ladrilhada sem juntas percept√≠veis. <br><br>  Depois de escolher a textura desejada, arraste-a para a janela Ativos do seu projeto.  Precisamos fazer refer√™ncia a essa textura a partir do script Water.js, ent√£o vamos criar um atributo para ela: <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'surfaceTexture'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'texture'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Surface Texture'</span></span> });</code> </pre> <br>  E, em seguida, atribua-o no editor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/672/61e/32f/67261e32f145eda9dab99d1866181ced.png"></div><br>  Agora precisamos passar para o shader.  Acesse <strong>Water.js</strong> e defina a fun√ß√£o <code>CreateWaterMaterial</code> novo par√¢metro: <br><br><pre> <code class="javascript hljs">material.setParameter(<span class="hljs-string"><span class="hljs-string">'uSurfaceTexture'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.surfaceTexture.resource);</code> </pre> <br>  Agora volte para <strong>Water.frag</strong> e declare um novo uniforme: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture;</code> </pre> <br>  Estamos quase terminando.  Para renderizar uma textura em um plano, precisamos saber onde cada pixel est√° na malha.  Ou seja, precisamos transferir dados do sombreador de v√©rtice para o fragmento. <br><br><h3>  Vari√°veis ‚Äã‚ÄãVari√°veis </h3><br>  <em>Vari√°veis</em> vari√°veis ‚Äã‚Äãpermitem transferir dados do sombreador de v√©rtice para o fragmento.  Este √© o terceiro tipo de vari√°veis ‚Äã‚Äãespeciais que podem ser usadas no shader (as duas primeiras s√£o <em>uniformes</em> e <em>atributo</em> ).  Uma vari√°vel √© definida para cada v√©rtice e cada pixel pode acess√°-lo.  Como h√° muito mais pixels do que v√©rtices, o valor √© interpolado entre os v√©rtices (da√≠ o nome ‚Äúvariando‚Äù - ele se desvia dos valores passados ‚Äã‚Äãpara ele). <br><br>  Para test√°-lo em opera√ß√£o, declare uma nova vari√°vel em <strong>Water.vert</strong> como vari√°vel: <br><br><pre> <code class="javascript hljs">varying vec2 ScreenPosition;</code> </pre> <br>  E, em seguida, atribua o valor <code>gl_Position</code> ap√≥s o c√°lculo: <br><br><pre> <code class="javascript hljs">ScreenPosition = gl_Position.xyz;</code> </pre> <br>  Agora, volte para <strong>Water.frag</strong> e declare a mesma vari√°vel.  N√£o podemos obter a sa√≠da de dados de depura√ß√£o do shader, mas podemos usar cores para depura√ß√£o visual.  Veja como faz√™-lo: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec3 ScreenPosition; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    varying- color = vec4(vec3(ScreenPosition.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  O plano agora deve parecer preto e branco, e a linha de divis√£o de cores ir√° para <code>ScreenPosition.x</code> = 0. Os valores das cores mudam apenas de 0 para 1, mas os valores no <code>ScreenPosition</code> podem estar fora desse intervalo.  Eles s√£o automaticamente limitados; portanto, quando voc√™ v√™ preto, pode ser 0 ou um n√∫mero negativo. <br><br>  O que acabamos de fazer √© passar a posi√ß√£o da tela de cada v√©rtice para cada pixel.  Voc√™ pode ver que a linha que separa os lados preto e branco sempre passar√° no centro da tela, independentemente de onde a superf√≠cie realmente esteja no mundo. <br><br><blockquote>  <em>Tarefa 1: crie uma nova vari√°vel vari√°vel para transferir a posi√ß√£o no mundo em vez da posi√ß√£o na tela.</em>  <em>Visualize-o da mesma maneira.</em>  <em>Se a cor n√£o mudar com o movimento da c√¢mera, tudo ser√° feito corretamente.</em> </blockquote><br><h3>  Usando UV </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">UV</a> s√£o as coordenadas 2D de cada v√©rtice na malha, normalizadas de 0 a 1. Elas s√£o necess√°rias para a amostragem correta da textura no plano e j√° as configuramos na parte anterior. <br><br>  Declararemos um novo atributo em <strong>Water.vert</strong> (esse nome √© obtido da defini√ß√£o de sombreador em Water.js): <br><br><pre> <code class="javascript hljs">attribute vec2 aUv0;</code> </pre> <br>  E agora s√≥ precisamos pass√°-lo para o shader de fragmento, ent√£o basta criar varia√ß√µes e atribuir o valor do atributo a ele: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Water.vert //        varying vec2 vUv0; // .. //        //  varying,        vUv0 = aUv0;</span></span></code> </pre> <br>  Agora declararemos a mesma vari√°vel vari√°vel no shader de fragmento.  Para garantir que tudo funcione, podemos visualizar a depura√ß√£o como antes, e ent√£o o Water.frag ficar√° assim: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  UV color = vec4(vec3(vUv0.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  Voc√™ deve ver um gradiente confirmando que temos um valor de 0 em uma extremidade e 1 na outra.  Agora, para provar a textura de verdade, tudo o que precisamos fazer √©: <br><br><pre> <code class="javascript hljs">color = texture2D(uSurfaceTexture,vUv0);</code> </pre> <br>  Depois disso, veremos a textura na superf√≠cie: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/9bf/ae2/f499bfae266b0aa16709bbea0280df6f.png"></div><br><h3>  Estilo de textura </h3><br>  Em vez de apenas definir a textura como a nova cor, vamos combin√°-la com o azul existente: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec4 WaterLines = texture2D(uSurfaceTexture,vUv0); color.rgba += WaterLines.r; gl_FragColor = color; }</code> </pre> <br>  Isso funciona porque a cor da textura √© preta (0) em todos os lugares, exceto nas linhas de √°gua.  Adicionando-o, n√£o alteramos a cor azul inicial, com exce√ß√£o dos locais com linhas onde ela fica mais clara. <br><br>  No entanto, essa n√£o √© a √∫nica maneira de combinar cores. <br><br><blockquote>  <em>Tarefa 2: Voc√™ pode combinar as cores para obter o efeito mais fraco mostrado abaixo?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/e18/22a/a3de1822a348656f47e5bd6cfa6cbed5.png"></div><br><h3>  Textura em movimento </h3><br>  Como efeito final, queremos que as linhas se movam ao longo da superf√≠cie e ela n√£o pare√ßa t√£o est√°tica.  Para fazer isso, tiraremos vantagem do fato de que qualquer valor fora do intervalo de 0 a 1 passado para a fun√ß√£o <code>texture2D</code> ser√° transferido (por exemplo, 1,5 e 2,5 se tornam iguais a 0,5).  Portanto, podemos aumentar nossa posi√ß√£o pela vari√°vel de tempo uniforme que j√° definimos para aumentar ou diminuir a densidade de linhas na superf√≠cie, o que dar√° ao fragmento final shader esta forma: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; uniform float uTime; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0; <span class="hljs-comment"><span class="hljs-comment">//      1 //     pos *= 2.0; //   ,      pos.y += uTime * 0.02; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r; gl_FragColor = color; }</span></span></code> </pre> <br><h2>  Linhas de espuma e tamp√£o de profundidade </h2><br>  A renderiza√ß√£o de linhas de espuma em torno de objetos na √°gua facilita a visualiza√ß√£o da imers√£o dos objetos e de onde eles cruzam a superf√≠cie.  Al√©m disso, dessa maneira nossa √°gua se torna muito mais cr√≠vel.  Para perceber as linhas de espuma, precisamos descobrir de alguma forma onde est√£o os limites de cada objeto e faz√™-lo efetivamente. <br><br><h3>  Truque </h3><br>  Precisamos aprender a determinar se um pixel na superf√≠cie da √°gua est√° pr√≥ximo ao objeto.  Nesse caso, podemos pint√°-lo na cor da espuma.  N√£o h√° maneiras simples de resolver esse problema (tanto quanto eu sei).  Portanto, para resolv√™-lo, uso uma t√©cnica √∫til para resolver problemas: darei um exemplo para o qual sabemos a resposta e veremos se podemos generaliz√°-la. <br><br>  D√™ uma olhada na imagem abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d0/0e7/eec/4d00e7eec8714a365c110aea67df9fab.png"></div><br>  Quais pixels devem fazer parte da espuma?  Sabemos que deve ser algo como isto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a8/541/c4f/1a8541c4f8fdd65879966b909805c484.png"></div><br>  Ent√£o, vamos olhar para dois pixels espec√≠ficos.  Abaixo os marquei com asteriscos.  O preto estar√° na espuma e o vermelho n√£o.  Como os distinguimos em um sombreador? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/d35/fb2/012d35fb25d42c19a86adaa081048237.png"></div><br>  Sabemos que, embora esses dois pixels no espa√ßo da tela estejam pr√≥ximos um do outro (ambos renderizados no topo do farol), na verdade eles est√£o muito distantes no espa√ßo do mundo.  Podemos verificar isso olhando a mesma cena de um √¢ngulo diferente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd3/5a0/31b/cd35a031bbd18805128ebd44ed1c1279.png"></div><br>  Note que a estrela vermelha n√£o est√° localizada no farol, como nos pareceu, mas a estrela preta est√° realmente l√°.  Podemos distinguir do uso da dist√¢ncia da c√¢mera, que geralmente √© chamada de "profundidade".  A profundidade 1 significa que o ponto est√° muito pr√≥ximo da c√¢mera, a profundidade 0 significa que est√° muito longe.  Mas isso n√£o √© apenas uma quest√£o de dist√¢ncias absolutas no mundo, profundidade ou c√¢mera.  A profundidade <em>relativa ao pixel atr√°s dele √©</em> importante. <br><br>  Olhe novamente para a primeira visualiza√ß√£o.  Digamos que o farol tenha um valor de profundidade de 0,5.  A profundidade da estrela negra ser√° muito pr√≥xima de 0,5.  Ou seja, ele e o pixel abaixo dele t√™m valores de profundidade muito pr√≥ximos.  Por outro lado, o asterisco vermelho ter√° uma profundidade muito maior, porque fica mais perto da c√¢mera, digamos 0,7.  E embora o pixel atr√°s dele ainda esteja no farol, ele tem um valor de profundidade de 0,5, ou seja, h√° mais diferen√ßa. <br><br>  Esse √© o truque.  <em>Quando a profundidade de um pixel na superf√≠cie da √°gua est√° pr√≥xima o suficiente da profundidade do pixel sobre o qual √© desenhada, estamos bem perto da borda de algum objeto</em> e podemos renderiz√°-lo como espuma. <br><br>  Ou seja, precisamos de mais informa√ß√µes do que em qualquer pixel.  De alguma forma, precisamos descobrir a profundidade do pixel sobre o qual ele deve ser desenhado.  E aqui o buffer de profundidade √© √∫til para n√≥s. <br><br><h3>  Buffer de profundidade </h3><br>  Voc√™ pode pensar em um buffer de quadro ou buffer de quadro como uma renderiza√ß√£o ou textura de destino fora da tela.  Quando precisamos ler dados, precisamos renderizar fora da tela.  Esta t√©cnica √© usada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">efeito de fuma√ßa</a> . <br><br>  O buffer de profundidade √© uma renderiza√ß√£o de destino especial que cont√©m informa√ß√µes sobre os valores de profundidade de cada pixel.  N√£o esque√ßa que o valor em <code>gl_Position</code> calculado no sombreador de v√©rtice era o valor do espa√ßo da tela, mas tamb√©m possui uma terceira coordenada - o valor Z. Esse valor Z √© usado para calcular a profundidade, que √© gravada no buffer de profundidade. <br><br>  O buffer de profundidade destina-se √† renderiza√ß√£o correta da cena, sem a necessidade de classificar objetos de tr√°s para frente.  Cada pixel a ser desenhado primeiro verifica o buffer de profundidade.  Se seu valor de profundidade for maior que o valor no buffer, ele ser√° desenhado e seu pr√≥prio valor substituir√° o valor do buffer.  Caso contr√°rio, ele ser√° descartado (porque significa que h√° outro objeto √† sua frente). <br><br>  Na verdade, voc√™ pode desativar a grava√ß√£o no buffer de profundidade para ver como tudo ficaria sem ele.  Vamos tentar fazer isso no Water.js: <br><br><pre> <code class="javascript hljs">material.depthTest = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Voc√™ notar√° que a √°gua ser√° sempre sempre retirada de cima, mesmo que esteja atr√°s de objetos opacos. <br><br><h3>  Visualiza√ß√£o do buffer de profundidade </h3><br>  Vamos adicionar uma maneira de renderizar o buffer de profundidade para fins de depura√ß√£o.  Crie um novo script <strong>DepthVisualize.js</strong> .  Anexe-o √† c√¢mera. <br><br>  Para acessar o buffer de profundidade no PlayCanvas, basta escrever o seguinte: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.camera.camera.requestDepthMap();</code> </pre> <br>  Portanto, injetamos automaticamente a vari√°vel uniforme em todos os nossos shaders, que podemos usar declarando-a da seguinte maneira: <br><br><pre> <code class="javascript hljs">uniform sampler2D uDepthMap;</code> </pre> <br>  Abaixo est√° um exemplo de script solicitando um mapa de profundidade e renderizando-o sobre uma cena.  Ele configurou uma reinicializa√ß√£o a quente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DepthVisualize = pc.createScript(<span class="hljs-string"><span class="hljs-string">'depthVisualize'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  initialize,       DepthVisualize.prototype.initialize = function() { this.entity.camera.camera.requestDepthMap(); this.antiCacheCount = 0; //    ,         this.SetupDepthViz(); }; DepthVisualize.prototype.SetupDepthViz = function(){ var device = this.app.graphicsDevice; var chunks = pc.shaderChunks; this.fs = ''; this.fs += 'varying vec2 vUv0;'; this.fs += 'uniform sampler2D uDepthMap;'; this.fs += ''; this.fs += 'float unpackFloat(vec4 rgbaDepth) {'; this.fs += ' const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);'; this.fs += ' float depth = dot(rgbaDepth, bitShift);'; this.fs += ' return depth;'; this.fs += '}'; this.fs += ''; this.fs += 'void main(void) {'; this.fs += ' float depth = unpackFloat(texture2D(uDepthMap, vUv0)) * 30.0; '; this.fs += ' gl_FragColor = vec4(vec3(depth),1.0);'; this.fs += '}'; this.shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, this.fs, "renderDepth" + this.antiCacheCount); this.antiCacheCount ++; //     ,        this.command = new pc.Command(pc.LAYER_FX, pc.BLEND_NONE, function () { pc.drawQuadWithShader(device, null, this.shader); }.bind(this)); this.command.isDepthViz = true; //    ,      this.app.scene.drawCalls.push(this.command); }; //  update,     DepthVisualize.prototype.update = function(dt) { }; //  swap,      //      DepthVisualize.prototype.swap = function(old) { this.antiCacheCount = old.antiCacheCount; //      for(var i=0;i&lt;this.app.scene.drawCalls.length;i++){ if(this.app.scene.drawCalls[i].isDepthViz){ this.app.scene.drawCalls.splice(i,1); break; } } //    this.SetupDepthViz(); }; //      ,  : // http://developer.playcanvas.com/en/user-manual/scripting/</span></span></code> </pre> <br>  Tente copiar o c√≥digo e comentar / descomentar a linha <code>this.app.scene.drawCalls.push(this.command);</code>  para ativar / desativar a renderiza√ß√£o em profundidade.  Isso deve se parecer com a imagem abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c09/93a/c4f/c0993ac4f8ed7a4c739658bbff69e455.png"></div><br><blockquote>  <em>Tarefa 3: a superf√≠cie da √°gua n√£o √© atra√≠da para o buffer de profundidade.</em>  <em>O mecanismo PlayCanvas faz isso de prop√≥sito.</em>  <em>Voc√™ pode descobrir o porqu√™?</em>  <em>O que h√° de especial no material da √°gua?</em>  <em>Em outras palavras, dadas nossas regras para verificar profundidades, o que aconteceria se pixels de √°gua fossem gravados no buffer de profundidade?</em> </blockquote><br>  <em>Dica: Voc√™ pode alterar uma linha no Water.js, que permite gravar √°gua no buffer de profundidade.</em> <br><br>  Deve-se notar tamb√©m que, na fun√ß√£o de inicializa√ß√£o, multiplico o valor da profundidade por 30. Isso √© necess√°rio para ver claramente, pois, caso contr√°rio, o intervalo de valores seria muito pequeno para exibir tons de cores. <br><br><h3>  Implementa√ß√£o de truques </h3><br>  Existem v√°rias fun√ß√µes auxiliares no mecanismo PlayCanvas para trabalhar com valores de profundidade, mas, no momento da reda√ß√£o, eles n√£o foram liberados na produ√ß√£o, portanto teremos que configur√°-los n√≥s mesmos. <br><br>  <strong>Definimos as</strong> seguintes vari√°veis ‚Äã‚Äãuniformes em <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   uniform-    PlayCanvas uniform sampler2D uDepthMap; uniform vec4 uScreenSize; uniform mat4 matrix_view; //      uniform vec4 camera_params;</span></span></code> </pre> <br>  Definimos essas fun√ß√µes auxiliares sobre a fun√ß√£o principal: <br><br><pre> <code class="javascript hljs">#ifdef GL2 float linearizeDepth(float z) { z = z * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (camera_params.z * z + camera_params.w); } #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #ifndef UNPACKFLOAT #define UNPACKFLOAT float unpackFloat(vec4 rgbaDepth) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec4 bitShift = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">256.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot(rgbaDepth, bitShift); } #endif #endif float getLinearScreenDepth(vec2 uv) { #ifdef GL2 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y; #endif } float getLinearDepth(vec3 pos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -(matrix_view * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)).z; } float getLinearScreenDepth() { vec2 uv = gl_FragCoord.xy * uScreenSize.zw; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getLinearScreenDepth(uv); }</code> </pre> <br>  Passaremos as informa√ß√µes do shader sobre a c√¢mera no <strong>Water.js</strong> .  Cole isso para onde voc√™ passa as outras vari√°veis ‚Äã‚Äãuniformes como uTime: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">"Camera"</span></span>).camera; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = camera.nearClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = camera.farClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera_params = [ <span class="hljs-number"><span class="hljs-number">1</span></span>/f, f, (<span class="hljs-number"><span class="hljs-number">1</span></span>-f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-number"><span class="hljs-number">1</span></span> + f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span> ]; material.setParameter(<span class="hljs-string"><span class="hljs-string">'camera_params'</span></span>, camera_params);</code> </pre> <br>  Finalmente, precisamos de uma posi√ß√£o no mundo de cada pixel para o nosso shader de fragmento.  Temos que obt√™-lo do vertex shader.  Portanto, definiremos uma vari√°vel vari√°vel em <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs">varying vec3 WorldPosition;</code> </pre> <br>  Defina a mesma vari√°vel vari√°vel em <strong>Water.vert</strong> .  Em seguida, atribu√≠mos a ela uma posi√ß√£o distorcida do vertex shader, para que o c√≥digo completo fique assim: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; attribute vec2 aUv0; varying vec2 vUv0; varying vec3 WorldPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; uniform float uTime; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vUv0 = aUv0; vec3 pos = aPosition; pos.y += cos(pos.z*<span class="hljs-number"><span class="hljs-number">5.0</span></span>+uTime) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> * sin(pos.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span> + uTime); gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); WorldPosition = pos; }</code> </pre> <br><h3>  Percebemos o truque de verdade </h3><br>  Agora estamos finalmente prontos para implementar a t√©cnica descrita no in√≠cio desta se√ß√£o.  Queremos comparar a profundidade do pixel em que estamos com a profundidade do pixel abaixo dele.  O pixel em que estamos √© retirado de uma posi√ß√£o no mundo e o pixel abaixo dele √© obtido na posi√ß√£o da tela.  Portanto, tomamos essas duas profundidades: <br><br><pre> <code class="javascript hljs">float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth();</code> </pre> <br><blockquote>  <em>Tarefa 4: um desses valores nunca ser√° maior que o outro (assumindo depthTest = true).</em>  <em>Voc√™ pode determinar qual?</em> </blockquote><br>  Sabemos que a espuma ser√° onde a dist√¢ncia entre os dois valores √© pequena.  Portanto, vamos renderizar essa diferen√ßa para cada pixel.  Cole isso no final do sombreador (e desative o script de visualiza√ß√£o em profundidade da se√ß√£o anterior): <br><br><pre> <code class="javascript hljs">color = vec4(vec3(screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">1.0</span></span>); gl_FragColor = color;</code> </pre> <br>  E deve ser algo como isto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/173/883/ad2173883ebe214bbec6c97921810755.png"></div><br>  Ou seja, escolhemos corretamente os limites de qualquer objeto imerso na √°gua em tempo real!  Obviamente, voc√™ pode escalar a diferen√ßa para tornar a espuma mais espessa ou menos comum. <br><br>  Agora temos muitas op√ß√µes para combinar essa sa√≠da com a superf√≠cie da √°gua para criar belas linhas de espuma.  Voc√™ pode deix√°-los com um gradiente, usar para obter amostras de uma textura diferente ou atribuir a eles uma cor espec√≠fica se a diferen√ßa for menor ou igual a um determinado valor limite. <br><br>  O que eu mais gostei foi a atribui√ß√£o de uma cor semelhante √†s linhas de √°gua est√°tica; portanto, minha fun√ß√£o principal final √© assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0 * <span class="hljs-number"><span class="hljs-number">2.0</span></span>; pos.y += uTime * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r * <span class="hljs-number"><span class="hljs-number">0.1</span></span>; float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth(); float foamLine = clamp((screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(foamLine &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>){ color.rgba += <span class="hljs-number"><span class="hljs-number">0.2</span></span>; } gl_FragColor = color; }</code> </pre> <br><h2>  Resumir </h2><br>  Criamos a flutuabilidade dos objetos imersos na √°gua, aplicamos uma textura m√≥vel na superf√≠cie para simular c√°usticos e aprendemos a usar o buffer de profundidade para criar faixas din√¢micas de espuma. <br><br>  Na terceira e na √∫ltima parte, adicionaremos os efeitos do p√≥s-processamento e aprenderemos como us√°-los para criar o efeito de distor√ß√£o subaqu√°tica. <br><br><h2>  C√≥digo fonte </h2><br>  O projeto conclu√≠do do PlayCanvas pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">aqui</a> .  Nosso reposit√≥rio tamb√©m possui uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">porta de projeto em Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416983/">https://habr.com/ru/post/pt416983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416967/index.html">Como fizemos o BelAZ. Parte 3 - Comissionamento secional</a></li>
<li><a href="../pt416969/index.html">Justificativa matem√°tica pitag√≥rica da escala musical</a></li>
<li><a href="../pt416977/index.html">Software para Casa Inteligente # 2</a></li>
<li><a href="../pt416979/index.html">Scrum para grandes equipes: LeSS Day 2018</a></li>
<li><a href="../pt416981/index.html">Como oito pessoas escalam um projeto de alta carga. Experi√™ncia Unsplash</a></li>
<li><a href="../pt416985/index.html">At√© o cent√©simo mais pr√≥ximo: Os 10 principais relat√≥rios do SmartData 2017</a></li>
<li><a href="../pt416987/index.html">Gartner: o principal no mercado de IaaS em 2018</a></li>
<li><a href="../pt416989/index.html">Rob√¥s bi√¥nicos Festo: aranhas e polvos nas f√°bricas do futuro?</a></li>
<li><a href="../pt416991/index.html">A grava√ß√£o de v√≠deo da tela n√£o √© t√£o secreta. Vers√µes de King Burger e Appsee</a></li>
<li><a href="../pt416993/index.html">Conhe√ßa Sofia: um rob√¥ quase indistingu√≠vel dos humanos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>