<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçü§ù‚Äçüë®üèº üòø üéº Replicaci√≥n de alto nivel en el DBMS Tarantool üïõ üë©üèº‚Äçüé® üë®üèΩ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola, estoy desarrollando aplicaciones para el DBMS de Tarantool . Esta es una plataforma desarrollada por Mail.ru Group que combina un DBMS de alto r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Replicaci√≥n de alto nivel en el DBMS Tarantool</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/455146/">  Hola, estoy desarrollando aplicaciones para el DBMS de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tarantool</a> . Esta es una plataforma desarrollada por Mail.ru Group que combina un DBMS de alto rendimiento y un servidor de aplicaciones en el idioma Lua.  La alta velocidad de las soluciones basadas en Tarantool se logra, en particular, al admitir el modo DBMS en memoria y la capacidad de ejecutar la l√≥gica de la aplicaci√≥n empresarial en un solo espacio de direcciones con datos.  Esto asegura la persistencia de los datos mediante transacciones ACID (se mantiene un registro WAL en el disco).  Tarantool tiene soporte de replicaci√≥n y fragmentaci√≥n incorporado.  A partir de la versi√≥n 2.1, se admiten consultas SQL.  Tarantool es de c√≥digo abierto y tiene licencia bajo el BSD simplificado.  Tambi√©n hay una versi√≥n comercial de Enterprise. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4aa/22f/d04/4aa22fd046775dd3b44af444ddcde28d.jpg"><br>  <i>Siente el poder!</i>  <i>(... tambi√©n conocido como disfrutar de la actuaci√≥n)</i> <br><br>  Todo lo anterior hace de Tarantool una plataforma atractiva para crear aplicaciones de bases de datos altamente cargadas.  En tales aplicaciones, la replicaci√≥n de datos a menudo se hace necesaria. <br><a name="habracut"></a><br>  Como se mencion√≥ anteriormente, Tarantool tiene replicaci√≥n de datos incorporada.  El principio de su trabajo es la ejecuci√≥n secuencial en r√©plicas de todas las transacciones contenidas en el registro del asistente (WAL).  T√≠picamente, dicha replicaci√≥n (la llamaremos de <i>bajo nivel a</i> continuaci√≥n) se usa para proporcionar tolerancia a fallas de la aplicaci√≥n y / o para distribuir la carga de lectura entre los nodos del cl√∫ster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1c/31b/83b/d1c31b83b1c71220a514deebb7d49952.png"><br>  <i>Fig.</i>  <i>1. Replicaci√≥n dentro del cl√∫ster</i> <br><br>  Un ejemplo de un escenario alternativo es la transferencia de datos creados en una base de datos a otra base de datos para su procesamiento / monitoreo.  En el √∫ltimo caso, una soluci√≥n m√°s conveniente puede ser utilizar <i>la</i> replicaci√≥n de <i>alto nivel</i> : la replicaci√≥n de datos en el nivel de l√≥gica de negocios de la aplicaci√≥n.  Es decir  No utilizamos una soluci√≥n lista para usar integrada en el DBMS, pero por nuestra cuenta implementamos la replicaci√≥n dentro de la aplicaci√≥n que estamos desarrollando.  Este enfoque tiene ventajas y desventajas.  Enumeramos los pros. <br><br>  1. Ahorre tr√°fico: <br><br><ul><li>  no puede transferir todos los datos, sino solo una parte de ellos (por ejemplo, puede transferir solo algunas tablas, algunas de sus columnas o registros que cumplan un determinado criterio); <br></li><li>  A diferencia de la replicaci√≥n de bajo nivel, que se realiza de forma continua en modo as√≠ncrono (implementado en la versi√≥n actual de Tarantool - 1.10) o s√≠ncrono (para implementarse en versiones futuras de Tarantool), la replicaci√≥n de alto nivel puede realizarse por sesiones (es decir, la aplicaci√≥n primero realiza la sincronizaci√≥n de datos - sesi√≥n de intercambio datos, entonces hay una pausa en la replicaci√≥n, despu√©s de lo cual ocurre la pr√≥xima sesi√≥n de intercambio, etc.); <br></li><li>  Si el registro ha cambiado varias veces, puede transferir solo su √∫ltima versi√≥n (a diferencia de la replicaci√≥n de bajo nivel, en la que todos los cambios realizados en el asistente se reproducir√°n secuencialmente en las r√©plicas). <br></li></ul><br>  2. No hay dificultades con la implementaci√≥n del intercambio a trav√©s de HTTP, que le permite sincronizar bases de datos remotas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/551/551/7aa/5515517aaa739f6260023c5e8ff30bf0.png"><br>  <i>Fig.</i>  <i>2. replicaci√≥n HTTP</i> <br><br>  3. Las estructuras de la base de datos entre las cuales se transmiten los datos no tienen que ser las mismas (adem√°s, en el caso general, incluso es posible utilizar diferentes DBMS, lenguajes de programaci√≥n, plataformas, etc.). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/830/85a/64b/83085a64b69ff5dba2431db97213fa82.png"><br>  <i>Fig.</i>  <i>3. Replicaci√≥n en sistemas heterog√©neos.</i> <br><br>  La desventaja es que, en promedio, la programaci√≥n es m√°s complicada / m√°s costosa que la configuraci√≥n, y en lugar de configurar la funcionalidad incorporada, tendr√° que implementar la suya. <br><br>  Si en su situaci√≥n las ventajas anteriores desempe√±an un papel decisivo (o son una condici√≥n necesaria), entonces tiene sentido utilizar la replicaci√≥n de alto nivel.  Consideremos varias formas de implementar la replicaci√≥n de datos de alto nivel en el DBMS de Tarantool. <br><br><h2>  Minimizaci√≥n del tr√°fico </h2><br>  Por lo tanto, uno de los beneficios de la replicaci√≥n de alto nivel es el ahorro de tr√°fico.  Para que esta ventaja se manifieste completamente, es necesario minimizar la cantidad de datos transmitidos durante cada sesi√≥n de intercambio.  Por supuesto, uno no debe olvidar que al final de la sesi√≥n el receptor de datos debe estar sincronizado con la fuente (al menos para la parte de los datos que est√° involucrada en la replicaci√≥n). <br><br>  ¬øC√≥mo minimizar la cantidad de datos transferidos durante la replicaci√≥n de alto nivel?  La soluci√≥n "en la frente" puede ser la selecci√≥n de datos por fecha y hora.  Para hacer esto, puede usar el campo de fecha y hora que ya se encuentra en la tabla (si corresponde).  Por ejemplo, un documento "orden" puede tener un campo "tiempo requerido para la ejecuci√≥n de la orden" - <code>delivery_time</code> .  El problema con esta soluci√≥n es que los valores en este campo no tienen que estar en la secuencia correspondiente a la creaci√≥n de √≥rdenes.  Por lo tanto, no podemos recordar el valor m√°ximo del campo <code>delivery_time</code> transmitido durante la sesi√≥n de intercambio anterior, y en la siguiente sesi√≥n de intercambio, seleccione todos los registros con un valor m√°s alto del campo <code>delivery_time</code> .  En el intervalo entre sesiones de intercambio, se podr√≠an agregar registros con un valor menor del campo <code>delivery_time</code> .  Adem√°s, el pedido podr√≠a sufrir cambios que, sin embargo, no afectaron el campo <code>delivery_time</code> .  En ambos casos, los cambios no se transmitir√°n desde la fuente al receptor.  Para resolver estos problemas, necesitaremos transmitir datos "superpuestos".  Es decir  durante cada sesi√≥n de intercambio, transferiremos todos los datos con un valor de campo <code>delivery_time</code> que exceda alg√∫n punto en el pasado (por ejemplo, N horas desde el momento actual).  Sin embargo, es obvio que para sistemas grandes este enfoque es muy redundante y puede reducir los ahorros de tr√°fico que buscamos.  Adem√°s, la tabla transmitida puede no tener un campo de fecha y hora. <br><br>  Otra soluci√≥n, m√°s compleja en t√©rminos de implementaci√≥n, es acusar recibo de los datos.  En este caso, en cada sesi√≥n de intercambio, se transmiten todos los datos, cuyo recibo no ha sido confirmado por el destinatario.  Para la implementaci√≥n, debe agregar una columna booleana a la tabla de origen (por ejemplo, <code>is_transferred</code> ).  Si el receptor confirma la recepci√≥n del registro, el campo correspondiente se establece en <code>true</code> , despu√©s de lo cual el registro ya no participa en los intercambios.  Esta opci√≥n de implementaci√≥n tiene las siguientes desventajas.  En primer lugar, para cada registro transferido, es necesario generar y enviar una confirmaci√≥n.  En t√©rminos generales, esto puede ser comparable a duplicar la cantidad de datos transferidos y a duplicar el n√∫mero de viajes de ida y vuelta.  En segundo lugar, no hay posibilidad de enviar el mismo registro a varios receptores (el primer receptor confirmar√° el recibo por s√≠ mismo y por todos los dem√°s). <br><br>  El m√©todo, sin las desventajas anteriores, es agregar columnas a la tabla que se transmitir√° para rastrear los cambios en sus filas.  Dicha columna puede ser del tipo de fecha y hora y la aplicaci√≥n debe establecerla / actualizarla para la hora actual cada vez que agrega / cambia registros (at√≥micamente con agregar / cambiar).  Como ejemplo, llamemos a la columna <code>update_time</code> .  Habiendo guardado el valor m√°ximo del campo de esta columna para los registros transferidos, podemos comenzar la pr√≥xima sesi√≥n de intercambio desde este valor (seleccione registros con el valor del campo <code>update_time</code> exceda el valor guardado previamente).  El problema con este √∫ltimo enfoque es que los cambios de datos pueden ocurrir en modo por lotes.  Como resultado, los valores de campo en la columna <code>update_time</code> no ser √∫nicos.  Por lo tanto, esta columna no se puede utilizar para la salida de datos por lotes (p√°gina).  Para la salida de datos p√°gina por p√°gina, ser√° necesario inventar mecanismos adicionales que probablemente tengan una eficiencia muy baja (por ejemplo, recuperar de la base de datos todos los registros con <code>update_time</code> encima del valor especificado y emitir un cierto n√∫mero de registros, comenzando en un cierto desplazamiento desde el inicio de la muestra). <br><br>  Puede aumentar la eficiencia de la transferencia de datos mejorando ligeramente el enfoque anterior.  Para hacer esto, usaremos un tipo entero (entero largo) como los valores de los campos de columna para el seguimiento de los cambios.  <code>row_ver</code> columna <code>row_ver</code> .  El valor del campo de esta columna a√∫n debe establecerse / actualizarse cada vez que se crea / modifica un registro.  Pero en este caso, el campo se asignar√° no a la fecha y hora actual, sino al valor de alg√∫n contador aumentado en uno.  Como resultado, la columna <code>row_ver</code> contendr√° valores √∫nicos y puede usarse no solo para generar datos ‚Äúdelta‚Äù (datos agregados / modificados despu√©s del final de la sesi√≥n de intercambio anterior), sino tambi√©n para una paginaci√≥n simple y eficiente. <br><br>  El √∫ltimo m√©todo propuesto para minimizar la cantidad de datos transferidos como parte de la replicaci√≥n de alto nivel me parece el m√°s √≥ptimo y universal.  Deteng√°monos en ello con m√°s detalle. <br><br><h2>  Transferencia de datos usando el contador de versiones de fila </h2><br><h4>  Implementaci√≥n de servidor / maestro </h4><br>  En MS SQL Server, para implementar este enfoque, hay un tipo de columna especial: <code>rowversion</code> .  Cada base de datos tiene un contador, que aumenta en uno cada vez que agrega / cambia un registro en una tabla que tiene una columna de tipo <code>rowversion</code> .  El valor de este contador se asigna autom√°ticamente al campo de esta columna en el registro agregado / modificado.  Tarantool DBMS no tiene un mecanismo incorporado similar.  Sin embargo, en Tarantool, no es dif√≠cil implementarlo manualmente.  Considera c√≥mo se hace esto. <br><br>  Primero, una peque√±a terminolog√≠a: las tablas en Tarantool se llaman espacio, y los registros se llaman tuplas.  En Tarantool, puedes crear secuencias.  Las secuencias no son m√°s que generadores nombrados de valores ordenados de enteros.  Es decir  Esto es justo lo que necesitamos para nuestros prop√≥sitos.  A continuaci√≥n crearemos tal secuencia. <br><br>  Antes de realizar cualquier operaci√≥n de base de datos en Tarantool, debe ejecutar el siguiente comando: <br><br><pre> <code class="lua hljs">box.cfg{}</code> </pre> <br>  Como resultado, Tarantool comenzar√° a escribir instant√°neas y un registro de transacciones en el directorio actual. <br><br>  Crea una secuencia <code>row_version</code> : <br><br><pre> <code class="lua hljs">box.schema.sequence.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'row_version'</span></span>, { if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  La opci√≥n <code>if_not_exists</code> permite ejecutar el script de creaci√≥n varias veces: si el objeto existe, Tarantool no intentar√° recrearlo.  Esta opci√≥n se usar√° en todos los comandos DDL posteriores. <br><br>  Creemos un espacio para un ejemplo. <br><br><pre> <code class="lua hljs">box.schema.space.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'goods'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">format</span></span> = { { name = <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'code'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'row_ver'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> } }, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Aqu√≠ establecemos el nombre del espacio ( <code>goods</code> ), los nombres de los campos y sus tipos. <br><br>  Los campos de incremento autom√°tico de Tarantool tambi√©n se crean usando secuencias.  Cree una clave primaria de incremento autom√°tico para el campo <code>id</code> : <br><br><pre> <code class="lua hljs">box.schema.sequence.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'goods_id'</span></span>, { if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) box.space.goods:create_index(<span class="hljs-string"><span class="hljs-string">'primary'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'id'</span></span> }, sequence = <span class="hljs-string"><span class="hljs-string">'goods_id'</span></span>, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'HASH'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Tarantool admite varios tipos de √≠ndices.  Muy a menudo, se utilizan √≠ndices de los tipos TREE y HASH, que se basan en las estructuras correspondientes al nombre.  TREE es el tipo de √≠ndice m√°s vers√°til.  Le permite recuperar datos de manera ordenada.  Pero para la elecci√≥n de la igualdad, HASH es m√°s adecuado.  En consecuencia, es aconsejable usar HASH para la clave primaria (lo cual hicimos). <br><br>  Para usar la columna <code>row_ver</code> para transmitir datos modificados, debe vincular los valores de secuencia <code>row_ver</code> a los campos de esta columna.  Pero a diferencia de la clave principal, el valor del campo en la columna <code>row_ver</code> deber√≠a aumentar en uno, no solo al agregar nuevos registros, sino tambi√©n al cambiar los existentes.  Para hacer esto, puedes usar disparadores.  Tarantool tiene dos tipos de disparadores para espacios: <code>before_replace</code> y <code>on_replace</code> .  Los activadores se activan cada vez que se modifican los datos en el espacio (para cada tupla afectada por los cambios, se activa la funci√≥n de activador).  A diferencia de <code>on_replace</code> , los disparadores <code>before_replace</code> permiten modificar los datos de la tupla para la que se ejecuta el disparador.  En consecuencia, el √∫ltimo tipo de desencadenantes nos conviene. <br><br><pre> <code class="lua hljs">box.space.goods:before_replace(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old, new)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> box.tuple.new({new[<span class="hljs-number"><span class="hljs-number">1</span></span>], new[<span class="hljs-number"><span class="hljs-number">2</span></span>], new[<span class="hljs-number"><span class="hljs-number">3</span></span>], box.sequence.row_version:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>()}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre> <br>  Este activador reemplaza el valor del campo <code>row_ver</code> de la tupla almacenada con el siguiente <code>row_version</code> secuencia <code>row_version</code> . <br><br>  Para poder extraer datos del espacio de <code>goods</code> en la columna <code>row_ver</code> , cree un √≠ndice: <br><br><pre> <code class="lua hljs">box.space.goods:create_index(<span class="hljs-string"><span class="hljs-string">'row_ver'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'row_ver'</span></span> }, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'TREE'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  El tipo de √≠ndice es un √°rbol ( <code>TREE</code> ), porque  necesitamos recuperar los datos en orden ascendente de valores en la columna <code>row_ver</code> . <br><br>  Agregue algunos datos al espacio: <br><br><pre> <code class="lua hljs">box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'pen'</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'pencil'</span></span>, <span class="hljs-number"><span class="hljs-number">321</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'brush'</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'watercolour'</span></span>, <span class="hljs-number"><span class="hljs-number">456</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'album'</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'notebook'</span></span>, <span class="hljs-number"><span class="hljs-number">800</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'rubber'</span></span>, <span class="hljs-number"><span class="hljs-number">531</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'ruler'</span></span>, <span class="hljs-number"><span class="hljs-number">135</span></span>}</code> </pre> <br>  Porque  el primer campo es un contador de incremento autom√°tico, pasamos nulo en su lugar.  Tarantool sustituir√° autom√°ticamente el siguiente valor.  Del mismo modo, puede pasar nil como el valor de los campos en la columna <code>row_ver</code> , o no especificar el valor en absoluto, porque  Esta columna toma la √∫ltima posici√≥n en el espacio. <br><br>  Verifique el resultado del inserto: <br><br><pre> <code class="lua hljs">tarantool&gt; box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">select</span></span>() <span class="hljs-comment"><span class="hljs-comment">--- - - [1, 'pen', 123, 1] - [2, 'pencil', 321, 2] - [3, 'brush', 100, 3] - [4, 'watercolour', 456, 4] - [5, 'album', 101, 5] - [6, 'notebook', 800, 6] - [7, 'rubber', 531, 7] - [8, 'ruler', 135, 8] ...</span></span></code> </pre> <br>  Como puede ver, el primer y el √∫ltimo campo se completaron autom√°ticamente.  Ahora ser√° f√°cil escribir una funci√≥n para paginar la descarga de las <code>goods</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> page_size = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(row_ver)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> index = box.space.goods.index.row_ver <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> goods = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, tuple <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> index:<span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(row_ver, { iterator = <span class="hljs-string"><span class="hljs-string">'GT'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> obj = tuple:tomap({ names_only = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(goods, obj) counter = counter + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> counter &gt;= page_size <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> goods <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  La funci√≥n toma como par√°metro el valor <code>row_ver</code> del √∫ltimo registro recibido (0 para la primera llamada) y devuelve el siguiente lote de datos modificados (si hay uno, de lo contrario, una matriz vac√≠a). <br><br>  La recuperaci√≥n de datos en Tarantool se realiza a trav√©s de √≠ndices.  La funci√≥n <code>get_goods</code> usa el <code>row_ver</code> √≠ndice <code>row_ver</code> para recuperar los datos modificados.  El tipo de iterador es GT (mayor que, m√°s que).  Esto significa que el iterador recorrer√° secuencialmente los valores del √≠ndice comenzando desde el siguiente valor despu√©s de la clave pasada. <br><br>  El iterador devuelve las tuplas.  Para poder transferir datos posteriormente a trav√©s de HTTP, es necesario convertir las tuplas en una estructura conveniente para la serializaci√≥n posterior.  En el ejemplo, la funci√≥n est√°ndar de <code>tomap</code> se utiliza para esto.  En lugar de usar <code>tomap</code> puede escribir su propia funci√≥n.  Por ejemplo, podr√≠amos querer cambiar el <code>name</code> campo de <code>name</code> , no pasar el campo de <code>code</code> y agregar el campo de <code>comment</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unflatten_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tuple)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> obj = {} obj.id = tuple.id obj.goods_name = tuple.name obj.comment = <span class="hljs-string"><span class="hljs-string">'some comment'</span></span> obj.row_ver = tuple.row_ver <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  El tama√±o de p√°gina de los datos de salida (el n√∫mero de registros en una porci√≥n) est√° determinado por la variable <code>page_size</code> .  En el ejemplo, el valor de tama√±o de p√°gina es 5. En un programa real, el tama√±o de p√°gina suele ser m√°s importante.  Depende del tama√±o promedio de la tupla espacial.  El tama√±o de p√°gina √≥ptimo se puede seleccionar emp√≠ricamente midiendo el tiempo de transferencia de datos.  Cuanto m√°s grande es la p√°gina, menor es el n√∫mero de viajes de ida y vuelta entre los lados emisores y receptores.  Por lo tanto, puede reducir el tiempo total para cargar los cambios.  Sin embargo, si el tama√±o de la p√°gina es demasiado grande, el servidor tardar√° demasiado en serializar la selecci√≥n.  Como resultado, puede haber demoras en el procesamiento de otras solicitudes que llegaron al servidor.  El par√°metro <code>page_size</code> se puede cargar desde el archivo de configuraci√≥n.  Para cada espacio transmitido, puede establecer su propio valor.  Sin embargo, para la mayor√≠a de los espacios, el valor predeterminado (por ejemplo, 100) puede ser adecuado. <br><br>  <code>get_goods</code> funci√≥n <code>get_goods</code> en el m√≥dulo.  Cree un archivo repl.lua que contenga la descripci√≥n de la variable <code>page_size</code> y la funci√≥n <code>get_goods</code> .  Al final del archivo, agregue la funci√≥n de exportaci√≥n: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { get_goods = get_goods }</code> </pre><br>  Para cargar el m√≥dulo, ejecute: <br><br><pre> <code class="lua hljs">tarantool&gt; repl = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'repl'</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- ...</span></span></code> </pre><br>  <code>get_goods</code> funci√≥n <code>get_goods</code> : <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - - row_ver: 1 code: 123 name: pen id: 1 - row_ver: 2 code: 321 name: pencil id: 2 - row_ver: 3 code: 100 name: brush id: 3 - row_ver: 4 code: 456 name: watercolour id: 4 - row_ver: 5 code: 101 name: album id: 5 ...</span></span></code> </pre> <br>  Tome el valor del campo <code>row_ver</code> de la √∫ltima fila y vuelva a llamar a la funci√≥n: <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - - row_ver: 6 code: 800 name: notebook id: 6 - row_ver: 7 code: 531 name: rubber id: 7 - row_ver: 8 code: 135 name: ruler id: 8 ...</span></span></code> </pre> <br>  Y de nuevo: <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - [] ...</span></span></code> </pre> <br>  Como puede ver, con este uso, la funci√≥n p√°gina por p√°gina devuelve todos los registros del espacio de <code>goods</code> .  La √∫ltima p√°gina es seguida por una selecci√≥n vac√≠a. <br><br>  Haremos cambios en el espacio: <br><br><pre> <code class="lua hljs">box.space.goods:update(<span class="hljs-number"><span class="hljs-number">4</span></span>, {{<span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">'copybook'</span></span>}}) box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'clip'</span></span>, <span class="hljs-number"><span class="hljs-number">234</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'folder'</span></span>, <span class="hljs-number"><span class="hljs-number">432</span></span>}</code> </pre> <br>  Cambiamos el valor del campo de <code>name</code> para un registro y agregamos dos nuevos registros. <br><br>  Repita la √∫ltima llamada a la funci√≥n: <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - - row_ver: 9 code: 800 name: copybook id: 6 - row_ver: 10 code: 234 name: clip id: 9 - row_ver: 11 code: 432 name: folder id: 10 ...</span></span></code> </pre> <br>  La funci√≥n devolvi√≥ los registros modificados y agregados.  Por lo tanto, la funci√≥n <code>get_goods</code> permite obtener datos que han cambiado desde su √∫ltima llamada, que es la base del m√©todo de replicaci√≥n en consideraci√≥n. <br><br>  Dejamos el resultado de los resultados a trav√©s de HTTP en forma de JSON m√°s all√° del alcance de este art√≠culo.  Puede leer sobre esto aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://habr.com/ru/company/mailru/blog/272141/</a> <br><br><h4>  Implementaci√≥n de la parte cliente / esclavo </h4><br>  Considere c√≥mo se ve la implementaci√≥n del lado receptor.  Cree un espacio en el lado receptor para almacenar los datos descargados: <br><br><pre> <code class="lua hljs">box.schema.space.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'goods'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">format</span></span> = { { name = <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'code'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> } }, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) box.space.goods:create_index(<span class="hljs-string"><span class="hljs-string">'primary'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'id'</span></span> }, sequence = <span class="hljs-string"><span class="hljs-string">'goods_id'</span></span>, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'HASH'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  La estructura del espacio se asemeja a la estructura del espacio en la fuente.  Pero como no vamos a transferir los datos recibidos a otra parte, la columna <code>row_ver</code> est√° <code>row_ver</code> en el espacio del destinatario.  En el campo <code>id</code> se escribir√°n los identificadores de la fuente.  Por lo tanto, en el lado del receptor, no es necesario que se incremente autom√°ticamente. <br><br>  Adem√°s, necesitamos un espacio para guardar los valores de <code>row_ver</code> : <br><br><pre> <code class="lua hljs">box.schema.space.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'row_ver'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">format</span></span> = { { name = <span class="hljs-string"><span class="hljs-string">'space_name'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'value'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> } }, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) box.space.row_ver:create_index(<span class="hljs-string"><span class="hljs-string">'primary'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'space_name'</span></span> }, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'HASH'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Para cada espacio cargado (campo <code>space_name</code> ) <code>space_name</code> aqu√≠ el √∫ltimo valor cargado <code>row_ver</code> ( <code>value</code> campo).  La clave primaria es la columna <code>space_name</code> . <br><br>  Creemos una funci√≥n para cargar datos de espacio de <code>goods</code> trav√©s de HTTP.  Para hacer esto, necesitamos una biblioteca que implemente un cliente HTTP.  La siguiente l√≠nea carga la biblioteca y crea instancias del cliente HTTP: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> http_client = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http.client'</span></span>).new()</code> </pre> <br>  Tambi√©n necesitamos una biblioteca para la deserializaci√≥n de json: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> json = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'json'</span></span>)</code> </pre> <br>  Esto es suficiente para crear una funci√≥n de carga de datos: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url, row_ver)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> url = (<span class="hljs-string"><span class="hljs-string">'%s?rowVer=%s'</span></span>):<span class="hljs-built_in"><span class="hljs-built_in">format</span></span>(url, <span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(row_ver)) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> body = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> data = http_client:request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, url, body, { keepalive_idle = <span class="hljs-number"><span class="hljs-number">1</span></span>, keepalive_interval = <span class="hljs-number"><span class="hljs-number">1</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json.decode(data.body) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  La funci√≥n realiza una solicitud HTTP en url, le pasa <code>row_ver</code> como par√°metro y devuelve el resultado deserializado de la solicitud. <br><br>  La funci√≥n de guardar los datos recibidos es la siguiente: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(goods)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> n = #goods box.atomic(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, n <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> obj = goods[i] box.space.goods:put( obj.id, obj.name, obj.code) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  El ciclo de almacenamiento de datos en el espacio de <code>goods</code> se coloca en una transacci√≥n (la funci√≥n <code>box.atomic</code> se utiliza para esto) para reducir el n√∫mero de operaciones de disco. <br><br>  Finalmente, la funci√≥n de sincronizaci√≥n de los <code>goods</code> espaciales locales con la fuente se puede implementar de la siguiente manera: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sync_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> tuple = box.space.row_ver:get(<span class="hljs-string"><span class="hljs-string">'goods'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> row_ver = tuple <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tuple.value <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">-- set your url here: local url = 'http://127.0.0.1:81/test/goods/list' while true do local goods = load_goods(url, row_ver) local count = #goods if count == 0 then return end save_goods(goods) row_ver = goods[count].rowVer box.space.row_ver:put({'goods', row_ver}) end end</span></span></code> </pre> <br>  Primero, leemos el valor <code>row_ver</code> previamente guardado para el espacio de <code>goods</code> .  Si est√° ausente (la primera sesi√≥n de intercambio), tomamos cero como <code>row_ver</code> .  A continuaci√≥n, en el ciclo, paginamos los datos modificados desde la fuente a la url especificada.  En cada iteraci√≥n, guardamos los datos recibidos en el espacio local correspondiente y actualizamos el valor <code>row_ver</code> (en el <code>row_ver</code> row_ver y en la variable <code>row_ver</code> ): tomamos el valor <code>row_ver</code> de la √∫ltima fila de los datos cargados. <br><br>  Para protegerse contra bucles accidentales (en caso de un error en el programa), el <code>while</code> se puede reemplazar por: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ = <span class="hljs-number"><span class="hljs-number">1</span></span>, max_req <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ...</code> </pre> <br>  Como resultado de la funci√≥n <code>sync_goods</code> , los <code>goods</code> en el receptor contendr√°n las √∫ltimas versiones de todos los registros de espacio de <code>goods</code> en la fuente. <br><br>  Obviamente, la eliminaci√≥n de datos no se puede transmitir de esta manera.  Si existe tal necesidad, puede usar la marca de borrado.  Agregue el campo booleano <code>is_deleted</code> espacio de <code>goods</code> y use la eliminaci√≥n l√≥gica en lugar de eliminar f√≠sicamente el registro; establezca el valor del campo <code>is_deleted</code> en <code>true</code> .  A veces, en lugar del campo booleano <code>is_deleted</code> , <code>is_deleted</code> m√°s conveniente usar el campo <code>deleted</code> , que almacena la fecha y hora de la eliminaci√≥n l√≥gica del registro.  Despu√©s de realizar una eliminaci√≥n l√≥gica, el registro marcado para eliminaci√≥n se transferir√° desde la fuente al receptor (de acuerdo con la l√≥gica discutida anteriormente). <br><br>  La secuencia <code>row_ver</code> se puede usar para transferir datos desde otros espacios: no es necesario crear una secuencia separada para cada espacio transmitido. <br><br>  Examinamos una forma efectiva de replicaci√≥n de datos de alto nivel en aplicaciones que utilizan el DBMS Tarantool. <br><br><h2>  Conclusiones </h2><br><ol><li>  Tarantool DBMS es un producto atractivo y prometedor para crear aplicaciones altamente cargadas. <br></li><li>  La replicaci√≥n de alto nivel proporciona un enfoque m√°s flexible para la transferencia de datos en comparaci√≥n con la replicaci√≥n de bajo nivel. <br></li><li>  El m√©todo de replicaci√≥n de alto nivel discutido en el art√≠culo permite minimizar la cantidad de datos transferidos al transferir solo aquellos registros que han cambiado desde la √∫ltima sesi√≥n de intercambio. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455146/">https://habr.com/ru/post/455146/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455132/index.html">Antig√ºedades: Philips Velo 1, la pesadilla de un entusiasta de la tecnolog√≠a</a></li>
<li><a href="../455134/index.html">¬øQu√© se record√≥ en el pasado Heisenbug y qu√© suceder√° despu√©s?</a></li>
<li><a href="../455136/index.html">¬øPor qu√© el simple bombeo de codificaci√≥n no lo convertir√° en un mejor desarrollador?</a></li>
<li><a href="../455138/index.html">JetBrains Night Moscow: como fue</a></li>
<li><a href="../455144/index.html">Prepar√°ndose para 2020: 8 tendencias en el desarrollo de JavaScript del lado del cliente que debe conocer</a></li>
<li><a href="../455148/index.html">Resolvemos tareas de toma de decisiones basadas en datos</a></li>
<li><a href="../455152/index.html">Mejore su aplicaci√≥n m√≥vil utilizando la tecnolog√≠a de aprendizaje autom√°tico</a></li>
<li><a href="../455156/index.html">Tareas de secuenciaci√≥n dom√©stica (junio de 2019)</a></li>
<li><a href="../455158/index.html">Las maravillas de la metodolog√≠a contable: fondo de amortizaci√≥n</a></li>
<li><a href="../455160/index.html">Entity Framework 6 con b√∫squeda de texto completo a trav√©s de LINQ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>