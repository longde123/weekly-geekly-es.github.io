<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüîß ‚õÖÔ∏è üè© Textversion des Berichts ‚ÄûActors vs CSP vs Tasks ...‚Äú mit C ++ CoreHard Autumn 2018 ü§´ ü§πüèΩ ‚ú¥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anfang November war Minsk Gastgeber der n√§chsten C ++ - Konferenz C ++ CoreHard Herbst 2018-Konferenz. Sie lieferte einen Kapit√§nsbericht ‚ÄûActors vs C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Textversion des Berichts ‚ÄûActors vs CSP vs Tasks ...‚Äú mit C ++ CoreHard Autumn 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430672/">  Anfang November war Minsk Gastgeber der n√§chsten C ++ - Konferenz C ++ CoreHard Herbst 2018-Konferenz. Sie lieferte einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapit√§nsbericht ‚ÄûActors vs CSP vs Tasks ...‚Äú</a> , in dem dargelegt wurde, wie √ºbergeordnete Anwendungen als ‚Äûin C ++ aussehen k√∂nnen‚Äú. Bare Multithreading ‚Äú, wettbewerbsf√§hige Programmiermodelle.  Unter der geschnittenen Version dieses Berichts in einen Artikel umgewandelt.  Gek√§mmt, stellenweise beschnitten, stellenweise erg√§nzt. <br><br>  Ich m√∂chte diese Gelegenheit nutzen, um der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoreHard-</a> Community f√ºr die Organisation der n√§chsten gro√üen Konferenz in Minsk und f√ºr die Gelegenheit zum Sprechen zu danken.  Und auch f√ºr die zeitnahe Ver√∂ffentlichung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Videoberichten von Berichten auf YouTube</a> . <br><br>  Kommen wir also zum Hauptthema der Konversation.  Welche Ans√§tze k√∂nnen wir verwenden, um die Multithread-Programmierung in C ++ zu vereinfachen, wie einige dieser Ans√§tze im Code aussehen, welche Funktionen bestimmten Ans√§tzen inh√§rent sind, was ihnen gemeinsam ist usw. <br><br>  Hinweis: In der urspr√ºnglichen Pr√§sentation des Berichts wurden Fehler und Tippfehler gefunden. Daher werden im Artikel Folien aus der aktualisierten und bearbeiteten Version verwendet, die in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Slides</a> oder auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SlideShare zu finden sind</a> . <br><br><h1>  Nacktes Multithreading ist b√∂se! </h1><br>  Sie m√ºssen mit der wiederholten Banalit√§t beginnen, die jedoch immer noch relevant bleibt: <br><blockquote>  Multithread-C ++ - Programmierung √ºber nackte Threads, Mutex und Bedingungsvariablen ist <b>Schwei√ü</b> , <b>Schmerz</b> und <b>Blut</b> . </blockquote><a name="habracut"></a><br>  Ein gutes Beispiel wurde k√ºrzlich hier in diesem Artikel hier auf Habr√© beschrieben: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Architektur des Metaservers des mobilen Online-Shooters Tacticool</a> ".  Darin sprachen die Jungs dar√ºber, wie sie es anscheinend geschafft haben, eine ganze Reihe von Rechen zu sammeln, die mit der Entwicklung von Multithread-Code in C und C ++ zusammenh√§ngen.  Es gab "Memory Passes" als Ergebnis von Rennen und geringe Leistung aufgrund erfolgloser Parallelisierung. <br><br>  Infolgedessen endete alles ganz nat√ºrlich: <br><blockquote>  Nachdem wir einige Wochen damit verbracht hatten, die kritischsten Fehler zu finden und zu beheben, entschieden wir, dass es <u>einfacher war, alles von Grund auf neu zu schreiben,</u> als zu versuchen, alle M√§ngel der aktuellen L√∂sung zu beheben. </blockquote><br>  Die Benutzer haben C / C ++ gegessen, w√§hrend sie an der ersten Version ihres Servers gearbeitet haben, und den Server in einer anderen Sprache neu geschrieben. <br><br>  Eine hervorragende Demonstration, wie Entwickler in der realen Welt au√üerhalb unserer gem√ºtlichen C ++ - Community die Verwendung von C ++ ablehnen, selbst wenn die Verwendung von C ++ noch angemessen und gerechtfertigt ist. <br><br><h2>  Aber warum? </h2><br>  Aber warum, wenn wiederholt gesagt wird, dass "nacktes Multithreading" in C ++ b√∂se ist, verwenden die Leute es weiterhin mit Ausdauer, die einer besseren Anwendung w√ºrdig ist?  Was ist schuld: <br><br><ul><li>  Unwissenheit? </li><li>  Faulheit? </li><li>  NIH-Syndrom? </li></ul><br>  Schlie√ülich gibt es bei weitem keinen einzigen Ansatz, der durch die Zeit und viele Projekte getestet wurde.  Insbesondere: <br><br><ul><li>  Schauspieler </li><li>  Kommunikation sequentieller Prozesse (CSP) </li><li>  Aufgaben (Async, Versprechen, Zukunft, ...) </li><li>  Datenfl√ºsse </li><li>  reaktive Programmierung </li><li>  ... </li></ul><br>  Es ist zu hoffen, dass der Hauptgrund immer noch Unwissenheit ist.  Es ist unwahrscheinlich, dass dies an Universit√§ten gelehrt wird.  Junge Berufst√§tige, die in den Beruf eintreten, nutzen das Wenige, das sie bereits kennen.  Und wenn dann der Wissensspeicher nicht aufgef√ºllt wird, verwenden die Benutzer weiterhin nackte Threads, Mutexe und Bedingungsvariablen. <br><br>  Heute werden wir √ºber die ersten drei Ans√§tze aus dieser Liste sprechen.  Und wir werden nicht abstrakt sprechen, sondern am Beispiel einer einfachen Aufgabe.  Versuchen wir zu zeigen, wie der Code, der dieses Problem l√∂st, mithilfe von Actor, CSP-Prozessen und -Kan√§len sowie mithilfe von Task aussehen wird. <br><br><h1>  Herausforderung f√ºr Experimente </h1><br>  Es ist erforderlich, einen HTTP-Server zu implementieren, der: <br><br><ul><li>  akzeptiert die Anfrage (Bild-ID, Benutzer-ID); </li><li>  gibt ein Bild mit "Wasserzeichen", das f√ºr diesen Benutzer einzigartig ist. </li></ul><br>  Beispielsweise kann ein solcher Server von einem kostenpflichtigen Dienst ben√∂tigt werden, der Inhalte per Abonnement verteilt.  Wenn das Bild von diesem Dienst irgendwo auftaucht, k√∂nnen Sie anhand der Wasserzeichen erkennen, wer Sauerstoff blockieren muss. <br><br>  Die Aufgabe ist abstrakt, sie wurde speziell f√ºr diesen Bericht unter dem Einfluss unseres Demo-Projekts Shrimp formuliert (wir haben bereits dar√ºber gesprochen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 3</a> ). <br><br>  Dies funktioniert auf unserem HTTP-Server wie folgt: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/bq/qo/zk/bqqozkulonydk1ccnzog-kzv610.jpeg"></td></tr></tbody></table><br>  Nachdem wir eine Anfrage von einem Kunden erhalten haben, wenden wir uns an zwei externe Dienste: <br><br><ul><li>  Der erste gibt uns Benutzerinformationen zur√ºck.  Einschlie√ülich von dort erhalten wir ein Bild mit "Wasserzeichen"; </li><li>  Die zweite gibt uns das Originalbild zur√ºck </li></ul><br>  Beide Dienste arbeiten unabh√§ngig voneinander und wir k√∂nnen gleichzeitig auf beide zugreifen. <br><br>  Da die Verarbeitung von Anforderungen unabh√§ngig voneinander erfolgen kann und sogar einige Aktionen bei der Verarbeitung einer einzelnen Anforderung parallel ausgef√ºhrt werden k√∂nnen, bietet sich die Nutzung der Wettbewerbsf√§higkeit an.  Am einfachsten f√§llt Ihnen ein, f√ºr jede eingehende Anfrage einen eigenen Thread zu erstellen: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/g0/f9/ps/g0f9ps3vmq-osh-hy0i71ut_kfw.jpeg"></td></tr></tbody></table><br>  Das One-Request = One-Workflow-Modell ist jedoch zu teuer und l√§sst sich nicht gut skalieren.  Das brauchen wir nicht. <br><br>  Selbst wenn wir uns der Anzahl der Workflows verschwenderisch n√§hern, brauchen wir immer noch eine kleine Anzahl davon: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/ve/yl/vv/veylvvoaisqxod1-0nsp4vhh80e.jpeg"></td></tr></tbody></table><br>  Hier ben√∂tigen wir einen separaten Stream zum Empfangen eingehender HTTP-Anforderungen, einen separaten Stream f√ºr unsere eigenen ausgehenden HTTP-Anforderungen und einen separaten Stream zum Koordinieren der Verarbeitung empfangener HTTP-Anforderungen.  Neben einem Pool von Workflows zum Ausf√ºhren von Vorg√§ngen an Bildern (da die Manipulationen an Bildern gut parallel sind, wird durch die gleichzeitige Verarbeitung eines Bildes durch mehrere Streams die Verarbeitungszeit verk√ºrzt). <br><br>  Daher ist es unser Ziel, eine gro√üe Anzahl von gleichzeitig eingehenden Anforderungen auf einer kleinen Anzahl von Arbeitsthreads zu verarbeiten.  Schauen wir uns an, wie wir dies durch verschiedene Ans√§tze erreichen. <br><br><h2>  Einige wichtige Haftungsausschl√ºsse </h2><br>  Bevor Sie mit der Hauptgeschichte fortfahren und Codebeispiele analysieren, m√ºssen Sie einige Notizen machen. <br><br>  Erstens sind alle folgenden Beispiele nicht an ein bestimmtes Framework oder eine bestimmte Bibliothek gebunden.  Alle √úbereinstimmungen in den Namen der API-Aufrufe sind zuf√§llig und unbeabsichtigt. <br><br>  Zweitens gibt es in den folgenden Beispielen keine Fehlerbehandlung.  Dies geschieht bewusst, damit die Folien kompakt und sichtbar sind.  Und damit das Material in die f√ºr den Bericht vorgesehene Zeit passt. <br><br>  Drittens verwenden die Beispiele einen bestimmten Entit√§tsausf√ºhrungskontext, der Informationen dar√ºber enth√§lt, was sonst noch im Programm vorhanden ist.  Das Bef√ºllen dieser Entit√§t h√§ngt vom Ansatz ab.  Bei Akteuren enth√§lt execute_context Links zu anderen Akteuren.  Im Fall von CSP gibt es im Ausf√ºhrungskontext CSP-Kan√§le f√ºr die Kommunikation mit anderen CSP-Prozessen.  Usw. <br><br><h1>  Ansatz 1: Schauspieler </h1><br><h2>  Schauspieler Modell auf den Punkt gebracht </h2><br>  Bei Verwendung des Modells der Akteure wird die L√∂sung aus separaten Objekt-Akteuren aufgebaut, von denen jeder seinen eigenen privaten Zustand hat und auf den nur der Schauspieler selbst zugreifen kann. <br><br>  Akteure interagieren √ºber asynchrone Nachrichten miteinander.  Jeder Akteur verf√ºgt √ºber ein eigenes Postfach (Nachrichtenwarteschlange), in dem an den Akteur gesendete Nachrichten gespeichert und von dort zur weiteren Verarbeitung abgerufen werden. <br><br>  Schauspieler arbeiten nach sehr einfachen Prinzipien: <br><br><ul><li>  Ein Schauspieler ist eine Einheit mit Verhalten. </li><li>  Akteure reagieren auf eingehende Nachrichten; </li><li>  Nach Erhalt der Nachricht kann der Schauspieler: <br><ul><li>  Senden Sie eine (endg√ºltige) Anzahl von Nachrichten an andere Akteure. </li><li>  eine (endg√ºltige) Anzahl neuer Akteure schaffen; </li><li>  Definieren Sie ein neues Verhalten f√ºr die Verarbeitung nachfolgender Nachrichten. </li></ul></li></ul><br>  Innerhalb einer Anwendung k√∂nnen Akteure auf verschiedene Arten implementiert werden: <br><br><ul><li>  Jeder Akteur kann als separater Betriebssystem-Stream dargestellt werden (dies geschieht beispielsweise in der C :: Just :: Thread Pro Actor Edition-Bibliothek). </li><li>  Jeder Schauspieler kann als stapelbare Coroutine dargestellt werden. </li><li>  Jeder Akteur kann als ein Objekt dargestellt werden, in dem jemand R√ºckrufmethoden aufruft. </li></ul><br>  In unserer Entscheidung werden wir Akteure in Form von Objekten mit R√ºckrufen verwenden und Coroutinen f√ºr den CSP-Ansatz belassen. <br><br><h2>  Entscheidungsschema basierend auf dem Modell der Akteure </h2><br>  Basierend auf den Akteuren sieht das allgemeine Schema zur L√∂sung unseres Problems folgenderma√üen aus: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/di/f7/pn/dif7pngijjde8aizja_skqy58oo.jpeg"></td></tr></tbody></table><br>  Wir werden Akteure haben, die am Anfang des HTTP-Servers erstellt werden und die ganze Zeit existieren, w√§hrend der HTTP-Server arbeitet.  Dies sind Akteure wie: HttpSrv, UserChecker, ImageDownloader, ImageMixer. <br><br>  Nach Erhalt einer neuen eingehenden HTTP-Anforderung erstellen wir eine neue Instanz des RequestHandler-Akteurs, die nach einer Antwort auf die eingehende HTTP-Anforderung zerst√∂rt wird. <br><br><h2>  RequestHandler Actor Code </h2><br>  Die Implementierung des Request_Handler-Akteurs, der die Verarbeitung einer eingehenden HTTP-Anforderung koordiniert, kann folgenderma√üen aussehen: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_handler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> some_basic_type { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> execution_context context_; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request request_; optional&lt;user_info&gt; user_info_; optional&lt;image_loaded&gt; image_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_user_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_info info)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_image_loaded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image_loaded image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_mixed_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mixed_image image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_mix_images_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; ... <span class="hljs-comment"><span class="hljs-comment">//     . }; void request_handler::on_start() { send(context_.user_checker(), check_user{request_.user_id(), self()}); send(context_.image_downloader(), download_image{request_.image_id(), self()}); } void request_handler::on_user_info(user_info info) { user_info_ = std::move(info); if(image_) send_mix_images_request(); } void request_handler::on_image_loaded(image_loaded image) { image_ = std::move(image); if(user_info_) send_mix_images_request(); } void request_handler::send_mix_images_request() { send(context_.image_mixer(), mix_images{user_info-&gt;watermark_image(), *image_, self()}); } void request_handler::on_mixed_image(mixed_image image) { send(context_.http_srv(), reply{..., std::move(image), ...}); }</span></span></code> </pre> <br>  Lassen Sie uns diesen Code analysieren. <br><br>  Wir haben eine Klasse, in deren Attributen wir speichern oder speichern werden, was wir zur Verarbeitung der Anforderung ben√∂tigen.  Auch in dieser Klasse gibt es eine Reihe von R√ºckrufen, die zu der einen oder anderen Zeit aufgerufen werden. <br><br>  Wenn gerade ein Akteur erstellt wurde, wird zun√§chst der R√ºckruf on_start () aufgerufen.  Darin senden wir zwei Nachrichten an andere Akteure.  Erstens ist dies eine check_user-Nachricht, um die Client-ID zu √ºberpr√ºfen.  Zweitens ist dies eine download_image-Nachricht zum Herunterladen des Originalbilds. <br><br>  In jeder der gesendeten Nachrichten √ºbergeben wir einen Link an uns selbst (ein Aufruf der self () -Methode gibt einen Link an den Akteur zur√ºck, f√ºr den self () aufgerufen wurde).  Dies ist notwendig, damit unser Schauspieler eine Nachricht als Antwort senden kann.  Wenn wir beispielsweise in der check_user-Nachricht keinen Link zu unserem Akteur senden, wei√ü der UserChecker-Akteur nicht, an wen er die Benutzerinformationen senden soll. <br><br>  Wenn eine user_info-Nachricht mit Benutzerinformationen als Antwort an uns gesendet wird, wird der R√ºckruf on_user_info () aufgerufen.  Und wenn die image_loaded-Nachricht an uns gesendet wird, ruft unser Akteur den R√ºckruf on_image_loaded () auf.  Und jetzt sehen wir in diesen beiden R√ºckrufen eine Funktion, die dem Modell der Akteure eigen ist: Wir wissen nicht genau, in welcher Reihenfolge wir Antwortnachrichten erhalten.  Daher m√ºssen wir unseren Code so schreiben, dass er nicht von der Reihenfolge abh√§ngt, in der die Nachrichten ankommen.  Daher speichern wir in jedem der Prozessoren zuerst die empfangenen Informationen im entsprechenden Attribut und pr√ºfen dann, ob wir bereits alle ben√∂tigten Informationen gesammelt haben.  Wenn ja, dann k√∂nnen wir weitermachen.  Wenn nicht, werden wir weiter warten. <br><br>  Aus diesem Grund haben wir ons in on_user_info () und on_image_loaded (), wenn send_mix_images_request () aufgerufen wird. <br><br><blockquote>  Grunds√§tzlich kann es in den Implementierungen des Modells der Akteure Mechanismen wie selektives Empfangen von Erlang oder Verstecken von Akka geben, √ºber die Sie die Verarbeitungsreihenfolge eingehender Nachrichten manipulieren k√∂nnen. Wir werden heute jedoch nicht dar√ºber sprechen, um nicht in den Dschungel der Details verschiedener Implementierungen des Modells einzutauchen Schauspieler. </blockquote><br>  Wenn also alle Informationen empfangen werden, die wir von UserChecker und ImageDownloader ben√∂tigen, wird die Methode send_mix_images_request () aufgerufen, bei der die Nachricht mix_images an den ImageMixer-Akteur gesendet wird.  Der R√ºckruf on_mixed_image () wird aufgerufen, wenn wir eine Antwortnachricht mit dem resultierenden Bild erhalten.  Hier senden wir dieses Bild an den HttpSrv-Akteur und warten, bis HttpSrv eine HTTP-Antwort bildet und den unn√∂tigen RequestHandler zerst√∂rt (obwohl im Prinzip nichts den RequestHandler-Akteur daran hindert, sich im R√ºckruf on_mixed_image () selbst zu zerst√∂ren). <br><br>  Das ist alles <br><br>  Die Implementierung des RequestHandler-Akteurs erwies sich als recht umfangreich.  Dies liegt jedoch daran, dass wir eine Klasse mit Attributen und R√ºckrufen beschreiben und dann auch R√ºckrufe implementieren mussten.  Die Logik der Arbeit von RequestHandler ist jedoch sehr trivial, und es ist einfach, sie trotz der Menge an Code in der request_handler-Klasse zu verstehen. <br><br><h2>  Merkmale, die den Schauspielern eigen sind </h2><br>  Jetzt k√∂nnen wir ein paar Worte zu den Merkmalen des Modells der Schauspieler sagen. <br><br><h3>  Reaktoren </h3><br>  Akteure reagieren in der Regel nur auf eingehende Nachrichten.  Es gibt Nachrichten - der Schauspieler verarbeitet sie.  Keine Nachrichten - der Schauspieler tut nichts. <br><br>  Dies gilt insbesondere f√ºr Implementierungen des Actors Model, bei denen Actors als Objekte mit R√ºckrufen dargestellt werden.  Das Framework ruft den R√ºckruf des Akteurs ab. Wenn der Akteur die Kontrolle √ºber den R√ºckruf nicht zur√ºckgibt, kann das Framework keine anderen Akteure im selben Kontext bedienen. <br><br><h3>  Schauspieler sind √ºberladen </h3><br>  Bei Schauspielern k√∂nnen wir Schauspieler und Produzenten sehr leicht dazu bringen, Nachrichten f√ºr Konsumenten-Schauspieler in einem viel schnelleren Tempo zu generieren, als Schauspieler-Konsumenten verarbeiten k√∂nnen. <br><br>  Dies f√ºhrt dazu, dass die Warteschlange eingehender Nachrichten f√ºr den Akteur-Verbraucher st√§ndig w√§chst.  Warteschlangenwachstum, d.h.  Ein erh√∂hter Speicherverbrauch in der Anwendung verringert die Geschwindigkeit der Anwendung.  Dies f√ºhrt zu einem noch schnelleren Wachstum der Warteschlange, und infolgedessen kann sich die Anwendung verschlechtern und die Inoperabilit√§t vollst√§ndig beeintr√§chtigen. <br><br>  All dies ist eine direkte Folge der asynchronen Interaktion der Akteure.  Weil der Sendevorgang im Allgemeinen nicht blockiert.  Und es zu blockieren ist nicht einfach, weil  Ein Schauspieler kann sich selbst schicken.  Und wenn die Warteschlange f√ºr den Schauspieler voll ist, wird der Schauspieler beim Senden an sich selbst blockiert und dies beendet seine Arbeit. <br><br>  Bei der Arbeit mit Schauspielern muss dem Problem der √úberlastung ernsthafte Aufmerksamkeit gewidmet werden. <br><br><h3>  Viele Schauspieler sind nicht immer die L√∂sung. </h3><br>  Akteure sind in der Regel leichte Einheiten, und es besteht die Versuchung, sie in ihrer Anwendung in gro√üer Anzahl zu erstellen.  Sie k√∂nnen zehntausend Schauspieler und hunderttausend und eine Million erstellen.  Und sogar hundert Millionen Schauspieler, wenn Eisen es Ihnen erlaubt. <br><br>  Das Problem ist jedoch, dass das Verhalten einer sehr gro√üen Anzahl von Akteuren schwer zu verfolgen ist.  Das hei√üt,  M√∂glicherweise haben Sie einige Schauspieler, die eindeutig richtig funktionieren.  Einige Schauspieler, die entweder offensichtlich falsch oder gar nicht arbeiten, und Sie wissen es genau.  Aber es kann eine gro√üe Anzahl von Schauspielern geben, √ºber die Sie nichts wissen: Arbeiten sie √ºberhaupt, funktionieren sie richtig oder falsch?  Und das alles, denn wenn Sie hundert Millionen autonome Einheiten mit Ihrer eigenen Verhaltenslogik in Ihrem Programm haben, ist die √úberwachung f√ºr alle sehr schwierig. <br><br>  Daher kann sich herausstellen, dass wir beim Erstellen einer gro√üen Anzahl von Akteuren in der Anwendung unser angewandtes Problem nicht l√∂sen, sondern ein anderes Problem erhalten.  Daher kann es f√ºr uns von Vorteil sein, einfache Akteure, die eine einzelne Aufgabe l√∂sen, zugunsten komplexerer und schwererer Akteure, die mehrere Aufgaben ausf√ºhren, aufzugeben.  Aber dann wird es weniger solche "schweren" Akteure in der Anwendung geben und es wird f√ºr uns einfacher sein, ihnen zu folgen. <br><br><h2>  Wo soll man suchen, was soll man mitnehmen? </h2><br>  Wenn jemand versuchen m√∂chte, mit Schauspielern in C ++ zu arbeiten, macht es keinen Sinn, eigene Fahrr√§der zu bauen. Es gibt mehrere vorgefertigte L√∂sungen, insbesondere: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer</a> (Unterst√ºtzung des heimischen Herstellers!) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Actor Framework (CAF)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QP / C ++</a> </li></ul><br>  Diese drei Optionen sind lebendig, weiterentwickelnd, plattform√ºbergreifend und dokumentiert.  Sie k√∂nnen sie auch kostenlos testen.  Weitere Optionen mit unterschiedlichem Grad an [nicht] Frische finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Liste auf Wikipedia</a> . <br><br>  SObjectizer und CAF sind f√ºr die Verwendung in Aufgaben auf relativ hoher Ebene konzipiert, bei denen Ausnahmen und dynamischer Speicher angewendet werden k√∂nnen.  Und das QP / C ++ - Framework kann f√ºr diejenigen von Interesse sein, die an der Embedded-Entwicklung beteiligt sind  Unter dieser Nische ist er "eingesperrt". <br><br><h1>  Ansatz 2: CSP (Kommunikation sequentieller Prozesse) </h1><br><h2>  CSP an den Fingern und ohne Matan </h2><br>  Das CSP-Modell ist dem Actors-Modell sehr √§hnlich.  Wir bauen unsere L√∂sung auch aus einer Reihe autonomer Entit√§ten auf, von denen jede ihren eigenen privaten Status hat und nur √ºber asynchrone Nachrichten mit anderen Entit√§ten interagiert. <br><br>  Nur diese Entit√§ten im CSP-Modell werden als "Prozesse" bezeichnet. <br><br>  Prozesse in CSP sind leicht und ohne Parallelisierung ihrer Arbeit im Inneren.  Wenn wir etwas parallelisieren m√ºssen, starten wir einfach mehrere CSP-Prozesse, in denen es keine Parallelisierung mehr gibt. <br><br>  CSP-Prozesse interagieren √ºber asynchrone Nachrichten miteinander, aber Nachrichten werden nicht wie im Modell der Akteure an Postf√§cher gesendet, sondern an Kan√§le.  Kan√§le k√∂nnen als Nachrichtenwarteschlangen betrachtet werden, die normalerweise eine feste Gr√∂√üe haben. <br><br>  Im Gegensatz zum Schauspieler-Modell, bei dem f√ºr jeden Akteur automatisch ein Postfach erstellt wird, m√ºssen Kan√§le im CSP explizit erstellt werden.  Und wenn wir die beiden Prozesse brauchen, um miteinander zu interagieren, m√ºssen wir den Kanal selbst erstellen und dann dem ersten Prozess sagen "Sie werden hier schreiben", und der zweite Prozess sollte sagen: "Sie werden hier von hier aus lesen." <br><br>  Gleichzeitig haben die Kan√§le mindestens zwei Operationen, die explizit aufgerufen werden m√ºssen.  Die erste ist die Schreib- (Sende-) Operation, um eine Nachricht in den Kanal zu schreiben. <br><br>  Zweitens ist es eine Lese- (Empfangs-) Operation, um eine Nachricht von einem Kanal zu lesen.  Und die Notwendigkeit, Read / Receive explizit aufzurufen, unterscheidet CSP vom Actors Model, weil  Im Fall von Akteuren kann die Lese- / Empfangsoperation im Allgemeinen vor dem Akteur verborgen sein.  Das hei√üt,  Das Actor Framework kann Nachrichten aus der Actor-Warteschlange abrufen und einen Handler (Callback) f√ºr die abgerufene Nachricht aufrufen. <br><br>  W√§hrend der CSP-Prozess selbst den Zeitpunkt f√ºr den Lese- / Empfangsanruf ausw√§hlen muss, muss der CSP-Prozess bestimmen, welche Nachricht er empfangen hat, und die extrahierte Nachricht verarbeiten. <br><br>  In unserer ‚Äûgro√üen‚Äú Anwendung k√∂nnen CSP-Prozesse auf verschiedene Arten implementiert werden: <br><br><ul><li>  Der CSP-shny-Prozess kann als separates Thread-Betriebssystem implementiert werden.  Es stellt sich als teure L√∂sung heraus, aber mit pr√§ventivem Multitasking; </li><li>  Der CSP-Prozess kann durch Coroutine implementiert werden (stapelbare Coroutine, Faser, gr√ºner Faden, ...).  Es ist viel billiger, aber Multitasking ist nur kooperativ. </li></ul><br>  Ferner nehmen wir an, dass CSP-Prozesse in Form von stapelbaren Coroutinen dargestellt werden (obwohl der unten gezeigte Code m√∂glicherweise in Betriebssystem-Threads implementiert ist). <br><br><h2>  CSP-basiertes L√∂sungsdiagramm </h2><br>  Das auf dem CSP-Modell basierende L√∂sungsschema √§hnelt stark einem √§hnlichen Schema f√ºr das Actors-Modell (und dies ist kein Zufall): <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/96/oy/uu/96oyuu6mwhj4ot6fqpsiiv-f1h8.jpeg"></td></tr></tbody></table><br>  Es wird auch Entit√§ten geben, die am Start des HTTP-Servers beginnen und st√§ndig funktionieren - dies sind die CSP-Prozesse HttpSrv, UserChecker, ImageDownloader und ImageMixer.  F√ºr jede neue eingehende Anforderung wird ein neuer RequestHandler-CSP-Prozess erstellt.  Dieser Prozess sendet und empf√§ngt dieselben Nachrichten wie bei Verwendung des Actors Model. <br><br><h2>  RequestHandler CSP-Prozesscode </h2><br>  Dies sieht m√∂glicherweise aus wie der Code einer Funktion, die den CSP-sch√ºchternen Prozess von RequestHandler implementiert: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ch = make_chain&lt;user_info&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_loaded_ch = make_chain&lt;image_loaded&gt;(); ctx.user_checker_ch().write(check_user{req.user_id(), user_info_ch}); ctx.image_downloader_ch().write(download_image{req.image_id(), image_loaded_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); ctx.image_mixer_ch().write( mix_image{user.watermark_image(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(original_image), image_mix_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result_image = image_mix_ch.read(); ctx.http_srv_ch().write(reply{..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(result_image), ...}); }</code> </pre> <br>  Hier ist alles ziemlich trivial und wiederholt regelm√§√üig das gleiche Muster: <br><br><ul><li>  Zun√§chst erstellen wir einen Kanal zum Empfangen von Antwortnachrichten.  Dies ist notwendig, weil  Der CSP-Prozess verf√ºgt nicht √ºber ein eigenes Standardpostfach wie Akteure.  Wenn der CSP-shny-Prozess etwas empfangen m√∂chte, sollte dies durch die Erstellung des Kanals, in dem dieses "Etwas" geschrieben wird, verwirrt werden. </li><li>  dann senden wir unsere Nachricht an den CSP-Master-Prozess.  Und in dieser Nachricht geben wir den Kanal f√ºr die Antwortnachricht an; </li><li>  Dann f√ºhren wir den Lesevorgang von dem Kanal aus, an den eine Antwortnachricht gesendet werden soll. </li></ul><br>  Dies wird am Beispiel der Kommunikation mit dem ImageSPixer CSP-Prozess sehr deutlich: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  . ctx.image_mixer_ch().write( //  . mix_image{..., image_mix_ch}); //     . auto result_image = image_mix_ch.read(); //  .</span></span></code> </pre> <br>  Aber separat lohnt es sich, sich auf dieses Fragment zu konzentrieren: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read();</code> </pre> <br>  Hier sehen wir einen weiteren gravierenden Unterschied zum Modell der Schauspieler.  Im Fall von CSP k√∂nnen wir Antwortnachrichten in der f√ºr uns geeigneten Reihenfolge empfangen. <br><br>  M√∂chten Sie zuerst auf user_info warten?  Kein Problem, gehen Sie beim Lesen in den Ruhezustand, bis user_info angezeigt wird.  Wenn image_loaded zu diesem Zeitpunkt bereits an uns gesendet wurde, wartet es einfach in seinem Kanal, bis wir es lesen. <br><br>  Das ist in der Tat alles, was den oben gezeigten Code begleiten kann.  CSP-basierter Code war kompakter als sein akteursbasiertes Gegenst√ºck.  Was seitdem nicht verwunderlich ist  hier mussten wir keine separate Klasse mit R√ºckrufmethoden beschreiben.  Und ein Teil des Zustands unseres CSP-sch√ºchternen Prozesses RequestHandler ist implizit in Form der Argumente ctx und req vorhanden. <br><br><h2>  CSP-Funktionen </h2><br><h3>  Reaktivit√§t und Proaktivit√§t von CSP-Prozessen </h3><br>  Im Gegensatz zu Akteuren k√∂nnen CSP-Prozesse reaktiv, proaktiv oder beides sein.  Angenommen, der CSP-Prozess hat seine eingehenden Nachrichten √ºberpr√ºft und gegebenenfalls verarbeitet.  Und als er sah, dass keine Nachrichten eingingen, verpflichtete er sich, die Matrizen zu multiplizieren. <br><br>  Nach einiger Zeit war der CSP-Prozess der Matrix der Multiplikation √ºberdr√ºssig und er suchte erneut nach eingehenden Nachrichten.  Keine neuen?  Okay, lass uns die Matrizen weiter multiplizieren. <br><br>  Und diese F√§higkeit von CSP-Prozessen, auch ohne eingehende Nachrichten einige Arbeiten auszuf√ºhren, unterscheidet das CSP-Modell stark vom Actors-Modell. <br><br><h3>  Native √úberlastschutzmechanismen </h3><br>  Da Kan√§le in der Regel Warteschlangen von Nachrichten begrenzter Gr√∂√üe sind und der Versuch, eine Nachricht in einen gef√ºllten Kanal zu schreiben, den Absender stoppt, verf√ºgen wir in CSP √ºber einen integrierten Schutzmechanismus gegen √úberlastung. <br><br>  Wenn wir einen flinken Produzentenprozess und einen langsamen Konsumentenprozess haben, wird der Produzentenprozess den Kanal schnell f√ºllen und f√ºr den n√§chsten Sendevorgang angehalten.  Und der Producer-Prozess wird so lange schlafen, bis der Consumer-Prozess Speicherplatz im Kanal f√ºr neue Nachrichten freigibt.  Sobald der Ort erscheint, wacht der Produzentenprozess auf und wirft neue Nachrichten in den Kanal. <br><br>  Daher k√∂nnen wir uns bei der Verwendung von CSP weniger Gedanken √ºber das Problem der √úberlastung machen als im Fall des Modells der Akteure.  Es stimmt, es gibt hier eine Falle, √ºber die wir etwas sp√§ter sprechen werden. <br><br><h3>  Wie werden CSP-Prozesse implementiert? </h3><br>  Wir m√ºssen entscheiden, wie unsere CSP-Prozesse implementiert werden. <br><br>  Dies kann so erfolgen, dass jeder CSP-shny-Prozess durch einen separaten Betriebssystem-Thread dargestellt wird.  Es stellt sich als teure und nicht skalierbare L√∂sung heraus.  Auf der anderen Seite erhalten wir pr√§ventives Multitasking: Wenn unser CSP-Prozess beginnt, Matrizen zu multiplizieren oder eine Art Blockierungsaufruf ausf√ºhrt, wird das Betriebssystem ihn schlie√ülich aus dem Rechenkern verdr√§ngen und anderen CSP-Prozessen die M√∂glichkeit geben, zu arbeiten. <br><br>  Es ist m√∂glich, jeden CSP-Prozess durch eine Coroutine (stapelbare Coroutine) darzustellen.  Dies ist eine viel billigere und skalierbare L√∂sung.  Aber hier werden wir nur kooperatives Multitasking haben.  Wenn der CSP-Prozess pl√∂tzlich die Matrixmultiplikation aufnimmt, wird der Arbeitsthread mit diesem CSP-Prozess und anderen damit verbundenen CSP-Prozessen blockiert. <br><br>  Es kann einen anderen Trick geben.  Angenommen, wir verwenden eine Bibliothek eines Drittanbieters, auf deren Innenseite wir keinen Einfluss haben.  Und innerhalb der Bibliothek werden TLS-Variablen verwendet (d. H. Thread-lokaler Speicher).  Wir rufen die Bibliotheksfunktion einmal auf und die Bibliothek legt den Wert einer TLS-Variablen fest.  Dann "bewegt" sich unsere Coroutine zu einem anderen Arbeitsfaden, und das ist m√∂glich, weil  Im Prinzip k√∂nnen Coroutinen von einem Arbeitsthread zu einem anderen migrieren.  Wir rufen die Bibliotheksfunktion wie folgt auf und die Bibliothek versucht, den Wert der TLS-Variablen zu lesen.  Aber es kann schon eine andere Bedeutung geben!  Und nach einem solchen Fehler zu suchen, wird sehr schwierig sein. <br><br>  Daher m√ºssen Sie die Wahl der Methode zur Implementierung von CSP-shnyh-Prozessen sorgf√§ltig abw√§gen.  Jede der Optionen hat ihre eigenen St√§rken und Schw√§chen. <br><br><h3>  Viele Prozesse sind nicht immer die L√∂sung. </h3><br>  Wie bei den Akteuren ist die F√§higkeit, viele CSP-Prozesse in Ihrem Programm zu erstellen, nicht immer eine L√∂sung f√ºr ein angewandtes Problem, sondern schafft zus√§tzliche Probleme f√ºr sich. <br><br>  Dar√ºber hinaus ist eine schlechte Sichtbarkeit der Vorg√§nge im Programm nur ein Teil des Problems.  Ich m√∂chte mich auf eine weitere Falle konzentrieren. <br><br>  Tatsache ist, dass Sie auf CSP-shnyh-Kan√§len leicht ein Analogon von Deadlock erhalten k√∂nnen.  Prozess A versucht, eine Nachricht auf den vollen Kanal C1 zu schreiben, und Prozess A wird angehalten.  Von Kanal C1 sollte Prozess B gelesen werden, der versucht hat, auf Kanal C2 zu schreiben, der voll ist, und daher wurde Prozess B angehalten.  Und von Kanal C2 sollte Prozess A gelesen werden. Das ist alles, wir haben einen Deadlock. <br><br>  Wenn wir nur zwei CSP-Prozesse haben, k√∂nnen wir einen solchen Deadlock beim Debuggen oder sogar bei der Code√ºberpr√ºfung feststellen.  Wenn wir jedoch Millionen von Prozessen im Programm haben, die aktiv miteinander kommunizieren, steigt die Wahrscheinlichkeit solcher Deadlocks erheblich. <br><br><h2>  Wo soll man suchen, was soll man mitnehmen? </h2><br>  Wenn jemand mit CSP in C ++ arbeiten m√∂chte, ist die Auswahl hier leider nicht so gro√ü wie f√ºr Schauspieler.  Nun, oder ich wei√ü nicht, wo und wie ich suchen soll.  In diesem Fall hoffe ich, dass die Kommentare andere Links teilen. <br><br>  Wenn wir jedoch CSP verwenden m√∂chten, m√ºssen wir uns zun√§chst mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boost.Fiber befassen</a> .  Es gibt Fasern (d. H. Coroutinen) und Kan√§le und sogar Grundelemente auf niedriger Ebene wie Mutex, Bedingung_Variable, Barriere.  All dies kann genommen und verwendet werden. <br><br>  Wenn Sie mit CSP-Prozessen in Form von Threads zufrieden sind, k√∂nnen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer ansehen</a> .  Es gibt auch Analoga von CSP-Kan√§len und komplexe Multithread-Anwendungen auf SObjectizer k√∂nnen ohne Akteure geschrieben werden. <br><br><h1>  Schauspieler gegen CSP </h1><br>  Schauspieler und CSPs sind einander sehr √§hnlich.  Immer wieder stie√ü ich auf die Aussage, dass diese beiden Modelle einander gleichwertig sind.  Das hei√üt,  Was an Akteuren getan werden kann, kann in CSP-Prozessen fast 1: 1 wiederholt werden und umgekehrt.  Sie sagen, dass es sogar mathematisch bewiesen ist.  Aber hier verstehe ich nichts, also kann ich nichts sagen.  Aber nach meinen eigenen Gedanken irgendwo auf der Ebene des allt√§glichen gesunden Menschenverstandes sieht das alles ziemlich plausibel aus.  In einigen F√§llen k√∂nnen Akteure tats√§chlich durch CSP-Prozesse und CSP-Prozesse durch Akteure ersetzt werden. <br><br>  Es gibt jedoch verschiedene Unterschiede zwischen Akteuren und CSPs, anhand derer festgestellt werden kann, wo jedes dieser Modelle vorteilhaft oder nachteilig ist. <br><br><h2>  Kan√§le gegen Mailbox </h2><br>  Ein Schauspieler hat einen einzigen ‚ÄûKanal‚Äú zum Empfangen eingehender Nachrichten - dies ist seine Mailbox, die automatisch f√ºr jeden Schauspieler erstellt wird.  Und der Schauspieler ruft die Nachrichten von dort nacheinander ab, genau in der Reihenfolge, in der sich die Nachrichten in der Mailbox befanden. <br><br>  Und das ist eine ziemlich ernste Frage.  Angenommen, das Postfach des Schauspielers enth√§lt drei Nachrichten: M1, M2 und M3.  Der Schauspieler interessiert sich derzeit nur f√ºr M3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber bevor er zu M3 kommt, extrahiert der Schauspieler zuerst M1, dann M2. </font><font style="vertical-align: inherit;">Und was wird er mit ihnen machen?</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auch im Rahmen dieses Gespr√§chs werden wir nicht auf die selektiven Empfangsmechanismen von Erlang und das Verstecken von Akka eingehen. </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hrend der CSP-shny-Prozess den Kanal ausw√§hlen kann, von dem er aktuell Nachrichten lesen m√∂chte. </font><font style="vertical-align: inherit;">Ein CSP-Prozess kann also drei Kan√§le haben: C1, C2 und C3. </font><font style="vertical-align: inherit;">Derzeit interessiert sich der CSP-Prozess nur f√ºr Nachrichten von C3. </font><font style="vertical-align: inherit;">Diesen Kanal liest der Prozess. </font><font style="vertical-align: inherit;">Und er wird zu den Inhalten der Kan√§le C1 und C2 zur√ºckkehren, wenn er daran interessiert ist.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reaktivit√§t und Proaktivit√§t </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akteure sind in der Regel reaktiv und arbeiten nur, wenn sie eingehende Nachrichten haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hrend CSP-Prozesse auch ohne eingehende Nachrichten einige Arbeit leisten k√∂nnen. </font><font style="vertical-align: inherit;">In einigen Szenarien kann dieser Unterschied eine wichtige Rolle spielen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zustandsautomaten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich sind Akteure Finite-State-Maschinen (KA). </font><font style="vertical-align: inherit;">Wenn es in Ihrem Fachgebiet viele Finite-State-Maschinen gibt und selbst wenn es sich um komplexe, hierarchische Finite-State-Maschinen handelt, k√∂nnen Sie diese daher viel einfacher auf der Grundlage des Akteurmodells implementieren, als indem Sie einem CSP-Prozess eine Raumfahrzeugimplementierung hinzuf√ºgen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In C ++ gibt es noch keine native CSP-Unterst√ºtzung. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Erfahrung mit der Go-Sprache zeigt, wie einfach und bequem es ist, das CSP-Modell zu verwenden, wenn seine Unterst√ºtzung auf der Ebene einer Programmiersprache und ihrer Standardbibliothek implementiert wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Go ist es einfach, "CSP-Prozesse" (auch bekannt als Goroutinen) zu erstellen. Es ist einfach, Kan√§le zu erstellen und damit zu arbeiten. Es gibt eine integrierte Syntax f√ºr die gleichzeitige Arbeit mit mehreren Kan√§len (Go-shny select, die nicht nur zum Lesen, sondern auch zum Schreiben funktioniert). Die Standardbibliothek kennt Goroutins und kann sie wechseln, wenn Goroutin einen blockierenden Aufruf von stdlib ausf√ºhrt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In C ++ gibt es bisher keine Unterst√ºtzung f√ºr stapelbare Coroutinen (auf Sprachebene). </font><font style="vertical-align: inherit;">Daher kann die Arbeit mit CSP in C ++ stellenweise aussehen, wenn nicht sogar wie eine Kr√ºcke, dann ... Das erfordert sicherlich viel mehr Aufmerksamkeit f√ºr sich selbst als im Fall des gleichen Go.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ansatz Nr. 3: Aufgaben (asynchron, Zukunft, wait_all, ...) </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úber den aufgabenbasierten Ansatz in den h√§ufigsten Worten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bedeutung des aufgabenbasierten Ansatzes besteht darin, dass wir bei einer komplexen Operation diese Operation in separate Aufgabenschritte unterteilen, wobei jede Aufgabe (es handelt sich um eine Aufgabe) eine einzelne Unteroperation ausf√ºhrt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir starten diese Aufgaben mit der speziellen Operation async. </font><font style="vertical-align: inherit;">Die asynchrone Operation gibt ein zuk√ºnftiges Objekt zur√ºck, in das nach Abschluss der Aufgabe der von der Aufgabe zur√ºckgegebene Wert platziert wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir N Aufgaben gestartet und N Objekte-Zukunft erhalten haben, m√ºssen wir das alles irgendwie in einer Kette zusammenf√ºgen. </font><font style="vertical-align: inherit;">Es scheint, dass nach Abschluss der Aufgaben Nr. 1 und Nr. 2 die von ihnen zur√ºckgegebenen Werte in Aufgabe Nr. 3 fallen sollten. </font><font style="vertical-align: inherit;">Und wenn Aufgabe Nr. 3 abgeschlossen ist, sollte der zur√ºckgegebene Wert an die Aufgaben Nr. 4, Nr. 5 und Nr. 6 √ºbertragen werden. </font><font style="vertical-align: inherit;">Usw. usw.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr eine solche "Krawatte" werden spezielle Mittel verwendet. </font><font style="vertical-align: inherit;">Wie zum Beispiel die .then () -Methode eines zuk√ºnftigen Objekts sowie die Funktionen wait_all (), wait_any (). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine solche Erkl√§rung ‚Äûan den Fingern‚Äú ist m√∂glicherweise nicht sehr klar. Fahren wir also mit dem Code fort. </font><font style="vertical-align: inherit;">Vielleicht wird in einem Gespr√§ch √ºber einen bestimmten Code die Situation klarer (aber keine Tatsache).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Request_handler-Code f√ºr den aufgabenbasierten Ansatz </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Code zum Verarbeiten einer eingehenden HTTP-Anforderung basierend auf Aufgaben kann folgenderma√üen aussehen: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context &amp; ctx, request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); }); when_all(user_info_ft, original_image_ft).then( [&amp;ctx, req](tuple&lt;future&lt;user_info&gt;, future&lt;image_loaded&gt;&gt; data) { async(ctx.image_mixer_ctx(), [&amp;ctx, req, d=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(data)] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mix_image(get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(d).get().watermark_image(), get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(d).get()); }) .then([req](future&lt;mixed_image&gt; mixed) { async(ctx.http_srv_ctx(), [req, im=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mixed)] { make_reply(...); }); }); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen wir herauszufinden, was hier passiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst erstellen wir eine Aufgabe, die im Kontext unseres eigenen HTTP-Clients gestartet werden soll und Informationen √ºber den Benutzer anfordert. Das zur√ºckgegebene zuk√ºnftige Objekt wird in der Variablen user_info_ft gespeichert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes erstellen wir eine √§hnliche Aufgabe, die auch im Kontext unseres eigenen HTTP-Clients ausgef√ºhrt werden sollte und die das Original-Image l√§dt. Das zur√ºckgegebene zuk√ºnftige Objekt wird in der Variablen original_image_ft gespeichert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes m√ºssen wir warten, bis die ersten beiden Aufgaben abgeschlossen sind. </font><font style="vertical-align: inherit;">Was wir direkt aufschreiben: when_all (user_info_ft, original_image_ft). </font><font style="vertical-align: inherit;">Wenn beide zuk√ºnftigen Objekte ihre Werte erhalten, f√ºhren wir eine weitere Aufgabe aus. </font><font style="vertical-align: inherit;">Diese Aufgabe nimmt die Bitmap mit dem Wasserzeichen und dem Originalbild und f√ºhrt eine weitere Aufgabe im Kontext von ImageMixer aus. </font><font style="vertical-align: inherit;">Diese Aufgabe mischt Bilder und wenn sie abgeschlossen ist, wird eine andere Aufgabe im HTTP-Serverkontext gestartet, die eine HTTP-Antwort generiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht ist eine solche Erkl√§rung dessen, was im Code passiert, nicht viel gekl√§rt. </font><font style="vertical-align: inherit;">Lassen Sie uns deshalb unsere Aufgaben nummerieren:</font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/5k/c0/mr/5kc0mrvqnxdf6lp4-p0wgn1nj7w.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und schauen wir uns die Abh√§ngigkeiten zwischen ihnen an (aus denen die Reihenfolge der Aufgaben hervorgeht): </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zu/j4/g4/zuj4g4wwg0wxmhazj5k5rdb8pgu.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und wenn wir dieses Bild jetzt auf unseren Quellcode legen, dann hoffe ich, dass es klarer wird: </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/sw/at/uz/swatuzio1z33-ei16gquj-ss5mg.jpeg"></td></tr></tbody></table><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Merkmale des aufgabenbasierten Ansatzes </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste Merkmal, das bereits offensichtlich sein sollte, ist die Sichtbarkeit des Codes in Task. </font><font style="vertical-align: inherit;">Nicht alles ist gut mit ihr. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier k√∂nnen Sie so etwas wie die R√ºckrufh√∂lle erw√§hnen. </font><font style="vertical-align: inherit;">Die Programmierer von Node.j sind sehr vertraut damit. </font><font style="vertical-align: inherit;">Aber auch C ++ - Spitznamen, die eng mit Task zusammenarbeiten, tauchen in diese H√∂lle des R√ºckrufs ein.</font></font><br><br><h3>  Fehlerbehandlung </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres interessantes Feature ist die Fehlerbehandlung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einerseits kann es bei Verwendung von Async und Future mit der √úbermittlung von Fehlerinformationen an die interessierte Partei noch einfacher sein als bei Akteuren oder CSP. </font><font style="vertical-align: inherit;">Wenn im CSP-Prozess A eine Anforderung an Prozess B sendet und auf eine Antwortnachricht wartet, m√ºssen wir entscheiden, wie der Fehler an Prozess A √ºbermittelt werden soll, wenn B beim Ausf√ºhren der Anforderung auf einen Fehler st√∂√üt:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder wir machen einen separaten Nachrichtentyp und einen Kanal f√ºr den Empfang; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder wir geben das Ergebnis mit einer einzelnen Nachricht zur√ºck, die f√ºr ein normales und fehlerhaftes Ergebnis std :: variante ist. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und im Falle der Zukunft ist alles einfacher: Wir extrahieren aus der Zukunft entweder ein normales Ergebnis oder eine Ausnahme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andererseits k√∂nnen wir leicht auf eine Kaskade von Fehlern sto√üen. </font><font style="vertical-align: inherit;">Beispielsweise ist in Aufgabe Nr. 1 eine Ausnahme aufgetreten. Diese Ausnahme fiel in das zuk√ºnftige Objekt, das an Aufgabe Nr. 2 √ºbergeben wurde. </font><font style="vertical-align: inherit;">In Aufgabe Nr. 2 haben wir versucht, den Wert aus der Zukunft zu √ºbernehmen, aber eine Ausnahme erhalten. </font><font style="vertical-align: inherit;">Und h√∂chstwahrscheinlich werden wir die gleiche Ausnahme rauswerfen. </font><font style="vertical-align: inherit;">Dementsprechend wird es in die n√§chste Zukunft fallen, die zu Aufgabe Nr. 3 gehen wird. </font><font style="vertical-align: inherit;">Es wird auch eine Ausnahme geben, die m√∂glicherweise auch ver√∂ffentlicht wird.</font></font> Usw. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn unsere Ausnahmen protokolliert werden, sehen wir im Protokoll die wiederholte Wiederholung derselben Ausnahme, die von einer Aufgabe in der Kette zu einer anderen Aufgabe wechselt. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgaben und Timer / Timeouts abbrechen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres sehr interessantes Merkmal der aufgabenbasierten Kampagne ist das Abbrechen von Aufgaben, wenn ein Fehler aufgetreten ist. </font><font style="vertical-align: inherit;">Nehmen wir an, wir haben 150 Aufgaben erstellt, die ersten 10 erledigt und festgestellt, dass es keinen Sinn macht, die Arbeit fortzusetzen. </font><font style="vertical-align: inherit;">Wie stornieren wir die verbleibenden 140? </font><font style="vertical-align: inherit;">Dies ist eine sehr, sehr gute Frage :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere √§hnliche Frage ist, wie man Freunde mit Timern und Timeouts zu Aufgaben macht. </font><font style="vertical-align: inherit;">Angenommen, wir greifen auf ein externes System zu und m√∂chten die Wartezeit auf 50 Millisekunden beschr√§nken. </font><font style="vertical-align: inherit;">Wie k√∂nnen wir den Timer einstellen, wie wir auf den Ablauf des Timeouts reagieren, wie wir die Task-Kette unterbrechen, wenn das Timeout abgelaufen ist? </font><font style="vertical-align: inherit;">Wieder ist Fragen einfacher als Antworten :)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrug </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, und um √ºber die Funktionen des aufgabenbasierten Ansatzes zu sprechen. </font><font style="vertical-align: inherit;">In dem gezeigten Beispiel wurde ein wenig betrogen:</font></font><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier habe ich zwei Aufgaben an den Kontext unseres eigenen HTTP-Servers gesendet, von denen jeder eine Blockierungsoperation im Inneren ausf√ºhrt. </font><font style="vertical-align: inherit;">Um zwei Anforderungen an Dienste von Drittanbietern parallel verarbeiten zu k√∂nnen, mussten Sie hier Ihre eigenen Ketten asynchroner Aufgaben erstellen. </font><font style="vertical-align: inherit;">Ich habe dies jedoch nicht getan, um die L√∂sung mehr oder weniger sichtbar zu machen und auf die Pr√§sentationsfolie zu passen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schauspieler / CSP vs Aufgaben </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben drei Ans√§tze untersucht und festgestellt, dass der aufgabenbasierte Ansatz keinem von ihnen √§hnelt, wenn Akteure und CSP-Prozesse einander √§hnlich sind. Und es k√∂nnte den Anschein haben, dass Actors / CSP im Gegensatz zu Task stehen sollten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber ich pers√∂nlich mag eine andere Sichtweise. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir √ºber das Modell der Akteure und CSP sprechen, dann sprechen wir √ºber die Zerlegung unserer Aufgabe. In unserer Aufgabe w√§hlen wir separate unabh√§ngige Entit√§ten aus und beschreiben die Schnittstellen dieser Entit√§ten: Welche Nachrichten senden sie, welche empfangen sie, √ºber welche Kan√§le gehen die Nachrichten.</font></font><br><br>  Das hei√üt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Zusammenarbeit mit Schauspielern und CSP sprechen wir √ºber Schnittstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nehmen wir jedoch an, wir teilen die Aufgabe in separate Akteure und CSP-Prozesse auf. Wie genau machen sie ihren Job? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir den aufgabenbasierten Ansatz aufgreifen, sprechen wir √ºber die Implementierung. Informationen dar√ºber, wie eine bestimmte Arbeit ausgef√ºhrt wird, welche Unteroperationen ausgef√ºhrt werden, in welcher Reihenfolge, wie diese Unteroperationen gem√§√ü Daten verbunden sind usw.</font></font><br><br>  Das hei√üt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Arbeit mit Task sprechen wir √ºber die Implementierung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher sind Schauspieler / CSP und Aufgaben nicht so sehr gegens√§tzlich, sondern erg√§nzen sich. </font><font style="vertical-align: inherit;">Akteure / CSPs k√∂nnen verwendet werden, um Aufgaben zu zerlegen und Schnittstellen zwischen Komponenten zu definieren. </font><font style="vertical-align: inherit;">Und Aufgaben k√∂nnen dann verwendet werden, um bestimmte Komponenten zu implementieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie beispielsweise Actor verwenden, haben wir eine Entit√§t wie ImageMixer, die mit Bildern im Thread-Pool bearbeitet werden muss. </font><font style="vertical-align: inherit;">Im Allgemeinen hindert uns nichts daran, den ImageMixer-Akteur f√ºr den aufgabenbasierten Ansatz zu verwenden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wo soll man suchen, was soll man mitnehmen? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie mit Aufgaben in C ++ arbeiten m√∂chten, k√∂nnen Sie sich die Standardbibliothek des kommenden C ++ 20 ansehen. Sie haben der Zukunft bereits die Methode .then () sowie die freien Funktionen wait_all () und wait_any hinzugef√ºgt. Siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppreference f√ºr Details</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist auch schon weit von einer neuen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async ++ Bibliothek entfernt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In dem gibt es im Prinzip alles, was Sie brauchen, nur ein bisschen mit einer anderen Sauce. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und es gibt eine noch √§ltere </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft PPL-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek </font><font style="vertical-align: inherit;">. Was auch alles gibt, was Sie brauchen, aber mit Ihrer eigenen Sauce.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separate Erg√§nzung zur Intel TBB-Bibliothek. </font><font style="vertical-align: inherit;">Es wurde in der Geschichte √ºber den aufgabenbasierten Ansatz nicht erw√§hnt, da Taskgraphen von TBB meiner Meinung nach bereits ein Datenflussansatz sind. </font><font style="vertical-align: inherit;">Und wenn dieser Bericht fortgesetzt wird, wird das Gespr√§ch √ºber Intel TBB sicherlich kommen, aber im Kontext der Geschichte √ºber den Datenfluss.</font></font></blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interessanter </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K√ºrzlich gab es hier auf Habr√© einen Artikel von Anton Polukhin: "Wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bereiten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uns </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">auf C ++ 20 vor. Coroutines TS anhand eines realen Beispiels</font></a><font style="vertical-align: inherit;"> ." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es geht darum, einen aufgabenbasierten Ansatz mit stapellosen Coroutinen aus C ++ 20 zu kombinieren. </font><font style="vertical-align: inherit;">Und es stellte sich heraus, dass der Code auf der Grundlage der Lesbarkeit von Aufgaben der Lesbarkeit von Code in CSP-Prozessen nahe kam. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich also jemand f√ºr den aufgabenbasierten Ansatz interessiert, ist es sinnvoll, diesen Artikel zu lesen.</font></font><br><br><h1>  Fazit </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, es ist Zeit, mit den Ergebnissen fortzufahren, da es nicht so viele davon gibt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Hauptsache, die ich sagen m√∂chte, ist, dass Sie in der modernen Welt m√∂glicherweise nur dann Multithreading ben√∂tigen, wenn Sie ein Framework entwickeln oder eine bestimmte Aufgabe auf niedriger Ebene l√∂sen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wenn Sie Anwendungscode schreiben, ben√∂tigen Sie kaum nackte Threads, Synchronisationsprimitive auf niedriger Ebene oder eine Art sperrfreier Algorithmen sowie sperrfreie Container. </font><font style="vertical-align: inherit;">Es gibt seit langem bew√§hrte Ans√§tze, die sich bew√§hrt haben:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schauspieler </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kommunikation sequentieller Prozesse (CSP) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgaben (Async, Versprechen, Zukunft, ...) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datenfl√ºsse </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reaktive Programmierung </font></font></li><li>  ... </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und vor allem gibt es in C ++ vorgefertigte Tools f√ºr sie. </font><font style="vertical-align: inherit;">Sie m√ºssen nichts radeln, Sie k√∂nnen es nehmen, versuchen und, wenn es Ihnen gef√§llt, in Betrieb nehmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So einfach: nehmen, versuchen und in Betrieb nehmen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430672/">https://habr.com/ru/post/de430672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430662/index.html">√úberwachen von Windows-Servern unter reinem MS SQL und wie ich es heimlich implementiert habe</a></li>
<li><a href="../de430664/index.html">Die Rolle des Teamleiters bei der Rekrutierung</a></li>
<li><a href="../de430666/index.html">Wie man die Teameffektivit√§t bewertet</a></li>
<li><a href="../de430668/index.html">Allein auf dem Feld ist kein Krieger. Der Weg zu effektiver Teamarbeit</a></li>
<li><a href="../de430670/index.html">Arrangement Management</a></li>
<li><a href="../de430674/index.html">Die Logik der Erstellung universeller Arbeitspl√§ne</a></li>
<li><a href="../de430676/index.html">Altert√ºmer: shshshsh, sssssss, VOIP, BBS und andere Freunde des Modems</a></li>
<li><a href="../de430678/index.html">Test von zehn Dimmern mit LED-Lampen</a></li>
<li><a href="../de430680/index.html">Schreiben eines einfachen Prozessors und einer Umgebung daf√ºr</a></li>
<li><a href="../de430682/index.html">Drei Jahre Mond-Mikrosatelliten-Projekt: Stadien des Erwachsenwerdens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>