<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🔧 ⛅️ 🏩 Textversion des Berichts „Actors vs CSP vs Tasks ...“ mit C ++ CoreHard Autumn 2018 🤫 🤹🏽 ✴️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anfang November war Minsk Gastgeber der nächsten C ++ - Konferenz C ++ CoreHard Herbst 2018-Konferenz. Sie lieferte einen Kapitänsbericht „Actors vs C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Textversion des Berichts „Actors vs CSP vs Tasks ...“ mit C ++ CoreHard Autumn 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430672/">  Anfang November war Minsk Gastgeber der nächsten C ++ - Konferenz C ++ CoreHard Herbst 2018-Konferenz. Sie lieferte einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitänsbericht „Actors vs CSP vs Tasks ...“</a> , in dem dargelegt wurde, wie übergeordnete Anwendungen als „in C ++ aussehen können“. Bare Multithreading “, wettbewerbsfähige Programmiermodelle.  Unter der geschnittenen Version dieses Berichts in einen Artikel umgewandelt.  Gekämmt, stellenweise beschnitten, stellenweise ergänzt. <br><br>  Ich möchte diese Gelegenheit nutzen, um der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoreHard-</a> Community für die Organisation der nächsten großen Konferenz in Minsk und für die Gelegenheit zum Sprechen zu danken.  Und auch für die zeitnahe Veröffentlichung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Videoberichten von Berichten auf YouTube</a> . <br><br>  Kommen wir also zum Hauptthema der Konversation.  Welche Ansätze können wir verwenden, um die Multithread-Programmierung in C ++ zu vereinfachen, wie einige dieser Ansätze im Code aussehen, welche Funktionen bestimmten Ansätzen inhärent sind, was ihnen gemeinsam ist usw. <br><br>  Hinweis: In der ursprünglichen Präsentation des Berichts wurden Fehler und Tippfehler gefunden. Daher werden im Artikel Folien aus der aktualisierten und bearbeiteten Version verwendet, die in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Slides</a> oder auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SlideShare zu finden sind</a> . <br><br><h1>  Nacktes Multithreading ist böse! </h1><br>  Sie müssen mit der wiederholten Banalität beginnen, die jedoch immer noch relevant bleibt: <br><blockquote>  Multithread-C ++ - Programmierung über nackte Threads, Mutex und Bedingungsvariablen ist <b>Schweiß</b> , <b>Schmerz</b> und <b>Blut</b> . </blockquote><a name="habracut"></a><br>  Ein gutes Beispiel wurde kürzlich hier in diesem Artikel hier auf Habré beschrieben: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Architektur des Metaservers des mobilen Online-Shooters Tacticool</a> ".  Darin sprachen die Jungs darüber, wie sie es anscheinend geschafft haben, eine ganze Reihe von Rechen zu sammeln, die mit der Entwicklung von Multithread-Code in C und C ++ zusammenhängen.  Es gab "Memory Passes" als Ergebnis von Rennen und geringe Leistung aufgrund erfolgloser Parallelisierung. <br><br>  Infolgedessen endete alles ganz natürlich: <br><blockquote>  Nachdem wir einige Wochen damit verbracht hatten, die kritischsten Fehler zu finden und zu beheben, entschieden wir, dass es <u>einfacher war, alles von Grund auf neu zu schreiben,</u> als zu versuchen, alle Mängel der aktuellen Lösung zu beheben. </blockquote><br>  Die Benutzer haben C / C ++ gegessen, während sie an der ersten Version ihres Servers gearbeitet haben, und den Server in einer anderen Sprache neu geschrieben. <br><br>  Eine hervorragende Demonstration, wie Entwickler in der realen Welt außerhalb unserer gemütlichen C ++ - Community die Verwendung von C ++ ablehnen, selbst wenn die Verwendung von C ++ noch angemessen und gerechtfertigt ist. <br><br><h2>  Aber warum? </h2><br>  Aber warum, wenn wiederholt gesagt wird, dass "nacktes Multithreading" in C ++ böse ist, verwenden die Leute es weiterhin mit Ausdauer, die einer besseren Anwendung würdig ist?  Was ist schuld: <br><br><ul><li>  Unwissenheit? </li><li>  Faulheit? </li><li>  NIH-Syndrom? </li></ul><br>  Schließlich gibt es bei weitem keinen einzigen Ansatz, der durch die Zeit und viele Projekte getestet wurde.  Insbesondere: <br><br><ul><li>  Schauspieler </li><li>  Kommunikation sequentieller Prozesse (CSP) </li><li>  Aufgaben (Async, Versprechen, Zukunft, ...) </li><li>  Datenflüsse </li><li>  reaktive Programmierung </li><li>  ... </li></ul><br>  Es ist zu hoffen, dass der Hauptgrund immer noch Unwissenheit ist.  Es ist unwahrscheinlich, dass dies an Universitäten gelehrt wird.  Junge Berufstätige, die in den Beruf eintreten, nutzen das Wenige, das sie bereits kennen.  Und wenn dann der Wissensspeicher nicht aufgefüllt wird, verwenden die Benutzer weiterhin nackte Threads, Mutexe und Bedingungsvariablen. <br><br>  Heute werden wir über die ersten drei Ansätze aus dieser Liste sprechen.  Und wir werden nicht abstrakt sprechen, sondern am Beispiel einer einfachen Aufgabe.  Versuchen wir zu zeigen, wie der Code, der dieses Problem löst, mithilfe von Actor, CSP-Prozessen und -Kanälen sowie mithilfe von Task aussehen wird. <br><br><h1>  Herausforderung für Experimente </h1><br>  Es ist erforderlich, einen HTTP-Server zu implementieren, der: <br><br><ul><li>  akzeptiert die Anfrage (Bild-ID, Benutzer-ID); </li><li>  gibt ein Bild mit "Wasserzeichen", das für diesen Benutzer einzigartig ist. </li></ul><br>  Beispielsweise kann ein solcher Server von einem kostenpflichtigen Dienst benötigt werden, der Inhalte per Abonnement verteilt.  Wenn das Bild von diesem Dienst irgendwo auftaucht, können Sie anhand der Wasserzeichen erkennen, wer Sauerstoff blockieren muss. <br><br>  Die Aufgabe ist abstrakt, sie wurde speziell für diesen Bericht unter dem Einfluss unseres Demo-Projekts Shrimp formuliert (wir haben bereits darüber gesprochen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 3</a> ). <br><br>  Dies funktioniert auf unserem HTTP-Server wie folgt: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/bq/qo/zk/bqqozkulonydk1ccnzog-kzv610.jpeg"></td></tr></tbody></table><br>  Nachdem wir eine Anfrage von einem Kunden erhalten haben, wenden wir uns an zwei externe Dienste: <br><br><ul><li>  Der erste gibt uns Benutzerinformationen zurück.  Einschließlich von dort erhalten wir ein Bild mit "Wasserzeichen"; </li><li>  Die zweite gibt uns das Originalbild zurück </li></ul><br>  Beide Dienste arbeiten unabhängig voneinander und wir können gleichzeitig auf beide zugreifen. <br><br>  Da die Verarbeitung von Anforderungen unabhängig voneinander erfolgen kann und sogar einige Aktionen bei der Verarbeitung einer einzelnen Anforderung parallel ausgeführt werden können, bietet sich die Nutzung der Wettbewerbsfähigkeit an.  Am einfachsten fällt Ihnen ein, für jede eingehende Anfrage einen eigenen Thread zu erstellen: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/g0/f9/ps/g0f9ps3vmq-osh-hy0i71ut_kfw.jpeg"></td></tr></tbody></table><br>  Das One-Request = One-Workflow-Modell ist jedoch zu teuer und lässt sich nicht gut skalieren.  Das brauchen wir nicht. <br><br>  Selbst wenn wir uns der Anzahl der Workflows verschwenderisch nähern, brauchen wir immer noch eine kleine Anzahl davon: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/ve/yl/vv/veylvvoaisqxod1-0nsp4vhh80e.jpeg"></td></tr></tbody></table><br>  Hier benötigen wir einen separaten Stream zum Empfangen eingehender HTTP-Anforderungen, einen separaten Stream für unsere eigenen ausgehenden HTTP-Anforderungen und einen separaten Stream zum Koordinieren der Verarbeitung empfangener HTTP-Anforderungen.  Neben einem Pool von Workflows zum Ausführen von Vorgängen an Bildern (da die Manipulationen an Bildern gut parallel sind, wird durch die gleichzeitige Verarbeitung eines Bildes durch mehrere Streams die Verarbeitungszeit verkürzt). <br><br>  Daher ist es unser Ziel, eine große Anzahl von gleichzeitig eingehenden Anforderungen auf einer kleinen Anzahl von Arbeitsthreads zu verarbeiten.  Schauen wir uns an, wie wir dies durch verschiedene Ansätze erreichen. <br><br><h2>  Einige wichtige Haftungsausschlüsse </h2><br>  Bevor Sie mit der Hauptgeschichte fortfahren und Codebeispiele analysieren, müssen Sie einige Notizen machen. <br><br>  Erstens sind alle folgenden Beispiele nicht an ein bestimmtes Framework oder eine bestimmte Bibliothek gebunden.  Alle Übereinstimmungen in den Namen der API-Aufrufe sind zufällig und unbeabsichtigt. <br><br>  Zweitens gibt es in den folgenden Beispielen keine Fehlerbehandlung.  Dies geschieht bewusst, damit die Folien kompakt und sichtbar sind.  Und damit das Material in die für den Bericht vorgesehene Zeit passt. <br><br>  Drittens verwenden die Beispiele einen bestimmten Entitätsausführungskontext, der Informationen darüber enthält, was sonst noch im Programm vorhanden ist.  Das Befüllen dieser Entität hängt vom Ansatz ab.  Bei Akteuren enthält execute_context Links zu anderen Akteuren.  Im Fall von CSP gibt es im Ausführungskontext CSP-Kanäle für die Kommunikation mit anderen CSP-Prozessen.  Usw. <br><br><h1>  Ansatz 1: Schauspieler </h1><br><h2>  Schauspieler Modell auf den Punkt gebracht </h2><br>  Bei Verwendung des Modells der Akteure wird die Lösung aus separaten Objekt-Akteuren aufgebaut, von denen jeder seinen eigenen privaten Zustand hat und auf den nur der Schauspieler selbst zugreifen kann. <br><br>  Akteure interagieren über asynchrone Nachrichten miteinander.  Jeder Akteur verfügt über ein eigenes Postfach (Nachrichtenwarteschlange), in dem an den Akteur gesendete Nachrichten gespeichert und von dort zur weiteren Verarbeitung abgerufen werden. <br><br>  Schauspieler arbeiten nach sehr einfachen Prinzipien: <br><br><ul><li>  Ein Schauspieler ist eine Einheit mit Verhalten. </li><li>  Akteure reagieren auf eingehende Nachrichten; </li><li>  Nach Erhalt der Nachricht kann der Schauspieler: <br><ul><li>  Senden Sie eine (endgültige) Anzahl von Nachrichten an andere Akteure. </li><li>  eine (endgültige) Anzahl neuer Akteure schaffen; </li><li>  Definieren Sie ein neues Verhalten für die Verarbeitung nachfolgender Nachrichten. </li></ul></li></ul><br>  Innerhalb einer Anwendung können Akteure auf verschiedene Arten implementiert werden: <br><br><ul><li>  Jeder Akteur kann als separater Betriebssystem-Stream dargestellt werden (dies geschieht beispielsweise in der C :: Just :: Thread Pro Actor Edition-Bibliothek). </li><li>  Jeder Schauspieler kann als stapelbare Coroutine dargestellt werden. </li><li>  Jeder Akteur kann als ein Objekt dargestellt werden, in dem jemand Rückrufmethoden aufruft. </li></ul><br>  In unserer Entscheidung werden wir Akteure in Form von Objekten mit Rückrufen verwenden und Coroutinen für den CSP-Ansatz belassen. <br><br><h2>  Entscheidungsschema basierend auf dem Modell der Akteure </h2><br>  Basierend auf den Akteuren sieht das allgemeine Schema zur Lösung unseres Problems folgendermaßen aus: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/di/f7/pn/dif7pngijjde8aizja_skqy58oo.jpeg"></td></tr></tbody></table><br>  Wir werden Akteure haben, die am Anfang des HTTP-Servers erstellt werden und die ganze Zeit existieren, während der HTTP-Server arbeitet.  Dies sind Akteure wie: HttpSrv, UserChecker, ImageDownloader, ImageMixer. <br><br>  Nach Erhalt einer neuen eingehenden HTTP-Anforderung erstellen wir eine neue Instanz des RequestHandler-Akteurs, die nach einer Antwort auf die eingehende HTTP-Anforderung zerstört wird. <br><br><h2>  RequestHandler Actor Code </h2><br>  Die Implementierung des Request_Handler-Akteurs, der die Verarbeitung einer eingehenden HTTP-Anforderung koordiniert, kann folgendermaßen aussehen: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_handler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> some_basic_type { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> execution_context context_; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request request_; optional&lt;user_info&gt; user_info_; optional&lt;image_loaded&gt; image_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_user_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_info info)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_image_loaded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image_loaded image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_mixed_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mixed_image image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_mix_images_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; ... <span class="hljs-comment"><span class="hljs-comment">//     . }; void request_handler::on_start() { send(context_.user_checker(), check_user{request_.user_id(), self()}); send(context_.image_downloader(), download_image{request_.image_id(), self()}); } void request_handler::on_user_info(user_info info) { user_info_ = std::move(info); if(image_) send_mix_images_request(); } void request_handler::on_image_loaded(image_loaded image) { image_ = std::move(image); if(user_info_) send_mix_images_request(); } void request_handler::send_mix_images_request() { send(context_.image_mixer(), mix_images{user_info-&gt;watermark_image(), *image_, self()}); } void request_handler::on_mixed_image(mixed_image image) { send(context_.http_srv(), reply{..., std::move(image), ...}); }</span></span></code> </pre> <br>  Lassen Sie uns diesen Code analysieren. <br><br>  Wir haben eine Klasse, in deren Attributen wir speichern oder speichern werden, was wir zur Verarbeitung der Anforderung benötigen.  Auch in dieser Klasse gibt es eine Reihe von Rückrufen, die zu der einen oder anderen Zeit aufgerufen werden. <br><br>  Wenn gerade ein Akteur erstellt wurde, wird zunächst der Rückruf on_start () aufgerufen.  Darin senden wir zwei Nachrichten an andere Akteure.  Erstens ist dies eine check_user-Nachricht, um die Client-ID zu überprüfen.  Zweitens ist dies eine download_image-Nachricht zum Herunterladen des Originalbilds. <br><br>  In jeder der gesendeten Nachrichten übergeben wir einen Link an uns selbst (ein Aufruf der self () -Methode gibt einen Link an den Akteur zurück, für den self () aufgerufen wurde).  Dies ist notwendig, damit unser Schauspieler eine Nachricht als Antwort senden kann.  Wenn wir beispielsweise in der check_user-Nachricht keinen Link zu unserem Akteur senden, weiß der UserChecker-Akteur nicht, an wen er die Benutzerinformationen senden soll. <br><br>  Wenn eine user_info-Nachricht mit Benutzerinformationen als Antwort an uns gesendet wird, wird der Rückruf on_user_info () aufgerufen.  Und wenn die image_loaded-Nachricht an uns gesendet wird, ruft unser Akteur den Rückruf on_image_loaded () auf.  Und jetzt sehen wir in diesen beiden Rückrufen eine Funktion, die dem Modell der Akteure eigen ist: Wir wissen nicht genau, in welcher Reihenfolge wir Antwortnachrichten erhalten.  Daher müssen wir unseren Code so schreiben, dass er nicht von der Reihenfolge abhängt, in der die Nachrichten ankommen.  Daher speichern wir in jedem der Prozessoren zuerst die empfangenen Informationen im entsprechenden Attribut und prüfen dann, ob wir bereits alle benötigten Informationen gesammelt haben.  Wenn ja, dann können wir weitermachen.  Wenn nicht, werden wir weiter warten. <br><br>  Aus diesem Grund haben wir ons in on_user_info () und on_image_loaded (), wenn send_mix_images_request () aufgerufen wird. <br><br><blockquote>  Grundsätzlich kann es in den Implementierungen des Modells der Akteure Mechanismen wie selektives Empfangen von Erlang oder Verstecken von Akka geben, über die Sie die Verarbeitungsreihenfolge eingehender Nachrichten manipulieren können. Wir werden heute jedoch nicht darüber sprechen, um nicht in den Dschungel der Details verschiedener Implementierungen des Modells einzutauchen Schauspieler. </blockquote><br>  Wenn also alle Informationen empfangen werden, die wir von UserChecker und ImageDownloader benötigen, wird die Methode send_mix_images_request () aufgerufen, bei der die Nachricht mix_images an den ImageMixer-Akteur gesendet wird.  Der Rückruf on_mixed_image () wird aufgerufen, wenn wir eine Antwortnachricht mit dem resultierenden Bild erhalten.  Hier senden wir dieses Bild an den HttpSrv-Akteur und warten, bis HttpSrv eine HTTP-Antwort bildet und den unnötigen RequestHandler zerstört (obwohl im Prinzip nichts den RequestHandler-Akteur daran hindert, sich im Rückruf on_mixed_image () selbst zu zerstören). <br><br>  Das ist alles <br><br>  Die Implementierung des RequestHandler-Akteurs erwies sich als recht umfangreich.  Dies liegt jedoch daran, dass wir eine Klasse mit Attributen und Rückrufen beschreiben und dann auch Rückrufe implementieren mussten.  Die Logik der Arbeit von RequestHandler ist jedoch sehr trivial, und es ist einfach, sie trotz der Menge an Code in der request_handler-Klasse zu verstehen. <br><br><h2>  Merkmale, die den Schauspielern eigen sind </h2><br>  Jetzt können wir ein paar Worte zu den Merkmalen des Modells der Schauspieler sagen. <br><br><h3>  Reaktoren </h3><br>  Akteure reagieren in der Regel nur auf eingehende Nachrichten.  Es gibt Nachrichten - der Schauspieler verarbeitet sie.  Keine Nachrichten - der Schauspieler tut nichts. <br><br>  Dies gilt insbesondere für Implementierungen des Actors Model, bei denen Actors als Objekte mit Rückrufen dargestellt werden.  Das Framework ruft den Rückruf des Akteurs ab. Wenn der Akteur die Kontrolle über den Rückruf nicht zurückgibt, kann das Framework keine anderen Akteure im selben Kontext bedienen. <br><br><h3>  Schauspieler sind überladen </h3><br>  Bei Schauspielern können wir Schauspieler und Produzenten sehr leicht dazu bringen, Nachrichten für Konsumenten-Schauspieler in einem viel schnelleren Tempo zu generieren, als Schauspieler-Konsumenten verarbeiten können. <br><br>  Dies führt dazu, dass die Warteschlange eingehender Nachrichten für den Akteur-Verbraucher ständig wächst.  Warteschlangenwachstum, d.h.  Ein erhöhter Speicherverbrauch in der Anwendung verringert die Geschwindigkeit der Anwendung.  Dies führt zu einem noch schnelleren Wachstum der Warteschlange, und infolgedessen kann sich die Anwendung verschlechtern und die Inoperabilität vollständig beeinträchtigen. <br><br>  All dies ist eine direkte Folge der asynchronen Interaktion der Akteure.  Weil der Sendevorgang im Allgemeinen nicht blockiert.  Und es zu blockieren ist nicht einfach, weil  Ein Schauspieler kann sich selbst schicken.  Und wenn die Warteschlange für den Schauspieler voll ist, wird der Schauspieler beim Senden an sich selbst blockiert und dies beendet seine Arbeit. <br><br>  Bei der Arbeit mit Schauspielern muss dem Problem der Überlastung ernsthafte Aufmerksamkeit gewidmet werden. <br><br><h3>  Viele Schauspieler sind nicht immer die Lösung. </h3><br>  Akteure sind in der Regel leichte Einheiten, und es besteht die Versuchung, sie in ihrer Anwendung in großer Anzahl zu erstellen.  Sie können zehntausend Schauspieler und hunderttausend und eine Million erstellen.  Und sogar hundert Millionen Schauspieler, wenn Eisen es Ihnen erlaubt. <br><br>  Das Problem ist jedoch, dass das Verhalten einer sehr großen Anzahl von Akteuren schwer zu verfolgen ist.  Das heißt,  Möglicherweise haben Sie einige Schauspieler, die eindeutig richtig funktionieren.  Einige Schauspieler, die entweder offensichtlich falsch oder gar nicht arbeiten, und Sie wissen es genau.  Aber es kann eine große Anzahl von Schauspielern geben, über die Sie nichts wissen: Arbeiten sie überhaupt, funktionieren sie richtig oder falsch?  Und das alles, denn wenn Sie hundert Millionen autonome Einheiten mit Ihrer eigenen Verhaltenslogik in Ihrem Programm haben, ist die Überwachung für alle sehr schwierig. <br><br>  Daher kann sich herausstellen, dass wir beim Erstellen einer großen Anzahl von Akteuren in der Anwendung unser angewandtes Problem nicht lösen, sondern ein anderes Problem erhalten.  Daher kann es für uns von Vorteil sein, einfache Akteure, die eine einzelne Aufgabe lösen, zugunsten komplexerer und schwererer Akteure, die mehrere Aufgaben ausführen, aufzugeben.  Aber dann wird es weniger solche "schweren" Akteure in der Anwendung geben und es wird für uns einfacher sein, ihnen zu folgen. <br><br><h2>  Wo soll man suchen, was soll man mitnehmen? </h2><br>  Wenn jemand versuchen möchte, mit Schauspielern in C ++ zu arbeiten, macht es keinen Sinn, eigene Fahrräder zu bauen. Es gibt mehrere vorgefertigte Lösungen, insbesondere: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer</a> (Unterstützung des heimischen Herstellers!) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Actor Framework (CAF)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QP / C ++</a> </li></ul><br>  Diese drei Optionen sind lebendig, weiterentwickelnd, plattformübergreifend und dokumentiert.  Sie können sie auch kostenlos testen.  Weitere Optionen mit unterschiedlichem Grad an [nicht] Frische finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Liste auf Wikipedia</a> . <br><br>  SObjectizer und CAF sind für die Verwendung in Aufgaben auf relativ hoher Ebene konzipiert, bei denen Ausnahmen und dynamischer Speicher angewendet werden können.  Und das QP / C ++ - Framework kann für diejenigen von Interesse sein, die an der Embedded-Entwicklung beteiligt sind  Unter dieser Nische ist er "eingesperrt". <br><br><h1>  Ansatz 2: CSP (Kommunikation sequentieller Prozesse) </h1><br><h2>  CSP an den Fingern und ohne Matan </h2><br>  Das CSP-Modell ist dem Actors-Modell sehr ähnlich.  Wir bauen unsere Lösung auch aus einer Reihe autonomer Entitäten auf, von denen jede ihren eigenen privaten Status hat und nur über asynchrone Nachrichten mit anderen Entitäten interagiert. <br><br>  Nur diese Entitäten im CSP-Modell werden als "Prozesse" bezeichnet. <br><br>  Prozesse in CSP sind leicht und ohne Parallelisierung ihrer Arbeit im Inneren.  Wenn wir etwas parallelisieren müssen, starten wir einfach mehrere CSP-Prozesse, in denen es keine Parallelisierung mehr gibt. <br><br>  CSP-Prozesse interagieren über asynchrone Nachrichten miteinander, aber Nachrichten werden nicht wie im Modell der Akteure an Postfächer gesendet, sondern an Kanäle.  Kanäle können als Nachrichtenwarteschlangen betrachtet werden, die normalerweise eine feste Größe haben. <br><br>  Im Gegensatz zum Schauspieler-Modell, bei dem für jeden Akteur automatisch ein Postfach erstellt wird, müssen Kanäle im CSP explizit erstellt werden.  Und wenn wir die beiden Prozesse brauchen, um miteinander zu interagieren, müssen wir den Kanal selbst erstellen und dann dem ersten Prozess sagen "Sie werden hier schreiben", und der zweite Prozess sollte sagen: "Sie werden hier von hier aus lesen." <br><br>  Gleichzeitig haben die Kanäle mindestens zwei Operationen, die explizit aufgerufen werden müssen.  Die erste ist die Schreib- (Sende-) Operation, um eine Nachricht in den Kanal zu schreiben. <br><br>  Zweitens ist es eine Lese- (Empfangs-) Operation, um eine Nachricht von einem Kanal zu lesen.  Und die Notwendigkeit, Read / Receive explizit aufzurufen, unterscheidet CSP vom Actors Model, weil  Im Fall von Akteuren kann die Lese- / Empfangsoperation im Allgemeinen vor dem Akteur verborgen sein.  Das heißt,  Das Actor Framework kann Nachrichten aus der Actor-Warteschlange abrufen und einen Handler (Callback) für die abgerufene Nachricht aufrufen. <br><br>  Während der CSP-Prozess selbst den Zeitpunkt für den Lese- / Empfangsanruf auswählen muss, muss der CSP-Prozess bestimmen, welche Nachricht er empfangen hat, und die extrahierte Nachricht verarbeiten. <br><br>  In unserer „großen“ Anwendung können CSP-Prozesse auf verschiedene Arten implementiert werden: <br><br><ul><li>  Der CSP-shny-Prozess kann als separates Thread-Betriebssystem implementiert werden.  Es stellt sich als teure Lösung heraus, aber mit präventivem Multitasking; </li><li>  Der CSP-Prozess kann durch Coroutine implementiert werden (stapelbare Coroutine, Faser, grüner Faden, ...).  Es ist viel billiger, aber Multitasking ist nur kooperativ. </li></ul><br>  Ferner nehmen wir an, dass CSP-Prozesse in Form von stapelbaren Coroutinen dargestellt werden (obwohl der unten gezeigte Code möglicherweise in Betriebssystem-Threads implementiert ist). <br><br><h2>  CSP-basiertes Lösungsdiagramm </h2><br>  Das auf dem CSP-Modell basierende Lösungsschema ähnelt stark einem ähnlichen Schema für das Actors-Modell (und dies ist kein Zufall): <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/96/oy/uu/96oyuu6mwhj4ot6fqpsiiv-f1h8.jpeg"></td></tr></tbody></table><br>  Es wird auch Entitäten geben, die am Start des HTTP-Servers beginnen und ständig funktionieren - dies sind die CSP-Prozesse HttpSrv, UserChecker, ImageDownloader und ImageMixer.  Für jede neue eingehende Anforderung wird ein neuer RequestHandler-CSP-Prozess erstellt.  Dieser Prozess sendet und empfängt dieselben Nachrichten wie bei Verwendung des Actors Model. <br><br><h2>  RequestHandler CSP-Prozesscode </h2><br>  Dies sieht möglicherweise aus wie der Code einer Funktion, die den CSP-schüchternen Prozess von RequestHandler implementiert: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ch = make_chain&lt;user_info&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_loaded_ch = make_chain&lt;image_loaded&gt;(); ctx.user_checker_ch().write(check_user{req.user_id(), user_info_ch}); ctx.image_downloader_ch().write(download_image{req.image_id(), image_loaded_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); ctx.image_mixer_ch().write( mix_image{user.watermark_image(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(original_image), image_mix_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result_image = image_mix_ch.read(); ctx.http_srv_ch().write(reply{..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(result_image), ...}); }</code> </pre> <br>  Hier ist alles ziemlich trivial und wiederholt regelmäßig das gleiche Muster: <br><br><ul><li>  Zunächst erstellen wir einen Kanal zum Empfangen von Antwortnachrichten.  Dies ist notwendig, weil  Der CSP-Prozess verfügt nicht über ein eigenes Standardpostfach wie Akteure.  Wenn der CSP-shny-Prozess etwas empfangen möchte, sollte dies durch die Erstellung des Kanals, in dem dieses "Etwas" geschrieben wird, verwirrt werden. </li><li>  dann senden wir unsere Nachricht an den CSP-Master-Prozess.  Und in dieser Nachricht geben wir den Kanal für die Antwortnachricht an; </li><li>  Dann führen wir den Lesevorgang von dem Kanal aus, an den eine Antwortnachricht gesendet werden soll. </li></ul><br>  Dies wird am Beispiel der Kommunikation mit dem ImageSPixer CSP-Prozess sehr deutlich: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  . ctx.image_mixer_ch().write( //  . mix_image{..., image_mix_ch}); //     . auto result_image = image_mix_ch.read(); //  .</span></span></code> </pre> <br>  Aber separat lohnt es sich, sich auf dieses Fragment zu konzentrieren: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read();</code> </pre> <br>  Hier sehen wir einen weiteren gravierenden Unterschied zum Modell der Schauspieler.  Im Fall von CSP können wir Antwortnachrichten in der für uns geeigneten Reihenfolge empfangen. <br><br>  Möchten Sie zuerst auf user_info warten?  Kein Problem, gehen Sie beim Lesen in den Ruhezustand, bis user_info angezeigt wird.  Wenn image_loaded zu diesem Zeitpunkt bereits an uns gesendet wurde, wartet es einfach in seinem Kanal, bis wir es lesen. <br><br>  Das ist in der Tat alles, was den oben gezeigten Code begleiten kann.  CSP-basierter Code war kompakter als sein akteursbasiertes Gegenstück.  Was seitdem nicht verwunderlich ist  hier mussten wir keine separate Klasse mit Rückrufmethoden beschreiben.  Und ein Teil des Zustands unseres CSP-schüchternen Prozesses RequestHandler ist implizit in Form der Argumente ctx und req vorhanden. <br><br><h2>  CSP-Funktionen </h2><br><h3>  Reaktivität und Proaktivität von CSP-Prozessen </h3><br>  Im Gegensatz zu Akteuren können CSP-Prozesse reaktiv, proaktiv oder beides sein.  Angenommen, der CSP-Prozess hat seine eingehenden Nachrichten überprüft und gegebenenfalls verarbeitet.  Und als er sah, dass keine Nachrichten eingingen, verpflichtete er sich, die Matrizen zu multiplizieren. <br><br>  Nach einiger Zeit war der CSP-Prozess der Matrix der Multiplikation überdrüssig und er suchte erneut nach eingehenden Nachrichten.  Keine neuen?  Okay, lass uns die Matrizen weiter multiplizieren. <br><br>  Und diese Fähigkeit von CSP-Prozessen, auch ohne eingehende Nachrichten einige Arbeiten auszuführen, unterscheidet das CSP-Modell stark vom Actors-Modell. <br><br><h3>  Native Überlastschutzmechanismen </h3><br>  Da Kanäle in der Regel Warteschlangen von Nachrichten begrenzter Größe sind und der Versuch, eine Nachricht in einen gefüllten Kanal zu schreiben, den Absender stoppt, verfügen wir in CSP über einen integrierten Schutzmechanismus gegen Überlastung. <br><br>  Wenn wir einen flinken Produzentenprozess und einen langsamen Konsumentenprozess haben, wird der Produzentenprozess den Kanal schnell füllen und für den nächsten Sendevorgang angehalten.  Und der Producer-Prozess wird so lange schlafen, bis der Consumer-Prozess Speicherplatz im Kanal für neue Nachrichten freigibt.  Sobald der Ort erscheint, wacht der Produzentenprozess auf und wirft neue Nachrichten in den Kanal. <br><br>  Daher können wir uns bei der Verwendung von CSP weniger Gedanken über das Problem der Überlastung machen als im Fall des Modells der Akteure.  Es stimmt, es gibt hier eine Falle, über die wir etwas später sprechen werden. <br><br><h3>  Wie werden CSP-Prozesse implementiert? </h3><br>  Wir müssen entscheiden, wie unsere CSP-Prozesse implementiert werden. <br><br>  Dies kann so erfolgen, dass jeder CSP-shny-Prozess durch einen separaten Betriebssystem-Thread dargestellt wird.  Es stellt sich als teure und nicht skalierbare Lösung heraus.  Auf der anderen Seite erhalten wir präventives Multitasking: Wenn unser CSP-Prozess beginnt, Matrizen zu multiplizieren oder eine Art Blockierungsaufruf ausführt, wird das Betriebssystem ihn schließlich aus dem Rechenkern verdrängen und anderen CSP-Prozessen die Möglichkeit geben, zu arbeiten. <br><br>  Es ist möglich, jeden CSP-Prozess durch eine Coroutine (stapelbare Coroutine) darzustellen.  Dies ist eine viel billigere und skalierbare Lösung.  Aber hier werden wir nur kooperatives Multitasking haben.  Wenn der CSP-Prozess plötzlich die Matrixmultiplikation aufnimmt, wird der Arbeitsthread mit diesem CSP-Prozess und anderen damit verbundenen CSP-Prozessen blockiert. <br><br>  Es kann einen anderen Trick geben.  Angenommen, wir verwenden eine Bibliothek eines Drittanbieters, auf deren Innenseite wir keinen Einfluss haben.  Und innerhalb der Bibliothek werden TLS-Variablen verwendet (d. H. Thread-lokaler Speicher).  Wir rufen die Bibliotheksfunktion einmal auf und die Bibliothek legt den Wert einer TLS-Variablen fest.  Dann "bewegt" sich unsere Coroutine zu einem anderen Arbeitsfaden, und das ist möglich, weil  Im Prinzip können Coroutinen von einem Arbeitsthread zu einem anderen migrieren.  Wir rufen die Bibliotheksfunktion wie folgt auf und die Bibliothek versucht, den Wert der TLS-Variablen zu lesen.  Aber es kann schon eine andere Bedeutung geben!  Und nach einem solchen Fehler zu suchen, wird sehr schwierig sein. <br><br>  Daher müssen Sie die Wahl der Methode zur Implementierung von CSP-shnyh-Prozessen sorgfältig abwägen.  Jede der Optionen hat ihre eigenen Stärken und Schwächen. <br><br><h3>  Viele Prozesse sind nicht immer die Lösung. </h3><br>  Wie bei den Akteuren ist die Fähigkeit, viele CSP-Prozesse in Ihrem Programm zu erstellen, nicht immer eine Lösung für ein angewandtes Problem, sondern schafft zusätzliche Probleme für sich. <br><br>  Darüber hinaus ist eine schlechte Sichtbarkeit der Vorgänge im Programm nur ein Teil des Problems.  Ich möchte mich auf eine weitere Falle konzentrieren. <br><br>  Tatsache ist, dass Sie auf CSP-shnyh-Kanälen leicht ein Analogon von Deadlock erhalten können.  Prozess A versucht, eine Nachricht auf den vollen Kanal C1 zu schreiben, und Prozess A wird angehalten.  Von Kanal C1 sollte Prozess B gelesen werden, der versucht hat, auf Kanal C2 zu schreiben, der voll ist, und daher wurde Prozess B angehalten.  Und von Kanal C2 sollte Prozess A gelesen werden. Das ist alles, wir haben einen Deadlock. <br><br>  Wenn wir nur zwei CSP-Prozesse haben, können wir einen solchen Deadlock beim Debuggen oder sogar bei der Codeüberprüfung feststellen.  Wenn wir jedoch Millionen von Prozessen im Programm haben, die aktiv miteinander kommunizieren, steigt die Wahrscheinlichkeit solcher Deadlocks erheblich. <br><br><h2>  Wo soll man suchen, was soll man mitnehmen? </h2><br>  Wenn jemand mit CSP in C ++ arbeiten möchte, ist die Auswahl hier leider nicht so groß wie für Schauspieler.  Nun, oder ich weiß nicht, wo und wie ich suchen soll.  In diesem Fall hoffe ich, dass die Kommentare andere Links teilen. <br><br>  Wenn wir jedoch CSP verwenden möchten, müssen wir uns zunächst mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boost.Fiber befassen</a> .  Es gibt Fasern (d. H. Coroutinen) und Kanäle und sogar Grundelemente auf niedriger Ebene wie Mutex, Bedingung_Variable, Barriere.  All dies kann genommen und verwendet werden. <br><br>  Wenn Sie mit CSP-Prozessen in Form von Threads zufrieden sind, können Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer ansehen</a> .  Es gibt auch Analoga von CSP-Kanälen und komplexe Multithread-Anwendungen auf SObjectizer können ohne Akteure geschrieben werden. <br><br><h1>  Schauspieler gegen CSP </h1><br>  Schauspieler und CSPs sind einander sehr ähnlich.  Immer wieder stieß ich auf die Aussage, dass diese beiden Modelle einander gleichwertig sind.  Das heißt,  Was an Akteuren getan werden kann, kann in CSP-Prozessen fast 1: 1 wiederholt werden und umgekehrt.  Sie sagen, dass es sogar mathematisch bewiesen ist.  Aber hier verstehe ich nichts, also kann ich nichts sagen.  Aber nach meinen eigenen Gedanken irgendwo auf der Ebene des alltäglichen gesunden Menschenverstandes sieht das alles ziemlich plausibel aus.  In einigen Fällen können Akteure tatsächlich durch CSP-Prozesse und CSP-Prozesse durch Akteure ersetzt werden. <br><br>  Es gibt jedoch verschiedene Unterschiede zwischen Akteuren und CSPs, anhand derer festgestellt werden kann, wo jedes dieser Modelle vorteilhaft oder nachteilig ist. <br><br><h2>  Kanäle gegen Mailbox </h2><br>  Ein Schauspieler hat einen einzigen „Kanal“ zum Empfangen eingehender Nachrichten - dies ist seine Mailbox, die automatisch für jeden Schauspieler erstellt wird.  Und der Schauspieler ruft die Nachrichten von dort nacheinander ab, genau in der Reihenfolge, in der sich die Nachrichten in der Mailbox befanden. <br><br>  Und das ist eine ziemlich ernste Frage.  Angenommen, das Postfach des Schauspielers enthält drei Nachrichten: M1, M2 und M3.  Der Schauspieler interessiert sich derzeit nur für M3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber bevor er zu M3 kommt, extrahiert der Schauspieler zuerst M1, dann M2. </font><font style="vertical-align: inherit;">Und was wird er mit ihnen machen?</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auch im Rahmen dieses Gesprächs werden wir nicht auf die selektiven Empfangsmechanismen von Erlang und das Verstecken von Akka eingehen. </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Während der CSP-shny-Prozess den Kanal auswählen kann, von dem er aktuell Nachrichten lesen möchte. </font><font style="vertical-align: inherit;">Ein CSP-Prozess kann also drei Kanäle haben: C1, C2 und C3. </font><font style="vertical-align: inherit;">Derzeit interessiert sich der CSP-Prozess nur für Nachrichten von C3. </font><font style="vertical-align: inherit;">Diesen Kanal liest der Prozess. </font><font style="vertical-align: inherit;">Und er wird zu den Inhalten der Kanäle C1 und C2 zurückkehren, wenn er daran interessiert ist.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reaktivität und Proaktivität </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akteure sind in der Regel reaktiv und arbeiten nur, wenn sie eingehende Nachrichten haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Während CSP-Prozesse auch ohne eingehende Nachrichten einige Arbeit leisten können. </font><font style="vertical-align: inherit;">In einigen Szenarien kann dieser Unterschied eine wichtige Rolle spielen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zustandsautomaten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich sind Akteure Finite-State-Maschinen (KA). </font><font style="vertical-align: inherit;">Wenn es in Ihrem Fachgebiet viele Finite-State-Maschinen gibt und selbst wenn es sich um komplexe, hierarchische Finite-State-Maschinen handelt, können Sie diese daher viel einfacher auf der Grundlage des Akteurmodells implementieren, als indem Sie einem CSP-Prozess eine Raumfahrzeugimplementierung hinzufügen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In C ++ gibt es noch keine native CSP-Unterstützung. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Erfahrung mit der Go-Sprache zeigt, wie einfach und bequem es ist, das CSP-Modell zu verwenden, wenn seine Unterstützung auf der Ebene einer Programmiersprache und ihrer Standardbibliothek implementiert wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Go ist es einfach, "CSP-Prozesse" (auch bekannt als Goroutinen) zu erstellen. Es ist einfach, Kanäle zu erstellen und damit zu arbeiten. Es gibt eine integrierte Syntax für die gleichzeitige Arbeit mit mehreren Kanälen (Go-shny select, die nicht nur zum Lesen, sondern auch zum Schreiben funktioniert). Die Standardbibliothek kennt Goroutins und kann sie wechseln, wenn Goroutin einen blockierenden Aufruf von stdlib ausführt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In C ++ gibt es bisher keine Unterstützung für stapelbare Coroutinen (auf Sprachebene). </font><font style="vertical-align: inherit;">Daher kann die Arbeit mit CSP in C ++ stellenweise aussehen, wenn nicht sogar wie eine Krücke, dann ... Das erfordert sicherlich viel mehr Aufmerksamkeit für sich selbst als im Fall des gleichen Go.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ansatz Nr. 3: Aufgaben (asynchron, Zukunft, wait_all, ...) </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Über den aufgabenbasierten Ansatz in den häufigsten Worten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bedeutung des aufgabenbasierten Ansatzes besteht darin, dass wir bei einer komplexen Operation diese Operation in separate Aufgabenschritte unterteilen, wobei jede Aufgabe (es handelt sich um eine Aufgabe) eine einzelne Unteroperation ausführt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir starten diese Aufgaben mit der speziellen Operation async. </font><font style="vertical-align: inherit;">Die asynchrone Operation gibt ein zukünftiges Objekt zurück, in das nach Abschluss der Aufgabe der von der Aufgabe zurückgegebene Wert platziert wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir N Aufgaben gestartet und N Objekte-Zukunft erhalten haben, müssen wir das alles irgendwie in einer Kette zusammenfügen. </font><font style="vertical-align: inherit;">Es scheint, dass nach Abschluss der Aufgaben Nr. 1 und Nr. 2 die von ihnen zurückgegebenen Werte in Aufgabe Nr. 3 fallen sollten. </font><font style="vertical-align: inherit;">Und wenn Aufgabe Nr. 3 abgeschlossen ist, sollte der zurückgegebene Wert an die Aufgaben Nr. 4, Nr. 5 und Nr. 6 übertragen werden. </font><font style="vertical-align: inherit;">Usw. usw.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für eine solche "Krawatte" werden spezielle Mittel verwendet. </font><font style="vertical-align: inherit;">Wie zum Beispiel die .then () -Methode eines zukünftigen Objekts sowie die Funktionen wait_all (), wait_any (). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine solche Erklärung „an den Fingern“ ist möglicherweise nicht sehr klar. Fahren wir also mit dem Code fort. </font><font style="vertical-align: inherit;">Vielleicht wird in einem Gespräch über einen bestimmten Code die Situation klarer (aber keine Tatsache).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Request_handler-Code für den aufgabenbasierten Ansatz </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Code zum Verarbeiten einer eingehenden HTTP-Anforderung basierend auf Aufgaben kann folgendermaßen aussehen: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context &amp; ctx, request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); }); when_all(user_info_ft, original_image_ft).then( [&amp;ctx, req](tuple&lt;future&lt;user_info&gt;, future&lt;image_loaded&gt;&gt; data) { async(ctx.image_mixer_ctx(), [&amp;ctx, req, d=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(data)] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mix_image(get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(d).get().watermark_image(), get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(d).get()); }) .then([req](future&lt;mixed_image&gt; mixed) { async(ctx.http_srv_ctx(), [req, im=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mixed)] { make_reply(...); }); }); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen wir herauszufinden, was hier passiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst erstellen wir eine Aufgabe, die im Kontext unseres eigenen HTTP-Clients gestartet werden soll und Informationen über den Benutzer anfordert. Das zurückgegebene zukünftige Objekt wird in der Variablen user_info_ft gespeichert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes erstellen wir eine ähnliche Aufgabe, die auch im Kontext unseres eigenen HTTP-Clients ausgeführt werden sollte und die das Original-Image lädt. Das zurückgegebene zukünftige Objekt wird in der Variablen original_image_ft gespeichert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes müssen wir warten, bis die ersten beiden Aufgaben abgeschlossen sind. </font><font style="vertical-align: inherit;">Was wir direkt aufschreiben: when_all (user_info_ft, original_image_ft). </font><font style="vertical-align: inherit;">Wenn beide zukünftigen Objekte ihre Werte erhalten, führen wir eine weitere Aufgabe aus. </font><font style="vertical-align: inherit;">Diese Aufgabe nimmt die Bitmap mit dem Wasserzeichen und dem Originalbild und führt eine weitere Aufgabe im Kontext von ImageMixer aus. </font><font style="vertical-align: inherit;">Diese Aufgabe mischt Bilder und wenn sie abgeschlossen ist, wird eine andere Aufgabe im HTTP-Serverkontext gestartet, die eine HTTP-Antwort generiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht ist eine solche Erklärung dessen, was im Code passiert, nicht viel geklärt. </font><font style="vertical-align: inherit;">Lassen Sie uns deshalb unsere Aufgaben nummerieren:</font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/5k/c0/mr/5kc0mrvqnxdf6lp4-p0wgn1nj7w.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und schauen wir uns die Abhängigkeiten zwischen ihnen an (aus denen die Reihenfolge der Aufgaben hervorgeht): </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zu/j4/g4/zuj4g4wwg0wxmhazj5k5rdb8pgu.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und wenn wir dieses Bild jetzt auf unseren Quellcode legen, dann hoffe ich, dass es klarer wird: </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/sw/at/uz/swatuzio1z33-ei16gquj-ss5mg.jpeg"></td></tr></tbody></table><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Merkmale des aufgabenbasierten Ansatzes </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste Merkmal, das bereits offensichtlich sein sollte, ist die Sichtbarkeit des Codes in Task. </font><font style="vertical-align: inherit;">Nicht alles ist gut mit ihr. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier können Sie so etwas wie die Rückrufhölle erwähnen. </font><font style="vertical-align: inherit;">Die Programmierer von Node.j sind sehr vertraut damit. </font><font style="vertical-align: inherit;">Aber auch C ++ - Spitznamen, die eng mit Task zusammenarbeiten, tauchen in diese Hölle des Rückrufs ein.</font></font><br><br><h3>  Fehlerbehandlung </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres interessantes Feature ist die Fehlerbehandlung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einerseits kann es bei Verwendung von Async und Future mit der Übermittlung von Fehlerinformationen an die interessierte Partei noch einfacher sein als bei Akteuren oder CSP. </font><font style="vertical-align: inherit;">Wenn im CSP-Prozess A eine Anforderung an Prozess B sendet und auf eine Antwortnachricht wartet, müssen wir entscheiden, wie der Fehler an Prozess A übermittelt werden soll, wenn B beim Ausführen der Anforderung auf einen Fehler stößt:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder wir machen einen separaten Nachrichtentyp und einen Kanal für den Empfang; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder wir geben das Ergebnis mit einer einzelnen Nachricht zurück, die für ein normales und fehlerhaftes Ergebnis std :: variante ist. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und im Falle der Zukunft ist alles einfacher: Wir extrahieren aus der Zukunft entweder ein normales Ergebnis oder eine Ausnahme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andererseits können wir leicht auf eine Kaskade von Fehlern stoßen. </font><font style="vertical-align: inherit;">Beispielsweise ist in Aufgabe Nr. 1 eine Ausnahme aufgetreten. Diese Ausnahme fiel in das zukünftige Objekt, das an Aufgabe Nr. 2 übergeben wurde. </font><font style="vertical-align: inherit;">In Aufgabe Nr. 2 haben wir versucht, den Wert aus der Zukunft zu übernehmen, aber eine Ausnahme erhalten. </font><font style="vertical-align: inherit;">Und höchstwahrscheinlich werden wir die gleiche Ausnahme rauswerfen. </font><font style="vertical-align: inherit;">Dementsprechend wird es in die nächste Zukunft fallen, die zu Aufgabe Nr. 3 gehen wird. </font><font style="vertical-align: inherit;">Es wird auch eine Ausnahme geben, die möglicherweise auch veröffentlicht wird.</font></font> Usw. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn unsere Ausnahmen protokolliert werden, sehen wir im Protokoll die wiederholte Wiederholung derselben Ausnahme, die von einer Aufgabe in der Kette zu einer anderen Aufgabe wechselt. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgaben und Timer / Timeouts abbrechen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres sehr interessantes Merkmal der aufgabenbasierten Kampagne ist das Abbrechen von Aufgaben, wenn ein Fehler aufgetreten ist. </font><font style="vertical-align: inherit;">Nehmen wir an, wir haben 150 Aufgaben erstellt, die ersten 10 erledigt und festgestellt, dass es keinen Sinn macht, die Arbeit fortzusetzen. </font><font style="vertical-align: inherit;">Wie stornieren wir die verbleibenden 140? </font><font style="vertical-align: inherit;">Dies ist eine sehr, sehr gute Frage :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere ähnliche Frage ist, wie man Freunde mit Timern und Timeouts zu Aufgaben macht. </font><font style="vertical-align: inherit;">Angenommen, wir greifen auf ein externes System zu und möchten die Wartezeit auf 50 Millisekunden beschränken. </font><font style="vertical-align: inherit;">Wie können wir den Timer einstellen, wie wir auf den Ablauf des Timeouts reagieren, wie wir die Task-Kette unterbrechen, wenn das Timeout abgelaufen ist? </font><font style="vertical-align: inherit;">Wieder ist Fragen einfacher als Antworten :)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrug </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, und um über die Funktionen des aufgabenbasierten Ansatzes zu sprechen. </font><font style="vertical-align: inherit;">In dem gezeigten Beispiel wurde ein wenig betrogen:</font></font><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier habe ich zwei Aufgaben an den Kontext unseres eigenen HTTP-Servers gesendet, von denen jeder eine Blockierungsoperation im Inneren ausführt. </font><font style="vertical-align: inherit;">Um zwei Anforderungen an Dienste von Drittanbietern parallel verarbeiten zu können, mussten Sie hier Ihre eigenen Ketten asynchroner Aufgaben erstellen. </font><font style="vertical-align: inherit;">Ich habe dies jedoch nicht getan, um die Lösung mehr oder weniger sichtbar zu machen und auf die Präsentationsfolie zu passen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schauspieler / CSP vs Aufgaben </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben drei Ansätze untersucht und festgestellt, dass der aufgabenbasierte Ansatz keinem von ihnen ähnelt, wenn Akteure und CSP-Prozesse einander ähnlich sind. Und es könnte den Anschein haben, dass Actors / CSP im Gegensatz zu Task stehen sollten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber ich persönlich mag eine andere Sichtweise. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir über das Modell der Akteure und CSP sprechen, dann sprechen wir über die Zerlegung unserer Aufgabe. In unserer Aufgabe wählen wir separate unabhängige Entitäten aus und beschreiben die Schnittstellen dieser Entitäten: Welche Nachrichten senden sie, welche empfangen sie, über welche Kanäle gehen die Nachrichten.</font></font><br><br>  Das heißt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Zusammenarbeit mit Schauspielern und CSP sprechen wir über Schnittstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nehmen wir jedoch an, wir teilen die Aufgabe in separate Akteure und CSP-Prozesse auf. Wie genau machen sie ihren Job? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir den aufgabenbasierten Ansatz aufgreifen, sprechen wir über die Implementierung. Informationen darüber, wie eine bestimmte Arbeit ausgeführt wird, welche Unteroperationen ausgeführt werden, in welcher Reihenfolge, wie diese Unteroperationen gemäß Daten verbunden sind usw.</font></font><br><br>  Das heißt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Arbeit mit Task sprechen wir über die Implementierung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher sind Schauspieler / CSP und Aufgaben nicht so sehr gegensätzlich, sondern ergänzen sich. </font><font style="vertical-align: inherit;">Akteure / CSPs können verwendet werden, um Aufgaben zu zerlegen und Schnittstellen zwischen Komponenten zu definieren. </font><font style="vertical-align: inherit;">Und Aufgaben können dann verwendet werden, um bestimmte Komponenten zu implementieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie beispielsweise Actor verwenden, haben wir eine Entität wie ImageMixer, die mit Bildern im Thread-Pool bearbeitet werden muss. </font><font style="vertical-align: inherit;">Im Allgemeinen hindert uns nichts daran, den ImageMixer-Akteur für den aufgabenbasierten Ansatz zu verwenden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wo soll man suchen, was soll man mitnehmen? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie mit Aufgaben in C ++ arbeiten möchten, können Sie sich die Standardbibliothek des kommenden C ++ 20 ansehen. Sie haben der Zukunft bereits die Methode .then () sowie die freien Funktionen wait_all () und wait_any hinzugefügt. Siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppreference für Details</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist auch schon weit von einer neuen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async ++ Bibliothek entfernt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In dem gibt es im Prinzip alles, was Sie brauchen, nur ein bisschen mit einer anderen Sauce. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und es gibt eine noch ältere </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft PPL-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek </font><font style="vertical-align: inherit;">. Was auch alles gibt, was Sie brauchen, aber mit Ihrer eigenen Sauce.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separate Ergänzung zur Intel TBB-Bibliothek. </font><font style="vertical-align: inherit;">Es wurde in der Geschichte über den aufgabenbasierten Ansatz nicht erwähnt, da Taskgraphen von TBB meiner Meinung nach bereits ein Datenflussansatz sind. </font><font style="vertical-align: inherit;">Und wenn dieser Bericht fortgesetzt wird, wird das Gespräch über Intel TBB sicherlich kommen, aber im Kontext der Geschichte über den Datenfluss.</font></font></blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interessanter </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kürzlich gab es hier auf Habré einen Artikel von Anton Polukhin: "Wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bereiten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uns </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">auf C ++ 20 vor. Coroutines TS anhand eines realen Beispiels</font></a><font style="vertical-align: inherit;"> ." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es geht darum, einen aufgabenbasierten Ansatz mit stapellosen Coroutinen aus C ++ 20 zu kombinieren. </font><font style="vertical-align: inherit;">Und es stellte sich heraus, dass der Code auf der Grundlage der Lesbarkeit von Aufgaben der Lesbarkeit von Code in CSP-Prozessen nahe kam. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich also jemand für den aufgabenbasierten Ansatz interessiert, ist es sinnvoll, diesen Artikel zu lesen.</font></font><br><br><h1>  Fazit </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, es ist Zeit, mit den Ergebnissen fortzufahren, da es nicht so viele davon gibt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Hauptsache, die ich sagen möchte, ist, dass Sie in der modernen Welt möglicherweise nur dann Multithreading benötigen, wenn Sie ein Framework entwickeln oder eine bestimmte Aufgabe auf niedriger Ebene lösen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wenn Sie Anwendungscode schreiben, benötigen Sie kaum nackte Threads, Synchronisationsprimitive auf niedriger Ebene oder eine Art sperrfreier Algorithmen sowie sperrfreie Container. </font><font style="vertical-align: inherit;">Es gibt seit langem bewährte Ansätze, die sich bewährt haben:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schauspieler </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kommunikation sequentieller Prozesse (CSP) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgaben (Async, Versprechen, Zukunft, ...) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datenflüsse </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reaktive Programmierung </font></font></li><li>  ... </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und vor allem gibt es in C ++ vorgefertigte Tools für sie. </font><font style="vertical-align: inherit;">Sie müssen nichts radeln, Sie können es nehmen, versuchen und, wenn es Ihnen gefällt, in Betrieb nehmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So einfach: nehmen, versuchen und in Betrieb nehmen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430672/">https://habr.com/ru/post/de430672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430662/index.html">Überwachen von Windows-Servern unter reinem MS SQL und wie ich es heimlich implementiert habe</a></li>
<li><a href="../de430664/index.html">Die Rolle des Teamleiters bei der Rekrutierung</a></li>
<li><a href="../de430666/index.html">Wie man die Teameffektivität bewertet</a></li>
<li><a href="../de430668/index.html">Allein auf dem Feld ist kein Krieger. Der Weg zu effektiver Teamarbeit</a></li>
<li><a href="../de430670/index.html">Arrangement Management</a></li>
<li><a href="../de430674/index.html">Die Logik der Erstellung universeller Arbeitspläne</a></li>
<li><a href="../de430676/index.html">Altertümer: shshshsh, sssssss, VOIP, BBS und andere Freunde des Modems</a></li>
<li><a href="../de430678/index.html">Test von zehn Dimmern mit LED-Lampen</a></li>
<li><a href="../de430680/index.html">Schreiben eines einfachen Prozessors und einer Umgebung dafür</a></li>
<li><a href="../de430682/index.html">Drei Jahre Mond-Mikrosatelliten-Projekt: Stadien des Erwachsenwerdens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>