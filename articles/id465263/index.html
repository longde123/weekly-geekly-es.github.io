<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😒 ♋️ 👨‍🔧 Locks in PostgreSQL: 3. Mengunci objek lain 💪🏻 👳🏿 🎀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kita telah berbicara tentang beberapa kunci pada level objek (khususnya, tentang kunci pada relasi), serta tentang kunci pada level baris , hubunganny...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Locks in PostgreSQL: 3. Mengunci objek lain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/465263/">  Kita telah berbicara tentang beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kunci pada level objek</a> (khususnya, tentang kunci pada relasi), serta tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kunci pada level baris</a> , hubungannya dengan kunci objek dan antrian tunggu, yang tidak selalu jujur. <br><br>  Hari ini kita memiliki gado-gado.  Mari kita mulai dengan <strong>kebuntuan</strong> (sebenarnya, saya akan berbicara tentang mereka terakhir kali, tetapi artikel itu ternyata panjang tidak senonoh), maka kita akan membahas <strong>kunci objek yang</strong> tersisa dan berbicara tentang <strong>kunci predikat</strong> sebagai kesimpulan. <br><br><h1>  Jalan buntu </h1><br>  Saat menggunakan kunci, situasi <em>deadlock</em> (atau <em>deadlock</em> ) mungkin terjadi.  Itu terjadi ketika satu transaksi mencoba untuk menangkap sumber daya yang sudah ditangkap oleh transaksi lain, sedangkan transaksi lain mencoba untuk menangkap sumber daya yang ditangkap oleh yang pertama.  Ini diilustrasikan dalam gambar kiri di bawah ini: panah padat menunjukkan sumber daya yang ditangkap, panah putus-putus menunjukkan upaya untuk menangkap sumber daya yang sudah diduduki. <br><br>  Adalah mudah untuk memvisualisasikan kebuntuan dengan membuat grafik harapan.  Untuk melakukan ini, kami menghapus sumber daya tertentu dan hanya meninggalkan transaksi, mencatat transaksi mana yang menunggu.  Jika grafik memiliki kontur (dari atas Anda dapat melihatnya dengan panah) - ini adalah jalan buntu. <br><br><img src="https://habrastorage.org/webt/-b/rg/yr/-brgyrpjzf-xgudc27jgtyzr6d4.png"><br><a name="habracut"></a><br>  Tentu saja, jalan buntu tidak hanya dimungkinkan untuk dua transaksi, tetapi juga untuk jumlah yang lebih besar. <br><br>  Jika kebuntuan terjadi, transaksi yang terlibat di dalamnya tidak dapat berbuat apa-apa - mereka akan menunggu tanpa batas waktu.  Karenanya, semua DBMS, dan PostgreSQL, juga, secara otomatis melacak kebuntuan. <br><br>  Namun, pengecekan memerlukan upaya tertentu, yang tidak ingin saya lakukan setiap kali kunci baru diminta (setelah semua, deadlock sangat jarang terjadi).  Oleh karena itu, ketika proses mencoba untuk menangkap kunci dan tidak bisa, itu memasuki antrian dan tertidur, tetapi mulai timer ke nilai yang ditentukan dalam parameter <em>deadlock_timeout</em> (secara default, 1 detik).  Jika sumber dibebaskan sebelumnya, maka bagus, kami menghemat verifikasi.  Tetapi jika setelah <em>deadlock_timeout</em> tunggu terus, maka proses menunggu akan dibangunkan dan memulai pemeriksaan. <br><br>  Jika cek (yang terdiri dalam membangun grafik harapan dan mencari kontur di dalamnya) tidak mengungkapkan kebuntuan, maka proses terus tidur - sekarang sudah sampai pada akhir yang pahit. <br><br><blockquote>  Sebelumnya di komentar, saya benar dicela karena tidak mengatakan apa-apa tentang parameter <em>lock_timeout</em> , yang bertindak pada operator apa pun dan menghindari menunggu lama tanpa batas: jika kunci tidak dapat diperoleh dalam waktu yang ditentukan, pernyataan diakhiri dengan kesalahan lock_not_available.  Seharusnya tidak bingung dengan parameter <em>statement_timeout</em> , yang membatasi waktu eksekusi total pernyataan, tidak peduli apakah itu mengharapkan kunci atau hanya melakukan pekerjaan. <br></blockquote><br>  Jika kebuntuan terdeteksi, maka salah satu transaksi (dalam kebanyakan kasus, transaksi yang memulai cek) dihentikan secara paksa.  Dalam hal ini, kunci yang ditangkap olehnya dilepaskan dan sisa transaksi dapat terus berfungsi. <br><br>  Kebuntuan biasanya berarti bahwa aplikasi tidak dirancang dengan benar.  Ada dua cara untuk mendeteksi situasi seperti itu: pertama, pesan akan muncul di log server, dan kedua, nilai pg_stat_database.deadlocks akan meningkat. <br><br><h2>  Contoh deadlock </h2><br>  Penyebab umum kebuntuan adalah urutan berbeda di mana baris dalam tabel dikunci. <br>  Contoh sederhana.  Transaksi pertama bermaksud untuk mentransfer 100 rubel dari akun pertama ke akun kedua.  Untuk melakukan ini, pertama-tama dia mengurangi hitungan pertama: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br>  Pada saat yang sama, transaksi kedua bermaksud untuk mentransfer 10 rubel dari akun kedua ke yang pertama.  Dia mulai dengan mengurangi hitungan kedua: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">10.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><br>  Sekarang transaksi pertama sedang mencoba untuk menambah akun kedua, tetapi menemukan bahwa baris terkunci. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Kemudian transaksi kedua mencoba meningkatkan akun pertama, tetapi juga diblokir. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">10.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Ada harapan siklus yang tidak akan pernah berakhir dengan sendirinya.  Setelah satu detik, transaksi pertama, tidak memiliki akses ke sumber daya, memulai pemeriksaan kebuntuan dan memutuskan server. <br><br><pre> <code class="plaintext hljs">ERROR: deadlock detected DETAIL: Process 16477 waits for ShareLock on transaction 530695; blocked by process 16513. Process 16513 waits for ShareLock on transaction 530694; blocked by process 16477. HINT: See server log for query details. CONTEXT: while updating tuple (0,2) in relation "accounts"</code> </pre><br>  Sekarang transaksi kedua dapat dilanjutkan. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Cara yang benar untuk melakukan operasi seperti itu adalah memblokir sumber daya dalam urutan yang sama.  Misalnya, dalam hal ini, Anda dapat memblokir akun dalam urutan angka-angka mereka. <br><br><h2>  Jalan buntu untuk dua perintah PEMBARUAN </h2><br>  Kadang-kadang Anda bisa mendapatkan jalan buntu di mana, tampaknya, seharusnya tidak.  Misalnya, mudah dan akrab untuk menganggap perintah SQL sebagai atom, tetapi ambil UPDATE - perintah ini memblokir baris saat mereka diperbarui.  Ini tidak terjadi sekaligus.  Oleh karena itu, jika satu perintah memperbarui baris dalam satu urutan dan yang lainnya dalam urutan lainnya, mereka mungkin menemui jalan buntu. <br><br>  Sepertinya tidak mungkin mendapatkan situasi seperti itu, tetapi bagaimanapun juga itu bisa bertemu.  Untuk pemutaran, kami akan membuat indeks pada kolom jumlah, dibuat dalam urutan jumlah menurun: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> accounts(amount <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>);</code> </pre><br>  Untuk memiliki waktu untuk melihat apa yang terjadi, kami akan menulis fungsi yang meningkatkan nilai yang ditransmisikan, tetapi secara perlahan, perlahan, sebentar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> inc_slow(n <span class="hljs-type"><span class="hljs-type">numeric</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> pg_sleep(</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql">); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> n + </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">100.00</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Kita juga membutuhkan ekstensi pgrowlocks. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgrowlocks;</code> </pre><br>  Perintah UPDATE pertama akan memperbarui seluruh tabel.  Rencana eksekusi sudah jelas - pemindaian berurutan: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount);</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ---------------------------- | Update on accounts | -&gt; Seq Scan on accounts | (2 rows)</code> </pre><br>  Karena versi baris pada halaman tabel kami berada dalam urutan jumlah yang meningkat (persis seperti yang kami tambahkan), mereka akan diperbarui dalam urutan yang sama.  Kami memulai pembaruan untuk bekerja. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount);</code> </pre><br>  Sementara itu, di sesi lain, kami akan melarang penggunaan pemindaian berurutan: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>;</code> </pre><br>  Dalam hal ini, penjadwal memutuskan untuk menggunakan pemindaian indeks untuk pernyataan UPDATE berikut: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> amount &gt; <span class="hljs-number"><span class="hljs-number">100.00</span></span>;</code> </pre><pre> <code class="plaintext hljs">|| QUERY PLAN || -------------------------------------------------------- || Update on accounts || -&gt; Index Scan using accounts_amount_idx on accounts || Index Cond: (amount &gt; 100.00) || (3 rows)</code> </pre><br>  Baris kedua dan ketiga jatuh dalam kondisi tersebut, dan, karena indeks dibangun dalam urutan menurun, baris akan diperbarui dalam urutan terbalik. <br><br>  Kami meluncurkan pembaruan berikutnya. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> amount &gt; <span class="hljs-number"><span class="hljs-number">100.00</span></span>;</code> </pre><br>  Pandangan sekilas pada halaman tabular menunjukkan bahwa operator pertama telah berhasil memperbarui baris pertama (0,1), dan yang kedua - terakhir (0,3): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------- locked_row | (0,1) locker | 530699 &lt;-  multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 2 ]----------------- locked_row | (0,3) locker | 530700 &lt;-  multi | f xids | {530700} modes | {"No Key Update"} pids | {16549}</code> </pre><br>  Satu detik berlalu.  Operator pertama memperbarui baris kedua, dan yang kedua ingin melakukan ini, tetapi tidak bisa. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------- locked_row | (0,1) locker | 530699 &lt;-  multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 2 ]----------------- locked_row | (0,2) locker | 530699 &lt;-    multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 3 ]----------------- locked_row | (0,3) locker | 530700 &lt;-  multi | f xids | {530700} modes | {"No Key Update"} pids | {16549}</code> </pre><br>  Sekarang pernyataan pertama ingin memperbarui baris terakhir dari tabel, tetapi sudah dikunci oleh yang kedua.  Ini jalan buntu. <br><br>  Salah satu transaksi dibatalkan: <br><br><pre> <code class="plaintext hljs">|| ERROR: deadlock detected || DETAIL: Process 16549 waits for ShareLock on transaction 530699; blocked by process 16513. || Process 16513 waits for ShareLock on transaction 530700; blocked by process 16549. || HINT: See server log for query details. || CONTEXT: while updating tuple (0,2) in relation "accounts"</code> </pre><br>  Dan yang lainnya menyelesaikan eksekusi: <br><br><pre> <code class="plaintext hljs">| UPDATE 3</code> </pre><br><blockquote>  Detail menarik tentang mendeteksi dan mencegah kebuntuan dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manajer kunci README</a> . <br></blockquote><br>  Itu semua tentang kebuntuan, dan kami melanjutkan ke kunci objek yang tersisa. <br><br><img src="https://habrastorage.org/webt/wb/wm/ho/wbwmhoocvz64odsj3qqooqup9jw.png"><br><br><h1>  Kunci Non-Hubungan </h1><br>  Saat Anda ingin mengunci sumber daya yang bukan <em>hubungan</em> dalam pemahaman PostgreSQL, kunci objek digunakan.  Sumber daya semacam itu bisa berupa apa saja: ruang tabel, langganan, skema, peran, tipe data yang disebutkan ... Secara kasar, semua yang dapat ditemukan dalam katalog sistem. <br><br>  Mari kita lihat contoh sederhana.  Kami memulai transaksi dan membuat tabel di dalamnya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> example(n <span class="hljs-type"><span class="hljs-type">integer</span></span>);</code> </pre><br>  Sekarang mari kita lihat jenis objek kunci apa yang muncul di pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> datname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = l.<span class="hljs-keyword"><span class="hljs-keyword">database</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> dbname, classid, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = l.classid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> classname, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks l <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> l.locktype = <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> l.pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> database | dbname | classid | classname | objid | mode | granted ----------+--------+---------+--------------+-------+-----------------+--------- 0 | | 1260 | pg_authid | 16384 | AccessShareLock | t 16386 | test | 2615 | pg_namespace | 2200 | AccessShareLock | t (2 rows)</code> </pre><br>  Untuk memahami apa yang sebenarnya diblokir di sini, Anda perlu melihat tiga bidang: database, classid dan objid.  Mari kita mulai dengan baris pertama. <br><br>  Basis data adalah OID dari basis data tempat sumber daya terkunci.  Dalam kasus kami, ada nol di kolom ini.  Ini berarti bahwa kita berhadapan dengan objek global yang bukan milik basis tertentu. <br><br>  Classid berisi OID pg_class, yang sesuai dengan nama tabel katalog sistem, yang menentukan jenis sumber daya.  Dalam kasus kami, pg_authid, artinya, peran adalah sumber daya (pengguna). <br><br>  Objid berisi OID dari tabel katalog sistem yang ditunjukkan oleh classid kepada kami. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> rolname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_authid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-number"><span class="hljs-number">16384</span></span>;</code> </pre><pre> <code class="plaintext hljs"> rolname --------- student (1 row)</code> </pre><br>  Dengan demikian, peran siswa diblokir, dari mana kami bekerja. <br><br>  Sekarang mari kita berurusan dengan baris kedua.  Basis data ditunjukkan, dan ini adalah basis data uji yang terhubung dengan kami. <br><br>  Classid menunjuk ke tabel pg_namespace yang berisi skema. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> nspname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_namespace <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-number"><span class="hljs-number">2200</span></span>;</code> </pre><pre> <code class="plaintext hljs"> nspname --------- public (1 row)</code> </pre><br>  Dengan demikian, skema publik diblokir. <br><br>  Jadi, kami melihat bahwa saat membuat objek, peran pemilik dan skema tempat objek dibuat diblokir (dalam mode berbagi).  Yang logis: kalau tidak, seseorang bisa menghapus peran atau skema sementara transaksi belum selesai. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Kunci Ekstensi Hubungan </h1><br>  Ketika jumlah baris dalam suatu relasi (yaitu, dalam tabel, indeks, tampilan terwujud) meningkat, PostgreSQL dapat menggunakan ruang kosong di halaman yang ada untuk memasukkan, tetapi, jelas, pada titik tertentu Anda harus menambahkan halaman baru.  Secara fisik, mereka ditambahkan ke akhir file yang sesuai.  Ini dipahami sebagai <em>memperluas hubungan</em> . <br><br>  Untuk mencegah dua proses dari terburu-buru untuk menambah halaman pada saat yang sama, proses ini dilindungi oleh kunci jenis khusus yang diperluas.  Kunci yang sama digunakan saat membersihkan indeks sehingga proses lain tidak dapat menambahkan halaman selama pemindaian. <br><br>  Tentu saja, kunci ini dilepaskan tanpa menunggu akhir transaksi. <br><br><blockquote>  Sebelumnya, tabel hanya diperluas satu halaman pada satu waktu.  Ini menyebabkan masalah ketika beberapa proses secara bersamaan memasukkan baris, oleh karena itu, dalam PostgreSQL 9.6, beberapa halaman ditambahkan ke tabel sekaligus (sebanding dengan jumlah proses yang menunggu untuk dikunci, tetapi tidak lebih dari 512). <br></blockquote><br><h1>  Kunci Halaman </h1><br>  Kunci tingkat halaman diterapkan dalam satu-satunya kasus (kecuali untuk kunci predikat, yang akan dibahas kemudian). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Indeks GIN</a> memungkinkan Anda untuk mempercepat pencarian dalam nilai majemuk, misalnya, kata-kata dalam dokumen teks (atau elemen dalam array).  Untuk perkiraan pertama, indeks tersebut dapat direpresentasikan sebagai pohon-B biasa, di mana bukan dokumen itu sendiri disimpan, tetapi kata-kata individual dari dokumen-dokumen ini.  Oleh karena itu, ketika menambahkan dokumen baru, indeks harus dibangun kembali dengan cukup kuat, memasukkan setiap kata yang dimasukkan ke dalam dokumen. <br><br>  Untuk meningkatkan kinerja, indeks GIN memiliki fitur penyisipan tertunda yang diaktifkan oleh opsi penyimpanan pembaruan cepat.  Kata-kata baru pertama-tama dengan cepat ditambahkan ke daftar pending yang tidak berurutan, dan setelah beberapa waktu, semua yang telah terakumulasi dipindahkan ke struktur indeks utama.  Tabungan disebabkan oleh fakta bahwa dokumen yang berbeda cenderung mengandung kata-kata rangkap. <br><br>  Untuk mengecualikan beberapa proses dari pindah dari daftar tunggu ke indeks utama pada saat yang sama, halaman meta indeks diblokir dalam mode eksklusif selama durasi transfer.  Ini tidak mengganggu penggunaan indeks dalam mode normal. <br><br><h1>  Kunci penasehat </h1><br>  Tidak seperti kunci lainnya (seperti kunci hubungan), kunci penasihat tidak pernah diatur secara otomatis, mereka dikelola oleh pengembang aplikasi.  Mereka nyaman digunakan, misalnya, jika suatu aplikasi membutuhkan pemblokiran logika untuk beberapa tujuan yang tidak sesuai dengan logika standar kunci biasa. <br><br>  Misalkan kita memiliki sumber daya bersyarat yang tidak sesuai dengan objek basis data apa pun (yang dapat kita blokir dengan perintah seperti SELECT FOR atau LOCK TABLE).  Anda harus membuat pengidentifikasi numerik untuk itu.  Jika sumber daya memiliki nama unik, maka opsi sederhana adalah mengambil kode hash dari itu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 243773337 (1 row)</code> </pre><br>  Inilah cara kami menangkap kuncinya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock(hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>));</code> </pre><br>  Seperti biasa, informasi kunci tersedia di pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'advisory'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> locktype | objid | mode | granted ----------+-----------+---------------+--------- advisory | 243773337 | ExclusiveLock | t (1 row)</code> </pre><br>  Agar kunci benar-benar berfungsi, proses lain juga harus mendapatkan kunci sebelum mengakses sumber.  Kepatuhan terhadap aturan ini jelas harus dipastikan oleh aplikasi. <br><br>  Dalam contoh di atas, kunci valid hingga akhir sesi, dan bukan transaksi, seperti biasa. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'advisory'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> locktype | objid | mode | granted ----------+-----------+---------------+--------- advisory | 243773337 | ExclusiveLock | t (1 row)</code> </pre><br>  Itu harus secara eksplisit dirilis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_unlock(hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>));</code> </pre><br>  Ada sejumlah besar fungsi untuk bekerja dengan kunci penasihat untuk semua kesempatan: <br><br><ul><li>  pg_advisory_lock_shared memperlakukan kunci bersama, </li><li>  pg_advisory_xact_lock (dan pg_advisory_xact_lock_share) mendapat kunci sampai akhir transaksi, </li><li>  pg_try_advisory_lock (serta pg_try_advisory_xact_lock dan pg_try_advisory_xact_lock_shared) tidak menunggu kunci, tetapi mengembalikan nilai palsu jika kunci tidak dapat diperoleh dengan segera. </li></ul><br>  Serangkaian fungsi coba memberikan cara lain untuk tidak menunggu kunci, selain yang tercantum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel sebelumnya</a> . <br><br><h1>  Kunci predikat </h1><br>  Istilah <em>penguncian predikat</em> muncul sejak lama, pada upaya pertama untuk menerapkan isolasi penuh berdasarkan kunci di DBMSs awal (tingkat Serializable, meskipun standar SQL tidak ada pada waktu itu).  Masalah yang kemudian ditemui adalah bahwa bahkan memblokir semua baris yang dibaca dan diubah tidak memberikan isolasi lengkap: baris <em>baru</em> mungkin muncul dalam tabel yang termasuk dalam kondisi pemilihan yang sama, yang mengarah pada <em>hantu</em> (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tentang isolasi</a> ) . <br><br>  Ide kunci predikat adalah untuk memblokir predikat, bukan baris.  Jika, ketika menjalankan kueri dengan kondisi <em>a</em> &gt; 10, predikat <em>a</em> &gt; 10 diblokir, ini tidak akan menambah baris baru ke tabel yang termasuk dalam kondisi dan akan menghindari hantu.  Masalahnya adalah bahwa dalam kasus umum ini adalah tugas yang sulit secara komputasi;  dalam praktiknya, itu bisa diselesaikan hanya untuk predikat yang memiliki bentuk yang sangat sederhana. <br><br>  Dalam PostgreSQL, lapisan Serializable diimplementasikan secara berbeda, di atas isolasi berbasis snapshot yang ada.  Istilah <em>predicate lock</em> tetap ada, tetapi artinya telah berubah secara radikal.  Bahkan, "kunci" seperti itu tidak memblokir apa pun, tetapi digunakan untuk melacak ketergantungan data antara transaksi. <br><br>  Terbukti bahwa isolasi berdasarkan gambar memungkinkan <em>anomali rekaman yang tidak konsisten</em> dan <em>anomali hanya transaksi membaca</em> , tetapi tidak ada anomali lain yang mungkin.  Untuk memahami bahwa kita berurusan dengan salah satu dari dua anomali yang terdaftar, kita dapat menganalisis dependensi antara transaksi dan menemukan pola tertentu di dalamnya. <br><br>  Kami tertarik pada dua jenis dependensi: <br><br><ul><li>  satu transaksi membaca satu baris, yang kemudian diubah oleh transaksi lain (ketergantungan RW), </li><li>  satu transaksi memodifikasi baris yang dibaca oleh transaksi lain (ketergantungan WR). </li></ul><br>  WR-dependensi dapat dilacak menggunakan kunci konvensional yang ada, tetapi RW-dependency hanya perlu melacak tambahan. <br><br>  Saya ulangi sekali lagi: terlepas dari namanya, kunci predikat tidak memblokir apa pun.  Alih-alih, ketika transaksi dilakukan, pemeriksaan dilakukan dan, jika urutan dependensi “buruk” terdeteksi yang mungkin mengindikasikan anomali, transaksi terputus. <br><br>  Mari kita lihat bagaimana pemasangan kunci predikat terjadi.  Untuk melakukan ini, buat tabel dengan jumlah baris yang cukup besar dan indeks di atasnya. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> pred(n <span class="hljs-type"><span class="hljs-type">integer</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pred(n) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> gn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>) g(n); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pred(n) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor = <span class="hljs-number"><span class="hljs-number">10</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> pred;</code> </pre><br>  Jika kueri dijalankan oleh pemindaian berurutan dari seluruh tabel, maka kunci predikat diatur di seluruh tabel (bahkan jika tidak semua baris berada dalam kondisi penyaringan). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 12763 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ---------------------------------------------------------------- | Seq Scan on pred (actual time=0.047..12.709 rows=9900 loops=1) | Filter: (n &gt; 100) | Rows Removed by Filter: 100 | Planning Time: 0.190 ms | Execution Time: 15.244 ms | (5 rows)</code> </pre><br>  Setiap kunci predikat selalu ditangkap dalam satu mode SIReadLock (Serializable Isolation Read) khusus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+----------+------+------- relation | pred | | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Tetapi jika kueri dieksekusi menggunakan pemindaian indeks, situasinya berubah menjadi lebih baik.  Jika kita berbicara tentang B-tree, maka cukup untuk mengatur kunci pada baris tabel baca dan pada halaman rindang indeks - dengan demikian kita memblokir tidak hanya nilai-nilai spesifik, tetapi juga seluruh rentang dibaca. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1001</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ------------------------------------------------------------------------------------ | Index Only Scan using pred_n_idx on pred (actual time=0.122..0.131 rows=2 loops=1) | Index Cond: ((n &gt;= 1000) AND (n &lt;= 1001)) | Heap Fetches: 2 | Planning Time: 0.096 ms | Execution Time: 0.153 ms | (5 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- tuple | pred | 3 | 236 tuple | pred | 3 | 235 page | pred_n_idx | 22 | (3 rows)</code> </pre><br>  Anda mungkin memperhatikan beberapa kesulitan. <br><br>  Pertama, kunci terpisah dibuat untuk setiap versi baris yang dibaca, tetapi berpotensi ada banyak versi seperti itu.  Jumlah total kunci predikat dalam sistem dibatasi oleh produk dari nilai parameter <em>max_pred_locks_per_transaction</em> × <em>max_connections</em> (nilai default masing-masing adalah 64 dan 100).  Memori untuk kunci tersebut dialokasikan pada startup server;  berusaha melebihi angka ini akan menghasilkan kesalahan. <br><br>  Oleh karena itu, untuk kunci predikat (dan hanya untuk mereka!), Kenaikan <em>level</em> digunakan.  Sebelum PostgreSQL 10, ada batasan yang tertanam dalam kode, dan mulai dengan itu Anda dapat mengontrol parameter dengan menaikkan level.  Jika jumlah kunci versi baris <em>per baris</em> lebih besar dari <em>max_pred_locks_per_page</em> , kunci tersebut diganti dengan satu kunci tingkat halaman.  Berikut ini sebuah contoh: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> max_pred_locks_per_page;</code> </pre><pre> <code class="plaintext hljs"> max_pred_locks_per_page ------------------------- 2 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1002</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ------------------------------------------------------------------------------------ | Index Only Scan using pred_n_idx on pred (actual time=0.019..0.039 rows=3 loops=1) | Index Cond: ((n &gt;= 1000) AND (n &lt;= 1002)) | Heap Fetches: 3 | Planning Time: 0.069 ms | Execution Time: 0.057 ms | (5 rows)</code> </pre><br>  Alih-alih tiga kunci tuple, kita melihat satu jenis halaman: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- page | pred | 3 | page | pred_n_idx | 22 | (2 rows)</code> </pre><br>  Demikian pula, jika jumlah kunci halaman yang <em>terkait</em> dengan satu hubungan melebihi <em>max_pred_locks_per_relation</em> , kunci tersebut diganti dengan satu kunci tingkat hubungan. <br><br>  Tidak ada level lain: kunci predikat hanya ditangkap untuk hubungan, halaman, atau versi baris, dan selalu dengan mode SIReadLock. <br><br>  Tentu saja, peningkatan tingkat kunci tak terelakkan mengarah pada fakta bahwa jumlah transaksi yang lebih besar akan secara salah menghasilkan kesalahan serialisasi dan, sebagai hasilnya, throughput sistem akan menurun.  Di sini Anda perlu mencari keseimbangan antara konsumsi memori dan kinerja. <br><br>  Kesulitan kedua adalah bahwa dalam berbagai operasi dengan indeks (misalnya, karena pemisahan halaman indeks ketika memasukkan baris baru), jumlah halaman lembar yang mencakup rentang baca dapat berubah.  Tetapi implementasi ini memperhitungkan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1001</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- page | pred | 3 | page | pred_n_idx | 211 | page | pred_n_idx | 212 | page | pred_n_idx | 22 | (4 rows)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Omong-omong, kunci predikat tidak selalu dihapus segera setelah transaksi selesai, karena mereka diperlukan untuk melacak ketergantungan antara <em>beberapa</em> transaksi.  Tetapi bagaimanapun juga, mereka dikelola secara otomatis. <br><br>  Tidak semua tipe indeks di PostgreSQL mendukung kunci predikat.  Sebelumnya, hanya pohon-B yang dapat membanggakan ini, tetapi dalam PostgreSQL 11 situasinya membaik: indeks hash, GiST dan GIN ditambahkan ke daftar.  Jika akses indeks digunakan, dan indeks tidak berfungsi dengan kunci predikat, maka seluruh indeks dikunci ke kunci.  Tentu saja, ini juga meningkatkan jumlah jeda transaksi palsu. <br><br>  Sebagai kesimpulan, saya perhatikan bahwa dengan penggunaan kunci predikatlah ada batasan bahwa, untuk menjamin isolasi lengkap, <em>semua</em> transaksi harus bekerja pada tingkat Serializable.  Jika suatu transaksi menggunakan tingkat yang berbeda, itu tidak akan menetapkan (dan memeriksa) kunci predikat. <br><br><blockquote>  Secara tradisional, saya akan meninggalkan tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">README pada kunci predikat</a> , dari mana Anda dapat mulai mempelajari kode sumber. <br></blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk dilanjutkan</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465263/">https://habr.com/ru/post/id465263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465251/index.html">Musim panas hampir berakhir. Hampir tidak ada data yang bocor</a></li>
<li><a href="../id465255/index.html">Implementasi Pool Connection WCF untuk .Net Core Menggunakan HttpClientFactory</a></li>
<li><a href="../id465257/index.html">"Waspadalah, FAS!": Trik McDonald's, shawarma ilahi, Clooney palsu dan beberapa sihir jalanan</a></li>
<li><a href="../id465259/index.html">ValueTask <TResult> - mengapa, mengapa dan bagaimana?</a></li>
<li><a href="../id465261/index.html">Kekuatan sihir makro, atau cara membuat hidup lebih mudah bagi programmer assembler AVR</a></li>
<li><a href="../id465267/index.html">TypeScript Sihir Ekspresi</a></li>
<li><a href="../id465269/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 26. DNS dan DHCP</a></li>
<li><a href="../id465271/index.html">Peretas mencuri dan mencuci uang melalui pengiriman makanan dan layanan pemesanan hotel.</a></li>
<li><a href="../id465273/index.html">Bagaimana Pengembang Perangkat Lunak Microgaming Melindungi Pengguna dari Hacks</a></li>
<li><a href="../id465275/index.html">Alice Mendapat Keterampilan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>