<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíñ üç¥ üê¥ Ivan Tulup: asynchron in JS unter der Haube üôéüèª üë± üë∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kennst du Ivan Tulup? H√∂chstwahrscheinlich ja, Sie wissen nur noch nicht, um welche Art von Person es sich handelt, und Sie m√ºssen sehr genau auf den ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ivan Tulup: asynchron in JS unter der Haube</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417461/">  Kennst du Ivan Tulup?  H√∂chstwahrscheinlich ja, Sie wissen nur noch nicht, um welche Art von Person es sich handelt, und Sie m√ºssen sehr genau auf den Zustand seines Herz-Kreislauf-Systems achten. <br><br>  Dar√ºber und dar√ºber, wie Asynchronismus in JS unter der Haube funktioniert, wie Event Loop in Browsern und Node.js funktioniert, gibt es Unterschiede und m√∂glicherweise wurden √§hnliche Dinge von <strong>Mikhail Bashurov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">SaitoNakamura</a> ) in seinem Bericht √ºber RIT erz√§hlt ++.  Wir freuen uns, Ihnen das Protokoll dieser informativen Pr√§sentation mitteilen zu k√∂nnen. <br><br><img src="https://habrastorage.org/webt/mv/fj/ah/mvfjah-dahl8fndi-w8rt4qkbxw.jpeg"><br><br>  <strong>√úber den Sprecher:</strong> Mikhail Bashurov ist ein Fullstack-Webentwickler f√ºr JS und .NET von Luxoft.  Er liebt sch√∂ne Benutzeroberfl√§che, gr√ºne Tests, Transpilation, Kompilierung, Compiler-Technik und verbesserte Entwicklererfahrung. <br><br>  <strong>Anmerkung des Herausgebers:</strong> Mikhails Bericht wurde nicht nur von Folien begleitet, sondern auch von einem Demo-Projekt, in dem Sie auf Schaltfl√§chen klicken und die Ausf√ºhrung von Mischvorg√§ngen unabh√§ngig verfolgen k√∂nnen.  Die beste Option w√§re, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§sentation</a> in einem angrenzenden Tab zu √∂ffnen und regelm√§√üig darauf zu verweisen. Der Text enth√§lt jedoch auch Links zu bestimmten Seiten.  Und jetzt geben wir das Wort an den Sprecher weiter und genie√üen das Lesen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Gro√üvater Ivan Tulup </h2><br>  Ich hatte eine Kandidatur f√ºr Ivan Tulup. <br><br><img src="https://habrastorage.org/webt/hl/8x/lx/hl8xlx_fubycz-ivega_hinmhp0.png"><br><br>  Aber ich habe mich f√ºr einen konformistischeren Weg entschieden, also treffe dich - Gro√üvater Ivan Tulup! <br><br><img src="https://habrastorage.org/webt/qd/jc/dn/qdjcdntndkzeyiuw3zpwt4vos74.png"><br><br>  Tats√§chlich m√ºssen nur zwei Dinge √ºber ihn bekannt sein: <br><br><ol><li>  Er spielt gerne Karten. </li><li>  Er hat wie alle Menschen ein Herz und es schl√§gt. </li></ol><br><h2>  Fakten zum Herzinfarkt </h2><br>  Sie haben vielleicht geh√∂rt, dass F√§lle von Herzerkrankungen und deren Sterblichkeit in letzter Zeit h√§ufiger geworden sind.  Die wahrscheinlich h√§ufigste Herzkrankheit ist ein Herzinfarkt, dh ein Herzinfarkt. <br><br>  Was ist interessant an Herzinfarkt? <br><br><ul><li>  Meistens tritt es am Montagmorgen auf. </li><li>  Bei alleinstehenden Personen ist das Risiko eines Herzinfarkts doppelt so hoch.  Hier liegt der Punkt vielleicht nur in der Korrelation und nicht in einem kausalen Zusammenhang.  Leider (oder zum Gl√ºck) ist dies jedoch so. </li><li>  Zehn Dirigenten starben w√§hrend des Dirigierens an einem Herzinfarkt (anscheinend sehr nerv√∂se Arbeit!). </li><li>  Ein Herzinfarkt ist eine Nekrose des Herzmuskels, die durch einen Mangel an Durchblutung verursacht wird. </li></ul><br>  Wir haben eine Koronararterie, die Blut in den Muskel bringt (Myokard).  Wenn das Blut schlecht dorthin flie√üt, stirbt der Muskel allm√§hlich ab.  Dies wirkt sich nat√ºrlich √§u√üerst negativ auf das Herz und seine Arbeit aus. <br><br>  Gro√üvater Ivan Tulup hat auch ein Herz und es schl√§gt.  Aber unser Herz pumpt Blut und das Herz von Ivan Tulup pumpt unseren Code und unsere Sorgen. <br><br><h2>  Tasky: ein gro√üer Kreislauf der Durchblutung <br></h2><br>  Was sind Aufgaben?  Was kann in einem Browser generell faul sein?  Warum werden sie √ºberhaupt gebraucht? <br><br>  Zum Beispiel f√ºhren wir Code aus einem Skript aus.  Dies ist ein Herzschlag, und jetzt haben wir Blutfluss.  Wir haben auf die Schaltfl√§che geklickt und das Ereignis abonniert - der Ereignishandler f√ºr dieses Ereignis hat ausgespuckt - den R√ºckruf, den wir gesendet haben.  Sie setzten Timeout, Callback funktionierte - eine weitere Aufgabe.  Und so ist in Teilen ein Herzschlag eine Aufgabe. <br><br><img src="https://habrastorage.org/webt/vz/sb/0z/vzsb0znwotnkpldqmb2chhwblxs.png"><br><br>  Es gibt viele verschiedene Kohlquellen, je nach Spezifikation gibt es viele davon.  Unser Herz schl√§gt weiter und w√§hrend es schl√§gt, ist alles in Ordnung mit uns. <br><br><h3>  Ereignisschleife im Browser: vereinfachte Version <br></h3><br>  Dies kann in einem sehr einfachen Diagramm dargestellt werden. <br><br><img src="https://habrastorage.org/webt/hy/zf/2p/hyzf2pktcyzag0oroich978odpa.png"><br><br><ul><li>  Es gibt eine Aufgabe, wir haben sie erledigt. </li><li>  Dann f√ºhren wir das Browser-Rendering aus. </li></ul><br>  Dies ist jedoch nicht erforderlich, da der Browser in einigen F√§llen m√∂glicherweise nicht zwischen zwei Aufgaben rendert. <br><br>  Dies kann beispielsweise passieren, wenn der Browser mehrere Zeit√ºberschreitungen oder mehrere Bildlaufereignisse gruppieren kann.  Oder irgendwann geht etwas schief und der Browser entscheidet anstelle von 60 fps (normale Bildrate, damit alles k√ºhl und fl√ºssig wird), 30 fps anzuzeigen.  Auf diese Weise hat er viel mehr Zeit, um Ihren Code und andere n√ºtzliche Arbeiten auszuf√ºhren. Er kann mehrere Schocks ausf√ºhren. <br><br>  Daher wird das Rendern nicht wirklich nach jeder Aufgabe ausgef√ºhrt. <br><br><h3>  Aufgabe: Klassifizierung <br></h3><br>  Es gibt zwei Arten von m√∂glichen Operationen: <br><br><ol><li>  E / A gebunden; </li><li>  CPU gebunden. </li></ol><br>  <strong>CPU-gebunden</strong> ist unsere n√ºtzliche Arbeit, die wir leisten (glauben, anzeigen usw.) <br><br>  <strong>E / A-gebunden</strong> sind die Punkte, an denen wir unsere Aufgaben teilen k√∂nnen.  Das kann sein: <br><br><ul><li>  Zeit√ºberschreitung </li></ul>  Wir haben setTimeout 5000 ms erstellt und warten nur auf diese 5000 ms, aber wir k√∂nnen andere n√ºtzliche Arbeiten ausf√ºhren.  Erst wenn diese Zeit vergeht, erhalten wir einen R√ºckruf und arbeiten daran. <br><br><ul><li>  xhr / fetch. </li></ul>  Wir sind online gegangen.  W√§hrend wir auf eine Antwort vom Netzwerk warten, warten wir nur, aber wir k√∂nnen auch etwas N√ºtzliches tun. <br><br><ul><li>  Netzwerk (OBD). </li></ul>  Oder wir gehen zum Beispiel zu Network BD.  Wir sprechen auch √ºber Node.js, einschlie√ülich, und wenn wir von Node.js irgendwo ins Netzwerk gehen m√∂chten, bitte - dies ist dieselbe potenzielle E / A-gebundene Aufgabe (Eingabe / Ausgabe). <br><br><ul><li>  Datei. </li></ul>  Lesen Sie die Datei - m√∂glicherweise handelt es sich √ºberhaupt nicht um eine CPU-gebundene Aufgabe.  In Node.js wird es aufgrund einer leicht krummen Linux-API im Thread-Pool ausgef√ºhrt, um ehrlich zu sein. <br><br>  Dann ist CPUbound: <br><br><ul><li>  Zum Beispiel, wenn wir eine for of / for (;;) - Schleife ausf√ºhren oder das Array irgendwie mit zus√§tzlichen Methoden durchlaufen: Filter, Map usw. </li><li>  JSON.parse oder JSON.stringify, d. H. Nachrichtenserialisierung / -deserialisierung.  Dies geschieht alles auf der CPU. Wir k√∂nnen es kaum erwarten, dass alles irgendwo magisch ausgef√ºhrt wird. </li><li>  Z√§hlen von Hashes, d. H. Krypto-Mining. </li></ul><br>  Nat√ºrlich kann Krypto auch auf der GPU abgebaut werden, aber ich denke - GPU, CPU - Sie verstehen diese Analogie. <br><br><h3>  Aufgabe: Arrhythmie und Thrombus </h3><br>  Infolgedessen stellt sich heraus, dass unser Herz schl√§gt: Es erledigt eine Aufgabe, die zweite, die dritte - bis wir etwas falsch machen.  Zum Beispiel gehen wir ein Array von 1 Million Elementen durch und z√§hlen die Summe.  Es scheint, dass dies nicht so schwierig ist, aber es kann greifbare Zeit dauern.  Wenn wir uns st√§ndig Zeit nehmen, ohne die Aufgabe freizugeben, kann unser Rendern nicht ausgef√ºhrt werden.  Er schwebte in dieser Sehnsucht, und alle Arrhythmien beginnen. <br><br>  Ich denke, jeder versteht, dass Arrhythmie eine ziemlich unangenehme Herzkrankheit ist.  Aber du kannst immer noch mit ihm leben.  Was passiert, wenn Sie eine Aufgabe platzieren, bei der einfach die gesamte Ereignisschleife in einer Endlosschleife h√§ngt?  Sie legen ein Blutgerinnsel in die Herzkranzgef√§√üe oder eine andere Arterie, und alles wird v√∂llig traurig.  Leider wird unser Gro√üvater Ivan Tulup sterben. <br><br><h3>  Also starb Gro√üvater Ivan ... <br></h3><br><img src="https://habrastorage.org/webt/8t/nq/gc/8tnqgc8lygwpsdvts0b3xpqgtta.png"><br><br>  F√ºr uns bedeutet dies, dass der gesamte Tab vollst√§ndig einfriert - Sie k√∂nnen auf nichts klicken, und dann sagt Chrome: "Aw, Snap!" <br><br>  Dies ist noch viel schlimmer als Website-Fehler, wenn etwas schief gelaufen ist.  Aber wenn √ºberhaupt alles h√§ngen blieb und wahrscheinlich sogar die CPU geladen und der Benutzer im Allgemeinen h√§ngen geblieben ist, wird er h√∂chstwahrscheinlich nie wieder auf Ihre Site gehen. <br><br>  Die Idee lautet daher: Wir haben eine Aufgabe, und wir m√ºssen nicht lange an dieser Aufgabe festhalten.  Wir m√ºssen es schnell freigeben, damit der Browser, wenn √ºberhaupt, rendern kann (wenn er will).  Wenn du nicht willst - gro√üartig, tanz! <br><br><h2>  Philip Roberts Demo: Lupe von Philip Roberts <br></h2><br>  Betrachten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> : <br><br><pre><code class="javascript hljs">$.on(<span class="hljs-string"><span class="hljs-string">'button'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'click'</span></span>); }); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span> log(<span class="hljs-string"><span class="hljs-string">"timeout"</span></span>); }. <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(‚ÄúHello world<span class="hljs-string"><span class="hljs-string">");</span></span></code> </pre> <br>  Das Wesentliche ist: Wir haben eine Schaltfl√§che, wir abonnieren sie (addEventListener), Timeout wird f√ºr 5 Sekunden aufgerufen und sofort in der console.log schreiben wir "Hallo Welt!", In setTimeout schreiben wir Timeout, in onClick schreiben wir Click. <br><br>  Was passiert, wenn wir es ausf√ºhren und oft auf die Schaltfl√§che klicken - wann wird das Timeout tats√§chlich ausgef√ºhrt?  Schauen wir uns die Demo an: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Der Code beginnt auszuf√ºhren, wird auf den Stapel gesetzt, Timeout geht.  In der Zwischenzeit haben wir auf den Button geklickt.  Am Ende der Warteschlange wurden mehrere Ereignisse hinzugef√ºgt.  W√§hrend Click ausgef√ºhrt wird, wartet Timeout, obwohl 5 Sekunden vergangen sind. <br><br>  Hier ist onClick schnell, aber wenn Sie eine l√§ngere Aufgabe stellen, friert alles ein, wie bereits erl√§utert.  Dies ist ein sehr vereinfachtes Beispiel.  Hier ist eine Runde, aber in Browsern ist tats√§chlich nicht alles so. <br><br>  In welcher Reihenfolge werden Ereignisse ausgef√ºhrt - was sagt die HTML-Spezifikation aus? <br><br>  Sie sagt folgendes: Wir haben 2 Konzepte: <br><br><ol><li>  Aufgabenquelle; </li><li>  Aufgabenwarteschlange. </li></ol><br>  Die Aufgabenquelle ist eine Art Aufgabe.  Dies kann eine Benutzerinteraktion sein, dh onClick, onChange - etwas, mit dem der Benutzer interagiert.  oder Zeitgeber, d. h. setTimeout und setInterval oder PostMessages;  oder sogar vollst√§ndig wilde Typen wie die Canvas Blob Serialization-Taskquelle - ebenfalls ein separater Typ. <br><br>  Die Spezifikation besagt, dass f√ºr dieselbe Aufgabe Quellaufgaben garantiert in der Reihenfolge ausgef√ºhrt werden, in der sie hinzugef√ºgt werden.  F√ºr alles andere ist nichts garantiert, da es eine unbegrenzte Anzahl von Aufgabenwarteschlangen geben kann.  Der Browser entscheidet, wie viele es sein werden.  Mithilfe der Aufgabenwarteschlange und ihrer Erstellung kann der Browser bestimmte Aufgaben priorisieren. <br><br><h3>  Browserpriorit√§ten und Aufgabenwarteschlangen <br></h3><br><img src="https://habrastorage.org/webt/xv/fu/s9/xvfus9kn-18e_oxy00s_xwm6vdq.png"><br><br>  Stellen Sie sich vor, wir haben 3 Zeilen: <br><br><ol><li>  Benutzerinteraktion; </li><li>  Zeit√ºberschreitungen </li><li>  Nachrichten posten. </li></ol><br>  Der Browser beginnt, Aufgaben aus diesen Warteschlangen abzurufen: <br><br><ul><li>  Erstens √ºbernimmt er die <strong>Fokus-</strong> Benutzerinteraktion - das ist sehr wichtig - ein Herzschlag ist vergangen. <br></li><li>  Dann nimmt er <strong>postMessages</strong> - na <strong>ja</strong> , postMessages hat ziemlich hohe Priorit√§t, cool! <br></li><li>  Der n√§chste, <strong>onChange,</strong> hat ebenfalls wieder Priorit√§t f√ºr die Benutzerinteraktion. <br></li><li>  Als <strong>n√§chstes wird onClick</strong> gesendet.  Die Benutzerinteraktionswarteschlange ist beendet. Wir haben dem Benutzer alles angezeigt, was ben√∂tigt wird. <br></li><li>  Dann nehmen wir <strong>setInterval</strong> und f√ºgen postMessages hinzu. <br></li><li>  <strong>setTimeout f√ºhrt nur die aktuellste aus</strong> .  Er war irgendwo am Ende der Leitung. <br></li></ul><br>  Dies ist wieder ein sehr vereinfachtes Beispiel, und leider kann <strong>niemand garantieren, wie dies in Browsern funktioniert</strong> , da sie dies alles selbst entscheiden.  Sie m√ºssen dies selbst testen, wenn Sie herausfinden m√∂chten, was es ist. <br><br>  Beispielsweise hat postMessages Vorrang vor setTimeout.  M√∂glicherweise haben Sie von so etwas wie setImmediate geh√∂rt, das beispielsweise in IE-Browsern nur nativ war.  Es gibt jedoch Polydateien, die haupts√§chlich nicht auf setTimeout basieren, sondern darauf, einen postMessages-Kanal zu erstellen und ihn zu abonnieren.  Dies funktioniert im Allgemeinen schneller, da Browser Priorit√§ten setzen. <br><br>  Nun, diese Aufgaben werden ausgef√ºhrt.  Wann beenden wir unsere Aufgabe und verstehen, dass wir die n√§chste √ºbernehmen oder rendern k√∂nnen? <br><br><h3>  Stapel </h3><br>  Der Stapel ist eine einfache Datenstruktur, die nach dem Prinzip "last in - first out" arbeitet, d.h.  "Ich habe den letzten gesetzt - du bekommst den ersten <strong>.</strong> "  Das n√§chste, wahrscheinlich echte Gegenst√ºck ist ein Kartenspiel.  Deshalb spielt unser Gro√üvater Ivan Tulup gerne Karten. <br><br><img src="https://habrastorage.org/webt/5b/03/dh/5b03dh5di0r9oktsyvekmflkey4.png"><br><br>  Im obigen Beispiel, in dem Code enthalten ist, kann dasselbe Beispiel in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§sentation verwendet werden</a> .  An einer Stelle rufen wir handleClick auf, geben console.log ein, rufen showPopup und window auf.  best√§tigen.  Bilden wir einen Stapel. <br><br><ul><li>  Also nehmen wir zuerst handleClick und schieben den Aufruf dieser Funktion auf den Stack - gro√üartig! </li><li>  Dann gehen wir in seinen K√∂rper und f√ºhren ihn aus. </li><li>  Wir legen console.log auf den Stack und f√ºhren es sofort aus, da alles vorhanden ist, um es auszuf√ºhren. </li><li>  Als n√§chstes setzen wir showConfirm - dies ist ein Funktionsaufruf - gro√üartig. </li><li>  Wir setzen Funktionen auf den Stapel - wir setzen seinen K√∂rper, das hei√üt window.confirm. </li></ul><br>  Wir haben nichts mehr - wir machen es.  Ein Fenster √∂ffnet sich: "Sind Sie sicher?", Klicken Sie auf "Ja" und alles verl√§sst den Stapel.  Jetzt haben wir den showConfirm-Body und den handleClick-Body fertiggestellt.  Unser Stapel wird gel√∂scht und wir k√∂nnen mit der n√§chsten Aufgabe fortfahren.  Frage: OK, ich wei√ü jetzt, dass Sie alles in kleine St√ºcke zerbrechen m√ºssen.  Wie kann ich das zum Beispiel im elementarsten Fall tun? <br><br><h3>  Partitionieren eines Arrays in Chunks und asynchrone Verarbeitung </h3><br>  Schauen wir uns das Beispiel mit der meisten Stirn an.  Ich warne Sie sofort: Bitte versuchen Sie nicht, dies zu Hause zu wiederholen - es wird nicht kompiliert. <br><br><img src="https://habrastorage.org/webt/on/a4/kz/ona4kz7lojjan82vfis4dkoxvh0.png"><br><br>  Wir haben ein gro√ües, gro√ües Array und m√∂chten etwas basierend darauf berechnen, um beispielsweise einige Bin√§rdaten zu analysieren.  Wir k√∂nnen es einfach in St√ºcke zerbrechen: Verarbeiten Sie dieses St√ºck, dies und das.  Wir w√§hlen die Gr√∂√üe des Blocks aus, zum Beispiel 10 Tausend Elemente. Wir √ºberlegen, wie viele Bl√∂cke wir haben werden.  Wir haben eine parseData-Funktion, die CPU-gebunden ist und wirklich etwas Schweres tun kann.  Dann zerlegen wir das Array in Bl√∂cke, machen setTimeout (() =&gt; parseData (Slice), 0). <br><br>  In diesem Fall kann der Browser die Benutzerinteraktion wieder priorisieren und dazwischen rendern.  Das hei√üt, Sie geben zumindest Ihre Ereignisschleife frei und sie funktioniert weiterhin.  Dein Herz schl√§gt weiter und das ist gut so. <br><br>  Aber das ist wirklich ein sehr "Stirn" Beispiel.  Es gibt viele APIs in Browsern, mit denen Sie dies auf speziellere Weise tun k√∂nnen. <br><br>  Neben setTimeout und setInterval gibt es APIs, die √ºber die Grenzen hinausgehen, z. B. requestAnimationFrame und requestIdleCallback. <br><br>  Wahrscheinlich sind viele mit <strong>requestAnimationFrame</strong> vertraut und verwenden es sogar bereits.  Es wird vor dem Rendern ausgef√ºhrt.  Sein Reiz ist, dass erstens versucht wird, alle 60 fps (oder 30 fps) auszuf√ºhren, und zweitens alles unmittelbar vor dem Erstellen des CSS-Objektmodells usw. erfolgt. <br><br><img src="https://habrastorage.org/webt/0-/hy/qt/0-hyqtkge9dm9ayeciqrrzgjors.png"><br><br>  Selbst wenn Sie mehrere requestAnimationFrame haben, werden alle √Ñnderungen gruppiert und der Frame wird vollst√§ndig ausgegeben.  Im Fall von setTimeout k√∂nnen Sie eine solche Garantie sicherlich nicht erhalten.  Ein setTimeout √§ndert eine Sache, die andere eine andere, und dazwischen kann das Rendern verrutschen - Sie haben ein Ruckeln auf dem Bildschirm oder etwas anderes.  RequestAnimationFrame ist daf√ºr gro√üartig. <br><br>  Dar√ºber hinaus gibt es auch <strong>requestIdleCallback.</strong>  Vielleicht haben Sie geh√∂rt, dass es in React v16.0 (Fibre) verwendet wird.  RequestIdleCallback funktioniert so, dass es cool zu sein scheint, wenn der Browser versteht, dass zwischen Frames (60 fps) Zeit ist, um etwas N√ºtzliches zu tun, und gleichzeitig bereits alles getan hat - sie haben die Aufgabe erledigt, requestAnimationFrame -, es scheint cool zu sein kann kleine Quanten erzeugen, beispielsweise jeweils 50 ms, so dass Sie etwas tun k√∂nnen (IDLE-Modus). <br><br>  Es befindet sich nicht im obigen Diagramm, da es sich nicht an einem bestimmten Ort befindet.  Der Browser kann entscheiden, es vor dem Frame, nach dem Frame, zwischen dem requestAnimationFrame und dem Render, nach der Task, vor der Task zu platzieren.  Niemand kann dies garantieren. <br><br>  Es ist Ihnen garantiert, dass requestIdleCallback Ihr Ausweg ist, wenn Sie Arbeiten haben, die nicht mit dem √Ñndern des DOM zusammenh√§ngen (denn dann ist requestAnimationFrame eine Animation usw.), obwohl dies keine √ºbergeordnete Priorit√§t, sondern greifbar ist. <br><br>  Wenn wir also eine lange CPU-gebundene Operation haben, k√∂nnen wir versuchen, sie in Teile zu zerlegen. <br><br><ul><li>  Wenn dies eine DOM-√Ñnderung ist, verwenden Sie <strong>requestAnimationFrame.</strong> <br></li><li>  Wenn dies eine nicht priorisierte, kurzlebige und nicht schwierige Aufgabe ist, die <strong>die</strong> CPU nicht <strong>√ºberlastet</strong> , <strong>fordern Sie IdleCallback an.</strong> <br></li><li>  Wenn wir eine gro√üe, leistungsstarke Aufgabe haben, die st√§ndig ausgef√ºhrt werden muss, gehen wir √ºber die Ereignisschleife hinaus und verwenden WebWorker.  Es gibt keinen anderen Weg. <br></li></ul><br>  <strong>Aufgaben in Browsern:</strong> <br><br><ol><li>  Zerquetsche alles in kleine Aufgaben. </li><li>  Es gibt viele Arten von Aufgaben. </li><li>  Aufgaben werden von diesen Typen √ºber Spezifikationswarteschlangen priorisiert. </li><li>  Browser entscheiden viel, und der einzige Weg, um zu verstehen, wie es funktioniert, besteht darin, einfach zu √ºberpr√ºfen, ob der eine oder andere Code ausgef√ºhrt wird. </li><li>  Die Spezifikation wird jedoch nicht immer eingehalten! </li></ol><br>  Das Problem ist, dass unser Ivan Tulup ein alter Gro√üvater ist, weil die Event-Loop-Implementierungen in Browsern auch sehr alt sind.  Sie wurden erstellt, bevor die Spezifikation geschrieben wurde, daher wird die Spezifikation leider respektiert, sofern.  Selbst wenn Sie lesen, wie die Spezifikation aussehen sollte, garantiert niemand, dass alle Browser sie unterst√ºtzen.  √úberpr√ºfen Sie daher unbedingt in den Browsern, wie dies tats√§chlich funktioniert. <br><br>  Gro√üvater Ivan Tulup in Browsern ist eine schlecht vorhersehbare Person mit einigen interessanten Funktionen, an die Sie sich erinnern m√ºssen. <br><br><h2>  Terminator Santa: Maskottchenschleife bei Node.js. <br></h2><br>  Node.js ist eher so jemand. <br><br><img src="https://habrastorage.org/webt/bb/5u/bx/bb5ubx5cvdgtu2lilmk-rfmeajc.png"><br><br>  Denn einerseits ist es derselbe Gro√üvater mit Bart, aber gleichzeitig ist alles in Phasen verteilt und es ist klar gemalt, wo was getan wird. <br><br>  <strong>Phasen der Ereignisschleife in Node.js:</strong> <br><br><ul><li>  Timer; <br></li><li>  ausstehender R√ºckruf; <br></li><li>  unt√§tig, vorbereiten; <br></li><li>  Umfrage; <br></li><li>  √ºberpr√ºfen; <br></li><li>  R√ºckrufe schlie√üen. <br></li></ul><br>  Alles au√üer dem letzten ist nicht sehr klar, was es bedeutet.  Die Phasen haben so seltsame Namen, weil wir unter der Haube, wie wir bereits wissen, Libuv haben, um alle zu regieren: <br><br><ul><li>  <em>Linux -</em> Epoll / POSIX AIO; <br></li><li>  <em>BSD -</em> Warteschlange; <br></li><li>  <em>Windows -</em> IOCP; <br></li><li>  <em>Solaris -</em> Ereignisports. <br></li></ul><br>  Tausende von allen! <br><br>  Dar√ºber hinaus bietet Libuv dieselbe Ereignisschleife.  Es hat nicht die Besonderheiten von Node.js, aber es gibt Phasen, und Node.js verwendet sie nur.  Aber aus irgendeinem Grund nahm sie die Namen von dort. <br><br>  Mal sehen, was jede Phase tats√§chlich bedeutet. <br><br><h4>  Die Timer-Phase f√ºhrt Folgendes aus: <br></h4><br><ul><li>  R√ºckrufbereite Timer; <br></li><li>  setTimeout und setInterval; <br></li><li>  Aber <strong>NICHT</strong> setImmediate ist eine andere Phase. <br></li></ul><br><h4>  Phase ausstehende R√ºckrufe <br></h4><br>  Zuvor wurde in der Dokumentationsphase E / A-R√ºckrufe genannt.  Zuletzt wurde diese Dokumentation korrigiert und widersprach sich nicht mehr.  Zuvor wurde an einer Stelle geschrieben, dass E / A-R√ºckrufe in dieser Phase ausgef√ºhrt werden, an einer anderen - in der Abfragephase.  Aber jetzt ist dort alles eindeutig und gut geschrieben. Lesen Sie also die Dokumentation - etwas wird viel verst√§ndlicher. <br><br>  In der anstehenden R√ºckrufphase werden R√ºckrufe von einigen Systemoperationen (TCP-Fehler) ausgef√ºhrt.  Das hei√üt, wenn unter Unix ein Fehler im TCP-Socket vorliegt, m√∂chte er ihn in diesem Fall nicht sofort wegwerfen, sondern im R√ºckruf, der gerade in dieser Phase ausgef√ºhrt wird.  Das ist alles was wir √ºber sie wissen m√ºssen.  Wir sind praktisch nicht daran interessiert. <br><br><h4>  Phase Leerlauf, vorbereiten <br></h4><br>  In dieser Phase k√∂nnen wir √ºberhaupt nichts tun, daher werden wir es im Prinzip vergessen. <br><br><img src="https://habrastorage.org/webt/xa/6l/n-/xa6ln-ao3qbubxteqecnh8lm5ke.png"><br><br><h4>  Umfragephase <br></h4><br>  Dies ist die interessanteste Phase in Node.js, da sie die wichtigste n√ºtzliche Arbeit leistet: <br><br><ul><li>  F√ºhrt E / A-R√ºckrufe durch (keine ausstehende R√ºckrufphase!). </li><li>  Warten auf Ereignisse von I / O; </li><li>  Es ist cool, setImmediate zu machen. </li><li>  Keine Timer; </li></ul><br>  Mit Blick auf die Zukunft wird setImmediate in der n√§chsten Pr√ºfphase ausgef√ºhrt, dh vor Timern garantiert. <br><br>  Au√üerdem steuert die Abfragephase den Ablauf der Ereignisschleife.  Wenn wir zum Beispiel keine Timer haben, gibt es kein setImmediate, dh niemand hat den Timer gemacht, setImmediate hat nicht aufgerufen, wir blockieren einfach in dieser Phase und warten auf das Ereignis von I / O, wenn etwas zu uns kommt, wenn es R√ºckrufe gibt wenn wir uns f√ºr etwas angemeldet haben. <br><br>  Wie wird ein nicht blockierendes Modell implementiert?  Zum Beispiel k√∂nnen wir bei demselben Epoll ein Ereignis abonnieren - √∂ffnen Sie einen Socket und warten Sie, bis etwas darauf geschrieben wird.  Zus√§tzlich ist das zweite Argument eine Zeit√ºberschreitung, d.h.  Wir werden auf Epoll warten, aber wenn das Timeout endet und das Ereignis von I / O nicht eintritt, wird das Timeout beendet.  Wenn ein Ereignis aus dem Netzwerk zu uns kommt (jemand schreibt in den Socket), wird es kommen. <br><br>  Daher ruft die Abfragephase den fr√ºhesten R√ºckruf vom Heap ab (der Heap ist eine Datenstruktur, die eine gut sortierte Zustellung und Zustellung erm√∂glicht), nimmt seine Zeit√ºberschreitung, schreibt in diese Zeit√ºberschreitung und gibt alles frei.  Selbst wenn niemand in den Socket schreibt, funktioniert das Timeout, kehrt zur Abfragephase zur√ºck und die Arbeit wird fortgesetzt. <br><br><blockquote>  Es ist wichtig zu beachten, dass in der Abfragephase die Anzahl der R√ºckrufe gleichzeitig begrenzt ist. <br></blockquote><br>  Es ist traurig, dass dies in den verbleibenden Phasen nicht der Fall ist.  Wenn Sie eine Zeit√ºberschreitung von 10 Milliarden hinzuf√ºgen, f√ºgen Sie eine Zeit√ºberschreitung von 10 Milliarden hinzu.  Daher ist die n√§chste Phase die Pr√ºfphase. <br><br><h4>  Phase pr√ºfen </h4><br>  Hier wird setImmediate ausgef√ºhrt.  Die Phase ist wundersch√∂n, da setImmediate, das in der Abfragephase aufgerufen wird, garantiert fr√ºher als der Timer ausgef√ºhrt wird.  Weil der Timer erst ganz am Anfang und fr√ºher in der Abfragephase auf dem n√§chsten Tick steht.  Daher k√∂nnen wir keine Angst vor der Konkurrenz mit anderen Timern haben und diese Phase f√ºr die Dinge verwenden, die wir aus irgendeinem Grund nicht in einem R√ºckruf ausf√ºhren m√∂chten. <br><br><h4>  R√ºckrufe zum Schlie√üen der Phase </h4><br>  In dieser Phase werden nicht alle R√ºckrufe zum Schlie√üen des Sockets und andere Typen ausgef√ºhrt: <br><br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, ‚Ä¶).</code> </pre><br>  Sie f√ºhrt sie nur aus, wenn dieses Ereignis unerwartet flog, zum Beispiel jemand am anderen Ende schickte: "Alles - schlie√üen Sie die Steckdose - gehen Sie von hier aus, Vasya!"  Dann funktioniert diese Phase, da das Ereignis unerwartet ist.  Dies betrifft uns jedoch nicht besonders. <br><br><h3>  Falsche asynchrone Verarbeitung von Chunks in Node.js </h3><br>  Was passiert, wenn wir das gleiche Muster, das wir in Browsern mit setTimeout verwendet haben, auf Node.js setzen - das hei√üt, wir teilen das Array f√ºr jeden Block, den wir setTimeout - 0 machen, in Bl√∂cke auf. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bigArray = [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_000_000] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chunks = getChunks(bigArray) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data for (chunk of chunks) { setTimeout(() =&gt; parseData(slice), 0) }</span></span></code> </pre><br>  Denken Sie, dass es damit Probleme gibt? <br><br>  Ich bin schon ein bisschen vorausgelaufen, als ich sagte, wenn Sie 10 Tausend Timeout (oder 10 Milliarden!) Hinzuf√ºgen, befinden sich 10 Tausend Timer in der Warteschlange, und er wird sie erhalten und ausf√ºhren - es gibt keinen Schutz davor: get - execute, get - zu erf√ºllen und so weiter ad infinitum. <br><br>  Nur in der Abfragephase, wenn wir st√§ndig ein Ereignis von E / A erhalten, schreibt immer jemand etwas in den Socket, damit wir mindestens Timer und setImmediate ausf√ºhren k√∂nnen, es hat einen Grenzschutz und es ist systemabh√§ngig.  Das hei√üt, es wird auf verschiedenen Betriebssystemen unterschiedlich sein. <br><br>  Leider haben andere Phasen, einschlie√ülich Timer und setImmediate, <strong>keinen solchen Schutz.</strong>  Wenn Sie also wie im Beispiel vorgehen, friert alles ein und erreicht die Abfragephase f√ºr eine sehr lange Zeit nicht. <br><br>  Aber glauben Sie, dass sich etwas √§ndern wird, wenn wir setTimeout (() =&gt; parseData (Slice), 0) durch setImmediate (() =&gt; parseData (Slice)) ersetzen?  - Nat√ºrlich gibt es dort auch keinen Schutz f√ºr die Kontrollphase. <br><br>  Um dieses Problem zu l√∂sen, k√∂nnen Sie die <strong>rekursive Verarbeitung</strong> aufrufen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data const recursiveAsyncParseData = (i) =&gt; { parseData(getChunk(i)) setImmediate(() =&gt; recursiveAsyncParseData(i + 1)) } recursiveAsyncParseData(0)</span></span></code> </pre><br>  Unter dem Strich haben wir die Funktion parseData verwendet und ihren rekursiven Aufruf geschrieben, aber nicht nur uns selbst, sondern √ºber setImmediate.  Wenn Sie dies in der setImmediate-Phase aufrufen, wird das n√§chste H√§kchen und nicht das aktuelle angekreuzt.  Dadurch wird die Ereignisschleife freigegeben und im Kreis weitergef√ºhrt.  Das hei√üt, wir haben recursiveAsyncParseData, wo wir einen bestimmten Index √ºbergeben, den Block anhand dieses Index abrufen, ihn analysieren - und dann die Warteschlange setImmediate mit dem n√§chsten Index setzen.  Es wird zu unserem n√§chsten Tick kommen und wir k√∂nnen diese ganze Sache rekursiv verarbeiten. <br><br>  Das Problem ist zwar, dass dies immer noch eine Art CPU-gebundene Aufgabe ist.  Vielleicht wiegt sie sich noch irgendwie und nimmt sich Zeit in Event Loop.  H√∂chstwahrscheinlich m√∂chten Sie, dass Ihre Node.js rein E / A-gebunden sind. <br>  Daher ist es besser, einige andere Dinge zu verwenden, z. B. den <strong>Prozessgabel / Thread-Pool.</strong> <br><br>  Jetzt wissen wir √ºber Node.js, dass: <br><br><ul><li>  alles ist in Phasen verteilt - nun, das wissen wir klar; <br></li><li>  Es gibt Schutz vor zu langer Abstimmungsphase, aber nicht vor dem Rest. <br></li><li>  rekursive Verarbeitungsmuster k√∂nnen angewendet werden, um die Ereignisschleife nicht zu blockieren; </li><li>  Es ist jedoch besser, Process Fork, Thread Pool und Child Process zu verwenden </li></ul><br>  Sie sollten auch mit dem Thread-Pool vorsichtig sein, da Node.js dort Dinge startet, insbesondere die DNS-Aufl√∂sung, da die DNS-Aufl√∂sungsfunktion f√ºr Linux aus irgendeinem Grund nicht asynchron ist.  Daher muss es in ThreadPool ausgef√ºhrt werden.  Unter Windows zum Gl√ºck nicht.  Dort k√∂nnen Sie Dateien aber asynchron lesen.  Unter Linux ist das leider unm√∂glich. <br><br>  Meiner Meinung nach betr√§gt das Standardlimit 4 Prozesse in ThreadPool.  Wenn Sie dort aktiv etwas tun, konkurriert es daher mit allen anderen - mit fs und anderen.  Sie k√∂nnen ThreadPool erh√∂hen, aber auch sehr sorgf√§ltig.  Lesen Sie also etwas zu diesem Thema. <br><br><h2>  Mikrotask: Lungenkreislauf </h2><br>  Wir haben Aufgaben in Node.js und Aufgaben in Browsern.  M√∂glicherweise haben Sie bereits von Mikrotask geh√∂rt.  Mal sehen, was es ist und wie sie funktionieren, und mit Browsern beginnen. <br><br><h3>  Mikrotask in Browsern <br></h3><br>  Um zu verstehen, wie Mikrotasking funktioniert, wenden wir uns dem Ereignisschleifenalgorithmus gem√§√ü dem whatwg-Standard zu. Gehen wir also zur Spezifikation und sehen Sie, wie alles aussieht. <br><br><img src="https://habrastorage.org/webt/cb/kj/76/cbkj76j9xqsivioo2demagbbfty.png"><br><br>  In die menschliche Sprache √ºbersetzt sieht es ungef√§hr so ‚Äã‚Äãaus: <br><br><ul><li>  Nehmen Sie die freie Aufgabe von unserer Linie </li><li>  Wir f√ºhren es aus </li><li>  Wir f√ºhren einen Mikrotask-Checkpoint durch - OK, wir wissen immer noch nicht, was es ist, aber wir erinnern uns daran. </li><li>  Wir aktualisieren das Rendering (falls erforderlich) und kehren zum ersten Punkt zur√ºck. </li></ul><br><img src="https://habrastorage.org/webt/1h/rs/ce/1hrsceluhstlxrdjjr7ig2wh9l0.png"><br><br>  Sie werden an der im Diagramm angegebenen Stelle und an mehreren weiteren Stellen durchgef√ºhrt, √ºber die wir bald erfahren werden.  Das hei√üt, die Aufgabe ist beendet, Mikrotasking wird ausgef√ºhrt. <br><br><h3>  Quellen von Mikrotuckern </h3><br><ul><li>  <strong>Versprechen.</strong> </li></ul><br>  Wichtig - nicht Versprechen selbst, n√§mlich Versprechen.  Der R√ºckruf, der dann platziert wurde, ist eine Mikrotask.  Wenn Sie dann 10 angerufen haben - Sie haben 10 Mikrowagen, dann 10 Tausend - 10 Tausend Kleinstwagen. <br><br><ul><li>  <strong>Mutationsbeobachter.</strong> <br></li><li>  <strong>Object.observe</strong> , das veraltet ist und niemand braucht. <br></li></ul><br>  Wie viele verwenden den Mutationsbeobachter? <br><br>  Ich denke, nur wenige verwenden den Mutationsbeobachter.  Wahrscheinlich wird Promise.then h√§ufiger verwendet, deshalb werden wir es im Beispiel betrachten. <br><br>  <strong>Merkmale des Mikrotask-Checkpoints:</strong> <br><br><ul><li>  <strong>Wir machen alles</strong> - das bedeutet, dass wir alle Mikrotasks ausf√ºhren, die wir bis zum Ende in der Warteschlange haben.  Wir lassen nichts los - wir nehmen und tun einfach alles, was ist, sie sollten mikro sein, oder? </li><li>  Sie k√∂nnen dabei immer noch neue Mikrotask generieren, die am selben Mikrotask-Pr√ºfpunkt ausgef√ºhrt werden. </li><li>  Was auch wichtig ist - sie werden nicht nur nach der Ausf√ºhrung der Aufgabe ausgef√ºhrt, sondern auch nach dem Reinigen des Stapels. </li></ul><br>  Dies ist ein interessanter Punkt.  Es stellt sich heraus, dass es m√∂glich ist, neue Mikrotasks zu generieren, und wir alle werden sie bis zum Ende erf√ºllen.  Was kann uns das f√ºhren? <br><br><img src="https://habrastorage.org/webt/yr/i_/i9/yri_i9mhp2jz-6nyyj7pvfwl6yg.png"><br>  Wir haben zwei Herzen.  Ich habe das erste Herz mit JS-Animation und das zweite mit CSS-Animation animiert.  Es gibt noch eine weitere gro√üartige Funktion namens starveMicrotasks.  Wir rufen Promise.resolve auf und setzen dann die gleiche Funktion ein. <br>  Sehen Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§sentation,</a> was passiert, wenn Sie diese Funktion aufrufen. <br><br>  Ja, das Herz von JS wird aufh√∂ren, weil wir eine Mikrotask hinzuf√ºgen und dann eine Mikrotask hinzuf√ºgen und dann eine Mikrotask hinzuf√ºgen ... Und so endlos. <br><br>  Das hei√üt, der rekursive Aufruf von Microtucks wird alles h√§ngen lassen.  Aber es scheint, dass ich alles asynchron habe!  Es sollte losgelassen werden, ich habe dort setTimeout angerufen.  Nein!  Leider m√ºssen Sie mit Mikrotask vorsichtig sein. Wenn Sie also einen rekursiven Aufruf verwenden, seien Sie vorsichtig - Sie k√∂nnen alles blockieren. <br><br>  Wie wir uns erinnern, wird die Mikrotask au√üerdem am Ende der Stapelbereinigung ausgef√ºhrt.  Wir erinnern uns, was ein Stapel ist.  Es stellte sich heraus, dass der setTimeout-R√ºckruf ausgef√ºhrt wurde, sobald wir unseren Code verlassen hatten - das war's - Mikrotasks gingen genau dort hin.  Dies kann zu interessanten Nebenwirkungen f√ºhren. <br><br>  Betrachten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> . <br><br><img src="https://habrastorage.org/webt/kf/e-/tq/kfe-tqsysmprki74ayahty-n9ke.png"><br><br>  Es gibt einen Knopf und einen grauen Beh√§lter, in dem es liegt.  Wir abonnieren den Klick sowohl auf die Schaltfl√§che als auch auf den Container. ,   , ,       . <br><br>     2 : <br><br><ol><li> Promise.resolve; </li><li> .then,    console.log('RO') </li></ol><br>       ¬´FUS¬ª,      ‚Äì ¬´DAH!¬ª (    ). <br><br>   ,      ?      ,    ,   ¬´FUS RO DAH!¬ª  Gro√üartig!  ,   . <br><br><img src="https://habrastorage.org/webt/3g/b6/w3/3gb6w3gi4es-fzxcicyk2batfm8.png"><br><br>       ,            ,        .   ‚Äì  . , -   ? <br><br><img src="https://habrastorage.org/webt/uo/-t/dx/uo-tdxdjrfwgt0vvse4a6vuqips.png"><br><br>  !         . <br><br><img src="https://habrastorage.org/webt/yk/ob/w3/ykobw30-vcw5h6t6vvlitwk-y2a.png"><br><br>  ,   . <br><br> ,      ,     ,     .  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> . <br><br><ul><li>         ‚Äî buttonHandleClick,    . </li><li>    Promise.resolve.     .   ,      console.log('RO')  .   . </li><li>      console.log('FUS'). </li><li>   buttonHandleClick       .        . </li><li>   ,      (divHandleClick)    ,  ¬´DAH!¬ª. </li><li> HandleClick . </li></ul><br>  ,     .         ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> : <br><br><ul><li>  button.click().     . </li><li>   button HandleClick. </li><li>  Promise.resolve  then.      , Promise.resolve . </li><li>    console.log   ¬´FUS¬ª. </li><li>    buttonHandleClick    ,    . </li></ul><br>     (click)  ,       ,    .     divHandleClick , ,  console.log('DAH!') .        ,      . <br><br>   , ,    button.click   . <br>        .   , ,   .  ,    ,    . <br><br>    :     ()       (  ).   - ,      ,   stopPropagation.  ,     ,  ,  ,   -   ,  . <br><br>  ,  -   ( junior-)     ‚Äî      ¬´¬ª,    promise,  ,    then  ,  -  .    ,  <strong>    ,    </strong> :   ,    ,  .   .        ,   -       . <br><br>    (  4)    ,        .     ,   ,  ,   ,      -   .           . <br><br> <strong>     , :</strong> <br><br><ul><li>      Event Loop.  Das ist unangenehm. </li><li>         ,   . </li></ul><br>           ,    .  ‚Äî   ,     ,  . <br><br><h2>   Node.js <br></h2><br>   Node.js  Promise.then  process.nextTick.      ,    ‚Äî    .   ,   , ,   , . <br><br><h3> process.nextTick <br></h3><br> ,     process.nextTick,   setImmediate?      Node.js  ? <br><br>    .     createServer,   EventEmitter,    ,     listen (  ),      . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createServer = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> evEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">listen</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">port</span></span></span><span class="hljs-function"> =&gt;</span></span> { evEmitter.emit(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, port) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evEmitter } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = createServer().listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>) server.on(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, () =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>))</code> </pre><br>    ,  ,   8080,    listening   console.log  - . <br><br>  ,       ,      - . <br><br>    createServer,    .       listen,      ,        .        . <br><br>  ,    ,    .  Was kann getan werden?   process.nextTick:  evEmitter.emit('listening', port)  process.nextTick(() =&gt; evEmitter.emit('listening', port)). <br><br>   ,  <strong>process.nextTick     ,    </strong> .    EventEmitter,     . ,   ,      API,       .    process.nextTick,   emit    ,  userland  .      createServer,  ,  listen,    listening.     ‚Äî    process.nextTick ‚Äî !  ,     ,  . <br><br>     process.nextTick  .     ,         . <br><br>   ,  process.nextTick    ,  Promise.then  .     process.nextTick ,     ‚Äî    ,   Event Loop,  Node.js. , ,   . <br><br> <strong> process.nextTick    </strong> ,   ghbvtybnm  setImmediate   ,        C++  ..  process.nextTick       . <br><br><h2> Async/await </h2><br>      API ‚Äî async/await, - .    .    , async/await   Promise,     Event Loop      .     ,          . <br><br><h2>  N√ºtzliche Links </h2><br><ul><li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Philip Roberts. What the heck is the event loop anyway?</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bert Belder. Everything you need to know about Node.js event loop.</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jake Archibald. In the Loop</a> . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Node.js Event Loop, Timers, and process.nextTick()</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WHATWG Specification event loop processing model</a> <br></li></ul><br> <strong>,     !</strong> <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frontend Conf</a>     ‚Äî 4  5   ,  .    ,        : <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grid Layout    </a> /   ( .) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Building decentralised apps with JS</a> /   (ING) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> /   () <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StoreWars (ngxs, redux, vuex)</a> /  ,   (Cinimex) <br></li></ul><br>  Komm, es wird interessant sein! <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417461/">https://habr.com/ru/post/de417461/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417449/index.html">Jurassic World: K√∂nnen wir Dinosaurier wirklich wiederbeleben?</a></li>
<li><a href="../de417451/index.html">F√ºnf h√§ufige Fehler f√ºr Anf√§nger</a></li>
<li><a href="../de417453/index.html">Organisation von Praktika f√ºr Studenten: Rechen und Tricks</a></li>
<li><a href="../de417457/index.html">Frontend Conf Moscow - Kundenseite rein und raus</a></li>
<li><a href="../de417459/index.html">Kennen Sie Ihre JIT: n√§her am Auto</a></li>
<li><a href="../de417463/index.html">Ein unerwartetes Treffen. Kapitel 17</a></li>
<li><a href="../de417465/index.html">Eine √úbersicht √ºber Textverkn√ºpfungsmethoden</a></li>
<li><a href="../de417469/index.html">F√ºnf egoistische Gr√ºnde, reproduzierbar zu arbeiten</a></li>
<li><a href="../de417471/index.html">Einfaches Lot MK936 SMD. DIY L√∂tstation f√ºr SMD-Komponenten</a></li>
<li><a href="../de417473/index.html">Vertrauensw√ºrdiger Speicher mit DRBD9 und Proxmox (Teil 1: NFS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>