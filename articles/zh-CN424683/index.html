<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😇 💾 🍋 JDK 11中的90个新功能（和API） 👴🏽 🚸 🚜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我向您介绍Simon Ritter撰写的文章“ JDK 11中的90个新功能（和API） ”的翻译。 





 对于许多人来说，新的六个月JDK发布周期意味着有些人甚至还没有弄清JDK 10中有哪些新功能，而JDK 11即将到来。设法在JDK 10中找到它。因此，对于JDK 11，决定...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JDK 11中的90个新功能（和API）</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424683/"><p> 哈Ha！ 我向您介绍Simon Ritter撰写的文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JDK 11中的90个新功能（和API）</a> ”的翻译。 </p><br><p><img src="https://habrastorage.org/webt/nz/8c/f_/nz8cf_erkk_q0xqhz_kptdl772s.jpeg"></p><br><p> 对于许多人来说，新的六个月JDK发布周期意味着有些人甚至还没有弄清JDK 10中有哪些新功能，而JDK 11即将到来。设法在JDK 10中找到它。因此，对于JDK 11，决定这样做。 但是，选择了不同的格式。 这篇文章将分为两部分：开发人员可以使用的新功能（公共API）以及其他所有功能。 因此，如果您只对直接影响开发的内容感兴趣，则可以跳过第二部分。 </p><br><p> 可以计算出的更改总数为90（这是JEP加上新的类和方法，不包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://openjdk.java.net/groups/net/">HTTP客户端</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Flight Recorder的</a>单独方法） <em>在JDK中，但从Java 11开始，这要归功于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 328</a> ，并将其转移到开源中）</em> 。 尽管JDK 11设法发现的变化少于JDK 10，但我认为可以肯定地说是在JVM级别向JDK 11添加了更多功能。 </p><a name="habracut"></a><br><h3 id="novye-zametnye-dlya-razrabotchika-fichi"> 开发人员应注意的新功能 </h3><br><p>  JDK 11有很多可能影响开发风格的更改。 语法略有变化，提供了许多新的API，并且无需使用编译器就可以在一个文件中运行应用程序（ <em>请注意翻译器：所谓的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">shebang文件</a></em> ）。 另外，最大的变化（并且是重大的变化）是删除了<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">java.se.ee</a></strong>聚合模块，这可能会影响现有应用程序向JDK 11的迁移。 </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 323：Lambda参数的本地变量语法</a></strong> </p><br><p> 在JDK 10中，引入了局部变量推断（或类型推断）（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 286</a> ）。 这简化了代码，因为您不再需要显式指定局部变量的类型，而可以使用<strong>var</strong> 。  JEP 323扩展了此语法的使用，该语法现在也适用于lambda表达式的参数。 一个简单的例子： </p><br><pre><code class="java hljs">list.stream() .map((<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p> 细心的Java程序员会指出lambda表达式已经具有类型推断，因此（在这种情况下）使用var是多余的。 我们可以轻松地编写与以下代码相同的代码： </p><br><pre> <code class="java hljs"> list.stream() .map(s -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p> 为什么要添加var支持？ 答案是一种特殊情况-当您想向lambda参数添加注释时。 没有任何类型的参与就不可能做到这一点。 为了避免使用显式类型，我们可以使用var通过以下方式简化事情： </p><br><pre> <code class="java hljs"> list.stream() .map((<span class="hljs-meta"><span class="hljs-meta">@Notnull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p> 此更改要求更改<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java语言规范（JLS）</a> ，尤其是： </p><br><p> 第24页：var特殊标识符的描述。 <br> 页面627-630：Lambda参数 <br>  Lambda表达式的页面636：运行时评估 <br> 页面746：Lambda语法 </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 330：启动单文件源代码程序</a></strong> </p><br><p> 对Java的批评之一是语法的冗余，与启动甚至是琐碎的应用程序相关的“仪式”也可能严重增加初学者的入门门槛。 要编写仅打印“ Hello World！”的应用程序，您需要使用公共静态void main方法编写一个类，并使用System.out.println（）方法。 完成此操作后，您必须使用javac编译代码。 最后，您可以启动一个欢迎世界的应用程序。 使用大多数现代语言运行同一脚本要简单得多，而且速度也快得多。 </p><br><p>  JEP 330消除了编译单个文件应用程序的需要。 现在只需输入： </p><br><pre> <code class="java hljs"> java HelloWorld.java</code> </pre> <br><p>  Java启动器会识别该文件包含Java源代码，并在执行该代码之前将其编译为* .class文件。 </p><br><p> 当应用程序启动时，放置在源文件名后面的参数将作为参数传递。 编译代码后，将放置在源文件名称之前的参数作为参数传递给java启动器（这使您可以在命令行上设置诸如classpath之类的东西）。 与编译器相关的参数（例如classpath）也将传递给javac进行编译。 </p><br><p> 一个例子： </p><br><pre> <code class="java hljs"> java -classpath /home/foo/java Hello.java Bonjour</code> </pre> <br><p> 等同于： </p><br><pre> <code class="java hljs"> javac -classpath /home/foo/java Hello.java java -classpath /home/foo/java Hello Bonjour</code> </pre> <br><p> 该JEP还提供对shebang文件的支持。 为了减少甚至在命令行上提到Java启动器的需求，您可以将其包含在源文件的第一行中。 例如： </p><br><pre> <code class="java hljs"> #!/usr/bin/java --source <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloWorld</span></span></span><span class="hljs-class"> </span></span>{ ...</code> </pre> <br><p> 必须带有所使用的Java版本的-source标志。 </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 321：HTTP客户端（标准）</a></strong> </p><br><p>  JDK 9引入了新的API以支持HTTP客户端协议（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 110</a> ）。 由于JDK 9提供了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java平台模块系统（JPMS）</a> ，因此将该API作为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">孵化器模块</a>包括在内。 孵化器模块旨在提供新的API，但不要将其转变为Java SE标准。 开发人员可以通过提供反馈来尝试使用API​​。 进行必要的更改（此API在JDK 10中进行了更新）后，可以将该API转移到主模块以成为标准的一部分。 </p><br><p>  HTTP客户端API现在是Java SE 11标准的一部分，它为JDK引入了新的模块和软件包<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://download.java.net/java/early_access/jdk11/docs/api/java.net.">java.net.http</a> 。 主要课程： </p><br><ul><li>  Http客户端 </li><li>  Http请求 </li><li>  HttpResponse </li><li> 网络插座 </li></ul><br><p> 该API可以同步或异步使用。 在异步模式下，使用CompletionFutures和CompletionStages。 </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 320：删除Java EE和CORBA模块</a></strong> </p><br><p> 通过在JDK 9中引入JPMS，可以将整体式rt.jar文件拆分为几个模块。  JPMS的另一个好处是，您现在可以创建一个Java运行时环境，该环境仅包含应用程序所需的模块，从而大大减小了整体尺寸。 有了明确定义的边界，现在可以更容易地从Java API中删除过时的模块。 这就是JEP所做的；  java.se.ee元模块包含六个模块，这些模块将不再是Java SE 11标准的一部分，并且不会包含在JDK中。 </p><br><p> 远程模块： </p><br><ul><li>  corba（ <em>译者注：</em> <del>  <em>安息</em> </del>  <em>，在地狱中燃烧</em> ） </li><li> 交易 </li><li> 激活 </li><li>  xml.bind </li><li>  xml.ws </li><li>  xml.ws.annotation </li></ul><br><p> 自JDK 9起，这些模块已标记为过时（@Deprecated），并且默认情况下未包含在编译或运行时中。 如果您尝试使用JDK 9或JDK 10上这些模块中的API编译或运行应用程序，那么您将失败。 如果您在代码中使用这些模块中的API，则需要将它们作为单独的模块或库提供。 从评论来看，似乎是最引起问题的模块是JAX-WS，SOAP Web服务支持的java.xml模块。 </p><br><h3 id="novyy-publichnyy-api"> 新的公共API </h3><br><p>  JDK 11中的许​​多新API是由于HTTP客户端模块现已成为标准的一部分以及包含Flight Recorder的结果。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可在此处找到</a> API更改的完整示意图列表，包括对JDK不同版本的比较<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> </p><br><p> 这里列出的是除java.net.http和jdk.jfr模块中包含的那些方法以外的所有新方法。 同样未列出的是java.security模块中的新方法和类，它们专门针对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 324</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 329</a>更改（有六个新类和八个新方法）。 </p><br><h4 id="javaiobytearrayoutputstream">  java.io.ByteArrayOutputStream </h4><br><ul><li>  <strong>void writeBytes（byte []）</strong> ：将参数中的所有字节写入OutputStream </li></ul><br><h4 id="javaiofilereader">  java.io.FileReader </h4><br><p> 两个新的构造函数，可让您指定字符集。 </p><br><h4 id="javaiofilewriter">  java.io.FileWriter </h4><br><p> 四个新的构造函数，可让您指定字符集。 </p><br><h4 id="javaioinputstream">  java.io.InputStream </h4><br><ul><li>  <strong>io.InputStream nullInputStream（）</strong> ：返回一个不读取字节的InputStream。 查看此方法（以及OutputStream，Reader和Writer中的方法），就产生了一个问题，为什么它会派上用场。 您可以将它们视为<strong>/ dev / null-</strong>丢弃不需要的输出，或提供始终返回空字节的输入。 </li></ul><br><h4 id="javaiooutputstream">  java.io.OutputStream </h4><br><ul><li>  <strong>io.OutputStream nullOutputStream（）</strong> </li></ul><br><h4 id="javaioreader">  java.io.Reader </h4><br><ul><li>  <strong>io.Reader nullReader（）</strong> </li></ul><br><h4 id="javaiowriter">  java.io.Writer </h4><br><ul><li>  <strong>io.Writer nullWriter（）</strong> </li></ul><br><h4 id="javalangcharacter">  java.lang.Character </h4><br><ul><li>  <strong>String toString（int）</strong> ：这是现有方法的重载形式，但是使用int代替char。  Int是Unicode代码点。 </li></ul><br><h4 id="javalangcharsequence">  java.lang.CharSequence </h4><br><ul><li>  <strong>int compare（CharSequence，CharSequence）</strong> ：按<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">字典顺序</a>比较CharSequence的两个实例。 如果第一个序列在字典上小于，等于或大于第二个序列，则分别返回负值，零或正值。 </li></ul><br><h4 id="javalangrefreference">  java.lang.ref.Reference </h4><br><ul><li>  <strong>lang.Object clone（）</strong> ：我必须承认，这种更改会引起混乱。  Reference类未实现Cloneable接口，并且此方法引发CloneNotSupportedException。 必须将其包括在内，也许是将来的某些原因。  （ <em>译者注： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenJDK中</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">票证</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StackOverflow的讨论</a></em> ） </li></ul><br><h4 id="javalangruntime">  java.lang.Runtime </h4><br><h4 id="javalangsystem">  java.lang.System </h4><br><p> 这里没有新方法，但是值得一提的是，现在两个类都删除了<strong>runFinalizersOnExit（）</strong>方法（迁移到JDK 11时可能会出现问题）。 </p><br><h4 id="javalangstring">  java.lang.String </h4><br><p> 我认为这是JDK 11中新API的亮点之一。这里有一些有用的新方法。 </p><br><ul><li>  <strong>boolean isBlank（）</strong> ：如果字符串为空或仅包含空格，则返回true，否则返回false。 </li><li>  <strong>Stream lines（）</strong> ：从字符串返回Stream，从字符串中提取，并由行分隔符分隔。 </li><li>  <strong>字符串重复（int）</strong> ：返回一个字符串，其值是此字符串的串联，重复多次。 </li><li>  <strong>String strip（）</strong> ：返回一个值为该字符串的字符串，这将删除字符串开头和结尾的所有空格。 </li><li>  <strong>String stripLeading（）</strong> ：返回一个值为该字符串的字符串，同时删除行首的所有空格。 </li><li>  <strong>String stripTrailing（）</strong> ：返回一个值为该字符串的字符串，这将删除字符串末尾的所有空格。 </li></ul><br><p> 您最有可能看一下<strong>strip（）</strong>并问：“这与现有的<strong>trim（）</strong>方法有何不同？” 答案在于空间定义的差异。  （ <em>译者注：简而言之， <strong>strip（）</strong>更好地理解了Unicode， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">并在StackOverflow上进行了详细的分析</a></em> ） </p><br><h4 id="javalangstringbuffer">  java.lang.StringBuffer </h4><br><h4 id="javalangstringbuilder">  java.lang.StringBuilder </h4><br><p> 这两个类都有一个新的<strong>compareTo（）</strong>方法，该方法采用StringBuffer / StringBuilder并返回一个int。 词法比较方法类似于CharSequence中新的<strong>compareTo（）</strong>方法。 </p><br><h4 id="javalangthread">  java.lang.Thread </h4><br><p> 没有新方法。  <strong>删除（）</strong>和<strong>停止（Throwable）方法</strong>已被删除。 仍然存在不带任何参数的<strong>stop（）</strong>方法。 可能导致兼容性问题。 </p><br><h4 id="javaniobytebuffer">  java.nio.ByteBuffer </h4><br><h4 id="javaniocharbuffer">  java.nio.CharBuffer </h4><br><h4 id="javaniodoublebuffer">  java.nio.DoubleBuffer </h4><br><h4 id="javaniofloatbuffer">  java.nio.FloatBuffer </h4><br><h4 id="javaniolongbuffer">  java.nio.LongBuffer </h4><br><h4 id="javanioshortbuffer">  java.nio.ShortBuffer </h4><br><p> 现在，所有这些类都具有<strong>mismatch（）</strong>方法，该方法查找并返回此缓冲区与传递的缓冲区之间的第一个不匹配项的相对索引。 </p><br><h4 id="javaniochannelsselectionkey">  java.nio.channels.SelectionKey </h4><br><ul><li>  <strong>int interestOpsAnd（int）</strong> ：以原子方式将此键的权益（键的权益）设置为现有权益和传递的值的按位相交（“和”）。 </li><li>  <strong>int interestOpsOr（int）</strong> ：以原子方式设置此密钥的利益（密钥的利益）为现有利益和传递的值的按位并集（“或”）。 </li></ul><br><h4 id="javaniochannelsselector">  java.nio.channels.Selector </h4><br><ul><li>  <strong>int select（java.util.function.Consumer，long）</strong> ：选择键并对其相应的通道准备进行I / O操作的键执行操作。 长参数是超时。 </li><li>  <strong>int select（java.util.function.Consumer）</strong> ：与上面相同，但没有超时。 </li><li>  <strong>int selectNow（java.util.function.Consumer）</strong> ：与上面相同，只是非阻塞。 </li></ul><br><h4 id="javaniofilefiles">  java.nio.file.Files </h4><br><ul><li>  <strong>String readString（Path）</strong> ：将文件中的所有内容读取为字符串，然后使用UTF-8编码从字节解码为字符。 </li><li>  <strong>字符串readString（路径，字符集）</strong> ：如上所述，区别在于使用指定的字符集进行从字节到字符的解码。 </li><li>  <strong>路径writeString（路径，CharSequence，java.nio.file.OpenOption []）</strong> ：将CharSequence写入文件。 使用UTF-8编码将字符编码为字节。 </li><li>  <strong>路径writeString（Path，CharSequence，java.nio.file.Charset，OpenOption []）</strong> ：与上面相同，使用Charset中指定的编码将字符编码为字节。 </li></ul><br><h4 id="javaniofilepath">  java.nio.file.Path </h4><br><ul><li>  <strong>（String，String []）的</strong> Path：从路径的字符串参数或字符串序列返回的Path，这些字符串或字符串序列组合后会形成路径字符串。 </li><li>  <strong>（net.URI）的</strong>路径：从URI返回路径。 </li></ul><br><h4 id="javautilcollection">  java.util.Collection </h4><br><ul><li>  <strong>Object [] toArray（java.util.function.IntFunction）</strong> ：使用提供的生成函数分配返回的数组，返回一个包含此集合中所有元素的数组。 </li></ul><br><h4 id="javautilconcurrentpriorityblockingqueue">  java.util.concurrent.PriorityBlockingQueue </h4><br><h4 id="javautilpriorityqueue">  java.util.PriorityQueue </h4><br><ul><li>  <strong>void forEach（java.util.function.Consumer）</strong> ：对每个Iterable元素执行传递的操作，直到处理完所有元素或该操作引发异常为止。 </li><li>  <strong>boolean removeAll（java.util.Collection）</strong> ：删除此集合中也包含在指定集合中的所有元素（可选操作）。 </li><li>  <strong>boolean removeIf（java.util.function.Predicate）</strong> ：从此集合中移除所有满足给定谓词的元素。 </li><li>  <strong>boolean keepAll（java.util.Collection）</strong> ：仅保存此集合中包含在传输的集合中的那些元素（可选操作）。 </li></ul><br><h4 id="javautilconcurrenttimeunit">  java.util.concurrent.TimeUnit </h4><br><ul><li>  <strong>long convert（java.time.Duration）</strong> ：将传递的Duration转换为此类型。 </li></ul><br><h4 id="javautilfunctionpredicate">  java.util.function.Predicate </h4><br><ul><li>  <strong>谓词not（谓词）</strong> ：返回谓词，它是所传输谓词的否定。 </li></ul><br><p> 这是JDK 11中我最喜欢的新API之一。例如，您可以转换以下代码： </p><br><pre> <code class="java hljs"> lines.stream() .filter(s -&gt; !s.isBlank())</code> </pre> <br><p> 在 </p><br><pre> <code class="java hljs"> lines.stream() .filter(Predicate.not(String::isBlank))</code> </pre> <br><p> 或者如果我们使用静态导入： </p><br><pre> <code class="java hljs"> lines.stream() .filter(not(String::isBlank))</code> </pre> <br><p> 我个人认为此版本更易于理解和简洁。 </p><br><h4 id="javautiloptional">  java.util.Optional </h4><br><h4 id="javautiloptionalint">  java.util.OptionalInt </h4><br><h4 id="javautiloptionaldouble">  java.util.OptionalDouble </h4><br><h4 id="javautiloptionallong">  java.util.OptionalLong </h4><br><ul><li>  <strong>boolean isEmpty（）</strong> ：如果没有值，则返回true，否则返回false。 </li></ul><br><h4 id="javautilregexpattern">  java.util.regex.Pattern </h4><br><ul><li>  <strong>Predicate asMatchPredicate（）</strong> ：我认为这可能是新JDK 11 API的瑰宝。创建一个谓词，检查该模板是否与给定的输入字符串匹配。 </li></ul><br><h4 id="javautilzipdeflater">  java.util.zip.Deflater </h4><br><ul><li><p>  <strong>int deflate（ByteBuffer）</strong> ：压缩输入并用它填充指定的缓冲区。 </p><br></li><li><p>  <strong>int deflate（ByteBuffer，int）</strong> ：压缩输入并用它填充指定的缓冲区。 返回实际的压缩数据量。 </p><br></li><li><p>  <strong>setDictionary（ByteBuffer）</strong> ：将指定的压缩字典设置为此缓冲区中的字节。 这是ByteBuffer现在可以接受的现有方法的重载形式，而不是字节数组。 </p><br></li><li><p>  <strong>setInput（ByteBuffer）</strong> ：设置要压缩的输入。 也是现有方法的重载形式。 </p><br></li></ul><br><h4 id="javautilzipinflater">  java.util.zip.Inflater </h4><br><ul><li>  <strong>int inflate（ByteBuffer）</strong> ：将字节解压缩到指定的缓冲区。 返回实际的未压缩字节数。 </li><li>  <strong>setDictionary（ByteBuffer）</strong> ：将指定的字典设置为此缓冲区中的字节。 现有方法的重载形式。 </li><li>  <strong>setInput（ByteBuffer）</strong> ：设置用于解压缩的输入。 现有方法的重载形式。 </li></ul><br><h4 id="javaxprintattributestandarddialogowner">  javax.print.attribute.standard.DialogOwner </h4><br><p> 这是JDK 11中的新类。用于支持打印对话框或页面设置的请求。 必须显示在所有窗口或特定窗口的顶部。 </p><br><h4 id="javaxswingdefaultcomboboxmodel">  javax.swing.DefaultComboBoxModel </h4><br><h4 id="javaxswingdefaultlistmodel">  javax.swing.DefaultListModel </h4><br><ul><li>  <strong>void addAll（Collection）</strong> ：添加集合中存在的所有元素。 </li><li>  <strong>void addAll（int，Collection）</strong> ：从指定的索引开始，添加集合中存在的所有元素。 </li></ul><br><h4 id="javaxswinglistselectionmodel">  javax.swing.ListSelectionModel </h4><br><ul><li>  <strong>int [] getSelectedIndices（）</strong> ：按升序返回所选模型中所有所选索引的数组。 </li><li>  <strong>int getSelectedItemsCount（）</strong> ：返回所选项目的数量。 </li></ul><br><h4 id="jdkjshellevalexception">  jdk.jshell.EvalException </h4><br><ul><li>  <strong>jshell.JShellException getCause（）</strong> ：在由EvalException表示的执行客户端中返回可引发的原因包装器；如果原因不存在或未知，则返回null。 </li></ul><br><h3 id="novye-fichi-ne-publichnyy-api"> 新功能（不是公共API） </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 181：基于嵌套的访问控制</a> </p><br><p>  Java（和其他语言）通过内部类支持嵌套类。 为了进行正确的操作，编译器必须执行一些技巧。 例如： </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outerInt); } } }</code> </pre> <br><p> 在进行编译之前，编译器会对此进行修改以创建如下所示的内容： </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> access$<span class="hljs-number"><span class="hljs-number">000</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outerInt; } }</code> </pre> <br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Outer outer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outer.access$<span class="hljs-number"><span class="hljs-number">000</span></span>()); } }</code> </pre> <br><p> 尽管从逻辑上讲，内部类与外部类是同一代码的一部分，但它被编译为单独的类。 因此，这需要合成方法（“桥”），该方法必须由编译器创建以提供对外部类的私有字段的访问。 </p><br><p> 该JEP表示“套接字”的概念，其中同一套接字的两个成员（在我们的示例中为“外部”和“内部”）是邻居。  * .class文件格式添加了两个新属性：NestHost和NestMembers。 这些更改对于其他支持嵌套类的字节码编译语言也很有用。 </p><br><p> 此功能为java.lang.Class提供了三种新方法： </p><br><ul><li>  <strong>类getNestHost（）</strong> </li><li>  <strong>类别[] getNestMembers（）</strong> </li><li>  <strong>boolean isNestmateOf（clazz）</strong> </li></ul><br><p> 此功能还需要更改<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java虚拟机规范（JVMS）</a> ，尤其是在5.4.4节“访问控制”中。 </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 309：动态类文件常量</a></strong> </p><br><p> 该JEP描述了* .class文件格式的扩展，以使用常量池CONSTANT_Dynamic（在演示文稿中通常称为condy）来支持新格式。 动态常数的想法似乎是矛盾的，但是实际上，您可以将其视为Java中的最终值。 常量池的值未在编译阶段设置（与其他常量不同），但是引导程序方法用于在运行时确定该值。 因此，该值是动态的，但是由于其值仅设置一次，因此它也是恒定的。 </p><br><p> 对于正在开发新语言和编译器的人来说，此功能将非常有用。 谁将生成字节码和* .class文件以在JVM上运行。 这将简化某些任务。 </p><br><p> 此功能提供了一个带有九个新方法的新类java.lang.invoke.ConstantBootstraps。 我不会在这里列出所有内容； 这些是用于动态计算常量的引导方法。 </p><br><p> 此功能需要对JVMS进行更改，特别是在特殊调用字节代码和“常量池”的4.4节的使用方式方面。 </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 315：改进Aarch64本征</a></strong> </p><br><p> 这是Red Hat提供的JEP。  JVM现在可以使用Arm 64命令集中的更多专用指令，尤其是可以改善java.lang.Math类的sin（），cos（）和log（）方法的操作。 </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 318：Epsilon垃圾收集器</a></strong> </p><br><p> 红帽也为此JEP做出了贡献。  Epsilon垃圾收集器有些不寻常，因为它不收集垃圾！ 创建新对象时，如有必要，它将分配新的内存，但是不会释放没有链接的对象所占用的空间。 </p><br><p> 那么，看起来有什么意义呢？ 至少有两个用途： </p><br><ul><li> 首先，此收集器旨在确保评估新的GC算法对性能的影响。 想法是使用Epsilon GC运行示例应用程序并生成度量。 包括新的GC算法，运行相同的测试，并比较结果。 </li><li> 对于非常短暂或短暂的任务（例如云中的无服务器功能），可以确保不超出分配给堆空间的内存。 通过消除应用程序代码中的开销（包括收集决定是否运行收集器所需的统计信息），可以提高性能。 </li></ul><br><p> 如果堆空间已用完，则可以通过以下三种方式之一配置后续的JVM操作： </p><br><ul><li> 调用常规的OutOfMemoryError。 </li><li> 重置堆 </li><li> 硬停止JVM并可能执行外部任务（例如，启动调试器）。 </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>JEP 324：与Curve25519和Curve448的关键协议</strong></a> </p><br><p> 密码标准正在不断变化和提高。 在这种情况下，将现有的具有椭圆曲线的Diffie-Hellman方案替换为Curve25519和Curve448。 这是RFC-7748中定义的关键协议方案。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>JEP 327：Unicode 10</strong></a> </p><br><p>  Java平台支持Unicode以启用所有字符集的处理。 由于Unicode已更新为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">版本10</a> ，因此JDK也已更新为支持该版本的标准。 </p><br><p> 我总是很高兴看到新版本中包含哪些Unicode开发人员。  Unicode 10具有8,518个新字符。 其中包括比特币符号，Nüshu字符集（中国妇女用来写诗）以及Soyombo和Zanabazar Square（在佛教历史文献中用于书写梵语，藏语和蒙古语的字符）。 还添加了许多其他表情符号，包括期待已久（显然）的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">科尔伯特表情符号</a> 。 </p><br><p> 请记住，从JDK 9开始，您可以在属性文件（.properties）中使用UTF-8。 这意味着在此类文件中可以使用任何Unicode字符。 包括表情符号。 还是Nüshu。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>JEP 328：飞行记录器</strong></a> </p><br><p> Flight Recorder —       JVM.  JDK 11        Oracle JDK. ,  Oracle     Oracle JDK  OpenJDK,      OpenJDK. </p><br><p> JEP    : </p><br><ul><li>  API        </li><li>        </li><li>      </li><li>    , JVM HotSpot   JDK </li></ul><br><p>      : jdk.jfr  jdk.management.jfr. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms</strong></a> </p><br><p>  JEP 324,   ,  JDK.   ChaCha20  ChaCha20-Poly1305,    RFC 7539. ChaCha20 —     ,    ,    RC4. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>JEP 331: Low-overhead Heap Profiling</strong></a> </p><br><p>  ,   JEP,   Google.          Java  JVM. </p><br><p>  : </p><br><ul><li>    ,       </li><li>       </li><li>     </li><li>        ( ,     GC   VM) </li><li>         Java. </li></ul><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>JEP 332: Transport Layer Security (TLS) 1.3</strong></a> </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TLS 1.3 (RFC 8446)</a>  " "  TLS            . JDK   ,      Datagram Transport Layer Security (DTLS). </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>JEP 333: ZGC A Scalable, Low Latency Garbage Collector</strong></a> </p><br><p>     ,     ,     ()    .      (  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Weak Generational Hypothesis</a> )    (  )  GC   .     ""  ,            .           . </p><br><p> ZGC — region-based (  G1), NUMA aware  compacting  .      . </p><br><p>     pauseless     ,      C4   Zing JVM. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>JEP 335: Deprecate the Nashorn Scripting Engine</strong></a> </p><br><p> Nashorn    JDK 8     Rhino Javascript .    ,   Nashorn   API  jjs     Java.   ,   .     Graal VM   ,     ,  . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>JEP 336: Deprecate the Pack200 Tools and APIs</strong></a> </p><br><p> Pack200 —     JAR-,     Java SE 5.0.   JPMS  JDK 9 Pack200       JDK.  pack200  unpack200  API Pack200  java.util.jar          JDK.   ,  . </p><br><h3 id="vyvody"> 结论 </h3><br><p> JDK 11 —   LTS JDK (       ).   ,  ,   ,   ,  JVM   ,        . </p><br><p> Zulu  JDK 11  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>   ! </p><br><p>         JDK 11? </p><br><p> ( <em>. : ,         </em> ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424683/">https://habr.com/ru/post/zh-CN424683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424673/index.html">CLRium＃4：.NET社区会议</a></li>
<li><a href="../zh-CN424675/index.html">零售业会发生什么</a></li>
<li><a href="../zh-CN424677/index.html">数字键盘的简要历史记录</a></li>
<li><a href="../zh-CN424679/index.html">维修计算机外围设备</a></li>
<li><a href="../zh-CN424681/index.html">十月IT活动摘要（第一部分）</a></li>
<li><a href="../zh-CN424685/index.html">美国证券交易委员会针对特斯拉·埃隆·马斯克（Tesla Elon Musk）的负责人提起诉讼，包括由于欺诈行为</a></li>
<li><a href="../zh-CN424687/index.html">这些是正确的蜜蜂：机械适应动态效果</a></li>
<li><a href="../zh-CN424689/index.html">控制局势使您感到高兴。</a></li>
<li><a href="../zh-CN424691/index.html">我们邀请您参加2018年10月13日在塔甘罗格举行的Azov开发者大会2018</a></li>
<li><a href="../zh-CN424693/index.html">在网站的所有图片上添加水印</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>