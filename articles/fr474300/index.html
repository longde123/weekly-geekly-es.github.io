<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎾 🐄 👆🏽 Sauvegarde fiable, sécurisée et polyvalente pour U2F 🐃 ▶️ 🐹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'aime vraiment le niveau de sécurité fourni par U2F, mais avec la sécurité, vous devez envisager un plan de récupération. Perdre l'accès à vos compte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sauvegarde fiable, sécurisée et polyvalente pour U2F</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474300/">  J'aime vraiment le niveau de sécurité fourni par U2F, mais avec la sécurité, vous devez envisager un plan de récupération.  Perdre l'accès à vos comptes les plus importants, si quelque chose se passe avec le jeton U2F principal, est un problème grave.  Dans le même temps, je voudrais éviter d'utiliser une sauvegarde qui compromet la sécurité fournie par U2F. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ede/ae9/0a7/edeae90a73189ed879d63056d56afda5.jpg" alt="yubikey"></div><br><h2>  Méthodes de sauvegarde populaires </h2><br>  À ce jour, il a été recommandé de conserver un deuxième jeton U2F indépendant pour la sauvegarde;  ce jeton doit être ajouté manuellement à chaque service et stocké dans un endroit "sûr".  Une autre pratique courante consiste à utiliser la méthode non U2F comme sauvegarde (OTP, codes de récupération).  Honnêtement, ces deux méthodes laissent beaucoup à désirer. <br><a name="habracut"></a><br><h3>  Jeton U2F indépendant </h3><br>  Cela signifie que chaque fois que je m'inscris sur un nouveau service, je dois ajouter mes deux jetons.  Ce fait soulève un certain nombre de problèmes: <br><br><ul><li>  Un jeton de sauvegarde doit être assez facilement accessible.  Malgré le fait que je ne le porterai pas avec moi sur un porte-clés, je devrais pouvoir y accéder rapidement, donc je peux à peine trouver quelque chose de mieux que de le garder à la maison.  Dans quelle mesure il est sûr, même si un coffre-fort est utilisé, vous pouvez parler longtemps; </li><li>  Lorsque je dois m'inscrire à un service lorsque je suis loin de chez moi, je ne peux pas ajouter de jeton de sauvegarde.  Vous devez donc essayer de vous rappeler que vous devez l'ajouter plus tard, et jusqu'à ce que cela se produise, il n'y a pas de sauvegarde.  Dans le pire des cas, je peux complètement l'oublier; </li><li>  Quand je suis à la maison, mes deux jetons sont au même endroit.  Cette méthode de sauvegarde est loin d'être idéale: les deux jetons peuvent être indisponibles en raison d'un incident (être détruits ou volés); </li><li>  Le fait que le jeton de sauvegarde soit stocké à la maison est tout à fait évident.  Si quelqu'un veut vraiment accéder à mon jeton, il sait déjà où le chercher; </li><li>  Méthode non universelle: tous les services ne vous permettent pas d'ajouter plus d'une clé à votre compte. </li></ul><br>  À mon avis, cette «pratique exemplaire» n'est pas très fiable et plutôt contraignante.  Regardons une autre pratique courante. <br><br><h3>  Méthode non U2F comme sauvegarde </h3><br>  OTP: <br><br><ul><li>  Il est préférable d'utiliser OTP comme sauvegarde que de l'utiliser comme méthode 2FA principale, mais le fait d'avoir OTP ouvre en quelque sorte un vecteur d'attaque supplémentaire; </li><li>  Les téléphones tombent en panne, se perdent et sont volés, et si après leur perte il y a une chance qu'ils soient entre les mains d'étrangers, alors vous devez rappeler manuellement cette sauvegarde sur tous les comptes; </li><li>  Je porte toujours un téléphone <b>et un</b> jeton U2F avec moi, donc encore une fois, une telle méthode de sauvegarde est loin d'être idéale: la probabilité de les perdre tous les deux à la fois est beaucoup plus élevée que si la sauvegarde était stockée séparément.  Mais cet élément peut être légèrement compensé en utilisant, par exemple, Authy, qui stocke la sauvegarde chiffrée sur son serveur; </li><li>  Méthode non universelle: malheureusement, il existe un nombre suffisant de services qui n'offrent que des applications personnalisées et ne prennent pas en charge TOTP standard. </li></ul><br>  Codes de récupération: <br><br><ul><li>  Les codes de récupération doivent être stockés dans un endroit sûr.  Encore une fois, cet «endroit sûr» sera probablement ma maison, avec presque les mêmes problèmes qu'un jeton U2F distinct; </li><li>  Encore une fois, une méthode non universelle: chaque service a sa propre approche de sauvegarde </li></ul><br>  Donc, pour résumer, toutes ces méthodes sont non universelles, lourdes et pas trop sûres. <br><br><h2>  La meilleure méthode de sauvegarde </h2><br>  Maintenant, après avoir suffisamment critiqué la situation actuelle, je dirai enfin ce que je veux vraiment.  Je veux vraiment avoir deux jetons U2F: primaire et sauvegarde, mais ils doivent être configurés d'une certaine manière: <br><br><ul><li>  Lorsque j'enregistre le jeton principal sur n'importe quel appareil, le jeton de sauvegarde devient automatiquement opérationnel pour ce service; </li><li>  Dès que j'utilise un jeton de sauvegarde sur un service, le jeton principal n'est pas valide pour ce service. </li></ul><br>  Avant de discuter de la faisabilité technique de cela au sein de U2F, j'expliquerai pourquoi c'est génial et comment je l'utilise. <br><br><h3>  Pourquoi c'est génial </h3><br>  Si nous regardons la critique du jeton de sauvegarde indépendant décrit ci-dessus, nous pouvons voir que tous les défauts de cette méthode sont éliminés: <br><br><ul><li>  Le jeton de sauvegarde ne devrait plus être facilement accessible.  Des exemples extrêmes peuvent être: briquez un jeton à l'intérieur d'un mur de briques, ou enterrez un mètre et demi dans un jardin ou ailleurs.  Sans blague, je suis tout à fait prêt à y aller; </li><li>  Peu importe où je me trouve, si je m'inscris à un service, je n'ai rien à faire pour ajouter un jeton de sauvegarde à ce service.  J'utilise juste mon jeton principal, et je suis en toute tranquillité d'esprit, sachant que j'ai une sauvegarde; </li><li>  Pour les étrangers, il est complètement difficile de savoir où se trouve mon jeton de sauvegarde.  Même en sachant qu'il existe, essayer de le trouver vous-même n'a guère de sens; </li><li>  C'est assez sûr.  Même si quelque chose de mal arrive à mon jeton principal, il est très peu probable que le même incident affecte le jeton de sauvegarde; </li><li>  C'est universel.  Cette méthode de sauvegarde fonctionnera sur tout service qui prend en charge U2F, indépendamment de ce que ce service prend en charge. </li></ul><br>  Et si quelque chose de grave se produit vraiment avec le jeton principal, je fais ce qui suit: <br><br><ul><li>  Je déterre / efface un jeton de sauvegarde; </li><li>  Authentifiez-vous sur tous mes services avec U2F, annulant ainsi le jeton principal; </li><li>  Je commande une nouvelle paire de jetons et, à la réception, j'ajoute un nouveau jeton principal sur tous les services et révoque l'ancien. </li></ul><br>  Du moins pour moi personnellement, cette stratégie est un grand compromis pour un haut niveau de sécurité et un fardeau de sauvegarde facile.  Il est plus sûr et plus fiable que toute autre méthode. <br><br><h2>  Implémentation </h2><br><h3>  Présentation du protocole U2F </h3><br>  Avant de parler d'implémentation, nous devons comprendre à un certain niveau comment fonctionne U2F.  La plupart des fabricants l'implémentent comme suit (tous les éléments suivants ne sont pas présents dans la norme; certains éléments sont des détails d'implémentation, mais la plupart des implémentations existantes, pour autant que je sache, fonctionnent de cette façon): <br><br>  <code>device_secret</code> programmé dans le jeton U2F, avec un <code>counter</code> 32 bits, qui ne peut être incrémenté.  Lorsque nous enregistrons un jeton U2F sur un service, les événements suivants se produisent: <br><br><ul><li>  Le navigateur envoie l' <code>AppID</code> (en fait, le nom de domaine) au périphérique U2F; </li><li>  L'appareil génère un nombre aléatoire ( <code>nonce</code> ), le combine avec lui avec l' <code>AppID</code> , le transmet à travers HMAC-SHA256 en utilisant <code>device_secret</code> comme clé, et le hachage résultant devient la clé privée pour ce service particulier: <code>service_private_key</code> ; </li><li>  A partir de <code>service_private_key</code> , la clé publique <code>service_public_key</code> générée; </li><li>  L'appareil prend à nouveau l' <code>AppID</code> , le combine avec <code>service_private_key</code> et le transmet à nouveau via le HMAC-SHA256 en utilisant <code>device_secret</code> comme clé.  Le résultat ( <code>MAC</code> ), avec le <code>nonce</code> qui a été généré précédemment, devient <code>key_handle</code> ; </li><li>  L'appareil renvoie <code>key_handle</code> et <code>service_public_key</code> au navigateur, et le navigateur passe au service, qui enregistre ces données pour de futures authentifications. </li></ul><br>  L'authentification suivante se déroule comme suit: <br><br><ul><li>  Le service génère un <code>challenge</code> (données générées aléatoirement) et l'envoie au navigateur avec <code>key_handle</code> (qui se compose de <code>nonce</code> et <code>MAC</code> ).  Le navigateur transmet tout cela à l'appareil, ainsi que l' <code>AppID</code> (c'est-à-dire le nom de domaine); </li><li>  L'appareil, ayant <code>nonce</code> et <code>AppID</code> , génère <code>service_private_key</code> de la même manière qu'il a été généré lors de l'inscription; </li><li>  L'appareil génère un <code>MAC</code> de la même manière que lors de l'enregistrement, et en le comparant avec le <code>MAC</code> reçu du navigateur, il s'assure que <code>nonce</code> pas remplacé, et donc, <code>service_private_key</code> fiable; </li><li>  Le périphérique incrémente le <code>counter</code> ; </li><li>  L'appareil signe le <code>challenge</code> , l' <code>AppID</code> et le <code>counter</code> aide de <code>service_private_key</code> , et envoie la signature ( <code>signature</code> ) et le <code>counter</code> résultants <code>counter</code> navigateur, qui transfère ces données au service; </li><li>  Le service vérifie la <code>signature</code> à l'aide de la <code>service_public_key</code> qu'il possède après l'enregistrement.  De plus, la plupart des services vérifient que le <code>counter</code> plus grand que la valeur précédente (s'il ne s'agit pas de la première authentification).  Le but de ce test est de rendre le clonage des appareils U2F inaccessible.  Par conséquent, si la <code>signature</code> correspond et que le <code>counter</code> supérieur à la valeur précédente, l'authentification est considérée comme terminée avec succès et le service enregistre la nouvelle valeur du <code>counter</code> . </li></ul><br>  Décrivons maintenant les détails directement liés à la discussion. <br><br><h3>  Détails d'intérêt </h3><br>  La première est que le périphérique ne stocke pas <code>service_private_key</code> pour chaque service: à la place, il affiche <code>service_private_key</code> chaque fois en utilisant HMAC-SHA256.  C'est très important pour nous: il est évident que si chaque appareil stockait des clés uniques séparément pour chaque service, alors seul cet appareil pourrait s'authentifier par la suite. <br><br>  <i>Soit dit en passant, ce n'est pas une exigence de U2F: U2F n'indique pas comment les clés doivent être stockées, et certaines premières implémentations de U2F ont en fait stocké les clés pour chaque service séparément.</i>  <i>Cette approche présente l'inconvénient que le nombre de services pour lesquels l'appareil peut être utilisé est limité.</i>  <i>La dérivation de <code>service_private_key</code> élimine cet inconvénient.</i> <br><br>  Et deuxièmement, l'appareil dispose d'un <code>counter</code> pour empêcher le clonage. <br><br>  À première vue, il peut sembler que ce <code>counter</code> ne nous permet pas de mettre en œuvre la stratégie de sauvegarde discutée (du moins il m'a semblé quand j'ai essayé de trouver une solution), mais en fait, cela ne fait que nous aider!  Je vais vous expliquer maintenant. <br><br><h3>  Idée principale </h3><br>  L'idée est la suivante: au stade de la production, programmez deux jetons de manière à ce qu'ils aient tous les deux le même <code>device_secret</code> , mais le jeton de sauvegarde a besoin d'une correction: au lieu d'utiliser le <code>counter</code> dans sa forme pure (comme le font les jetons ordinaires), il devrait ajouter une grosse constante pour <code>counter</code> .  Par exemple, la moitié de la plage 32 bits, c'est-à-dire  environ <code>2 000 000 000</code> , cela semble raisonnable: il est peu probable que j'épuise autant d'authentifications dans toute ma vie. <br><br>  En fait, c'est tout.  Simple et efficace. <br><br>  Ayant deux jetons programmés de cette manière, je cache le jeton de sauvegarde dans un endroit <i>vraiment</i> difficile à atteindre et ne le touche jamais.  Si quelque chose de terrible se produit et que je perds l'accès au jeton principal, j'arrive toujours au jeton de sauvegarde et je peux l'utiliser immédiatement sur tous les services où j'ai enregistré le jeton principal, car  La sauvegarde a le même <code>device_secret</code> , et son <code>counter</code> démarre avec un très grand nombre, que je n'aurai pas pour le reste de ma vie. <br><br>  Aussi, j'attire l'attention sur le fait que <b>je ne propose pas de faire des jetons clonés</b> .  Deux jetons, bien qu'ils aient le même <code>device_secret</code> , ont des compteurs différents, et après la programmation de <code>device_secret</code> il ne devrait y avoir aucun moyen de le récupérer à partir du périphérique ou de créer un clone d'une autre manière. <br><br><h3>  Une note sur Counter </h3><br>  Un lecteur attentif peut remarquer qu'il existe le problème de sécurité suivant: que se passe-t-il si un attaquant accède au jeton principal et initie en quelque sorte 2 000 000 000 d'authentifications?  Il accède ensuite au service même après que le jeton de sauvegarde a été utilisé sur ce service. <br><br>  Heureusement, ce problème a une solution simple.  Dans tous les cas, le compteur matériel doit être implémenté dans le matériel (vraisemblablement sur certains processeurs cryptographiques), et pour une implémentation sûre, ce compteur matériel doit avoir une plage inférieure à 32 bits.  Par exemple, sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ATECC508A, les</a> compteurs ne peuvent compter que jusqu'à 2097151, donc en définissant la constante ajoutée au compteur sur une valeur supérieure à la valeur maximale du compteur, nous pouvons être sûrs que le jeton principal ne pourra jamais compter sur le compteur dans le jeton de sauvegarde. <br><br>  Pour clarifier: disons que notre jeton U2F utilise ATECC508A et désignons le compteur à l'intérieur de l'ATECC508A comme <code>hw_counter</code> .  Ensuite: <br><br><ul><li>  Dans le jeton principal, nous utilisons pour les calculs: <code>hw_counter</code> ; </li><li>  Dans le jeton de sauvegarde, nous utilisons pour les calculs: <code>hw_counter + 2000000000</code> . </li></ul><br>  Veuillez noter que nous ne modifions pas le vrai <code>hw_counter</code> à l'intérieur du processeur cryptographique;  il comptera toujours de 0 à 2097151. Au lieu de cela, chaque fois que nous avons besoin d'obtenir la valeur du compteur, nous lisons <code>hw_counter</code> de ATECC508A, puis nous ajoutons notre constante et la renvoyons (pour d'autres calculs pour U2F). <br><br>  Ainsi, la plage de valeurs de compteur dans le jeton principal sera [0, 2097151], tandis que la plage de valeurs de compteur dans le jeton de sauvegarde sera [2000000000, 2002097151].  Le fait que ces plages ne se chevauchent pas garantit l'annulation du jeton principal lors de l'utilisation de la sauvegarde (si le service utilise un <code>counter</code> ; les principaux services que j'ai vérifiés l'utilisent). <br><br><h3>  Mise en œuvre réelle </h3><br>  Aucun des fabricants de jetons U2F que je connais ne prend en charge la personnalisation requise aujourd'hui.  Mais heureusement, il existe une implémentation open-source du token U2F: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SoloKeys</a> . <br><br>  J'ai écrit mon article original (en anglais) il y a un an, et cette partie est un peu datée: alors SoloKeys était au stade du prototypage, et j'ai utilisé l'itération précédente du projet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">u2f-zero</a> .  Par conséquent, je ne traduirai pas cette partie maintenant, car la seule façon d'obtenir un appareil u2f-zero est de le souder vous-même, et il n'est guère conseillé de le faire (bien qu'il y ait des instructions sur le github). <br><br>  Néanmoins, tous les détails de la modification nécessaire de u2f-zero sont donnés dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article d'origine</a> . <br><br>  Lorsque mes mains atteindront les solokeys, j'écrirai des instructions pour sa modification. <br><br>  D'une manière ou d'une autre, c'est le seul moyen que je connaisse aujourd'hui pour obtenir un jeton U2F fonctionnel avec une sauvegarde fiable.  La vérification de plusieurs services (au moins google et github) a montré que cela fonctionne: en enregistrant le jeton principal sur le service, nous pouvons également utiliser la sauvegarde, et après la première utilisation de la sauvegarde, le jeton principal cesse de fonctionner.  Awwwwwww.  &lt;3 <br><br><h3>  Avertissement </h3><br>  Malgré le fait que cette stratégie de sauvegarde soit cool, je ne suis pas sûr de sa mise en œuvre spécifique via u2f-zero ou solokey.  Ce chemin est le seul moyen d'obtenir ce que vous voulez, alors je suis allé de cette façon;  mais en supposant que l'attaquant obtienne un accès physique à l'appareil U2F, je ne suis pas sûr que le piratage de l'appareil (c'est-à-dire en obtenant <code>device_secret</code> ) sera aussi difficile que dans le cas de Yubikey ou d'autres grands fabricants.  Les auteurs de solokey affirment que «le niveau de sécurité est le même que dans une clé de voiture moderne», mais je n'ai effectué aucun examen pour le confirmer. <br><br>  Cependant, pour être honnête, je ne suis pas vraiment inquiet à ce sujet.  Si un attaquant vole simplement un jeton sans avoir l'intention de le retourner, la complexité de le casser n'a pas d'importance, car  un attaquant peut simplement utiliser ce jeton pour accéder à un compte et, par exemple, simplement révoquer ce jeton et en ajouter un autre.  Cependant, pour cela, je dois également avoir d'autres problèmes de sécurité graves.  Le jeton U2F n'est que le deuxième facteur. <br><br>  Ainsi, le seul scénario dans lequel solokey peut être moins sécurisé qu'autre chose est lorsqu'un attaquant essaie d'accéder à l'appareil pendant une courte période, d'obtenir <code>device_secret</code> de lui et de me renvoyer l'appareil de manière invisible.  Pour ce faire, il doit lire le contenu du microcontrôleur flash (ou RAM au bon moment), et ce n'est pas très banal. <br><br>  Compte tenu de tous les facteurs, je pense que pour moi personnellement, avoir une sauvegarde fiable est beaucoup plus important que d'avoir une implémentation matérielle ultra-sécurisée d'un appareil U2F.  La probabilité de problèmes avec une implémentation aussi sûre et l'absence d'une bonne sauvegarde est plus élevée que la probabilité de problèmes avec u2f-zero (solokey) et la sauvegarde. <br><br><h2>  Conclusion </h2><br>  La stratégie de sauvegarde envisagée surpasse les alternatives dans toutes les dimensions: elle est universelle, plus sûre et plus fiable que toutes les autres méthodes. <br><br>  Je serai heureux si au moins l'un des principaux fabricants implémente cela dans leurs produits, mais il n'y a pas encore de certitude.  Un gars du support de Yubico, James A., m'a même dit que pour implémenter la sauvegarde comme j'avais besoin, ce n'était pas possible avec la façon dont U2F est conçu, et après avoir défini les détails de l'implémentation, il a juste cessé de répondre. <br><br>  Heureusement, ce n'était pas aussi impossible que le croit Yubico. <br><br><hr><br>  <i>Mon article original en anglais: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reliable, Secure and Universal Backup for U2F Token</a> .</i>  <i>Parce que</i>  <i>l'auteur de l'article original est moi-même, puis, avec votre permission, je n'ai pas mis cet article dans la catégorie «traduction»</i> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474300/">https://habr.com/ru/post/fr474300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474284/index.html">Non seulement les futures et les options: quels autres instruments financiers secondaires existent sur les bourses et pas seulement</a></li>
<li><a href="../fr474286/index.html">Analyse détaillée de la méthode simplex</a></li>
<li><a href="../fr474292/index.html">Tutoriel JavaFX: Prise en main</a></li>
<li><a href="../fr474294/index.html">Compatibilité binaire: maintenant ou jamais</a></li>
<li><a href="../fr474298/index.html">Mise en œuvre d'une opération de transfert de carte à carte de passerelle P2P</a></li>
<li><a href="../fr474302/index.html">Comment écrire un script de test d'utilisabilité d'application efficace</a></li>
<li><a href="../fr474306/index.html">Rendre les styles de pointage, de mise au point et d'état actif différents</a></li>
<li><a href="../fr474308/index.html">Types pour les API HTTP écrites en Python: expérience Instagram</a></li>
<li><a href="../fr474310/index.html">Y a-t-il des nombres aléatoires dans CSS?</a></li>
<li><a href="../fr474312/index.html">Installation de l'interface graphique sur Windows Server Core</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>