<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèΩ üíÆ üë©üèª‚ÄçüöÄ Animation squelettique sur le c√¥t√© de la carte vid√©o üë©üèª‚Äçüöí üòû ü§∏üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unity a r√©cemment introduit ECS. Au cours de mes √©tudes, je me suis int√©ress√© √† la fa√ßon dont l'animation et l'ECS peuvent devenir amis. Et dans le pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Animation squelettique sur le c√¥t√© de la carte vid√©o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452416/"><p>  Unity a r√©cemment introduit ECS.  Au cours de mes √©tudes, je me suis int√©ress√© √† la fa√ßon dont l'animation et l'ECS peuvent devenir amis.  Et dans le processus de recherche, je suis tomb√© sur une technique int√©ressante que les gars de NORDVEUS ont utilis√©e dans leur d√©mo pour le rapport Unite Austin 2017. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Unite Austin 2017 - Bataille massive dans l'univers de Spellsouls.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> </p><br><p>  Le rapport contient de nombreuses solutions int√©ressantes, mais aujourd'hui nous discuterons de la pr√©servation de l'animation squelettique dans la texture en vue de son application ult√©rieure. </p><br><p>  Pourquoi de telles difficult√©s, demandez-vous? </p><br><p>  Les gars de NORDVEUS ont simultan√©ment peint √† l'√©cran un grand nombre du m√™me type d'objet anim√©: squelettes, √©p√©istes.  Dans le cas de l'utilisation de l'approche traditionnelle: <u>SkinnedMeshRenderers</u> et <u>Animation \ Animator</u> , entra√Ænera une augmentation des appels de tirage et une charge suppl√©mentaire sur le CPU pour le rendu de l'animation.  Et pour r√©soudre ces probl√®mes, l'animation a √©t√© d√©plac√©e du c√¥t√© du GPU, et plus pr√©cis√©ment, du vertex shader. </p><br><a name="habracut"></a><br><p>  J'√©tais tr√®s int√©ress√© par l'approche et j'ai d√©cid√© de la comprendre plus en d√©tail, et comme je n'ai pas trouv√© d'articles sur ce sujet, je suis entr√© dans le code.  En train d'√©tudier la question, cet article est n√©, et ma vision de r√©soudre ce probl√®me. </p><br><h4>  Coupons donc l'√©l√©phant en morceaux: </h4><br><br><ul><li>  Obtention de cl√©s d'animation √† partir de clips </li><li>  Enregistrement des donn√©es dans la texture </li><li>  Pr√©paration de maille (maille) </li><li>  Shader </li><li>  Tout mettre ensemble </li></ul><br><br><h4>  Obtention de cl√©s d'animation √† partir de clips d'animation </h4><br><p>  √Ä partir des composants de <u>SkinnedMeshRenderers, nous</u> obtenons un tableau d'os et un maillage.  Le composant <u>Animation</u> fournit une liste des animations disponibles.  Donc, pour chaque clip, nous devons enregistrer la matrice de transformation image par image pour tous les os du maillage.  En d'autres termes, nous conservons la pose du personnage par unit√© de temps. </p><br><p>  Nous s√©lectionnons un tableau √† deux dimensions dans lequel les donn√©es seront stock√©es.  Dont une dimension a le nombre d'images multipli√© par la longueur du clip en secondes.  Un autre est le nombre total d'os dans le maillage: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boneMatrices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Matrix4x4[Mathf.CeilToInt(frameRate * clip.length), renderer.bones.Length];</code> </pre> <br><p>  Dans l'exemple suivant, nous modifions les images du clip un par un et enregistrons les matrices: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//       for (var frameIndex = 0; frameIndex &lt; totalFramesInClip; ++frameIndex) { //  : 0 -  , 1 - . var normalizedTime = (float) frameIndex / totalFramesInClip; //     animationState.normalizedTime = normalizedTime; animation.Sample(); //     for (var boneIndex = 0; j &lt; renderer.bones.Length; boneIndex++) { //         var matrix = renderer.bones[boneIndex].localToWorldMatrix * renderer.sharedMesh.bindposes[boneIndex]; //   boneMatrices[i, j] = matrix; } }</span></span></code> </pre><br><p>  Les matrices sont 4 par 4, mais la derni√®re ligne ressemble toujours √† (0, 0, 0, 1).  Par cons√©quent, √† des fins de l√©g√®re optimisation, il peut √™tre ignor√©.  Ce qui √† son tour r√©duira le co√ªt du transfert de donn√©es entre le processeur et la carte vid√©o. </p><br><pre> <code class="plaintext hljs">a00 a01 a02 a03 a10 a11 a12 a13 a20 a21 a22 a23 0 0 0 1</code> </pre><br><h4>  Enregistrement des donn√©es dans la texture </h4><br><p>  Pour calculer la taille de la texture, nous multiplions le nombre total d'images dans tous les clips d'animation par le nombre d'os et le nombre de lignes dans la matrice (nous avons convenu d'enregistrer les 3 premi√®res lignes). </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataSize = numberOfBones * numberOfKeyFrames * MATRIX_ROWS_COUNT); <span class="hljs-comment"><span class="hljs-comment">//      var size = NextPowerOfTwo((int) Math.Sqrt(dataSize)); var texture = new Texture2D(size, size, TextureFormat.RGBAFloat, false) { wrapMode = TextureWrapMode.Clamp, filterMode = FilterMode.Point, anisoLevel = 0 };</span></span></code> </pre><br><p>  Nous √©crivons les donn√©es dans la texture.  Pour chaque clip, nous enregistrons la matrice de transformation image par image.  Le format des donn√©es est le suivant.  Les clips sont enregistr√©s s√©quentiellement un par un et se composent d'un ensemble d'images.  Qui √† son tour se composent d'un ensemble d'os.  Chaque os contient 3 rang√©es de matrice. </p><br><pre> <code class="plaintext hljs">Clip0[Frame0[Bone0[row0,row1,row2]...BoneN[row0,row1,row2].]...FramM[bone0[row0,row1,row2]...ClipK[...]</code> </pre><br><p>  Voici le code de sauvegarde: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> textureColor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[texture.width * texture.height]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clipOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clipIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; clipIndex &lt; sampledBoneMatrices.Count; clipIndex++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> framesCount = sampledBoneMatrices[clipIndex].GetLength(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyframeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; keyframeIndex &lt; framesCount; keyframeIndex++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> frameOffset = keyframeIndex * numberOfBones * <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boneIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; boneIndex &lt; numberOfBones; boneIndex++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = clipOffset + frameOffset + boneIndex * <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = sampledBoneMatrices[clipIndex][keyframeIndex, boneIndex]; textureColor[index + <span class="hljs-number"><span class="hljs-number">0</span></span>] = matrix.GetRow(<span class="hljs-number"><span class="hljs-number">0</span></span>); textureColor[index + <span class="hljs-number"><span class="hljs-number">1</span></span>] = matrix.GetRow(<span class="hljs-number"><span class="hljs-number">1</span></span>); textureColor[index + <span class="hljs-number"><span class="hljs-number">2</span></span>] = matrix.GetRow(<span class="hljs-number"><span class="hljs-number">2</span></span>); } } } texture.SetPixels(textureColor); texture.Apply(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><h4>  Pr√©paration de maille (maille) </h4><br><p>  Ajoutez un ensemble suppl√©mentaire de coordonn√©es de texture auxquelles nous enregistrons pour chaque sommet les indices osseux associ√©s et le poids de l'influence de l'os sur ce sommet. <br>  Unity fournit une structure de donn√©es dans laquelle jusqu'√† 4 os sont possibles pour un sommet.  Vous trouverez ci-dessous le code pour √©crire ces donn√©es sur uv.  Nous enregistrons les indices osseux dans UV1, les poids dans UV2. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boneWeights = mesh.boneWeights; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boneIds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector4&gt;(mesh.vertexCount); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boneInfluences = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector4&gt;(mesh.vertexCount); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mesh.vertexCount; i++) { boneIds.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(bw.boneIndex0, bw.boneIndex1, bw.boneIndex2, bw.boneIndex3); boneInfluences.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(bw.weight0, bw.weight1, bw.weight2, bw.weight3)); } mesh.SetUVs(<span class="hljs-number"><span class="hljs-number">1</span></span>, boneIds); mesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, boneInfluences);</code> </pre><br><h4>  Shader </h4><br><p>  La t√¢che principale du shader est de trouver la matrice de transformation de l'os associ√© au sommet et de multiplier les coordonn√©es du sommet par cette matrice.  Pour ce faire, nous avons besoin d'un ensemble suppl√©mentaire de coordonn√©es avec des indices et des poids osseux.  Nous avons √©galement besoin de l'index de la trame courante, il changera avec le temps et sera transmis depuis le CPU. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// frameOffset = clipOffset + frameIndex * clipLength * 3 -     CPU // boneIndex -      ,   UV1 int index = frameOffset + boneIndex * 3;</span></span></code> </pre><br><p>  Nous avons donc obtenu l'indice de la premi√®re ligne de la matrice, l'indice des deuxi√®me et troisi√®me sera respectivement +1, +2.  Il reste √† traduire l'index unidimensionnel en coordonn√©es normalis√©es de la texture et pour cela nous avons besoin de la taille de la texture. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexToUV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, float2 size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(index % size.x)) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) / size.x, ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(index / size.x)) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) / size.y, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><p>  Apr√®s avoir soustrait les lignes, nous collectons la matrice sans oublier la derni√®re ligne, qui est toujours √©gale √† (0, 0, 0, 1). </p><br><pre> <code class="cpp hljs">float4 row0 = tex2Dlod(frameOffset, IndexToUV(index + <span class="hljs-number"><span class="hljs-number">0</span></span>, animationTextureSize)); float4 row1 = tex2Dlod(frameOffset, IndexToUV(index + <span class="hljs-number"><span class="hljs-number">1</span></span>, animationTextureSize)); float4 row2 = tex2Dlod(frameOffset, IndexToUV(index + <span class="hljs-number"><span class="hljs-number">2</span></span>, animationTextureSize)); float4 row3 = float4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4x4(row0, row1, row2, row3);</code> </pre><br><p>  En m√™me temps, plusieurs os peuvent affecter un sommet √† la fois.  La matrice r√©sultante sera la somme de toutes les matrices affectant le sommet multipli√©e par le poids de leur influence. </p><br><pre> <code class="cpp hljs">float4x4 m0 = CreateMatrix(frameOffset, bones.x) * boneInfluences.x; float4x4 m1 = CreateMatrix(frameOffset, bones.y) * boneInfluences.y; float4x4 m2 = CreateMatrix(frameOffset, bones.z) * boneInfluences.z; float4x4 m3 = CreateMatrix(frameOffset, bones.w) * boneInfluences.w; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m0 + m1 + m2 + m3;</code> </pre><br><p>  Apr√®s avoir re√ßu la matrice, nous la multiplions par les coordonn√©es du sommet.  Par cons√©quent, tous les sommets seront d√©plac√©s vers la pose du personnage, ce qui correspond √† l'image actuelle.  En changeant le cadre, nous animerons le personnage. </p><br><h4>  Tout mettre ensemble </h4><br><p>  Pour afficher les objets, nous utiliserons Graphics.DrawMeshInstancedIndirect, dans lequel nous transf√©rerons le maillage et le mat√©riau pr√©par√©s.  De plus, dans le mat√©riau, nous devons passer la texture avec des animations √† la taille de la texture et un tableau avec des pointeurs vers le cadre pour chaque objet √† l'heure actuelle.  Comme information suppl√©mentaire, nous passons la position de chaque objet et la rotation.  Pour savoir comment modifier la position et la rotation du c√¥t√© du shader, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[l'article]</a> . </p><br><p>  Dans la m√©thode Update, augmentez le temps √©coul√© depuis le d√©but de l'animation sur Time.deltaTime. </p><br><p>  Afin de calculer l'indice d'image, nous devons normaliser le temps en le divisant par la longueur du clip.  Par cons√©quent, l'index d'image dans le clip sera le produit du temps normalis√© par le nombre d'images.  Et l'indice d'image dans la texture sera la somme du d√©calage du d√©but du clip actuel et du produit de l'image actuelle par la quantit√© de donn√©es stock√©es dans cette image. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> offset = clipStart + frameIndex * bonesCount * <span class="hljs-number"><span class="hljs-number">3.0f</span></span></code> </pre> <br><p>  C'est probablement tout apr√®s avoir transmis toutes les donn√©es au shader, nous appelons Graphics.DrawMeshInstancedIndirect avec le maillage et le mat√©riau pr√©par√©s. </p><br><h4>  Conclusions </h4><br><p>  Le test de cette technique sur une machine avec une carte graphique 1050 a montr√© une augmentation des performances d'environ 2 fois. </p><br><img src="https://habrastorage.org/webt/yz/a-/iv/yza-ivxgj5ccdyb7kxomb2smgxm.png" alt="image"><br><p>  Animation de 4000 objets du m√™me type sur la CPU </p><br><img src="https://habrastorage.org/webt/xd/73/e1/xd73e1eil8yq1qjo134kx77cbna.png" alt="image"><br><p>  Animation de 8000 objets du m√™me type sur le GPU </p><br><p>  Dans le m√™me temps, tester cette sc√®ne sur un macbook pro 15 avec une carte graphique int√©gr√©e montre le r√©sultat inverse.  Le GPU perd sans vergogne (environ 2-3 fois), ce qui n'est pas surprenant. </p><br><p>  L'animation sur la carte vid√©o est un autre outil qui peut √™tre utilis√© dans votre application.  Mais comme tous les outils, il doit √™tre utilis√© √† bon escient et hors de propos. </p><br><h4>  Les r√©f√©rences </h4><br><br><ul><li>  Instanciation d'animation - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Instanciation pour SkinnedMeshRenderer</a> </li><li>  GPUSkinning - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">am√©liorez les performances.</a> </li><li>  UniteAustinTechnicalPresentation - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©mo ECS</a> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[Code de projet GitHub]</a> <br><p>  Merci de votre attention. </p><br><p>  PS: Je suis nouveau sur Unity et je ne connais pas toutes les subtilit√©s, l'article peut contenir des inexactitudes.  J'esp√®re les corriger avec votre aide et mieux comprendre le sujet. </p><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452416/">https://habr.com/ru/post/fr452416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452404/index.html">Cinq tendances cl√©s de l'ITSM pour cette ann√©e</a></li>
<li><a href="../fr452408/index.html">Toilette Maine Coon</a></li>
<li><a href="../fr452410/index.html">Lancement de Bash en d√©tail</a></li>
<li><a href="../fr452412/index.html">Confidentialit√© des donn√©es, IoT et Mozilla WebThings</a></li>
<li><a href="../fr452414/index.html">HP Reverb - Examen du nouvel ensemble VR</a></li>
<li><a href="../fr452418/index.html">Comment faire une pr√©sentation produit qui engagera le client?</a></li>
<li><a href="../fr452424/index.html">La carence en h√©lium peut ralentir le d√©veloppement des ordinateurs quantiques - discuter de la situation</a></li>
<li><a href="../fr452426/index.html">Connexion √† Azure DevOps √† l'aide des informations d'identification GitHub</a></li>
<li><a href="../fr452428/index.html">Dictionnaire Yandex rapide</a></li>
<li><a href="../fr452430/index.html">QA: Hackathons</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>