<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💝 🖐️ 🧗🏻 Bataille de MERGE. Chronique avec conclusions et morale 👸 🈯️ 🎴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quelques semaines avant l'important festival de commit - le dernier avant la version feature freeze de PostgreSQL 11 - les newsletters des hackers , c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bataille de MERGE. Chronique avec conclusions et morale</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/412605/"> Quelques semaines avant l'important <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">festival de commit</a> - le dernier avant la version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>feature freeze</code></a> de <b>PostgreSQL 11</b> - les newsletters des <b>hackers</b> , compressant le chipset dans le package de gauche, ont regardé le thriller <b>MERGE</b> .  Le directeur du thriller et PDG de <b>2ndQuadrant, <i>Simon Riggs</i></b> , a essayé de pousser un patch qui implémente la syntaxe de la commande MERGE avec une persévérance et une ingéniosité impressionnantes.  Riggs est comédien depuis 2009, et avec le statut de comédien, vous pouvez approuver les correctifs vous-même.  Il a été combattu par des comités et des vétérans de PostgreSQL non moins respectés.  Les passions bouillonnaient clairement et implicitement, il ne s'agissait même pas d'insultes directes - un fait surprenant pour les habitués de nombreux forums nationaux.  Cependant, une certaine tension est restée jusqu'à présent lorsque la question a été réglée, et il n'y a rien à discuter. <a name="habracut"></a><br><br>  Mais les passions sont des passions (elles seront discutées plus loin), et je voudrais trier sans passion l'essence de ce problème complètement farfelu. <br><br><img src="https://habrastorage.org/webt/t5/zc/ra/t5zcramwnjffszncwjkkkl9xt2g.jpeg"><br><h3>  MERGE dehors </h3><br>  Si cela simplifie complètement, alors la chose est la suivante: nous avons 2 tables avec les mêmes champs et des données différentes.  Supposons le nom et l'âge.  Nous devons les combiner en un seul.  Mais il serait nécessaire de décider quoi faire avec ces personnalités qui sont dans les deux tableaux.  Très probablement, nous voudrons tout dans la table finale et mettre à jour les informations pour les individus correspondants.  Il est clair que même dans ce contexte, c'est une tâche très courante.  Il peut être résolu sans <code>MERGE</code> , ce qui rend une demande complexe, vous pouvez utiliser des déclencheurs et ainsi de suite.  Mais c'est gênant.  Cependant, la version non canonique de MERGE, appelée UPSERT (UPdate + inSERT), résout ce problème. <br><br>  L'opérateur MERGE est dans la norme SQL-2003 et déjà dans toute sa splendeur dans SQL-2008.  Il est implémenté dans Oracle, DB2 et MS SQL, ce qui signifie que le manque de MERGE dérangera ceux qui envisagent de passer de ces SGBD à PostgreSQL.  Le désir ardent de Simon Riggs le plus rapidement possible, déjà dans PostgreSQL 11, a été alimenté par les souhaits des clients 2ndQuadrant, et non par l'ambition ou la querelle. <br><br>  En fait, MERGE a des capacités riches, les données ne doivent pas être extraites de tables, en particulier de structures similaires. <br><br>  La syntaxe de la commande est la suivante: <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tablename <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> table_reference <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (condition) <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> column1 = value1 [, column2 = value2 ...] <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> (column1 [, column2 ...]) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (value1 [, value2 ...]);</code> </pre> <br>  Vous pouvez cependant comme ceci: <br><br><pre> <code class="hljs powershell">MERGE <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">hint</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">INTO</span></span></span></span> <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">schema</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">.</span></span></span><span class="hljs-function">] {</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">table</span></span></span></span> | view} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">table_alias</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USING</span></span></span></span> { subquery | <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">schema</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">.</span></span></span><span class="hljs-function">] { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">table</span></span></span></span> | view}} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">table_alias</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ON</span></span></span></span> ( condition ) [ <span class="hljs-type"><span class="hljs-type">merge_update_clause</span></span> ] [ <span class="hljs-type"><span class="hljs-type">merge_insert_clause</span></span> ] [ <span class="hljs-type"><span class="hljs-type">error_logging_clause</span></span> ] ;</code> </pre> <br>  Cette syntaxe est implémentée dans Oracle.  En d'autres termes, MERGE effectue des actions qui modifient les enregistrements dans la table cible target_table_name à l'aide de data_source dans une seule commande SQL, qui peut, selon les conditions, faire INSERT, UPDATE ou DELETE par rapport aux enregistrements dans target_table_name.  Dans ce cas, target_table_name peut être une vue et data_source peut être un ensemble de <b>tables ou de vues, le résultat d'une sous-requête</b> . <br><br>  Premièrement, l' <code>MERGE</code> effectue une <code>left outer join</code> sur la <code>data_source</code> de <code>data_source</code> avec <code>target_table_name</code> , suggérant 0 ou plusieurs enregistrements de changement de candidat;  <code>WHEN</code> clauses sont calculées dans l'ordre spécifié;  dès que la condition est remplie, l'action correspondante est exécutée.  Mots clés <code>WHEN [NOT] MATCH THEN</code> n'est pas très courant en <code>SQL</code> , nous vous rappelons donc qu'il s'agit d'une construction de contrôle comme <code>if-else</code> dans d'autres langages.  <code>MERGE</code> agit de la même manière que <code>UPDATE, INSERT</code> ou <code>DELETE</code> qui concerne <code>target_table_name</code> , seule la syntaxe de la commande entière est différente. <br><br>  Une clause avec <code>ON</code> doit établir une connexion sur toutes les colonnes de la clé primaire ou, si d'autres colonnes sont spécifiées, alors un index unique doit être utilisé pour que les conditions <code>[NOT] MATCHED</code> déterminent immédiatement les actions pour l'enregistrement candidat afin d'exclure l'interaction avec d'autres transactions. <br><br>  Commande déterministe <code>MERGE</code> : vous ne pouvez pas mettre à jour plusieurs fois le même enregistrement dans la même commande MERGE. <br>  Un exemple: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> CustomerAccount CA <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> RecentTransactions T <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> T.CustomerId = CA.CustomerId <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> Balance = Balance + TransactionValue <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> (CustomerId, Balance) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (T.CustomerId, T.TransactionValue);</code> </pre> <br>  ou avec une sous-requête: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bonuses D <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> employee_id, salary, department_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> department_id = <span class="hljs-number"><span class="hljs-number">80</span></span>) S <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (D.employee_id = S.employee_id) <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> D.bonus = D.bonus + S.salary*<span class="hljs-number"><span class="hljs-number">.01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (S.salary &gt; <span class="hljs-number"><span class="hljs-number">8000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> (D.employee_id, D.bonus) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (S.employee_id, S.salary*<span class="hljs-number"><span class="hljs-number">.01</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (S.salary &lt;= <span class="hljs-number"><span class="hljs-number">8000</span></span>);</code> </pre> <br>  Dans <b>IBM DB2, la</b> syntaxe fonctionnera également.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comme on dit</a> , "sous le capot", cela se fera de la même manière que la construction <code>UPDATE FROM</code> . <br>  Depuis 2008, <b>MS SQL</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">possède également</a> <code>MERGE</code> . <br><br>  Mais même derrière une seule syntaxe standard, le problème du choix parmi un nombre considérable de mécanismes et de méthodes de mise en œuvre commence.  L'équipe doit travailler à différents niveaux d'isolement des transactions, avec différents algorithmes de verrouillage, en se concentrant sur un mode de fonctionnement hautement compétitif ou pas si bon.  Et, comme vous pouvez le deviner, pour implémenter cette logique compliquée, vous devez toucher à de nombreux composants SGBD. <br><br><h3>  UPSERT, pseudo-MERGE </h3><br>  Il est clair que les développeurs de SGBD recherchaient des solutions de compromis, refusant de reproduire littéralement la syntaxe standard.  Le plus de cette approche est la liberté.  Vous pouvez utiliser des mécanismes organiques pour un SGBD particulier, vous pouvez optimiser la mise en œuvre pour les tâches que vous jugez les plus pertinentes pour vos utilisateurs. <br><br>  Par exemple, dans <b>MySQL,</b> il existe une commande <code>REPLACE</code> qui fonctionne comme <code>INSERT</code> , mais si les nouvelles et anciennes lignes ont les mêmes valeurs dans l'index <code>PRIMARY KEY</code> ou <code>UNIQUE</code> , alors l'ancienne ligne est supprimée avant l'insertion de la nouvelle.  Mais il y a aussi <code>INSERT ... ON DUPLICATE KEY UPDATE</code> où <code>INSERT</code> et <code>UPDATE</code> se produisent (au lieu de <code>DELETE</code> dans <code>REPLACE</code> ).  Voici <code>UPSERT</code> .  Et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il y a</a> <code>INSERT IGNORE</code> , qui n'effectue simplement pas l'insertion, sans lancer d'erreur (mais d'avertissement) sous certaines restrictions sur la table cible. <br><br><h3>  Chroniques de PG MERGE </h3><br>  Dans la communauté PostgreSQL, parler de MERGE a commencé en 2005 lorsque Jaime Casanova a demandé <i>si quelqu'un dans la communauté avait commencé à développer</i> <code>MERGE</code> .  <i>Peter Eisentraut a</i> <a href="">suggéré de discuter</a> <i>si PostgreSQL devrait développer l'une des options MERGE: similaire à l'implémentation MySQL, ou mieux pour diriger l'effort vers une version fonctionnellement légère du type <code>MERGE</code> d'Oracle.</i>  <i>Mais vaut-il la peine de faire des efforts dans ce sens?</i> <br><br>  Au milieu d'une courte discussion, le protagoniste de ce récit <i>Simon Riggs</i> apparaît avec les mots: <br>  <i>MERGE est utile à la fois pour les systèmes OLTP et pour DW (Data Warehouse - les entrepôts de données, c'est-à-dire les applications analytiques où les requêtes complexes, mais les environnements et les données pas trop compétitifs sont rarement mis à jour, et s'ils sont mis à jour, généralement en gros morceaux. &lt;...&gt; Nous pouvons implémenter MERGE comme une variante de COPY FROM, ce sera très cool.</i> <br><br>  Tout le monde est d'accord: oui, cool.  Plus précisément, presque tout: <i>Stephen Frost</i> : <i>Je pense que je ne suis pas le seul à dire que j'ai besoin d'une norme MERGE à part entière et conforme.</i> <br><br>  Bruce Momjian a une proposition différente et plus pragmatique: <i>il me semble que nous devons implémenter dans</i> <code>MERGE</code> <i>quelques options que nous pouvons implémenter, et dans le reste nous donnerons une erreur (et dans les cas où il sera nécessaire de bloquer la table entière).</i>  <i>Et après avoir reçu les commentaires des utilisateurs et nous réfléchirons à la suite.</i> <br><br>  Mais jusqu'à présent, rien ne se passe. <br><br><h3>  La glace s'est brisée </h3><br>  En <b>2008,</b> <i>Simon Riggs a de</i> nouveau exhorté à traiter avec MERGE - laquelle des façons de choisir (d'ici là, une nouvelle version de MERGE dans la norme SQL-2008, qui est encore en ébauche, est déjà en train d'apparaître).  Il peint en détail à ce moment l'implémentation d'Oracle, IBM et MS SQL et la syntaxe alternative de MySQL et Teradata.  Et un peu plus tard, il mentionne déjà le <b>début des travaux dans 2ndQuadrant</b> dans ce sens. <br><br>  Peter Eisentraut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écrit sur son blog</a> : <i>Bien sûr, Riggs est l'un des spécialistes les plus qualifiés, il peut diriger les travaux sur la mise en œuvre de MERGE.</i> <br><br>  Mais voici le premier virage inattendu: un <b>étudiant</b> est impliqué dans le problème - un participant au développement du programme <b>GSoC</b> , c'est-à-dire Google Summer of Code.  Son nom est <i>Boxuan Bxzhai</i> - je ne prétends pas transcrire le nom de famille.  Bientôt, il écrit que le travail est presque terminé. <br><br>  Mais presque ne compte pas.  <i>Greg Smith</i> de 2ndQuadrant (c'est-à-dire l'allié de Simon Riggs) écrit: <br>  <i>Nous avons donc un correctif dans le code dont une demi-douzaine de problèmes graves non résolus.</i>  <i>Je me tais sur les petits.</i>  <i>Les problèmes sont trop profonds pour finaliser le code du commitfest.</i>  <i>Pendant ce temps, rien n'a été entendu de Boxuan depuis longtemps.</i>  <i>Nous pourrions l'aider, mais où est-il?</i>  <i>Qui est au courant?</i> <br><br>  Une discussion sur les chemins d'implémentation refait surface en <b>2014</b> , mais là encore rien ne se passe: il n'y a pas de code. <br><br>  Enfin, dès <b>2017,</b> <i>Simon Riggs</i> écrit: <br>  <i>Je travaille sur du code pour valider <code>MERGE</code> dans <b>PostgreSQL</b> version <b>11</b> .</i>  <i>Nous utilisons les mêmes mécanismes qui sous-tendent le <code>INSERT ON CONFLICT</code> , qui fonctionne déjà, afin qu'aucune modification d'infrastructure ne soit nécessaire, en implémentant simplement la syntaxe en plus de ce qui est disponible.</i>  <i>Mais j'écris mon code à partir de zéro, je n'utilise pas les développements précédents.</i> <br><br>  Nous parlons de Peter Geoghegan ( <b>VMware</b> ) implémenté à cette époque déjà dans la syntaxe alternative <code>INSERT .. ON CONFLICT UPDATE</code> 9.5 <code>INSERT .. ON CONFLICT UPDATE</code> , différent du standard SQL, mais toujours lié à <code>MERGE</code> et <code>REPLACE</code> dans MySQL. <br><br>  Au début, le travail de Simon a rencontré des exclamations du travail de Nice!  Cependant, <i>Robert Haas</i> , bien que favorable, met en garde contre d'éventuelles anomalies de sérialisation.  Par exemple, pour gérer <code>INSERT .. ON CONFLICT UPDATE</code> , sans MERGE à sa base, c'est en quelque sorte plus calme. <br><br>  <code>UPSERT</code> auteur de PostgreSQL <code>UPSERT</code> lui-même: <br>  <i>Je ne mélangerais pas le <code>MERGE</code> <code>ON CONFLICT DO UPDATE</code> et <code>MERGE</code> .</i>  <i>&lt;...&gt; Pour charger de gros morceaux de données ( <code>bulk load</code> ), j'utiliserais, par exemple, l'algorithme de <code>merge join</code> .</i>  <i>&lt;...&gt; En général, les avantages de <code>MERGE</code> seraient liés au fait que les connexions normales y fonctionneraient de la manière habituelle: <code>nested loop, hash, merge</code> .</i>  <i>Et dans <code>INSERT … ON CONFLICT</code> il n'y a aucune jointure.</i> <br><br>  Haas: <i>Comme Peter, je pense que si cela est fait de cette façon, alors un tel verrou fort lors de l'exécution d'une demande <code>DML</code> semble moyen.</i>  <i>Il est peu probable que quiconque soit satisfait qu'une seule personne puisse travailler avec <code>MERGE</code> à la fois.</i> <br><br>  Pour ceux qui sont curieux: Geigan analyse les subtilités et les différences <code>UPSERT</code> entre <code>MERGE</code> et <code>MERGE</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> (nous stockons la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correspondance archivée de</a> PostgreSQL sur notre site Web). <br><br>  Simon résiste.  Il fait appel à l'histoire récente.  Par exemple, à propos de la section, ils ont également dit "une nouvelle syntaxe, rien de plus".  Mais cela s'est avéré être une chose très utile.  <i>Mais je ne propose pas de réaliser tout de suite tout ce qu'il y a dans MERGE.</i>  <i>Nous ferons la même chose qu'avec le partitionnement - nous divisons le développement en phases.</i> <br><br>  Et un autre argument, à mon avis, est très convaincant: <i>bien.</i>  <i>Mais choisissons.</i>  <i>Je propose une option pratique.</i>  <i><b>10 ans viendront bientôt</b> de la première tentative sérieuse de développer <code>MERGE</code> .</i>  <i>N'est-il pas temps de commencer à faire quelque chose, d'obtenir une solution utile, au lieu d'attendre encore 10 ans de la solution parfaite?</i>  <i>En supposant que cela existe.</i> <br><br>  Enfin, le patch arrive dans la communauté.  Quelle date?  Imaginez s'il vous plaît.  Non, ils n'ont pas deviné: Simon l'envoie le 30 décembre 2017.  Et stipule qu'il s'agit d'un correctif WIP, c'est-à-dire Work in Progress - un correctif en cours. <br><br>  Simon, janvier: <br>  <i>Le patch est terminé sans aucun bogue spécial.</i>  <i><b>1200 lignes de code</b> plus tests et documentation.</i>  <i>Je vais le confier à ce commitfest, et nous compléterons le RLS (Row Level Security - protection au niveau de l'enregistrement) et le support de partitionnement plus tard.</i> <br><br><h3>  Caste des commissions </h3><br>  Ici, nous devons prendre un pas de côté et expliquer le rôle du commissaire dans la communauté.  Les fonctions du commissaire, c'est-à-dire celui qui est autorisé à accepter le patch dans la prochaine version, ont historiquement changé.  Il était une fois, quand il y avait peu de développeurs, le droit de s'engager était généreusement distribué.  Par exemple, le célèbre (dans un domaine complètement différent) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Julian Assange a</b></a> reçu le titre de commandant, étant l'auteur de seulement six patchs.  Maintenant, ce n'est pas facile de devenir commissaire, il n'y a pas de parvenus sur la liste de quelques dizaines de personnes.  Boyus Momdjan ( <b>EnterpriseDB</b> ) a 13 363 commits, Tom Lane (Tom Lane, <b>Crunchy Data</b> ) 13127, Robert Haas ( <b>EnterpriseDB</b> ) - 2074. Soit dit en passant, le <b>seul committer de Russie</b> est <i>Fedor Sigaev</i> ( <b>Postgres Professional</b> ) avec ses 383 commits .  Simon Riggs en a lui-même 449. Je le répète: en tant que commissaire, il a suffisamment d'autorité pour prendre et commettre des correctifs - lui et ses employés.  Une autre chose est que cela ne vaut guère la peine de le faire, négligeant franchement les opinions des autres principaux comités de sommités.  Ils peuvent également priver le statut de commissaire, mais au moins ils <code>revert</code> patch. <br><br><h3>  Fracture au combat </h3><br>  Bien sûr, dans le patch "désespéré", fait, en général, à la hâte, ils trouvent de nouvelles erreurs.  Les nouvelles versions roulent en réponse. <br><br>  Fin janvier, un nouveau personnage apparaît: le développeur de 2ndQuadrant <i>Pavan</i> (son nom est tout le monde par son nom; complètement Pavan Deolasee).  Maintenant, la communauté a affaire à un tandem: Pavan envoie de nouvelles versions et merci pour les critiques, et Simon les brise avec une pression marketing remarquable. <br><br>  Haas: <i>Je ne pense pas que cela vaut la peine de prendre des décisions unilatérales sur l'exclusion des fonctionnalités qui fonctionnent partout.</i>  <i>Si nous convenons que certaines fonctionnalités ne seront pas incluses dans ce patch - c'est une chose.</i>  <i>Et c'est complètement différent que dans les commentaires à cette occasion, tout le monde ait exprimé son désaccord.</i>  <i>Et nous n'avons en fait pas entendu les raisons pour lesquelles ces fonctionnalités devraient être exclues.</i> <br><br>  La logique a été présentée comme suit: <br><br><ul><li>  a priori, il y a de sérieux problèmes car ils ne peuvent qu'être dans les évolutions du style «attaque de cavalerie». </li><li>  La prise en charge de fonctionnalités même importantes telles que le nouveau partitionnement dans les versions 10-11, CTE (Common Table Expressions = WITH queries) ou RLS (Row Level Security) peut être terminée même après l'acceptation du correctif dans la version actuelle, mais uniquement si l'architecture proposée convient pour la construction par le haut sa fonctionnalité souhaitée. </li></ul><br>  Le deuxième Peter Geigan formule ceci: <br>  <i>Habituellement, je fais attention au <b>support de diverses fonctionnalités, car si c'est le cas, cela renforce la croyance générale que le design est fait comme il se doit</b> .</i>  <i>Et si de tels problèmes sont causés par la prise en charge des expressions <code>WITH</code> [c'est-à-dire <code>CTE</code> ], j'ai alors l'idée que l'architecture sous-jacente est telle qu'elle causera des problèmes ici et là.</i> <br><br>  Pendant ce temps, l'heure X (le dernier comité) approche et les nuages ​​au-dessus de MERGE se rassemblent.  Ce n'est pas que les pères fondateurs aient spécifiquement recherché de sérieux problèmes dans l'architecture des patchs réalisés par Simon puis Pavan.  Je n'ai pas eu à chercher de problèmes, ils se sont volontairement ouverts. <br><br><h3>  Le dénouement approche </h3><br>  L'intrigue s'accélère.  Malgré l'attitude cool des autres comités envers son entreprise, <b>le 2 avril,</b> Simon décide de valider la <b>commande SQL SQL 2016</b> , ajoute les fichiers, Depesz (Hubert Lubachevsky) parvient à l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">annoncer</a> sur son blog, mais le même jour, Simon annule tout parce que des erreurs. <br><br>  Le lendemain, engagez-vous à nouveau en ajoutant <code>WITH</code> support. <br><br>  En réponse, les allégations sont vraiment graves.  <i>Andres Freund</i> ( <b>EnterpriseDB</b> ) écrit: <br>  <i>L'architecture de MERGE dans l'analyseur et l'exécuteur testamentaire ne m'a pas impressionné de manière fiable.</i>  <i>La création de jointures cachées lors de l'analyse syntaxique est une très mauvaise idée.</i>  <i>Cette structure de l'exécuteur doit être complètement modifiée.</i> <br><br>  Tom Lane: <br>  <i>La conception de l'arbre d'analyse est faible.</i> <br><br><br><br>  <i>Vous surchargez la fonction <code>InsertStmt</code> , poursuit-il, elle ne fait pas du tout <code>INSERT</code> , mais elle a aléatoirement les mêmes champs que celui d'origine.</i>  <i>Et pas tous, mais certains.</i>  <i>C'est mauvais, cela mène à la confusion.</i> <br><br>  Ajoutons des observations de <i>Fedor Sigayev</i> : <br>  <i>Dans l'analyseur, des nœuds <code>INSERT</code> liés à <code>MERGE</code> sont apparus, accrochés à un tas de champs supplémentaires.</i>  <i>Si vous regardez le plan d'exécution dans <code>ANALIZE</code> , vous ne comprendrez pas immédiatement si vous avez affaire à un <code>INSERT</code> régulier ou à <code>MERGE</code> : pour comprendre, vous devez regarder des champs supplémentaires.</i> <br><br><br>  Simon, calmement: <i>OK, nous allons changer cela et envoyer un nouveau fichier demain</i> . <br>  Haas: <i>Je suis d'accord avec Peter.</i>  <i>Le choix de l'architecture est infructueux.</i> <br><br>  Simon n'abandonne pas.  <b>Le 6 avril,</b> en réponse aux critiques de Tom Lane, commet un nouveau patch tel que modifié dans l'analyseur. <br><br><h3>  Négociation et remise </h3><br>  Bruce Momjan <b>6 avril</b> : <br>  <i>Je veux noter que les gens ne vous ont pas demandé de travailler dur pour réparer quelque chose de toute urgence.</i>  <i>Ils vous ont demandé de retirer le patch.</i>  <i>Vous pouvez bien sûr travailler dur, en espérant qu'ils changeront d'avis, mais - encore une fois - ils ne vous ont pas posé de questions à ce sujet.</i> <br><br>  Simon: <i>Si Tom [Lane] et Andres [Freund] pour les quelques jours restants estiment toujours que leurs craintes n'ont pas été dissipées, je <b>serai heureux de faire reculer le patch</b> sans plus tarder.</i> <br><br>  Tom Lane: <i>Je vote toujours pour que le patch soit annulé.</i>  <i>Même s'il était parfait maintenant, les gens n'ont plus le temps d'en être convaincus - à la gorge d'autres questions urgentes.</i> <br><br>  C’est tout. <br><br>  Simon a dit OK, et la bataille de <code>MERGE</code> terminée.  Tous les correctifs sont pompés, le sujet a été déplacé vers le prochain commitfest avec le statut "En attente de la fin de l'auteur".  Les participants au spectacle ont fait la paix. <br><br><img src="https://habrastorage.org/webt/ad/zw/ry/adzwryarovhxoldwxewpneljyms.jpeg"><br>  Cependant, à en juger par la correspondance des dernières semaines, une certaine tension semble persister. <br><br><h3>  Moralité promise </h3><br><ul><li>  Heureusement, la communauté PostgreSQL dispose de mécanismes naturels et formels pour le filtrage (presque) sans conflit des tentatives de solutions immatures.  Même s'ils sont poinçonnés par des développeurs respectés au rang de chef d'entreprise, dont la contribution au développement de PostgreSQL est énorme.  Et les clients qui manquent de fonctionnalités poussent à investir. </li><li>  Malheureusement, la communauté cale souvent.  Elle est inertielle dans l'adoption d'évolutions pertinentes, même sans ambiguïté.  Parfois, le perfectionnisme irrationnel est inclus.  L'expérience de Postgres Professional, où je travaille, le confirme.  Nous avons perforé un patch important et important d' <b>indices INCLUDE</b> pendant 3 ans.  Une série de correctifs utiles pour travailler avec <b>JSON / JSONB</b> attend toujours.  L'expression "donnez votre développement à la communauté" ne signifie <b>pas vraiment donner, mais donner des coups de poing</b> : l'invité est accueilli à bras ouverts et escorté en quarantaine. </li></ul><br>  PS: <i>Avis de non-responsabilité de l'auteur</i> : nous voulions simplement montrer un morceau de vie communautaire.  Toutes les correspondances de noms sont aléatoires :) <br>  PPS: Samurai <i>Natalia Levshina</i> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412605/">https://habr.com/ru/post/fr412605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412591/index.html">Construire un jetpack: le 29 mai est le Memorial Day de Wendell Moore</a></li>
<li><a href="../fr412593/index.html">Nouveaux produits, plates-formes et tout-en-un: Webinaires HPE</a></li>
<li><a href="../fr412595/index.html">Rapport 2018 du Club de Rome, chapitre 1.1.2: «Financement»</a></li>
<li><a href="../fr412597/index.html">Jeff Bezos va construire une colonie à la surface de la lune</a></li>
<li><a href="../fr412603/index.html">Étranges déclarations PHP</a></li>
<li><a href="../fr412607/index.html">Station de soudage réversible classe HI-END</a></li>
<li><a href="../fr412609/index.html">10 conseils pour la productivité dans CLion, un IDE C / C ++ multiplateforme</a></li>
<li><a href="../fr412611/index.html">Qu'ont en commun l'efficacité de l'exploitation minière et de la théorie des jeux</a></li>
<li><a href="../fr412613/index.html">Arithmétique entière. Divisez en arrondissant le résultat. Partie 1</a></li>
<li><a href="../fr412615/index.html">Présence d'un objectif de route dans les annonces BGP entre PE et CE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>