<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¥§ ğŸ¤°ğŸ¿ ğŸ‘‡ğŸ¼ Nous Ã©tudions les analyseurs syntaxiques pour la langue russe ğŸŒ­ ğŸ¦ ğŸ’‹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut Je m'appelle Denis Kiryanov, je travaille Ã  la Sberbank et je m'occupe des problÃ¨mes de traitement du langage naturel (PNL). Une fois, nous devi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous Ã©tudions les analyseurs syntaxiques pour la langue russe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/418701/">  Salut  Je m'appelle Denis Kiryanov, je travaille Ã  la Sberbank et je m'occupe des problÃ¨mes de traitement du langage naturel (PNL).  Une fois, nous devions choisir un analyseur syntaxique pour travailler avec la langue russe.  Pour ce faire, nous nous sommes plongÃ©s dans la nature sauvage de la morphologie et de la tokenisation, testÃ© diffÃ©rentes options et Ã©valuÃ© leur application.  Nous partageons notre expÃ©rience dans ce post. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c87/ec8/f26/c87ec8f26a969cf54915271e24abcba1.png"><br><a name="habracut"></a><br><h2>  PrÃ©paration Ã  la sÃ©lection </h2><br>  CommenÃ§ons par les bases: comment Ã§a marche?  Nous prenons le texte, effectuons la tokenisation et obtenons un tableau de pseudo-jetons.  Les Ã©tapes d'une analyse plus approfondie s'inscrivent dans une pyramide: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2f/cd9/0aa/b2fcd90aaf42d1eee5ed3ee84fcf27fd.png"><br><br>  Tout commence par la morphologie - avec une analyse de la forme d'un mot et de ses catÃ©gories grammaticales (genre, cas, etc.).  La morphologie est basÃ©e sur la syntaxe - des relations au-delÃ  des limites d'un mot, entre les mots.  Les analyseurs syntaxiques qui seront discutÃ©s, analysent le texte et donnent la structure des dÃ©pendances des mots les uns des autres. <br><br><h3>  Grammaire des dÃ©pendances et grammaire des composants immÃ©diats </h3><br>  Il existe deux approches principales de l'analyse, qui existent en thÃ©orie linguistique sur un pied d'Ã©galitÃ©. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c59/951/f08/c59951f08529e3628f3ad969385e4be9.png"><br><br>  Dans la premiÃ¨re ligne, la phrase est analysÃ©e dans le cadre de la grammaire des dÃ©pendances.  Cette approche est enseignÃ©e Ã  l'Ã©cole.  Chaque mot d'une phrase est en quelque sorte liÃ© aux autres.  Â«SavonsÂ» - un prÃ©dicat dont dÃ©pend le sujet Â«mÃ¨reÂ» (ici la grammaire des dÃ©pendances diverge de l'Ã©cole, oÃ¹ le prÃ©dicat dÃ©pend du sujet).  Le sujet a une dÃ©finition dÃ©pendante du Â«mienÂ».  Le prÃ©dicat a une "trame" de complÃ©ment direct dÃ©pendante.  Et l'ajout direct au "cadre" - la dÃ©finition de "sale". <br><br>  Dans la deuxiÃ¨me ligne, l'analyse est conforme Ã  la grammaire des composants eux-mÃªmes. <br>  Selon elle, la phrase est divisÃ©e en groupes de mots (phrases).  Les mots d'un mÃªme groupe sont plus Ã©troitement liÃ©s.  Les mots Â«maÂ» et Â«mÃ¨reÂ» sont plus Ã©troitement liÃ©s, Â«cadreÂ» et Â«saleÂ» - aussi.  Et il y a encore un Â«savonÂ» distinct. <br><br>  La deuxiÃ¨me approche pour l'analyse automatique de la langue russe est mal applicable, car en elle, des mots Ã©troitement liÃ©s (membres du mÃªme groupe) ne se tiennent trÃ¨s souvent pas d'affilÃ©e.  Il faudrait les combiner avec des parenthÃ¨ses Ã©tranges - en un ou deux mots.  Par consÃ©quent, dans l'analyse automatique de la langue russe, il est habituel de travailler sur la base de la grammaire des dÃ©pendances.  C'est Ã©galement pratique car tout le monde connaÃ®t un tel Â«cadreÂ» Ã  l'Ã©cole. <br><br><h3>  Arbre de dÃ©pendance </h3><br>  Nous pouvons traduire un ensemble de dÃ©pendances en une structure arborescente.  Le sommet est le mot Â«savonÂ», certains mots dÃ©pendent directement de lui, certains dÃ©pendent de ses dÃ©pendants.  Voici la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dÃ©finition</a> de l'arbre de dÃ©pendance du manuel de Martin et Zhurafsky: <br><br>  <i>L'arbre de dÃ©pendance est un graphe orientÃ© qui satisfait les contraintes suivantes:</i> <br><br><ul><li>  <i>Il existe un seul nÅ“ud racine dÃ©signÃ© qui n'a pas d'arcs entrants.</i> <br></li><li>  <i>Ã€ l'exception du nÅ“ud racine, chaque sommet a exactement un arc entrant.</i> <br></li><li>  <i>Il existe un chemin unique du nÅ“ud racine Ã  chaque sommet de V.</i> <br></li></ul><br>  Il existe un nÅ“ud de niveau supÃ©rieur - un prÃ©dicat.  De lÃ , vous pouvez atteindre n'importe quel mot.  Chaque mot dÃ©pend d'un autre, mais d'un seul.  L'arbre des dÃ©pendances ressemble Ã  ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b3/b16/19d/4b3b1619db261a71dfd749c28b4fde31.png"><br><br>  Dans cet arbre, les bords sont signÃ©s avec un type particulier de relation syntaxique.  Dans la grammaire des dÃ©pendances, non seulement le fait de la connexion entre les mots est analysÃ©, mais aussi la nature de cette connexion.  Par exemple, Â«est prisÂ» est presque une forme verbale, Â«inventaireÂ» est le sujet de Â«est prisÂ».  Par consÃ©quent, nous avons un bord Â«estÂ» dans un sens et dans l'autre.  Ce ne sont pas les mÃªmes connexions, elles sont de nature diffÃ©rente, il faut donc les distinguer. <br><br>  Ci-aprÃ¨s, nous considÃ©rons des cas simples oÃ¹ des membres d'une peine sont prÃ©sents, non implicites.  Il existe des structures et des marques pour gÃ©rer les passes.  Quelque chose apparaÃ®t dans l'arbre qui n'a pas d'expression superficielle - un mot.  Mais c'est le sujet d'une autre Ã©tude, mais nous devons encore nous concentrer sur la nÃ´tre. <br><br><h3>  Projet des dÃ©pendances universelles </h3><br>  Pour faciliter le choix d'un analyseur, nous avons tournÃ© notre attention vers le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Universal Dependencies</a> et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">concours CoNLL Shared Task</a> , qui a rÃ©cemment eu lieu dans son cadre. <br><br>  Universal Dependencies est un projet visant Ã  unifier le balisage des corpus syntaxiques (tribanks) dans le cadre de la grammaire des dÃ©pendances.  En russe, le nombre de types de liens syntaxiques est limitÃ© - sujet, prÃ©dicat, etc.  En anglais pareil, mais l'ensemble est dÃ©jÃ  diffÃ©rent.  Par exemple, un article y apparaÃ®t qui doit Ã©galement Ãªtre Ã©tiquetÃ© d'une maniÃ¨re ou d'une autre.  Si nous voulions Ã©crire un analyseur magique capable de gÃ©rer toutes les langues, nous rencontrerions rapidement des problÃ¨mes de comparaison de diffÃ©rentes grammaires.  Les crÃ©ateurs hÃ©roÃ¯ques des dÃ©pendances universelles ont rÃ©ussi Ã  s'entendre entre eux et Ã  dÃ©limiter tous les bÃ¢timents qui Ã©taient Ã  leur disposition dans un format unique.  Peu importe la faÃ§on dont ils se sont mis d'accord, l'essentiel est qu'Ã  la sortie, nous avons obtenu un certain format uniforme pour prÃ©senter toute cette histoire - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus de 100 tribanks pour 60 langues</a> . <br><br>  CoNLL Shared Task est une compÃ©tition entre dÃ©veloppeurs d'algorithmes d'analyse, organisÃ©e dans le cadre du projet Universal Dependencies.  Les organisateurs prennent un certain nombre de tribanks et les dÃ©composent en trois parties: formation, validation et test.  La premiÃ¨re partie est fournie aux participants du concours afin qu'ils y forment leurs modÃ¨les.  La deuxiÃ¨me partie est Ã©galement utilisÃ©e par les participants pour Ã©valuer le fonctionnement de l'algorithme aprÃ¨s la formation.  Les participants peuvent rÃ©pÃ©ter la formation et l'Ã©valuation de maniÃ¨re itÃ©rative.  Ensuite, ils donnent leur meilleur algorithme aux organisateurs, qui l'exÃ©cutent sur la partie test, fermÃ©e aux participants.  Les rÃ©sultats des modÃ¨les sur les piÃ¨ces d'essai des tribanks sont les rÃ©sultats de la compÃ©tition. <br><br><h3>  Mesures de qualitÃ© </h3><br>  Nous avons des liens entre les mots et leurs types.  Nous pouvons Ã©valuer si le mot top est correctement trouvÃ© - la mÃ©trique UAS (Unlabeled attachment score).  Ou pour Ã©valuer si le sommet et le type de dÃ©pendance sont trouvÃ©s correctement - la mÃ©trique LAS (Labeled attachment score). <br><br><img src="https://habrastorage.org/webt/zb/q5/ic/zbq5icc6mgwabmeryltcbgnp8g4.png"><br><br>  Il semblerait qu'une Ã©valuation de l'exactitude s'impose ici - nous considÃ©rons combien de fois nous avons obtenu du nombre total de cas.  Si nous avons 5 mots et pour 4 nous avons correctement dÃ©terminÃ© le sommet, nous obtenons 80%. <br><br>  Mais en rÃ©alitÃ©, Ã©valuer l'analyseur dans sa forme pure est problÃ©matique.  Les dÃ©veloppeurs qui rÃ©solvent les problÃ¨mes de l'analyse automatique prennent souvent du texte brut en entrÃ©e qui, conformÃ©ment Ã  la pyramide d'analyse, passe par les Ã©tapes de la tokenisation et de l'analyse morphologique.  Les erreurs de ces Ã©tapes prÃ©cÃ©dentes peuvent affecter la qualitÃ© de l'analyseur.  En particulier, cela s'applique Ã  la procÃ©dure de tokenisation - attribution de mots.  Si nous avons identifiÃ© les mauvais mots d'unitÃ©, nous ne serons plus en mesure d'Ã©valuer correctement les relations syntaxiques entre eux - aprÃ¨s tout, dans notre corps d'origine Ã©tiquetÃ©, les unitÃ©s Ã©taient diffÃ©rentes. <br><br>  Par consÃ©quent, la formule d'Ã©valuation dans ce cas est la f-mesure, oÃ¹ la prÃ©cision est la part des hits prÃ©cis par rapport au nombre total de prÃ©dictions, et l'exhaustivitÃ© est la part des hits prÃ©cis par rapport au nombre de liens dans les donnÃ©es balisÃ©es. <br><br>  Lorsque nous donnerons des estimations Ã  l'avenir, nous devons nous rappeler que les mÃ©triques utilisÃ©es affectent non seulement la syntaxe, mais Ã©galement la qualitÃ© de la tokenisation. <br><br><h3>  La langue russe aux dÃ©pendances universelles </h3><br>  Pour que l'analyseur puisse marquer syntaxiquement des phrases qu'il n'a pas encore vues, il doit alimenter le corpus balisÃ© pour la formation.  Pour la langue russe, il existe plusieurs cas de ce type: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/839/f92/0bf/839f920bffbfaf4efc0d054ee4804f0d.png"><br><br>  La deuxiÃ¨me colonne indique le nombre de jetons - mots.  Plus il y a de jetons, plus le corps d'entraÃ®nement est grand et meilleur est l'algorithme final (s'il s'agit de bonnes donnÃ©es).  De toute Ã©vidence, toutes les expÃ©riences sont menÃ©es sur SynTagRus (dÃ©veloppÃ© par IPPI RAS), dans lequel il y a plus d'un million de jetons.  Tous les algorithmes y seront entraÃ®nÃ©s, ce qui sera discutÃ© plus tard. <br><br><h3>  Analyseurs du russe dans la tÃ¢che partagÃ©e CoNLL </h3><br>  Selon les rÃ©sultats du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">concours de</a> l'annÃ©e derniÃ¨re, les modÃ¨les formÃ©s sur le mÃªme SynTagRus ont atteint les indicateurs LAS suivants: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ded/ab4/27e/dedab427eef589c4bf8e3c24475632f7.png"><br><br>  Les rÃ©sultats des analyseurs pour le russe sont impressionnants - ils sont meilleurs que ceux des analyseurs pour l'anglais, le franÃ§ais et d'autres langues plus rares.  Nous avons eu beaucoup de chance pour deux raisons Ã  la fois.  PremiÃ¨rement, les algorithmes font un bon travail avec la langue russe.  DeuxiÃ¨mement, nous avons SynTagRus - un grand logement marquÃ©. <br><br>  Soit dit en passant, la compÃ©tition de 2018 est dÃ©jÃ  passÃ©e, mais nous avons menÃ© nos recherches au printemps de cette annÃ©e, nous nous appuyons donc sur les rÃ©sultats de la piste de l'annÃ©e derniÃ¨re.  Pour l'avenir, nous notons que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nouvelle version d'UDPipe</a> (Future) s'est avÃ©rÃ©e encore plus Ã©levÃ©e cette annÃ©e. <br><br>  Syntaxnet, un analyseur Google, n'est pas sur la liste.  Qu'est-ce qui ne va pas avec lui?  La rÃ©ponse est simple: Syntaxnet n'a commencÃ© qu'au stade de l'analyse morphologique.  Il a pris une tokenisation idÃ©ale prÃªte Ã  l'emploi et a dÃ©jÃ  construit un traitement par-dessus.  Par consÃ©quent, il est injuste de l'Ã©valuer sur un pied d'Ã©galitÃ© avec les autres - les autres ont effectuÃ© la division en jetons avec leurs propres algorithmes, ce qui pourrait aggraver les rÃ©sultats Ã  l'Ã©tape suivante de la syntaxe.  L'Ã©chantillon 2017 de Syntaxnet a un meilleur rÃ©sultat que la liste complÃ¨te ci-dessus, mais les comparaisons directes ne sont pas justes. <br><br>  Le tableau a obtenu deux versions de UDPipe, Ã  12 et 15 places.  Les mÃªmes personnes qui ont participÃ© activement au projet des dÃ©pendances universelles dÃ©veloppent ce parseur. <br><br>  Des mises Ã  jour UDPipe apparaissent pÃ©riodiquement (un peu moins souvent, d'ailleurs, la disposition des cas est Ã©galement mise Ã  jour).  Ainsi, aprÃ¨s le concours de l'annÃ©e derniÃ¨re, UDPipe a Ã©tÃ© mis Ã  jour (il s'agissait de validations pour la version 2.0 non encore publiÃ©es; Ã  l'avenir, pour plus de simplicitÃ©, nous ferons rÃ©fÃ©rence Ã  peu prÃ¨s au commit UDPipe 2.0 que nous avons pris, bien que ce ne soit pas le cas Ã  proprement parler);  Bien sÃ»r, il n'y a pas de telles mises Ã  jour dans la table de compÃ©tition.  Le rÃ©sultat de Â«notreÂ» engagement est approximativement Ã  la septiÃ¨me place. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/262/c42/635/262c42635f1f93cdfd690418208f79fe.png"><br><br>  Donc, nous devons choisir un analyseur pour la langue russe.  Comme donnÃ©es initiales, nous avons la plaque ci-dessus avec le Syntaxnet leader et avec UDPipe 2.0 quelque part Ã  la 7Ã¨me place. <br><br><h2>  Choisissez un modÃ¨le </h2><br>  Nous simplifions les choses: nous commenÃ§ons par l'analyseur avec les taux les plus Ã©levÃ©s.  Si quelque chose ne va pas avec lui, allez ci-dessous.  Quelque chose ne va peut-Ãªtre pas selon les critÃ¨res suivants - peut-Ãªtre qu'ils ne sont pas parfaits, mais ils nous sont parvenus: <br><br><ul><li>  <b>Vitesse de travail</b> .  Notre analyseur devrait fonctionner assez rapidement.  La syntaxe, bien sÃ»r, est loin d'Ãªtre le seul module "sous le capot" d'un systÃ¨me en temps rÃ©el, vous ne devez donc pas y consacrer plus d'une dizaine de millisecondes. <br></li><li>  <b>La qualitÃ© du travail</b> .  Au minimum, l'analyseur lui-mÃªme est basÃ© sur des donnÃ©es en russe.  L'exigence est Ã©vidente.  Pour la langue russe, nous avons de trÃ¨s bons analyseurs morphologiques qui peuvent Ãªtre intÃ©grÃ©s dans notre pyramide.  Si nous pouvons nous assurer que l'analyseur lui-mÃªme fonctionne bien sans morphologie, alors cela nous conviendra - nous glisserons la morphologie plus tard. <br></li><li>  <b>DisponibilitÃ© d'un code de formation et de prÃ©fÃ©rence d'un modÃ¨le dans le domaine public</b> .  Si nous avons un code de formation, nous pourrons rÃ©pÃ©ter les rÃ©sultats de l'auteur du modÃ¨le.  Pour ce faire, ils doivent Ãªtre ouverts.  Et, en outre, nous devons surveiller attentivement les conditions de distribution des cas et des modÃ¨les - devrons-nous acheter une licence pour les utiliser, si nous les utilisons dans le cadre de nos algorithmes? <br></li><li>  <b>Lancez sans effort supplÃ©mentaire</b> .  Cet article est trÃ¨s subjectif, mais important.  Qu'est-ce que cela signifie?  Cela signifie que si nous nous asseyons pendant trois jours et commenÃ§ons quelque chose, mais que cela ne dÃ©marre pas, nous ne pourrons pas sÃ©lectionner cet analyseur, mÃªme s'il sera de qualitÃ© parfaite. <br></li></ul><br>  Tout ce qui Ã©tait supÃ©rieur Ã  UDPipe 2.0 sur le graphique de l'analyseur ne nous convenait pas.  Nous avons un projet Python, et certains analyseurs de la liste ne sont pas Ã©crits en Python.  Pour les implÃ©menter dans le projet Python, il faudrait appliquer les trÃ¨s gros efforts.  Dans d'autres cas, nous avons Ã©tÃ© confrontÃ©s Ã  des codes source fermÃ©s, des dÃ©veloppements acadÃ©miques et industriels - en gÃ©nÃ©ral, vous n'allez pas au fond. <br><br>  Star Syntaxnet mÃ©rite une histoire distincte sur la qualitÃ© du travail.  Ici, il ne nous convenait pas pour la rapiditÃ© du travail.  Le temps de sa rÃ©ponse Ã  quelques phrases simples courantes dans les chats est de 100 millisecondes.  Si nous dÃ©pensons autant en syntaxe, nous n'avons pas assez de temps pour autre chose.  Dans le mÃªme temps, UDPipe 2.0 effectue une analyse pendant environ 3 ms.  En consÃ©quence, le choix s'est portÃ© sur UDPipe 2.0. <br><br><h2>  UDPipe 2.0 </h2><br>  UDPipe est un pipeline qui apprend la tokenisation, la lemmatisation, le marquage morphologique et l'analyse grammaticale des dÃ©pendances.  Nous pouvons lui apprendre tout cela ou quelque chose sÃ©parÃ©ment.  Par exemple, faites avec lui un autre analyseur morphologique pour la langue russe.  Ou entraÃ®nez-vous et utilisez UDPipe comme tokenizer. <br><br>  UDPipe 2.0 est documentÃ© en dÃ©tail.  Il y a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">description de l'architecture</a> , un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rÃ©fÃ©rentiel avec un code de formation</a> , un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel</a> .  Le plus intÃ©ressant est les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modÃ¨les prÃªts Ã </a> l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">emploi</a> , y compris pour la langue russe.  TÃ©lÃ©chargez et exÃ©cutez.  Ã‰galement sur cette ressource, les paramÃ¨tres de formation sÃ©lectionnÃ©s pour chaque corpus linguistique ont Ã©tÃ© publiÃ©s.  Pour chacun de ces modÃ¨les, environ 60 paramÃ¨tres de formation sont nÃ©cessaires, et avec leur aide, vous pouvez obtenir indÃ©pendamment les mÃªmes indicateurs de qualitÃ© que dans le tableau.  Ils ne sont peut-Ãªtre pas optimaux, mais au moins nous pouvons Ãªtre sÃ»rs que le pipeline fonctionnera correctement.  De plus, la prÃ©sence d'une telle rÃ©fÃ©rence nous permet d'expÃ©rimenter sereinement le modÃ¨le par nous-mÃªmes. <br><br><h3>  Fonctionnement d'UDPipe 2.0 </h3><br>  Tout d'abord, le texte est divisÃ© en phrases et les phrases en mots.  UDPipe fait tout cela Ã  la fois Ã  l'aide d'un module commun - un rÃ©seau de neurones (GRU double couche monocouche), qui pour chaque caractÃ¨re prÃ©dit s'il est le dernier d'une phrase ou d'un mot. <br><br>  Ensuite, le tagueur commence Ã  travailler - une chose qui prÃ©dit les propriÃ©tÃ©s morphologiques du jeton: dans ce cas, le mot est, dans quel numÃ©ro.  Sur la base des quatre derniers caractÃ¨res de chaque mot, un tagueur gÃ©nÃ¨re des hypothÃ¨ses concernant une partie de la parole et des balises morphologiques de ce mot, puis Ã  l'aide d'un perceptron sÃ©lectionne la meilleure option. <br><br>  UDPipe dispose Ã©galement d'un lemmatiseur qui sÃ©lectionne la forme initiale des mots.  Il apprend le mÃªme principe par lequel un locuteur non natif pourrait essayer de dÃ©terminer le lemme d'un mot inconnu.  Nous coupons le prÃ©fixe et la fin du mot, ajoutons du Â«tÂ», qui est prÃ©sent dans la forme initiale du verbe, etc.  Ainsi, les candidats sont gÃ©nÃ©rÃ©s, Ã  partir desquels le meilleur perceptron choisit. <br><br>  Le schÃ©ma de marquage morphologique (dÃ©termination du nombre, du cas et de tout le reste) et les prÃ©dictions des lemmes sont trÃ¨s similaires.  Ils peuvent Ãªtre prÃ©dits ensemble, mais mieux sÃ©parÃ©ment - la morphologie de la langue russe est trop riche.  Vous pouvez Ã©galement connecter votre liste de lemmes. <br><br>  Passons Ã  la partie la plus intÃ©ressante - l'analyseur.  Il existe plusieurs architectures d'analyseur de dÃ©pendance.  UDPipe est une architecture basÃ©e sur la transition: elle fonctionne rapidement, en traversant tous les jetons une fois dans un temps linÃ©aire. <br><br>  L'analyse syntaxique dans une telle architecture commence par une pile (oÃ¹ au dÃ©but il n'y a que root) et une configuration vide.  Il existe trois mÃ©thodes par dÃ©faut pour le modifier: <br><br><ul><li>  LeftArc - applicable si le deuxiÃ¨me Ã©lÃ©ment de la pile n'est pas root.  Il conserve la relation entre le jeton en haut de la pile et le deuxiÃ¨me jeton, et Ã©jecte Ã©galement le second de la pile. <br></li><li>  RightArc est le mÃªme, mais la dÃ©pendance est construite dans l'autre sens et la pointe est ignorÃ©e. <br></li><li>  Shift - transfÃ¨re le mot suivant du tampon vers la pile. <br></li></ul><br>  Voici un exemple de l'analyseur ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source</a> ).  Nous avons la phrase Â«rÃ©servez-moi le vol du matinÂ» et nous nous y reconnectons: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/196/b17/845/196b17845e524d75a878837b25325a76.png"><br><br>  Voici le rÃ©sultat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/686/c78/066/686c780661b296250d53cba054317a18.png"><br><br>  L'analyseur classique basÃ© sur la transition a les trois opÃ©rations Ã©numÃ©rÃ©es ci-dessus: flÃ¨che unidirectionnelle, flÃ¨che unidirectionnelle et dÃ©calage.  Il existe Ã©galement une opÃ©ration Swap, dans les architectures de base basÃ©es sur la transition, elle n'est pas utilisÃ©e, mais elle est incluse dans UDPipe.  Swap renvoie le deuxiÃ¨me Ã©lÃ©ment de la pile dans le tampon pour prendre le suivant dans le tampon (s'ils sont espacÃ©s).  Cela permet de sauter quelques mots et de rÃ©tablir la connexion correcte. <br><br>  Il y a un bon article du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien de la</a> personne qui a proposÃ© l'opÃ©ration de swap.  Nous allons souligner un point: malgrÃ© le fait que nous passions plusieurs fois par le tampon de jeton initial (c'est-Ã -dire que notre temps n'est plus linÃ©aire), ces opÃ©rations peuvent Ãªtre optimisÃ©es de sorte que le temps soit retournÃ© trÃ¨s prÃ¨s de linÃ©aire.  Autrement dit, devant nous n'est pas seulement une opÃ©ration significative du point de vue de la langue, mais aussi un outil qui ne ralentit pas beaucoup le travail de l'analyseur. <br><br>  En utilisant l'exemple ci-dessus, nous avons montrÃ© les opÃ©rations, Ã  la suite desquelles nous obtenons une configuration - le tampon de jeton et les connexions entre eux.  Nous donnons cette configuration Ã  l'Ã©tape actuelle Ã  l'analyseur basÃ© sur la transition, et avec lui, il devrait prÃ©dire la configuration Ã  l'Ã©tape suivante.  En comparant les vecteurs d'entrÃ©e et les configurations Ã  chaque Ã©tape, le modÃ¨le est formÃ©. <br><br>  Nous avons donc sÃ©lectionnÃ© un analyseur qui correspond Ã  tous nos critÃ¨res et avons mÃªme compris comment cela fonctionne.  Nous procÃ©dons aux expÃ©riences. <br><br><h3>  ProblÃ¨mes UDPipe </h3><br>  Demandons une petite phrase: "TransfÃ©rer cent roubles Ã  maman".  Le rÃ©sultat vous fait saisir la tÃªte. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9cb/948/1f2/9cb9481f2e06b366fbee26f0835d31b0.png"><br><br>  Â«TraduireÂ» s'est avÃ©rÃ© Ãªtre une excuse, mais c'est tout Ã  fait logique.  Nous dÃ©terminons la grammaire de la forme verbale par les quatre derniers caractÃ¨res.  "Plomb" est quelque chose comme "au milieu", donc le choix est relativement logique.  C'est plus intÃ©ressant avec "maman": "maman" Ã©tait dans le cas prÃ©positionnel et est devenu le summum de cette phrase. <br><br>  Si nous essayons d'interprÃ©ter tout sur la base des rÃ©sultats de l'analyse, nous obtiendrions quelque chose comme "au milieu d'une maman (dont la maman? Qui est cette maman?) Des centaines de roubles."  Pas tout Ã  fait ce que c'Ã©tait au dÃ©but.  Nous devons en quelque sorte faire face Ã  cela.  Et nous avons trouvÃ© comment. <br><br>  Dans la pyramide d'analyse, la syntaxe est construite au-dessus de la morphologie, basÃ©e sur des balises morphologiques.  Voici un exemple de manuel d'un linguiste L.V.  Shcherby Ã  cet Ã©gard: <br><br>  <i>"Gloky cuzdra shteko budlanula bokra et petit garÃ§on aux cheveux bouclÃ©s."</i> <br><br>  L'analyse de cette proposition ne pose pas de problÃ¨me.  Pourquoi?  Parce que nous, en tant que tagueur UDPipe, regardons la fin d'un mot et comprenons Ã  quelle partie du discours il fait rÃ©fÃ©rence et de quelle forme il s'agit.  L'histoire avec Â«traduireÂ» comme excuse contredit complÃ¨tement notre intuition, mais elle s'avÃ¨re logique au moment oÃ¹ nous essayons de faire de mÃªme avec des mots inconnus.  Une personne pourrait penser de la mÃªme faÃ§on. <br><br>  Nous Ã©valuerons le tagueur UDPipe sÃ©parÃ©ment.  Si cela ne nous convient pas, nous prendrons un autre tagueur - puis pour construire l'analyse syntaxique sur un autre balisage morphologique. <br><br>  <i>Balisage Ã  partir de texte brut (score CoNLL17 F1)</i> <br><br><ul><li>  <i>formes d'or: 301639</i> , <br></li><li>  <i>upostag: 98,15%</i> , <br></li><li>  <i>xpostag: 99,89%</i> , <br></li><li>  <b><i>exploits: 93,97%</i></b> , <br></li><li>  <b><i>alltags: 93,44%</i></b> , <br></li><li>  <b><i>lemmes: 96,68%</i></b> <br></li></ul><br>  La qualitÃ© morphologique de UDPipe 2.0 n'est pas mauvaise.  Mais pour la langue russe, c'est mieux.  L'analyseur Mystem (le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dÃ©veloppement de Yandex</a> ) obtient de meilleurs rÃ©sultats dans la dÃ©termination des parties de la parole que UDPipe.  De plus, d'autres analyseurs sont plus difficiles Ã  implÃ©menter dans un projet python, et ils fonctionnent plus lentement avec une qualitÃ© comparable Ã  Mystem. ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br>              UDPipe.   .  ,  Mystem     .  ,    Â«  Â»  Â«Â» â€”   Â«Â»,    Â«Â».    .   ,     Â«Â»,     (),  ,    .   : <br><br><ul><li> Â« Â» â€”     <br></li><li> Â«  Â» â€” ..     <br></li><li> Â« - Â» â€”     (-     ) <br></li></ul><br>  Dans de tels cas, Mystem donne honnÃªtement Ã  toute la chaÃ®ne: <br><br> <code>m.analyze(" ") <br> [{'analysis': [{'lex': '', 'gr': 'PART='}], 'text': ''}, <br> {'text': ' '}, <br> {'analysis': [{'lex': '', 'gr': 'S,,=(,|,|,)'}], <br> 'text': ''}, <br> {'text': '\n'}] <br></code> <br>  Mais nous ne pouvons pas envoyer toute la chaÃ®ne de tuyaux Ã  UDPipe, mais nous devons spÃ©cifier une meilleure balise.  Comment le choisir?  Si vous ne touchez Ã  rien, je veux prendre le premier, Ã§a marchera peut-Ãªtre.  Mais les balises sont triÃ©es alphabÃ©tiquement en fonction des noms anglais, donc notre choix sera proche de l'alÃ©atoire, et certaines analyses perdent presque la chance d'Ãªtre les premiÃ¨res. <br><br>  Il y a un analyseur qui peut donner la meilleure option - Pymorphy2.  Mais avec une analyse de la morphologie, il est pire.  De plus, il donne le meilleur mot hors contexte.  Pymorphy2 ne donnera qu'une seule analyse pour "pas de rÃ©alisateur", "voir rÃ©alisateur" et "rÃ©alisateur".  Ce ne sera pas alÃ©atoire, mais vraiment le meilleur en probabilitÃ©, qui en pymorphie2 Ã©tait considÃ©rÃ© sur un corps sÃ©parÃ© de textes.  Mais un certain pourcentage dâ€™analyses incorrectes des textes de combat sera garanti, tout simplement parce quâ€™elles peuvent contenir des phrases aux formes rÃ©elles diffÃ©rentes: Â«Je vois le rÃ©alisateurÂ» et Â«les rÃ©alisateurs sont venus Ã  la rÃ©unionÂ» et Â«il nâ€™y a pas de rÃ©alisateurÂ».  Une probabilitÃ© d'analyse contextuelle ne nous convient pas. <br><br>  Comment obtenir contextuellement le meilleur ensemble de balises?  Utilisation de l'analyseur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RNNMorph</a> .  Peu de gens ont entendu parler de lui, mais l'annÃ©e derniÃ¨re, il a remportÃ© le concours des analyseurs morphologiques, organisÃ© dans le cadre de la confÃ©rence Dialogue. <br><br>  RNNMorph a son propre problÃ¨me: il n'a pas de tokenisation.  Si Mystem peut symboliser du texte brut, alors RNNMorph requiert une liste de jetons Ã  l'entrÃ©e.  Pour arriver Ã  la syntaxe, vous devrez d'abord utiliser un tokenizer externe, puis donner le rÃ©sultat Ã  RNNMorph et ensuite seulement nourrir la morphologie rÃ©sultante Ã  l'analyseur syntaxique. <br><br>  Voici les options que nous avons.  Nous ne refuserons pas pour l'instant l'analyse sans contexte de pymorphy2 sur des cas discutables dans le MystÃ¨me - du coup, elle ne sera pas loin derriÃ¨re RNNMorph.  Bien que si nous les comparons uniquement au niveau de la qualitÃ© du balisage morphologique (donnÃ©es de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MorphoRuEval-2017</a> ), la perte est importante - environ 15%, si nous prenons la prÃ©cision selon les mots. <br>  Ensuite, nous devons convertir la sortie de Mystem au format que UDPipe comprend - conllu.  Et encore une fois, c'est un problÃ¨me, mÃªme jusqu'Ã  deux.  Purement technique - les lignes ne correspondent pas.  Et conceptuel - il n'est pas toujours clair de savoir comment les comparer.  Face Ã  deux balises diffÃ©rentes de donnÃ©es de langage, vous rencontrerez trÃ¨s certainement le problÃ¨me de la correspondance des balises, voir les exemples ci-dessous.  Les rÃ©ponses Ã  la question Â«quelle balise se trouve iciÂ» peuvent Ãªtre diffÃ©rentes, et probablement la bonne rÃ©ponse dÃ©pend de la tÃ¢che.  En raison de cette incohÃ©rence, l'appariement des systÃ¨mes de balisage n'est pas une tÃ¢che facile en soi. <br><br>  Comment convertir?  Il existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">russian_tagsets</a> _ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package</a> - un package pour Python qui peut convertir diffÃ©rents formats.  Il n'y a pas de traduction du format d'Ã©mission de Mystem vers Conllu, qui est acceptÃ© dans les dÃ©pendances universelles, mais il y a une traduction vers conllu, par exemple, du format de balisage du corpus national de la langue russe (et vice versa).  L'auteur du paquet (d'ailleurs, il est l'auteur de pymorphy2) a Ã©crit une chose merveilleuse directement dans la documentation: "Si vous ne pouvez pas utiliser ce paquet, ne l'utilisez pas."  Il ne l'a pas fait parce que le programmeur krivorukov (c'est un excellent programmeur!), Mais parce que si vous avez besoin de vous convertir l'un Ã  l'autre, vous risquez de rencontrer des problÃ¨mes en raison de l'incohÃ©rence linguistique des conventions de balisage. <br><br>  Voici un exemple.  L'Ã©cole a appris la "catÃ©gorie de condition" (froid, nÃ©cessaire).  Certains disent que c'est un adverbe, d'autres disent un adjectif.  Vous devez convertir cela, et vous ajoutez quelques rÃ¨gles, mais ne rÃ©alisez toujours pas une correspondance sans ambiguÃ¯tÃ© entre un format et un autre. <br><br>  Un autre exemple: un engagement (soit quelqu'un a fait quelque chose ou a fait quelque chose avec quelqu'un).  "Petya a tuÃ© quelqu'un" ou "Petya a Ã©tÃ© tuÃ©".  Â«Vasya prend des photosÂ» - Â«Vasya prend des photosÂ» (c'est-Ã -dire, en fait, Â«Vasya est photographiÃ©eÂ»).  Il y a aussi une garantie mÃ©diale dans SynTagRus - nous ne creuserons mÃªme pas ce que c'est et pourquoi.  Mais dans Mystem, ce n'est pas le cas.  Si vous devez en quelque sorte amener un format Ã  un autre, c'est une impasse. <br><br>  Nous avons plus ou moins honnÃªtement suivi l'avis de l'auteur du paquet russian_tagsets - n'avons pas utilisÃ© son dÃ©veloppement, car nous n'avons pas trouvÃ© la paire requise dans la liste des formats de correspondance.  En consÃ©quence, nous avons Ã©crit notre convertisseur personnalisÃ© de Mystem en Conllu et avons continuÃ©. <br><br><h3>  Nous connectons le tagueur tiers et l'analyseur UDPipe </h3><br>  AprÃ¨s toutes les aventures, nous avons pris trois algorithmes, dÃ©crits ci-dessus: <br><br><ul><li>  UDPipe de base <br></li><li>  Mym avec dÃ©sambiguÃ¯sation d'Ã©tiquette de pymorphy2 <br></li><li>  RNNMorph <br></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7a/6e8/acb/c7a6e8acba5759723b585121d296b4e5.png"><br><br>  Nous avons perdu de la qualitÃ© pour une raison assez Ã©vidente.  Nous avons pris le modÃ¨le UDPipe formÃ© sur une morphologie, mais avons glissÃ© une autre morphologie sur une entrÃ©e.  Le problÃ¨me classique de l'inadÃ©quation des donnÃ©es entre le train et le test est le rÃ©sultat d'une baisse de qualitÃ©. <br><br>  Nous avons essayÃ© d'aligner nos outils de marquage morphologique automatique avec le balisage SynTagRus, qui a Ã©tÃ© marquÃ© manuellement.  Nous n'avons pas rÃ©ussi, donc, dans le cas de la formation SynTagRus, nous remplacerons tous les marquages â€‹â€‹morphologiques manuels par ceux obtenus Ã  partir de Mystem et de pymorphy2 dans un cas et de RNNMorph dans un autre.  Dans un cas validÃ© balisÃ© Ã  la main, nous sommes obligÃ©s de changer le marquage manuel en automatique, car Â«au combatÂ» nous n'obtiendrons jamais de marquage manuel. <br><br>  En consÃ©quence, nous avons formÃ© l'analyseur UDPipe (uniquement l'analyseur) avec les mÃªmes hyperparamÃ¨tres que la ligne de base.  Ce qui Ã©tait responsable de la syntaxe - l'ID de sommet, dont dÃ©pend le type de connexion - nous sommes partis, nous avons tout changÃ©. <br><br><h2>  RÃ©sultats </h2><br>  De plus, je vais nous comparer avec Syntaxnet et d'autres algorithmes.  Les organisateurs de la tÃ¢che partagÃ©e CoNLL ont dÃ©voilÃ© la partition SynTagRus (train / dev / test 80/10/10).  Nous en avons initialement pris un autre (train / test 70/30), donc les donnÃ©es ne coÃ¯ncident pas toujours avec nous, bien qu'elles aient Ã©tÃ© reÃ§ues sur le mÃªme cas.  De plus, nous avons pris la derniÃ¨re version (de fÃ©vrier Ã  mars) du rÃ©fÃ©rentiel SynTagRus - cette version est lÃ©gÃ¨rement diffÃ©rente de celle de la compÃ©tition.  Les donnÃ©es pour ce qui n'a pas dÃ©collÃ© sont donnÃ©es dans des articles oÃ¹ la rÃ©partition Ã©tait la mÃªme que dans la compÃ©tition - ces algorithmes sont marquÃ©s d'un astÃ©risque dans le tableau. <br><br>  Voici les rÃ©sultats finaux: <br><img src="https://habrastorage.org/getpro/habr/post_images/f80/3ac/3ce/f803ac3ce0068974e855a050ebddc61b.png"><br><br>  RNNMorph s'est avÃ©rÃ© vraiment meilleur - non pas dans le sens absolu, mais dans le rÃ´le d'un outil auxiliaire pour obtenir une mÃ©trique commune en fonction des rÃ©sultats de l'analyse (par rapport Ã  Mystem + pymorphy2).  Autrement dit, meilleure est la morphologie, meilleure est la syntaxe, mais la sÃ©paration "syntaxique" est beaucoup moins importante que la sÃ©paration morphologique.  Notez Ã©galement que nous ne sommes pas allÃ©s trÃ¨s loin du modÃ¨le de rÃ©fÃ©rence, ce qui signifie qu'en morphologie, il n'y en avait vraiment pas autant que prÃ©vu. <br><br>  Je me demande combien de mensonges sur la morphologie?  Est-il possible d'obtenir une amÃ©lioration fondamentale de l'analyseur syntaxique grÃ¢ce Ã  une morphologie idÃ©ale?  Pour rÃ©pondre Ã  cette question, nous avons conduit UDPipe 2.0 sur la tokenisation et la morphologie qui Ã©taient parfaitement calibrÃ©es (en utilisant la norme de balisage manuel standard).  Nous avons obtenu une certaine marge (voir la ligne sur Gold Morph dans le tableau; il s'avÃ¨re que + 1,54% de RNNMorph_reannotated_syntax) de ce que nous avions, y compris du point de vue de dÃ©terminer correctement le type de connexion.  Si quelqu'un Ã©crit un analyseur morphologique absolument parfait de la langue russe, il est probable que les rÃ©sultats que nous obtenons en utilisant un analyseur syntaxique abstrait augmenteront Ã©galement.  Et nous comprenons approximativement le plafond (au moins le plafond de cette architecture et de la combinaison de paramÃ¨tres que nous avons utilisÃ©s pour UDPipe - il est indiquÃ© dans la troisiÃ¨me ligne du tableau ci-dessus). <br><br>  Fait intÃ©ressant, nous avons presque atteint la version Syntaxnet dans la mÃ©trique LAS.  Il est clair que nous avons des donnÃ©es lÃ©gÃ¨rement diffÃ©rentes, mais en principe, elles sont toujours comparables.  La tokenisation Syntaxnet est "or", et pour nous - de Mystem.  Nous avons Ã©crit le wrapper susmentionnÃ© dans Mystem, mais l'analyse se fait toujours automatiquement;  Mystem se trompe probablement aussi quelque part.  Ã€ partir de la ligne du tableau Â«Jeton d'or UDPipe 2.0Â», on peut voir que si vous prenez le jeton UDPipe et or par dÃ©faut, il perd encore un peu Syntaxnet-2017.  Mais cela fonctionne beaucoup plus rapidement. <br><br>  Ce que personne n'a atteint, c'est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'analyseur de Stanford</a> .  Il est conÃ§u de la mÃªme maniÃ¨re que Syntaxnet, il fonctionne donc longtemps.  Dans UDPipe, nous suivons simplement la pile.  L'architecture de l'analyseur Stanford et de Syntaxnet a un concept diffÃ©rent: ils gÃ©nÃ¨rent d'abord un graphe orientÃ© complet, puis l'algorithme fonctionne pour laisser le squelette (arbre couvrant minimal) qui sera le plus probable.  Pour ce faire, il passe par des combinaisons, et cette recherche n'est plus linÃ©aire, car vous vous tournerez vers un mot plus d'une fois.  MalgrÃ© le fait que depuis longtemps, du point de vue de la science pure, au moins pour la langue russe, c'est une architecture plus efficace.  Nous avons essayÃ© de soulever ce dÃ©veloppement acadÃ©mique pendant deux jours - hÃ©las, cela n'a pas fonctionnÃ©.  Mais sur la base de son architecture, il est clair qu'il ne fonctionne pas rapidement. <br><br>  Quant Ã  notre approche - bien que nous n'ayons pratiquement pas augmentÃ© de maniÃ¨re mÃ©trique, maintenant tout va bien avec la Â«mÃ¨reÂ». <br><br><img src="https://habrastorage.org/getpro/habr/post_images/423/f71/8b2/423f718b24dbb3c0db517fc13c032647.png"><br><br>  Dans la phrase Â«traduire cent roubles Ã  mamanÂ», Â«traduireÂ» est vraiment un verbe d'humeur impÃ©rative.  "Maman" a obtenu son Ã©tui datif.  Et la chose la plus importante pour nous est notre Ã©tiquette (iobj), un objet indirect (destination).  Bien que la croissance en nombre soit nÃ©gligeable, nous avons bien gÃ©rÃ© le problÃ¨me avec lequel la tÃ¢che a commencÃ©. <br><br><h2>  Bonus track: ponctuation </h2><br>  Si nous revenons aux donnÃ©es rÃ©elles, il s'avÃ¨re que la syntaxe dÃ©pend de la ponctuation.  Prenez la phrase Â«vous ne pouvez pas faire misÃ©ricordeÂ».  Ce qui ne peut pas Ãªtre fait exactement - Â«exÃ©cuterÂ» ou Â«avoir pitiÃ©Â» - dÃ©pend de la position de la virgule.  MÃªme si nous mettons le linguiste pour baliser les donnÃ©es, il aura besoin de la ponctuation comme d'une sorte d'outil auxiliaire.  Il ne pouvait pas se passer d'elle. <br><br>  Prenons les phrases Â«Peter bonjourÂ» et Â«Peter bonjourÂ» et regardons leur analyse par le modÃ¨le de base-UDPipe.  On laisse de cÃ´tÃ© les problÃ¨mes qui, selon ce modÃ¨le, alors: <br>  1) "Petya" est un nom fÃ©minin; <br>  2) "Petya" est (Ã  en juger par l'ensemble de balises) la forme initiale, mais en mÃªme temps, son lemme n'est pas censÃ© Ãªtre "Petya". <br><br>  C'est ainsi que le rÃ©sultat change en raison de la virgule, avec son aide, nous obtenons quelque chose de similaire Ã  la vÃ©ritÃ©. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46f/821/773/46f8217734e6e8c0f31e8f7f47d23d7d.png"><br><br>  Dans le second cas, Â«PetyaÂ» est un sujet et Â«bonjourÂ» est un verbe.  Revenons Ã  prÃ©dire la forme d'un mot en fonction des quatre derniers caractÃ¨res.  Dans l'interprÃ©tation de l'algorithme, il ne s'agit pas de Â«salutations PetyaÂ», mais de Â«salutations PetyaÂ».  Tapez "Petya chante" ou "Petya viendra".  L'analyse est tout Ã  fait comprÃ©hensible: en russe, il ne peut pas y avoir de virgule entre le sujet et le prÃ©dicat.  Par consÃ©quent, si la virgule est, c'est le mot "bonjour", et s'il n'y a pas de virgule, cela pourrait bien Ãªtre quelque chose comme "Petya Privet". <br><br>  Nous le rencontrerons assez souvent en production, car les correcteurs orthographiques corrigeront l'orthographe, mais pas la ponctuation.  Pour aggraver les choses, l'utilisateur peut dÃ©finir des virgules de maniÃ¨re incorrecte, et notre algorithme en tiendra compte pour comprendre le langage naturel.  Quelles sont les solutions possibles ici?  Nous voyons deux options. <br><br>  La premiÃ¨re option consiste Ã  faire comme ils le font parfois lors de la traduction de la parole en texte.  Initialement, il n'y a pas de ponctuation dans un tel texte, il est donc restaurÃ© via le modÃ¨le.  La sortie est un matÃ©riau relativement compÃ©tent en termes de rÃ¨gles de la langue russe, ce qui aide l'analyseur syntaxique Ã  fonctionner correctement. <br><br>  La deuxiÃ¨me idÃ©e est quelque peu plus audacieuse et contredit les leÃ§ons scolaires de la langue russe.  Il s'agit de travailler sans ponctuation: si tout Ã  coup l'entrÃ©e est ponctuÃ©e, on la supprimera de lÃ .  Nous supprimerons Ã©galement absolument toute ponctuation du corps d'entraÃ®nement.  Nous supposons que la langue russe existe sans ponctuation.  Seuls les points pour la division en phrases. <br><br>  Techniquement, c'est assez simple, car nous ne modifions pas les nÅ“uds finaux dans l'arbre de syntaxe.  Nous ne pouvons pas avoir tel que le signe de ponctuation soit le haut.  Il s'agit toujours d'un nÅ“ud d'extrÃ©mitÃ©, Ã  l'exception du signe%, qui pour une raison quelconque dans SynTagRus est le sommet du chiffre prÃ©cÃ©dent (50% dans SynTagRus est marquÃ© comme% - sommet et 50 - dÃ©pendant). <br><br>  Testons en utilisant le modÃ¨le Mystem (+ pymorphy 2). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e4/578/1de/4e45781de1ac88426d8e6da786903d8b.png"><br><br>  Il est extrÃªmement important pour nous de ne pas donner le modÃ¨le de texte de ponctuation sans ponctuation.  Mais si nous donnons toujours le texte sans ponctuation, alors nous serons en premiÃ¨re ligne et obtiendrons au moins des rÃ©sultats acceptables.  Si le texte sans ponctuation et le modÃ¨le fonctionnent sans ponctuation, alors en ce qui concerne la ponctuation idÃ©ale et le modÃ¨le de ponctuation, la baisse ne sera que d'environ 3%. <br><br>  Que faire Ã  ce sujet?  Nous pouvons nous attarder sur ces chiffres - obtenus en utilisant le modÃ¨le sans ponctuation et la purification de la ponctuation.  Ou trouvez une sorte de classificateur pour restaurer la ponctuation.  Nous n'atteindrons pas les nombres idÃ©aux (ceux avec ponctuation sur le modÃ¨le de ponctuation), parce que l'algorithme de rÃ©cupÃ©ration de ponctuation fonctionne avec une certaine erreur, et les nombres Â«idÃ©auxÂ» ont Ã©tÃ© calculÃ©s sur SynTagRus absolument pur.  Mais si nous allons Ã©crire un modÃ¨le qui rÃ©tablit la ponctuation, les progrÃ¨s nous rembourseront-ils?  La rÃ©ponse n'est pas encore Ã©vidente. <br><br>  Nous pouvons rÃ©flÃ©chir longtemps Ã  l'architecture de l'analyseur, mais nous devons nous rappeler qu'en fait il n'y a pas de grand corpus syntaxiquement marquÃ© de textes web.  Son existence permettrait de mieux rÃ©soudre les problÃ¨mes rÃ©els.  Jusqu'Ã  prÃ©sent, nous Ã©tudions le corps de textes Ã©ditÃ©s absolument alphabÃ©tisÃ©s - et nous perdons de la qualitÃ© en obtenant des textes personnalisÃ©s au combat, qui sont souvent Ã©crits analphabÃ¨tes. <br><br><h2>  Conclusion </h2><br>  Nous avons examinÃ© l'utilisation de divers algorithmes d'analyse syntaxique basÃ©s sur la grammaire des dÃ©pendances, appliquÃ©s Ã  la langue russe.  Il s'est avÃ©rÃ© qu'en termes de rapiditÃ©, de commoditÃ© et de qualitÃ© de travail, UDPipe s'est avÃ©rÃ© Ãªtre le meilleur outil.  Son modÃ¨le de rÃ©fÃ©rence peut Ãªtre amÃ©liorÃ© si les Ã©tapes de la tokenisation et de l'analyse morphologique sont attribuÃ©es Ã  d'autres analyseurs tiers: cette astuce permet de corriger le comportement incorrect du tagueur et, par consÃ©quent, de l'analyseur dans les cas importants pour l'analyse. <br><br>  Nous avons Ã©galement analysÃ© le problÃ¨me de la relation entre la ponctuation et l'analyse et sommes parvenus Ã  la conclusion que dans notre cas, la ponctuation avant l'analyse syntaxique est prÃ©fÃ©rable de supprimer. <br><br>  Nous espÃ©rons que les points d'application abordÃ©s dans notre article vous aideront Ã  utiliser l'analyse syntaxique pour rÃ©soudre vos problÃ¨mes aussi efficacement que possible. <br><br>  <i>L'auteur remercie Nikita Kuznetsova et Natalya Filippova pour leur aide dans la prÃ©paration de l'article;</i>  <i>pour l'assistance dans l'Ã©tude - Anton Alekseev, Nikita Kuznetsov, Andrei Kutuzov, Boris Orekhov et Mikhail Popov.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418701/">https://habr.com/ru/post/fr418701/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418689/index.html">Comment crÃ©er des bibliothÃ¨ques de composants dans Figma, Ã©conomiser un budget, en utilisant l'exemple d'une vente aux enchÃ¨res en ligne</a></li>
<li><a href="../fr418691/index.html">Rancher: Kubernetes en 5 minutes sur du mÃ©tal nu</a></li>
<li><a href="../fr418693/index.html">Pourquoi le bonheur est-il si difficile Ã  dÃ©tecter dans le cerveau</a></li>
<li><a href="../fr418695/index.html">Anti-Piracy Wars - L'Empire contre-attaque</a></li>
<li><a href="../fr418699/index.html">CrÃ©ation d'une machine d'arcade d'Ã©mulation. 3e partie</a></li>
<li><a href="../fr418705/index.html">Les bases de Futex</a></li>
<li><a href="../fr418707/index.html">KDispatcher - Eventbus lÃ©ger et pratique pour une utilisation quotidienne</a></li>
<li><a href="../fr418709/index.html">Besoin de vous forcer: pilotes et barriÃ¨res d'interface</a></li>
<li><a href="../fr418711/index.html">Registres gÃ©rÃ©s par jeton 1.0</a></li>
<li><a href="../fr418713/index.html">Jeu pour amÃ©liorer la qualitÃ© de Wikipedia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>