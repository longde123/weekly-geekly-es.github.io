<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐘 🏇🏼 ♑️ Menjelajahi format biner menggunakan bytecode file .class sebagai contoh. 👨‍👨‍👧‍👧 ⚕️ 😘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda tidak takut dengan gambar di atas, jika Anda tahu bagaimana big-endian berbeda dari little-endian, jika Anda selalu tertarik pada bagaimana ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menjelajahi format biner menggunakan bytecode file .class sebagai contoh.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481260/"><p><img src="https://habrastorage.org/webt/2-/ht/7w/2-ht7w15prc6owrbxqrljbxmq0g.png" alt="gambar"></p><br><p>  Jika Anda tidak takut dengan gambar di atas, jika Anda tahu bagaimana big-endian berbeda dari little-endian, jika Anda selalu tertarik pada bagaimana file biner "diatur", maka artikel ini adalah untuk ANDA! </p><a name="habracut"></a><br><h1 id="vvedenie">  Pendahuluan </h1><br><p>  Di Habré sudah ada beberapa artikel tentang rekayasa terbalik format biner dan tentang studi struktur bytecode dari file .class: <br>  <a href="https://habr.com/ru/post/222519/">Kelompok konstanta</a> <br>  <a href="https://habr.com/ru/post/111456/">Java Bytecode Fundamentals</a> , <br>  <a href="https://habr.com/ru/post/264919/">Bytecode Java "Halo dunia"</a> , <br>  <a href="https://habr.com/ru/post/480550/">Hello World dari bytecode untuk JVM</a> dll. <br>  Peneliti memiliki tugas untuk berurusan dengan protokol biner yang tidak diketahui atau menggali struktur biner yang ada spesifikasi. </p><br><p>  Ketertarikan saya pada format biner muncul bahkan ketika saya masih mahasiswa dan menulis makalah tentang pengembangan driver sistem file Linux.  Beberapa tahun kemudian, saya memberi kuliah tentang dasar-dasar Linux untuk para ahli forensik - di masa lalu, Linux adalah baru dan spesialis muda setelah universitas dapat menceritakan banyak hal baru kepada para ahli dewasa.  Memberitahu saya cara menghapus dump dari disk menggunakan dd, dan setelah menghubungkan gambar ke komputer lain untuk belajar, saya menyadari bahwa gambar disk berisi banyak informasi menarik.  Informasi ini dapat diekstraksi bahkan tanpa memasang gambar (ya, mount -o loop ...) jika Anda tahu spesifikasi untuk format sistem file dan memiliki alat yang sesuai.  Sayangnya, saya tidak punya alat seperti itu. </p><br><p>  Setelah beberapa tahun, saya perlu mendekompilasi perpustakaan Java.  Tidak ada JD GUI pada masa itu, serta dekompiler ideologis, tetapi ada JAD.  Untuk pustaka saya, JAD menghasilkan campuran opcode Java dengan pesan kesalahan.  Selain itu, JAD tidak mendukung anotasi, dan di Java 6, yang muncul kemudian, mereka sudah terbiasa.  Berbekal spesifikasi mesin virtual Java, saya mulai ... </p><br><h1 id="ideya">  Ide </h1><br><p>  Saya membutuhkan mekanisme universal untuk menggambarkan struktur biner dan loader universal.  Loader, menggunakan deskripsi, akan membaca data biner ke dalam memori.  Anda biasanya harus berurusan dengan angka, string, susunan data, dan struktur majemuk.  Semuanya sederhana dengan angka - mereka memiliki panjang tetap - 1, 2, 4 atau 8 byte dan dapat segera dipetakan ke tipe data yang tersedia dalam bahasa.  Misalnya: byte, pendek, int, panjang untuk Java.  Untuk tipe numerik yang lebih panjang dari satu byte, penanda urutan byte (yang disebut representasi BigEndian / LittleEndiang) harus disediakan. </p><br><p>  Ini lebih sulit dengan string - mereka dapat dalam pengkodean yang berbeda (ASCII, UNICODE), memiliki panjang tetap atau variabel.  String dengan panjang tetap dapat dianggap sebagai array byte.  Untuk string panjang variabel, Anda dapat menggunakan dua opsi perekaman - tunjukkan panjangnya di awal baris (Pascal atau string awalan-awalan) atau letakkan karakter khusus di akhir baris untuk menunjukkan akhir baris.  Byte dengan nilai nol (yang disebut null-sided dihentikan) digunakan sebagai tanda seperti itu.  Kedua opsi memiliki kelebihan dan kekurangan, diskusi yang berada di luar cakupan artikel ini.  Jika ukurannya ditentukan di awal, maka ketika mengembangkan format, Anda perlu memutuskan panjang string maksimum: berapa banyak byte yang harus kami alokasikan ke penanda panjang tergantung pada ini: 2 <sup>8</sup> - 1 untuk satu byte, 2 <sup>16</sup> - 1 untuk dua byte, dll. </p><br><p>  Kami akan membedakan struktur data komposit menjadi kelas yang terpisah, melanjutkan dekomposisi ke angka dan string. </p><br><h1 id="struktura-class-fayla">  Struktur file .class </h1><br><p>  Kita perlu menggambarkan struktur file Java .class.  Sebagai hasilnya, saya ingin memiliki satu set kelas Java, di mana setiap kelas hanya berisi bidang yang sesuai dengan struktur data yang diteliti dan, mungkin, metode bantu untuk menampilkan objek dalam bentuk yang dapat dibaca manusia ketika metode toString () dipanggil.  Secara kategoris, saya tidak ingin memiliki logika di dalam yang bertanggung jawab untuk membaca atau menulis file. </p><br><p>  Kami mengambil spesifikasi dari mesin virtual Java, <br>  <a href="https://docs.oracle.com/javase/specs/jvms/se12/jvms12.pdf" rel="nofollow">Spesifikasi JVM, Java SE 12 Edition</a> . <br>  Kami akan tertarik pada bagian 4 "Format File kelas". </p><br><p>  Untuk menentukan bidang mana dalam urutan apa untuk memuat, kami memperkenalkan anotasi @FieldOrder (indeks = ...).  Kita perlu secara eksplisit menunjukkan urutan bidang untuk bootloader, karena spesifikasi tidak memberi kami jaminan pada urutan di mana mereka akan disimpan dalam file biner. </p><br><p>  File Java .class dimulai dengan 4 byte angka ajaib, dua byte versi minor Java, dan dua byte versi utama.  Kami mengemas angka ajaib dalam variabel int, dan nomor versi minor dan utama singkatnya: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> magic; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> minorVersion; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> majorVersion;</code> </pre> <br><p>  Selanjutnya dalam file .class adalah ukuran pool konstan (variabel dua-byte) dan pool konstan itu sendiri.  Kami memperkenalkan anotasi @ContainerSize untuk mendeklarasikan ukuran array dan daftar struktur.  Ukuran dapat diperbaiki (kami akan mengaturnya melalui atribut nilai) atau memiliki panjang variabel, ditentukan oleh variabel yang sebelumnya dibaca.  Dalam hal ini, kita akan menggunakan atribut "fieldName", yang menunjukkan dari variabel mana kita akan membaca ukuran kontainer.  Menurut spesifikasi (bagian 4.1, <br>  "Struktur ClassFile"), ukuran aktual dari kolam konstan berbeda dengan 1 dari nilai <br>  yang ditulis ke constant_pool_count: </p><br><pre> <code class="plaintext hljs">u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1];</code> </pre> <br><p>  Untuk menjelaskan koreksi tersebut, kami memperkenalkan atribut korektor tambahan dalam penjelasan @ContainerSize. <br>  Sekarang kita dapat menambahkan deskripsi dari kumpulan konstan: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> constantPoolCount; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"constantPoolCount"</span></span>, corrector = -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;ConstantPoolItem&gt; constantPoolList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Dalam hal perhitungan yang lebih kompleks, Anda cukup menambahkan metode get yang akan mengembalikan nilai yang diinginkan:</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> containerSize; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(filed=<span class="hljs-string"><span class="hljs-string">"actualContainerSize"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;ContainerItem&gt; containerItems; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActualContainerSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> containerSize * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> </div></div><br><h1 id="constant-pool">  Kolam renang konstan </h1><br><p>  Setiap elemen dalam kumpulan konstanta adalah deskripsi konstanta yang sesuai dari tipe int, long, float, double, String, atau deskripsi salah satu komponen kelas Java - bidang kelas (bidang), metode, tanda tangan metode, dll.  Istilah "konstan" di sini berarti nilai yang tidak disebutkan namanya yang digunakan dalam kode: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intValue &gt; <span class="hljs-number"><span class="hljs-number">100500</span></span>)</code> </pre> <br><p>  Nilai 100500 akan diwakili dalam kumpulan konstan sebagai turunan dari CONSTANT_Integer.  Spesifikasi JVM untuk Java 12 mendefinisikan 17 jenis yang dapat berada dalam kumpulan konstan. </p><br><div class="spoiler">  <b class="spoiler_title">Kemungkinan instance elemen pool const</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th>  Tipe konstan </th><th>  Tag </th></tr></thead><tbody><tr><td>  CONSTANT_Class </td><td>  7 </td></tr><tr><td>  CONSTANT_Fieldref </td><td>  9 </td></tr><tr><td>  CONSTANT_Methodref </td><td>  10 </td></tr><tr><td>  CONSTANT_InterfaceMethodref </td><td>  11 </td></tr><tr><td>  CONSTANT_String </td><td>  8 </td></tr><tr><td>  CONSTANT_Integer </td><td>  3 </td></tr><tr><td>  CONSTANT_Float </td><td>  4 </td></tr><tr><td>  CONSTANT_Long </td><td>  5 </td></tr><tr><td>  CONSTANT_Double </td><td>  6 </td></tr><tr><td>  CONSTANT_NameAndType </td><td>  12 </td></tr><tr><td>  CONSTANT_Utf8 </td><td>  1 </td></tr><tr><td>  CONSTANT_MetodeHandle </td><td>  15 </td></tr><tr><td>  CONSTANT_MethodType </td><td>  16 </td></tr><tr><td>  CONSTANT_Dinamik </td><td>  17 </td></tr><tr><td>  CONSTANT_InvokeDynamic </td><td>  18 </td></tr><tr><td>  CONSTANT_Module </td><td>  19 </td></tr><tr><td>  CONSTANT_Paket </td><td>  20 </td></tr></tbody></table></div></div></div><br><p>  Dalam implementasi kami, kami akan membuat ConstantPoolItem kelas di mana akan ada tag bidang bita tunggal, yang menentukan struktur mana yang sedang kita baca saat ini.  Untuk setiap elemen dalam tabel di atas, buat kelas Java, turunan ConstantPoolItem.  Pemuat file biner universal harus dapat menentukan kelas mana yang harus digunakan berdasarkan tag yang sudah dibaca. <br>  (secara umum, tag dapat berupa variabel jenis apa pun).  Untuk tujuan ini, tentukan antarmuka HasInheritor dan terapkan antarmuka ini di kelas ConstantPoolItem: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasInheritor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;? extends T&gt; getInheritor() <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> InheritorNotFoundException; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Collection&lt;Class&lt;? extends T&gt;&gt; getInheritors(); }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstantPoolItem</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasInheritor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstantPoolItem</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map&lt;Byte, Class&lt;? extends ConstantPoolItem&gt;&gt; m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">7</span></span>, ClassInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">9</span></span>, FieldRefInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">10</span></span>, MethodRefInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">11</span></span>, InterfaceMethodRefInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">8</span></span>, StringInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>, IntegerInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">4</span></span>, FloatInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">5</span></span>, LongInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">6</span></span>, DoubleInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">12</span></span>, NameAndTypeInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>, Utf8Info.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">15</span></span>, MethodHandleInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">16</span></span>, MethodTypeInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">17</span></span>, DynamicInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">18</span></span>, InvokeDynamicInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">19</span></span>, ModuleInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">20</span></span>, PackageInfo.class); } <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> tag; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;? extends ConstantPoolItem&gt; getInheritor() <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> InheritorNotFoundException { Class&lt;? extends ConstantPoolItem&gt; clazz = m.get(tag); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clazz == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InheritorNotFoundException(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getClass().getName(), String.valueOf(tag)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clazz; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Collection&lt;Class&lt;? extends ConstantPoolItem&gt;&gt; getInheritors() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.values(); } }</code> </pre> <br><p>  Pemuat universal akan membuat instance kelas yang diperlukan dan melanjutkan membaca.  Satu-satunya syarat: indeks dalam kelas penerus harus memiliki penomoran end-to-end dengan kelas induk.  Ini berarti bahwa di semua kelas ConstantPoolItem, yang diturunkan dari FieldOrder, anotasi harus memiliki indeks lebih dari satu, karena di kelas induk kita sudah membaca bidang tag dengan nomor "1". </p><br><h1 id="struktura-class-fayla-prodolzhenie">  Struktur file .class (lanjutan) </h1><br><p>  Setelah daftar elemen dari kumpulan konstan dalam file .class ada pengidentifikasi dua byte yang mendefinisikan rincian kelas ini - adalah kelas anotasi, antarmuka, kelas abstrak, apakah memiliki bendera akhir, dll.  Ini diikuti oleh pengidentifikasi dua byte (referensi ke elemen dalam kumpulan konstan) yang mendefinisikan kelas ini.  Pengidentifikasi ini harus menunjuk ke elemen tipe ClassInfo.  Superclass untuk kelas yang diberikan didefinisikan dengan cara yang sama (apa yang ditunjukkan setelah kata "extends" dalam definisi kelas).  Untuk kelas yang tidak memiliki superclasses secara eksplisit, bidang ini berisi referensi ke kelas Object. </p><br><p>  Di Jawa, setiap kelas hanya dapat memiliki satu superclass, tetapi jumlahnya <br>  Mungkin ada beberapa antarmuka yang mengimplementasikan kelas ini: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> interfacesCount; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"interfacesCount"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Short&gt; interfaceIndexList;</code> </pre> <br><p>  Setiap elemen di interfaceIndexList mewakili tautan ke elemen dalam kumpulan konstan (seperti yang ditentukan <br>  indeks harus berupa elemen dengan tipe ClassInfo). <br>  Variabel kelas (properti, bidang) dan metode diwakili oleh daftar yang sesuai: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> fieldsCount; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"fieldsCount"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Field&gt; fieldList; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> methodsCount; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"methodsCount"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Method&gt; methodList;</code> </pre> <br><p>  Elemen terakhir dalam deskripsi file Java .class adalah daftar atribut kelas.  Atribut yang menggambarkan file sumber yang terkait dengan kelas, kelas bersarang, dll. Dapat dicantumkan di sini. </p><br><p>  Bytecode Java beroperasi dengan data numerik dalam representasi big-endian, kami akan menggunakan representasi ini secara default.  Untuk format biner dengan angka little-endian, kami akan menggunakan anotasi <a href="https://habr.com/ru/users/littleendian/" class="user_link">LittleEndian</a> .  Untuk string yang tidak memiliki panjang yang telah ditentukan, tetapi <br>  dibaca sebelum karakter terminal (seperti string null-terminated C-like) yang akan kita gunakan <br>  @StringTerminator anotasi: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-meta"><span class="hljs-meta">@StringTerminator</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String nullTerminatedString;</code> </pre> <br><p>  Terkadang di kelas yang mendasarinya Anda perlu meneruskan informasi dari tingkat yang lebih tinggi.  Objek Metode di methodList tidak memiliki informasi tentang nama kelas di mana ia berada, apalagi objek metode tidak mengandung nama dan daftar parameternya.  Semua informasi ini disajikan sebagai indeks pada elemen-elemen dalam kumpulan konstan.  Ini cukup untuk mesin virtual, tetapi kami ingin menerapkan metode toString () sehingga mereka menampilkan informasi tentang metode dalam bentuk yang ramah manusia, dan tidak dalam bentuk indeks pada elemen dalam kumpulan konstan.  Untuk melakukan ini, kelas Metode harus mendapatkan referensi ke ConstantPoolList dan ke variabel dengan nilai thisClassIndex.  Agar dapat meneruskan tautan ke tingkat sarang yang mendasarinya, kami akan menggunakan anotasi <a href="https://habr.com/ru/users/inject/" class="user_link">Suntikan</a> : </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"methodsCount"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"constantPoolList"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"thisClassIndex"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Method&gt; methodList;</code> </pre> <br><p>  Dalam metode pengambil kelas (ClassFile) saat ini akan dipanggil untuk variabel constantPoolList dan thisClassIndex, dan di kelas penerima (dalam hal ini Metode), metode penyetel akan dipanggil (jika ada). </p><br><h1 id="universalnyy-zagruzchik">  Bootloader universal </h1><br><p>  Jadi, kami memiliki satu antarmuka HasInheritor dan lima anotasi @FieldOrder, @ContainerSize, <a href="https://habr.com/ru/users/littleendian/" class="user_link">LittleEndian</a> , <a href="https://habr.com/ru/users/inject/" class="user_link">Inject</a> dan @StringTerminator, yang memungkinkan kami untuk menggambarkan struktur biner pada abstraksi tingkat tinggi.  Memiliki deskripsi formal, kita dapat meneruskannya ke universal loader, yang dapat membuat struktur yang dijelaskan, mem-parsing file biner dan membacanya ke dalam memori. </p><br><p>  Akibatnya, kita harus dapat menggunakan kode ini: </p><br><pre> <code class="java hljs"> ClassFile classFile; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(inputFileName)) { Loader loader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamLoader(is); classFile = (ClassFile) loader.load(); }</code> </pre> <br><p>  Sayangnya, pengembang platform Java sedikit terlalu canggih untuk nilai delapan byte di pool. <br>  konstanta disediakan untuk dua sel, sel pertama harus mengandung nilai, dan yang kedua tetap <br>  kosong  Ini berlaku untuk konstanta panjang dan ganda. </p><br><div class="spoiler">  <b class="spoiler_title">Deskripsi dari spesifikasi JVM</b> <div class="spoiler_text"><p>  Semua konstanta 8-byte mengambil dua entri dalam tabel constant_pool kelas <br>  file.  Jika struktur CONSTANT_Long_info atau CONSTANT_Double_info adalah entri <br>  pada indeks n pada tabel constant_pool, maka entri yang dapat digunakan selanjutnya dalam tabel adalah <br>  terletak di indeks n + 2.  Indeks constant_pool n +1 harus valid tetapi dipertimbangkan <br>  tidak dapat digunakan. </p></div></div><br>  Tampaknya, pengembang Java ingin menerapkan semacam optimasi tingkat rendah, tetapi kemudian <br>  diakui bahwa keputusan desain ini berubah <br><div class="spoiler">  <b class="spoiler_title">tidak berhasil.</b> <div class="spoiler_text"><p>  Dalam retrospeksi, membuat konstanta 8-byte mengambil dua entri konstan adalah pilihan yang buruk. </p></div></div><br><p>  Untuk menangani kasus-kasus khusus ini, kami akan menambahkan anotasi @EntrySize, yang akan kami gunakan, <br>  untuk menandai konstanta delapan byte: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@EntrySize</span></span>(value = <span class="hljs-number"><span class="hljs-number">2</span></span>, index = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EightByteNumberInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstantPoolItem</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> highBytes; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lowBytes; }</code> </pre> <br><p>  Atribut nilai menunjukkan jumlah sel yang akan ditempati elemen, indeks - indeks elemen, <br>  yang mengandung nilai.  kelas LongInfo dan DoubleInfo akan memperluas kelas EightByteNumberInfo. <br>  Bootloader universal perlu diperluas dengan fungsional yang mendukung anotasi @EntrySize. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassFileLoader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String fileName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { File f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(fileName); FileInputStream fis = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(f); loader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EntrySizeSupportLoader(fis); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (FileNotFoundException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e); } }</code> </pre> <br><p>  Setelah memuat kelas dengan ClassFileLoader, Anda dapat menghentikan debugger dan memeriksa kelas yang dimuat di pengawas variabel di IDE. </p><br><p>  File kelas akan terlihat seperti ini: <br><img src="https://habrastorage.org/webt/s6/jg/p_/s6jgp_an_ouz-lfdtc39d8gxd88.png" alt="gambar"></p><br><p>  Dan Constant Pool seperti ini: <br><img src="https://habrastorage.org/webt/5f/u4/sk/5fu4skrhx-jxhjjyiju4nc_apj0.png" alt="gambar"></p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Siapa pun yang dapat membaca sampai akhir mungkin ingin memilih bytecode Java dengan tangan mereka sendiri.  Jangan ragu untuk pergi ke github dan unduh deskripsi file kelas Java sebagai satu set kelas Java: <a href="https://github.com/esavin/annotate4j-classfile" rel="nofollow">https://github.com/esavin/annotate4j-classfile</a> .  Pemuat universal dan anotasi ada di sini: <a href="https://github.com/esavin/annotate4j-core" rel="nofollow">https://github.com/esavin/annotate4j-core</a> . </p><br><p>  Untuk mengunduh file kelas yang dikompilasi, gunakan annotate4j.classfile.loader.ClassFileLoader loader. </p><br><p>  Sebagian besar kode ditulis untuk Java 6, saya hanya mengadaptasi kolam konstan ke versi modern.  Saya tidak memiliki kekuatan dan keinginan untuk mengimplementasikan Java loader sepenuhnya untuk opcode Java, jadi hanya ada perkembangan kecil di bagian ini. </p><br><p>  Menggunakan perpustakaan ini (bagian inti) saya berhasil mengembalikan file biner dengan data pemantauan Holter (studi EKG aktivitas jantung harian).  Di sisi lain, saya tidak bisa mendekripsi protokol biner dari satu sistem akuntansi yang ditulis dalam Delphi.  Saya tidak mengerti bagaimana tanggal dikirim, dan kadang-kadang muncul situasi ketika data aktual tidak sesuai dengan struktur yang dibangun pada nilai-nilai sebelumnya. </p><br><p>  Saya mencoba membangun model yang mirip dengan file kelas Java untuk format ELF (format yang dapat dijalankan pada Unix / Linux), tetapi saya tidak dapat sepenuhnya memahami spesifikasi - ternyata terlalu kabur bagi saya.  Nasib yang sama menimpa format JPEG dan BMP - sepanjang waktu saya menemukan beberapa kesulitan dengan memahami spesifikasi. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481260/">https://habr.com/ru/post/id481260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481250/index.html">Penguji AI vs, Brandashmyg, bebek: bagaimana Heisenbug 2019 Moskow pergi</a></li>
<li><a href="../id481252/index.html">Kami mengaktifkan dukungan NVMe pada motherboard lama menggunakan Asus P9X79 WS sebagai contoh</a></li>
<li><a href="../id481254/index.html">Programmer fanatik. Sinopsis bagian 1. Mengapa Anda harus lebih buruk dan tidak mendengarkan saran orang tua</a></li>
<li><a href="../id481256/index.html">Startup mana yang harus saya luncurkan besok?</a></li>
<li><a href="../id481258/index.html">Kami merekatkan frame untuk sekunar tanpa registrasi dan SMS</a></li>
<li><a href="../id481264/index.html">Berapa banyak orang yang melihat ikon Anda di App Store selama aplikasi "App of the Day"</a></li>
<li><a href="../id481272/index.html">Pembekuan atau modernisasi - apa yang kita lakukan saat berlibur?</a></li>
<li><a href="../id481276/index.html">Bagaimana saya membuat YP dan kompiler saya selama 12 tahun</a></li>
<li><a href="../id481280/index.html">Bagaimana kami mempersiapkan tahap kualifikasi CTFZone-2020</a></li>
<li><a href="../id481282/index.html">Nilai ide itu dan bagaimana mengubahnya menjadi sebuah konsep: alat perancang permainan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>