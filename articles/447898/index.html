<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç± üë∞ üë®üèø‚Äçüåæ Fil√≥sofos bien alimentados o programaci√≥n competitiva .NET üí• üïñ üë©üèø‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Veamos c√≥mo funciona la programaci√≥n concurrente y paralela en .Net, utilizando el problema de los fil√≥sofos como ejemplo. Dicho plan, desde la sincro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fil√≥sofos bien alimentados o programaci√≥n competitiva .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447898/"><p><img src="https://habrastorage.org/webt/ox/lr/6d/oxlr6dmndsfjh_zjsowzpozt-30.png"></p><br><p>  Veamos c√≥mo funciona la programaci√≥n concurrente y paralela en .Net, utilizando el problema de los fil√≥sofos como ejemplo.  Dicho plan, desde la sincronizaci√≥n de hilos / procesos, hasta el modelo de actores (en las siguientes partes).  El art√≠culo puede ser √∫til para un primer conocido o para actualizar sus conocimientos. </p><br><p>  ¬øPor qu√© ser capaz de hacer esto?  Los transistores alcanzan su tama√±o m√≠nimo, la ley de Moore se basa en la limitaci√≥n de la velocidad de la luz y, por lo tanto, se observa un crecimiento en cantidad, se pueden hacer m√°s transistores.  Al mismo tiempo, la cantidad de datos est√° creciendo y los usuarios esperan una reacci√≥n inmediata de los sistemas.  En tal situaci√≥n, la programaci√≥n "normal", cuando tenemos un hilo en ejecuci√≥n, ya no es efectiva.  Es necesario resolver de alguna manera el problema de la ejecuci√≥n simult√°nea o competitiva.  Adem√°s, este problema existe en diferentes niveles: a nivel de flujos, a nivel de procesos, a nivel de m√°quinas en la red (sistemas distribuidos).  .NET tiene tecnolog√≠as probadas y de alta calidad para resolver estos problemas de manera r√°pida y efectiva. </p><a name="habracut"></a><br><br><h2 id="anchorproblemanchor-zadacha"><a name="problem"></a>  Desaf√≠o </h2><br><p>  Edsger Dijkstra plante√≥ este problema a sus alumnos ya en 1965. La redacci√≥n establecida es esta.  Hay un n√∫mero (generalmente cinco) de fil√≥sofos y tantos tenedores.  Est√°n sentados en la mesa redonda, con tenedores en el medio.  Los fil√≥sofos pueden comer de sus platos con comida interminable, pensar o esperar.  Para comer al fil√≥sofo, debes tomar dos tenedores (el √∫ltimo comparte el tenedor con el primero).  Para tomar y poner un tenedor: dos acciones separadas.  Todos los fil√≥sofos callan.  La tarea es encontrar un algoritmo tal que todos piensen y est√©n hartos incluso despu√©s de 54 a√±os. </p><br><p>  Primero, intentemos resolver este problema usando el espacio compartido.  Los tenedores est√°n sobre la mesa y los fil√≥sofos los toman cuando est√°n y los vuelven a poner.  Hay problemas con la sincronizaci√≥n, ¬øcu√°ndo exactamente tomar los enchufes?  ¬øQu√© hacer si no hay enchufe?  y otros. Pero primero, vamos a lanzar a los fil√≥sofos. </p><br><p> Para iniciar subprocesos, use el grupo de subprocesos a trav√©s del m√©todo <code>Task.Run</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancelTokenSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; create = (i) =&gt; RunPhilosopher(i, cancelTokenSource.Token); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; philosophersAmount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> icopy = i; <span class="hljs-comment"><span class="hljs-comment">//      .  RunDeadlock   // ,    .  . philosophers[i] = Task.Run(() =&gt; create(icopy), cancelTokenSource.Token); }</span></span></code> </pre> <br><p>  Grupo de subprocesos creado para optimizar la creaci√≥n y eliminaci√≥n de subprocesos.  Este grupo tiene una cola de tareas y el CLR crea o elimina subprocesos seg√∫n el n√∫mero de estas tareas.  Un grupo para todos los dominios de aplicaci√≥n.  Este grupo debe usarse casi siempre, porque  no necesita molestarse en crear, eliminar hilos, sus colas, etc. Es posible sin un grupo, pero luego debe usar el <code>Thread</code> directamente, es aconsejable para casos en los que necesita cambiar la prioridad de un hilo, cuando tenemos una operaci√≥n larga, para el primer plano de un hilo, etc. </p><br><p>  Y la clase <code>System.Threading.Tasks.Task</code> simplemente hace que sea f√°cil trabajar con este grupo de subprocesos (o incluso prescindir de √©l).  Es una operaci√≥n asincr√≥nica.  En t√©rminos generales, este es el mismo <code>Thread</code> , pero con todo tipo de comodidades: la capacidad de iniciar tareas despu√©s de un bloque de otras tareas, devolverlas de las funciones, es conveniente interrumpirlas y muchas m√°s.  etc. Son necesarios para admitir construcciones as√≠ncronas / en espera (patr√≥n asincr√≥nico basado en tareas, az√∫car sint√°ctico para esperar la operaci√≥n IO).  Hablaremos de esto nuevamente. </p><br><p>  <code>CancelationTokenSource</code> se necesita aqu√≠ para que el hilo en s√≠ mismo pueda ser terminado por la se√±al del hilo que llama. </p><br><h2 id="problemy-s-sinhronizaciey">  Problemas de sincronizaci√≥n </h2><br><h3 id="blokirovannye-filosofy">  Fil√≥sofos bloqueados </h3><br><p>  Ok, podemos crear hilos, intentemos almorzar: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    .  : 1 1 3 3 - 1  3    . private int[] forks = Enumerable.Repeat(0, philosophersAmount).ToArray(); //  ,  RunPhilosopher() private void RunDeadlock(int i, CancellationToken token) { //  ,  . : // while(true) // if forks[fork] == 0 // forks[fork] = i+1 // break // Thread.Sleep()  Yield()  SpinWait() void TakeFork(int fork) =&gt; SpinWait.SpinUntil(() =&gt; Interlocked.CompareExchange(ref forks[fork], i+1, 0) == 0); //  ,    Interlocked.Exchange: void PutFork(int fork) =&gt; forks[fork] = 0; while (true) { TakeFork(Left(i)); TakeFork(Right(i)); eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutFork(Left(i)); PutFork(Right(i)); Think(i); //   -. token.ThrowIfCancellationRequested(); } }</span></span></code> </pre> <br><p>  Aqu√≠ intentamos primero tomar las horquillas izquierda y luego la derecha, y si funciona, entonces comemos y volvemos a colocarlas.  Tomar un tenedor es at√≥mico, es decir  dos transmisiones no pueden tomar una al mismo tiempo (incorrectamente: la primera lee que el enchufe est√° libre, la segunda tambi√©n, la primera toma, la segunda toma).  Para hacer esto, <code>Interlocked.CompareExchange</code> , que debe implementarse utilizando una instrucci√≥n de procesador ( <code>TSL</code> , <code>XCHG</code> ), que bloquea una pieza de memoria para lectura y escritura secuencial at√≥mica.  Y SpinWait es equivalente a una construcci√≥n <code>while(true)</code> con solo un poco de "magia": el subproceso ocupa el procesador ( <code>Thread.SpinWait</code> ), pero a veces transfiere el control a otro subproceso ( <code>Thread.Yeild</code> ) o se queda dormido ( <code>Thread.Sleep</code> ). </p><br><p>  Pero esta soluci√≥n no funciona, porque  los flujos pronto ser√°n bloqueados (para m√≠ en un segundo): todos los fil√≥sofos toman su bifurcaci√≥n izquierda, pero no la correcta.  La matriz de horquillas tiene valores: 1 2 3 4 5. </p><br><p><img src="https://habrastorage.org/webt/4l/0x/h9/4l0xh9rwiyjh1l8u2z2szlnv--o.png" alt="Livelock"></p><br><p>  En la figura, hilos de bloqueo (punto muerto).  El verde indica ejecuci√≥n, el rojo indica sincronizaci√≥n y el gris indica suspensi√≥n.  Los diamantes indican la hora de inicio de la tarea. </p><br><h3 id="golod-filosofov">  El hambre de los fil√≥sofos </h3><br><p>  Aunque no es necesario pensar especialmente en la comida, debes obligar a cualquiera a abandonar la filosof√≠a.  Tratemos de simular la situaci√≥n de los flujos de ayuno en nuestro problema.  El hambre es cuando la corriente funciona, pero sin un trabajo significativo, en otras palabras, es el mismo punto muerto, solo que ahora la corriente no duerme, pero est√° buscando activamente algo para comer, pero no hay comida.  Para evitar bloqueos frecuentes, volveremos a enchufar si no pudimos tomar otro. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      RunDeadlock,         . private void RunStarvation(int i, CancellationToken token) { while (true) { bool hasTwoForks = false; var waitTime = TimeSpan.FromMilliseconds(50); //      : bool hasLeft = forks[Left(i)] == i + 1; if (hasLeft || TakeFork(Left(i), i + 1, waitTime)) { if (TakeFork(Right(i), i + 1, TimeSpan.Zero)) hasTwoForks = true; else PutFork(Left(i)); //      . } if (!hasTwoForks) { if (token.IsCancellationRequested) break; continue; } eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); bool goodPhilosopher = i % 2 == 0; //        : if (goodPhilosopher) PutFork(Left(i)); //      ,      . PutFork(Right(i)); Think(i); if (token.IsCancellationRequested) break; } } //     . bool TakeFork(int fork, int philosopher, TimeSpan? waitTime = null) { return SpinWait.SpinUntil( () =&gt; Interlocked.CompareExchange(ref forks[fork], philosopher, 0) == 0, waitTime ?? TimeSpan.FromMilliseconds(-1) ); }</span></span></code> </pre> <br><p>  En este c√≥digo, es importante que dos de cada cuatro fil√≥sofos se olviden de poner el tenedor izquierdo.  Y resulta que comen m√°s alimentos, mientras que otros comienzan a morir de hambre, aunque los flujos tienen la misma prioridad.  Aqu√≠ realmente no mueren de hambre, porque  los fil√≥sofos malos a veces vuelven a poner los tenedores.  Resulta que los buenos comen unas 5 veces menos que los malos.  Entonces, un peque√±o error en el c√≥digo conduce a una ca√≠da en el rendimiento.  Aqu√≠ vale la pena se√±alar que una situaci√≥n rara es posible cuando todos los fil√≥sofos toman la bifurcaci√≥n izquierda, no hay derecha, ponen la izquierda, esperan, vuelven a girar a la izquierda, etc.  Esta situaci√≥n tambi√©n es inanici√≥n, m√°s como un punto muerto.  No pude repetirlo.  A continuaci√≥n se muestra una imagen de una situaci√≥n en la que dos fil√≥sofos malos tomaron ambos tenedores y dos buenos fil√≥sofos est√°n muriendo de hambre. </p><br><p><img src="https://habrastorage.org/webt/2v/iw/b_/2viwb_qgxqznj1timeklnwscluw.png" alt="Inanici√≥n"></p><br><p>  Aqu√≠ puede ver que los hilos a veces se despiertan e intentan obtener un recurso.  Dos de los cuatro n√∫cleos no hacen nada (el gr√°fico verde en la parte superior). </p><br><h3 id="smert-filosofa">  La muerte del fil√≥sofo </h3><br><p>  Bueno, otro problema que puede interrumpir la gloriosa cena de los fil√≥sofos es si uno de ellos muere repentinamente con tenedores en sus manos (y lo enterrar√°n as√≠).  Luego los vecinos se quedar√°n sin almuerzo.  Puede <code>NullReferenceException</code> c√≥digo de muestra para este caso usted mismo, por ejemplo, <code>NullReferenceException</code> lanza una <code>NullReferenceException</code> despu√©s de que el fil√≥sofo toma los tenedores.  Y, por cierto, la excepci√≥n no se procesar√° y el c√≥digo de llamada simplemente no la detectar√° (para esto, <code>AppDomain.CurrentDomain.UnhandledException</code> , etc.).  Por lo tanto, los manejadores de errores son necesarios en los propios subprocesos y con la terminaci√≥n correcta. </p><br><h2 id="oficiant">  Camarero </h2><br><p>  Bueno, ¬øc√≥mo resolvemos este problema con puntos muertos, hambre y muerte?  Permitiremos que solo un fil√≥sofo se bifurque, agregue la exclusi√≥n mutua de flujos para este lugar.  Como hacerlo  Supongamos que un mesero se para al lado de los fil√≥sofos y da permiso a un fil√≥sofo para que tome tenedores.  ¬øC√≥mo hacemos a este camarero y c√≥mo los fil√≥sofos le hacen preguntas interesantes? </p><br><p>  La forma m√°s simple es cuando los fil√≥sofos simplemente le piden constantemente al camarero que acceda a los tenedores.  Es decir  ahora los fil√≥sofos no esperar√°n un enchufe cercano, sino que esperar√°n o preguntar√°n a un mesero.  Primero, usamos solo Espacio de usuario para esto, en √©l no usamos interrupciones para llamar a ning√∫n procedimiento desde el n√∫cleo (sobre ellos a continuaci√≥n). </p><br><h3 id="resheniya-v-prostranstve-polzovatelya">  Soluciones de espacio de usuario </h3><br><p>  Aqu√≠ haremos lo mismo que sol√≠amos hacer con un tenedor y dos fil√≥sofos, giraremos en un ciclo y esperaremos.  Pero ahora ser√°n todos fil√≥sofos y como si solo un tenedor, es decir  podemos decir que solo habr√° ese fil√≥sofo que tom√≥ este "tenedor dorado" del camarero.  Para esto usamos SpinLock. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> SpinLock spinLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinLock(); <span class="hljs-comment"><span class="hljs-comment">//  "" private void RunSpinLock(int i, CancellationToken token) { while (true) { //    busy waiting.   try,  //        SpinLock. bool hasLock = false; spinLock.Enter(ref hasLock); try { //       (mutual exclusion). forks[Left(i)] = i + 1; //   ,  . forks[Right(i)] = i + 1; eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); forks[Left(i)] = 0; forks[Right(i)] = 0; } finally { if(hasLock) spinLock.Exit(); //     . } Think(i); if (token.IsCancellationRequested) break; } }</span></span></code> </pre> <br><p>  <code>SpinLock</code> es un bloqueador, con, en t√©rminos generales, el mismo <code>while(true) { if (!lock) break; }</code>  <code>while(true) { if (!lock) break; }</code> , pero con a√∫n m√°s "magia" que en <code>SpinWait</code> (que se usa all√≠).  Ahora sabe contar a los que est√°n esperando, ponerlos a dormir un poco y m√°s.  etc. En general, hace todo lo posible para optimizar.  Pero debemos recordar que este sigue siendo el mismo ciclo activo que consume recursos del procesador y mantiene un hilo que puede conducir al hambre si uno de los fil√≥sofos se convierte en una prioridad sobre otros, pero no tiene un tenedor dorado (problema de inversi√≥n prioritaria).  Por lo tanto, lo usamos solo para cambios muy breves en la memoria compartida, sin sorpresas en llamadas de terceros, bloqueos anidados, etc. </p><br><p><img src="https://habrastorage.org/webt/ev/wu/kk/evwukkxrcgfutky1cihoe5dns0e.png" alt="Spinlock"></p><br><p>  Figura para <code>SpinLock</code> .  Las corrientes est√°n constantemente "luchando" por el tenedor dorado.  Las fallas ocurren: en la figura, el √°rea seleccionada.  Los n√∫cleos no se utilizan por completo: solo alrededor de 2/3 de estos cuatro hilos. </p><br><p>  Otra soluci√≥n aqu√≠ ser√≠a usar solo <code>Interlocked.CompareExchange</code> con la misma expectativa activa, como se muestra en el c√≥digo anterior (en fil√≥sofos hambrientos), pero esto, como ya se mencion√≥, podr√≠a conducir te√≥ricamente al bloqueo. </p><br><p>  Sobre <code>Interlocked</code> vale la pena decir que no solo hay <code>CompareExchange</code> , sino tambi√©n otros m√©todos para la lectura y escritura at√≥mica.  Y al repetir los cambios en caso de que otro hilo logre hacer sus cambios (leer 1, leer 2, escribir 2, escribir 1 es malo), puede usarse para cambios complejos de un valor (patr√≥n de cualquier cosa entrelazada). </p><br><h3 id="resheniya-v-rezhime-yadra">  Soluciones en modo kernel </h3><br><p>  Para evitar perder recursos en un bucle, veamos c√≥mo puede bloquear una transmisi√≥n.  En otras palabras, continuando con nuestro ejemplo, veremos c√≥mo el camarero duerme al fil√≥sofo y lo despierta solo cuando es necesario.  Primero, veamos c√≥mo hacer esto a trav√©s del modo kernel del sistema operativo.  Todas las estructuras all√≠ a menudo resultan ser m√°s lentas que las del espacio de usuario.  Varias veces m√°s lento, por ejemplo, <code>AutoResetEvent</code> puede ser 53 veces m√°s lento que <code>SpinLock</code> [Richter].  Pero con su ayuda, puede sincronizar procesos en todo el sistema, gestionados o no. </p><br><p>  La construcci√≥n principal aqu√≠ es el sem√°foro propuesto por Dijkstroy hace m√°s de medio siglo.  Un sem√°foro es, en t√©rminos simples, un n√∫mero entero positivo controlado por un sistema, y ‚Äã‚Äãdos operaciones en √©l: aumentar y disminuir.  Si la reducci√≥n no funciona, cero, entonces el hilo de llamada est√° bloqueado.  Cuando el n√∫mero es incrementado por alg√∫n otro hilo / proceso activo, entonces los hilos se saltan, y el sem√°foro nuevamente disminuye por el n√∫mero de pasados.  Puedes imaginar trenes en un cuello de botella con un sem√°foro.  .NET ofrece varios dise√±os con caracter√≠sticas similares: <code>AutoResetEvent</code> , <code>ManualResetEvent</code> , <code>Mutex</code> y <code>Semaphore</code> .  Usaremos <code>AutoResetEvent</code> , esta es la m√°s simple de estas construcciones: solo dos valores son 0 y 1 (falso, verdadero).  Su m√©todo <code>WaitOne()</code> bloquea el hilo de llamada si el valor era 0, y si es 1, luego baja a 0 y lo omite.  Y el m√©todo <code>Set()</code> aumenta a 1 y omite una espera, que nuevamente baja a 0. Act√∫a como un torniquete en el metro. </p><br><p>  Complicaremos la soluci√≥n y usaremos la cerradura para cada fil√≥sofo, y no para todos a la vez.  Es decir  ahora puede haber varios fil√≥sofos a la vez, y ninguno.  Pero nuevamente bloqueamos el acceso a la mesa para tomar los tenedores correctamente, evitando carreras (condiciones de carrera). </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    . // : new AutoResetEvent(true)  . private AutoResetEvent[] philosopherEvents; //     /   . private AutoResetEvent tableEvent = new AutoResetEvent(true); //  . public void Run(int i, CancellationToken token) { while (true) { TakeForks(i); //  . // .    . eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutForks(i); //     . Think(i); if (token.IsCancellationRequested) break; } } //    . void TakeForks(int i) { bool hasForks = false; while (!hasForks) //    (  ). { //    ,    . tableEvent.WaitOne(); if (forks[Left(i)] == 0 &amp;&amp; forks[Right(i)] == 0) forks[Left(i)] = forks[Right(i)] = i + 1; hasForks = forks[Left(i)] == i + 1 &amp;&amp; forks[Right(i)] == i + 1; if (hasForks) //   ,   .  Set //  ,   true. philosopherEvents[i].Set(); //   .    tableEvent  false. tableEvent.Set(); //   true,  ,   false,    Set  . philosopherEvents[i].WaitOne(); } } //     . void PutForks(int i) { tableEvent.WaitOne(); //    . forks[Left(i)] = 0; //  ,     ,  AutoResetEvent  true. philosopherEvents[LeftPhilosopher(i)].Set(); forks[Right(i)] = 0; philosopherEvents[RightPhilosopher(i)].Set(); tableEvent.Set(); }</span></span></code> </pre> <br><p>  Para comprender lo que est√° sucediendo aqu√≠, considere el caso en que el fil√≥sofo no tom√≥ los tenedores, entonces sus acciones ser√°n as√≠.  Est√° esperando el acceso a la mesa.  Habi√©ndolo recibido, intenta tomar los tenedores.  No funcion√≥.  Da acceso a la mesa (exclusi√≥n mutua).  Y pasa su "torniquete" ( <code>AutoResetEvent</code> ) (al principio est√°n abiertos).  Entra nuevamente en el ciclo, porque  No tiene tenedores.  Trata de tomarlos y se detiene en su torniquete.  Un vecino m√°s afortunado a la derecha o a la izquierda, despu√©s de haber terminado de comer, desbloquea a nuestro fil√≥sofo, "abriendo su torniquete".  Nuestro fil√≥sofo lo pasa (y se cierra detr√°s de √©l) por segunda vez.  Intenta por tercera vez tomar los tenedores.  Buena suerte  Y pasa su torniquete a cenar. </p><br><p>  Cuando hay errores aleatorios en dicho c√≥digo (siempre existen), por ejemplo, un vecino se especifica incorrectamente o se <code>AutoResetEvent</code> el mismo objeto <code>AutoResetEvent</code> para todos ( <code>Enumerable.Repeat</code> ), entonces los fil√≥sofos esperar√°n a los desarrolladores, porque  Encontrar errores en dicho c√≥digo es una tarea bastante dif√≠cil.  Otro problema con esta soluci√≥n es que no garantiza que ning√∫n fil√≥sofo se muera de hambre. </p><br><h3 id="gibridnye-resheniya">  Soluciones h√≠bridas </h3><br><p>  Examinamos dos enfoques para la sincronizaci√≥n cuando permanecemos en modo de usuario y giramos en un bucle y cuando bloqueamos un hilo a trav√©s del n√∫cleo.  El primer m√©todo es bueno para cerraduras cortas, el segundo para cerraduras largas.  A menudo, primero debe esperar brevemente a que cambie una variable en el bucle y luego bloquear el hilo cuando la espera es larga.  Este enfoque se implementa en el llamado  dise√±os h√≠bridos  Aqu√≠ hay las mismas construcciones que para el modo kernel, pero ahora con un bucle en modo usuario: <code>SemaphorSlim</code> , <code>ManualResetEventSlim</code> , etc. La construcci√≥n m√°s popular aqu√≠ es <code>Monitor</code> , porque  C # tiene una sintaxis de <code>lock</code> conocida.  <code>Monitor</code> es el mismo sem√°foro con un valor m√°ximo de 1 (mutex), pero con soporte para esperar en un bucle, recursi√≥n, patr√≥n de Variable de condici√≥n (al respecto a continuaci√≥n), etc. Veamos una soluci√≥n con √©l. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      ,   . private readonly object _lock = new object(); //   . private DateTime?[] _waitTimes = new DateTime?[philosophersAmount]; public void Run(int i, CancellationToken token) { while (true) { TakeForks(i); eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutForks(i); Think(i); if (token.IsCancellationRequested) break; } } //     Condition Variable . bool CanIEat(int i) { //   : if (forks[Left(i)] != 0 &amp;&amp; forks[Right(i)] != 0) return false; var now = DateTime.Now; // ,     ,  . foreach(var p in new int[] {LeftPhilosopher(i), RightPhilosopher(i)}) if (_waitTimes[p] != null &amp;&amp; now - _waitTimes[p] &gt; now - _waitTimes[i]) return false; return true; } void TakeForks(int i) { //   .   : lock(_lock) {..}. //   try,     . bool lockTaken = false; Monitor.Enter(_lock, ref lockTaken); try { _waitTimes[i] = DateTime.Now; // Condition Variable .  ,    //  .    -  Pulse / PulseAll. while (!CanIEat(i)) Monitor.Wait(_lock); forks[Left(i)] = i + 1; forks[Right(i)] = i + 1; _waitTimes[i] = null; } finally { if (lockTaken) Monitor.Exit(_lock); } } void PutForks(int i) { //   : lock (_lock) {..}. bool lockTaken = false; Monitor.Enter(_lock, ref lockTaken); try { forks[Left(i)] = 0; forks[Right(i)] = 0; //        Monitor.Exit. Monitor.PulseAll(_lock); } finally { if (lockTaken) Monitor.Exit(_lock); } }</span></span></code> </pre> <br><p>  Aqu√≠ bloqueamos nuevamente toda la mesa para acceder a las horquillas, pero ahora desbloqueamos todos los flujos a la vez, y no a los vecinos cuando alguien termina de comer.  Es decir  primero, alguien come y bloquea a los vecinos, y cuando este termina, pero quiere volver a comer de inmediato, entra en la cerradura y despierta a sus vecinos, porque  Su tiempo de espera es m√°s corto. </p><br><p>  As√≠ evitamos los callejones sin salida y el hambre de alg√∫n fil√≥sofo.  Usamos un ciclo para una espera corta y bloqueamos el flujo para una larga.  Desbloquear todo a la vez funciona m√°s lentamente que si solo el vecino estuviera desbloqueado, como en la soluci√≥n con <code>AutoResetEvent</code> , pero la diferencia no deber√≠a ser grande, porque  los hilos deben permanecer en modo de usuario primero. </p><br><p>  El <code>lock</code> sintaxis tiene sorpresas desagradables.  Recomiendan usar <code>Monitor</code> directamente [Richter] [Eric Lippert].  Uno de ellos es que el <code>lock</code> siempre sale de <code>Monitor</code> , incluso si hubo una excepci√≥n, y luego otro subproceso puede cambiar el estado de la memoria compartida.  En tales casos, a menudo es mejor ir al punto muerto o de alguna manera completar el programa de manera segura.  Otra sorpresa es que Monitor usa bloques de sincronizaci√≥n ( <code>SyncBlock</code> ), que est√°n en todos los objetos.  Por lo tanto, si selecciona el objeto incorrecto, puede obtener f√°cilmente un punto muerto (por ejemplo, si realiza un bloqueo en la cadena interna).  Siempre usamos un objeto oculto para esto. </p><br><p>  El patr√≥n de condici√≥n variable le permite implementar de manera m√°s concisa la expectativa de una condici√≥n compleja.  En .NET, est√° incompleto, en mi opini√≥n, porque  en teor√≠a deber√≠a haber varias colas en varias variables (como en los hilos de Posix), y no en un bloqueo.  Entonces uno podr√≠a hacerlos para todos los fil√≥sofos.  Pero de esta forma, le permite reducir el c√≥digo. </p><br><h3 id="mnogo-filosofov-ili-async--await">  Muchos fil√≥sofos o <code>async</code> / <code>await</code> </h3><br><p>  Ok, ahora podemos bloquear efectivamente los hilos.  Pero, ¬øqu√© pasa si tenemos muchos fil√≥sofos?  100?  10000?  Por ejemplo, recibimos 100,000 solicitudes a un servidor web.  Crear una secuencia para cada solicitud ser√° una sobrecarga, porque  tantos hilos no se ejecutar√°n en paralelo.  Solo se ejecutar√°n tantos n√∫cleos l√≥gicos (tengo 4).  Y todos los dem√°s simplemente tomar√°n recursos.  Una soluci√≥n a este problema es el patr√≥n as√≠ncrono / espera.  Su idea es que una funci√≥n no contenga una secuencia, si necesita esperar a que contin√∫e.  Y cuando hace esto, algo sucede, reanuda su ejecuci√≥n (¬°pero no necesariamente en el mismo hilo!).  En nuestro caso, esperaremos el enchufe. </p><br><p>  <code>SemaphoreSlim</code> tiene un m√©todo <code>WaitAsync()</code> para esto.  Aqu√≠ hay una implementaci√≥n que usa este patr√≥n. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  . -  : Task.Run(() =&gt; Run(i, cancelTokenSource.Token)); //  . //   async --      . public async Task Run(int i, CancellationToken token) { while (true) { // await --   - . await TakeForks(i); //  await,     . eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); //      . await PutForks(i); Think(i); if (token.IsCancellationRequested) break; } } async Task TakeForks(int i) { bool hasForks = false; while (!hasForks) { //    : await _tableSemaphore.WaitAsync(); if (forks[Left(i)] == 0 &amp;&amp; forks[Right(i)] == 0) { forks[Left(i)] = i+1; forks[Right(i)] = i+1; hasForks = true; } _tableSemaphore.Release(); //  ,    : if (!hasForks) await _philosopherSemaphores[i].WaitAsync(); } } //       . async Task PutForks(int i) { await _tableSemaphore.WaitAsync(); forks[Left(i)] = 0; // "" ,   "". _philosopherSemaphores[LeftPhilosopher(i)].Release(); forks[Right(i)] = 0; _philosopherSemaphores[RightPhilosopher(i)].Release(); _tableSemaphore.Release(); }</span></span></code> </pre> <br><p>   <code>async</code> / <code>await</code>     ,      <code>Task</code> .      ,     ,     Task.  ,  ,  .   ,    ,   ,   ,   .         .      <code>async</code> / <code>await</code> . </p><br><p> .  100     4  , 8 .    Monitor   4  ,     .    4    2.    async / await   100,       6.8 . ,      6         .    Monitor    . </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>      , .NET    .  , , ,   .     .    ,     ,   , TPL Dataflow, Reactive , Software Transaction   . </p><br><h2 id="istochniki">  Fuentes </h2><br><ul><li>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Concurrency Visualizer</a> </li><li> MSDN: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Threading</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asynchronous programming patterns</a>  . . </li><li> [] ‚Äî CLR via C#, Jeffrey Richter </li><li> [ ] ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> lock</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> </li><li>  ‚Äî "  ", .  </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447898/">https://habr.com/ru/post/447898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447886/index.html">An√°lisis de registro de Nginx con Amazon Athena y Cube.js</a></li>
<li><a href="../447890/index.html">Gracias a Dios no soy gerente</a></li>
<li><a href="../447892/index.html">Dos nuevos concursos PHDays: bypass de IDS y pirater√≠a de f√°brica</a></li>
<li><a href="../447894/index.html">MODX Digest # 3 (25 de marzo - 8 de abril de 2019)</a></li>
<li><a href="../447896/index.html">Im√°genes de bocetos: exactamente c√≥mo funciona la red neuronal GauGAN de NVIDIA</a></li>
<li><a href="../447900/index.html">Cerrar contactos ADL</a></li>
<li><a href="../447902/index.html">GitHub "elimin√≥" por completo el repositorio de la utilidad del repositorio de bloqueo y toda la cuenta del creador</a></li>
<li><a href="../447904/index.html">Expertos en tecnolog√≠as positivas identifican intentos de explotar en masa la vulnerabilidad cr√≠tica en Confluence</a></li>
<li><a href="../447906/index.html">Innovaciones reales: ¬øqu√© esperar del mercado de centros de datos en 2019?</a></li>
<li><a href="../447908/index.html">Deben funcionar dos formas de obtener recompensas por publicidad en juegos m√≥viles o robots</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>