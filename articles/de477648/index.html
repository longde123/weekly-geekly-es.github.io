<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôäÔ∏è üë®‚Äçüç≥ ‚ô£Ô∏è MVCC in PostgreSQL-3. Zeilenversionen üëßüèΩ üë®üèΩ‚Äç‚öñÔ∏è üë≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nun, wir haben bereits √ºber Isolation gesprochen und einen Exkurs in Bezug auf die Datenstruktur auf niedriger Ebene gemacht . Und wir haben endlich d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC in PostgreSQL-3. Zeilenversionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/477648/">  Nun, wir haben bereits √ºber <a href="https://habr.com/ru/company/postgrespro/blog/467437/">Isolation gesprochen</a> und einen Exkurs in Bezug auf <a href="https://habr.com/ru/company/postgrespro/blog/469087/">die Datenstruktur</a> auf <a href="https://habr.com/ru/company/postgrespro/blog/469087/">niedriger Ebene gemacht</a> .  Und wir haben endlich das Faszinierendste erreicht, n√§mlich die Zeilenversionen (Tupel). <br><br><h1>  Tupel-Header </h1><br>  Wie bereits erw√§hnt, k√∂nnen mehrere Versionen jeder Zeile gleichzeitig in der Datenbank vorhanden sein.  Und wir m√ºssen irgendwie eine Version von einer anderen unterscheiden.  Zu diesem Zweck wird jede Version mit ihrer effektiven "Zeit" ( <code>xmin</code> ) und Ablauf "Zeit" ( <code>xmax</code> ) gekennzeichnet.  Anf√ºhrungszeichen geben an, dass ein spezieller Inkrementierungsz√§hler anstelle der Zeit selbst verwendet wird.  Und dieser Z√§hler ist <em>die Transaktionskennung</em> . <br><br>  (In der Realit√§t ist dies wie √ºblich komplizierter: Die Transaktions-ID kann aufgrund einer begrenzten Bittiefe des Z√§hlers nicht immer inkrementiert werden. Weitere Einzelheiten hierzu werden wir jedoch untersuchen, wenn unsere Diskussion zum Einfrieren kommt.) <br><a name="habracut"></a><br>  Beim <code>xmin</code> einer Zeile wird der Wert von <code>xmin</code> gleich der ID der Transaktion gesetzt, die den Befehl INSERT ausgef√ºhrt hat, w√§hrend <code>xmax</code> nicht ausgef√ºllt ist. <br><br>  Wenn eine Zeile gel√∂scht wird, wird der <code>xmax</code> Wert der aktuellen Version mit der ID der Transaktion gekennzeichnet, die DELETE ausgef√ºhrt hat. <br><br>  Ein UPDATE-Befehl f√ºhrt tats√§chlich zwei nachfolgende Operationen aus: DELETE und INSERT.  In der aktuellen Version der Zeile ist <code>xmax</code> gleich der ID der Transaktion, die UPDATE ausgef√ºhrt hat.  Dann wird eine neue Version derselben Zeile erstellt, in der der Wert von <code>xmin</code> dem Wert von <code>xmin</code> der vorherigen Version entspricht. <br><br>  <code>xmin</code> Felder <code>xmin</code> und <code>xmax</code> sind in der Kopfzeile einer Zeilenversion enthalten.  Zus√§tzlich zu diesen Feldern enth√§lt der Tupelheader weitere Felder, z. <br><br><ul><li>  <code>infomask</code> - mehrere Bits, die die Eigenschaften eines gegebenen Tupels bestimmen.  Es gibt einige von ihnen, und wir werden sie im Laufe der Zeit besprechen. </li><li>  <code>ctid</code> - ein Verweis auf die n√§chste, neuere Version derselben Zeile.  <code>ctid</code> der neuesten, aktuellen Zeilenversion verweist auf <code>ctid</code> diese Version.  Die Nummer hat die Form <code>(x,y)</code> , wobei <code>x</code> die Seitennummer und <code>y</code> die Ordnungsnummer des Zeigers im Array ist. </li><li>  Die NULL-Bitmap, die die Spalten einer bestimmten Version markiert, die eine NULL enthalten.  NULL ist kein regul√§rer Wert f√ºr Datentypen, daher m√ºssen wir dieses Merkmal separat speichern. </li></ul><br>  Infolgedessen erscheint der Header ziemlich gro√ü: Mindestens 23 Byte pro Tupel, jedoch aufgrund der NULL-Bitmap in der Regel gr√∂√üer.  Wenn eine Tabelle "eng" ist (dh nur wenige Spalten enth√§lt), k√∂nnen die Overhead-Bytes mehr Platz belegen als die n√ºtzlichen Informationen. <br><br><h1>  Einf√ºgen </h1><br>  Schauen wir uns genauer an, wie die Operationen an Zeilen auf einer niedrigen Ebene ausgef√ºhrt werden, und beginnen wir mit einer Einf√ºgung. <br><br>  Zum Experimentieren erstellen wir eine neue Tabelle mit zwei Spalten und einem Index f√ºr eine davon: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre><br>  Wir starten eine Transaktion, um eine Zeile einzuf√ºgen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br>  Dies ist die ID unserer aktuellen Transaktion: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br>  Schauen wir uns den Inhalt der Seite an.  Mit der Funktion <code>heap_page_items</code> aus der Erweiterung "pageinspect" k√∂nnen wir Informationen zu den Zeigern und Zeilenversionen abrufen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br>  Beachten Sie, dass das Wort "Heap" in PostgreSQL Tabellen bezeichnet.  Dies ist eine weitere seltsame Verwendung eines Begriffs: Ein Heap ist eine bekannte <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">Datenstruktur</a> , die nichts mit einer Tabelle zu tun hat.  Dieses Wort wird hier in dem Sinne verwendet, dass "alles aufgesch√ºttet ist", anders als in geordneten Indizes. <br><br>  Diese Funktion zeigt die Daten "wie sie sind" in einem schwer verst√§ndlichen Format an.  Um die Dinge zu kl√§ren, belassen wir nur einen Teil der Informationen und interpretieren sie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br>  Wir haben folgendes gemacht: <br><br><ul><li>  Der Zeigernummer wurde eine Null hinzugef√ºgt, damit sie wie eine <code>t_ctid</code> : (Seitennummer, <code>t_ctid</code> ). </li><li>  Interpretierte den Status des Zeigers <code>lp_flags</code> .  Es ist hier "normal", was bedeutet, dass der Zeiger tats√§chlich auf eine Zeilenversion verweist.  Wir werden sp√§ter √ºber andere Werte sprechen. </li><li>  Von allen Informationsbits haben wir bisher nur zwei Paare ausgew√§hlt.  <code>xmin_committed</code> Bits <code>xmin_committed</code> und <code>xmin_aborted</code> zeigen an, ob die Transaktion mit der ID <code>xmin</code> ist ( <code>xmin</code> ).  Ein Paar √§hnlicher Bits bezieht sich auf die Transaktion mit der ID <code>xmax</code> . </li></ul><br>  Was beobachten wir?  Wenn eine Zeile eingef√ºgt wird, wird auf der Tabellenseite ein Zeiger mit der Nummer 1 angezeigt, der auf die erste und die einzige Version der Zeile verweist. <br><br>  Das Feld <code>xmin</code> im Tupel wird mit der ID der aktuellen Transaktion gef√ºllt.  Da die Transaktion noch aktiv ist, sind die Bits <code>xmin_committed</code> und <code>xmin_aborted</code> nicht gesetzt. <br><br>  Das Feld <code>ctid</code> der Zeilenversion verweist auf dieselbe Zeile.  Dies bedeutet, dass keine neuere Version verf√ºgbar ist. <br><br>  Das <code>xmax</code> Feld wird mit der konventionellen Nummer 0 gef√ºllt, da das Tupel nicht gel√∂scht wird, <code>xmax</code> aktuell ist.  Transaktionen ignorieren diese Nummer aufgrund des gesetzten <code>xmax_aborted</code> Bits. <br><br>  Gehen wir noch einen Schritt weiter, um die Lesbarkeit zu verbessern, indem wir Informationsbits an Transaktions-IDs anh√§ngen.  Und lassen Sie uns die Funktion erstellen, da wir die Abfrage mehr als einmal ben√∂tigen werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Was in der Kopfzeile der Zeilenversion passiert, ist in dieser Form viel klarer: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Wir k√∂nnen √§hnliche, aber weitaus weniger detaillierte Informationen aus der Tabelle selbst erhalten, indem <code>xmin</code> <code>xmax</code> <code>xmin</code> und <code>xmax</code> : <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1>  Commit </h1><br>  Wenn eine Transaktion erfolgreich ist, muss ihr Status gespeichert werden, dh, die Transaktion muss als festgeschrieben markiert werden.  Zu diesem Zweck wird die XACT-Struktur verwendet.  (Vor Version 10 hie√ü es CLOG (Festschreibungsprotokoll), und Sie werden wahrscheinlich immer noch auf diesen Namen sto√üen.) <br><br>  XACT ist keine Tabelle des Systemkatalogs, sondern Dateien im Verzeichnis PGDATA / pg_xact.  In diesen Dateien werden f√ºr jede Transaktion zwei Bits zugewiesen - "festgeschrieben" und "abgebrochen" - genau so wie im Tupel-Header.  Diese Informationen sind nur zur Vereinfachung auf mehrere Dateien verteilt.  Wir werden darauf zur√ºckkommen, wenn wir √ºber das Einfrieren sprechen.  PostgreSQL arbeitet mit diesen Dateien wie mit allen anderen auch seitenweise. <br><br>  Wenn also eine Transaktion festgeschrieben wird, wird das Bit "festgeschrieben" f√ºr diese Transaktion in XACT gesetzt.  Dies ist alles, was passiert, wenn die Transaktion festgeschrieben wird (obwohl wir das Write-Ahead-Protokoll noch nicht erw√§hnen). <br><br>  Wenn eine andere Transaktion auf die gerade betrachtete Tabellenseite zugreift, muss die erstere einige Fragen beantworten. <br><br><ol><li>  Wurde die Transaktion <code>xmin</code> abgeschlossen?  Wenn nicht, darf das erzeugte Tupel nicht sichtbar sein. <br>  Dies wird √ºberpr√ºft, indem eine andere Struktur durchsucht wird, die sich im gemeinsamen Speicher der Instanz befindet und ProcArray hei√üt.  Diese Struktur enth√§lt eine Liste aller aktiven Prozesse sowie die ID der jeweils aktuellen (aktiven) Transaktion. </li><li>  Wenn die Transaktion abgeschlossen wurde, wurde sie dann festgeschrieben oder r√ºckg√§ngig gemacht?  Wenn es zur√ºckgesetzt wurde, darf das Tupel auch nicht sichtbar sein. <br>  Genau daf√ºr wird XACT ben√∂tigt.  Es ist jedoch teuer, XACT jedes Mal zu √ºberpr√ºfen, obwohl die letzten Seiten von XACT in Puffern im gemeinsamen Speicher gespeichert sind.  Sobald dies herausgefunden wurde, wird der Transaktionsstatus in die Bits <code>xmin_committed</code> und <code>xmin_aborted</code> des Tupels geschrieben.  Wenn eines dieser Bits gesetzt ist, wird der Transaktionsstatus als bekannt behandelt und die n√§chste Transaktion muss XACT nicht √ºberpr√ºfen. </li></ol><br>  Warum setzt die Transaktion, die die Einf√ºgung durchf√ºhrt, diese Bits nicht?  Wenn eine Einf√ºgung ausgef√ºhrt wird, wei√ü die Transaktion noch nicht, ob sie erfolgreich abgeschlossen wird.  Und zum Festschreibungszeitpunkt ist bereits unklar, welche Zeilen und auf welchen Seiten ge√§ndert wurden.  Es kann eine Menge solcher Seiten geben, und es ist unpraktisch, sie im Auge zu behalten.  Au√üerdem k√∂nnen einige der Seiten aus dem Puffer-Cache auf die Festplatte entfernt werden.  Sie erneut zu lesen, um die Bits zu √§ndern, w√ºrde eine signifikante Verlangsamung des Commits bedeuten. <br><br>  Die Kehrseite der Kostenersparnis ist, dass nach den Aktualisierungen jede Transaktion (auch die, die SELECT ausf√ºhrt) beginnen kann, Datenseiten im Puffercache zu √§ndern. <br><br>  Also verpflichten wir uns zur Ver√§nderung. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Auf der Seite hat sich nichts ge√§ndert (aber wir wissen, dass der Transaktionsstatus bereits in XACT geschrieben wurde): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Nun muss eine Transaktion, die zuerst auf die Seite zugreift, den Status der Transaktion <code>xmin</code> und in die Informationsbits schreiben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1>  L√∂schen </h1><br>  Beim L√∂schen einer Zeile wird die ID der aktuellen <code>xmax</code> Feld <code>xmax</code> der aktuellen Version geschrieben und das Bit <code>xmax_aborted</code> zur√ºckgesetzt. <br><br>  Beachten Sie, dass der Wert von <code>xmax</code> , der der aktiven Transaktion entspricht, als Zeilensperre fungiert.  Wenn eine andere Transaktion diese Zeile aktualisieren oder l√∂schen wird, muss sie warten, bis die <code>xmax</code> Transaktion abgeschlossen ist.  Wir werden sp√§ter detaillierter auf Sperren eingehen.  Beachten Sie an dieser Stelle nur, dass die Anzahl der Zeilensperren √ºberhaupt nicht begrenzt ist.  Sie belegen keinen Speicher und die Systemleistung wird von dieser Zahl nicht beeinflusst.  Langfristige Transaktionen haben jedoch andere Nachteile, auf die sp√§ter noch eingegangen wird. <br><br>  Lassen Sie uns eine Zeile l√∂schen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br>  Wir sehen, dass die Transaktions-ID in das <code>xmax</code> Feld geschrieben wird, aber die Informationsbits nicht gesetzt sind: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1>  Abbrechen </h1><br>  Der Abbruch einer Transaktion funktioniert √§hnlich wie das Festschreiben, au√üer dass das Bit "Abgebrochen" in XACT gesetzt ist.  Ein Abbruch erfolgt so schnell wie ein Commit.  Obwohl der Befehl ROLLBACK hei√üt, werden die √Ñnderungen nicht zur√ºckgesetzt: Alles, was die Transaktion bereits ge√§ndert hat, bleibt unber√ºhrt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br>  Beim Zugriff auf die Seite wird der Status √ºberpr√ºft und das Hinweisbit <code>xmax_aborted</code> gesetzt.  Obwohl die Zahl <code>xmax</code> selbst noch auf der Seite vorhanden ist, wird sie nicht <code>xmax</code> . <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1>  Update </h1><br>  Ein Update funktioniert so, als w√ºrde zuerst die aktuelle Version gel√∂scht und dann eine neue eingef√ºgt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br>  Die Abfrage gibt eine Zeile zur√ºck (die neue Version): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br>  Aber wir k√∂nnen beide Versionen auf der Seite sehen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Die gel√∂schte Version wird mit der ID der aktuellen Transaktion im Feld <code>xmax</code> .  Dar√ºber hinaus hat dieser Wert den alten Wert √ºberschrieben, seit die vorherige Transaktion zur√ºckgesetzt wurde.  Das <code>xmax_aborted</code> Bit wird zur√ºckgesetzt, da der Status der aktuellen Transaktion noch nicht bekannt ist. <br><br>  Die erste Version der Zeile verweist jetzt auf die zweite, und zwar auf eine neuere. <br><br>  Die Indexseite enth√§lt jetzt den zweiten Zeiger und die zweite Zeile, die auf die zweite Version auf der Tabellenseite verweisen. <br><br>  Wie beim L√∂schen zeigt der Wert von <code>xmax</code> in der ersten Version an, dass die Zeile gesperrt ist. <br><br>  Zuletzt verpflichten wir uns zur Transaktion. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Indizes </h1><br>  Bisher haben wir nur √ºber Tabellenseiten gesprochen.  Aber was passiert in Indizes? <br><br>  Informationen auf Indexseiten h√§ngen stark vom jeweiligen Indextyp ab.  Dar√ºber hinaus kann auch ein Indextyp unterschiedliche Seitentypen haben.  Beispiel: Ein B-Baum enth√§lt die Metadatenseite und "normale" Seiten. <br><br>  Dennoch enth√§lt eine Indexseite normalerweise ein Array von Zeigern auf die Zeilen und Zeilen selbst (genau wie Tabellenseiten).  Au√üerdem wird am Ende einer Seite etwas Platz f√ºr spezielle Daten reserviert. <br><br>  Zeilen in Indizes k√∂nnen je nach Indextyp auch unterschiedliche Strukturen haben.  Beispiel: In einem B-Baum enthalten die f√ºr Blattseiten relevanten Zeilen den Wert des <code>ctid</code> und einen Verweis ( <code>ctid</code> ) auf die entsprechende Tabellenzeile.  Generell kann ein Index ganz anders aufgebaut sein. <br><br>  Der wichtigste Punkt ist, dass es in Indizes jeglichen Typs keine Zeilenversionen gibt.  Oder wir k√∂nnen davon ausgehen, dass jede Zeile nur durch eine Version dargestellt wird.  Mit anderen Worten enth√§lt der Header der Indexzeile nicht die Felder <code>xmin</code> und <code>xmax</code> .  Im Moment k√∂nnen wir davon ausgehen, dass Referenzen aus dem Index auf alle Versionen von Tabellenzeilen verweisen.  Um herauszufinden, welche der Zeilenversionen f√ºr eine Transaktion sichtbar sind, muss PostgreSQL die Tabelle untersuchen.  (Wie √ºblich ist dies nicht die ganze Geschichte. Manchmal erm√∂glicht die Sichtbarkeitskarte die Optimierung des Prozesses, aber wir werden dies sp√§ter diskutieren.) <br><br>  Hier auf der Indexseite finden wir Verweise auf beide Versionen: die aktuelle und die vorherige: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1>  Virtuelle Transaktionen </h1><br>  In der Praxis nutzt PostgreSQL eine Optimierung, mit der Transaktions-IDs "sparsam" verbraucht werden k√∂nnen. <br><br>  Wenn eine Transaktion nur Daten liest, hat dies keine Auswirkungen auf die Sichtbarkeit von Tupeln.  Daher weist der Backend-Prozess der Transaktion zun√§chst eine virtuelle ID (virtuelle xid) zu.  Diese ID besteht aus der Prozesskennung und einer fortlaufenden Nummer. <br><br>  Die Zuweisung dieser virtuellen ID erfordert keine Synchronisation zwischen allen Prozessen und erfolgt daher sehr schnell.  Wir werden einen weiteren Grund f√ºr die Verwendung virtueller IDs kennenlernen, wenn wir √ºber das Einfrieren sprechen. <br><br>  Datenschnappsch√ºsse ber√ºcksichtigen die virtuelle ID √ºberhaupt nicht. <br><br>  Zu verschiedenen Zeitpunkten kann das System √ºber virtuelle Transaktionen mit bereits verwendeten IDs verf√ºgen. Dies ist in Ordnung.  Diese ID kann jedoch nicht auf Datenseiten geschrieben werden, da die ID beim n√§chsten Zugriff auf die Seite bedeutungslos werden kann. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br>  Wenn eine Transaktion beginnt, Daten zu √§ndern, erh√§lt sie eine echte, eindeutige Transaktions-ID. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Subtransaktionen </h1><br><h2>  Sicherungspunkte </h2><br>  In SQL werden <em>Sicherungspunkte</em> definiert, mit denen einige Vorg√§nge der Transaktion <em>r√ºckg√§ngig gemacht</em> werden k√∂nnen, ohne dass sie vollst√§ndig abgebrochen werden.  Dies ist jedoch mit dem obigen Modell nicht kompatibel, da der Transaktionsstatus f√ºr alle √Ñnderungen gleich ist und kein physisches Rollback f√ºr Daten ausgef√ºhrt wird. <br><br>  Um diese Funktionalit√§t zu implementieren, wird eine Transaktion mit einem Sicherungspunkt in mehrere separate <em>Subtransaktionen unterteilt,</em> deren Status separat verwaltet werden kann. <br><br>  Subtransaktionen haben ihre eigenen IDs (gr√∂√üer als die ID der Haupttransaktion).  Der Status von Subtransaktionen wird auf √ºbliche Weise in XACT geschrieben, der endg√ºltige Status h√§ngt jedoch vom Status der Haupttransaktion ab: Wenn ein Rollback durchgef√ºhrt wird, werden auch alle Subtransaktionen zur√ºckgesetzt. <br><br>  Informationen zur Verschachtelung von Subtransaktionen werden in Dateien des Verzeichnisses PGDATA / pg_subtrans gespeichert.  Auf diese Dateien wird √ºber Puffer im gemeinsamen Speicher der Instanz zugegriffen, die genauso aufgebaut sind wie XACT-Puffer. <br><br>  Verwechseln Sie Subtransaktionen nicht mit autonomen Transaktionen.  Autonome Transaktionen h√§ngen in keiner Weise voneinander ab, w√§hrend Subtransaktionen davon abh√§ngen.  Es gibt keine autonomen Transaktionen im regul√§ren PostgreSQL, was vielleicht zum Besseren ist: Sie werden tats√§chlich √§u√üerst selten ben√∂tigt, und ihre Verf√ºgbarkeit in anderen DBMS f√ºhrt zu Missbrauch, unter dem jeder leidet. <br><br>  Lassen Sie uns die Tabelle leeren, eine Transaktion starten und eine Zeile einf√ºgen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Jetzt legen wir einen Sicherungspunkt fest und f√ºgen eine weitere Zeile ein. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br>  Beachten Sie, dass die Funktion <code>txid_current</code> die ID der Haupttransaktion und nicht der Subtransaktion zur√ºckgibt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Lassen Sie uns zum Sicherungspunkt zur√ºckkehren und die dritte Zeile einf√ºgen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Auf der Seite sehen wir weiterhin die Zeile, die durch die r√ºckg√§ngig gemachte Subtransaktion hinzugef√ºgt wurde. <br><br>  √Ñnderungen √ºbernehmen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Es ist jetzt deutlich zu sehen, dass jede Subtransaktion ihren eigenen Status hat. <br><br>  Beachten Sie, dass SQL die explizite Verwendung von Subtransaktionen nicht zul√§sst. Sie k√∂nnen also keine neue Transaktion starten, bevor Sie die aktuelle abgeschlossen haben.  Diese Technik wird implizit angewendet, wenn Sicherungspunkte verwendet werden und wenn PL / pgSQL-Ausnahmen behandelt werden, sowie in einigen anderen, exotischeren Situationen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2>  Fehler und Funktionsunterschiede </h2><br>  Was passiert, wenn w√§hrend des Vorgangs ein Fehler auftritt?  Zum Beispiel so: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br>  Ein Fehler ist aufgetreten.  Jetzt wird die Transaktion als abgebrochen behandelt und es sind keine Operationen darin erlaubt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br>  Und selbst wenn wir versuchen, die √Ñnderungen festzuschreiben, meldet PostgreSQL das Rollback: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ROLLBACK</code> </pre><br>  Warum kann die Transaktion nach einem Fehler nicht mehr ausgef√ºhrt werden?  Die Sache ist, dass der Fehler auftreten k√∂nnte, so dass wir Zugriff auf einen Teil der √Ñnderungen erhalten w√ºrden, das hei√üt, die Atomizit√§t w√ºrde nicht nur f√ºr die Transaktion, sondern auch f√ºr einen einzelnen Operator unterbrochen.  In unserem Beispiel h√§tte der Operator beispielsweise eine Zeile aktualisieren k√∂nnen, bevor der Fehler auftrat: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br>  Es ist erw√§hnenswert, dass psql √ºber einen Modus verf√ºgt, mit dem die Transaktion nach einem Fehler fortgesetzt werden kann, als ob die Auswirkungen des fehlerhaften Operators r√ºckg√§ngig gemacht w√ºrden. <br><br><pre> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Es ist einfach herauszufinden, dass in diesem Modus psql vor jedem Befehl einen impliziten Sicherungspunkt erstellt und bei einem Fehler ein Rollback darauf initiiert.  Dieser Modus wird standardm√§√üig nicht verwendet, da das Einrichten von Sicherungspunkten (auch ohne Rollback) einen erheblichen Mehraufwand mit sich bringt. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/479512/">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477648/">https://habr.com/ru/post/de477648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477634/index.html">Microservices und Organisationsstruktur. Welche Arten von Teams werden den Erfolg sicherstellen?</a></li>
<li><a href="../de477638/index.html">Gekauft! = Mit freundlichen Gr√º√üen: John Deere beraubt die Landwirte des Rechts, ihre eigenen Traktoren zu reparieren</a></li>
<li><a href="../de477642/index.html">Machine (Radio) Vision sieht durch W√§nde</a></li>
<li><a href="../de477644/index.html">Wiederherstellen von UNIX v0 auf PDP-7: Backroom-Details</a></li>
<li><a href="../de477646/index.html">Mathematiker schneiden Formen auf der Suche nach Teilen von Gleichungen</a></li>
<li><a href="../de477650/index.html">Verschl√ºsselung des TLS-Verkehrs nach GOST-2012-Algorithmen mit Stunnel</a></li>
<li><a href="../de477654/index.html">Probieren Sie den verbesserten instanceof-Operator in Java 14 aus</a></li>
<li><a href="../de477656/index.html">Also trotzdem, warum brauchst du make?</a></li>
<li><a href="../de477658/index.html">Active Restore: Kann Disaster Recovery schneller sein? Viel schneller</a></li>
<li><a href="../de477662/index.html">Zugriff auf Redd Tyres auf FTDI-Br√ºcken</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>