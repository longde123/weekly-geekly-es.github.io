<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêí üö¥ üéõÔ∏è Desde API primero en Swagger hasta contrato individual en RAML ü§∏üèº üå°Ô∏è üë®üèΩ‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola% username%! 

 Probablemente sepa qu√© son las API y cu√°nto depende de ellas en su proyecto. Adem√°s, tambi√©n creo que ya est√°s familiarizado con c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desde API primero en Swagger hasta contrato individual en RAML</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419525/"><img src="https://habrastorage.org/webt/cj/pv/it/cjpvit3gxuwcyybj7ifn7xzv8gw.png" alt="imagen"><br><br>  Hola% username%! <br><br>  Probablemente sepa qu√© son las API y cu√°nto depende de ellas en su proyecto.  Adem√°s, tambi√©n creo que ya est√°s familiarizado con cu√°l es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer</a> enfoque de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API</a> y sabes que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Swagger</a> y su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API abierta</a> son algunas de las herramientas m√°s populares para ayudarlo a seguir. <br><br>  Pero en este art√≠culo quiero hablar sobre el enfoque para la implementaci√≥n de la API primero, conceptualmente diferente de lo que ofrecen Swagger y Apiary.  A la cabeza de la idea est√° el concepto de <i>contrato √∫nico</i> y la posibilidad de su implementaci√≥n basada en RAML 1.0. <br><br>  Debajo del corte: <br><br><ul><li>  Una breve descripci√≥n de los principios de la API primero; </li><li>  <i>Contrato √∫nico</i> : introducci√≥n de un concepto, requisitos previos para la aparici√≥n, consideraci√≥n de la posibilidad de su implementaci√≥n sobre la base de la OEA (Swagger); </li><li>  RAML + anotaciones + superposiciones como base para <i>un contrato √∫nico</i> , ejemplos; </li><li>  Problemas RAML, desacuerdos conceptuales de los desarrolladores; </li><li>  La idea de un servicio SaaS basado en la idea anterior (imagen prototipo arriba). </li></ul><br><br><a name="habracut"></a><br><h2>  Desde API primero en Swagger hasta contrato individual en RAML </h2><br>  Al dise√±ar sistemas de software modernos, a menudo surge la tarea de coordinar y desarrollar interfaces para la interacci√≥n de sus componentes entre s√≠.  En la √∫ltima d√©cada, el SPA y las aplicaciones m√≥viles gruesas que interact√∫an con el servidor a trav√©s de API han ganado una inmensa popularidad y desarrollo.  Anteriormente, el desarrollo de un sitio web interactivo se llevaba a cabo mediante la edici√≥n paso a paso del c√≥digo del lado del servidor para generar el marcado HTML con su posterior transferencia al navegador del cliente, ahora el desarrollo de aplicaciones web din√°micas se ha desplazado hacia la creaci√≥n de una API de servicio √∫nico y el desarrollo paralelo de muchas aplicaciones (incluido SPA) que funcionan con esta API como fuente principal de datos.  Este enfoque le permite compartir tareas de manera m√°s conveniente, organizar equipos especializados solo en tecnolog√≠as espec√≠ficas (atraer especialistas m√°s especializados), organizar el desarrollo paralelo en las primeras etapas y tambi√©n le permite crear un √∫nico punto de comunicaci√≥n: una interfaz API. <br><br>  Tal punto √∫nico de comunicaci√≥n requiere una definici√≥n formal e inequ√≠voca, este documento es una especificaci√≥n API.  Para desarrollar y documentar las especificaciones API hoy en d√≠a, se utilizan diversas tecnolog√≠as y lenguajes, por ejemplo: OAS (Swagger), Apiary y RAML. <br><br>  Los siguientes tres puntos determinan la naturaleza del primer enfoque de API: <br><br><ol><li>  API deber√≠a ser la primera interfaz de cliente de la aplicaci√≥n desarrollada; </li><li>  En primer lugar, se desarrolla una especificaci√≥n API y luego la parte de software de sus clientes; </li><li>  Las etapas de vida de una API deben coincidir con las etapas de vida de su documentaci√≥n. </li></ol><br>  Si consideramos el proceso basado en lo anterior, entonces la especificaci√≥n API est√° en el centro del proceso de desarrollo, y todos los nodos que componen el sistema y usan esta API como puerta de enlace de interacci√≥n son clientes de la especificaci√≥n API.  Por lo tanto, la parte del servidor del sistema puede considerarse la misma API de especificaci√≥n de cliente, como cualquier otro nodo que use la API para comunicarse con √©l.  Los modelos de dominio de aplicaci√≥n no tienen que coincidir con los modelos descritos en la especificaci√≥n API.  Sus posibles coincidencias intencionales con estructuras de clase en el c√≥digo de aplicaci√≥n del cliente o con estructuras de esquema de base de datos se introducen en lugar de simplificar el proceso de desarrollo, por ejemplo, cuando se utiliza un generador de c√≥digo de acuerdo con la especificaci√≥n OAS.  L√≥gicamente, lo anterior se puede resumir bajo la definici√≥n de <i>contrato √∫nico</i> .  <i>Contrato √∫nico</i> : muchos clientes. <br><br><h3>  Contrato √∫nico.  Herramientas de contrato y bibliotecas </h3><br><blockquote>  El t√©rmino <i>contrato √∫nico</i> no reclama ninguna participaci√≥n en las cr√≠ticas por su uso en el texto del art√≠culo.  Su aplicaci√≥n, en este contexto, es personalmente mi idea. </blockquote>  Extender el concepto de <i>API primero</i> a un <i>contrato √∫nico</i> m√°s general nos permite considerar la especificaci√≥n API no solo como una descripci√≥n formal de la interfaz entre los componentes del sistema, sino tambi√©n como un <i>contrato √∫nico</i> utilizado por cualquier cantidad de bibliotecas y herramientas externas como fuente de configuraci√≥n.  En este caso, estas herramientas y bibliotecas se pueden percibir como clientes contratados junto con SPA o aplicaciones m√≥viles.  Ejemplos de tales clientes incluyen: <br><br><ul><li>  Generador de documentaci√≥n </li><li>  API de servidor simulado </li><li>  Servicio de pruebas de estr√©s </li><li>  Biblioteca de validaci√≥n de solicitud / respuesta </li><li>  Generador de c√≥digo </li><li>  UI Generator </li><li>  etc. </li></ul><br>  <i>El contrato √∫nico</i> para dichos clientes es un archivo de configuraci√≥n √∫nico y una fuente de datos.  Los instrumentos contractuales solo funcionan sobre la base de la informaci√≥n obtenida de un contrato particular.  Obviamente, para la funcionalidad completa de clientes tan heterog√©neos como el servidor simulado de API, una descripci√≥n de API no es suficiente, se necesita metainformaci√≥n adicional, por ejemplo, una descripci√≥n de la relaci√≥n entre los par√°metros de solicitud GET (identificador de recurso) y los datos que el servidor debe devolver, sugerencias apuntando a los campos de respuesta y par√°metros de consulta utilizados para organizar la paginaci√≥n.  Adem√°s, este ejemplo se considerar√° con m√°s detalle.  La informaci√≥n espec√≠fica para instrumentos espec√≠ficos, al mismo tiempo, debe existir y mantenerse inextricablemente del documento principal, de lo contrario, esto violar√° el concepto de un contrato √∫nico. <br><br><h3>  Swagger (OEA) como herramienta de descripci√≥n de contrato √∫nico </h3><br>  Los Swagger (OAS) y Apiary (Blueprint) m√°s populares en el mercado le permiten describir las API HTTP utilizando lenguajes especiales: API abierta basada en YAML o JSON, Blueprint basada en Markdown, que hace que las especificaciones sean f√°ciles de leer.  Tambi√©n hay muchas herramientas y bibliotecas creadas por la gran comunidad de c√≥digo abierto.  Swagger actualmente est√° ampliamente distribuido y, uno podr√≠a decir, se ha convertido en el est√°ndar de facto de API primero.  Muchos sistemas externos admiten la importaci√≥n de especificaciones Swagger, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SoapUI</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Readme.io</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apigee</a> , etc.  Adem√°s, el SaaS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Swagger Hub</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apiary existentes</a> permiten a los usuarios crear proyectos, cargar o crear sus propias especificaciones, usar los generadores de documentaci√≥n incorporados y servidores simulados, as√≠ como publicar enlaces para acceder a ellos desde el exterior. <br><br>  Swagger junto con su OAS 3.0 se ven bastante seguros y su funcionalidad para describir la API (especialmente simple) es suficiente en la mayor√≠a de los casos.  La siguiente es una lista de los pros y los contras de Swagger: <br><br>  Pros: <br><br><ul><li>  Lenguaje descriptivo claro y f√°cil de leer; </li><li>  Gran comunidad de c√≥digo abierto; </li><li>  Una gran cantidad de editores, generadores, bibliotecas oficiales y de c√≥digo abierto; </li><li>  La presencia de un equipo central de desarrollo que trabaja constantemente en el desarrollo y la mejora del formato; </li><li>  Hub de shareware para especificaciones; </li><li>  Documentaci√≥n oficial detallada; </li><li>  Umbral de entrada bajo. </li></ul><br>  Contras: <br><br><ul><li>  Soporte de modularidad d√©bil; </li><li>  Falta de ejemplos autogenerados de respuestas a consultas basadas en una descripci√≥n de sus estructuras; </li><li>  A menudo hay problemas con la poca estabilidad de los productos SmartBear (autores fan√°ticos) y la reacci√≥n tard√≠a del desarrollador a esto (la opini√≥n se basa √∫nicamente en la experiencia personal de uso y la experiencia de nuestro equipo). </li></ul><br>  Pero la principal limitaci√≥n que no permite el uso de la OEA como un medio para describir <i>un contrato √∫nico</i> es la falta de la capacidad de adjuntar metainformaci√≥n personalizada para describir par√°metros adicionales de herramientas / bibliotecas de destino. <br>  Por lo tanto, todas las herramientas que funcionan seg√∫n las especificaciones de Swagger deben estar contentas con el conjunto de informaci√≥n que puede acomodar el formato b√°sico. <br><br>  Por ejemplo, la implementaci√≥n de un servidor de API simulado inteligente requiere m√°s informaci√≥n de la que puede proporcionar un documento de especificaci√≥n, raz√≥n por la cual la API de simulaci√≥n Swagger Hub integrada solo es capaz de generar datos falsos basados ‚Äã‚Äãen tipos / estructuras de datos obtenidos de un documento de especificaci√≥n.  Sin lugar a dudas, esto no es suficiente y una funcionalidad de servidor simulado solo puede ser satisfecha por un simple cliente API. <br><br>  En nuestra empresa, durante el desarrollo de uno de los proyectos (servidor React SPA + API), se requer√≠a la siguiente funcionalidad de servidor simulado: <br><br><ul><li>  imitaci√≥n de paginaci√≥n.  El servidor no debe devolver valores completamente aleatorios de los campos currentPage, nextPage, pagesTotal en respuesta a las solicitudes de lista, sino que debe ser capaz de simular el comportamiento real del mecanismo de paginaci√≥n con la generaci√≥n de los valores de estos metapole dependiendo del valor de la p√°gina recibida del cliente; </li><li>  generar cuerpos de respuesta que contienen varios conjuntos de datos dependiendo del par√°metro espec√≠fico de la solicitud entrante; </li><li>  la capacidad de construir relaciones reales entre objetos falsos: el campo <i>foo_id</i> de la entidad <i>Bar</i> deber√≠a referirse a la entidad <i>Foo</i> generada previamente.  Esto se puede lograr agregando soporte de idempotencia al servidor simulado; </li><li>  imitaci√≥n del trabajo de varios m√©todos de autorizaci√≥n: OAuth2, JWT, etc. </li></ul><br>  Sin todo esto, es muy dif√≠cil desarrollar SPA en paralelo con el desarrollo de la parte del servidor del sistema.  Y, al mismo tiempo, dicho servidor simulado, por la raz√≥n descrita anteriormente, es casi imposible de implementar sin una metainformaci√≥n espec√≠fica adicional que podr√≠a almacenarse directamente en la especificaci√≥n API e informarle del comportamiento requerido al simular el siguiente punto final.  Este problema se puede resolver agregando los par√°metros requeridos en forma de un archivo separado con configuraciones paralelas a la especificaci√≥n b√°sica de OAS, pero, en este caso, debe admitir estas dos fuentes diferentes por separado. <br><br>  Si habr√° m√°s de un servidor simulado con herramientas que trabajen en el entorno del proceso de desarrollo de acuerdo con este principio, obtendremos un "zool√≥gico" de herramientas, cada una de las cuales, con su propia funcionalidad √∫nica, se ve obligada a tener su propio archivo de configuraci√≥n √∫nico, vinculado l√≥gicamente a la API base -especificaciones, pero en realidad ubicadas por separado y viviendo "su propia vida". <br><br><img src="https://habrastorage.org/webt/-1/2j/nx/-12jnxo_wzra4vl923py0d4hgnk.png" alt="imagen"><br><br>  Problema: el desarrollador se ver√° obligado a mantener la relevancia de todas las configuraciones despu√©s de cambiar las versiones de la especificaci√≥n base, a menudo en lugares y formatos completamente diferentes. <br><br>  Algunos ejemplos de servicios que funcionan con un principio similar: <br><br><ul><li>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SoapUI</a></i> es un sistema para probar interfaces REST y SOAP.  Admite la importaci√≥n de un proyecto desde la especificaci√≥n Swagger.  Al cambiar la especificaci√≥n b√°sica de Swagger, la configuraci√≥n de un proyecto basada en una lista de llamadas API contin√∫a existiendo en paralelo y requiere sincronizaci√≥n manual; </li><li>  Otros productos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SmartBear</a> ; </li><li>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apigee</a></i> es un servicio de gesti√≥n del ciclo de vida API.  Utiliza las especificaciones de Swagger como plantillas, en base a las cuales permite inicializar sus configuraciones de servicios internos.  Tampoco hay sincronizaci√≥n autom√°tica; </li><li>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Readme.io</a></i> es un servicio que le permite crear documentaci√≥n hermosa basada en la especificaci√≥n Swagger, y tambi√©n tiene un mecanismo para rastrear cambios a la especificaci√≥n b√°sica y resolver conflictos mediante la actualizaci√≥n de la configuraci√≥n del proyecto en el lado del servicio.  Seguramente, esto requer√≠a una complejidad innecesaria para desarrollar este servicio. </li></ul><br>  Puede agregar muchos otros servicios a esta lista que proporcionan la funci√≥n de integraci√≥n con la especificaci√≥n Swagger.  La integraci√≥n para la mayor√≠a de ellos significa la copia habitual de la estructura b√°sica de la especificaci√≥n Swagger y la posterior autocompletaci√≥n de los campos de configuraci√≥n locales sin admitir la sincronizaci√≥n con cambios en la especificaci√≥n b√°sica. <br><br><h3>  RAML, anotaciones, superposiciones </h3><br>  El deseo de encontrar una herramienta que excluya la restricci√≥n de la OEA mencionada anteriormente, lo que nos permite considerar la especificaci√≥n como un contrato √∫nico para todas las herramientas del cliente, nos ha llevado a familiarizarnos con el lenguaje RAML.  Hay bastante escrito sobre RAML, puede leerlo, por ejemplo, aqu√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.infoq.com/articles/power-of-raml</a> .  Los desarrolladores de RAML han intentado establecer el soporte del lenguaje para la modularidad a nivel de su concepto.  Ahora, cada empresa o desarrollador individual puede crear sus propios diccionarios p√∫blicos o utilizarlos al dise√±ar la API, redefinir y heredar modelos de datos preparados.  A partir de la versi√≥n 1.0, RAML admite 5 tipos diferentes de m√≥dulos externos: <i>incluir, biblioteca, extensi√≥n, rasgo, superposici√≥n</i> , lo que permite que cada uno de ellos se use de la manera m√°s flexible posible seg√∫n la tarea. <br><br>  Es hora de discutir la caracter√≠stica principal de RAML, que, por razones que no se entienden completamente, no tiene an√°logos en OEA y Blueprint - Annotations. <br><blockquote>  Las anotaciones en RAML son la capacidad de adjuntar metadatos personalizados a las estructuras de lenguaje subyacentes. </blockquote>  Fue esta funci√≥n RAML la que se convirti√≥ en la raz√≥n para escribir este art√≠culo. <br><br>  Un ejemplo: <br><br><pre><code class="hljs pgsql">#%RAML <span class="hljs-number"><span class="hljs-number">1.0</span></span> title: Example API mediaType: application/<span class="hljs-type"><span class="hljs-type">json</span></span> # Annotation <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> block may be placed <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> file annotationTypes: validation-rules: description: | Describes <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> validation rules <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the model properties. Can be used <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> validation library allowedTargets: [ TypeDeclaration ] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string[] <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-tip: description: | Can be used <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Documentation generator <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> showing tips allowedTargets: [ <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span>, DocumentationItem, TypeDeclaration ] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string condition: description: | Named example can be returned <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> evaluated <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. Can be used <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Intelligent mock <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> allowedTargets: [ Example ] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>: Article: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> properties: id: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-type"><span class="hljs-type">integer</span></span> title: string paragraphs: Paragraph[] createdAt: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string (validation-rules): ["regex:/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?Z?/"] Paragraph: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> properties: <span class="hljs-keyword"><span class="hljs-keyword">order</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-type"><span class="hljs-type">integer</span></span> (validation-rules): ["min:0"] content: string (validation-rules): ["max-length:1024"] /articles/{articleId}: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: (<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-tip): This endpoint <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> deprecated description: <span class="hljs-keyword"><span class="hljs-keyword">Returns</span></span> Article <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ID responses: <span class="hljs-number"><span class="hljs-number">200</span></span>: body: application/<span class="hljs-type"><span class="hljs-type">json</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Article</code> </pre> <br>  Las estructuras de anotaci√≥n del usuario deben tener descripciones claras en RAML.  Para esto, se utiliza una secci√≥n especial de <i>annotationTypes</i> , cuyas definiciones tambi√©n pueden extraerse al m√≥dulo externo.  Por lo tanto, se hace posible definir par√°metros especiales de una herramienta externa en forma de anotaciones adjuntas a la definici√≥n base de la API RAML.  Para evitar saturar la especificaci√≥n b√°sica con una gran cantidad de anotaciones para diversas herramientas externas, existe la posibilidad de transferirlas a archivos separados: <i>superposiciones</i> (y tambi√©n <i>extensiones</i> ), con clasificaci√≥n por alcance.  Esto es lo que se dice sobre las superposiciones en la documentaci√≥n RAML ( <a href="">https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md#overlays</a> ): <br><blockquote>  Una superposici√≥n agrega o anula los nodos de una definici√≥n de API RAML mientras conserva sus aspectos funcionales y de comportamiento.  Ciertos nodos de una definici√≥n de API RAML especifican el comportamiento de una API: sus recursos, m√©todos, par√°metros, cuerpos, respuestas, etc.  Estos nodos no se pueden cambiar aplicando una superposici√≥n.  Por el contrario, otros nodos, como descripciones o anotaciones, abordan inquietudes m√°s all√° de la interfaz funcional, como la documentaci√≥n descriptiva orientada al ser humano en alg√∫n idioma, o la informaci√≥n de implementaci√≥n o verificaci√≥n para su uso en herramientas automatizadas.  Estos nodos se pueden cambiar aplicando una superposici√≥n. <br><br>  Las superposiciones son particularmente importantes para separar la interfaz de la implementaci√≥n.  Las superposiciones permiten ciclos de vida separados para los aspectos de comportamiento de la API que deben controlarse estrictamente, como un contrato entre el proveedor de API y sus consumidores, en comparaci√≥n con aquellos que necesitan poco control, como los aspectos orientados a la implementaci√≥n o humanos que pueden evolucionar en diferentes ritmos  Por ejemplo, agregar ganchos para probar y monitorear herramientas, agregar metadatos relevantes a un registro de API o proporcionar documentaci√≥n humana actualizada o traducida se puede lograr sin cambiar ning√∫n aspecto de los aspectos de comportamiento de la API.  Estas cosas pueden controlarse mediante una versi√≥n rigurosa y un proceso de gesti√≥n de cambios. </blockquote>  En otras palabras, esta funcionalidad le permite "separar el grano de la paja", por ejemplo, la descripci√≥n principal de la especificaci√≥n API, de la metainformaci√≥n adicional espec√≠fica de una herramienta particular que la utiliza para el trabajo.  La metainformaci√≥n en cada superposici√≥n separada se "cuelga" en varios bloques de la especificaci√≥n en forma de anotaciones. <br><br>  Un ejemplo de una estructura b√°sica: <br><br><pre> <code class="hljs pgsql">#%RAML <span class="hljs-number"><span class="hljs-number">1.0</span></span> title: Phrases API mediaType: application/<span class="hljs-type"><span class="hljs-type">json</span></span> <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>: Phrase: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> properties: content: string /phrases: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: queryParameters: whoSaid: string responses: <span class="hljs-number"><span class="hljs-number">200</span></span>: body: application/<span class="hljs-type"><span class="hljs-type">json</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Phrase</code> </pre><br>  Superposici√≥n: <br><pre> <code class="hljs vbscript">#%RAML <span class="hljs-number"><span class="hljs-number">1.0</span></span> Overlay usage: Applies annotations <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Intelligent mock <span class="hljs-built_in"><span class="hljs-built_in">server</span></span> extends: example_for_article_2_1.raml annotationTypes: condition: description: | Named example can be returned <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> evaluated <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> type: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> allowedTargets: Example /phrases: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: responses: <span class="hljs-number"><span class="hljs-number">200</span></span>: body: application/json: examples: firstExample: (condition): $whoSaid <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Hamlet content: <span class="hljs-string"><span class="hljs-string">"To be, or not to be?"</span></span> secondExample: (condition): $whoSaid <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Homer Simpson content: <span class="hljs-string"><span class="hljs-string">"D'oh!"</span></span></code> </pre><br>  Como resultado, se hace posible implementar un contrato √∫nico: toda la informaci√≥n funcional, de comportamiento y meta se almacena y versiona en un solo lugar, y las herramientas del contrato, los clientes del contrato, deben tener soporte para las anotaciones utilizadas en esta especificaci√≥n.  Por otro lado, son las herramientas en s√≠ mismas las que pueden presentar sus propios requisitos para las anotaciones, que deben "colgarse" en la especificaci√≥n; esto proporcionar√° una gama m√°s amplia de posibilidades al desarrollar herramientas de contrato. <br><br>  El concepto anterior se representa en la figura a continuaci√≥n: <br><br><img src="https://habrastorage.org/webt/w1/0i/aj/w10iajxxllknypbvu6gwcvwrtkc.png" alt="imagen"><br><br>  Entre los inconvenientes de este enfoque, se puede destacar la alta complejidad de la sincronizaci√≥n manual del archivo de especificaci√≥n base y cada una de las superposiciones: al actualizar la estructura de la especificaci√≥n b√°sica, debe aplicar los cambios necesarios en las estructuras de las superposiciones.  Este problema se vuelve m√°s grave cuando aparece m√°s de una superposici√≥n. <br><br>  Una soluci√≥n posible y m√°s obvia ser√≠a desarrollar un editor especial o complemento para el editor RAML en l√≠nea existente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/mulesoft/api-designer</a> .  El √°rea de edici√≥n permanece sin cambios, pero es posible crear pesta√±as: cada nueva pesta√±a es una ventana para editar la superposici√≥n asignada a ella.  Al editar la estructura b√°sica de la especificaci√≥n en la ventana principal, las estructuras en todas las pesta√±as creadas tambi√©n cambian, y cuando se detecta una incompatibilidad de la nueva estructura con las anotaciones existentes ubicadas en las pesta√±as superpuestas, aparece una advertencia.  Una consideraci√≥n m√°s detallada de dicho editor es un tema aparte y merece una seria consideraci√≥n. <br><br><h3>  Desarrollos existentes </h3><br>  En la b√∫squeda de soluciones existentes que est√°n cerca de darse cuenta de la idea de usar anotaciones como un medio para describir la metainformaci√≥n, se encontraron las siguientes soluciones: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/raml-org/raml-annotations</a> repositorio que contiene anotaciones oficiales aprobadas por la comunidad de desarrolladores RAML.  En la versi√≥n actual, solo est√°n disponibles las anotaciones de OAuth2.  Pueden ser utilizados por herramientas externas para obtener metainformaci√≥n que describa aspectos de la implementaci√≥n de OAuth2 para la especificaci√≥n API desarrollada; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/petrochenko-pavel-a/raml-annotations</a> biblioteca de anotaciones de usuario <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@ petrochenko-pavel-a</a> con una agrupaci√≥n l√≥gica por √°rea de aplicaci√≥n.  El proyecto es m√°s experimental, pero ilustra perfectamente la idea de usar anotaciones.  Los grupos de anotaciones m√°s interesantes: <br><ul><li>  <i>AdditionalValidation.raml</i> : anotaciones para describir reglas adicionales para la validaci√≥n de modelos de especificaci√≥n.  Pueden ser utilizados, por ejemplo, por la biblioteca del servidor para validar consultas de acuerdo con la especificaci√≥n RAML; </li><li>  <i>mock.raml</i> : anotaciones para describir los detalles del servidor falso basado en la especificaci√≥n RAML; </li><li>  <i>semanticContexts.raml</i> : anotaciones que apuntan al contexto sem√°ntico de los bloques estructurales individuales declarados de la especificaci√≥n RAML; </li><li>  <i>estructural.raml</i> : anotaciones que aclaran el papel de una entidad RAML separada en la estructura general del modelo de dominio descrito; </li><li>  <i>uiCore.raml</i> : un ejemplo de anotaciones posibles para el uso de herramientas de generaci√≥n de interfaz de usuario basadas en la especificaci√≥n RAML; </li></ul></li></ul><br>  El repositorio tambi√©n contiene bibliotecas de tipos de utilidad adecuados para su uso como primitivas en la descripci√≥n de estructuras de datos de la especificaci√≥n RAML. <br><br><h3>  Problemas RAML </h3><br>  A pesar de la funcionalidad, la progresividad de la idea b√°sica y la atenci√≥n de los grandes fabricantes de software (cisco, spotify, vmware, etc.), RAML hoy tiene serios problemas que pueden llegar a ser fatales con respecto a su destino exitoso: <br><br><ul><li>  Comunidad de c√≥digo abierto peque√±a y fragmentada; </li><li>  Una estrategia incomprensible del desarrollador principal de RAML es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mulesoft</a> .  La compa√±√≠a desarrolla productos que son solo una copia de las soluciones existentes basadas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OAS</a> (incluidas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Anypoint Platform</a> ), en lugar de crear servicios que enfaticen las ventajas de RAML sobre Swagger; </li><li>  La consecuencia del primer p√°rrafo: un peque√±o n√∫mero de bibliotecas / herramientas de c√≥digo abierto; </li><li>  Umbral de entrada m√°s alto que la OEA (esto es extra√±o, pero mucha gente piensa que s√≠); </li><li>  Debido a la gran cantidad de errores y problemas con UX / UI, el servicio principal que es completamente inadecuado y repele a los usuarios es el punto de entrada a RAML: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://anypoint.mulesoft.com/</a> . </li></ul><br><h3>  Desacuerdo conceptual.  Primera conclusi√≥n </h3><br>  Hay contradicciones dentro de la comunidad con respecto al concepto b√°sico.  Alguien piensa que RAML es un <i>lenguaje de definici√≥n de modelo</i> , y alguien piensa que es un <i>lenguaje de definici√≥n de API</i> como OAS o Blueprint (los tipos que se hacen llamar desarrolladores RAML a menudo mencionan esto en varios comentarios).  El concepto de <i>lenguaje de definici√≥n</i> de <i>modelo</i> permitir√≠a dentro de la especificaci√≥n RAML describir el modelo de dominio del dominio sin vinculaci√≥n estrecha con el contexto de la descripci√≥n del recurso API, expandiendo los horizontes de las opciones para usar la especificaci√≥n con herramientas externas (de hecho, ¬°creando la base para la existencia de este <i>contrato √önico</i> !)  Aqu√≠ se puede ver una definici√≥n del concepto de un recurso en el sitio web readhat docs ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://restful-api-design.readthedocs.io/en/latest/resources.html</a> , por cierto, recomiendo a todos leer esta maravillosa gu√≠a sobre dise√±o de API): <br><blockquote>  Llamamos a la informaci√≥n que describe los <b><i>tipos de recursos</i></b> disponibles, su comportamiento y sus relaciones, <b><i>el modelo de recursos de una API</i></b> .  <i><b>El modelo de recursos</b></i> se puede ver como la asignaci√≥n RESTful del <b><i>modelo de datos</i></b> de <b><i>la aplicaci√≥n</i></b> . </blockquote>  En el <i><b>modelo de datos de la aplicaci√≥n</b></i> RAML <i><b>,</b></i> estos son tipos declarados en el bloque de <i>tipos</i> , y el <b><i>modelo de recursos de una API</i></b> es lo que se describe en el bloque RAML de <i>recursos</i> .  Por lo tanto, debe tener la capacidad de describir esta <i><b>asignaci√≥n</b></i> .  Pero la implementaci√≥n actual de RAML permite que dicha <b><i>asignaci√≥n</i></b> se realice solo de 1 a 1, es decir, para usar los tipos "tal cual" dentro de la declaraci√≥n de API de recursos. <br><br>  Creo que este es el principal problema del lenguaje, cuya soluci√≥n permitir√° que RAML vaya m√°s all√° del <i>lenguaje de definici√≥n API</i> y se convierta en un <i>lenguaje de definici√≥n de modelo</i> completo: un lenguaje m√°s general (en lugar de OEA o Blueprint) utilizado para describir los contratos individuales de sistemas, que en esencia son el n√∫cleo formal Muchos de sus componentes. <br><br>  Lo anterior convierte a RAML en un jugador d√©bil que actualmente no puede ganar la competencia contra Swagger.  Quiz√°s es por eso que, como resultado, el desarrollador principal de RAML tom√≥ medidas dr√°sticas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://blogs.mulesoft.com/dev/api-dev/open-api-raml-better-together/</a> <br><br><h3>  La idea del contrato √∫nico RAML SaaS </h3><br>  Basado en el concepto de <i>contrato √∫nico</i> , a partir de la idea de alojar una API de especificaciones Swagger basada en la OAS de especificaciones, adem√°s de confiar en la posibilidad de que RAML declare metainformaci√≥n y comparta la especificaci√≥n b√°sica usando superposiciones, la idea de una soluci√≥n SaaS alternativa para alojar y administrar especificaciones basadas en el lenguaje RAML sugiere Supere el Swagger Hub y Apiary en el volumen y la calidad de la posible funcionalidad. <br><br>  El nuevo servicio, por analog√≠a con el centro Swagger, ser√° el alojamiento de contratos de usuarios con la provisi√≥n de un editor en l√≠nea y la capacidad de ver previsualizaciones de documentaci√≥n con actualizaciones en tiempo real.  La principal diferencia deber√≠a ser la presencia de un cat√°logo de complementos de contrato integrados en el servicio, cualquiera de los cuales el usuario podr√° instalar especificaciones de API en su proyecto actual.  Para la instalaci√≥n, ser√° necesario implementar las anotaciones RAML requeridas especificadas en la documentaci√≥n del complemento.  Despu√©s de agregar un nuevo complemento al proyecto, se agregar√° una nueva pesta√±a en la ventana del editor de c√≥digo cuando lo cambie, las anotaciones de edici√≥n del complemento instalado estar√°n disponibles.  La estructura de la especificaci√≥n b√°sica debe duplicarse autom√°ticamente en todas las pesta√±as correspondientes a los complementos.  Si surgen conflictos entre la estructura b√°sica y las anotaciones ya existentes, un mecanismo especial debe ofrecer opciones para su soluci√≥n, o resolverlo autom√°ticamente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/le/5g/go/le5ggomtfukodgechbdyhugpafq.png" alt="imagen"></div><br>  T√©cnicamente, cada pesta√±a ser√° una abstracci√≥n de la superposici√≥n RAML que contiene anotaciones de cada complemento espec√≠fico.  Esto asegura que la especificaci√≥n sea compatible con cualquier herramienta que soporte RAML 1.0. <br><br>  El directorio de complementos debe estar abierto para la expansi√≥n de la comunidad de c√≥digo abierto.  La implementaci√≥n de complementos pagados tambi√©n es posible, lo que puede servir como un incentivo para el desarrollo de nuevos. <br><br>  Posibles complementos: documentaci√≥n API con soporte para una gran cantidad de anotaciones para la parametrizaci√≥n flexible de su representaci√≥n, servidor simulado "inteligente" (del ejemplo anterior), bibliotecas descargables para validar solicitudes o generaci√≥n de c√≥digo, herramientas de depuraci√≥n para solicitudes API salientes para aplicaciones m√≥viles (proxy de almacenamiento en cach√©), pruebas de carga con la configuraci√≥n de pruebas de flujo a trav√©s de anotaciones, varios complementos para la integraci√≥n con servicios externos. <br><br>  Esta idea del servicio contiene claras ventajas sobre los servicios existentes para administrar las especificaciones de la API, y su implementaci√≥n allana el camino para un posible cambio en el enfoque de la implementaci√≥n de cualquier sistema externo que de alguna manera est√© relacionado con la API. <br><br><h3>  Segunda conclusi√≥n </h3><br>  El prop√≥sito de este art√≠culo no es criticar a Swagger, Apiary u otras herramientas est√°ndar de facto para desarrollar API, sino m√°s bien examinar la diferencia conceptual con el enfoque de las especificaciones de dise√±o promovidas por RAML, intentar <i>primero</i> introducir el concepto de <i>Contrato</i> y considerar la posibilidad de su implementaci√≥n basada en RAML.  Otro objetivo era el deseo de atraer la merecida atenci√≥n de los desarrolladores a RAML para el posible desarrollo de su comunidad. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sitio oficial RAML</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Canal flojo</a> <br>  <a href="">Especificaci√≥n</a> <br><br>  Gracias por su atencion </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419525/">https://habr.com/ru/post/es419525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es419511/index.html">tipo de (T) vs. TypeOf‚ü®T‚ü©</a></li>
<li><a href="../es419513/index.html">Configurar la pol√≠tica de seguridad de contrase√±a en Zimbra</a></li>
<li><a href="../es419515/index.html">C√≥mo una startup "sin marca" obtuvo $ 240 millones para derrotar a Amazon</a></li>
<li><a href="../es419519/index.html">Consejos para juegos m√≥viles: Parte 1, lanzamiento suave</a></li>
<li><a href="../es419523/index.html">El equipo de PVS-Studio es imparcial al escribir art√≠culos</a></li>
<li><a href="../es419527/index.html">C√≥mo suena el latido del coraz√≥n: convertir el cardiograma de papel al formato WAV</a></li>
<li><a href="../es419531/index.html">Elegir el par perfecto para tus o√≠dos: diez consejos pr√°cticos</a></li>
<li><a href="../es419535/index.html">Actualizaci√≥n en tostadora</a></li>
<li><a href="../es419539/index.html">Webinar abierto "Programaci√≥n asincr√≥nica en Python"</a></li>
<li><a href="../es419547/index.html">Organizar un resumen de registro regular con python y ansible usando un asterisco como ejemplo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>