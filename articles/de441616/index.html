<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•£ üòÆ üëáüèø Likbez startet Istio üëãüèø üë®üèΩ‚Äç‚úàÔ∏è ü§Ωüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Isstio Service Mesh 


 Wir bei Namely verwenden Istio seit einem Jahr. Er ist dann einfach gegangen. Wir hatten einen gro√üen Leistungsabfall im Kuber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Likbez startet Istio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/441616/"><p> <a href=""><img src="https://habrastorage.org/webt/sh/m2/ja/shm2jainigjyhqewoqvi4cxdlg0.jpeg"></a> <br>  <em>Isstio Service Mesh</em> </p><br><p>  Wir bei Namely verwenden Istio seit einem Jahr.  Er ist dann einfach gegangen.  Wir hatten einen gro√üen Leistungsabfall im Kubernetes-Cluster, wir wollten verteiltes Tracing und nahmen Istio mit, um Jaeger auszuf√ºhren und es herauszufinden.  Service Mesh passt so gut in unsere Infrastruktur, dass wir uns entschlossen haben, in dieses Tool zu investieren. </p><br><p>  Ich musste leiden, aber wir haben es weit und breit studiert.  Dies ist der erste Beitrag in einer Reihe, in der ich beschreiben werde, wie Istio sich in Kubernetes integriert und was wir √ºber seine Arbeit gelernt haben.  Manchmal wandern wir in die technische Wildnis, aber nicht sehr weit.  Weiter wird es weitere Beitr√§ge geben. </p><a name="habracut"></a><br><h3 id="chto-takoe-istio">  Was ist Istio? </h3><br><p>  Istio ist ein Service-Mesh-Konfigurationstool.  Es liest den Status des Kubernetes-Clusters und aktualisiert die L7-Proxys (HTTP und gRPC), die als Sidecar in Kubernetes-Pods implementiert sind.  Bei diesem Beiwagen handelt es sich um Envoy-Container, die die Konfiguration von der Istio Pilot-API (und dem gRPC-Dienst) lesen und den Verkehr durch diese leiten.  Mit dem leistungsstarken L7-Proxy unter der Haube k√∂nnen wir Metriken, Traces, Wiederholungslogik, Leistungsschalter, Lastausgleich und kanarische Bereitstellungen verwenden. </p><br><h3 id="nachnem-s-nachala-kubernetes">  Beginnen wir von vorne: Kubernetes </h3><br><p> In Kubernetes erstellen wir unter Verwendung eines Deployments oder StatefulSets.  Oder es kann einfach "Vanille" ohne einen High-Level-Controller sein.  Dann bem√ºht sich Kubernetes, den gew√ºnschten Status beizubehalten - es erstellt Pods im Cluster auf dem Knoten und stellt sicher, dass sie gestartet und neu gestartet werden.  Wenn ein Under erstellt wird, durchl√§uft Kubernetes den API-Lebenszyklus, stellt sicher, dass jeder Schritt erfolgreich ist, und erstellt erst dann das Under im Cluster. </p><br><p>  API-Lebenszyklusphasen: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/dl/dc/t5/dldct5fzrxubc5c1z3zt2m7lchu.png"></a> <br>  <em>Danke an Banzai Cloud f√ºr das coole Bild.</em> </p><br><p>  Einer der Schritte ist das √Ñndern von Zulassungs-Webhooks.  Dies ist ein separater Teil des Lebenszyklus in Kubernetes, in dem Ressourcen angepasst werden, bevor sie in das etcd-Repository √ºbertragen werden, die Quelle der Wahrheit f√ºr die Kubernetes-Konfiguration.  Und hier macht Istio seine Magie. </p><br><h3 id="modificiruyuschie-vebhuki-dopuska">  Zulassungs-Webhooks √§ndern </h3><br><p> Wenn ein Sub erstellt wird (√ºber <code>kubectl</code> oder <code>Deployment</code> ), durchl√§uft es diesen Lebenszyklus, und durch Zugriff auf modifizierende Webhooks wird es ge√§ndert, bevor es f√ºr die gro√üe Welt freigegeben wird. </p><br><p>  W√§hrend der Installation von Istio wird der Istio-Sidecar-Injektor als Konfigurationsressource zum √Ñndern von Webhooks hinzugef√ºgt: </p><br><pre> <code class="plaintext hljs">$ kubectl get mutatingwebhookconfiguration NAME AGE istio-sidecar-injector 87d</code> </pre> <br><p>  Und die Konfiguration: </p><br><pre> <code class="plaintext hljs">apiVersion: admissionregistration.k8s.io/v1beta1 kind: MutatingWebhookConfiguration metadata: labels: app: istio-sidecar-injector chart: sidecarInjectorWebhook-1.0.4 heritage: Tiller name: istio-sidecar-injector webhooks: - clientConfig: caBundle: redacted service: name: istio-sidecar-injector namespace: istio-system path: /inject failurePolicy: Fail name: sidecar-injector.istio.io namespaceSelector: matchLabels: istio-injection: enabled rules: - apiGroups: - "" apiVersions: - v1 operations: - CREATE resources: - pods</code> </pre> <br><p>  Hier hei√üt es, dass Kubernetes alle <code>istio-sidecar-injector</code> an den <code>istio-sidecar-injector</code> <code>istio-system</code> im <code>istio-system</code> Namespace senden soll, wenn f√ºr den Namespace <code>istio-injection=enabled</code> .  Der Injektor enth√§lt zwei weitere Container in PodSpec: einen tempor√§ren zum Festlegen von Proxy-Regeln und einen zum Proxy selbst.  Der Beiwageninjektor setzt diese Beh√§lter gem√§√ü der Vorlage aus der Konfigurationskarte des <code>istio-sidecar-injector</code> .  Dieser Vorgang wird auch als Sidecaring bezeichnet. </p><br><h3 id="sidecar-pody">  Beiwagenkapseln </h3><br><p>  Beiwagen sind die Tricks unseres Magiers Istio.  Istio dreht alles so geschickt, dass es von au√üen einfach magisch ist, wenn Sie die Details nicht kennen.  Und es ist n√ºtzlich, sie zu kennen, wenn Sie pl√∂tzlich Netzwerkanforderungen debuggen m√ºssen. </p><br><h3 id="init--i-proksi-konteynery">  Init- und Proxy-Container </h3><br><p>  Kubernetes verf√ºgt √ºber tempor√§re einmalige Init-Container, die vor den Hauptcontainern ausgef√ºhrt werden k√∂nnen.  Sie b√ºndeln Ressourcen, migrieren Datenbanken oder konfigurieren, wie bei Istio, Netzwerkregeln. </p><br><p>  Istio verwendet Envoy, um alle Anfragen an Einreichungen entlang der gew√ºnschten Routen zu senden.  Zu diesem Zweck erstellt Istio <code>iptables</code> Regeln, die eingehenden und ausgehenden Datenverkehr direkt an Envoy senden und den Datenverkehr sauber an sein Ziel weiterleiten.  Der Datenverkehr macht einen kleinen Umweg, aber Sie haben die Ablaufverfolgung, Abfragemetriken und die Durchsetzung von Richtlinien verteilt.  In dieser Datei k√∂nnen Sie im Istio-Repository <a href="">sehen,</a> wie Istio iptables-Regeln erstellt. </p><br><p>  <a href="">@jimmysongio hat</a> ein hervorragendes Verbindungsdiagramm zwischen den iptables-Regeln und dem Envoy-Proxy erstellt: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/yl/3m/yc/yl3myca7qv4esodpj8a7iwsp6bc.jpeg"></a> <br>  <em>Gesandter - Gesandterverkehr</em> </p><br><p>  Envoy empf√§ngt den gesamten eingehenden und ausgehenden Verkehr, sodass sich der gesamte Verkehr im Allgemeinen innerhalb von Envoy bewegt, wie in der Abbildung dargestellt.  Der Istio-Proxy ist ein weiterer Container, der allen vom Istio-Beiwageninjektor modifizierten Pods hinzugef√ºgt wird.  In diesem Container wird der Envoy-Prozess gestartet, der den gesamten Datenverkehr vom Herd empf√§ngt (mit einigen Ausnahmen, z. B. Datenverkehr von Ihrem Kubernetes-Cluster). </p><br><p>  Der Envoy-Prozess erkennt alle Routen √ºber die Envoy v2-API, die Istio implementiert. </p><br><h3 id="envoy-i-pilot">  Gesandter und Pilot </h3><br><p>  Envoy selbst hat keine Logik zum Erkennen von Pods und Diensten in einem Cluster.  Es ist eine Datenebene und ben√∂tigt eine Steuerebene zur F√ºhrung.  Der Envoy-Konfigurationsparameter fordert den Host oder Service-Port auf, diese Konfiguration √ºber die gRPC-API zu erhalten.  Istio erf√ºllt √ºber seinen Pilotdienst die Anforderungen f√ºr die gRPC-API.  Envoy stellt eine Verbindung zu dieser API her, basierend auf einer Sidecar-Konfiguration, die √ºber einen modifizierenden Webhook implementiert wird.  Die API verf√ºgt √ºber alle Verkehrsregeln, die Envoy zum Erkennen und Weiterleiten f√ºr den Cluster ben√∂tigt.  Dies ist das Service-Mesh. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/lr/kn/bz/lrknbzkkjqescnkyh6k1voy_nyk.png"></a> <br>  <em>Datenaustausch "unter dem &lt;-&gt; Piloten"</em> </p><br><p>  Pilot stellt eine Verbindung zum Kubernetes-Cluster her, liest den Clusterstatus und wartet auf Aktualisierungen.  Es √ºberwacht die Pods, Dienste und Endpunkte im Kubernetes-Cluster, um dann allen mit dem Piloten verbundenen Envoy-Beiwagen die richtige Konfiguration zu geben.  Dies ist die Br√ºcke zwischen Kubernetes und Envoy. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/fg/no/hj/fgnohjdngxbyn8kj5u_udcvl6x0.png"></a> <br>  <em>Vom Piloten zum Kubernetes</em> </p><br><p>  Wenn Pods, Dienste oder Endpunkte in Kubernetes erstellt oder aktualisiert werden, erf√§hrt Pilot davon und sendet die erforderliche Konfiguration an alle verbundenen Envoy-Instanzen. </p><br><h3 id="kakaya-konfiguraciya-otpravlyaetsya">  Welche Konfiguration wird gesendet? </h3><br><p>  Welche Konfiguration erh√§lt der Gesandte vom Istio-Piloten? </p><br><p>  Standardm√§√üig l√∂st Kubernetes Ihre Netzwerkprobleme mit einem Dienst, der <code>endpoint</code> verwaltet.  Die Liste der Endpunkte kann mit dem folgenden Befehl ge√∂ffnet werden: </p><br><pre> <code class="plaintext hljs">kubectl get endpoints</code> </pre> <br><p>  Dies ist eine Liste aller IP-Adressen und Ports im Cluster und ihrer Adressen (normalerweise sind dies Pods, die aus einer Bereitstellung erstellt wurden).  Istio ist wichtig zu wissen, um Routendaten zu konfigurieren und an Envoy zu senden. </p><br><h3 id="servisy-proslushivateli-i-marshruty">  Dienste, Listener und Routen </h3><br><p>  Wenn Sie einen Dienst in einem Kubernetes-Cluster erstellen, f√ºgen Sie Verkn√ºpfungen hinzu, mit denen alle geeigneten Pods ausgew√§hlt werden.  Wenn Sie Datenverkehr an die IP des Dienstes senden, w√§hlt Kubernetes den Datenverkehr f√ºr diesen Datenverkehr aus.  Zum Beispiel der Befehl </p><br><pre> <code class="plaintext hljs">curl my-service.default.svc.cluster.local:3000</code> </pre> <br><p>  Zun√§chst wird die dem <code>my-service</code> zugewiesene virtuelle IP im <code>default</code> Namespace gefunden, und diese IP leitet den Datenverkehr an ein Sub weiter, das der Dienstbezeichnung entspricht. </p><br><p>  Istio und Envoy √§ndern diese Logik leicht.  Istio konfiguriert Envoy basierend auf den Diensten und Endpunkten im Kubernetes-Cluster und verwendet die intelligenten Routing- und Lastausgleichsfunktionen von Envoy, um den Kubernetes-Dienst zu umgehen.  Anstatt jeweils nur eine IP zu √ºbertragen, stellt Envoy eine direkte Verbindung zum IP-Herd her.  <strong>Zu diesem Zweck ordnet Istio die Kubernetes-Konfiguration der Envoy-Konfiguration zu</strong> . </p><br><p>  Die Begriffe Kubernetes, Istio und Envoy unterscheiden sich geringf√ºgig, und es ist nicht sofort klar, was sie essen. </p><br><h3 id="servisy">  Dienstleistungen </h3><br><p>  Ein Dienst in Kubernetes wird einem <strong>Cluster</strong> in Envoy zugeordnet.  Der Envoy-Cluster enth√§lt eine Liste von <strong>Endpunkten</strong> , dh die IP (oder Hostnamen) der Instanzen f√ºr die Verarbeitung von Anforderungen.  F√ºhren Sie <code>istioctl proxy-config cluster &lt; &gt;</code> um die Liste der im Istio Sidecar-Pod konfigurierten Cluster anzuzeigen.  Dieser Befehl zeigt den aktuellen Stand der Dinge in Bezug auf den Herd.  Hier ist ein Beispiel aus einer unserer Umgebungen: </p><br><pre> <code class="plaintext hljs">$ istioctl proxy-config cluster taxparams-6777cf899c-wwhr7 -n applications SERVICE FQDN PORT SUBSET DIRECTION TYPE BlackHoleCluster - - - STATIC accounts-grpc-gw.applications.svc.cluster.local 80 - outbound EDS accounts-grpc-public.applications.svc.cluster.local 50051 - outbound EDS addressvalidator.applications.svc.cluster.local 50051 - outbound EDS</code> </pre> <br><p>  Alle gleichen Dienste befinden sich in diesem Namespace: </p><br><pre> <code class="plaintext hljs">$ kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) accounts-grpc-gw ClusterIP 10.3.0.91 &lt;none&gt; 80/TCP accounts-grpc-public ClusterIP 10.3.0.202 &lt;none&gt; 50051/TCP addressvalidator ClusterIP 10.3.0.56 &lt;none&gt; 50051/TCP</code> </pre> <br><p>  Woher wei√ü Istio, welches Protokoll den Dienst verwendet?  Konfiguriert Protokolle f√ºr Dienstmanifeste anhand des Namensfelds im Porteintrag. </p><br><pre> <code class="plaintext hljs">$ kubectl get service accounts-grpc-public -o yaml apiVersion: v1 kind: Service metadata: name: accounts-grpc-public spec: ports: - name: grpc port: 50051 protocol: TCP targetPort: 50051</code> </pre> <br><p>  Wenn es <code>grpc</code> oder das <code>grpc-</code> Pr√§fix gibt, konfiguriert Istio das HTTP2-Protokoll f√ºr den Dienst.  Wir haben durch bittere Erfahrung gelernt, wie Istio den Portnamen verwendet, wenn Proxy-Konfigurationen besch√§digt sind, weil sie keine http- oder grpc-Pr√§fixe angegeben haben ... </p><br><p>  Wenn Sie kubectl und die Admin-Port-Weiterleitungsseite in Envoy verwenden, k√∂nnen Sie sehen, dass die Konto-grpc-public-Endpunkte von Pilot als Cluster in Envoy mit dem HTTP2-Protokoll implementiert werden.  Dies best√§tigt unsere Annahmen: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward otherpod-dc56885ff-dqc6t 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... - cluster: circuit_breakers: thresholds: - {} connect_timeout: 1s eds_cluster_config: eds_config: ads: {} service_name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local http2_protocol_options: max_concurrent_streams: 1073741824 name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local type: EDS ...</code> </pre> <br><p>  Port 15000 ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Envoy-Administrationsseite</a> , die auf jedem Beiwagen verf√ºgbar ist. </p><br><h3 id="proslushivateli">  Zuh√∂rer </h3><br><p>  Listener erkennen Kubernetes-Endpunkte, um Datenverkehr an die Herde weiterzuleiten.  Der Adress√ºberpr√ºfungsdienst hat hier einen Endpunkt: </p><br><pre> <code class="plaintext hljs">$ kubectl get ep addressvalidator -o yaml apiVersion: v1 kind: Endpoints metadata: name: addressvalidator subsets: - addresses: - ip: 10.2.26.243 nodeName: ip-10-205-35-230.ec2.internal targetRef: kind: Pod name: addressvalidator-64885ccb76-87l4d namespace: applications ports: - name: grpc port: 50051 protocol: TCP</code> </pre> <br><p>  Daher verf√ºgt der Adress√ºberpr√ºfungsherd √ºber einen Listener an Port 50051: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward addressvalidator-64885ccb76-87l4d 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... dynamic_active_listeners: - version_info: 2019-01-13T18:39:43Z/651 listener: name: 10.2.26.243_50051 address: socket_address: address: 10.2.26.243 port_value: 50051 filter_chains: - filter_chain_match: transport_protocol: raw_buffer ...</code> </pre> <br><h3 id="marshruty">  Routen </h3><br><p>  In Istio wird anstelle des Standardobjekts von Kubernetes Ingress eine abstraktere und effizientere benutzerdefinierte Ressource verwendet - <code>VirtualService</code> .  VirtualService ordnet Routen Upstream-Clustern zu, indem sie an das Gateway gebunden werden.  So verwenden Sie Kubernetes Ingress mit einem Ingress-Controller. </p><br><p>  Wir verwenden n√§mlich das Istio Ingress-Gateway f√ºr den gesamten internen GRPC-Verkehr: </p><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: grpc-gateway spec: selector: istio: ingressgateway servers: - hosts: - '*' port: name: http2 number: 80 protocol: HTTP2 --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: grpc-gateway spec: gateways: - grpc-gateway hosts: - '*' http: - match: - uri: prefix: /namely.address_validator.AddressValidator retries: attempts: 3 perTryTimeout: 2s route: - destination: host: addressvalidator port: number: 50051</code> </pre> <br><p>  Auf den ersten Blick werden Sie im Beispiel nichts verstehen.  Hier ist es nicht sichtbar, aber die Istio-IngressGateway-Bereitstellung zeichnet basierend auf der <code>istio: ingressgateway</code> auf, welche Endpunkte ben√∂tigt werden.  In diesem Beispiel leitet IngressGateway den Datenverkehr f√ºr alle Dom√§nen √ºber Port 80 √ºber HTTP2 weiter.  VirtualService implementiert Routen f√ºr dieses Gateway, stimmt mit dem Pr√§fix <code>/namely.address_validator.AddressValidator</code> und √ºbergibt den <code>addressvalidator</code> √ºber den Port 50051 <code>addressvalidator</code> einer Wiederholungsregel in zwei Sekunden an den Upstream-Service. </p><br><p>  Wenn wir den Pod-Port von Istio-IngressGateway umleiten und die Konfiguration von Envoy sehen, werden wir sehen, was VirtualService tut: </p><br><pre> <code class="plaintext hljs">$ kubectl -n istio-system port-forward istio-ingressgateway-7477597868-rldb5 15000 ... - match: prefix: /namely.address_validator.AddressValidator route: cluster: outbound|50051||addressvalidator.applications.svc.cluster.local timeout: 0s retry_policy: retry_on: 5xx,connect-failure,refused-stream num_retries: 3 per_try_timeout: 2s max_grpc_timeout: 0s decorator: operation: addressvalidator.applications.svc.cluster.local:50051/namely.address_validator.AddressValidator* ...</code> </pre> <br><h3 id="chto-my-guglili-kopayas-v-istio">  Was wir beim Graben in Istio gegoogelt haben </h3><br><p>  <strong>Fehler 503 oder 404 tritt auf</strong> </p><br><p>  Die Gr√ºnde sind unterschiedlich, aber normalerweise sind dies: </p><br><ul><li>  Beiwagenanwendungen k√∂nnen Pilot nicht kontaktieren (√ºberpr√ºfen Sie, ob Pilot ausgef√ºhrt wird). </li><li>  Das Kubernetes-Dienstmanifest hat ein ung√ºltiges Protokoll. </li><li>  Die VirtualService / Envoy-Konfiguration schreibt die Route in den falschen Upstream-Cluster.  Beginnen Sie mit dem Edge-Service, bei dem Sie eingehenden Datenverkehr erwarten, und √ºberpr√ºfen Sie die Envoy-Protokolle.  Oder verwenden Sie etwas wie Jaeger, um Fehler zu finden. </li></ul><br><p>  <strong>Was bedeutet NR / UH / UF in Istio-Proxy-Protokollen?</strong> </p><br><ul><li>  NR - Keine Route. </li><li>  UH - Upstream Ungesund (Upstream nicht funktionsf√§hig). </li><li>  UF - Upstream-Fehler (Upstream-Fehler). </li></ul><br><p>  Lesen Sie mehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Envoy-Website</a> . </p><br><p>  <strong>In Bezug auf Hochverf√ºgbarkeit mit Istio</strong> </p><br><ul><li>  F√ºgen Sie den Istio-Komponenten NodeAffinity hinzu, um die Herde gleichm√§√üig auf verschiedene Verf√ºgbarkeitszonen zu verteilen und die Mindestanzahl an Replikaten zu erh√∂hen. </li><li>  Starten Sie die neue Version von Kubernetes mit der Funktion zur automatischen Skalierung horizontaler Pods.  Die wichtigsten Herde werden je nach Belastung skaliert. </li></ul><br><p>  <strong>Warum endet Cronjob nicht?</strong> </p><br><p>  Wenn die Hauptauslastung abgeschlossen ist, arbeitet der Beiwagencontainer weiter.  Um das Problem zu umgehen, deaktivieren Sie den Beiwagen in Cronjobs, indem Sie <code>sidecar.istio.io/inject: ‚Äúfalse‚Äù</code> die Anmerkung <code>sidecar.istio.io/inject: ‚Äúfalse‚Äù</code> hinzuf√ºgen. </p><br><p>  <strong>Wie installiere ich Istio?</strong> </p><br><p>  Wir verwenden Spinnaker f√ºr Bereitstellungen, aber wir nehmen normalerweise die neuesten Helm-Diagramme, zaubern sie, verwenden die <code>helm template -f values.yml</code> und <code>helm template -f values.yml</code> Dateien auf Github fest, um die √Ñnderungen zu sehen, bevor wir sie √ºber <code>kubectl apply -f -</code> .  Dies dient dazu, die CRD oder API in verschiedenen Versionen nicht versehentlich zu √§ndern. </p><br><p>  Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bobby Tables</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Michael Hamrah</a> f√ºr die Unterst√ºtzung beim Schreiben dieses Beitrags. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441616/">https://habr.com/ru/post/de441616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441600/index.html">Schwache Benutzeroberfl√§che, schwacher Programmierer</a></li>
<li><a href="../de441602/index.html">Warum ein klassisches Automatikauto unm√∂glich ist und keine kommerziellen Perspektiven hat</a></li>
<li><a href="../de441604/index.html">Chinas nationale √úberwachungssysteme: eine Quelle nicht nur f√ºr Daten, sondern auch f√ºr ein stabiles Einkommen</a></li>
<li><a href="../de441606/index.html">Fast zuverl√§ssige L√∂sungen</a></li>
<li><a href="../de441610/index.html">LED liegt in beispiellosen Ausma√üen</a></li>
<li><a href="../de441618/index.html">Erstellung der unteren Navigationsleiste auf Kotlin mit Anko</a></li>
<li><a href="../de441626/index.html">Workshop zum industriellen 3D-Druck: 1. M√§rz im Calibre Technopark</a></li>
<li><a href="../de441628/index.html">2018 Bewertung der IT-Arbeitgeber in Sankt Petersburg und Moskau: Ergebnisse einer Umfrage unter Entwicklern</a></li>
<li><a href="../de441632/index.html">1. M√§rz - Teamlead Meetup: Mitarbeiterbewertung und Motivation</a></li>
<li><a href="../de441634/index.html">Gibt es Leben unter Windows 98, Teil zwei - √ºber Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>