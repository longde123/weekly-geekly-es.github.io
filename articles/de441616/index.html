<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥣 😮 👇🏿 Likbez startet Istio 👋🏿 👨🏽‍✈️ 🤽🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Isstio Service Mesh 


 Wir bei Namely verwenden Istio seit einem Jahr. Er ist dann einfach gegangen. Wir hatten einen großen Leistungsabfall im Kuber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Likbez startet Istio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/441616/"><p> <a href=""><img src="https://habrastorage.org/webt/sh/m2/ja/shm2jainigjyhqewoqvi4cxdlg0.jpeg"></a> <br>  <em>Isstio Service Mesh</em> </p><br><p>  Wir bei Namely verwenden Istio seit einem Jahr.  Er ist dann einfach gegangen.  Wir hatten einen großen Leistungsabfall im Kubernetes-Cluster, wir wollten verteiltes Tracing und nahmen Istio mit, um Jaeger auszuführen und es herauszufinden.  Service Mesh passt so gut in unsere Infrastruktur, dass wir uns entschlossen haben, in dieses Tool zu investieren. </p><br><p>  Ich musste leiden, aber wir haben es weit und breit studiert.  Dies ist der erste Beitrag in einer Reihe, in der ich beschreiben werde, wie Istio sich in Kubernetes integriert und was wir über seine Arbeit gelernt haben.  Manchmal wandern wir in die technische Wildnis, aber nicht sehr weit.  Weiter wird es weitere Beiträge geben. </p><a name="habracut"></a><br><h3 id="chto-takoe-istio">  Was ist Istio? </h3><br><p>  Istio ist ein Service-Mesh-Konfigurationstool.  Es liest den Status des Kubernetes-Clusters und aktualisiert die L7-Proxys (HTTP und gRPC), die als Sidecar in Kubernetes-Pods implementiert sind.  Bei diesem Beiwagen handelt es sich um Envoy-Container, die die Konfiguration von der Istio Pilot-API (und dem gRPC-Dienst) lesen und den Verkehr durch diese leiten.  Mit dem leistungsstarken L7-Proxy unter der Haube können wir Metriken, Traces, Wiederholungslogik, Leistungsschalter, Lastausgleich und kanarische Bereitstellungen verwenden. </p><br><h3 id="nachnem-s-nachala-kubernetes">  Beginnen wir von vorne: Kubernetes </h3><br><p> In Kubernetes erstellen wir unter Verwendung eines Deployments oder StatefulSets.  Oder es kann einfach "Vanille" ohne einen High-Level-Controller sein.  Dann bemüht sich Kubernetes, den gewünschten Status beizubehalten - es erstellt Pods im Cluster auf dem Knoten und stellt sicher, dass sie gestartet und neu gestartet werden.  Wenn ein Under erstellt wird, durchläuft Kubernetes den API-Lebenszyklus, stellt sicher, dass jeder Schritt erfolgreich ist, und erstellt erst dann das Under im Cluster. </p><br><p>  API-Lebenszyklusphasen: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/dl/dc/t5/dldct5fzrxubc5c1z3zt2m7lchu.png"></a> <br>  <em>Danke an Banzai Cloud für das coole Bild.</em> </p><br><p>  Einer der Schritte ist das Ändern von Zulassungs-Webhooks.  Dies ist ein separater Teil des Lebenszyklus in Kubernetes, in dem Ressourcen angepasst werden, bevor sie in das etcd-Repository übertragen werden, die Quelle der Wahrheit für die Kubernetes-Konfiguration.  Und hier macht Istio seine Magie. </p><br><h3 id="modificiruyuschie-vebhuki-dopuska">  Zulassungs-Webhooks ändern </h3><br><p> Wenn ein Sub erstellt wird (über <code>kubectl</code> oder <code>Deployment</code> ), durchläuft es diesen Lebenszyklus, und durch Zugriff auf modifizierende Webhooks wird es geändert, bevor es für die große Welt freigegeben wird. </p><br><p>  Während der Installation von Istio wird der Istio-Sidecar-Injektor als Konfigurationsressource zum Ändern von Webhooks hinzugefügt: </p><br><pre> <code class="plaintext hljs">$ kubectl get mutatingwebhookconfiguration NAME AGE istio-sidecar-injector 87d</code> </pre> <br><p>  Und die Konfiguration: </p><br><pre> <code class="plaintext hljs">apiVersion: admissionregistration.k8s.io/v1beta1 kind: MutatingWebhookConfiguration metadata: labels: app: istio-sidecar-injector chart: sidecarInjectorWebhook-1.0.4 heritage: Tiller name: istio-sidecar-injector webhooks: - clientConfig: caBundle: redacted service: name: istio-sidecar-injector namespace: istio-system path: /inject failurePolicy: Fail name: sidecar-injector.istio.io namespaceSelector: matchLabels: istio-injection: enabled rules: - apiGroups: - "" apiVersions: - v1 operations: - CREATE resources: - pods</code> </pre> <br><p>  Hier heißt es, dass Kubernetes alle <code>istio-sidecar-injector</code> an den <code>istio-sidecar-injector</code> <code>istio-system</code> im <code>istio-system</code> Namespace senden soll, wenn für den Namespace <code>istio-injection=enabled</code> .  Der Injektor enthält zwei weitere Container in PodSpec: einen temporären zum Festlegen von Proxy-Regeln und einen zum Proxy selbst.  Der Beiwageninjektor setzt diese Behälter gemäß der Vorlage aus der Konfigurationskarte des <code>istio-sidecar-injector</code> .  Dieser Vorgang wird auch als Sidecaring bezeichnet. </p><br><h3 id="sidecar-pody">  Beiwagenkapseln </h3><br><p>  Beiwagen sind die Tricks unseres Magiers Istio.  Istio dreht alles so geschickt, dass es von außen einfach magisch ist, wenn Sie die Details nicht kennen.  Und es ist nützlich, sie zu kennen, wenn Sie plötzlich Netzwerkanforderungen debuggen müssen. </p><br><h3 id="init--i-proksi-konteynery">  Init- und Proxy-Container </h3><br><p>  Kubernetes verfügt über temporäre einmalige Init-Container, die vor den Hauptcontainern ausgeführt werden können.  Sie bündeln Ressourcen, migrieren Datenbanken oder konfigurieren, wie bei Istio, Netzwerkregeln. </p><br><p>  Istio verwendet Envoy, um alle Anfragen an Einreichungen entlang der gewünschten Routen zu senden.  Zu diesem Zweck erstellt Istio <code>iptables</code> Regeln, die eingehenden und ausgehenden Datenverkehr direkt an Envoy senden und den Datenverkehr sauber an sein Ziel weiterleiten.  Der Datenverkehr macht einen kleinen Umweg, aber Sie haben die Ablaufverfolgung, Abfragemetriken und die Durchsetzung von Richtlinien verteilt.  In dieser Datei können Sie im Istio-Repository <a href="">sehen,</a> wie Istio iptables-Regeln erstellt. </p><br><p>  <a href="">@jimmysongio hat</a> ein hervorragendes Verbindungsdiagramm zwischen den iptables-Regeln und dem Envoy-Proxy erstellt: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/yl/3m/yc/yl3myca7qv4esodpj8a7iwsp6bc.jpeg"></a> <br>  <em>Gesandter - Gesandterverkehr</em> </p><br><p>  Envoy empfängt den gesamten eingehenden und ausgehenden Verkehr, sodass sich der gesamte Verkehr im Allgemeinen innerhalb von Envoy bewegt, wie in der Abbildung dargestellt.  Der Istio-Proxy ist ein weiterer Container, der allen vom Istio-Beiwageninjektor modifizierten Pods hinzugefügt wird.  In diesem Container wird der Envoy-Prozess gestartet, der den gesamten Datenverkehr vom Herd empfängt (mit einigen Ausnahmen, z. B. Datenverkehr von Ihrem Kubernetes-Cluster). </p><br><p>  Der Envoy-Prozess erkennt alle Routen über die Envoy v2-API, die Istio implementiert. </p><br><h3 id="envoy-i-pilot">  Gesandter und Pilot </h3><br><p>  Envoy selbst hat keine Logik zum Erkennen von Pods und Diensten in einem Cluster.  Es ist eine Datenebene und benötigt eine Steuerebene zur Führung.  Der Envoy-Konfigurationsparameter fordert den Host oder Service-Port auf, diese Konfiguration über die gRPC-API zu erhalten.  Istio erfüllt über seinen Pilotdienst die Anforderungen für die gRPC-API.  Envoy stellt eine Verbindung zu dieser API her, basierend auf einer Sidecar-Konfiguration, die über einen modifizierenden Webhook implementiert wird.  Die API verfügt über alle Verkehrsregeln, die Envoy zum Erkennen und Weiterleiten für den Cluster benötigt.  Dies ist das Service-Mesh. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/lr/kn/bz/lrknbzkkjqescnkyh6k1voy_nyk.png"></a> <br>  <em>Datenaustausch "unter dem &lt;-&gt; Piloten"</em> </p><br><p>  Pilot stellt eine Verbindung zum Kubernetes-Cluster her, liest den Clusterstatus und wartet auf Aktualisierungen.  Es überwacht die Pods, Dienste und Endpunkte im Kubernetes-Cluster, um dann allen mit dem Piloten verbundenen Envoy-Beiwagen die richtige Konfiguration zu geben.  Dies ist die Brücke zwischen Kubernetes und Envoy. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/fg/no/hj/fgnohjdngxbyn8kj5u_udcvl6x0.png"></a> <br>  <em>Vom Piloten zum Kubernetes</em> </p><br><p>  Wenn Pods, Dienste oder Endpunkte in Kubernetes erstellt oder aktualisiert werden, erfährt Pilot davon und sendet die erforderliche Konfiguration an alle verbundenen Envoy-Instanzen. </p><br><h3 id="kakaya-konfiguraciya-otpravlyaetsya">  Welche Konfiguration wird gesendet? </h3><br><p>  Welche Konfiguration erhält der Gesandte vom Istio-Piloten? </p><br><p>  Standardmäßig löst Kubernetes Ihre Netzwerkprobleme mit einem Dienst, der <code>endpoint</code> verwaltet.  Die Liste der Endpunkte kann mit dem folgenden Befehl geöffnet werden: </p><br><pre> <code class="plaintext hljs">kubectl get endpoints</code> </pre> <br><p>  Dies ist eine Liste aller IP-Adressen und Ports im Cluster und ihrer Adressen (normalerweise sind dies Pods, die aus einer Bereitstellung erstellt wurden).  Istio ist wichtig zu wissen, um Routendaten zu konfigurieren und an Envoy zu senden. </p><br><h3 id="servisy-proslushivateli-i-marshruty">  Dienste, Listener und Routen </h3><br><p>  Wenn Sie einen Dienst in einem Kubernetes-Cluster erstellen, fügen Sie Verknüpfungen hinzu, mit denen alle geeigneten Pods ausgewählt werden.  Wenn Sie Datenverkehr an die IP des Dienstes senden, wählt Kubernetes den Datenverkehr für diesen Datenverkehr aus.  Zum Beispiel der Befehl </p><br><pre> <code class="plaintext hljs">curl my-service.default.svc.cluster.local:3000</code> </pre> <br><p>  Zunächst wird die dem <code>my-service</code> zugewiesene virtuelle IP im <code>default</code> Namespace gefunden, und diese IP leitet den Datenverkehr an ein Sub weiter, das der Dienstbezeichnung entspricht. </p><br><p>  Istio und Envoy ändern diese Logik leicht.  Istio konfiguriert Envoy basierend auf den Diensten und Endpunkten im Kubernetes-Cluster und verwendet die intelligenten Routing- und Lastausgleichsfunktionen von Envoy, um den Kubernetes-Dienst zu umgehen.  Anstatt jeweils nur eine IP zu übertragen, stellt Envoy eine direkte Verbindung zum IP-Herd her.  <strong>Zu diesem Zweck ordnet Istio die Kubernetes-Konfiguration der Envoy-Konfiguration zu</strong> . </p><br><p>  Die Begriffe Kubernetes, Istio und Envoy unterscheiden sich geringfügig, und es ist nicht sofort klar, was sie essen. </p><br><h3 id="servisy">  Dienstleistungen </h3><br><p>  Ein Dienst in Kubernetes wird einem <strong>Cluster</strong> in Envoy zugeordnet.  Der Envoy-Cluster enthält eine Liste von <strong>Endpunkten</strong> , dh die IP (oder Hostnamen) der Instanzen für die Verarbeitung von Anforderungen.  Führen Sie <code>istioctl proxy-config cluster &lt; &gt;</code> um die Liste der im Istio Sidecar-Pod konfigurierten Cluster anzuzeigen.  Dieser Befehl zeigt den aktuellen Stand der Dinge in Bezug auf den Herd.  Hier ist ein Beispiel aus einer unserer Umgebungen: </p><br><pre> <code class="plaintext hljs">$ istioctl proxy-config cluster taxparams-6777cf899c-wwhr7 -n applications SERVICE FQDN PORT SUBSET DIRECTION TYPE BlackHoleCluster - - - STATIC accounts-grpc-gw.applications.svc.cluster.local 80 - outbound EDS accounts-grpc-public.applications.svc.cluster.local 50051 - outbound EDS addressvalidator.applications.svc.cluster.local 50051 - outbound EDS</code> </pre> <br><p>  Alle gleichen Dienste befinden sich in diesem Namespace: </p><br><pre> <code class="plaintext hljs">$ kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) accounts-grpc-gw ClusterIP 10.3.0.91 &lt;none&gt; 80/TCP accounts-grpc-public ClusterIP 10.3.0.202 &lt;none&gt; 50051/TCP addressvalidator ClusterIP 10.3.0.56 &lt;none&gt; 50051/TCP</code> </pre> <br><p>  Woher weiß Istio, welches Protokoll den Dienst verwendet?  Konfiguriert Protokolle für Dienstmanifeste anhand des Namensfelds im Porteintrag. </p><br><pre> <code class="plaintext hljs">$ kubectl get service accounts-grpc-public -o yaml apiVersion: v1 kind: Service metadata: name: accounts-grpc-public spec: ports: - name: grpc port: 50051 protocol: TCP targetPort: 50051</code> </pre> <br><p>  Wenn es <code>grpc</code> oder das <code>grpc-</code> Präfix gibt, konfiguriert Istio das HTTP2-Protokoll für den Dienst.  Wir haben durch bittere Erfahrung gelernt, wie Istio den Portnamen verwendet, wenn Proxy-Konfigurationen beschädigt sind, weil sie keine http- oder grpc-Präfixe angegeben haben ... </p><br><p>  Wenn Sie kubectl und die Admin-Port-Weiterleitungsseite in Envoy verwenden, können Sie sehen, dass die Konto-grpc-public-Endpunkte von Pilot als Cluster in Envoy mit dem HTTP2-Protokoll implementiert werden.  Dies bestätigt unsere Annahmen: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward otherpod-dc56885ff-dqc6t 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... - cluster: circuit_breakers: thresholds: - {} connect_timeout: 1s eds_cluster_config: eds_config: ads: {} service_name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local http2_protocol_options: max_concurrent_streams: 1073741824 name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local type: EDS ...</code> </pre> <br><p>  Port 15000 ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Envoy-Administrationsseite</a> , die auf jedem Beiwagen verfügbar ist. </p><br><h3 id="proslushivateli">  Zuhörer </h3><br><p>  Listener erkennen Kubernetes-Endpunkte, um Datenverkehr an die Herde weiterzuleiten.  Der Adressüberprüfungsdienst hat hier einen Endpunkt: </p><br><pre> <code class="plaintext hljs">$ kubectl get ep addressvalidator -o yaml apiVersion: v1 kind: Endpoints metadata: name: addressvalidator subsets: - addresses: - ip: 10.2.26.243 nodeName: ip-10-205-35-230.ec2.internal targetRef: kind: Pod name: addressvalidator-64885ccb76-87l4d namespace: applications ports: - name: grpc port: 50051 protocol: TCP</code> </pre> <br><p>  Daher verfügt der Adressüberprüfungsherd über einen Listener an Port 50051: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward addressvalidator-64885ccb76-87l4d 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... dynamic_active_listeners: - version_info: 2019-01-13T18:39:43Z/651 listener: name: 10.2.26.243_50051 address: socket_address: address: 10.2.26.243 port_value: 50051 filter_chains: - filter_chain_match: transport_protocol: raw_buffer ...</code> </pre> <br><h3 id="marshruty">  Routen </h3><br><p>  In Istio wird anstelle des Standardobjekts von Kubernetes Ingress eine abstraktere und effizientere benutzerdefinierte Ressource verwendet - <code>VirtualService</code> .  VirtualService ordnet Routen Upstream-Clustern zu, indem sie an das Gateway gebunden werden.  So verwenden Sie Kubernetes Ingress mit einem Ingress-Controller. </p><br><p>  Wir verwenden nämlich das Istio Ingress-Gateway für den gesamten internen GRPC-Verkehr: </p><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: grpc-gateway spec: selector: istio: ingressgateway servers: - hosts: - '*' port: name: http2 number: 80 protocol: HTTP2 --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: grpc-gateway spec: gateways: - grpc-gateway hosts: - '*' http: - match: - uri: prefix: /namely.address_validator.AddressValidator retries: attempts: 3 perTryTimeout: 2s route: - destination: host: addressvalidator port: number: 50051</code> </pre> <br><p>  Auf den ersten Blick werden Sie im Beispiel nichts verstehen.  Hier ist es nicht sichtbar, aber die Istio-IngressGateway-Bereitstellung zeichnet basierend auf der <code>istio: ingressgateway</code> auf, welche Endpunkte benötigt werden.  In diesem Beispiel leitet IngressGateway den Datenverkehr für alle Domänen über Port 80 über HTTP2 weiter.  VirtualService implementiert Routen für dieses Gateway, stimmt mit dem Präfix <code>/namely.address_validator.AddressValidator</code> und übergibt den <code>addressvalidator</code> über den Port 50051 <code>addressvalidator</code> einer Wiederholungsregel in zwei Sekunden an den Upstream-Service. </p><br><p>  Wenn wir den Pod-Port von Istio-IngressGateway umleiten und die Konfiguration von Envoy sehen, werden wir sehen, was VirtualService tut: </p><br><pre> <code class="plaintext hljs">$ kubectl -n istio-system port-forward istio-ingressgateway-7477597868-rldb5 15000 ... - match: prefix: /namely.address_validator.AddressValidator route: cluster: outbound|50051||addressvalidator.applications.svc.cluster.local timeout: 0s retry_policy: retry_on: 5xx,connect-failure,refused-stream num_retries: 3 per_try_timeout: 2s max_grpc_timeout: 0s decorator: operation: addressvalidator.applications.svc.cluster.local:50051/namely.address_validator.AddressValidator* ...</code> </pre> <br><h3 id="chto-my-guglili-kopayas-v-istio">  Was wir beim Graben in Istio gegoogelt haben </h3><br><p>  <strong>Fehler 503 oder 404 tritt auf</strong> </p><br><p>  Die Gründe sind unterschiedlich, aber normalerweise sind dies: </p><br><ul><li>  Beiwagenanwendungen können Pilot nicht kontaktieren (überprüfen Sie, ob Pilot ausgeführt wird). </li><li>  Das Kubernetes-Dienstmanifest hat ein ungültiges Protokoll. </li><li>  Die VirtualService / Envoy-Konfiguration schreibt die Route in den falschen Upstream-Cluster.  Beginnen Sie mit dem Edge-Service, bei dem Sie eingehenden Datenverkehr erwarten, und überprüfen Sie die Envoy-Protokolle.  Oder verwenden Sie etwas wie Jaeger, um Fehler zu finden. </li></ul><br><p>  <strong>Was bedeutet NR / UH / UF in Istio-Proxy-Protokollen?</strong> </p><br><ul><li>  NR - Keine Route. </li><li>  UH - Upstream Ungesund (Upstream nicht funktionsfähig). </li><li>  UF - Upstream-Fehler (Upstream-Fehler). </li></ul><br><p>  Lesen Sie mehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Envoy-Website</a> . </p><br><p>  <strong>In Bezug auf Hochverfügbarkeit mit Istio</strong> </p><br><ul><li>  Fügen Sie den Istio-Komponenten NodeAffinity hinzu, um die Herde gleichmäßig auf verschiedene Verfügbarkeitszonen zu verteilen und die Mindestanzahl an Replikaten zu erhöhen. </li><li>  Starten Sie die neue Version von Kubernetes mit der Funktion zur automatischen Skalierung horizontaler Pods.  Die wichtigsten Herde werden je nach Belastung skaliert. </li></ul><br><p>  <strong>Warum endet Cronjob nicht?</strong> </p><br><p>  Wenn die Hauptauslastung abgeschlossen ist, arbeitet der Beiwagencontainer weiter.  Um das Problem zu umgehen, deaktivieren Sie den Beiwagen in Cronjobs, indem Sie <code>sidecar.istio.io/inject: “false”</code> die Anmerkung <code>sidecar.istio.io/inject: “false”</code> hinzufügen. </p><br><p>  <strong>Wie installiere ich Istio?</strong> </p><br><p>  Wir verwenden Spinnaker für Bereitstellungen, aber wir nehmen normalerweise die neuesten Helm-Diagramme, zaubern sie, verwenden die <code>helm template -f values.yml</code> und <code>helm template -f values.yml</code> Dateien auf Github fest, um die Änderungen zu sehen, bevor wir sie über <code>kubectl apply -f -</code> .  Dies dient dazu, die CRD oder API in verschiedenen Versionen nicht versehentlich zu ändern. </p><br><p>  Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bobby Tables</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Michael Hamrah</a> für die Unterstützung beim Schreiben dieses Beitrags. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441616/">https://habr.com/ru/post/de441616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441600/index.html">Schwache Benutzeroberfläche, schwacher Programmierer</a></li>
<li><a href="../de441602/index.html">Warum ein klassisches Automatikauto unmöglich ist und keine kommerziellen Perspektiven hat</a></li>
<li><a href="../de441604/index.html">Chinas nationale Überwachungssysteme: eine Quelle nicht nur für Daten, sondern auch für ein stabiles Einkommen</a></li>
<li><a href="../de441606/index.html">Fast zuverlässige Lösungen</a></li>
<li><a href="../de441610/index.html">LED liegt in beispiellosen Ausmaßen</a></li>
<li><a href="../de441618/index.html">Erstellung der unteren Navigationsleiste auf Kotlin mit Anko</a></li>
<li><a href="../de441626/index.html">Workshop zum industriellen 3D-Druck: 1. März im Calibre Technopark</a></li>
<li><a href="../de441628/index.html">2018 Bewertung der IT-Arbeitgeber in Sankt Petersburg und Moskau: Ergebnisse einer Umfrage unter Entwicklern</a></li>
<li><a href="../de441632/index.html">1. März - Teamlead Meetup: Mitarbeiterbewertung und Motivation</a></li>
<li><a href="../de441634/index.html">Gibt es Leben unter Windows 98, Teil zwei - über Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>