<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüë¶ ‚ÜîÔ∏è üè® Was bl√§st das Ged√§chtnis in Ruby auf? ‚òïÔ∏è üì≠ üëÉüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir bei Phusion haben einen einfachen Multithread-HTTP-Proxy in Ruby (vertreibt DEB- und RPM-Pakete). Ich sah darauf einen Speicherverbrauch von 1,3 G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was bl√§st das Ged√§chtnis in Ruby auf?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444482/">  Wir bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phusion haben</a> einen einfachen Multithread-HTTP-Proxy in Ruby (vertreibt DEB- und RPM-Pakete).  Ich sah darauf einen Speicherverbrauch von 1,3 GB.  Aber das ist verr√ºckt nach einem staatenlosen Prozess ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/f7a/d2b/9baf7ad2bd3ecdfb0779482c018473eb.jpg"></div><br>  <i><font color="gray">Frage: Was ist das?</font></i>  <i><font color="gray">Antwort: Ruby nutzt den Speicher im Laufe der Zeit!</font></i> <br><br>  Es stellt sich heraus, dass ich mit diesem Problem nicht allein bin.  Ruby-Anwendungen k√∂nnen viel Speicher belegen.  Aber warum?  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heroku</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nate Burkopek</a> ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufbl√§hen</a> haupts√§chlich auf Speicherfragmentierung und √ºberm√§√üige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heap-</a> Verteilung zur√ºckzuf√ºhren. <br><a name="habracut"></a><br>  Berkopek kam zu dem Schluss, dass es zwei L√∂sungen gibt: <br><br><ol><li>  Verwenden Sie entweder einen v√∂llig anderen Speicherzuweiser als glibc - normalerweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jemalloc</a> , oder: </li><li> Setzen Sie die magische Umgebungsvariable <code>MALLOC_ARENA_MAX=2</code> . </li></ol><br>  Ich mache mir Sorgen um die Beschreibung des Problems und die vorgeschlagenen L√∂sungen.  Hier stimmt etwas nicht ... Ich bin nicht sicher, ob das Problem vollst√§ndig beschrieben ist oder ob dies die einzigen verf√ºgbaren L√∂sungen sind.  Es √§rgert mich auch, dass viele Jemalloc als magischen Silberpool bezeichnen. <br><br>  <b>Magie ist nur eine Wissenschaft, die wir noch nicht verstehen</b> .  Also machte ich eine Forschungsreise, um die ganze Wahrheit herauszufinden.  Dieser Artikel behandelt die folgenden Themen: <br><br><ol><li>  So funktioniert die Speicherzuordnung. <br></li><li>  Was ist diese "Fragmentierung" und "√ºberm√§√üige Verteilung" des Ged√§chtnisses, von der alle sprechen? <br></li><li>  Was verursacht einen hohen Speicherverbrauch?  Stimmt die Situation mit dem √ºberein, was die Leute sagen, oder gibt es noch etwas anderes?  (Spoiler: Ja, da ist noch etwas). <br></li><li>  Gibt es alternative L√∂sungen?  (Spoiler: Ich habe einen gefunden). </li></ol><br>  <i>Hinweis: Dieser Artikel ist nur f√ºr Linux und nur f√ºr Ruby-Anwendungen mit mehreren Threads relevant.</i> <br><br><h1>  Inhalt </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ruby Memory Allocation: Eine Einf√ºhrung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ruby</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemspeicherzuordnung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Kern</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definition der Speichernutzung</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist Fragmentierung?</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ruby Level Fragmentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fragmentierung der Speicherzuordnung</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verursacht die Fragmentierung der Ruby-Heap-Seite ein Aufbl√§hen des Speichers?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Studie zur Fragmentierung der Speicherzuordnung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberm√§√üige Speicherzuordnung und Glibc</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visualisierung von Systemhaufen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zaubertrick: Beschneidung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visualizer-Quellcode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist mit Leistung?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ben√∂tigen Sie weitere Tests.</a> </li></ul></li></ul><br><a name="1"></a><h1>  Ruby Memory Allocation: Eine Einf√ºhrung </h1><br>  Ruby ordnet Speicher auf drei Ebenen von oben nach unten zu: <br><br><ol><li>  Ruby-Interpreter, der Ruby-Objekte verwaltet. <br></li><li>  Die Speicherzuordnungsbibliothek des Betriebssystems. <br></li><li>  Der Kern. </li></ol><br>  Lass uns durch jedes Level gehen. <br><br><a name="1_1"></a><h3>  Ruby </h3><br>  Auf seiner Seite organisiert Ruby Objekte in Speicherbereichen, die als <i>Ruby-Heap-Seiten bezeichnet werden</i> .  Eine solche Heap-Seite ist in Slots gleicher Gr√∂√üe unterteilt, wobei ein Objekt einen Slot belegt.  Unabh√§ngig davon, ob es sich um eine Zeichenfolge, eine Hash-Tabelle, ein Array, eine Klasse oder etwas anderes handelt, belegt sie einen Steckplatz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d6/155/0be/2d61550be208df42ad3052ca1f821807.png"></div><br><br>  Die Slots auf der Heap-Seite sind m√∂glicherweise belegt oder frei.  Wenn Ruby ein neues Objekt ausw√§hlt, versucht es sofort, einen freien Platz zu belegen.  Wenn keine freien Slots vorhanden sind, wird eine neue Heap-Seite hervorgehoben. <br><br>  Der Steckplatz ist klein, ungef√§hr 40 Bytes.  Offensichtlich passen einige Objekte nicht hinein, z. B. 1 MB Zeilen.  Dann speichert Ruby die Informationen an einer anderen Stelle au√üerhalb der Heap-Seite und platziert einen Zeiger auf diesen externen Speicherbereich im Steckplatz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/e96/1c6/1e5e961c6c90ed1cd17daa8ab19d8212.png"></div><br>  <i><font color="gray">Daten, die nicht in den Steckplatz passen, werden au√üerhalb der Heap-Seite gespeichert.</font></i>  <i><font color="gray">Ruby platziert einen Zeiger auf diese externen Daten im Steckplatz</font></i> <br><br>  Sowohl Ruby-Heap-Seiten als auch externe Speicherbereiche werden mithilfe des Systemspeicherzuordners zugewiesen. <br><br><a name="1_2"></a><h3>  Systemspeicherzuordnung </h3><br>  Der Speicherzuweiser des Betriebssystems ist Teil von glibc (C-Laufzeit).  Es wird von fast allen Anwendungen verwendet, nicht nur von Ruby.  Es hat eine einfache API: <br><br><ul><li>  Der Speicher wird durch Aufrufen von <code>malloc(size)</code> zugewiesen.  Sie geben ihm die Anzahl der Bytes, die Sie zuweisen m√∂chten, und es gibt entweder die Zuordnungsadresse oder einen Fehler zur√ºck. </li><li>  Der zugewiesene Speicher wird durch Aufrufen von <code>free(address)</code> freigegeben. </li></ul><br>  Im Gegensatz zu Ruby, wo Slots derselben Gr√∂√üe zugewiesen werden, verarbeitet der Speicherzuweiser Anforderungen zum Zuweisen von Speicher beliebiger Gr√∂√üe.  Wie Sie sp√§ter erfahren werden, f√ºhrt diese Tatsache zu einigen Komplikationen. <br><br>  Der Speicherzuweiser greift wiederum auf die Kernel-API zu.  Der Kernel ben√∂tigt viel gr√∂√üere Speicherbl√∂cke als von seinen eigenen Abonnenten angefordert, da der Kernelaufruf teuer ist und die Kernel-API eine Einschr√§nkung aufweist: Sie kann nur Speicher in Vielfachen von 4 KB zuweisen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/dba/21a/323dba21a7b5ad2df8e1f9335d6b7c11.png"></div><br>  <i><font color="gray">Der Speicherzuweiser weist gro√üe Bl√∂cke zu - sie werden als Systemhaufen bezeichnet - und teilt ihren Inhalt, um Anforderungen von Anwendungen zu erf√ºllen</font></i> <br><br>  Der Speicherbereich, den der Speicherzuweiser vom Kernel zuweist, wird als Heap bezeichnet.  Beachten Sie, dass dies nichts mit den Seiten des Ruby-Heaps zu tun hat. Aus Gr√ºnden der √úbersichtlichkeit wird der Begriff <i>System-Heap verwendet</i> . <br><br>  Der Speicherzuweiser weist dann seinen Anrufern Teile der Systemhaufen zu, bis freier Speicherplatz vorhanden ist.  In diesem Fall weist der Speicherzuweiser einen neuen Systemheap vom Kernel zu.  Dies √§hnelt der Auswahl von Objekten aus den Seiten eines Ruby-Heaps durch Ruby. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/f81/c11/453f81c11aaadb818ecdcf798112db99.png"></div><br>  <i><font color="gray">Ruby reserviert Speicher vom Speicherzuweiser, der wiederum Speicher vom Kernel zuweist</font></i> <br><br><a name="1_3"></a><h3>  Der Kern </h3><br>  Der Kernel kann nur Speicher in 4-KB-Einheiten zuweisen.  Ein solcher 4K-Block wird als Seite bezeichnet.  Um Verwechslungen mit den Ruby-Heap-Seiten zu vermeiden, verwenden wir aus Gr√ºnden der √úbersichtlichkeit den Begriff <i>Systemseite</i> (Betriebssystemseite). <br><br>  Der Grund ist schwer zu erkl√§ren, aber alle modernen Kernel funktionieren auf diese Weise. <br><br>  Das Zuweisen von Speicher √ºber den Kernel hat erhebliche Auswirkungen auf die Leistung, weshalb Speicherzuweiser versuchen, die Anzahl der Kernelaufrufe zu minimieren. <br><br><a name="1_4"></a><h3>  Definition der Speichernutzung </h3><br>  Somit wird Speicher auf mehreren Ebenen zugewiesen, und jede Ebene weist mehr Speicher zu, als er wirklich ben√∂tigt.  Ruby-Heap-Seiten k√∂nnen sowohl freie Slots als auch System-Heaps enthalten.  Daher die Antwort auf die Frage "Wie viel Speicher wird verwendet?"  h√§ngt ganz davon ab, welches Level du fragst! <br><br>  Tools wie <code>top</code> oder <code>ps</code> zeigen die Speichernutzung aus <b>Kernel-</b> Sicht.  Dies bedeutet, dass h√∂here Ebenen zusammenarbeiten m√ºssen, um Speicher aus Kernel-Sicht freizugeben.  Wie Sie sp√§ter erfahren werden, ist dies schwieriger als es sich anh√∂rt. <br><br><a name="2"></a><h1>  Was ist Fragmentierung? </h1><br>  Speicherfragmentierung bedeutet, dass Speicherzuordnungen zuf√§llig verteilt sind.  Dies kann interessante Probleme verursachen. <br><br><a name="2_1"></a><h3>  Ruby Level Fragmentation </h3><br>  Betrachten Sie Ruby Garbage Collection.  Die Speicherbereinigung f√ºr ein Objekt bedeutet, dass der Ruby-Heap-Seitenschlitz als frei markiert wird, damit er wiederverwendet werden kann.  Wenn die gesamte Seite des Ruby-Heaps nur aus freien Slots besteht, kann die gesamte Seite an den Speicherzuweiser (und m√∂glicherweise an den Kernel) zur√ºckgegeben werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/cde/97d/27bcde97d27e6aeed3dc2020a4eda766.png"></div><br><br>  Aber was passiert, wenn nicht alle Slots frei sind?  Was ist, wenn wir viele Seiten des Ruby-Heaps haben und der Garbage Collector Objekte an verschiedenen Orten freigibt, sodass am Ende viele freie Slots vorhanden sind, jedoch auf verschiedenen Seiten?  In dieser Situation verf√ºgt Ruby √ºber freie Steckpl√§tze zum Platzieren von Objekten, aber der Speicherzuweiser und der Kernel weisen weiterhin Speicher zu! <br><br><a name="2_2"></a><h3>  Fragmentierung der Speicherzuordnung </h3><br>  Der Speicherzuweiser hat ein √§hnliches, aber v√∂llig anderes Problem.  Er muss nicht sofort ganze Systemhaufen l√∂schen.  Theoretisch kann jede einzelne Systemseite freigegeben werden.  Da sich der Speicherzuweiser jedoch mit Speicherzuordnungen beliebiger Gr√∂√üe befasst, kann es auf der Systemseite mehrere Zuordnungen geben.  Die Systemseite kann erst freigegeben werden, wenn alle Auswahlen freigegeben sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76b/723/850/76b72385026fa24bd18b7db324d7353b.png"></div><br><br>  √úberlegen Sie, was passiert, wenn wir eine 3-KB-Zuordnung sowie eine 2-KB-Zuordnung haben, die in zwei Systemseiten unterteilt sind.  Wenn Sie die ersten 3 KB freigeben, bleiben beide Systemseiten teilweise belegt und k√∂nnen nicht freigegeben werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc2/cf1/70f/cc2cf170facbc6bca673014e33389606.png"></div><br><br>  Wenn die Umst√§nde fehlschlagen, ist auf den Systemseiten viel freier Speicherplatz vorhanden, der jedoch nicht vollst√§ndig freigegeben wird. <br><br>  Schlimmer noch: Was ist, wenn es viele freie Pl√§tze gibt, aber keiner gro√ü genug ist, um eine neue Zuteilungsanfrage zu erf√ºllen?  Der Speicherzuweiser muss einen ganz neuen Systemheap zuweisen. <br><br><a name="3"></a><h1>  Verursacht die Fragmentierung der Ruby-Heap-Seite ein Aufbl√§hen des Speichers? </h1><br>  Es ist wahrscheinlich, dass die Fragmentierung in Ruby zu einer √úberbeanspruchung des Speichers f√ºhrt.  Wenn ja, welche der beiden Fragmentierungen ist sch√§dlicher?  Das‚Ä¶ <br><br><ol><li>  Ruby Heap Page Fragmentierung?  Oder <br></li><li>  Speicherzuweisungsfragmentierung? </li></ol><br>  Die erste Option ist recht einfach zu √ºberpr√ºfen.  Ruby bietet zwei APIs: <code>ObjectSpace.memsize_of_all</code> und <code>GC.stat</code> .  Dank dieser Informationen k√∂nnen Sie den gesamten Speicher berechnen, den Ruby vom Allokator erhalten hat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb8/f7e/30e/cb8f7e30e363d2fa57f0fc37b84183fe.png"></div><br><br>  <code>ObjectSpace.memsize_of_all</code> gibt den von allen aktiven Ruby-Objekten belegten Speicher zur√ºck.  Das hei√üt, der gesamte Speicherplatz in ihren Steckpl√§tzen und alle externen Daten.  Im obigen Diagramm ist dies die Gr√∂√üe aller blauen und orangefarbenen Objekte. <br><br>  <code>GC.stat</code> k√∂nnen <code>GC.stat</code> die Gr√∂√üe aller freien Slots ermitteln, d. H. Den gesamten grauen Bereich in der obigen Abbildung.  Hier ist der Algorithmus: <br><br><pre> <code class="cpp hljs">GC.stat[:heap_free_slots] * GC::INTERNAL_CONSTANTS[:RVALUE_SIZE]</code> </pre> <br>  Zusammenfassend ist dies der gesamte Speicher, den Ruby kennt, und es geht darum, die Seiten des Ruby-Heaps zu fragmentieren.  Wenn aus Kernel-Sicht die Speichernutzung h√∂her ist, wird der verbleibende Speicher au√üerhalb der Kontrolle von Ruby gespeichert, z. B. f√ºr Bibliotheken oder Fragmentierung von Drittanbietern. <br><br>  Ich habe ein einfaches Testprogramm geschrieben, das eine Reihe von Threads erstellt, von denen jeder Zeilen in einer Schleife ausw√§hlt.  Hier ist das Ergebnis nach einer Weile: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4e/859/2fc/a4e8592fc1d2edf2f11957844d33e55d.png"></div><br><br>  es ist ... nur ... verr√ºckt! <br><br>  Das Ergebnis zeigt, dass Ruby einen so schwachen Effekt auf die Gesamtmenge des verwendeten Speichers hat, dass es keine Rolle spielt, ob die Seiten des Ruby-Heaps fragmentiert sind oder nicht. <br><br>  M√ºssen woanders nach dem T√§ter suchen.  Zumindest wissen wir jetzt, dass Ruby nicht schuld ist. <br><br><a name="4"></a><h1>  Studie zur Fragmentierung der Speicherzuordnung </h1><br>  Ein weiterer wahrscheinlicher Verd√§chtiger ist ein Speicherzuweiser.  Am Ende stellten Nate Berkopek und Heroku fest, dass die Arbeit mit dem Speicherzuweiser (entweder das vollst√§ndige Ersetzen von jemalloc oder das Setzen der magischen Umgebungsvariablen <code>MALLOC_ARENA_MAX=2</code> ) die Speichernutzung drastisch reduziert. <br><br>  Mal sehen, was <code>MALLOC_ARENA_MAX=2</code> macht und warum es hilft.  Dann untersuchen wir die Fragmentierung auf Verteilerebene. <br><br><a name="4_1"></a><h3>  √úberm√§√üige Speicherzuordnung und Glibc </h3><br>  Der Grund, warum <code>MALLOC_ARENA_MAX=2</code> hilft, ist Multithreading.  Wenn mehrere Threads gleichzeitig versuchen, Speicher von demselben Systemheap zuzuweisen, k√§mpfen sie um den Zugriff.  Es kann jeweils nur ein Thread Speicher empfangen, was die Leistung der Multithread-Speicherzuweisung verringert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a40/99c/65b/a4099c65b73541efa05c38008fa0e181.png"></div><br>  <i><font color="gray">Es kann jeweils nur ein Thread mit dem Systemheap arbeiten.</font></i>  <i><font color="gray">Bei Multithread-Aufgaben tritt ein Konflikt auf und folglich nimmt die Leistung ab</font></i> <br><br>  Im Speicherzuweiser f√ºr einen solchen Fall gibt es eine Optimierung.  Er versucht, mehrere System-Heaps zu erstellen und sie verschiedenen Threads zuzuweisen.  Meistens arbeitet ein Thread nur mit seinem eigenen Heap, um Konflikte mit anderen Threads zu vermeiden. <br><br>  Tats√§chlich entspricht die maximale Anzahl der auf diese Weise zugewiesenen System-Heaps standardm√§√üig der Anzahl der virtuellen Prozessoren multipliziert mit 8. Das hei√üt, in einem Dual-Core-System mit zwei Hyper-Threads werden jeweils <code>2 * 2 * 8 = 32</code> System-Heaps erzeugt!  Das nenne ich <b>√ºberm√§√üige Verteilung</b> . <br><br>  Warum ist der Standardmultiplikator so gro√ü?  Weil der f√ºhrende Entwickler des Speicherzuweisers Red Hat ist.  Ihre Kunden sind gro√üe Unternehmen mit leistungsstarken Servern und einer Menge RAM.  Mit der obigen Optimierung k√∂nnen Sie die durchschnittliche Multithreading-Leistung aufgrund einer signifikanten Erh√∂hung der Speichernutzung um 10% steigern.  F√ºr Red Hat-Kunden ist dies ein guter Kompromiss.  F√ºr die meisten anderen - kaum. <br><br>  Nate argumentiert in ihrem Blog und in ihrem Heroku-Artikel, dass eine Erh√∂hung der Anzahl der Systemhaufen die Fragmentierung erh√∂ht, und zitiert offizielle Dokumentation.  Die Variable <code>MALLOC_ARENA_MAX</code> reduziert die maximale Anzahl von System-Heaps, die f√ºr Multithreading zugewiesen sind.  Durch diese Logik wird die Fragmentierung reduziert. <br><br><a name="4_2"></a><h3>  Visualisierung von Systemhaufen </h3><br>  Stimmt die Aussage von Nate und Heroku, dass eine Erh√∂hung der Anzahl der Systemhaufen die Fragmentierung erh√∂ht?  Gibt es tats√§chlich ein Problem mit der Fragmentierung auf der Ebene des Speicherzuweisers?  Ich wollte keine dieser Annahmen f√ºr selbstverst√§ndlich halten, also begann ich mit der Studie. <br><br>  Leider gibt es keine Tools zum Visualisieren von Systemhaufen, daher habe <b>ich selbst einen solchen Visualizer geschrieben</b> . <br><br>  Erstens m√ºssen Sie das Verteilungsschema von System-Heaps irgendwie beibehalten.  Ich habe die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle des Speicherzuweisers untersucht</a> und mir angesehen, wie er den Speicher intern darstellt.  Dann schrieb er eine Bibliothek, die diese Datenstrukturen durchl√§uft und das Schema in eine Datei schreibt.  Schlie√ülich schrieb er ein Tool, das eine solche Datei als Eingabe verwendet und die Visualisierung als HTML- und PNG-Bilder ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kompiliert</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/adb/064/309adb06474b3ec49bb2d0d6622bbb48.png"></div><br><br>  Hier ist ein Beispiel f√ºr die Visualisierung eines bestimmten Systemheaps (es gibt viele weitere).  Kleine Bl√∂cke in dieser Visualisierung repr√§sentieren Systemseiten. <br><br><ul><li>  Rote Bereiche werden als Speicherzellen verwendet. </li><li>  Graut√∂ne sind freie Bereiche, die nicht in den Kern zur√ºckgef√ºhrt werden. </li><li>  Wei√üe Bereiche werden f√ºr den Kern freigegeben. </li></ul><br>  Die folgenden Schlussfolgerungen k√∂nnen aus der Visualisierung gezogen werden: <br><br><ol><li>  Es gibt eine gewisse Fragmentierung.  Rote Flecken werden aus dem Speicher gestreut, und einige Systemseiten sind nur halbrot. <br></li><li>  Zu meiner √úberraschung enthalten die <i>meisten</i> Systemhaufen eine erhebliche Anzahl vollst√§ndig freier Systemseiten (grau)! </li></ol><br>  Und dann d√§mmerte es mir: <br><br>  <i><b>Obwohl Fragmentierung ein Problem bleibt, ist es nicht der Punkt!</b></i> <br><br>  Vielmehr ist das Problem sehr grau: Dieser Speicherzuweiser <i>sendet keinen Speicher zur√ºck an den Kernel</i> ! <br><br>  Nach einer erneuten Untersuchung des Quellcodes des Speicherzuweisers stellte sich heraus, dass standardm√§√üig nur Systemseiten am Ende des Systemheaps an den Kernel gesendet werden, und dies sogar <i>selten</i> .  Wahrscheinlich ist ein solcher Algorithmus aus Leistungsgr√ºnden implementiert. <br><br><a name="5"></a><h1>  Zaubertrick: Beschneidung </h1><br>  Zum Gl√ºck habe ich einen Trick gefunden.  Es gibt eine Programmierschnittstelle, die den Speicherzuweiser zwingt, nicht nur die letzte, sondern <i>alle</i> relevanten Systemseiten f√ºr den Kernel freizugeben.  Es hei√üt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">malloc_trim</a> . <br><br>  Ich wusste √ºber diese Funktion Bescheid, hielt sie jedoch nicht f√ºr n√ºtzlich, da im Handbuch Folgendes steht: <br><br><blockquote>  Die Funktion malloc_trim () versucht, freien Speicher am oberen Rand des Heaps freizugeben. </blockquote><br>  <b>Das Handbuch ist falsch!</b>  Die Analyse des Quellcodes besagt, dass das Programm alle relevanten Systemseiten freigibt, nicht nur die obersten. <br><br>  Was passiert, wenn diese Funktion w√§hrend der Speicherbereinigung aufgerufen wird?  Ich habe den Ruby 2.6-Quellcode so ge√§ndert, dass <code>malloc_trim()</code> in der Funktion gc_start von gc.c aufgerufen wird, zum Beispiel: <br><br><pre> <code class="cpp hljs">gc_prof_timer_start(objspace); { gc_marks(objspace, do_full_mark); <span class="hljs-comment"><span class="hljs-comment">// BEGIN MODIFICATION if (do_full_mark) { malloc_trim(0); } // END MODIFICATION } gc_prof_timer_stop(objspace);</span></span></code> </pre> <br>  Und hier sind die Testergebnisse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f4/cfc/063/1f4cfc063a1c0672a80ed11baec2c323.png"></div><br><br>  <b>Was f√ºr ein gro√üer Unterschied!</b>  Ein einfacher Patch reduzierte den Speicherverbrauch auf fast <code>MALLOC_ARENA_MAX=2</code> . <br><br>  So sieht es in der Visualisierung aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/410/594/9de410594884baa131d3b8e52d7c6656.png"></div><br><br>  Wir sehen viele wei√üe Bereiche, die den im Kernel freigegebenen Systemseiten entsprechen. <br><br><a name="6"></a><h1>  Fazit </h1><br>  Es stellte sich heraus, dass Fragmentierung im Grunde nichts damit zu tun hatte.  Die Defragmentierung ist immer noch n√ºtzlich, aber das Hauptproblem besteht darin, dass der Speicherzuweiser den Speicher nicht gerne an den Kernel zur√ºckgeben m√∂chte. <br><br>  Gl√ºcklicherweise erwies sich die L√∂sung als sehr einfach.  Die Hauptsache war, die Grundursache zu finden. <br><br><a name="6_1"></a><h3>  Visualizer-Quellcode </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode</a> <br><br><a name="6_2"></a><h3>  Was ist mit Leistung? </h3><br>  Die Leistung blieb eines der Hauptanliegen.  Das Aufrufen von <code>malloc_trim()</code> kann nicht kostenlos <code>malloc_trim()</code> , aber gem√§√ü dem Code arbeitet der Algorithmus in linearer Zeit.  Also wandte ich mich an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noah Gibbs</a> , der den Rails Ruby Bench Benchmark startete.  Zu meiner √úberraschung f√ºhrte der Patch zu einer leichten Leistungssteigerung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/115/88c/7e511588c662a60e0f8a82556b2e1988.jpg"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/c8e/f91/474c8ef919bf360ecf45f365e1a87ab0.jpg"></div><br><br>  Es hat mich umgehauen.  Der Effekt ist unverst√§ndlich, aber die Nachrichten sind gut. <br><br><a name="6_3"></a><h3>  Ben√∂tigen Sie weitere Tests. </h3><br>  Im Rahmen dieser Studie wurde nur eine begrenzte Anzahl von F√§llen verifiziert.  Es ist nicht bekannt, wie sich dies auf andere Workloads auswirkt.  Wenn Sie beim Testen helfen m√∂chten, <a href="">kontaktieren Sie mich</a> bitte. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444482/">https://habr.com/ru/post/de444482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444470/index.html">20 Gewohnheiten f√ºr die Aufmerksamkeitshygiene: Umgang mit Technologie, aber nicht zulassen, dass sie sich Zeit und Aufmerksamkeit nehmen</a></li>
<li><a href="../de444472/index.html">Emulieren von Amazon-Webdiensten in einem JVM-Prozess. Vermeiden Sie Roskomnadzor und beschleunigen Sie die Entwicklung und das Testen</a></li>
<li><a href="../de444474/index.html">Bau der Kommunikationslinie Sachalin-Kuril. Segero Tour - Seilbahn</a></li>
<li><a href="../de444476/index.html">Wettbewerb von RUSNANO: Nehmen Sie an einem Online-Kurs √ºber moderne Mikroelektronik teil, dann an einer praktischen Tour mit FPGAs, und erhalten Sie einen Preis</a></li>
<li><a href="../de444480/index.html">So reduzieren Sie das Gewicht eines Flugzeugstrukturelements um ein Drittel</a></li>
<li><a href="../de444484/index.html">Sch√§tzung der Bedingungen f√ºr die Aufgabenentwicklung und das Testen (nicht erforderlich)</a></li>
<li><a href="../de444486/index.html">Das SIRIUS-19-Projekt ist eine viermonatige Simulation einer Expedition zum Mond in einem bodengest√ºtzten Komplex in Moskau</a></li>
<li><a href="../de444490/index.html">Ich habe die Ukraine gescannt</a></li>
<li><a href="../de444492/index.html">Abenteuer aus heiterem Himmel</a></li>
<li><a href="../de444494/index.html">La Moto Volante (Lazareth LMV 496) - fliegendes Transformatormotorrad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>