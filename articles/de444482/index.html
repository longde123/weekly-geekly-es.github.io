<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👦 ↔️ 🏨 Was bläst das Gedächtnis in Ruby auf? ☕️ 📭 👃🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir bei Phusion haben einen einfachen Multithread-HTTP-Proxy in Ruby (vertreibt DEB- und RPM-Pakete). Ich sah darauf einen Speicherverbrauch von 1,3 G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was bläst das Gedächtnis in Ruby auf?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444482/">  Wir bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phusion haben</a> einen einfachen Multithread-HTTP-Proxy in Ruby (vertreibt DEB- und RPM-Pakete).  Ich sah darauf einen Speicherverbrauch von 1,3 GB.  Aber das ist verrückt nach einem staatenlosen Prozess ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/f7a/d2b/9baf7ad2bd3ecdfb0779482c018473eb.jpg"></div><br>  <i><font color="gray">Frage: Was ist das?</font></i>  <i><font color="gray">Antwort: Ruby nutzt den Speicher im Laufe der Zeit!</font></i> <br><br>  Es stellt sich heraus, dass ich mit diesem Problem nicht allein bin.  Ruby-Anwendungen können viel Speicher belegen.  Aber warum?  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heroku</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nate Burkopek</a> ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufblähen</a> hauptsächlich auf Speicherfragmentierung und übermäßige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heap-</a> Verteilung zurückzuführen. <br><a name="habracut"></a><br>  Berkopek kam zu dem Schluss, dass es zwei Lösungen gibt: <br><br><ol><li>  Verwenden Sie entweder einen völlig anderen Speicherzuweiser als glibc - normalerweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jemalloc</a> , oder: </li><li> Setzen Sie die magische Umgebungsvariable <code>MALLOC_ARENA_MAX=2</code> . </li></ol><br>  Ich mache mir Sorgen um die Beschreibung des Problems und die vorgeschlagenen Lösungen.  Hier stimmt etwas nicht ... Ich bin nicht sicher, ob das Problem vollständig beschrieben ist oder ob dies die einzigen verfügbaren Lösungen sind.  Es ärgert mich auch, dass viele Jemalloc als magischen Silberpool bezeichnen. <br><br>  <b>Magie ist nur eine Wissenschaft, die wir noch nicht verstehen</b> .  Also machte ich eine Forschungsreise, um die ganze Wahrheit herauszufinden.  Dieser Artikel behandelt die folgenden Themen: <br><br><ol><li>  So funktioniert die Speicherzuordnung. <br></li><li>  Was ist diese "Fragmentierung" und "übermäßige Verteilung" des Gedächtnisses, von der alle sprechen? <br></li><li>  Was verursacht einen hohen Speicherverbrauch?  Stimmt die Situation mit dem überein, was die Leute sagen, oder gibt es noch etwas anderes?  (Spoiler: Ja, da ist noch etwas). <br></li><li>  Gibt es alternative Lösungen?  (Spoiler: Ich habe einen gefunden). </li></ol><br>  <i>Hinweis: Dieser Artikel ist nur für Linux und nur für Ruby-Anwendungen mit mehreren Threads relevant.</i> <br><br><h1>  Inhalt </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ruby Memory Allocation: Eine Einführung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ruby</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemspeicherzuordnung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Kern</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definition der Speichernutzung</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist Fragmentierung?</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ruby Level Fragmentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fragmentierung der Speicherzuordnung</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verursacht die Fragmentierung der Ruby-Heap-Seite ein Aufblähen des Speichers?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Studie zur Fragmentierung der Speicherzuordnung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übermäßige Speicherzuordnung und Glibc</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visualisierung von Systemhaufen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zaubertrick: Beschneidung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visualizer-Quellcode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist mit Leistung?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benötigen Sie weitere Tests.</a> </li></ul></li></ul><br><a name="1"></a><h1>  Ruby Memory Allocation: Eine Einführung </h1><br>  Ruby ordnet Speicher auf drei Ebenen von oben nach unten zu: <br><br><ol><li>  Ruby-Interpreter, der Ruby-Objekte verwaltet. <br></li><li>  Die Speicherzuordnungsbibliothek des Betriebssystems. <br></li><li>  Der Kern. </li></ol><br>  Lass uns durch jedes Level gehen. <br><br><a name="1_1"></a><h3>  Ruby </h3><br>  Auf seiner Seite organisiert Ruby Objekte in Speicherbereichen, die als <i>Ruby-Heap-Seiten bezeichnet werden</i> .  Eine solche Heap-Seite ist in Slots gleicher Größe unterteilt, wobei ein Objekt einen Slot belegt.  Unabhängig davon, ob es sich um eine Zeichenfolge, eine Hash-Tabelle, ein Array, eine Klasse oder etwas anderes handelt, belegt sie einen Steckplatz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d6/155/0be/2d61550be208df42ad3052ca1f821807.png"></div><br><br>  Die Slots auf der Heap-Seite sind möglicherweise belegt oder frei.  Wenn Ruby ein neues Objekt auswählt, versucht es sofort, einen freien Platz zu belegen.  Wenn keine freien Slots vorhanden sind, wird eine neue Heap-Seite hervorgehoben. <br><br>  Der Steckplatz ist klein, ungefähr 40 Bytes.  Offensichtlich passen einige Objekte nicht hinein, z. B. 1 MB Zeilen.  Dann speichert Ruby die Informationen an einer anderen Stelle außerhalb der Heap-Seite und platziert einen Zeiger auf diesen externen Speicherbereich im Steckplatz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/e96/1c6/1e5e961c6c90ed1cd17daa8ab19d8212.png"></div><br>  <i><font color="gray">Daten, die nicht in den Steckplatz passen, werden außerhalb der Heap-Seite gespeichert.</font></i>  <i><font color="gray">Ruby platziert einen Zeiger auf diese externen Daten im Steckplatz</font></i> <br><br>  Sowohl Ruby-Heap-Seiten als auch externe Speicherbereiche werden mithilfe des Systemspeicherzuordners zugewiesen. <br><br><a name="1_2"></a><h3>  Systemspeicherzuordnung </h3><br>  Der Speicherzuweiser des Betriebssystems ist Teil von glibc (C-Laufzeit).  Es wird von fast allen Anwendungen verwendet, nicht nur von Ruby.  Es hat eine einfache API: <br><br><ul><li>  Der Speicher wird durch Aufrufen von <code>malloc(size)</code> zugewiesen.  Sie geben ihm die Anzahl der Bytes, die Sie zuweisen möchten, und es gibt entweder die Zuordnungsadresse oder einen Fehler zurück. </li><li>  Der zugewiesene Speicher wird durch Aufrufen von <code>free(address)</code> freigegeben. </li></ul><br>  Im Gegensatz zu Ruby, wo Slots derselben Größe zugewiesen werden, verarbeitet der Speicherzuweiser Anforderungen zum Zuweisen von Speicher beliebiger Größe.  Wie Sie später erfahren werden, führt diese Tatsache zu einigen Komplikationen. <br><br>  Der Speicherzuweiser greift wiederum auf die Kernel-API zu.  Der Kernel benötigt viel größere Speicherblöcke als von seinen eigenen Abonnenten angefordert, da der Kernelaufruf teuer ist und die Kernel-API eine Einschränkung aufweist: Sie kann nur Speicher in Vielfachen von 4 KB zuweisen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/dba/21a/323dba21a7b5ad2df8e1f9335d6b7c11.png"></div><br>  <i><font color="gray">Der Speicherzuweiser weist große Blöcke zu - sie werden als Systemhaufen bezeichnet - und teilt ihren Inhalt, um Anforderungen von Anwendungen zu erfüllen</font></i> <br><br>  Der Speicherbereich, den der Speicherzuweiser vom Kernel zuweist, wird als Heap bezeichnet.  Beachten Sie, dass dies nichts mit den Seiten des Ruby-Heaps zu tun hat. Aus Gründen der Übersichtlichkeit wird der Begriff <i>System-Heap verwendet</i> . <br><br>  Der Speicherzuweiser weist dann seinen Anrufern Teile der Systemhaufen zu, bis freier Speicherplatz vorhanden ist.  In diesem Fall weist der Speicherzuweiser einen neuen Systemheap vom Kernel zu.  Dies ähnelt der Auswahl von Objekten aus den Seiten eines Ruby-Heaps durch Ruby. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/f81/c11/453f81c11aaadb818ecdcf798112db99.png"></div><br>  <i><font color="gray">Ruby reserviert Speicher vom Speicherzuweiser, der wiederum Speicher vom Kernel zuweist</font></i> <br><br><a name="1_3"></a><h3>  Der Kern </h3><br>  Der Kernel kann nur Speicher in 4-KB-Einheiten zuweisen.  Ein solcher 4K-Block wird als Seite bezeichnet.  Um Verwechslungen mit den Ruby-Heap-Seiten zu vermeiden, verwenden wir aus Gründen der Übersichtlichkeit den Begriff <i>Systemseite</i> (Betriebssystemseite). <br><br>  Der Grund ist schwer zu erklären, aber alle modernen Kernel funktionieren auf diese Weise. <br><br>  Das Zuweisen von Speicher über den Kernel hat erhebliche Auswirkungen auf die Leistung, weshalb Speicherzuweiser versuchen, die Anzahl der Kernelaufrufe zu minimieren. <br><br><a name="1_4"></a><h3>  Definition der Speichernutzung </h3><br>  Somit wird Speicher auf mehreren Ebenen zugewiesen, und jede Ebene weist mehr Speicher zu, als er wirklich benötigt.  Ruby-Heap-Seiten können sowohl freie Slots als auch System-Heaps enthalten.  Daher die Antwort auf die Frage "Wie viel Speicher wird verwendet?"  hängt ganz davon ab, welches Level du fragst! <br><br>  Tools wie <code>top</code> oder <code>ps</code> zeigen die Speichernutzung aus <b>Kernel-</b> Sicht.  Dies bedeutet, dass höhere Ebenen zusammenarbeiten müssen, um Speicher aus Kernel-Sicht freizugeben.  Wie Sie später erfahren werden, ist dies schwieriger als es sich anhört. <br><br><a name="2"></a><h1>  Was ist Fragmentierung? </h1><br>  Speicherfragmentierung bedeutet, dass Speicherzuordnungen zufällig verteilt sind.  Dies kann interessante Probleme verursachen. <br><br><a name="2_1"></a><h3>  Ruby Level Fragmentation </h3><br>  Betrachten Sie Ruby Garbage Collection.  Die Speicherbereinigung für ein Objekt bedeutet, dass der Ruby-Heap-Seitenschlitz als frei markiert wird, damit er wiederverwendet werden kann.  Wenn die gesamte Seite des Ruby-Heaps nur aus freien Slots besteht, kann die gesamte Seite an den Speicherzuweiser (und möglicherweise an den Kernel) zurückgegeben werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/cde/97d/27bcde97d27e6aeed3dc2020a4eda766.png"></div><br><br>  Aber was passiert, wenn nicht alle Slots frei sind?  Was ist, wenn wir viele Seiten des Ruby-Heaps haben und der Garbage Collector Objekte an verschiedenen Orten freigibt, sodass am Ende viele freie Slots vorhanden sind, jedoch auf verschiedenen Seiten?  In dieser Situation verfügt Ruby über freie Steckplätze zum Platzieren von Objekten, aber der Speicherzuweiser und der Kernel weisen weiterhin Speicher zu! <br><br><a name="2_2"></a><h3>  Fragmentierung der Speicherzuordnung </h3><br>  Der Speicherzuweiser hat ein ähnliches, aber völlig anderes Problem.  Er muss nicht sofort ganze Systemhaufen löschen.  Theoretisch kann jede einzelne Systemseite freigegeben werden.  Da sich der Speicherzuweiser jedoch mit Speicherzuordnungen beliebiger Größe befasst, kann es auf der Systemseite mehrere Zuordnungen geben.  Die Systemseite kann erst freigegeben werden, wenn alle Auswahlen freigegeben sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76b/723/850/76b72385026fa24bd18b7db324d7353b.png"></div><br><br>  Überlegen Sie, was passiert, wenn wir eine 3-KB-Zuordnung sowie eine 2-KB-Zuordnung haben, die in zwei Systemseiten unterteilt sind.  Wenn Sie die ersten 3 KB freigeben, bleiben beide Systemseiten teilweise belegt und können nicht freigegeben werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc2/cf1/70f/cc2cf170facbc6bca673014e33389606.png"></div><br><br>  Wenn die Umstände fehlschlagen, ist auf den Systemseiten viel freier Speicherplatz vorhanden, der jedoch nicht vollständig freigegeben wird. <br><br>  Schlimmer noch: Was ist, wenn es viele freie Plätze gibt, aber keiner groß genug ist, um eine neue Zuteilungsanfrage zu erfüllen?  Der Speicherzuweiser muss einen ganz neuen Systemheap zuweisen. <br><br><a name="3"></a><h1>  Verursacht die Fragmentierung der Ruby-Heap-Seite ein Aufblähen des Speichers? </h1><br>  Es ist wahrscheinlich, dass die Fragmentierung in Ruby zu einer Überbeanspruchung des Speichers führt.  Wenn ja, welche der beiden Fragmentierungen ist schädlicher?  Das… <br><br><ol><li>  Ruby Heap Page Fragmentierung?  Oder <br></li><li>  Speicherzuweisungsfragmentierung? </li></ol><br>  Die erste Option ist recht einfach zu überprüfen.  Ruby bietet zwei APIs: <code>ObjectSpace.memsize_of_all</code> und <code>GC.stat</code> .  Dank dieser Informationen können Sie den gesamten Speicher berechnen, den Ruby vom Allokator erhalten hat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb8/f7e/30e/cb8f7e30e363d2fa57f0fc37b84183fe.png"></div><br><br>  <code>ObjectSpace.memsize_of_all</code> gibt den von allen aktiven Ruby-Objekten belegten Speicher zurück.  Das heißt, der gesamte Speicherplatz in ihren Steckplätzen und alle externen Daten.  Im obigen Diagramm ist dies die Größe aller blauen und orangefarbenen Objekte. <br><br>  <code>GC.stat</code> können <code>GC.stat</code> die Größe aller freien Slots ermitteln, d. H. Den gesamten grauen Bereich in der obigen Abbildung.  Hier ist der Algorithmus: <br><br><pre> <code class="cpp hljs">GC.stat[:heap_free_slots] * GC::INTERNAL_CONSTANTS[:RVALUE_SIZE]</code> </pre> <br>  Zusammenfassend ist dies der gesamte Speicher, den Ruby kennt, und es geht darum, die Seiten des Ruby-Heaps zu fragmentieren.  Wenn aus Kernel-Sicht die Speichernutzung höher ist, wird der verbleibende Speicher außerhalb der Kontrolle von Ruby gespeichert, z. B. für Bibliotheken oder Fragmentierung von Drittanbietern. <br><br>  Ich habe ein einfaches Testprogramm geschrieben, das eine Reihe von Threads erstellt, von denen jeder Zeilen in einer Schleife auswählt.  Hier ist das Ergebnis nach einer Weile: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4e/859/2fc/a4e8592fc1d2edf2f11957844d33e55d.png"></div><br><br>  es ist ... nur ... verrückt! <br><br>  Das Ergebnis zeigt, dass Ruby einen so schwachen Effekt auf die Gesamtmenge des verwendeten Speichers hat, dass es keine Rolle spielt, ob die Seiten des Ruby-Heaps fragmentiert sind oder nicht. <br><br>  Müssen woanders nach dem Täter suchen.  Zumindest wissen wir jetzt, dass Ruby nicht schuld ist. <br><br><a name="4"></a><h1>  Studie zur Fragmentierung der Speicherzuordnung </h1><br>  Ein weiterer wahrscheinlicher Verdächtiger ist ein Speicherzuweiser.  Am Ende stellten Nate Berkopek und Heroku fest, dass die Arbeit mit dem Speicherzuweiser (entweder das vollständige Ersetzen von jemalloc oder das Setzen der magischen Umgebungsvariablen <code>MALLOC_ARENA_MAX=2</code> ) die Speichernutzung drastisch reduziert. <br><br>  Mal sehen, was <code>MALLOC_ARENA_MAX=2</code> macht und warum es hilft.  Dann untersuchen wir die Fragmentierung auf Verteilerebene. <br><br><a name="4_1"></a><h3>  Übermäßige Speicherzuordnung und Glibc </h3><br>  Der Grund, warum <code>MALLOC_ARENA_MAX=2</code> hilft, ist Multithreading.  Wenn mehrere Threads gleichzeitig versuchen, Speicher von demselben Systemheap zuzuweisen, kämpfen sie um den Zugriff.  Es kann jeweils nur ein Thread Speicher empfangen, was die Leistung der Multithread-Speicherzuweisung verringert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a40/99c/65b/a4099c65b73541efa05c38008fa0e181.png"></div><br>  <i><font color="gray">Es kann jeweils nur ein Thread mit dem Systemheap arbeiten.</font></i>  <i><font color="gray">Bei Multithread-Aufgaben tritt ein Konflikt auf und folglich nimmt die Leistung ab</font></i> <br><br>  Im Speicherzuweiser für einen solchen Fall gibt es eine Optimierung.  Er versucht, mehrere System-Heaps zu erstellen und sie verschiedenen Threads zuzuweisen.  Meistens arbeitet ein Thread nur mit seinem eigenen Heap, um Konflikte mit anderen Threads zu vermeiden. <br><br>  Tatsächlich entspricht die maximale Anzahl der auf diese Weise zugewiesenen System-Heaps standardmäßig der Anzahl der virtuellen Prozessoren multipliziert mit 8. Das heißt, in einem Dual-Core-System mit zwei Hyper-Threads werden jeweils <code>2 * 2 * 8 = 32</code> System-Heaps erzeugt!  Das nenne ich <b>übermäßige Verteilung</b> . <br><br>  Warum ist der Standardmultiplikator so groß?  Weil der führende Entwickler des Speicherzuweisers Red Hat ist.  Ihre Kunden sind große Unternehmen mit leistungsstarken Servern und einer Menge RAM.  Mit der obigen Optimierung können Sie die durchschnittliche Multithreading-Leistung aufgrund einer signifikanten Erhöhung der Speichernutzung um 10% steigern.  Für Red Hat-Kunden ist dies ein guter Kompromiss.  Für die meisten anderen - kaum. <br><br>  Nate argumentiert in ihrem Blog und in ihrem Heroku-Artikel, dass eine Erhöhung der Anzahl der Systemhaufen die Fragmentierung erhöht, und zitiert offizielle Dokumentation.  Die Variable <code>MALLOC_ARENA_MAX</code> reduziert die maximale Anzahl von System-Heaps, die für Multithreading zugewiesen sind.  Durch diese Logik wird die Fragmentierung reduziert. <br><br><a name="4_2"></a><h3>  Visualisierung von Systemhaufen </h3><br>  Stimmt die Aussage von Nate und Heroku, dass eine Erhöhung der Anzahl der Systemhaufen die Fragmentierung erhöht?  Gibt es tatsächlich ein Problem mit der Fragmentierung auf der Ebene des Speicherzuweisers?  Ich wollte keine dieser Annahmen für selbstverständlich halten, also begann ich mit der Studie. <br><br>  Leider gibt es keine Tools zum Visualisieren von Systemhaufen, daher habe <b>ich selbst einen solchen Visualizer geschrieben</b> . <br><br>  Erstens müssen Sie das Verteilungsschema von System-Heaps irgendwie beibehalten.  Ich habe die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle des Speicherzuweisers untersucht</a> und mir angesehen, wie er den Speicher intern darstellt.  Dann schrieb er eine Bibliothek, die diese Datenstrukturen durchläuft und das Schema in eine Datei schreibt.  Schließlich schrieb er ein Tool, das eine solche Datei als Eingabe verwendet und die Visualisierung als HTML- und PNG-Bilder ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kompiliert</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/adb/064/309adb06474b3ec49bb2d0d6622bbb48.png"></div><br><br>  Hier ist ein Beispiel für die Visualisierung eines bestimmten Systemheaps (es gibt viele weitere).  Kleine Blöcke in dieser Visualisierung repräsentieren Systemseiten. <br><br><ul><li>  Rote Bereiche werden als Speicherzellen verwendet. </li><li>  Grautöne sind freie Bereiche, die nicht in den Kern zurückgeführt werden. </li><li>  Weiße Bereiche werden für den Kern freigegeben. </li></ul><br>  Die folgenden Schlussfolgerungen können aus der Visualisierung gezogen werden: <br><br><ol><li>  Es gibt eine gewisse Fragmentierung.  Rote Flecken werden aus dem Speicher gestreut, und einige Systemseiten sind nur halbrot. <br></li><li>  Zu meiner Überraschung enthalten die <i>meisten</i> Systemhaufen eine erhebliche Anzahl vollständig freier Systemseiten (grau)! </li></ol><br>  Und dann dämmerte es mir: <br><br>  <i><b>Obwohl Fragmentierung ein Problem bleibt, ist es nicht der Punkt!</b></i> <br><br>  Vielmehr ist das Problem sehr grau: Dieser Speicherzuweiser <i>sendet keinen Speicher zurück an den Kernel</i> ! <br><br>  Nach einer erneuten Untersuchung des Quellcodes des Speicherzuweisers stellte sich heraus, dass standardmäßig nur Systemseiten am Ende des Systemheaps an den Kernel gesendet werden, und dies sogar <i>selten</i> .  Wahrscheinlich ist ein solcher Algorithmus aus Leistungsgründen implementiert. <br><br><a name="5"></a><h1>  Zaubertrick: Beschneidung </h1><br>  Zum Glück habe ich einen Trick gefunden.  Es gibt eine Programmierschnittstelle, die den Speicherzuweiser zwingt, nicht nur die letzte, sondern <i>alle</i> relevanten Systemseiten für den Kernel freizugeben.  Es heißt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">malloc_trim</a> . <br><br>  Ich wusste über diese Funktion Bescheid, hielt sie jedoch nicht für nützlich, da im Handbuch Folgendes steht: <br><br><blockquote>  Die Funktion malloc_trim () versucht, freien Speicher am oberen Rand des Heaps freizugeben. </blockquote><br>  <b>Das Handbuch ist falsch!</b>  Die Analyse des Quellcodes besagt, dass das Programm alle relevanten Systemseiten freigibt, nicht nur die obersten. <br><br>  Was passiert, wenn diese Funktion während der Speicherbereinigung aufgerufen wird?  Ich habe den Ruby 2.6-Quellcode so geändert, dass <code>malloc_trim()</code> in der Funktion gc_start von gc.c aufgerufen wird, zum Beispiel: <br><br><pre> <code class="cpp hljs">gc_prof_timer_start(objspace); { gc_marks(objspace, do_full_mark); <span class="hljs-comment"><span class="hljs-comment">// BEGIN MODIFICATION if (do_full_mark) { malloc_trim(0); } // END MODIFICATION } gc_prof_timer_stop(objspace);</span></span></code> </pre> <br>  Und hier sind die Testergebnisse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f4/cfc/063/1f4cfc063a1c0672a80ed11baec2c323.png"></div><br><br>  <b>Was für ein großer Unterschied!</b>  Ein einfacher Patch reduzierte den Speicherverbrauch auf fast <code>MALLOC_ARENA_MAX=2</code> . <br><br>  So sieht es in der Visualisierung aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/410/594/9de410594884baa131d3b8e52d7c6656.png"></div><br><br>  Wir sehen viele weiße Bereiche, die den im Kernel freigegebenen Systemseiten entsprechen. <br><br><a name="6"></a><h1>  Fazit </h1><br>  Es stellte sich heraus, dass Fragmentierung im Grunde nichts damit zu tun hatte.  Die Defragmentierung ist immer noch nützlich, aber das Hauptproblem besteht darin, dass der Speicherzuweiser den Speicher nicht gerne an den Kernel zurückgeben möchte. <br><br>  Glücklicherweise erwies sich die Lösung als sehr einfach.  Die Hauptsache war, die Grundursache zu finden. <br><br><a name="6_1"></a><h3>  Visualizer-Quellcode </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode</a> <br><br><a name="6_2"></a><h3>  Was ist mit Leistung? </h3><br>  Die Leistung blieb eines der Hauptanliegen.  Das Aufrufen von <code>malloc_trim()</code> kann nicht kostenlos <code>malloc_trim()</code> , aber gemäß dem Code arbeitet der Algorithmus in linearer Zeit.  Also wandte ich mich an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noah Gibbs</a> , der den Rails Ruby Bench Benchmark startete.  Zu meiner Überraschung führte der Patch zu einer leichten Leistungssteigerung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/115/88c/7e511588c662a60e0f8a82556b2e1988.jpg"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/c8e/f91/474c8ef919bf360ecf45f365e1a87ab0.jpg"></div><br><br>  Es hat mich umgehauen.  Der Effekt ist unverständlich, aber die Nachrichten sind gut. <br><br><a name="6_3"></a><h3>  Benötigen Sie weitere Tests. </h3><br>  Im Rahmen dieser Studie wurde nur eine begrenzte Anzahl von Fällen verifiziert.  Es ist nicht bekannt, wie sich dies auf andere Workloads auswirkt.  Wenn Sie beim Testen helfen möchten, <a href="">kontaktieren Sie mich</a> bitte. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444482/">https://habr.com/ru/post/de444482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444470/index.html">20 Gewohnheiten für die Aufmerksamkeitshygiene: Umgang mit Technologie, aber nicht zulassen, dass sie sich Zeit und Aufmerksamkeit nehmen</a></li>
<li><a href="../de444472/index.html">Emulieren von Amazon-Webdiensten in einem JVM-Prozess. Vermeiden Sie Roskomnadzor und beschleunigen Sie die Entwicklung und das Testen</a></li>
<li><a href="../de444474/index.html">Bau der Kommunikationslinie Sachalin-Kuril. Segero Tour - Seilbahn</a></li>
<li><a href="../de444476/index.html">Wettbewerb von RUSNANO: Nehmen Sie an einem Online-Kurs über moderne Mikroelektronik teil, dann an einer praktischen Tour mit FPGAs, und erhalten Sie einen Preis</a></li>
<li><a href="../de444480/index.html">So reduzieren Sie das Gewicht eines Flugzeugstrukturelements um ein Drittel</a></li>
<li><a href="../de444484/index.html">Schätzung der Bedingungen für die Aufgabenentwicklung und das Testen (nicht erforderlich)</a></li>
<li><a href="../de444486/index.html">Das SIRIUS-19-Projekt ist eine viermonatige Simulation einer Expedition zum Mond in einem bodengestützten Komplex in Moskau</a></li>
<li><a href="../de444490/index.html">Ich habe die Ukraine gescannt</a></li>
<li><a href="../de444492/index.html">Abenteuer aus heiterem Himmel</a></li>
<li><a href="../de444494/index.html">La Moto Volante (Lazareth LMV 496) - fliegendes Transformatormotorrad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>