<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèø üåù üë®üèæ‚Äçüè≠ Comment nous avons optimis√© les scripts dans Unity üîª üêÉ ü§≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il existe de nombreux articles et didacticiels sur les performances d'Unity. Nous n'essayons pas de les remplacer ou de les am√©liorer avec cet article...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment nous avons optimis√© les scripts dans Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481980/"> Il existe de nombreux articles et didacticiels sur les performances d'Unity.  Nous n'essayons pas de les remplacer ou de les am√©liorer avec cet article, ce n'est qu'un bref r√©sum√© des √©tapes que nous avons suivies apr√®s avoir lu ces articles, ainsi que les √©tapes qui nous ont permis de r√©soudre nos probl√®mes.  Je vous recommande fortement d'√©tudier au moins les documents sur <a href="https://learn.unity.com/">https://learn.unity.com/</a> . <br><br>  Dans le processus de d√©veloppement de notre jeu, nous avons rencontr√© des probl√®mes qui, de temps en temps, ont provoqu√© une inhibition du processus de jeu.  Apr√®s avoir pass√© du temps dans Unity Profiler, nous avons trouv√© deux types de probl√®mes: <br><br><ul><li>  Shaders non optimis√©s </li><li>  Scripts non optimis√©s en C # </li></ul><br>  La plupart des probl√®mes ont √©t√© caus√©s par le deuxi√®me groupe, j'ai donc d√©cid√© de me concentrer sur les scripts C # dans cet article (peut-√™tre aussi parce que je n'ai pas √©crit un seul shader dans ma vie). <br><br><h1>  Recherche de faiblesses </h1><br>  Le but de cet article n'est pas d'√©crire un didacticiel sur l'utilisation d'un profileur;  Je voulais juste parler de ce qui nous int√©ressait principalement pendant le processus de profilage. <br><br>  <strong>Unity Profiler est toujours le meilleur moyen de</strong> trouver les causes des retards dans les scripts.  Je recommande fortement de <strong>profiler le jeu directement dans l'appareil</strong> , et non dans l'√©diteur.  Depuis que notre jeu a √©t√© cr√©√© pour iOS, je devais connecter l'appareil et utiliser les param√®tres de construction affich√©s dans l'image, apr√®s quoi le profileur se connectait automatiquement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c7/fad/0e0/5c7fad0e0596f91c183a80ea3d72d1ae.png"></div><br>  <em>Param√®tres de g√©n√©ration pour le profilage</em> <br><br>  Si vous essayez de google "Random lag in Unity" ou une autre demande similaire, vous constaterez que la plupart des gens recommandent de se <strong>concentrer sur la collecte des ordures</strong> , ce qui est exactement ce que j'ai fait.  Des ordures sont g√©n√©r√©es chaque fois que vous cessez d'utiliser un objet (instance de classe), apr√®s quoi le garbage collector Unity d√©marre de temps en temps pour nettoyer le d√©sordre et lib√©rer de la m√©moire, ce qui prend un temps fou et entra√Æne une baisse de la fr√©quence d'images. <br><a name="habracut"></a><br><h2>  Comment trouver des scripts ind√©sirables dans le profileur? </h2><br>  S√©lectionnez simplement Utilisation du processeur -&gt; Choisir la vue Hi√©rarchie -&gt; Trier par l'allocation GC <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/aed/605/167aed6059ad0276a4275d5edf2179db.png"></div><br>  <em>Options du profileur pour la r√©cup√©ration de place</em> <br><br>  Votre t√¢che consiste √† obtenir des z√©ros dans la colonne d'allocation GC pour la sc√®ne de gameplay. <br><br>  Un autre bon moyen est de <strong>trier les entr√©es par Time ms</strong> (runtime) et d'optimiser les scripts afin qu'ils prennent le moins de temps possible.  Cette √©tape a eu un impact √©norme pour nous, car l'un de nos composants contenait une <strong>grande boucle for</strong> , qui a pris une √©ternit√© (oui, nous n'avons pas encore trouv√© de moyen de se d√©barrasser de la boucle), donc l'optimisation du temps d'ex√©cution de tous les scripts √©tait absolument n√©cessaire pour nous, car nous devions √©conomiser le temps d'ex√©cution sur cette boucle co√ªteuse, tout en maintenant une fr√©quence stable de 60 ips. <br><br>  Sur la base des donn√©es de profilage, j'ai divis√© l'optimisation en deux parties: <br><br><ul><li>  √âlimination des ordures </li><li>  D√©lai d'ex√©cution r√©duit </li></ul><br><h1>  Partie 1: combattre les d√©chets </h1><br>  Dans cette partie, je vais vous dire ce que nous avons fait pour nous d√©barrasser des ordures.  Il s'agit des connaissances les plus fondamentales que tout d√©veloppeur doit comprendre;  ils sont devenus une partie importante de notre analyse quotidienne dans chaque demande de pull / merge. <br><br><h2>  Premi√®re r√®gle: pas de nouveaux objets dans les m√©thodes de mise √† jour </h2><br>  Id√©alement, les <strong>m√©thodes Update, FixedUpdate et LateUpdate ne doivent pas contenir les "nouveaux" mots cl√©s</strong> .  Vous devez toujours utiliser ce que vous avez d√©j√†. <br><br>  Parfois, la <strong>cr√©ation d'un nouvel objet est masqu√©e</strong> dans certaines m√©thodes Unity internes, ce n'est donc pas si √©vident.  Nous en reparlerons plus tard. <br><br><h2>  Deuxi√®me r√®gle: cr√©ez une fois et r√©utilisez! </h2><br>  En substance, cela signifie que vous devez allouer de la m√©moire pour tout ce que vous pouvez dans les m√©thodes Start et Awake.  Cette r√®gle est tr√®s similaire √† la premi√®re.  Il s'agit en fait d'une autre fa√ßon d'√©liminer les ¬´nouveaux¬ª mots cl√©s des m√©thodes de mise √† jour. <br><br>  Code que: <br><br><ul><li>  cr√©e de nouvelles instances </li><li>  √† la recherche d'objets de jeu </li></ul><br>  Vous devez toujours essayer de passer des m√©thodes Update √† Start ou Awake. <br><br>  Voici des exemples de nos changements: <br><br>  Allocation de m√©moire pour les listes de la m√©thode Start, leur effacement (Clear) et r√©utilisation si n√©cessaire. <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code private List&lt;GameObject&gt; objectsList; void Update() { objectsList = new List&lt;GameObject&gt;(); objectsList.Add(......) } //Better Code private List&lt;GameObject&gt; objectsList; void Start() { objectsList = new List&lt;GameObject&gt;(); } void Update() { objectsList.Clear(); objectsList.Add(......) }</span></span></code> </pre> <br>  Stocker les liens et les r√©utiliser comme suit: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Update() { var levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); foreach(var obstacle in levelObstacles) { ....... } } //Better code private Object[] levelObstacles; void Start() { levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); } void Update() { foreach(var obstacle in levelObstacles) { ....... } }</span></span></code> </pre> <br>  La m√™me chose s'applique √† la m√©thode FindGameObjectsWithTag ou √† toute autre m√©thode qui renvoie un nouveau tableau. <br><br><h2>  La troisi√®me r√®gle: m√©fiez-vous des cha√Ænes et √©vitez de les encha√Æner </h2><br>  Quand il s'agit de cr√©er des ordures, les lignes sont terribles.  M√™me les op√©rations de cha√Æne les plus simples peuvent cr√©er beaucoup de d√©chets.  Pourquoi?  Les cha√Ænes ne sont que des tableaux et ces tableaux sont immuables.  Cela signifie que chaque fois que vous concat√©nez deux lignes, un nouveau tableau est cr√©√© et l'ancien se transforme en ordures.  Heureusement, StringBuilder peut √™tre utilis√© pour √©viter ou minimiser une telle cr√©ation de d√©chets. <br><br>  Voici un exemple de la fa√ßon dont vous pouvez am√©liorer la situation: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Start() { text = GetComponent&lt;Text&gt;(); } void Update() { text.text = "Player " + name + " has score " + score.toString(); } //Better code void Start() { text = GetComponent&lt;Text&gt;(); builder = new StringBuilder(50); } void Update() { //StringBuilder has overloaded Append method for all types builder.Length = 0; builder.Append("Player "); builder.Append(name); builder.Append(" has score "); builder.Append(score); text.text = builder.ToString(); }</span></span></code> </pre> <br>  Tout va bien avec l'exemple ci-dessus, mais il existe encore de nombreuses possibilit√©s pour am√©liorer le code.  Comme vous pouvez le voir, presque toute la cha√Æne peut √™tre consid√©r√©e comme statique.  Nous avons divis√© la cha√Æne en deux parties pour deux objets UI.Text.  Premi√®rement, l'un ne contient que le texte statique <strong>"Player" + nom + "a un score"</strong> , qui peut √™tre attribu√© dans la m√©thode Start, et le second contient la valeur du score, qui est mise √† jour dans chaque image.  <strong>Faites toujours des lignes statiques vraiment statiques et g√©n√©rez-les dans la m√©thode Start ou Awake</strong> .  Apr√®s cette am√©lioration, presque tout est en ordre, mais un peu de d√©chets sont toujours g√©n√©r√©s lors de l'appel de Int.ToString (), Float.ToString (), etc. <br><br>  Nous avons r√©solu ce probl√®me en g√©n√©rant et en pr√©-allouant de la m√©moire pour toutes les lignes possibles.  Cela peut sembler un stupide gaspillage de m√©moire, mais une telle solution est parfaitement adapt√©e √† nos besoins et r√©sout compl√®tement le probl√®me.  Donc, √† la fin, nous avons obtenu un tableau statique, dont l'acc√®s est directement accessible √† l'aide d'index pour prendre la cha√Æne souhait√©e indiquant un nombre: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] NUMBERS_THREE_DECIMAL = { <span class="hljs-string"><span class="hljs-string">"000"</span></span>, <span class="hljs-string"><span class="hljs-string">"001"</span></span>, <span class="hljs-string"><span class="hljs-string">"002"</span></span>, <span class="hljs-string"><span class="hljs-string">"003"</span></span>, <span class="hljs-string"><span class="hljs-string">"004"</span></span>, <span class="hljs-string"><span class="hljs-string">"005"</span></span>, <span class="hljs-string"><span class="hljs-string">"006"</span></span>,..........</code> </pre> <br><h2>  Quatri√®me r√®gle: valeurs de cache renvoy√©es par les m√©thodes d'acc√®s </h2><br>  Cela peut √™tre tr√®s difficile, car m√™me une simple m√©thode d'accesseur comme celle illustr√©e ci-dessous g√©n√®re des ordures: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void Update() { gameObject.tag; //or gameObject.name; }</span></span></code> </pre> <br>  Essayez d'√©viter d'utiliser des m√©thodes d'acc√®s dans la m√©thode Update.  Appelez la m√©thode d'acc√®s une seule fois dans la m√©thode Start et mettez en cache la valeur de retour. <br><br>  En g√©n√©ral, je recommande de <strong>NE PAS appeler de m√©thodes d'acc√®s aux cha√Ænes ou de m√©thodes d'acc√®s aux tableaux dans la m√©thode Update</strong> .  Dans la plupart des cas, il suffit <strong>d'obtenir le lien une fois dans la m√©thode Start</strong> . <br><br>  Voici deux exemples plus courants d'un autre code de m√©thode d'acc√®s non optimis√©: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void Update() { //Allocates new array containing all touches Input.touches[0]; } //Better Code void Update() { Input.GetTouch(0); } //Bad Code void Update() { //Returns new string(garbage) and compare the two strings gameObject.Tag == "MyTag"; } //Better Code void Update() { gameObject.CompareTag("MyTag"); }</span></span></code> </pre> <br><h2>  Cinqui√®me r√®gle: utiliser des fonctions qui n'allouent pas de m√©moire </h2><br>  Pour certaines fonctions Unity, des alternatives sans m√©moire peuvent √™tre trouv√©es.  Dans notre cas, toutes ces fonctions sont li√©es √† la physique.  Notre reconnaissance des collisions est bas√©e sur <br><br><pre> <code class="cs hljs">Physics2D. CircleCast();</code> </pre> <br>  Dans ce cas particulier, vous pouvez trouver une fonction non m√©moire appel√©e <br><br><pre> <code class="cs hljs">Physics2D. CircleCastNonAlloc();</code> </pre> <br>  De nombreuses autres fonctions ont √©galement des alternatives similaires, <strong>v√©rifiez</strong> donc <strong>toujours la documentation des fonctions NonAlloc</strong> . <br><br><h2>  Sixi√®me r√®gle: ne pas utiliser LINQ </h2><br>  Ne le fais pas.  Je veux dire, vous n'avez pas besoin de l'utiliser dans un code qui s'ex√©cute fr√©quemment.  Je sais que lors de l'utilisation de LINQ, le code est plus facile √† lire, mais dans de nombreux cas, les performances et l'allocation de m√©moire d'un tel code sont terribles.  Bien s√ªr, il peut parfois √™tre utilis√©, mais, pour √™tre honn√™te, dans notre jeu, nous n'utilisons pas du tout LINQ. <br><br><h2>  Septi√®me r√®gle: cr√©er une fois et r√©utiliser, partie 2 </h2><br>  Cette fois, nous parlons de regrouper des objets.  Je n'entrerai pas dans les d√©tails de la mutualisation, car cela a √©t√© dit plusieurs fois, par exemple, √©tudiez ce tutoriel: <a href="https://learn.unity.com/tutorial/object-pooling">https://learn.unity.com/tutorial/object- Covoiturage</a> <br><br>  Dans notre cas, le script de regroupement d'objets suivant est utilis√©.  Nous avons un niveau g√©n√©r√© rempli d'obstacles qui existent pendant une certaine p√©riode de temps jusqu'√† ce que le joueur passe cette partie du niveau.  Des instances de tels obstacles sont cr√©√©es √† partir de pr√©fabriqu√©s si certaines conditions sont remplies.  Le code est dans la m√©thode Update.  Ce code est compl√®tement inefficace en termes de m√©moire et d'ex√©cution.  Nous avons r√©solu le probl√®me en g√©n√©rant un pool de 40 obstacles: si n√©cessaire, nous r√©cup√©rons les obstacles du pool et renvoyons l'objet dans le pool lorsqu'il n'est plus n√©cessaire. <br><br><h2>  La huiti√®me r√®gle: plus attentivement avec le packaging-transformation (Boxe)! </h2><br>  La boxe g√©n√®re des d√©chets!  Mais qu'est-ce que la boxe?  Le plus souvent, la boxe se produit lorsque vous transmettez un type de valeur (int, float, bool, etc.) √† une fonction qui attend un objet de type Object. <br><br>  Voici un exemple de boxe que nous devons corriger dans notre projet: <br><br>  Nous avons impl√©ment√© notre propre syst√®me de messagerie dans le projet.  Chaque message peut contenir une quantit√© illimit√©e de donn√©es.  Les donn√©es sont stock√©es dans un dictionnaire d√©fini comme suit: <br><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; data;</code> </pre> <br>  Nous avons √©galement un setter qui d√©finit les valeurs dans ce dictionnaire: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Action </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attribute, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { data[attribute] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; }</code> </pre> <br>  La boxe ici est assez √©vidente.  Vous pouvez appeler la fonction comme suit: <br><br><pre> <code class="cs hljs">SetAttribute(<span class="hljs-string"><span class="hljs-string">"my_int_value"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>);</code> </pre> <br>  Ensuite, la valeur ¬´12¬ª est soumise √† la boxe et cela g√©n√®re des ordures. <br><br>  Nous avons r√©solu le probl√®me en cr√©ant des conteneurs de donn√©es distincts pour chaque type primitif, et le conteneur d'objets pr√©c√©dent est utilis√© uniquement pour les types de r√©f√©rence. <br><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; data; Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; dataBool; Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; dataInt; .......</code> </pre> <br>  Nous avons √©galement des setters s√©par√©s pour chaque type de donn√©es: <br><br><pre> <code class="cs hljs">SetBoolAttribute(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) SetIntAttribute(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)</code> </pre> <br>  Et tous ces setters sont impl√©ment√©s de telle mani√®re qu'ils appellent la m√™me fonction g√©n√©ralis√©e: <br><br><pre> <code class="cs hljs">SetAttribute&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, T&gt; dict, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, T <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)</code> </pre> <br>  Le probl√®me de boxe a √©t√© r√©solu! <br><br>  En savoir plus √† ce sujet dans l'article <a href="https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxing">https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxing</a> . <br><br><h2>  La neuvi√®me r√®gle: les cycles sont toujours suspects </h2><br>  Cette r√®gle est tr√®s similaire √† la premi√®re et √† la seconde.  Essayez simplement de supprimer tout le code facultatif des boucles pour des raisons de performances et de m√©moire. <br><br>  Dans le cas g√©n√©ral, nous nous effor√ßons de nous d√©barrasser des boucles dans les m√©thodes de mise √† jour, mais si nous ne pouvons pas nous en passer, nous √©viterons au moins toute allocation de m√©moire dans ces boucles.  Suivez donc les <strong>r√®gles 1 √† 8 et appliquez-les aux boucles</strong> en g√©n√©ral, pas seulement aux m√©thodes de mise √† jour. <br><br><h2>  R√®gle 10: pas de d√©chets dans les biblioth√®ques externes </h2><br>  Dans le cas o√π il s'av√®re qu'une partie de la poubelle est g√©n√©r√©e par du code t√©l√©charg√© depuis le magasin de ressources, ce probl√®me a de nombreuses solutions.  Mais avant de faire de l'ing√©nierie inverse et du d√©bogage, revenez simplement au magasin de ressources et mettez √† jour la biblioth√®que.  Dans notre cas, tous les actifs utilis√©s √©taient toujours pris en charge par les auteurs qui ont continu√© √† publier des mises √† jour am√©liorant les performances, ce qui a r√©solu tous nos probl√®mes.  <strong>Les d√©pendances doivent √™tre pertinentes!</strong>  Je pr√©f√®re me d√©barrasser de la biblioth√®que plut√¥t que de rester sans support. <br><br><h1>  Partie 2: maximiser l'ex√©cution </h1><br>  Certaines des r√®gles ci-dessus font une diff√©rence subtile si le code est rarement appel√©.  Il y a une grande boucle dans notre code qui s'ex√©cute dans chaque image, donc m√™me ces petits changements ont eu un effet √©norme. <br><br>  Certains de ces changements, s'ils sont mal utilis√©s ou dans une mauvaise situation, peuvent entra√Æner une dur√©e d'ex√©cution encore pire.  <strong>V√©rifiez toujours le profileur apr√®s avoir entr√© chaque optimisation dans le code pour vous assurer que vous vous d√©placez dans la bonne direction</strong> . <br><br>  Honn√™tement, certaines de <strong>ces r√®gles entra√Ænent un code lisible bien pire</strong> , et parfois m√™me une <strong>violation des recommandations</strong> , par exemple, l'incorporation de code mentionn√©e dans l'une des r√®gles ci-dessous. <br><br>  Bon nombre de ces r√®gles chevauchent celles pr√©sent√©es dans la premi√®re partie de l'article.  En r√®gle g√©n√©rale, les performances du code g√©n√©rateur de d√©chets sont inf√©rieures par rapport au code sans g√©n√©rateur de d√©chets. <br><br><h2>  La premi√®re r√®gle: l'ordre d'ex√©cution correct </h2><br>  <strong>D√©placez le code des m√©thodes FixedUpdate, Update, LateUpdate vers les m√©thodes Start et Awake</strong> .  Je sais que cela semble fou, mais croyez-moi, si vous fouillez dans votre code, vous trouverez des centaines de lignes de code qui peuvent √™tre d√©plac√©es vers des m√©thodes qui ne sont ex√©cut√©es qu'une seule fois. <br><br>  Dans notre cas, ce code est g√©n√©ralement associ√© √† <br><br><ul><li>  Appels √† GetComponent &lt;&gt; </li><li>  Calculs qui retournent en fait le m√™me r√©sultat dans chaque image </li><li>  Plusieurs instances des m√™mes objets, g√©n√©ralement des listes </li><li>  Rechercher GameObjects </li><li>  Obtenir des liens vers Transform et utiliser d'autres m√©thodes d'acc√®s </li></ul><br>  Voici une liste d'exemples de code que nous avons d√©plac√©s des m√©thodes de mise √† jour vers les m√©thodes de d√©marrage: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//There must be a good reason to keep GetComponent in Update gameObject.GetComponent&lt;LineRenderer&gt;(); gameObject.GetComponent&lt;CircleCollider2D&gt;(); //Examples of calculations returning same result every frame Mathf.FloorToInt(Screen.width / 2); var width = 2f * mainCamera.orthographicSize * mainCamera.aspect; var castRadius = circleCollider.radius * transform.lossyScale.x; var halfSize = GetComponent&lt;SpriteRenderer&gt;().bounds.size.x / 2f; //Finding objects var levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); var levelCollectibles = FindGameObjectsWithTag("COLLECTIBLE"); //References objectTransform = gameObject.transform; mainCamera = Camera.main;</span></span></code> </pre> <br><h2>  Deuxi√®me r√®gle: ex√©cuter du code uniquement lorsque cela est n√©cessaire </h2><br>  Dans notre cas, cela concerne principalement les scripts de mise √† jour de l'interface utilisateur.  Voici un exemple de la fa√ßon dont nous avons modifi√© l'impl√©mentation du code qui affiche l'√©tat actuel des √©l√©ments collect√©s au niveau. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code Text text; GameState gameState; void Start() { gameState = StoreProvider.Get&lt;GameState&gt;(); text = GetComponent&lt;Text&gt;(); } void Update() { text.text = gameState.CollectedCollectibles.ToString(); }</span></span></code> </pre> <br>  √âtant donn√© qu'√† chaque niveau il n'y a que quelques √©l√©ments √† collecter, cela n'a aucun sens de changer le texte de l'interface utilisateur dans chaque cadre.  Par cons√©quent, nous modifions le texte uniquement lorsque le nombre change. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Better code Text text; GameState gameState; int collectiblesCount; void Start() { gameState = StoreProvider.Get&lt;GameState&gt;(); text = GetComponent&lt;Text&gt;(); collectiblesCount = gameState.CollectedCollectibles; } void Update() { if(collectiblesCount != gameState.CollectedCollectibles) { //This code is ran only about 5 times each level collectiblesCount = gameState.CollectedCollectibles; text.text = collectiblesCount.ToString(); } }</span></span></code> </pre> <br>  Ce code est bien meilleur, surtout si les actions sont beaucoup plus compliqu√©es que de simplement changer l'interface utilisateur. <br><br>  Si vous recherchez une solution plus compl√®te, je vous recommande d'impl√©menter <a href="https://en.wikipedia.org/wiki/Observer_pattern">le mod√®le Observer √† l'</a> aide d'√©v√©nements C # ( <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/</a> ). <br><br>  Quoi qu'il en soit, cela ne nous suffisait pas encore, et nous voulions impl√©menter une solution compl√®tement g√©n√©ralis√©e, nous avons donc cr√©√© une biblioth√®que qui impl√©mente <a href="https://facebook.github.io/flux/">Flux</a> in Unity.  Cela a conduit √† une solution tr√®s simple, dans laquelle tout l'√©tat du jeu est stock√© dans l'objet ¬´Store¬ª, et tous les √©l√©ments d'interface utilisateur et autres composants sont notifi√©s lorsque l'√©tat change et r√©agissent √† ce changement sans code dans la m√©thode Update. <br><br><h2>  Troisi√®me r√®gle: les cycles sont toujours suspects </h2><br>  C'est exactement la m√™me r√®gle que j'ai mentionn√©e dans la premi√®re partie de l'article.  S'il y a une boucle dans le code qui contourne de mani√®re it√©rative un grand nombre d'√©l√©ments, pour am√©liorer les performances de la boucle, utilisez les deux r√®gles des deux parties de l'article. <br><br><h2>  Quatri√®me r√®gle: pour mieux que Foreach </h2><br>  La boucle Foreach est tr√®s facile √† √©crire, mais "tr√®s difficile" √† ex√©cuter.  √Ä l'int√©rieur de la boucle Foreach, Enumerator est utilis√© pour traiter de mani√®re it√©rative l'ensemble de donn√©es et renvoyer la valeur.  C'est plus compliqu√© que d'it√©rer sur des indices dans une simple boucle For. <br><br>  Par cons√©quent, dans notre projet, nous avons chaque fois que possible remplac√© les boucles Foreach par For: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code foreach (GameObject obstacle in obstacles) //Better code var count = obstacles.Count; for (int i = 0; i &lt; count; i++) { obstacles[i]; }</span></span></code> </pre> <br>  Dans notre cas avec une grande boucle for, ce changement est tr√®s important.  <strong>Une simple boucle for acc√©l√®re deux fois le code</strong> . <br><br><h2>  Cinqui√®me r√®gle: les tableaux sont meilleurs que les listes </h2><br>  Dans notre code, nous avons d√©couvert que la plupart des listes sont de longueur constante, ou nous pouvons calculer le nombre maximal d'√©l√©ments.  Par cons√©quent, nous les avons r√©impl√©ment√©es sur la base de tableaux, et dans certains cas, cela a conduit √† une double acc√©l√©ration des it√©rations sur les donn√©es. <br><br>  Dans certains cas, les listes ou autres structures de donn√©es complexes ne peuvent pas √™tre √©vit√©es.  Il arrive que vous deviez souvent ajouter ou supprimer des √©l√©ments, et dans ce cas, il est pr√©f√©rable d'utiliser des listes.  Mais en g√©n√©ral, les <strong>tableaux doivent toujours √™tre utilis√©s pour les listes de longueur fixe</strong> . <br><br><h2>  Sixi√®me r√®gle: les op√©rations flottantes sont meilleures que les op√©rations vectorielles </h2><br>  Cette diff√©rence est √† peine perceptible si vous n'effectuez pas des milliers de telles op√©rations, comme c'√©tait le cas dans notre cas, donc pour nous l'augmentation de la productivit√© a √©t√© significative. <br><br>  Nous avons apport√© des modifications similaires: <br><br><pre> <code class="cs hljs">Vector3 pos1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); Vector3 pos2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-comment"><span class="hljs-comment">//Bad code var pos3 = pos1 + pos2; //Better code var pos3 = new Vector3(pos1.x + pos2.x, pos1.y + pos2.y, ......); Vector3 pos1 = new Vector3(1,2,3); //Bad code var pos2 = pos1 * 2f; //Better code var pos2 = new Vector3(pos1.x * 2f, pos1.y * 2f, ......);</span></span></code> </pre> <br><h2>  Septi√®me r√®gle: rechercher correctement les objets </h2><br>  Pensez toujours √† savoir si vous devez vraiment utiliser la m√©thode GameObject.Find ().  Cette m√©thode est lourde et prend un temps fou.  Vous ne devez jamais utiliser cette m√©thode dans les m√©thodes de mise √† jour.  Nous avons constat√© que la plupart de nos appels Find peuvent √™tre <strong>remplac√©s par des liens directs dans l'√©diteur</strong> , ce qui, bien s√ªr, est bien meilleur. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code GameObject player; void Start() { player = GameObject.Find("PLAYER"); } //Better Code //Assign the reference to the player object in editor [SerializeField] GameObject player; void Start() { }</span></span></code> </pre> <br>  Si cela est impossible, <strong>envisagez</strong> au moins d' <strong>utiliser des balises (Tag) et de rechercher un objet par son √©tiquette √† l'aide de GameObject.FindWithTag</strong> . <br><br>  Donc, dans le cas g√©n√©ral: <strong>lien direct&gt; GameObject.FindWithTag ()&gt; GameObject.Find ()</strong> <br><br><h2>  Huiti√®me r√®gle: travailler uniquement avec des objets pertinents </h2><br>  Dans notre cas, cela √©tait important pour reconna√Ætre les collisions √† l'aide de RayCast-s (CircleCast, etc.).  Au lieu de reconna√Ætre les collisions et de d√©cider lesquelles sont importantes dans le code, <strong>nous avons d√©plac√© les objets du jeu vers les couches appropri√©es</strong> afin de pouvoir calculer les collisions uniquement pour les objets n√©cessaires. <br><br>  Voici un exemple <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void DetectCollision() { var count = Physics2D.CircleCastNonAlloc( position, radius, direction, results, distance); for (int i = 0; i &lt; count; i++) { var obj = results[i].collider.transform.gameObject; if(obj.CompareTag("FOO")) { ProcessCollision(results[i]); } } } //Better Code //We added all objects with tag FOO into the same layer void DetectCollision() { //8 is number of the desired layer var mask = 1 &lt;&lt; 8; var count = Physics2D.CircleCastNonAlloc( position, radius, direction, results, distance, mask); for (int i = 0; i &lt; count; i++) { ProcessCollision(results[i]); } }</span></span></code> </pre> <br><h2>  La neuvi√®me r√®gle: utiliser correctement les √©tiquettes </h2><br>  Il ne fait aucun doute que les √©tiquettes sont tr√®s utiles et peuvent am√©liorer les performances du code, mais n'oubliez pas qu'il <strong>n'y a qu'une seule fa√ßon correcte de comparer les √©tiquettes d'objets</strong> ! <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code gameObject.Tag == "MyTag"; //Better Code gameObject.CompareTag("MyTag");</span></span></code> </pre> <br><h2>  La dixi√®me r√®gle: m√©fiez-vous des astuces avec l'appareil photo! </h2><br>  Il est si facile d'utiliser <strong>Camera.main</strong> , mais les performances de cette action sont tr√®s m√©diocres.  La raison en est que dans les coulisses de chaque appel √† Camera.main, le moteur Unity ex√©cute en fait le r√©sultat FindGameObjectsWithTag (), donc nous comprenons d√©j√† que vous n'avez pas besoin de l'appeler souvent, et il est pr√©f√©rable de r√©soudre ce probl√®me en <strong>mettant</strong> en <strong>cache le lien dans la m√©thode Start</strong> ou √©veill√©. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Update() { Camera.main.orthographicSize //Some operation with camera } //Better Code private Camera cam; void Start() { cam = Camera.main; } void Update() { cam.orthographicSize //Some operation with camera }</span></span></code> </pre> <br><h2>  Onzi√®me r√®gle: LocalPosition vaut mieux que Position </h2><br>  <strong>Dans la mesure du possible, utilisez Transform.LocalPosition pour les getters et les setters au lieu de Transform.Position</strong> .  Dans chaque appel Transform.Position, beaucoup plus d'op√©rations sont effectu√©es, par exemple, le calcul de la position globale dans le cas d'un appel getter ou le calcul de la position locale √† partir du global dans le cas d'un appel setter.  Dans notre projet, il s'est av√©r√© que vous pouvez utiliser LocalPositions dans 99% des cas en utilisant Transform.Position, et vous n'avez pas besoin d'apporter d'autres modifications dans le code. <br><br><h2>  Douzi√®me r√®gle: n'utilisez pas LINQ </h2><br>  Cela a d√©j√† √©t√© discut√© dans la premi√®re partie.  Ne l'utilisez pas, c'est tout. <br><br><h2>  Treizi√®me r√®gle: n'ayez pas peur (parfois) d'enfreindre les r√®gles </h2><br>  Parfois, m√™me appeler une fonction simple peut √™tre trop co√ªteux.  Dans ce cas, vous devez toujours envisager d'incorporer du code (Code Inlining).  Qu'est-ce que cela signifie?  En fait, nous prenons simplement le code de la fonction et le copions directement √† l'endroit o√π nous voulons utiliser la fonction pour √©viter d'appeler des m√©thodes suppl√©mentaires. <br><br>  Dans la plupart des cas, cela n'aura aucun effet, car l'incorporation du code est effectu√©e automatiquement au stade de la compilation, mais il existe certaines r√®gles selon lesquelles le compilateur d√©cide d'incorporer le code (par exemple, les m√©thodes virtuelles ne sont jamais int√©gr√©es; pour plus de d√©tails, voir <a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html">https: //docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html</a> ).  Il suffit donc d'ouvrir le profileur, de lancer le jeu sur l'appareil cible et de voir si quelque chose peut √™tre am√©lior√©. <br><br>  Dans notre cas, il y avait plusieurs fonctions que nous avons d√©cid√© d'int√©grer pour am√©liorer les performances, en particulier dans la grande boucle for. <br><br><h1>  Conclusion </h1><br>  En appliquant les r√®gles √©num√©r√©es dans l'article, nous avons facilement atteint 60 fps stables dans le jeu pour iOS, m√™me sur l'iPhone 5S.  Peut-√™tre que certaines des r√®gles peuvent √™tre sp√©cifiques √† notre projet, mais je pense que la plupart d'entre elles doivent √™tre m√©moris√©es lors de l'√©criture du code ou de sa v√©rification afin d'√©viter des probl√®mes √† l'avenir.  Il est toujours pr√©f√©rable d'√©crire constamment du code en fonction des performances que plus tard pour refactoriser de gros morceaux de code. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481980/">https://habr.com/ru/post/fr481980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481960/index.html">2. Pile √©lastique: analyse des journaux de s√©curit√©. Logstash</a></li>
<li><a href="../fr481964/index.html">Comment organiser une sortie</a></li>
<li><a href="../fr481970/index.html">¬´Formats et supports audio oubli√©s¬ª: le d√©but de l'√®re de l'audio compact ou ¬´premier changement¬ª pour les bobines</a></li>
<li><a href="../fr481974/index.html">Test du melon d'eau √† l'aide de r√©seaux de neurones: Full Dev. Passez du prototypage √† l'application. sur google play</a></li>
<li><a href="../fr481978/index.html">Comment organiser le travail efficace d'une √©quipe de mise en page distribu√©e</a></li>
<li><a href="../fr481988/index.html">Pourquoi Koji est la ressource parfaite pour les cr√©ateurs d'applications KaiOS novices</a></li>
<li><a href="../fr481990/index.html">Dix ans de malware: les plus gros botnets de 2010</a></li>
<li><a href="../fr481992/index.html">Tekton Pipeline - Pipelines natifs de Kubernetes</a></li>
<li><a href="../fr481998/index.html">Machine de Turing, comme mod√®le de programmes d'automates</a></li>
<li><a href="../fr482000/index.html">Aimez-vous votre entreprise?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>