<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐 👑 🤹🏻 Buku "Tugas Ilmu Komputer Klasik dengan Python" 🐎 🛁 📣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak tugas di bidang Ilmu Komputer, yang sekilas tampak baru atau unik, sebenarnya berakar pada algoritma klasik, metode pengkodean, dan prinsip pen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku "Tugas Ilmu Komputer Klasik dengan Python"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/471520/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/op/8x/zc/op8xzcjsvwkjzgse183iwfc_sdw.jpeg" align="left" alt="gambar"></a>  Banyak tugas di bidang Ilmu Komputer, yang sekilas tampak baru atau unik, sebenarnya berakar pada algoritma klasik, metode pengkodean, dan prinsip pengembangan.  Dan teknik yang sudah ada masih merupakan cara terbaik untuk menyelesaikan masalah seperti itu! <br><br>  Buku ini akan memberi Anda kesempatan untuk mempelajari bahasa Python lebih dalam, menguji diri sendiri pada tugas, latihan, dan algoritme yang telah teruji waktu.  Anda harus menyelesaikan banyak tugas pemrograman: dari yang paling sederhana (misalnya, menemukan item daftar menggunakan penyortiran biner) ke yang kompleks (mengelompokkan data menggunakan metode k-means).  Bekerja melalui contoh-contoh yang ditujukan untuk pencarian, pengelompokan, grafik, dll., Anda akan ingat apa yang telah Anda lupakan dan kuasai teknik klasik untuk memecahkan masalah sehari-hari. <br><a name="habracut"></a><br><h3>  Untuk siapa buku ini? </h3><br>  Buku ini ditujukan untuk programmer tingkat menengah dan tinggi.  Para profesional berpengalaman yang ingin memperdalam pengetahuan mereka tentang Python akan menemukan tugas-tugas di sini yang sudah biasa sejak mereka mengajar ilmu komputer atau pemrograman.  Pemrogram tingkat menengah akan terbiasa dengan tugas-tugas klasik ini dalam bahasa pilihan mereka - Python.  Bagi pengembang yang sedang mempersiapkan wawancara pemrograman, publikasi ini kemungkinan akan menjadi bahan persiapan yang berharga. <br><br>  Selain programmer profesional, buku ini dapat dianggap berguna oleh siswa yang belajar untuk program sarjana dalam ilmu komputer dan tertarik pada Python.  Itu tidak mengklaim sebagai pengantar yang ketat untuk struktur data dan algoritma.  Ini bukan tutorial tentang struktur data dan algoritma.  Anda tidak akan menemukan bukti teorema atau penggunaan banyak notasi besar di halamannya.  Sebaliknya, buku ini diposisikan sebagai panduan praktis yang dapat diakses untuk metode untuk memecahkan masalah yang seharusnya menjadi produk akhir dari mempelajari struktur data, algoritma dan kelas kecerdasan buatan. <br><br>  Saya tekankan lagi: diasumsikan bahwa pembaca sudah familiar dengan sintaksis dan semantik Python.  Pembaca dengan pengalaman nol pemrograman kemungkinan tidak akan mendapat manfaat dari buku ini, dan seorang programmer dengan nol pengalaman dalam Python mungkin akan sulit.  Dengan kata lain, "Tugas Ilmu Komputer Klasik dengan Python" adalah buku untuk programmer Python dan mahasiswa ilmu komputer. <br><br><h3>  Kutipan.  1.5.  Menara Hanoi </h3><br>  Ada tiga kolom vertikal yang tinggi (selanjutnya - menara).  Kami akan menunjuk mereka A, B dan C. Disk dengan lubang di tengah digantung di menara A. Disk terluas - kami akan menyebutnya disk 1 - terletak di bawah.  Disk yang tersisa yang terletak di atasnya ditandai dengan peningkatan jumlah dan secara bertahap meruncing.  Misalnya, jika kami memiliki tiga disk, yang terluas di antaranya, yang di bawah, akan memiliki nomor 1. Disk terluas berikutnya, di nomor 2, akan berada di atas disk 1. Akhirnya, disk yang paling sempit, di nomor 3 akan berbaring di disk 2. <br><br>  Tujuan kami adalah memindahkan semua drive dari menara A ke menara C, dengan mempertimbangkan batasan berikut. <br><br><ul><li>  Disk hanya dapat dipindahkan satu per satu. </li><li>  Satu-satunya drive yang tersedia untuk bergerak adalah yang terletak di bagian atas menara apa pun. </li><li>  Drive yang lebih luas tidak pernah dapat ditempatkan di atas yang lebih sempit. <br>  Secara skematis, tugas ditunjukkan pada Gambar.  1.7. </li></ul><br><h3>  1.5.1.  Tower Modeling </h3><br>  Tumpukan adalah struktur data yang dimodelkan pada prinsip last-in-first-out (LIFO).  Hal terakhir yang ada di stack menjadi yang pertama diambil dari sana.  Dua operasi utama stack adalah push (put) dan pop (extract).  Operasi dorong mendorong item baru ke tumpukan, dan pop menghapusnya dari tumpukan dan mengembalikan item terakhir yang dimasukkan.  Anda dapat dengan mudah memodelkan tumpukan dengan Python menggunakan daftar sebagai penyimpanan cadangan (Listing 1.20). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pz/a2/gs/pza2gsaqiqas4khvhhwc6hdnfwi.png" alt="gambar"></div><br>  Listing 1.20.  hanoi.py <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TypeVar, Generic, List T = TypeVar(<span class="hljs-string"><span class="hljs-string">'T'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Generic[T])</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container: List[T] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, item: T)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container.append(item) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; T:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._container.pop() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; str:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repr(self._container)</code> </pre> <br><blockquote>  Kelas Stack yang disajikan mengimplementasikan metode __repr __ (), yang membuatnya mudah untuk memeriksa isi menara.  __repr __ () adalah apa yang akan dihasilkan ketika fungsi print () diterapkan pada stack. </blockquote><br><blockquote>  Seperti yang dinyatakan dalam pengantar, jenis anotasi digunakan dalam buku.  Mengimpor Generik dari modul input memungkinkan Stack menjadi kelas parametrik untuk jenis tertentu dalam anotasi jenis.  Tipe T yang berubah-ubah didefinisikan dalam T = TypeVar ('T').  T bisa jenis apa saja.  Ketika anotasi tipe selanjutnya digunakan untuk Stack dalam menyelesaikan masalah menara Hanoi, prompt akan menjadi Stack [int], yaitu, tipe int akan digunakan sebagai ganti T.  Dengan kata lain, di sini tumpukan adalah tumpukan bilangan bulat.  Jika Anda kesulitan mengetik anotasi, lihat Lampiran B. </blockquote><br>  Tumpukan sempurna untuk tantangan menara Hanoi.  Untuk memindahkan disk ke menara, kita bisa menggunakan operasi push.  Untuk memindahkan disk dari satu menara ke menara lainnya, kita dapat mendorongnya dari yang pertama (pop) dan meletakkannya di yang kedua (mendorong). <br><br>  Tentukan menara sebagai objek Stack dan isi yang pertama dengan disk (Listing 1.21). <br><br>  Listing 1.21.  hanoi.py (lanjutan) <br><br><pre> <code class="python hljs">num_discs: int = <span class="hljs-number"><span class="hljs-number">3</span></span> tower_a: Stack[int] = Stack() tower_b: Stack[int] = Stack() tower_c: Stack[int] = Stack() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, num_discs + <span class="hljs-number"><span class="hljs-number">1</span></span>): tower_a.push(i)</code> </pre> <br><h3>  1.5.2.  Memecahkan Masalah Menara Hanoi </h3><br>  Bagaimana saya bisa menyelesaikan masalah menara Hanoi?  Misalkan kita mencoba memindahkan hanya satu drive.  Maka kita akan tahu bagaimana melakukan ini, bukan?  Bahkan, memindahkan satu disk adalah kasus dasar untuk solusi rekursif untuk masalah ini.  Memindahkan banyak drive adalah kasus rekursif.  Poin kuncinya adalah bahwa kita, pada kenyataannya, memiliki dua skenario yang perlu dikodekan: memindahkan satu disk (base case) dan memindahkan beberapa disk (recursive case). <br><br>  Untuk memahami kasus rekursif, pertimbangkan contoh khusus.  Misalkan kita memiliki tiga disk - atas, tengah dan bawah, terletak di menara A, dan kami ingin memindahkannya ke menara C. (Selanjutnya, ini akan membantu untuk secara skematis menggambarkan masalahnya.) Pertama kita bisa memindahkan disk atas ke menara C. Lalu - pindahkan cakram tengah ke menara B, dan kemudian cakram atas dari menara C ke menara B. Sekarang kita memiliki cakram bawah yang masih terletak di menara A dan dua cakram atas di menara B. Pada dasarnya, kita sudah berhasil memindahkan dua berkendara dari satu menara (A) ke yang lain (B).  Memindahkan disk yang lebih rendah dari A ke C adalah kasus dasar (memindahkan satu disk).  Sekarang kita dapat memindahkan dua disk bagian atas dari B ke C menggunakan prosedur yang sama seperti dari A ke B. Kita memindahkan disk bagian atas ke A, disk tengah ke C, dan akhirnya disk bagian atas dari A ke C. <br><br><blockquote>  Di kelas ilmu komputer, model kecil menara ini sering ditemukan, dibuat dari pin dan disk plastik.  Anda dapat membuat model sendiri dengan tiga pensil dan tiga lembar kertas.  Mungkin ini akan membantu Anda memvisualisasikan solusinya. </blockquote><br>  Dalam contoh dengan tiga disk, ada kasus dasar sederhana memindahkan satu disk dan kasus rekursif memindahkan disk yang tersisa (dalam hal ini dua) menggunakan menara ketiga sementara.  Kami dapat memecahkan kasus rekursif ke dalam langkah-langkah berikut. <br><br><ol><li>  Pindahkan drive n - 1 teratas dari menara A ke menara B (sementara), menggunakan C sebagai menara perantara. </li><li>  Pindahkan drive yang lebih rendah dari A ke C. </li><li>  Pindahkan disk n-1 dari menara B ke menara C, menara A adalah perantara. </li></ol><br>  Anehnya, algoritma rekursif ini bekerja tidak hanya untuk tiga, tetapi untuk sejumlah disk.  Encode sebagai fungsi hanoi (), yang bertanggung jawab untuk memindahkan disk dari satu menara ke menara lainnya menggunakan menara sementara ketiga (Listing 1.22). <br><br>  Daftar 1.22.  hanoi.py (lanjutan) <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hanoi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(begin: Stack[int], end: Stack[int], temp: Stack[int], n: int)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">1</span></span>: end.push(begin.pop()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: hanoi(begin, temp, end, n — <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(begin, end, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(temp, end, begin, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Setelah memanggil hanoi (), Anda perlu memeriksa menara A, B, dan C untuk memastikan bahwa disk telah berhasil dipindahkan (Listing 1.23). <br><br>  Listing 1.23.  hanoi.py (lanjutan) <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: hanoi(tower_a, tower_c, tower_b, num_discs) print(tower_a) print(tower_b) print(tower_c)</code> </pre> <br>  Anda akan menemukan bahwa drive memang telah dipindahkan.  Ketika mengkode solusi untuk masalah menara Hanoi, tidak perlu memahami setiap langkah yang diperlukan untuk memindahkan beberapa disk dari menara A ke menara C. Kami memahami algoritma rekursif umum untuk memindahkan sejumlah disk dan mensistematisasinya, memungkinkan komputer melakukan sisanya.  Ini adalah kekuatan dari merumuskan solusi rekursif untuk masalah: kita sering dapat membayangkan solusi secara abstrak, tanpa membuang energi pada representasi mental dari setiap tindakan individu. <br><br>  By the way, fungsi hanoi () akan dieksekusi secara eksponensial tergantung pada jumlah disk, yang membuat solusi untuk masalah bahkan untuk 64 disk tidak cocok.  Anda dapat mencoba menjalankannya dengan jumlah disk yang berbeda dengan mengubah variabel num_discs.  Ketika jumlah disk meningkat, jumlah langkah untuk menyelesaikan tugas menara Hanoi tumbuh secara eksponensial, lebih banyak detail dapat ditemukan di banyak sumber.  Jika Anda tertarik untuk mempelajari lebih lanjut tentang matematika di balik solusi rekursif dari masalah ini, lihat penjelasan Karl Birch dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Di Menara Hanoi"</a> . <br><br><h3>  1.6.  Aplikasi nyata </h3><br>  Berbagai metode yang disajikan dalam bab ini (rekursi, memoisasi, kompresi, dan manipulasi pada level bit) begitu luas dalam pengembangan perangkat lunak modern sehingga tanpa mereka tidak mungkin membayangkan dunia komputasi.  Terlepas dari kenyataan bahwa tugas dapat diselesaikan tanpa mereka, seringkali lebih logis atau lebih bijaksana untuk menyelesaikannya dengan menggunakan metode ini. <br><br>  Secara khusus, rekursi tidak hanya mendasari banyak algoritma, tetapi bahkan seluruh bahasa pemrograman.  Dalam beberapa bahasa pemrograman fungsional, seperti Skema dan Haskell, rekursi menggantikan loop yang digunakan dalam bahasa imperatif.  Namun, harus diingat bahwa segala sesuatu yang dapat dicapai dengan menggunakan metode rekursif juga dapat dilakukan secara iteratif. <br><br>  Memoisasi telah berhasil digunakan untuk mempercepat pekerjaan parser - program yang menafsirkan bahasa.  Ini berguna dalam semua tugas di mana hasil perhitungan terbaru kemungkinan akan diminta lagi.  Bidang tindakan lain untuk memoisasi adalah runtime bahasa pemrograman.  Beberapa runtime ini, misalnya, untuk versi Prolog, secara otomatis menyimpan hasil pemanggilan fungsi (auto-mash), sehingga fungsi tersebut tidak harus dieksekusi di waktu berikutnya dengan panggilan yang sama.  Ini mirip dengan dekorator @lru_cache () di fib6 (). <br><br>  Kompresi telah membuat dunia Internet, dengan bandwidth yang terbatas, lebih tertahankan.  Metode bit string yang dibahas dalam Bagian 1.2 berlaku untuk tipe data sederhana di dunia nyata yang memiliki jumlah nilai yang mungkin terbatas, yang bahkan 1 byte adalah redundan.  Namun, sebagian besar algoritma kompresi bekerja dengan mencari pola atau struktur dalam dataset yang menghilangkan informasi duplikat.  Mereka jauh lebih rumit daripada yang dijelaskan di bagian 1.2. <br><br>  Cipher sekali pakai tidak cocok untuk kasus enkripsi umum.  Mereka mengharuskan encoder dan decoder memiliki salah satu kunci (data dummy dalam contoh kami) untuk mengembalikan data asli, yang terlalu rumit dan dalam sebagian besar skema enkripsi tidak memungkinkan untuk mencapai tujuan menjaga kerahasiaan kunci.  Tetapi Anda mungkin tertarik untuk mengetahui bahwa nama "cipher sekali pakai" ditemukan oleh mata-mata yang selama Perang Dingin menggunakan notebook kertas nyata dengan data fiktif yang direkam di dalamnya untuk membuat pesan terenkripsi. <br><br>  Metode-metode ini adalah blok bangunan program, algoritma lain didasarkan pada mereka.  Dalam bab-bab berikut, Anda akan melihat seberapa luas penerapannya. <br><br><h3>  Tentang penulis </h3><br>  <b>David Kopec</b> adalah Dosen Senior Ilmu Komputer dan Inovasi di Champlain College di Burlington, Vermont.  Dia adalah pengembang perangkat lunak yang berpengalaman dan penulis Classic Computer Science Problems in Swift (Manning, 2018) dan Dart for Absolute Beginners (Apress, 2014).  David meraih gelar sarjana di bidang ekonomi dan gelar master di bidang ilmu komputer dari Dartmouth College.  Anda dapat menghubunginya di Twitter melalui @davekopec. <br><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Kupon diskon 25% untuk penjaja - <b>Python</b> <br><br>  Setelah pembayaran versi kertas buku, sebuah buku elektronik dikirim melalui email. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471520/">https://habr.com/ru/post/id471520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471508/index.html">Admin tanpa senjata = hyperconvergence?</a></li>
<li><a href="../id471512/index.html">28 Oktober, Yekaterinburg - Komunikasi Berkualitas</a></li>
<li><a href="../id471514/index.html">Judul "Baca artikel untuk Anda." Januari - Juni 2019</a></li>
<li><a href="../id471516/index.html">Intel 665p - SSD dengan QLC NAND 96-layer</a></li>
<li><a href="../id471518/index.html">Apple pada 2019 adalah Linux pada 2000</a></li>
<li><a href="../id471522/index.html">Askozia. Cara Kerja Plug & Play Autoprovisioning</a></li>
<li><a href="../id471524/index.html">Terjemahan lengkap instruksi untuk penilai Google</a></li>
<li><a href="../id471528/index.html">Menyebarkan aplikasi menggunakan gerombolan buruh pelabuhan</a></li>
<li><a href="../id471530/index.html">GitLab berjalan di jalur yang tidak biasa ke CI / CD dan Kubernetes</a></li>
<li><a href="../id471532/index.html">Selamat tinggal PCB; halo silikon interkoneksi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>