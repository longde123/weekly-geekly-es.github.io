<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☢️ 👨🏿‍🔧 👏🏾 Sur les doigts: les types associés dans Rust et quelle est leur différence avec les arguments de type 🚻 🕵🏿 🥀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pourquoi Rust a-t-il des types associés, et quelle est la différence entre eux et les arguments de type aka génériques, car ils sont si similaires? Ne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sur les doigts: les types associés dans Rust et quelle est leur différence avec les arguments de type</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441444/"><p> Pourquoi Rust a-t-il des types associés, et quelle est la différence entre eux et les arguments de type aka génériques, car ils sont si similaires?  Ne suffit-il pas seulement de ce dernier, comme dans toutes les langues normales?  Pour ceux qui commencent tout juste à apprendre la rouille, et surtout pour ceux qui viennent d'autres langues ("C'est générique!" - dira le javiste, sage depuis des années), une telle question se pose régulièrement.  Faisons les choses correctement. </p><br><p>  TL; DR Le premier contrôle le code appelé, le second l'appelant. </p><a name="habracut"></a><br><h3 id="dzheneriki-vs-associirovannye-tipy">  Génériques vs types associés </h3><br><p>  Donc, nous avons déjà des arguments de type, ou les génériques préférés de tout le monde.  Cela ressemble à ceci: </p><br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, x: T); }</code> </pre> <br><p>  Ici, <code>T</code> est précisément l'argument type.  Il semble que cela devrait être suffisant pour tout le monde (comme 640 kilo-octets de mémoire).  Mais dans Rust, il existe également des types associés, quelque chose comme ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    fn bar(self, x: Self::Bar); }</span></span></code> </pre> <br><p>  À première vue, les mêmes œufs, mais sous un angle différent.  Pourquoi avez-vous dû introduire une autre entité dans la langue?  (Ce qui, soit dit en passant, n'était pas dans les premières versions de la langue.) </p><br><p>  Les arguments de type sont exactement des <strong><em>arguments</em></strong> , cela signifie qu'ils sont passés au trait à l'endroit de l'appel, et le contrôle sur le type qui sera utilisé au lieu de <code>T</code> appartient à l'appelant.  Même si nous ne spécifions pas explicitement <code>T</code> à l'emplacement de l'appel, le compilateur le fera pour nous en utilisant l'inférence de type.  Autrement dit, de toute façon, ce type sera déduit de l'appelant et passé en argument.  (Bien sûr, tout cela se produit pendant la compilation, pas pendant l'exécution.) </p><br><p>  Prenons un exemple.  La bibliothèque standard a un <code>AsRef</code> AsRef, qui permet à un type de faire semblant d'être un autre type pendant un certain temps, convertissant un lien vers lui-même en un lien vers autre chose.  Simplifié, ce trait ressemble à ceci (en réalité, c'est un peu plus compliqué, j'ai volontairement supprimé tout ce qui n'était pas nécessaire, ne laissant que le minimum nécessaire à la compréhension): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsRef</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_ref</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;T; }</code> </pre> <br><p>  Ici, le type <code>T</code> passé par l'appelant comme argument, même s'il se produit implicitement (si le compilateur déduit ce type pour vous).  En d'autres termes, c'est l'appelant qui décide quel nouveau type <code>T</code> prétendra être notre type qui implémente ce trait: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo = Foo::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bar: &amp;Bar = foo.as_ref();</code> </pre> <br><p>  Ici, le compilateur, en utilisant la connaissance de <code>bar: &amp;Bar</code> , utilisera l' <code>AsRef&lt;Bar&gt;</code> pour appeler la méthode <code>as_ref()</code> , car c'est le type de <code>Bar</code> requis par l'appelant.  Il va sans dire que le type <code>Foo</code> doit implémenter le trait AsRef <code>AsRef&lt;Bar&gt;</code> , et en plus de cela, il peut implémenter autant d'autres <code>AsRef&lt;T&gt;</code> , parmi lesquelles l'appelant sélectionne celle désirée. </p><br><p>  Dans le cas du type associé, tout est exactement le contraire.  Le type associé est entièrement contrôlé par ceux qui mettent en œuvre cette caractéristique, et non par l'appelant. </p><br><p>  Un exemple courant est un itérateur.  Supposons que nous ayons une collection et que nous voulons en obtenir un itérateur.  Quel type de valeurs l'itérateur doit-il renvoyer?  Exactement celle contenue dans cette collection!  Il n'appartient pas à l'appelant de décider ce que l'itérateur retournera, et l'itérateur lui-même sait mieux <em>ce</em> qu'il sait <em>exactement</em> comment retourner.  Voici le code abrégé de la bibliothèque standard: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt;; }</code> </pre> <br><p>  Notez que l'itérateur n'a pas de paramètre de type qui permet à l'appelant de choisir ce que l'itérateur doit retourner.  Au lieu de cela, le type de la valeur renvoyée par la méthode <code>next()</code> est déterminé par l'itérateur lui-même en utilisant le type associé, mais il n'est pas coincé avec des clous, c'est-à-dire  chaque implémentation d'itérateur peut choisir son type. </p><br><p>  Arrêter  Et alors?  Néanmoins, il n'est pas clair pourquoi c'est mieux qu'un générique.  Imaginez un instant que nous utilisons le générique habituel au lieu du type associé.  Le trait de l'itérateur ressemblera alors à ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericIterator</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt;; }</code> </pre> <br><p>  Mais maintenant, premièrement, le type <code>T</code> doit être indiqué encore et encore à chaque endroit où l'itérateur est mentionné, et deuxièmement, maintenant il est devenu possible d'implémenter ce trait plusieurs fois avec différents types, ce qui pour l'itérateur semble quelque peu étrange.  Voici un exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIterator</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GenericIterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIterator { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GenericIterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIterator { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter = MyIterator; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lolwhat: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;_&gt; = iter.next(); <span class="hljs-comment"><span class="hljs-comment">// Error! Which impl of GenericIterator to use? }</span></span></code> </pre> <br><p>  Vous voyez le hic?  Nous ne pouvons pas simplement prendre et appeler <code>iter.next()</code> sans squats - nous devons faire savoir au compilateur, explicitement ou implicitement, quel type sera retourné.  Et cela semble gênant: pourquoi devrions-nous, du côté de l'appel, connaître (et dire au compilateur!) Le type que l'itérateur retournera, alors que cet itérateur devrait mieux savoir quel type il retourne?!  Et tout cela parce que nous avons pu implémenter le <code>GenericIterator</code> GenericIterator deux fois avec un paramètre différent pour le même <code>MyIterator</code> , ce qui, du point de vue de la sémantique de l'itérateur, semble également ridicule: pourquoi le même itérateur peut-il renvoyer des valeurs de différents types? </p><br><p>  Si nous revenons à la variante avec le type associé, tous ces problèmes peuvent être évités: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIter</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIter { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter = MyIter; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = iter.next(); }</code> </pre> <br><p>  Ici, premièrement, le compilateur affichera correctement la <code>value: Option&lt;String&gt;</code> type sans mots inutiles, et deuxièmement, cela ne fonctionnera pas pour implémenter le <code>MyIter</code> <code>Iterator</code> pour <code>MyIter</code> deuxième fois avec un type de retour différent, et ainsi tout gâcher. </p><br><p>  Pour la fixation.  Une collection peut implémenter un tel trait afin de pouvoir se transformer en itérateur: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntoIterator</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntoIter</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item=Self::Item&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">into_iter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Self::IntoIter; }</code> </pre> <br><p>  Et encore une fois, c'est la collection qui décide de quel itérateur il s'agit, à savoir: un itérateur dont le type de retour correspond au type d'éléments de la collection elle-même, et aucun autre. </p><br><h3 id="eschyo-bolee-na-palcah">  Plus sur les doigts </h3><br><p>  Si les exemples ci-dessus sont encore incompréhensibles, alors voici une explication encore moins scientifique mais plus intelligible.  Les arguments de type peuvent être considérés comme des informations «d'entrée» que nous fournissons pour que le trait fonctionne.  Les types associés peuvent être considérés comme des informations de «sortie» que le trait nous fournit afin que nous puissions utiliser les résultats de son travail. </p><br><p>  La bibliothèque standard a la capacité de surcharger les opérateurs mathématiques pour ses types (addition, soustraction, multiplication, division, etc.).  Pour ce faire, vous devez implémenter l'un des traits correspondants de la bibliothèque standard.  Voici, par exemple, à quoi ressemble ce trait pour l'opération d'addition (encore une fois, simplifiée): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Add</span></span></span></span>&lt;RHS&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, rhs: RHS) -&gt; Self::Output; }</code> </pre> <br><p>  Ici, nous avons l'argument <code>RHS</code> «entrée» - c'est le type auquel nous appliquerons l'opération d'addition avec notre type.  Et il y a un argument "sortie" <code>Add::Output</code> - c'est le type qui résultera de l'addition.  Dans le cas général, cela peut différer du type de termes, qui, à leur tour, peuvent également être de types différents (ajoutez du goût au bleu et devenez doux - mais quoi, je le fais tout le temps).  Le premier est spécifié à l'aide de l'argument type, le second est spécifié à l'aide du type associé. </p><br><p>  Vous pouvez implémenter n'importe quel nombre d'additions avec différents types du deuxième argument, mais à chaque fois il n'y aura qu'un seul type de résultat, et il est déterminé par l'implémentation de cette addition. </p><br><p>  Essayons d'implémenter ce trait: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>); <span class="hljs-meta"><span class="hljs-meta">#[derive(PartialEq, Debug)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Foo { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Bar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, rhs: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; Bar { Bar(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, rhs) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = Foo(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = x + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      &lt;Foo as Add&gt;::add(42)  x assert_eq!(y, Bar("test", 42)); }</span></span></code> </pre> <br><p>  Dans cet exemple, le type de la variable <code>y</code> est déterminé par l'algorithme d'addition, pas le code appelant.  Il serait très étrange s'il était possible d'écrire quelque chose comme <code>let y: Baz = x + 42</code> , c'est-à-dire de forcer l'opération d'addition à renvoyer un résultat d'un type étranger.  C'est à partir de telles choses que le type associé <code>Add::Output</code> nous assure. </p><br><h3 id="itogo">  Total </h3><br><p>  Nous utilisons des génériques où cela ne nous dérange pas d'avoir plusieurs implémentations de traits pour le même type, et où il est acceptable de spécifier une implémentation spécifique du côté de l'appel.  Nous utilisons des types associés où nous voulons avoir une implémentation "canonique", qui contrôle elle-même les types.  Combinez et mélangez dans les bonnes proportions, comme dans le dernier exemple. </p><br><p>  La pièce a-t-elle échoué?  Tuez-moi avec des commentaires. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441444/">https://habr.com/ru/post/fr441444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441428/index.html">Principes de base de PowerShell: définition de la fin d'une ligne avec un caractère spécifique</a></li>
<li><a href="../fr441430/index.html">La première fois que nous essayons App Center et racontons notre expérience</a></li>
<li><a href="../fr441436/index.html">Les scientifiques ont développé des cellules souches universelles en utilisant l'ingénierie CRISPR</a></li>
<li><a href="../fr441438/index.html">Services unifiés goszakup.gov.kz - Version 2</a></li>
<li><a href="../fr441442/index.html">YouTube a désactivé les publicités anti-vaccin</a></li>
<li><a href="../fr441446/index.html">Apprendre à l'ordinateur: comment acquérir une nouvelle compétence</a></li>
<li><a href="../fr441448/index.html">Pan impossible et autres victoires de tuiles Penrose</a></li>
<li><a href="../fr441450/index.html">Pentesting Azure - Réflexions sur la sécurité dans le cloud computing</a></li>
<li><a href="../fr441452/index.html">Trois extensions réactives zen</a></li>
<li><a href="../fr441454/index.html">La NASA met en garde SpaceX et Boeing sur les défauts des vaisseaux spatiaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>