<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò¢Ô∏è üë®üèø‚Äçüîß üëèüèæ Sur les doigts: les types associ√©s dans Rust et quelle est leur diff√©rence avec les arguments de type üöª üïµüèø ü•Ä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pourquoi Rust a-t-il des types associ√©s, et quelle est la diff√©rence entre eux et les arguments de type aka g√©n√©riques, car ils sont si similaires? Ne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sur les doigts: les types associ√©s dans Rust et quelle est leur diff√©rence avec les arguments de type</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441444/"><p> Pourquoi Rust a-t-il des types associ√©s, et quelle est la diff√©rence entre eux et les arguments de type aka g√©n√©riques, car ils sont si similaires?  Ne suffit-il pas seulement de ce dernier, comme dans toutes les langues normales?  Pour ceux qui commencent tout juste √† apprendre la rouille, et surtout pour ceux qui viennent d'autres langues ("C'est g√©n√©rique!" - dira le javiste, sage depuis des ann√©es), une telle question se pose r√©guli√®rement.  Faisons les choses correctement. </p><br><p>  TL; DR Le premier contr√¥le le code appel√©, le second l'appelant. </p><a name="habracut"></a><br><h3 id="dzheneriki-vs-associirovannye-tipy">  G√©n√©riques vs types associ√©s </h3><br><p>  Donc, nous avons d√©j√† des arguments de type, ou les g√©n√©riques pr√©f√©r√©s de tout le monde.  Cela ressemble √† ceci: </p><br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, x: T); }</code> </pre> <br><p>  Ici, <code>T</code> est pr√©cis√©ment l'argument type.  Il semble que cela devrait √™tre suffisant pour tout le monde (comme 640 kilo-octets de m√©moire).  Mais dans Rust, il existe √©galement des types associ√©s, quelque chose comme ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    fn bar(self, x: Self::Bar); }</span></span></code> </pre> <br><p>  √Ä premi√®re vue, les m√™mes ≈ìufs, mais sous un angle diff√©rent.  Pourquoi avez-vous d√ª introduire une autre entit√© dans la langue?  (Ce qui, soit dit en passant, n'√©tait pas dans les premi√®res versions de la langue.) </p><br><p>  Les arguments de type sont exactement des <strong><em>arguments</em></strong> , cela signifie qu'ils sont pass√©s au trait √† l'endroit de l'appel, et le contr√¥le sur le type qui sera utilis√© au lieu de <code>T</code> appartient √† l'appelant.  M√™me si nous ne sp√©cifions pas explicitement <code>T</code> √† l'emplacement de l'appel, le compilateur le fera pour nous en utilisant l'inf√©rence de type.  Autrement dit, de toute fa√ßon, ce type sera d√©duit de l'appelant et pass√© en argument.  (Bien s√ªr, tout cela se produit pendant la compilation, pas pendant l'ex√©cution.) </p><br><p>  Prenons un exemple.  La biblioth√®que standard a un <code>AsRef</code> AsRef, qui permet √† un type de faire semblant d'√™tre un autre type pendant un certain temps, convertissant un lien vers lui-m√™me en un lien vers autre chose.  Simplifi√©, ce trait ressemble √† ceci (en r√©alit√©, c'est un peu plus compliqu√©, j'ai volontairement supprim√© tout ce qui n'√©tait pas n√©cessaire, ne laissant que le minimum n√©cessaire √† la compr√©hension): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsRef</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_ref</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;T; }</code> </pre> <br><p>  Ici, le type <code>T</code> pass√© par l'appelant comme argument, m√™me s'il se produit implicitement (si le compilateur d√©duit ce type pour vous).  En d'autres termes, c'est l'appelant qui d√©cide quel nouveau type <code>T</code> pr√©tendra √™tre notre type qui impl√©mente ce trait: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo = Foo::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bar: &amp;Bar = foo.as_ref();</code> </pre> <br><p>  Ici, le compilateur, en utilisant la connaissance de <code>bar: &amp;Bar</code> , utilisera l' <code>AsRef&lt;Bar&gt;</code> pour appeler la m√©thode <code>as_ref()</code> , car c'est le type de <code>Bar</code> requis par l'appelant.  Il va sans dire que le type <code>Foo</code> doit impl√©menter le trait AsRef <code>AsRef&lt;Bar&gt;</code> , et en plus de cela, il peut impl√©menter autant d'autres <code>AsRef&lt;T&gt;</code> , parmi lesquelles l'appelant s√©lectionne celle d√©sir√©e. </p><br><p>  Dans le cas du type associ√©, tout est exactement le contraire.  Le type associ√© est enti√®rement contr√¥l√© par ceux qui mettent en ≈ìuvre cette caract√©ristique, et non par l'appelant. </p><br><p>  Un exemple courant est un it√©rateur.  Supposons que nous ayons une collection et que nous voulons en obtenir un it√©rateur.  Quel type de valeurs l'it√©rateur doit-il renvoyer?  Exactement celle contenue dans cette collection!  Il n'appartient pas √† l'appelant de d√©cider ce que l'it√©rateur retournera, et l'it√©rateur lui-m√™me sait mieux <em>ce</em> qu'il sait <em>exactement</em> comment retourner.  Voici le code abr√©g√© de la biblioth√®que standard: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt;; }</code> </pre> <br><p>  Notez que l'it√©rateur n'a pas de param√®tre de type qui permet √† l'appelant de choisir ce que l'it√©rateur doit retourner.  Au lieu de cela, le type de la valeur renvoy√©e par la m√©thode <code>next()</code> est d√©termin√© par l'it√©rateur lui-m√™me en utilisant le type associ√©, mais il n'est pas coinc√© avec des clous, c'est-√†-dire  chaque impl√©mentation d'it√©rateur peut choisir son type. </p><br><p>  Arr√™ter  Et alors?  N√©anmoins, il n'est pas clair pourquoi c'est mieux qu'un g√©n√©rique.  Imaginez un instant que nous utilisons le g√©n√©rique habituel au lieu du type associ√©.  Le trait de l'it√©rateur ressemblera alors √† ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericIterator</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt;; }</code> </pre> <br><p>  Mais maintenant, premi√®rement, le type <code>T</code> doit √™tre indiqu√© encore et encore √† chaque endroit o√π l'it√©rateur est mentionn√©, et deuxi√®mement, maintenant il est devenu possible d'impl√©menter ce trait plusieurs fois avec diff√©rents types, ce qui pour l'it√©rateur semble quelque peu √©trange.  Voici un exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIterator</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GenericIterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIterator { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GenericIterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIterator { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter = MyIterator; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lolwhat: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;_&gt; = iter.next(); <span class="hljs-comment"><span class="hljs-comment">// Error! Which impl of GenericIterator to use? }</span></span></code> </pre> <br><p>  Vous voyez le hic?  Nous ne pouvons pas simplement prendre et appeler <code>iter.next()</code> sans squats - nous devons faire savoir au compilateur, explicitement ou implicitement, quel type sera retourn√©.  Et cela semble g√™nant: pourquoi devrions-nous, du c√¥t√© de l'appel, conna√Ætre (et dire au compilateur!) Le type que l'it√©rateur retournera, alors que cet it√©rateur devrait mieux savoir quel type il retourne?!  Et tout cela parce que nous avons pu impl√©menter le <code>GenericIterator</code> GenericIterator deux fois avec un param√®tre diff√©rent pour le m√™me <code>MyIterator</code> , ce qui, du point de vue de la s√©mantique de l'it√©rateur, semble √©galement ridicule: pourquoi le m√™me it√©rateur peut-il renvoyer des valeurs de diff√©rents types? </p><br><p>  Si nous revenons √† la variante avec le type associ√©, tous ces probl√®mes peuvent √™tre √©vit√©s: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIter</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIter { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter = MyIter; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = iter.next(); }</code> </pre> <br><p>  Ici, premi√®rement, le compilateur affichera correctement la <code>value: Option&lt;String&gt;</code> type sans mots inutiles, et deuxi√®mement, cela ne fonctionnera pas pour impl√©menter le <code>MyIter</code> <code>Iterator</code> pour <code>MyIter</code> deuxi√®me fois avec un type de retour diff√©rent, et ainsi tout g√¢cher. </p><br><p>  Pour la fixation.  Une collection peut impl√©menter un tel trait afin de pouvoir se transformer en it√©rateur: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntoIterator</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntoIter</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item=Self::Item&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">into_iter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Self::IntoIter; }</code> </pre> <br><p>  Et encore une fois, c'est la collection qui d√©cide de quel it√©rateur il s'agit, √† savoir: un it√©rateur dont le type de retour correspond au type d'√©l√©ments de la collection elle-m√™me, et aucun autre. </p><br><h3 id="eschyo-bolee-na-palcah">  Plus sur les doigts </h3><br><p>  Si les exemples ci-dessus sont encore incompr√©hensibles, alors voici une explication encore moins scientifique mais plus intelligible.  Les arguments de type peuvent √™tre consid√©r√©s comme des informations ¬´d'entr√©e¬ª que nous fournissons pour que le trait fonctionne.  Les types associ√©s peuvent √™tre consid√©r√©s comme des informations de ¬´sortie¬ª que le trait nous fournit afin que nous puissions utiliser les r√©sultats de son travail. </p><br><p>  La biblioth√®que standard a la capacit√© de surcharger les op√©rateurs math√©matiques pour ses types (addition, soustraction, multiplication, division, etc.).  Pour ce faire, vous devez impl√©menter l'un des traits correspondants de la biblioth√®que standard.  Voici, par exemple, √† quoi ressemble ce trait pour l'op√©ration d'addition (encore une fois, simplifi√©e): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Add</span></span></span></span>&lt;RHS&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, rhs: RHS) -&gt; Self::Output; }</code> </pre> <br><p>  Ici, nous avons l'argument <code>RHS</code> ¬´entr√©e¬ª - c'est le type auquel nous appliquerons l'op√©ration d'addition avec notre type.  Et il y a un argument "sortie" <code>Add::Output</code> - c'est le type qui r√©sultera de l'addition.  Dans le cas g√©n√©ral, cela peut diff√©rer du type de termes, qui, √† leur tour, peuvent √©galement √™tre de types diff√©rents (ajoutez du go√ªt au bleu et devenez doux - mais quoi, je le fais tout le temps).  Le premier est sp√©cifi√© √† l'aide de l'argument type, le second est sp√©cifi√© √† l'aide du type associ√©. </p><br><p>  Vous pouvez impl√©menter n'importe quel nombre d'additions avec diff√©rents types du deuxi√®me argument, mais √† chaque fois il n'y aura qu'un seul type de r√©sultat, et il est d√©termin√© par l'impl√©mentation de cette addition. </p><br><p>  Essayons d'impl√©menter ce trait: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>); <span class="hljs-meta"><span class="hljs-meta">#[derive(PartialEq, Debug)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Foo { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Bar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, rhs: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; Bar { Bar(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, rhs) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = Foo(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = x + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      &lt;Foo as Add&gt;::add(42)  x assert_eq!(y, Bar("test", 42)); }</span></span></code> </pre> <br><p>  Dans cet exemple, le type de la variable <code>y</code> est d√©termin√© par l'algorithme d'addition, pas le code appelant.  Il serait tr√®s √©trange s'il √©tait possible d'√©crire quelque chose comme <code>let y: Baz = x + 42</code> , c'est-√†-dire de forcer l'op√©ration d'addition √† renvoyer un r√©sultat d'un type √©tranger.  C'est √† partir de telles choses que le type associ√© <code>Add::Output</code> nous assure. </p><br><h3 id="itogo">  Total </h3><br><p>  Nous utilisons des g√©n√©riques o√π cela ne nous d√©range pas d'avoir plusieurs impl√©mentations de traits pour le m√™me type, et o√π il est acceptable de sp√©cifier une impl√©mentation sp√©cifique du c√¥t√© de l'appel.  Nous utilisons des types associ√©s o√π nous voulons avoir une impl√©mentation "canonique", qui contr√¥le elle-m√™me les types.  Combinez et m√©langez dans les bonnes proportions, comme dans le dernier exemple. </p><br><p>  La pi√®ce a-t-elle √©chou√©?  Tuez-moi avec des commentaires. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441444/">https://habr.com/ru/post/fr441444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441428/index.html">Principes de base de PowerShell: d√©finition de la fin d'une ligne avec un caract√®re sp√©cifique</a></li>
<li><a href="../fr441430/index.html">La premi√®re fois que nous essayons App Center et racontons notre exp√©rience</a></li>
<li><a href="../fr441436/index.html">Les scientifiques ont d√©velopp√© des cellules souches universelles en utilisant l'ing√©nierie CRISPR</a></li>
<li><a href="../fr441438/index.html">Services unifi√©s goszakup.gov.kz - Version 2</a></li>
<li><a href="../fr441442/index.html">YouTube a d√©sactiv√© les publicit√©s anti-vaccin</a></li>
<li><a href="../fr441446/index.html">Apprendre √† l'ordinateur: comment acqu√©rir une nouvelle comp√©tence</a></li>
<li><a href="../fr441448/index.html">Pan impossible et autres victoires de tuiles Penrose</a></li>
<li><a href="../fr441450/index.html">Pentesting Azure - R√©flexions sur la s√©curit√© dans le cloud computing</a></li>
<li><a href="../fr441452/index.html">Trois extensions r√©actives zen</a></li>
<li><a href="../fr441454/index.html">La NASA met en garde SpaceX et Boeing sur les d√©fauts des vaisseaux spatiaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>