<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏯 🧑🏾‍🤝‍🧑🏼 🎅🏻 Fault Injection: Sistem Anda tidak dapat diandalkan jika Anda belum mencoba untuk memecahkannya ☺️ 🦑 🎟️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Nama saya Pavel Lipsky. Saya seorang insinyur, saya bekerja untuk Sberbank-Technology. Spesialisasi saya adalah menguji toleransi kesalaha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fault Injection: Sistem Anda tidak dapat diandalkan jika Anda belum mencoba untuk memecahkannya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/433468/">  Halo, Habr!  Nama saya Pavel Lipsky.  Saya seorang insinyur, saya bekerja untuk Sberbank-Technology.  Spesialisasi saya adalah menguji toleransi kesalahan dan kinerja backend sistem terdistribusi besar.  Sederhananya, saya merusak program orang lain.  Dalam posting ini saya akan berbicara tentang injeksi kesalahan - metode pengujian yang memungkinkan Anda menemukan masalah dalam sistem dengan membuat kegagalan buatan.  Saya akan mulai dengan bagaimana saya sampai pada metode ini, maka kita akan berbicara tentang metode itu sendiri dan bagaimana kita menggunakannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/593/a93/c50593a934415805dac00c5de3a07390.png"></div><a name="habracut"></a><br>  Artikel ini akan memiliki contoh Java.  Jika Anda tidak pemrograman di Jawa - tidak apa-apa, cukup pahami pendekatan itu sendiri dan prinsip-prinsip dasar.  Apache Ignite digunakan sebagai basis data, tetapi pendekatan yang sama berlaku untuk DBMS lainnya.  Semua contoh dapat diunduh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> saya. <br><br><h2>  Mengapa kita membutuhkan semua ini? </h2><br>  Saya akan mulai dengan ceritanya.  Pada 2005, saya bekerja untuk Rambler.  Pada saat itu, jumlah pengguna Rambler berkembang pesat, dan arsitektur dua-tier kami "server - database - server - application" berhenti mengatasi.  Kami memikirkan cara mengatasi masalah kinerja, dan menarik perhatian pada teknologi memcached. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e4e/907/91e/e4e90791ef24ecaba4ec24a941f6e5ce.png" width="600" height="278"><br><br>  Apa itu memcached?  Memcached - tabel hash dalam memori akses acak dengan akses ke objek yang disimpan dengan kunci.  Misalnya, Anda perlu mendapatkan profil pengguna.  Aplikasi mengakses memcached (2).  Jika ada objek di dalamnya, maka itu segera dikembalikan ke pengguna.  Jika tidak ada objek, maka banding dibuat ke database (3), objek dibentuk dan dimasukkan ke dalam memcached (4).  Kemudian, pada panggilan berikutnya, kita tidak perlu lagi membuat panggilan sumber daya mahal ke database - kita akan mendapatkan objek siap pakai dari RAM - memcached. <br><br>  Karena memcached, kami secara nyata menurunkan database, dan aplikasi kami mulai bekerja lebih cepat.  Tetapi, ternyata, terlalu dini untuk bersukacita.  Seiring dengan peningkatan produktivitas, kami mendapat tantangan baru. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42c/4f9/c03/42c4f9c03bf3a365e19b4cda2dc6562b.png" width="600" height="277"><br><br>  Ketika Anda perlu mengubah data, aplikasi pertama-tama membuat koreksi ke database (2), membuat objek baru dan kemudian mencoba memasukkannya ke dalam memcached (3).  Artinya, objek lama harus diganti dengan yang baru.  Bayangkan bahwa pada saat ini terjadi hal yang mengerikan - koneksi antara aplikasi dan memcached terputus, server memcached atau bahkan aplikasi itu sendiri crash.  Jadi, aplikasi tidak dapat memperbarui data dalam memcached.  Akibatnya, pengguna akan pergi ke halaman situs (misalnya, profilnya), melihat data lama dan tidak mengerti mengapa ini terjadi. <br><br>  Bisakah bug ini terdeteksi selama pengujian fungsional atau pengujian kinerja?  Saya pikir, kemungkinan besar, kita tidak akan menemukannya.  Untuk mencari bug semacam itu ada jenis pengujian khusus - injeksi kesalahan. <br><br>  Biasanya selama pengujian injeksi kesalahan ada bug yang populer disebut <i>mengambang</i> .  Mereka muncul di bawah beban, ketika lebih dari satu pengguna bekerja dalam sistem, ketika situasi abnormal terjadi - kerusakan peralatan, listrik terputus, kerusakan jaringan, dll. <br><br><h2>  Sistem TI Sberbank Baru </h2><br>  Beberapa tahun yang lalu, Sberbank mulai membangun sistem TI baru.  Mengapa  Berikut adalah statistik dari situs web Bank Sentral: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/32c/1ab/05232c1ab18a23996d9172fcdc05d970.png" width="600" height="229"><br><br>  Bagian hijau dari kolom adalah jumlah penarikan tunai di ATM, bagian biru adalah jumlah operasi untuk membayar barang dan jasa.  Kami melihat bahwa jumlah transaksi tanpa uang tunai meningkat dari tahun ke tahun.  Dalam beberapa tahun, kita harus mampu menangani meningkatnya beban kerja dan terus menawarkan layanan baru kepada pelanggan kami.  Ini adalah salah satu alasan untuk menciptakan sistem IT Sberbank baru.  Selain itu, kami ingin mengurangi ketergantungan kami pada teknologi Barat dan mainframe yang mahal, yang harganya jutaan dolar, dan beralih ke teknologi open source dan server kelas bawah. <br><br>  Awalnya, kami meletakkan dasar teknologi Apache Ignite di jantung arsitektur Sberbank baru.  Lebih tepatnya, kami menggunakan plugin Gridgain berbayar.  Teknologi ini memiliki fungsionalitas yang cukup kaya: menggabungkan sifat-sifat database relasional (ada dukungan untuk pertanyaan SQL), NoSQL, pemrosesan terdistribusi dan penyimpanan data dalam RAM.  Apalagi saat Anda reboot, data yang ada di RAM tidak akan hilang di mana pun.  Dimulai dengan versi 2.1, Apache Ignite telah mendistribusikan Apache Ignite Persistent Data Store dengan dukungan SQL. <br><br>  Saya akan mencantumkan beberapa fitur dari teknologi ini: <br><br><ul><li>  Penyimpanan dan pemrosesan data dalam RAM <br></li><li>  Penyimpanan disk <br></li><li>  Dukungan SQL <br></li><li>  Eksekusi tugas terdistribusi <br></li><li>  Penskalaan horisontal <br></li></ul><br>  Teknologi ini relatif baru, sehingga membutuhkan perhatian khusus. <br><br>  Sistem TI baru Sberbank secara fisik terdiri dari banyak server yang relatif kecil yang dirakit dalam satu cloud cluster.  Semua node identik dalam struktur, peer to peer, melakukan fungsi menyimpan dan memproses data. <br><br>  Di dalam cluster dibagi menjadi sel-sel yang disebut.  Satu sel adalah 8 node.  Setiap pusat data memiliki 4 node. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a6/e18/2da/7a6e182daba502a73800093e18e1b4f7.png" width="600" height="343"><br>  Karena kami menggunakan Apache Ignite, kotak data dalam memori, maka, karenanya, semua ini disimpan dalam cache yang didistribusikan server.  Selain itu, cache, pada gilirannya, dibagi menjadi potongan - potongan yang identik.  Di server, mereka direpresentasikan sebagai file.  Partisi dari cache yang sama dapat disimpan di server yang berbeda.  Untuk setiap partisi di cluster, ada node primer dan cadangan. <br><br>  Node utama menyimpan partisi utama dan memproses permintaan mereka, mereplikasi data ke node cadangan (backup node), di mana partisi cadangan disimpan. <br><br>  Ketika merancang arsitektur baru Sberbank, kami sampai pada kesimpulan bahwa komponen sistem dapat dan akan gagal.  Katakanlah, jika Anda memiliki sekelompok 1000 server low-end besi, maka dari waktu ke waktu Anda akan mengalami kegagalan perangkat keras.  Potongan RAM, kartu jaringan dan hard drive, dll. Akan gagal.  Kami akan menganggap perilaku ini sebagai perilaku sistem yang sepenuhnya normal.  Situasi seperti itu harus ditangani dengan benar dan pelanggan kita seharusnya tidak melihatnya. <br><br>  Tapi itu tidak cukup untuk merancang ketahanan sistem terhadap kegagalan, penting untuk menguji sistem selama kegagalan ini.  Seperti Caitie McCaffrey dari Microsoft Research, seorang peneliti sistem terdistribusi yang terkenal, mengatakan: "Anda tidak akan pernah tahu bagaimana sistem berperilaku selama kegagalan darurat sampai Anda mereproduksi kegagalan." <br><br><h2>  Pembaruan yang Hilang </h2><br>  Mari kita ambil contoh sederhana, aplikasi perbankan yang mensimulasikan transfer uang.  Aplikasi akan terdiri dari dua bagian: Server Apache Ignite dan klien Apache Ignite.  Sisi server adalah gudang data. <br><br>  Aplikasi klien terhubung ke server Apache Ignite.  Membuat cache di mana kuncinya adalah ID akun dan nilainya adalah objek akun.  Secara total, sepuluh objek tersebut akan disimpan dalam cache.  Dalam hal ini, awalnya kami akan memberikan $ 100 pada setiap akun (sehingga ada sesuatu untuk ditransfer).  Dengan demikian, total saldo pada semua akun akan sama dengan $ 1.000. <br><br><pre><code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.ATOMIC); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IgniteCache&lt;Integer, Account&gt; cache = ignite.getOrCreateCache(cfg)) {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= ENTRIES_COUNT; i++)       cache.put(i, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Account(i, <span class="hljs-number"><span class="hljs-number">100</span></span>));   System.out.println(<span class="hljs-string"><span class="hljs-string">"Accounts before transfers"</span></span>);   printAccounts(cache);   printTotalBalance(cache);   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pairOfAccounts[] = getPairOfRandomAccounts();       transferMoney(cache, pairOfAccounts[<span class="hljs-number"><span class="hljs-number">0</span></span>], pairOfAccounts[<span class="hljs-number"><span class="hljs-number">1</span></span>]);   } } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IgniteCache&lt;Integer, Account&gt; cache, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{   Account fromAccount = cache.get(fromAccountId);   Account toAccount = cache.get(toAccountId);   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance);   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;   }   fromAccount.withdraw(amount);   toAccount.deposit(amount);   cache.put(fromAccountId, fromAccount);   cache.put(toAccountId, toAccount); }</code> </pre> <br><br>  Lalu kami melakukan 100 transfer uang acak antara 10 akun ini.  Misalnya, $ 50 ditransfer dari akun A ke akun B. lainnya  Secara skematis, proses ini dapat direpresentasikan sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/526/dc8/626/526dc86262d11f823d0aabce90c2c429.png"><br><br>  Sistem ditutup, transfer hanya dilakukan secara internal, mis.  total saldo harus tetap sama dengan $ 1000. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6d/afe/366/f6dafe3664e4f55c07515fde18d0e92e.png" width="600" height="268"><br><br>  Luncurkan aplikasi. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/S8_UMhMwhb0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Kami mendapat nilai yang diharapkan dari total saldo - $ 1000.  Sekarang mari kita sedikit mempersulit aplikasi kita - mari kita buat multitask.  Pada kenyataannya, beberapa aplikasi klien dapat bekerja secara bersamaan dengan akun yang sama.  Jalankan dua tugas yang secara bersamaan akan melakukan transfer uang antara sepuluh akun. <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.ATOMIC); cfg.setCacheMode(CacheMode.PARTITIONED); cfg.setIndexedTypes(Integer.class, Account.class); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IgniteCache&lt;Integer, Account&gt; cache = ignite.getOrCreateCache(cfg)) {  <span class="hljs-comment"><span class="hljs-comment">// Initializing the cache.  for (int i = 1; i &lt;= ENTRIES_COUNT; i++)    cache.put(i, new Account(i, 100));  System.out.println("Accounts before transfers");  System.out.println();  printAccounts(cache);  printTotalBalance(cache);  IgniteRunnable run1 = new MyIgniteRunnable(cache, ignite,1);  IgniteRunnable run2 = new MyIgniteRunnable(cache, ignite,2);  List&lt;IgniteRunnable&gt; arr = Arrays.asList(run1, run2);  ignite.compute().run(arr); } ... private void transferMoney(int fromAccountId, int toAccountId) {  Account fromAccount = cache.get(fromAccountId);  Account toAccount = cache.get(toAccountId);  int amount = getRandomAmount(fromAccount.balance);  if (amount &lt; 1) {      return;  }  int fromAccountBalanceBeforeTransfer = fromAccount.balance;  int toAccountBalanceBeforeTransfer = toAccount.balance;  fromAccount.withdraw(amount);  toAccount.deposit(amount);  cache.put(fromAccountId, fromAccount);  cache.put(toAccountId, toAccount); }</span></span></code> </pre><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3RPeJlYNDFg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Total saldo adalah $ 1.296.  Pelanggan bersukacita, bank menderita kerugian.  Mengapa ini terjadi? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed1/636/2fd/ed16362fd78ed83f0ecb703941eb2596.png"><br><br>  Di sini kita melihat bagaimana dua tugas secara bersamaan mengubah keadaan akun A. Namun tugas kedua berhasil mencatat perubahannya lebih awal daripada yang pertama.  Kemudian tugas pertama mencatat perubahannya, dan semua perubahan yang dilakukan oleh tugas kedua segera menghilang.  Anomali ini disebut masalah pembaruan yang hilang. <br><br>  Agar aplikasi berfungsi sebagaimana mestinya, basis data kami harus mendukung transaksi ACID dan kode kami harus mempertimbangkan ini. <br><br>  Mari kita lihat properti ACID untuk aplikasi kita untuk memahami mengapa ini sangat penting. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2f/210/b47/f2f210b470dc23068ac49e0b68b54de3.png" width="315" height="315"><br><br><ul><li>  <i>A - Atomicity, atomicity.</i>  Entah semua perubahan yang diajukan akan dilakukan ke database, atau tidak ada yang dibuat.  Artinya, jika kami mengalami kegagalan antara langkah 3 dan 6, perubahan tidak boleh ada di database <br></li><li>  <i>C - Konsistensi, Integritas.</i>  Setelah transaksi selesai, basis data harus tetap dalam kondisi yang konsisten.  Dalam contoh kami, ini berarti bahwa jumlah A dan B harus selalu sama, total saldo adalah $ 1000. <br></li><li>  <i>I - Isolasi, isolasi.</i>  Transaksi tidak boleh saling mempengaruhi.  Jika satu transaksi melakukan transfer, dan yang lainnya menerima nilai akun A dan B setelah langkah 3 dan hingga langkah 6, ia berpikir bahwa sistem memiliki lebih sedikit uang daripada yang diperlukan.  Ada nuansa di sini yang akan saya fokuskan nanti. <br></li><li>  <i>D - Daya Tahan</i>  Setelah transaksi melakukan perubahan pada basis data, perubahan ini tidak boleh hilang sebagai akibat dari kegagalan. <br></li></ul><br>  Jadi, dalam metode transferMoney, kami akan melakukan transfer uang dalam transaksi. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart()) {      Account fromAccount = cache.get(fromAccountId);      Account toAccount = cache.get(toAccountId);      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance);      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) {          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;      }      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fromAccountBalanceBeforeTransfer = fromAccount.balance;      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> toAccountBalanceBeforeTransfer = toAccount.balance;          fromAccount.withdraw(amount);      toAccount.deposit(amount);          cache.put(fromAccountId, fromAccount);      cache.put(toAccountId, toAccount);          tx.commit();  } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){      e.printStackTrace();  } }</code> </pre><br>  Luncurkan aplikasi. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pEgyqAUAvM8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hm  Transaksi tidak membantu.  Total saldo adalah $ 6951!  Apa masalah dengan perilaku aplikasi ini? <br><br>  Pertama, mereka memilih jenis cache ATOMIC, mis.  tanpa dukungan transaksi ACID: <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.TOMIC);</code> </pre> <br>  Kedua, metode txStart memiliki dua parameter penting dari tipe enum yang akan lebih baik untuk ditentukan: metode kunci (mode concurrency di Apache Ignite) dan tingkat isolasi.  Bergantung pada nilai parameter ini, transaksi dapat membaca dan menulis data dengan berbagai cara.  Di Apache Ignite, parameter ini ditetapkan sebagai berikut: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart( ,  )) { Account fromAccount = cache.get(fromAccountId); Account toAccount = cache.get(toAccountId); ...  tx.commit(); }</code> </pre><br>  Anda dapat menggunakan PESSIMISTIC (kunci pesimis) atau OPTIMISTIK (kunci optimis) sebagai nilai parameter METODE LOCK.  Mereka berbeda dalam instan pemblokiran.  Saat menggunakan PESSIMISTIC, kunci dikenai pada baca / tulis pertama dan ditahan hingga transaksi dilakukan.  Misalnya, ketika transaksi dengan kunci pesimistis melakukan transfer dari akun A ke akun B, transaksi lain tidak akan dapat membaca atau menulis nilai-nilai akun ini hingga transaksi yang membuat transfer dilakukan.  Jelas bahwa jika transaksi lain ingin mengakses akun A dan B, mereka dipaksa untuk menunggu transaksi selesai, yang memiliki dampak negatif pada keseluruhan kinerja aplikasi.  Penguncian optimis tidak membatasi akses ke data untuk transaksi lain, namun, selama fase persiapan transaksi untuk komit (tahap persiapan, Apache Ignite menggunakan protokol 2PC), akan dilakukan pemeriksaan - apakah data berubah dengan transaksi lain?  Dan jika terjadi perubahan, maka transaksi akan dibatalkan.  Dalam hal kinerja, OPTIMISTIK akan berjalan lebih cepat, tetapi lebih cocok untuk aplikasi di mana tidak ada persaingan dengan data. <br><br>  Parameter INSULATION LEVEL menentukan tingkat isolasi transaksi dari satu sama lain.  Standar SQL ANSI / ISO mendefinisikan 4 jenis isolasi, dan untuk setiap tingkat isolasi, skenario transaksi yang sama dapat menghasilkan hasil yang berbeda. <br><br><ul><li>  READ_UNCOMMITED adalah tingkat isolasi terendah.  Transaksi dapat melihat data yang "tidak dikomit" kotor. <br></li><li>  READ_COMMITTED - ketika transaksi melihat di dalam dirinya sendiri hanya data sensitif <br></li><li>  REPEATABLE_READ - artinya jika pembacaan dilakukan di dalam transaksi, maka pembacaan ini harus diulang. <br></li><li>  SERIALIZABLE - level ini mengasumsikan tingkat isolasi transaksi maksimum - seolah-olah tidak ada pengguna lain dalam sistem.  Hasil transaksi paralel akan seolah-olah dieksekusi secara berurutan.  Tetapi bersama dengan tingkat isolasi yang tinggi, kami mendapatkan pengurangan kinerja.  Karena itu, Anda harus hati-hati mendekati pilihan tingkat isolasi ini. <br></li></ul><br>  Untuk banyak DBMS modern (Microsoft SQL Server, PostgreSQL dan Oracle), level isolasi default adalah READ_COMMITTED.  Misalnya, ini akan berakibat fatal, karena tidak akan melindungi kami dari pembaruan yang hilang.  Hasilnya akan sama seperti jika kita belum pernah menggunakan transaksi sama sekali. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/32a/a26/0a6/32aa260a65aa3ad758dbecc220eef231.png"><br><br>  Dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi transaksi Apache Ignite</a> , cocok bagi kami untuk menggunakan kombinasi metode kunci dan tingkat isolasi: <br><br><ul><li>  <b>PESSIMISTIC REPEATABLE_READ</b> - kunci dikenakan pada pembacaan pertama atau penulisan data dan ditahan sampai selesai. <br></li><li>  <b>PESSIMISTIC SERIALIZABLE</b> - berfungsi serupa dengan PESSIMISTIC REPEATABLE_READ <br></li><li>  <b>SERIALISASI YANG OPTIMIS</b> - versi data yang diperoleh setelah pembacaan pertama diingat, dan jika versi ini berbeda selama tahap persiapan untuk komit (data diubah oleh transaksi lain), transaksi akan dibatalkan.  Mari kita coba opsi ini. <br></li></ul><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart(OPTIMISTIC, SERIALIZABLE)) { Account fromAccount = cache.get(fromAccountId); Account toAccount = cache.get(toAccountId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fromAccountBalanceBeforeTransfer = fromAccount.balance; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> toAccountBalanceBeforeTransfer = toAccount.balance; fromAccount.withdraw(amount); toAccount.deposit(amount); cache.put(fromAccountId, fromAccount); cache.put(toAccountId, toAccount); tx.commit(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ e.printStackTrace(); } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/vPZcW7qbvvs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hore, dapatkan $ 1.000, seperti yang diharapkan.  Pada upaya ketiga. <br><br><h2>  Menguji di bawah beban </h2><br>  Sekarang kami akan membuat pengujian kami lebih realistis - kami akan menguji di bawah beban.  Dan tambahkan node server tambahan.  Ada banyak alat untuk melakukan stress testing, di Sberbank kami menggunakan HP Performance Center.  Ini adalah alat yang cukup kuat, mendukung lebih dari 50 protokol, dirancang untuk tim besar dan menghabiskan banyak uang.  Saya menulis contoh saya di JMeter - ini gratis dan menyelesaikan masalah kami 100%.  Saya tidak ingin menulis ulang kode di Jawa, jadi saya akan menggunakan sampler JSR223. <br><br>  Kami akan membuat arsip JAR dari kelas aplikasi kami dan memuatnya ke dalam rencana pengujian.  Untuk membuat dan mengisi cache, jalankan kelas CreateCache.  Setelah menginisialisasi cache, Anda dapat menjalankan skrip JMeter. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/i7jUnyfz_88" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Semuanya keren, dapatkan $ 1.000. <br><br><h2>  Shutdown darurat cluster cluster </h2><br>  Sekarang kita akan lebih destruktif: selama operasi cluster, kita akan crash salah satu dari dua node server.  Melalui utilitas Visor, yang termasuk dalam paket Gridgain, kita dapat memonitor cluster Apache Ignite dan membuat sampel data yang berbeda.  Di tab Penampil SQL, jalankan kueri SQL untuk mendapatkan saldo keseluruhan untuk semua akun. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/phUdYiMrPLg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Apa itu  553 dolar.  Pelanggan takut, bank menderita kerugian reputasi.  Apa yang kita lakukan salah kali ini? <br><br>  Ternyata ada jenis cache di Apache Ignite: <br><br><ul><li>  dipartisi - satu atau beberapa salinan cadangan disimpan di dalam cluster <br></li><li>  cache yang direplikasi - semua partisi (semua bagian dari cache) disimpan dalam satu server.  Tembolok seperti itu cocok terutama untuk buku referensi - sesuatu yang jarang berubah dan sering dibaca. <br></li><li>  lokal - semua dalam satu simpul <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/032/23e/360/03223e3607e052fe4f0e3f24aca15837.png" width="600" height="344"><br><br>  Kami akan sering mengubah data kami, jadi kami akan memilih cache yang dipartisi dan menambahkan cadangan tambahan untuk itu.  Artinya, kita akan memiliki dua salinan data - primer dan cadangan. <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL); cfg.setCacheMode(CacheMode.PARTITIONED); cfg.setBackups(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Kami meluncurkan aplikasi.  Saya mengingatkan Anda bahwa sebelum transfer kami memiliki $ 1000.  Kami memulai dan selama operasi kami "memadamkan" salah satu node <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1Y0C9eaTXFk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dalam utilitas Visor, kami membuat kueri SQL untuk mendapatkan saldo total $ 1000.  Semuanya berjalan dengan baik! <br><br><h2>  Kasus keandalan </h2><br>  Dua tahun lalu, kami baru mulai menguji sistem TI Sberbank yang baru.  Entah bagaimana, kami pergi ke insinyur pengawal kami dan bertanya: apa yang bisa menghancurkan sama sekali?  Mereka menjawab kami: semuanya bisa pecah, uji semuanya!  Tentu saja, jawaban ini tidak cocok untuk kita.  Kami duduk bersama, menganalisis statistik kegagalan dan menyadari bahwa kasus yang paling mungkin kami temui adalah kegagalan simpul. <br><br>  Selain itu, ini dapat terjadi karena alasan yang sangat berbeda.  Misalnya, aplikasi mungkin macet, crash JVM, crash OS, atau kegagalan perangkat keras. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68c/ea2/035/68cea2035db5f01d47e48943a2c8797a.png" width="600" height="197"><br><br>  Kami membagi semua kemungkinan kegagalan menjadi 4 kelompok: <br><br><ol><li>  Peralatan <br></li><li>  Jaringan <br></li><li>  Perangkat lunak <br></li><li>  Lainnya <br></li></ol><br>  Mereka datang dengan tes untuk mereka dan menyebut mereka kasus keandalan.  Kasus keandalan tipikal terdiri dari deskripsi kondisi sistem sebelum pengujian, langkah-langkah untuk mereproduksi kegagalan, dan deskripsi perilaku yang diharapkan selama kegagalan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/201/bc5/484/201bc5484c7811d1a70bb8da502e3ad9.png" width="600" height="313"><br><br><h4>  Kasus keandalan: peralatan </h4><br>  Grup ini mencakup beberapa kasus seperti: <br><br><ul><li>  Kegagalan daya <br></li><li>  Kehilangan akses total ke hard drive <br></li><li>  Kegagalan satu jalur akses hard drive <br></li><li>  CPU, RAM, disk, beban jaringan <br></li></ul><br>  Cluster menyimpan 4 salinan identik dari setiap partisi: satu partisi primer dan tiga partisi cadangan.  Misalkan sebuah simpul meninggalkan sebuah cluster karena kegagalan peralatan.  Dalam hal ini, partisi utama harus pindah ke node yang masih hidup lainnya. <br><br>  Apa lagi yang bisa terjadi?  Hilangnya rak di dalam sel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44d/2b8/132/44d2b81324d9a0d91ee63a5508652456.png" width="600" height="251"><br><br>  Semua node sel berada di rak yang berbeda.  Yaitu  output rak tidak akan menyebabkan kegagalan cluster atau kehilangan data.  Kami akan memiliki tiga salinan empat.  Tetapi bahkan jika kita kehilangan seluruh pusat data, itu juga tidak akan menjadi masalah besar bagi kita, karena  kami masih memiliki dua salinan data lagi dari empat. <br><br>  Beberapa kasus dilakukan langsung di pusat data dengan bantuan insinyur pendukung.  Misalnya, mematikan hard drive, mematikan daya ke server atau rak. <br><br><h4>  Kasus keandalan: jaringan </h4><br>  Untuk menguji kasus yang terkait dengan fragmentasi jaringan, kami menggunakan iptables.  Dan menggunakan utilitas NetEm kami meniru: <br><br><ul><li>  keterlambatan jaringan dengan fungsi distribusi yang berbeda <br></li><li>  paket hilang <br></li><li>  coba lagi paket <br></li><li>  paket pemesanan ulang <br></li><li>  distorsi paket <br></li></ul><br>  Kasus jaringan lain yang menarik yang kami uji adalah split-brain.  Ini adalah ketika semua node cluster hidup, tetapi karena segmentasi jaringan mereka tidak dapat berkomunikasi satu sama lain.  Istilah ini berasal dari kedokteran dan berarti bahwa otak dibagi menjadi dua belahan, yang masing-masing menganggap dirinya unik.  Hal yang sama dapat terjadi pada sebuah cluster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/778/cc0/58e/778cc058e68e7d552b612f9389af7499.png"><br>  Terjadi bahwa antara pusat data koneksi hilang.  Misalnya, tahun lalu, karena kerusakan pada kabel serat optik oleh excavator, klien bank Tochka, Otkrytie, dan bank Rocketbank tidak melakukan transaksi melalui Internet selama beberapa jam, terminal tidak menerima kartu dan ATM tidak berfungsi.  Banyak yang telah ditulis tentang kecelakaan ini di Twitter. <br><br>  Dalam kasus kami, situasi otak terpecah harus ditangani dengan benar.  Sebuah grid mengidentifikasi otak-terpisah - membagi sebuah cluster menjadi dua bagian.  Setengah masuk ke mode baca.  Ini adalah setengah di mana ada lebih banyak node yang hidup atau koordinator berada (node ​​tertua di cluster). <br><br><h4>  Kasus keandalan: perangkat lunak </h4><br>  Ini adalah kasus yang berkaitan dengan kegagalan berbagai subsistem: <br><br><ul><li>  DPL ORM - modul akses data, seperti Hibernate ORM <br></li><li>  Transportasi antar moda - pengiriman pesan antar modul (layanan microser) <br></li><li>  Sistem pembalakan <br></li><li>  Sistem akses <br></li><li>  Apache Ignite Cluster <br></li><li>  ... <br></li></ul><br>  Karena sebagian besar perangkat lunak ditulis dalam Java, kami rentan terhadap semua masalah yang melekat pada aplikasi Java.  Menguji berbagai pengaturan pengumpul sampah.  Menjalankan tes dengan crash mesin virtual java. <br><br>  Untuk kluster Apache Ignite, ada case khusus untuk off-heap - ini adalah area memori yang dikendalikan oleh Apache Ignite.  Ini jauh lebih besar dari heap java dan dirancang untuk menyimpan data dan indeks.  Di sini Anda dapat, misalnya, menguji overflow.  Kami meluap-luap dan melihat bagaimana cluster bekerja ketika beberapa data tidak masuk ke dalam RAM, mis.  baca dari disk. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d97/cb0/29a/d97cb029adf7075f155c3f68332b3a80.png" width="600" height="374"><br><br><h4>  Kasus lainnya </h4><br>  Ini adalah kasus-kasus yang tidak termasuk dalam tiga kelompok pertama.  Ini termasuk utilitas yang memungkinkan pemulihan data jika terjadi kecelakaan besar atau ketika data dimigrasikan ke cluster lain. <br><br><ul><li>  Utilitas untuk membuat snapshot (cadangan) data - pengujian snapshot penuh dan tambahan. <br></li><li>  Pemulihan ke titik waktu tertentu - Mekanisme PITR (Pemulihan dalam waktu). <br></li></ul><br><h2>  Utilitas untuk injeksi kesalahan </h2><br>  Saya ingat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ke contoh dari laporan saya.  Anda dapat mengunduh distribusi Apache Ignite dari situs resmi - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unduh Apache Ignite</a> .  Dan sekarang saya akan membagikan utilitas yang kami gunakan di Sberbank, jika Anda tiba-tiba tertarik pada topik tersebut. <br><br>  Kerangka kerja <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jepsen</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monyet kekacauan</a> <br></li></ul><br>  Manajemen Konfigurasi: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mungkin</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wayang</a> <br></li></ul><br>  Utilitas Linux: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NetEm (tc)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stres-ng</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Iperf</a> <br></li><li>  bunuh -9 <br></li><li>  iptables <br></li></ul><br>  Alat Uji Beban: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jmeter</a> <br></li></ul><br>  Baik di dunia modern maupun di Sberbank, semua perubahan bersifat dinamis dan sulit untuk memprediksi teknologi mana yang akan digunakan dalam beberapa tahun mendatang.  Tapi saya tahu pasti bahwa kita akan menggunakan metode Fault Injection.  Metode ini bersifat universal - sangat cocok untuk menguji teknologi apa pun, benar-benar berfungsi, membantu menangkap banyak bug dan membuat produk yang kami kembangkan menjadi lebih baik. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433468/">https://habr.com/ru/post/id433468/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433446/index.html">Security Week 51: bug di WordPress 5.0 dan perangkat lunak Logitech, kerentanan foto Facebook</a></li>
<li><a href="../id433448/index.html">Analisis komparatif dari pasar bekas Mobil Jerman dan Prancis di segmen B dan C</a></li>
<li><a href="../id433450/index.html">Tumbuhkan dan ajarkan. Bagaimana kami berteman dengan PEGA</a></li>
<li><a href="../id433456/index.html">Bagaimana meyakinkan pelanggan atau perusahaan untuk menggunakan Flutter</a></li>
<li><a href="../id433462/index.html">Pemeriksaan kesehatan dan degradasi bertahap sistem terdistribusi</a></li>
<li><a href="../id433472/index.html">Unity 2018.3 dirilis</a></li>
<li><a href="../id433474/index.html">Pylint dari dalam ke luar. Bagaimana dia melakukannya?</a></li>
<li><a href="../id433478/index.html">Mengapa Django dipilih di Tinkoff Magazine</a></li>
<li><a href="../id433480/index.html">Kisah Holivarny tentang linter</a></li>
<li><a href="../id433482/index.html">Django di bawah mikroskop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>