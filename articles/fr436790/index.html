<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñ§ üë©üèΩ‚Äçüíª üôéüèæ 256 lignes de C ++ nu: √©criture d'un ray tracer √† partir de z√©ro en quelques heures üê´ üëö ‚õàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je publie le chapitre suivant de mon cours magistral sur l'infographie ( ici vous pouvez lire l' original en russe, bien que la version anglaise soit ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>256 lignes de C ++ nu: √©criture d'un ray tracer √† partir de z√©ro en quelques heures</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436790/">  Je publie le chapitre suivant de mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cours magistral sur l'infographie</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici vous pouvez lire l'</a> original en russe, bien que la version anglaise soit plus r√©cente).  Cette fois, le sujet de la conversation est de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dessiner des sc√®nes en utilisant le lancer de rayons</a> .  Comme d'habitude, j'essaie d'√©viter les biblioth√®ques tierces, car cela incite les √©tudiants √† regarder sous le capot. <br><br>  Il existe d√©j√† de nombreux projets similaires sur Internet, mais presque tous pr√©sentent des programmes finis extr√™mement difficiles √† comprendre.  Voici, par exemple, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">programme de rendu</a> tr√®s c√©l√®bre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qui tient sur une carte de visite</a> .  Un r√©sultat tr√®s impressionnant, mais comprendre ce code est tr√®s difficile.  Mon objectif n'est pas de montrer comment je peux, mais de dire en d√©tail comment le reproduire.  De plus, il me semble que sp√©cifiquement cette conf√©rence est utile non seulement autant que du mat√©riel de formation sur l'infographie, mais plut√¥t comme un manuel de programmation.  Je montrerai constamment comment arriver au r√©sultat final, en partant de z√©ro: comment d√©composer un probl√®me complexe en √©tapes √©l√©mentaires r√©solubles. <br><br>  <i>Attention: juste regarder mon code, ainsi que lire cet article avec une tasse de th√© √† la main, n'a pas de sens.</i>  <i>Cet article est con√ßu pour vous permettre de saisir un clavier et d'√©crire votre propre moteur.</i>  <i>Il sera s√ªrement meilleur que le mien.</i>  <i>Eh bien, ou changez simplement le langage de programmation!</i> <br><br>  Donc, aujourd'hui, je vais montrer comment dessiner de telles images: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><a name="habracut"></a><br><h1>  Premi√®re √©tape: enregistrer l'image sur le disque </h1><br>  Je ne veux pas m'emb√™ter avec les gestionnaires de fen√™tres, le traitement souris / clavier, etc.  Le r√©sultat de notre programme sera une simple image enregistr√©e sur le disque.  Ainsi, la premi√®re chose que nous devons √™tre en mesure de faire est d'enregistrer l'image sur le disque.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici</a> se trouve le code qui vous permet de le faire.  Permettez-moi de vous donner son fichier principal: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br>  Dans la fonction principale, seule la fonction render () est appel√©e, rien d'autre.  Que contient la fonction render ()?  Tout d'abord, je d√©finis une image comme un tableau unidimensionnel de valeurs de tampon d'image de type Vec3f, ce sont de simples vecteurs tridimensionnels qui nous donnent la couleur (r, g, b) pour chaque pixel. <br><br>  La classe vector se trouve dans le fichier geometry.h, je ne la d√©crirai pas ici: premi√®rement, tout y est trivial, manipulation simple de vecteurs bidimensionnels et tridimensionnels (addition, soustraction, affectation, multiplication par un scalaire, produit scalaire), et deuxi√®mement, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">gbg l'a</a> d√©j√† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©crit</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©tail</a> dans le cadre d'un cours magistral sur l'infographie. <br><br>  J'enregistre l'image au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">format ppm</a> ;  C'est le moyen le plus simple d'enregistrer des images, mais ce n'est pas toujours le plus pratique pour une visualisation ult√©rieure.  Si vous souhaitez enregistrer dans d'autres formats, je recommande toujours de connecter une biblioth√®que tierce, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stb</a> .  C'est une merveilleuse biblioth√®que: il suffit d'inclure un fichier d'en-t√™te stb_image_write.h dans le projet, et cela permettra d'enregistrer m√™me en png, m√™me en jpg. <br><br>  Au total, l'objectif de cette √©tape est de s'assurer que nous pouvons a) cr√©er une image en m√©moire et y √©crire diff√©rentes valeurs de couleur b) enregistrer le r√©sultat sur le disque afin qu'il puisse √™tre visualis√© dans un programme tiers.  Voici le r√©sultat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg"><br><br><h1>  √âtape deux, la plus difficile: le lancer de rayons directement </h1><br>  Il s'agit de l'√©tape la plus importante et la plus difficile de toute la cha√Æne.  Je veux d√©finir une sph√®re dans mon code et l'afficher √† l'√©cran sans se soucier des mat√©riaux ou de l'√©clairage.  Voici √† quoi devrait ressembler notre r√©sultat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg"><br><br>  Pour plus de commodit√©, dans mon r√©f√©rentiel, il y a un commit pour chaque √©tape;  Github facilite l'affichage de vos modifications.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici, par exemple</a> , ce qui a chang√© dans le deuxi√®me commit par rapport au premier. <br><br>  Pour commencer: de quoi avons-nous besoin pour repr√©senter une sph√®re dans la m√©moire de l'ordinateur?  Quatre nombres nous suffisent: un vecteur tridimensionnel avec le centre de la sph√®re et un scalaire d√©crivant le rayon: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre><br>  La seule chose non triviale dans ce code est une fonction qui vous permet de v√©rifier si un rayon donn√© (originaire d'orig dans la direction de dir) croise notre sph√®re.  Une description d√©taill√©e de l'algorithme pour v√©rifier l'intersection du faisceau et de la sph√®re peut √™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lue ici</a> , je recommande fortement de le faire et de v√©rifier mon code. <br><br>  Comment fonctionne le lancer de rayons?  Tr√®s simple.  Au premier stade, nous avons simplement recouvert l'image d'un d√©grad√©: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre><br>  Maintenant, pour chaque pixel, nous allons former un rayon venant du centre des coordonn√©es et traversant notre pixel, et v√©rifier si ce rayon intersecte notre sph√®re. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><br>  S'il n'y a pas d'intersection avec la sph√®re, alors nous mettrons color1, sinon color2: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { Ôøº [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } Ôøº [...] }</span></span></code> </pre><br>  √Ä ce stade, je recommande de prendre un crayon et de v√©rifier sur papier tous les calculs, √† la fois l'intersection d'un rayon avec une sph√®re et le balayage d'une image avec des rayons.  Au cas o√π, notre cam√©ra est d√©termin√©e par les √©l√©ments suivants: <br><br><ul><li>  largeur d'image </li><li>  hauteur de l'image </li><li>  angle de vue, fov </li><li>  emplacement de la cam√©ra, Vec3f (0,0,0) </li><li>  direction du regard, le long de l'axe z, dans le sens de moins l'infini </li></ul><br><h1>  Troisi√®me √©tape: ajouter plus de sph√®res </h1><br>  Le plus difficile est derri√®re nous, maintenant notre chemin est sans nuage.  Si nous pouvons dessiner une sph√®re.  alors √©videmment ajouter un peu plus de travail n'est pas difficile.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici, vous pouvez</a> voir les changements dans le code, et voici le r√©sultat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg"><br><br><h1>  Quatri√®me √©tape: l'√©clairage </h1><br>  Tout le monde est bon dans notre photo, mais ce n'est tout simplement pas assez d'√©clairage.  Dans le reste de l'article, nous n'en parlerons que.  Ajoutez des sources lumineuses ponctuelles: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre><br>  Consid√©rer un √©clairage r√©el est une t√¢che tr√®s, tr√®s difficile, donc, comme tout le monde, nous tromperons l'≈ìil en dessinant des r√©sultats compl√®tement non physiques, mais tr√®s probablement, plausibles.  Premi√®re remarque: pourquoi fait-il froid en hiver et chaud en √©t√©?  Parce que le chauffage de la surface de la terre d√©pend de l'angle d'incidence de la lumi√®re solaire.  Plus le soleil est haut au-dessus de l'horizon, plus la surface est lumineuse.  Et vice versa, plus l'horizon est bas, plus faible.  Eh bien, apr√®s le coucher du soleil √† l'horizon, les photons ne nous atteignent pas du tout.  En ce qui concerne nos sph√®res: voici notre faisceau √©mis par la cam√©ra (pas de relation avec les photons, attention!) Intersect√© avec la sph√®re.  Comment comprendre comment le point d'intersection est illumin√©?  Vous pouvez simplement regarder l'angle entre le vecteur normal √† ce point et le vecteur d√©crivant la direction de la lumi√®re.  Plus l'angle est petit, meilleure est la surface √©clair√©e.  Pour le rendre encore plus pratique, vous pouvez simplement prendre le produit scalaire entre le vecteur normal et le vecteur d'√©clairage.  Je rappelle que le produit scalaire entre deux vecteurs a et b est √©gal au produit des normes des vecteurs par le cosinus de l'angle entre les vecteurs: a * b = | a |  | b |  cos (alpha (a, b)).  Si nous prenons des vecteurs de longueur unitaire, alors le produit scalaire le plus simple nous donnera l'intensit√© de l'√©clairage de surface. <br><br>  Ainsi, dans la fonction cast_ray, au lieu d'une couleur constante, nous retournerons la couleur en tenant compte des sources lumineuses: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voir les</a> changements <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , mais le r√©sultat du programme: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg"><br><br><h1>  Cinqui√®me √©tape: surfaces brillantes </h1><br>  Une astuce avec un produit scalaire entre un vecteur normal et un vecteur lumineux se rapproche assez bien de l'illumination des surfaces mates, dans la litt√©rature on l'appelle illumination diffuse.  Que faire si on veut du lisse et du brillant?  Je veux avoir cette photo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg"><br><br>  Voyez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">combien peu de</a> changements devaient √™tre faits.  En bref, les r√©flexions sur les surfaces brillantes sont plus lumineuses, plus l'angle entre la direction de vue et la direction de <i>la</i> lumi√®re <i>r√©fl√©chie est</i> petit.  Eh bien, les coins, bien s√ªr, nous compterons √† travers les produits scalaires, exactement comme avant. <br><br>  Cette gymnastique avec √©clairage des surfaces mates et brillantes est connue sous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le</a> nom de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le Phong</a> .  Le wiki a une description assez d√©taill√©e de ce mod√®le d'√©clairage; il se lit bien lorsqu'il est compar√© en parall√®le avec mon code.  Voici une image cl√© √† comprendre: <br><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png"><br><br><h1>  √âtape six: Ombres </h1><br>  Pourquoi avons-nous de la lumi√®re, mais pas d'ombres?  Mess!  Je veux cette photo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Seules six lignes de code</a> nous permettent d'y parvenir: lors du dessin de chaque point, nous nous assurons simplement que la source lumineuse n'intersecte pas les objets de notre sc√®ne, et si c'est le cas, alors la source lumineuse actuelle saute.  Il n'y a qu'une petite subtilit√©: je d√©place un peu le point dans le sens de la normale: <br><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre><br>  Pourquoi?  Oui, c'est juste que notre point se trouve sur la surface de l'objet, et (√† l'exception du probl√®me des erreurs num√©riques) tout rayon de ce point traversera notre sc√®ne. <br><br><h1>  √âtape sept: R√©flexions </h1><br>  C'est incroyable, mais pour ajouter des reflets √† notre sc√®ne, il suffit d'ajouter trois lignes de code: <br><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voyez par vous-m√™me:</a> √† l'intersection avec l'objet, nous comptons simplement le rayon r√©fl√©chi (la fonction du calcul des bosses est utile!) Et appelons r√©cursivement la fonction cast_ray dans la direction du rayon r√©fl√©chi.  Assurez-vous de jouer avec la <a href="">profondeur de r√©cursivit√©</a> , je la mets √† quatre, je recommence √† z√©ro, qu'est-ce qui va changer dans l'image?  Voici mon r√©sultat avec une r√©flexion de travail et une profondeur de quatre: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg"><br><br><h1>  √âtape huit: R√©fraction </h1><br>  En apprenant √† compter les r√©flexions, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©fractions sont compt√©es exactement de la m√™me mani√®re</a> .  Une fonction qui vous permet de calculer la direction du rayon r√©fract√© ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">selon la loi de Snell</a> ), et trois lignes de code dans notre fonction r√©cursive cast_ray.  Voici le r√©sultat, dans lequel la boule la plus proche est devenue ¬´verre¬ª, elle se r√©fracte et se refl√®te l√©g√®rement: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg"><br><br><h1>  √âtape neuf: ajouter plus d'objets </h1><br>  Pourquoi sommes-nous tous sans lait, mais sans lait.  Jusqu'√† ce moment, nous n'avons rendu que des sph√®res, car il s'agit de l'un des objets math√©matiques non triviaux les plus simples.  Et ajoutons un morceau de l'avion.  Un classique du genre est un √©chiquier.  Pour cela, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dizaine de lignes</a> dans une fonction qui consid√®re l'intersection du faisceau avec la sc√®ne nous suffisent largement. <br><br>  Eh bien, voici le r√©sultat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><br>  Comme je l'ai promis, exactement 256 lignes de code, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comptez pour vous</a> ! <br><br><h1>  √âtape dix: devoirs </h1><br>  Nous avons parcouru un long chemin: nous avons appris √† ajouter des objets √† la sc√®ne, √† consid√©rer un √©clairage assez compliqu√©.  Permettez-moi de laisser deux t√¢ches comme devoirs.  Absolument tout le travail pr√©paratoire a d√©j√† √©t√© fait dans la branche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">homework_assignment</a> .  Chaque travail n√©cessitera un maximum de dix lignes de code. <br><br><h3>  T√¢che un: Carte de l'environnement </h3><br>  Pour le moment, si le faisceau ne traverse pas la sc√®ne, nous le r√©glons simplement sur une couleur constante.  Et pourquoi, en fait, permanent?  Prenons une photo sph√©rique (fichier <a href="">envmap.jpg</a> ) et utilisons-la comme arri√®re-plan!  Pour vous faciliter la vie, j'ai li√© notre projet √† la biblioth√®que stb pour la commodit√© de travailler avec des fichiers jpeg.  Cela devrait √™tre un rendu comme celui-ci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg"><br><br><h3>  La deuxi√®me t√¢che: charlatan! </h3><br>  Nous pouvons rendre des sph√®res et des plans (voir √©chiquier).  Ajoutons donc un dessin de mod√®les triangul√©s!  J'ai √©crit du code pour lire la grille de triangles et y ai ajout√© une fonction d'intersection rayon-triangle.  Maintenant, ajouter un canard √† notre sc√®ne devrait √™tre compl√®tement trivial! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><br><h1>  Conclusion </h1><br>  Ma t√¢che principale est de montrer des projets int√©ressants (et faciles!) √Ä programmer, j'esp√®re vraiment pouvoir le faire.  C'est tr√®s important, car je suis convaincu qu'un programmeur doit √©crire beaucoup et avec go√ªt.  Je ne sais pas pour vous, mais personnellement la comptabilit√© et un sapeur, avec une complexit√© de code assez comparable, ne m'attirent pas du tout. <br><br>  Deux cent cinquante lignes de lancer de rayons peuvent en fait √™tre √©crites en quelques heures.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cinq cents lignes de</a> tramage logiciel peuvent √™tre ma√Ætris√©es en quelques jours.  La prochaine fois, nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trierons le rakecasting</a> et, en m√™me temps, je montrerai les jeux les plus simples que mes √©l√®ves de premi√®re ann√©e √©crivent dans le cadre de l'enseignement de la programmation C ++.  Restez √† l'√©coute! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436790/">https://habr.com/ru/post/fr436790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436776/index.html">De la zone de confort aux meilleurs d√©veloppeurs</a></li>
<li><a href="../fr436778/index.html">defi.js est une biblioth√®que r√©active bas√©e sur Object.defineProperty</a></li>
<li><a href="../fr436780/index.html">Pi√®ges du d√©veloppement instantan√© de Google Play</a></li>
<li><a href="../fr436784/index.html">Thimble (Mozilla) passe √† Glitch</a></li>
<li><a href="../fr436786/index.html">Comment nous avons surveill√© Black Hat Europe 2018</a></li>
<li><a href="../fr436792/index.html">Conf√©rence DEFCON 19. Anonyme et nous. Partie 1</a></li>
<li><a href="../fr436794/index.html">Conf√©rence DEFCON 19. Anonyme et nous. 2e partie</a></li>
<li><a href="../fr436798/index.html">D√©formation administrative professionnelle</a></li>
<li><a href="../fr436802/index.html">Widget de communication 3CX pour votre site Wordpress</a></li>
<li><a href="../fr436826/index.html">Android Robotics jusqu'en 2019: la vraie histoire; en 5 parties; partie 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>