<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖤 👩🏽‍💻 🙎🏾 256 lignes de C ++ nu: écriture d'un ray tracer à partir de zéro en quelques heures 🐫 👚 ⛈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je publie le chapitre suivant de mon cours magistral sur l'infographie ( ici vous pouvez lire l' original en russe, bien que la version anglaise soit ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>256 lignes de C ++ nu: écriture d'un ray tracer à partir de zéro en quelques heures</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436790/">  Je publie le chapitre suivant de mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cours magistral sur l'infographie</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici vous pouvez lire l'</a> original en russe, bien que la version anglaise soit plus récente).  Cette fois, le sujet de la conversation est de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dessiner des scènes en utilisant le lancer de rayons</a> .  Comme d'habitude, j'essaie d'éviter les bibliothèques tierces, car cela incite les étudiants à regarder sous le capot. <br><br>  Il existe déjà de nombreux projets similaires sur Internet, mais presque tous présentent des programmes finis extrêmement difficiles à comprendre.  Voici, par exemple, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">programme de rendu</a> très célèbre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qui tient sur une carte de visite</a> .  Un résultat très impressionnant, mais comprendre ce code est très difficile.  Mon objectif n'est pas de montrer comment je peux, mais de dire en détail comment le reproduire.  De plus, il me semble que spécifiquement cette conférence est utile non seulement autant que du matériel de formation sur l'infographie, mais plutôt comme un manuel de programmation.  Je montrerai constamment comment arriver au résultat final, en partant de zéro: comment décomposer un problème complexe en étapes élémentaires résolubles. <br><br>  <i>Attention: juste regarder mon code, ainsi que lire cet article avec une tasse de thé à la main, n'a pas de sens.</i>  <i>Cet article est conçu pour vous permettre de saisir un clavier et d'écrire votre propre moteur.</i>  <i>Il sera sûrement meilleur que le mien.</i>  <i>Eh bien, ou changez simplement le langage de programmation!</i> <br><br>  Donc, aujourd'hui, je vais montrer comment dessiner de telles images: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><a name="habracut"></a><br><h1>  Première étape: enregistrer l'image sur le disque </h1><br>  Je ne veux pas m'embêter avec les gestionnaires de fenêtres, le traitement souris / clavier, etc.  Le résultat de notre programme sera une simple image enregistrée sur le disque.  Ainsi, la première chose que nous devons être en mesure de faire est d'enregistrer l'image sur le disque.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici</a> se trouve le code qui vous permet de le faire.  Permettez-moi de vous donner son fichier principal: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br>  Dans la fonction principale, seule la fonction render () est appelée, rien d'autre.  Que contient la fonction render ()?  Tout d'abord, je définis une image comme un tableau unidimensionnel de valeurs de tampon d'image de type Vec3f, ce sont de simples vecteurs tridimensionnels qui nous donnent la couleur (r, g, b) pour chaque pixel. <br><br>  La classe vector se trouve dans le fichier geometry.h, je ne la décrirai pas ici: premièrement, tout y est trivial, manipulation simple de vecteurs bidimensionnels et tridimensionnels (addition, soustraction, affectation, multiplication par un scalaire, produit scalaire), et deuxièmement, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">gbg l'a</a> déjà <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décrit</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">détail</a> dans le cadre d'un cours magistral sur l'infographie. <br><br>  J'enregistre l'image au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">format ppm</a> ;  C'est le moyen le plus simple d'enregistrer des images, mais ce n'est pas toujours le plus pratique pour une visualisation ultérieure.  Si vous souhaitez enregistrer dans d'autres formats, je recommande toujours de connecter une bibliothèque tierce, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stb</a> .  C'est une merveilleuse bibliothèque: il suffit d'inclure un fichier d'en-tête stb_image_write.h dans le projet, et cela permettra d'enregistrer même en png, même en jpg. <br><br>  Au total, l'objectif de cette étape est de s'assurer que nous pouvons a) créer une image en mémoire et y écrire différentes valeurs de couleur b) enregistrer le résultat sur le disque afin qu'il puisse être visualisé dans un programme tiers.  Voici le résultat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg"><br><br><h1>  Étape deux, la plus difficile: le lancer de rayons directement </h1><br>  Il s'agit de l'étape la plus importante et la plus difficile de toute la chaîne.  Je veux définir une sphère dans mon code et l'afficher à l'écran sans se soucier des matériaux ou de l'éclairage.  Voici à quoi devrait ressembler notre résultat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg"><br><br>  Pour plus de commodité, dans mon référentiel, il y a un commit pour chaque étape;  Github facilite l'affichage de vos modifications.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici, par exemple</a> , ce qui a changé dans le deuxième commit par rapport au premier. <br><br>  Pour commencer: de quoi avons-nous besoin pour représenter une sphère dans la mémoire de l'ordinateur?  Quatre nombres nous suffisent: un vecteur tridimensionnel avec le centre de la sphère et un scalaire décrivant le rayon: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre><br>  La seule chose non triviale dans ce code est une fonction qui vous permet de vérifier si un rayon donné (originaire d'orig dans la direction de dir) croise notre sphère.  Une description détaillée de l'algorithme pour vérifier l'intersection du faisceau et de la sphère peut être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lue ici</a> , je recommande fortement de le faire et de vérifier mon code. <br><br>  Comment fonctionne le lancer de rayons?  Très simple.  Au premier stade, nous avons simplement recouvert l'image d'un dégradé: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre><br>  Maintenant, pour chaque pixel, nous allons former un rayon venant du centre des coordonnées et traversant notre pixel, et vérifier si ce rayon intersecte notre sphère. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><br>  S'il n'y a pas d'intersection avec la sphère, alors nous mettrons color1, sinon color2: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { ￼ [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } ￼ [...] }</span></span></code> </pre><br>  À ce stade, je recommande de prendre un crayon et de vérifier sur papier tous les calculs, à la fois l'intersection d'un rayon avec une sphère et le balayage d'une image avec des rayons.  Au cas où, notre caméra est déterminée par les éléments suivants: <br><br><ul><li>  largeur d'image </li><li>  hauteur de l'image </li><li>  angle de vue, fov </li><li>  emplacement de la caméra, Vec3f (0,0,0) </li><li>  direction du regard, le long de l'axe z, dans le sens de moins l'infini </li></ul><br><h1>  Troisième étape: ajouter plus de sphères </h1><br>  Le plus difficile est derrière nous, maintenant notre chemin est sans nuage.  Si nous pouvons dessiner une sphère.  alors évidemment ajouter un peu plus de travail n'est pas difficile.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici, vous pouvez</a> voir les changements dans le code, et voici le résultat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg"><br><br><h1>  Quatrième étape: l'éclairage </h1><br>  Tout le monde est bon dans notre photo, mais ce n'est tout simplement pas assez d'éclairage.  Dans le reste de l'article, nous n'en parlerons que.  Ajoutez des sources lumineuses ponctuelles: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre><br>  Considérer un éclairage réel est une tâche très, très difficile, donc, comme tout le monde, nous tromperons l'œil en dessinant des résultats complètement non physiques, mais très probablement, plausibles.  Première remarque: pourquoi fait-il froid en hiver et chaud en été?  Parce que le chauffage de la surface de la terre dépend de l'angle d'incidence de la lumière solaire.  Plus le soleil est haut au-dessus de l'horizon, plus la surface est lumineuse.  Et vice versa, plus l'horizon est bas, plus faible.  Eh bien, après le coucher du soleil à l'horizon, les photons ne nous atteignent pas du tout.  En ce qui concerne nos sphères: voici notre faisceau émis par la caméra (pas de relation avec les photons, attention!) Intersecté avec la sphère.  Comment comprendre comment le point d'intersection est illuminé?  Vous pouvez simplement regarder l'angle entre le vecteur normal à ce point et le vecteur décrivant la direction de la lumière.  Plus l'angle est petit, meilleure est la surface éclairée.  Pour le rendre encore plus pratique, vous pouvez simplement prendre le produit scalaire entre le vecteur normal et le vecteur d'éclairage.  Je rappelle que le produit scalaire entre deux vecteurs a et b est égal au produit des normes des vecteurs par le cosinus de l'angle entre les vecteurs: a * b = | a |  | b |  cos (alpha (a, b)).  Si nous prenons des vecteurs de longueur unitaire, alors le produit scalaire le plus simple nous donnera l'intensité de l'éclairage de surface. <br><br>  Ainsi, dans la fonction cast_ray, au lieu d'une couleur constante, nous retournerons la couleur en tenant compte des sources lumineuses: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voir les</a> changements <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , mais le résultat du programme: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg"><br><br><h1>  Cinquième étape: surfaces brillantes </h1><br>  Une astuce avec un produit scalaire entre un vecteur normal et un vecteur lumineux se rapproche assez bien de l'illumination des surfaces mates, dans la littérature on l'appelle illumination diffuse.  Que faire si on veut du lisse et du brillant?  Je veux avoir cette photo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg"><br><br>  Voyez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">combien peu de</a> changements devaient être faits.  En bref, les réflexions sur les surfaces brillantes sont plus lumineuses, plus l'angle entre la direction de vue et la direction de <i>la</i> lumière <i>réfléchie est</i> petit.  Eh bien, les coins, bien sûr, nous compterons à travers les produits scalaires, exactement comme avant. <br><br>  Cette gymnastique avec éclairage des surfaces mates et brillantes est connue sous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le</a> nom de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modèle Phong</a> .  Le wiki a une description assez détaillée de ce modèle d'éclairage; il se lit bien lorsqu'il est comparé en parallèle avec mon code.  Voici une image clé à comprendre: <br><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png"><br><br><h1>  Étape six: Ombres </h1><br>  Pourquoi avons-nous de la lumière, mais pas d'ombres?  Mess!  Je veux cette photo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Seules six lignes de code</a> nous permettent d'y parvenir: lors du dessin de chaque point, nous nous assurons simplement que la source lumineuse n'intersecte pas les objets de notre scène, et si c'est le cas, alors la source lumineuse actuelle saute.  Il n'y a qu'une petite subtilité: je déplace un peu le point dans le sens de la normale: <br><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre><br>  Pourquoi?  Oui, c'est juste que notre point se trouve sur la surface de l'objet, et (à l'exception du problème des erreurs numériques) tout rayon de ce point traversera notre scène. <br><br><h1>  Étape sept: Réflexions </h1><br>  C'est incroyable, mais pour ajouter des reflets à notre scène, il suffit d'ajouter trois lignes de code: <br><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voyez par vous-même:</a> à l'intersection avec l'objet, nous comptons simplement le rayon réfléchi (la fonction du calcul des bosses est utile!) Et appelons récursivement la fonction cast_ray dans la direction du rayon réfléchi.  Assurez-vous de jouer avec la <a href="">profondeur de récursivité</a> , je la mets à quatre, je recommence à zéro, qu'est-ce qui va changer dans l'image?  Voici mon résultat avec une réflexion de travail et une profondeur de quatre: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg"><br><br><h1>  Étape huit: Réfraction </h1><br>  En apprenant à compter les réflexions, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réfractions sont comptées exactement de la même manière</a> .  Une fonction qui vous permet de calculer la direction du rayon réfracté ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">selon la loi de Snell</a> ), et trois lignes de code dans notre fonction récursive cast_ray.  Voici le résultat, dans lequel la boule la plus proche est devenue «verre», elle se réfracte et se reflète légèrement: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg"><br><br><h1>  Étape neuf: ajouter plus d'objets </h1><br>  Pourquoi sommes-nous tous sans lait, mais sans lait.  Jusqu'à ce moment, nous n'avons rendu que des sphères, car il s'agit de l'un des objets mathématiques non triviaux les plus simples.  Et ajoutons un morceau de l'avion.  Un classique du genre est un échiquier.  Pour cela, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dizaine de lignes</a> dans une fonction qui considère l'intersection du faisceau avec la scène nous suffisent largement. <br><br>  Eh bien, voici le résultat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><br>  Comme je l'ai promis, exactement 256 lignes de code, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comptez pour vous</a> ! <br><br><h1>  Étape dix: devoirs </h1><br>  Nous avons parcouru un long chemin: nous avons appris à ajouter des objets à la scène, à considérer un éclairage assez compliqué.  Permettez-moi de laisser deux tâches comme devoirs.  Absolument tout le travail préparatoire a déjà été fait dans la branche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">homework_assignment</a> .  Chaque travail nécessitera un maximum de dix lignes de code. <br><br><h3>  Tâche un: Carte de l'environnement </h3><br>  Pour le moment, si le faisceau ne traverse pas la scène, nous le réglons simplement sur une couleur constante.  Et pourquoi, en fait, permanent?  Prenons une photo sphérique (fichier <a href="">envmap.jpg</a> ) et utilisons-la comme arrière-plan!  Pour vous faciliter la vie, j'ai lié notre projet à la bibliothèque stb pour la commodité de travailler avec des fichiers jpeg.  Cela devrait être un rendu comme celui-ci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg"><br><br><h3>  La deuxième tâche: charlatan! </h3><br>  Nous pouvons rendre des sphères et des plans (voir échiquier).  Ajoutons donc un dessin de modèles triangulés!  J'ai écrit du code pour lire la grille de triangles et y ai ajouté une fonction d'intersection rayon-triangle.  Maintenant, ajouter un canard à notre scène devrait être complètement trivial! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><br><h1>  Conclusion </h1><br>  Ma tâche principale est de montrer des projets intéressants (et faciles!) À programmer, j'espère vraiment pouvoir le faire.  C'est très important, car je suis convaincu qu'un programmeur doit écrire beaucoup et avec goût.  Je ne sais pas pour vous, mais personnellement la comptabilité et un sapeur, avec une complexité de code assez comparable, ne m'attirent pas du tout. <br><br>  Deux cent cinquante lignes de lancer de rayons peuvent en fait être écrites en quelques heures.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cinq cents lignes de</a> tramage logiciel peuvent être maîtrisées en quelques jours.  La prochaine fois, nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trierons le rakecasting</a> et, en même temps, je montrerai les jeux les plus simples que mes élèves de première année écrivent dans le cadre de l'enseignement de la programmation C ++.  Restez à l'écoute! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436790/">https://habr.com/ru/post/fr436790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436776/index.html">De la zone de confort aux meilleurs développeurs</a></li>
<li><a href="../fr436778/index.html">defi.js est une bibliothèque réactive basée sur Object.defineProperty</a></li>
<li><a href="../fr436780/index.html">Pièges du développement instantané de Google Play</a></li>
<li><a href="../fr436784/index.html">Thimble (Mozilla) passe à Glitch</a></li>
<li><a href="../fr436786/index.html">Comment nous avons surveillé Black Hat Europe 2018</a></li>
<li><a href="../fr436792/index.html">Conférence DEFCON 19. Anonyme et nous. Partie 1</a></li>
<li><a href="../fr436794/index.html">Conférence DEFCON 19. Anonyme et nous. 2e partie</a></li>
<li><a href="../fr436798/index.html">Déformation administrative professionnelle</a></li>
<li><a href="../fr436802/index.html">Widget de communication 3CX pour votre site Wordpress</a></li>
<li><a href="../fr436826/index.html">Android Robotics jusqu'en 2019: la vraie histoire; en 5 parties; partie 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>