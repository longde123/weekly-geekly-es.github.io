<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ—¿ ğŸ•œ ğŸ‘» Mengetsa data dengan travajs â›¹ğŸ¿ ğŸ‘©â€ğŸ¤ ğŸï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam posting saya sebelumnya, saya menggambarkan poin utama ketika mengembangkan perpustakaan opensource lain. Saya lupa menyebutkan satu hal lagi: j...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengetsa data dengan travajs</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462189/"><img src="https://habrastorage.org/webt/kb/fw/tm/kbfwtmm5xe1jxdaa1l2avw8geuo.jpeg"><br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya,</a> saya menggambarkan poin utama ketika mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan opensource</a> lain.  Saya lupa menyebutkan satu hal lagi: jika Anda tidak memberi tahu siapa pun tentang perpustakaan, apa pun itu, kemungkinan besar tidak ada yang akan mengetahuinya. <br><br>  Jadi, temui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">trava.js</a> - validasi juicy untuk kepentingan proyek.  Ngomong-ngomong, kami telah menggunakan rumput selama lebih dari enam bulan, dan saya pikir sudah waktunya untuk memberi tahu Anda tentang manfaat menggunakannya.  Bahkan sudah kering, jadi tahan napas.  Dan lanjutkan. <br><a name="habracut"></a><br><h2>  Konsep </h2><br>  Sepintas, tampaknya validasi adalah topik sepele yang tidak memerlukan perhatian khusus.  Nilainya benar atau tidak, yang bisa lebih sederhana: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// any checking... if (!check(value)) return false; return true; }</span></span></code> </pre> <br>  Tetapi biasanya akan menyenangkan untuk mengetahui apa yang salah: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check1(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'ERROR_1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check2(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'ERROR_2'</span></span>; }</code> </pre><br>  Sebenarnya itu saja, masalahnya selesai. <br><br>  Jika bukan karena satu "tetapi." <br><br>  Dari pengalaman mengembangkan aplikasi nyata, diketahui bahwa masalah ini tidak berakhir dengan validasi.  Biasanya, data ini juga perlu dikonversi ke format tertentu, karena alasan tertentu tidak didukung oleh serializer di luar kotak, misalnya tanggal, set, atau tipe data khusus lainnya.  Mengingat ini terutama JSON, dalam praktiknya ternyata Anda harus melakukan double pass melalui struktur data input selama validasi dan transformasi.  Idenya muncul, mengapa tidak menggabungkan dua tahap ini menjadi satu.  Kemungkinan plus juga akan menjadi keberadaan skema data deklaratif eksplisit. <br><br>  Untuk mendukung konversi nilai ke format tertentu, validator harus dapat mengembalikan tidak hanya kesalahan, tetapi juga nilai yang dikurangi.  Di dunia js, beberapa opsi antarmuka cukup umum dengan kemungkinan pengembalian kesalahan. <br><br><ol><li>  Mungkin yang paling umum adalah kembalinya tuple [error, data]: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check1(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'ERROR_1'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check2(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'ERROR_2'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, value]; }</code> </pre> <br>  Ada juga opsi serupa di mana bukan array dikembalikan, tetapi objek <i>{error, data}</i> , tetapi tidak ada perbedaan mendasar.  Keuntungan dari pendekatan ini adalah kejelasan, minusnya adalah bahwa sekarang di mana pun Anda perlu mempertahankan kontrak ini.  Untuk validasi, ini tidak menyebabkan ketidaknyamanan, tetapi untuk transformasi ini jelas berlebihan. <br></li><li>  Gunakan pengecualian.  Meskipun menurut saya kesalahan validasi adalah situasi standar dalam aplikasi, tidak ada yang luar biasa.  Sejujurnya, saya berpikir bahwa pengecualian paling baik digunakan hanya jika ada sesuatu yang salah.  Selain itu, pengecualian dapat secara tidak sengaja disebut di validator sendiri, dan kemudian Anda mungkin tidak tahu sama sekali bahwa itu adalah kesalahan dalam kode, dan bukan dalam nilainya.  Keuntungan dari pendekatan ini adalah penyederhanaan antarmuka - sekarang selalu nilainya dikembalikan dengan cara biasa, dan kesalahan dilemparkan sebagai pengecualian. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ada opsi</a> untuk menempatkan kesalahan dalam variabel global.  Tapi saya tidak akan menarik negara tidak perlu. <br></li><li>  Gunakan tipe terpisah untuk kesalahan.  Sepertinya opsi dengan pengecualian, jika Anda mengambil jenis kesalahan dari mereka, tetapi jangan membuangnya. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check1(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Trava.ValidationError({ <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-number"><span class="hljs-number">401</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check2(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Trava.ValidationError({ <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-number"><span class="hljs-number">405</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseOrTransform(value); <span class="hljs-comment"><span class="hljs-comment">// apply some parse or transform }</span></span></code> </pre> <br></li></ol>  Saya memilih opsi yang terakhir, meskipun ini juga kompromi, tetapi secara keseluruhan tidak buruk.  <i>Trava.ValidationError</i> diusulkan sebagai jenis kesalahan, yang mewarisi dari <i>Kesalahan</i> standar dan menambahkan kemampuan untuk menggunakan tipe data sewenang-wenang untuk melaporkan kesalahan.  Tidak perlu menggunakan <i>Trava.ValidationError</i> , Anda dapat menggunakan <i>Kesalahan</i> standar, tetapi jangan lupa bahwa kemudian pesan kesalahan hanya string. <br><br>  Untuk meringkas, kita dapat mengatakan bahwa validator adalah fungsi yang bersih dan sinkron yang, selain nilai, dapat mengembalikan kesalahan.  Sangat sederhana.  Dan teori ini bekerja dengan baik tanpa perpustakaan.  Dalam praktiknya, validator digabungkan ke dalam rantai dan hierarki, dan di sini rumput pasti akan berguna. <br><br><h2>  Komposisi </h2><br>  Mungkin komposisi adalah kasus paling umum bekerja dengan validator.  Implementasi komposisi mungkin berbeda.  Misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka joi</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">v8n yang</a> terkenal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> ini dilakukan melalui objek dan serangkaian metode: <br><br><pre> <code class="javascript hljs">Joi.string().alphanum().min(<span class="hljs-number"><span class="hljs-number">0</span></span>).max(<span class="hljs-number"><span class="hljs-number">255</span></span>)</code> </pre> <br>  Meskipun terlihat indah pada pandangan pertama, pendekatan ini memiliki beberapa kelemahan, dan satu fatal.  Dan inilah masalahnya.  Dalam pengalaman saya, validator selalu menjadi hal untuk aplikasi spesifik, jadi fokus utama di perpustakaan harus pada kenyamanan memperluas validator dan integrasi dengan pendekatan yang ada, dan bukan pada jumlah primitif dasar, yang, menurut saya, hanya menambah bobot ke perpustakaan, tetapi sebagian besar tidak akan digunakan.  Ambil contoh validator yang sama untuk string.  Kemudian ternyata Anda perlu memangkas spasi dari ujungnya, lalu tiba-tiba Anda perlu mengizinkan penggunaan karakter khusus dalam satu kasus tunggal, dan di suatu tempat Anda perlu mengarah ke huruf kecil, dll.  Bahkan, mungkin ada banyak primitif seperti itu, dan saya hanya tidak melihat gunanya bahkan mulai menambahkannya ke perpustakaan.  Menurut pendapat saya, penggunaan objek juga berlebihan dan mengarah pada peningkatan kompleksitas selama ekspansi, meskipun pada pandangan pertama tampaknya membuat hidup lebih mudah.  Misalnya, c <i>joi</i> tidak begitu mudah <a href="">untuk menulis validator Anda</a> . <br><br>  Pendekatan fungsional dan rumput di sini dapat membantu.  Contoh yang sama untuk memvalidasi angka yang ditentukan dalam rentang dari 0 hingga 255: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    const isNumber = n =&gt; typeof n == 'number' &amp;&amp; !isNaN(n); //  const numberValidator = Trava.Check(isNumber); const byteValidator = Trava.Compose([ numberValidator, Trava.Check(n =&gt; 0 &lt;= n &amp;&amp; n &lt; 256), ]); byteValidator(-1); // !</span></span></code> </pre><br>  Pernyataan <b>Periksa</b> membuat validator keluar dari pemeriksaan kebenaran (nilai =&gt; benar / salah).  Dan <b>menulis rantai</b> validator.  Ketika dieksekusi, rantai terputus setelah kesalahan pertama.  Yang penting adalah bahwa fungsi-fungsi biasa digunakan di mana-mana, yang sangat mudah untuk diperluas dan digunakan.  Menurut saya, kemudahan ekspansi ini adalah fitur kunci dari pustaka validasi yang valid. <br><br>  Secara tradisional, tempat terpisah dalam validasi ditempati dengan memeriksa <i>nol</i> dan <i>tidak terdefinisi</i> .  Ada operator pembantu di rumput untuk ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   null  undefined const requiredNumberValidator = Trava.Required(numberValidator); requiredNumberValidator(undefined); // ! const optNumberValidator = Trava.Optional(numberValidator, 2); // 2 is default optNumberValidator(undefined); // 2 optNumberValidator(null); // null const nullNumberValidator = Trava.Nullable(numberValidator, 3); // 3 is default nullNumberValidator(undefined); // 3 nullNumberValidator(null); // 3</span></span></code> </pre><br>  Ada beberapa operator pembantu lagi di rumput, dan mereka semua menyusun dengan indah dan mengejutkan hanya berkembang.  Seperti fungsi biasa :) <br><br><h2>  Hierarki </h2><br>  Tipe data sederhana disusun dalam hierarki.  Kasing yang paling umum adalah objek dan array.  Ada operator di rumput yang membuatnya lebih mudah untuk bekerja dengan mereka: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const byteArrayValidator = Trava.Each(byteValidator); byteArrayValidator([1, -1, 2, -3]); // ValidationError: {"1":"Incorrect value","3":"Incorrect value"} //   const pointValidator = Trava.Keys({ x: numberValidator, y: numberValidator, }); pointValidator({x: 1, y: 'a'}); // ValidationError: {"y":"Incorrect value"}</span></span></code> </pre><br>  Ketika memvalidasi objek, diputuskan untuk menekankan keparahan definisi: semua kunci diperlukan secara default (dibungkus dalam <b>Wajib</b> ).  Kunci yang tidak ditentukan dalam validator dibuang. <br><br>  Beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jsonschema</a> , solusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kuartet</a> lebih suka menggambarkan validator dalam bentuk data, misalnya {x: 'number', y: 'number'}, tetapi ini mengarah pada kesulitan yang sama ketika berkembang.  Keuntungan yang signifikan dari pendekatan ini adalah kemungkinan serialisasi dan pertukaran sirkuit, yang tidak mungkin dengan fungsi.  Namun, ini dapat dengan mudah diimplementasikan di atas antarmuka fungsional.  Tidak perlu menyembunyikan fungsi di belakang garis!  Fungsi sudah memiliki nama dan hanya itu yang diperlukan. <br><br>  Untuk kemudahan penggunaan di dalam validator, operator <b>Compose</b> dan <b>Keys</b> dapat dihilangkan, juga nyaman untuk membungkus validator root di <b>Trava</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pointValidator = Trava({ <span class="hljs-comment"><span class="hljs-comment">//  -&gt; Keys x: [numberValidator, Trava.Check(v =&gt; v &gt; 180)], //  -&gt; Compose y: [numberValidator, Trava.Check(v =&gt; v &lt; 180)], });</span></span></code> </pre> <br>  Jika Anda memanggil <b>Trava</b> dengan argumen kedua, maka nilai balik akan menjadi hasil penerapan validator: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = Trava({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: [numberValidator, Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">180</span></span>)], <span class="hljs-attr"><span class="hljs-attr">y</span></span>: [numberValidator, Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &lt; <span class="hljs-number"><span class="hljs-number">180</span></span>)], }, <span class="hljs-comment"><span class="hljs-comment">//      { x: 200, y: 100, }); // { x: 200, y: 100 }</span></span></code> </pre> <br>  Sejauh ini, dukungan telah diterapkan hanya untuk array dan objek, seperti  pada dasarnya meracuni JSON dan itu sudah cukup.  Tarik Permintaan untuk Wellcome! <br><br><h2>  Konteks </h2><br>  Saat menggunakan validator sebagai parameter terakhir, Anda dapat melewati konteks yang akan dapat diakses dari semua validator yang disebut sebagai parameter terakhir.  Secara pribadi, kesempatan ini belum berguna bagi saya, tetapi itu mungkin. <br><br>  Untuk beberapa validator yang mungkin mengembalikan kesalahan, dimungkinkan untuk menentukan pesan kesalahan di tingkat yang berbeda.  Contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pos = Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); pos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ValidationError: "Incorrect value" (by default)</span></span></code> </pre><br>  Ganti untuk satu kasus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pos = Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"    "</span></span>); pos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ValidationError: "    "</span></span></code> </pre><br>  Ganti untuk semua kasus: <br><br><pre> <code class="javascript hljs">Trava.Check.ErrorMessage = <span class="hljs-string"><span class="hljs-string">" "</span></span>; pos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ValidationError: " "</span></span></code> </pre><br>  Selain itu, untuk konfigurasi yang lebih terperinci, Anda dapat mentransfer fungsi di tempat kesalahan, yang seharusnya mengembalikan kesalahan dan akan dipanggil dengan parameter validator. <br><br><h2>  Gunakan kasing </h2><br>  Sebagian besar kita meracuni JSON di backend bersama dengan koa.  Frontend juga duduk perlahan.  Lebih mudah memiliki validator bersama di kedua ujungnya.  Dan sekarang saya akan menunjukkan kasus penggunaan yang hampir nyata.  Misalkan Anda ingin menerapkan API untuk membuat dan memperbarui data pasien. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// validators.js const trava = require('trava'); const { isFilledString, isDate, isNumber } = require('../common/validators'); const patientSchema = { name: isFilledString, dateOfBirth: isDate, height: isNumber, } //        //      const patientNew = trava(patientSchema); //      const patientPatch = trava(mapValues(patientSchema, trava.Optional)); module.exports = { patientNew, patientPatch, }; // controllers.js const validate = require('./validators'); const { ValidationError } = require('../common/errors'); function create (ctx) { const patientData = validate.patientNew(ctx.request.body); //       Error,             Error if (patientData instanceof Error) return ValidationError(ctx, patientData); // ...create new patient } function update (ctx) { const patientData = validate.patientPatch(ctx.request.body); if (patientData instanceof Error) return ValidationError(ctx, patientData); // ...update patient data }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">common / errors.js</b> <div class="spoiler_text">  const trava = membutuhkan ('trava'); <br><br>  function ValidationError (ctx, params) { <br>  if (params instance of Error) { <br>  params = trava.ValidationError.extractData (params); <br>  } <br>  ctx.body = { <br>  kode: 'VALIDATION_ERROR', <br>  params, <br>  }; <br>  ctx.status = HttpStatus.BAD_REQUEST; <br>  } <br></div></div><br>  Meskipun contohnya sangat sederhana, itu tidak bisa disebut disederhanakan.  Dalam aplikasi nyata, hanya validator yang akan rumit.  Anda juga dapat membuat validasi di middleware - validator diterapkan sepenuhnya pada konteks atau ke badan permintaan. <br><br>  Dalam proses bekerja dan menggunakan validasi, kami sampai pada kesimpulan bahwa validator sinkron sederhana dan pesan kesalahan sederhana sudah cukup.  Bahkan, kami sampai pada kesimpulan bahwa kami hanya menggunakan dua pesan: "DIBUTUHKAN" dan "INVALID", yang dilokalkan di frontend bersama dengan prompt untuk bidang.  Pemeriksaan lain yang memerlukan tindakan tambahan (misalnya, pada saat pendaftaran untuk memeriksa apakah surat semacam itu sudah ada) berada di luar ruang lingkup validasi.  Bagaimanapun, rumput bukan tentang hal ini. <br><br><h2>  Kesimpulannya </h2><br>  Dalam artikel singkat ini, saya menjelaskan hampir seluruh fungsi perpustakaan, di luar ruang lingkup artikel ada beberapa pembantu yang menyederhanakan kehidupan.  Saya meminta detail di github <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/uNmAnNeR/travajs</a> . <br><br>  Kami membutuhkan alat yang dapat disesuaikan sebanyak mungkin, di mana tidak ada yang berlebihan, tetapi pada saat yang sama ada semua yang diperlukan untuk pekerjaan sehari-hari.  Dan saya pikir secara umum ini tercapai, saya berharap seseorang juga akan membuat hidup lebih mudah.  Saya akan senang dengan keinginan dan saran. <br>  Untuk kesehatan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462189/">https://habr.com/ru/post/id462189/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462175/index.html">Kami menangani singkatan dan frasa Latin dalam bahasa Inggris</a></li>
<li><a href="../id462177/index.html">Tur foto Museum Mineralogis dinamai Fersman</a></li>
<li><a href="../id462179/index.html">F-string atau cara membuat kode sedikit lebih cepat dan lebih mudah dibaca</a></li>
<li><a href="../id462181/index.html">Aturan untuk komunikasi yang efektif dalam obrolan grup</a></li>
<li><a href="../id462185/index.html">Revolusi telah berakhir. Apakah ada alternatif untuk baterai lithium-ion?</a></li>
<li><a href="../id462191/index.html">Museum DataArt: A Tour of Italy Utara</a></li>
<li><a href="../id462197/index.html">Kiat tentang cara membebaskan pikiran Anda dan meningkatkan kreativitas Anda</a></li>
<li><a href="../id462203/index.html">KVM (di bawah) VDI dengan mesin virtual satu kali menggunakan bash</a></li>
<li><a href="../id462205/index.html">Memenangkan PHDays 9 Standoff: Kronik tim True0xA3</a></li>
<li><a href="../id462209/index.html">Solusi VideoConference Polycom. Kenangan 6 tahun kemudian ... Tahap 2. Bagian 1. RMX1500</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>