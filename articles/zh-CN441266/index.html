<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚩 ⚡️ 🤚🏿 tiOPF delphi / lazarus框架的工作方式。 访客模板 👫 😀 🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="来自翻译 
 我承诺在二十年前针对不太流行的编程环境开发的框架上翻译几种材料的原因有两个： 

 1.几年前，在学习了使用实体框架作为.Net平台的ORM的许多乐趣之后，我徒劳地寻找了Lazarus环境的类似物，并且大体上搜索了freepascal。 
 令人惊讶的是，她缺少好的ORM。 当时发现的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>tiOPF delphi / lazarus框架的工作方式。 访客模板</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441266/"><h3> 来自翻译 </h3><br> 我承诺在二十年前针对不太流行的编程环境开发的框架上翻译几种材料的原因有两个： <br><br>  1.几年前，在学习了使用实体框架作为.Net平台的ORM的许多乐趣之后，我徒劳地寻找了Lazarus环境的类似物，并且大体上搜索了freepascal。 <br> 令人惊讶的是，她缺少好的ORM。 当时发现的只是一个名为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tiOPF</a>的开源项目，该项目于90年代后期为delphi开发，后来移植到了freepascal。 但是，此框架与大型ORM的通常外观根本不同。 <br><br> 在tiOPF中，没有视觉上的方法来设计对象（在实体中–首先是模型）并将对象映射到关系数据库表中的字段（在实体-中首先是数据库）。 开发人员自己将此事实视为项目的缺点之一，但是，值得一提的是，他针对对象业务模型提供了完整的定位，这仅是一个硬代码而已... <br><a name="habracut"></a><br> 在建议的硬编码级别上，我遇到了问题。 那时，我对框架开发人员完整使用并在文档中每段多次提到的那些范式和方法不是很精通（访问者，链接器，观察者的设计模式，DBMS独立性的多个抽象级别等）。 ）。 当时我从事数据库的大型项目完全专注于Lazarus的可视化组件以及可视化环境提供的数据库的工作方式，结果-大量相同的代码：数据库中的三个表具有几乎相同的结构和同质数据，用于查看的三个相同表格，用于编辑的三个相同表格，用于报告的三个相同表格，以及“如何不设计软件”标题顶部的其他所有内容。 <br><br> 阅读了足够的有关数据库和信息系统正确设计原理的文献，包括模板的研究，并且熟悉实体框架，我决定对数据库本身和应用程序进行全面的重构。 如果我完全完成了第一个任务，那么在执行第二个任务时，有两条路要走不同的方向：要么完全学习.net，C＃和Entity Framework，要么为熟悉的Lazarus系统找到合适的ORM。 还有第三条，第一条不起眼的自行车道-编写适合您自己需要的ORM，但这不是重点。 <br><br> 框架的源代码评论不多，但是开发人员仍然准备了一定数量的文档（显然是在开发的初期）。 当然，所有这些都是讲英语的，经验表明，尽管有大量的代码，图表和模板编程短语，但是许多说俄语的程序员在英语文档中仍然缺乏导向。 并非总是，并非每个人都希望训练他们理解英语技术文本的能力，而无需将其翻译成俄语。 <br><br> 此外，对译文进行反复校对可让您了解我第一次见到文档时错过的内容，但我并不完全理解或理解不正确。 也就是说，这本身就是一个更好地学习所研究框架的机会。 <br><br>  2.在文档中，作者有意或无意跳过了一些代码，这在他看来可能很明显。 由于其编写的局限性，该文档使用了过时的机制和对象作为示例，已被删除或在新版本的框架中不再使用（我不是说它本身会继续发展吗？）。 另外，当我自己重复开发的示例时，我发现了一些应该修复的错误。 因此，在一些地方，我不仅允许自己翻译文本，还允许我对其进行补充或修订，以使文本保持相关性，并且示例在起作用。 <br><br> 我想从彼得·亨里克森（Peter Henrikson）的一篇文章开始翻译材料，该文章涉及整个框架所代表的第一个“鲸鱼”-访客模板。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原文发表在这里</a> 。 <br><br><h2> 访客和tiOPF模板 </h2><br> 本文的目的是介绍Visitor模板，该模板的使用是tiOPF（TechInsite对象持久性框架）框架的主要概念之一。 在使用“访问者”之前，分析其他解决方案之后，我们将详细考虑该问题。 在发展我们自己的访客概念的过程中，我们将面临另一个挑战：需要遍历集合中的所有对象。 这个问题也将被研究。 <br><br> 主要任务是想出一种通用的方法来对集合中的某些对象执行一组相关的方法。 所执行的方法可能会根据对象的内部状态而有所不同。 我们根本不能执行方法，但是可以在同一个对象上执行多个方法。 <br><br><h3> 必要的培训水平 </h3><br> 读者应该熟悉对象Pascal，并掌握面向对象编程的基本原理。 <br><br><h3> 本文中的示例业务任务 </h3><br> 例如，我们将开发一个通讯录，使您可以创建人员及其联系信息的记录。 随着人与人之间可能的交流方式的增加，应用程序应灵活地允许您添加此类方法而无需进行大量代码处理（我记得一旦完成了添加电话号码的代码处理，我立即需要再次对其进行处理以添加电子邮件）。 我们需要提供两类地址：真实地址，例如家庭住址，邮政，工作地址和电子地址：座机电话，传真，移动电话，电子邮件，网站。 <br><br> 在表示级别上，我们的应用程序应类似于Explorer / Outlook，即应该使用标准组件，例如TreeView和ListView。 该应用程序应该可以快速运行，并且不会给人以庞大的客户端-服务器软件的印象。 <br><br> 应用程序可能看起来像这样： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18a/fa8/773/18afa8773d4df14f7c08b3e4ae5ec204.png"><br><br> 在树的上下文菜单中，您可以选择添加/删除个人或公司的联系人，然后右键单击联系人数据列表以打开一个对话框来编辑他们，删除或添加数据。 <br><br> 数据可以以各种形式保存，将来我们将考虑如何使用此模板来实现此功能。 <br><br><h3> 开始之前 </h3><br> 我们将从对象的简单集合开始-依次具有两个属性的人的列表-名称（名称）和地址（EmailAdrs）。 首先，该列表将在构造函数中填充数据，然后从文件或数据库加载。 当然，这是一个非常简化的示例，但是足以完全实现Visitor模板。 <br><br> 创建一个新的应用程序，并添加主模块的接口部分的两类：TPersonList（从TObjectList继承，并且需要连接使用的contnrs模块）和TPerson（从TObject继承）： <br><br><pre><code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList)  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;  <span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject)  <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>    FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;    FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;    <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs;  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 在TPersonList构造函数中，我们创建三个TPerson对象并添加到列表中： <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; lData := TPerson.Create; lData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> := <span class="hljs-string"><span class="hljs-string">'Malcolm Groves'</span></span>; lData.EMailAdrs := <span class="hljs-string"><span class="hljs-string">'malcolm@dontspamme.com'</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// (ADUG Vice President) Add(lData); lData := TPerson.Create; lData.Name := 'Don MacRae';  // (ADUG President) lData.EMailAdrs := 'don@dontspamme.com'; Add(lData); lData := TPerson.Create; lData.Name := 'Peter Hinrichsen';  // (Yours truly) lData.EMailAdrs := 'peter_hinrichsen@dontspamme.com'; Add(lData); end;</span></span></code> </pre> <br> 首先，我们将遍历列表，并对列表的每个元素执行两项操作。 操作类似，但不相同：一个简单的ShowMessage调用以显示TPerson对象的Name和EmailAdrs属性的内容。 在表单中添加两个按钮，并将其命名为： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/201/819/5ce/2018195cee6acbb2348e3ceb78abeaea.png"><br><br> 在表单的首选范围内，还应该添加TPersonList类型的属性（或仅是字段）FPersonList（如果在表单下方声明了该类型，请更改顺序或进行初步的类型声明），然后在onCreate事件处理程序中调用构造函数： <br><br><pre> <code class="delphi hljs">FPersonList := TPersonList.Create;</code> </pre> <br> 为了正确释放窗体的onClose事件处理程序中的内存，必须销毁此对象： <br><br><pre> <code class="delphi hljs">FPersonList.Free.</code> </pre> <br><h3> 步骤1.硬编码迭代 </h3><br> 要显示TPerson对象的名称，请将以下代码添加到第一个按钮的onClick事件处理程序中： <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FPersonList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   ShowMessage(TPerson(FPersonList.Items[i]).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 对于第二个按钮，处理程序代码如下： <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FPersonList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   ShowMessage(TPerson(FPersonList.Items[i]).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 这是此代码的明显选项： <br><br><ul><li> 两种方法几乎可以完成相同的操作。 所有区别仅在于它们显示的对象的属性名称； <br></li><li> 迭代将是乏味的，尤其是当您被迫在代码的一百个地方编写类似的循环时； <br></li><li> 对TPerson的强硬选择充满了特殊情况。 如果列表中有一个TAnimal实例而没有address属性怎么办？ 在此代码中，没有机制可以阻止错误并加以防御。 <br></li></ul><br> 让我们弄清楚如何通过引入抽象来改进代码：我们将迭代器代码传递给父类。 <br><br><h3> 步骤2.抽象迭代器 </h3><br> 因此，我们希望将迭代器逻辑移至基类。 列表迭代器本身非常简单： <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">// -    …</span></span></code> </pre> <br> 听起来我们正在计划使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Iterator</a>模板。 从《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">四方设计模式》一书中</a>可以知道，迭代器可以是内部的，也可以是内部的。 使用外部迭代器时，客户端通过调用Next方法显式控制遍历（例如，TCollection元素的枚举由First，Next，Last方法控制）。 我们将在这里使用内部迭代器，因为通过它的帮助更容易实现树遍历，这是我们的目标。 我们将Iterate方法添加到列表类中，并将回调方法传递给它，该方法必须在列表的每个元素上执行。 对象pascal中的回调被声明为过程类型，例如，我们将拥有TDoSomethingToAPerson。 <br><br> 因此，我们声明了一个过程类型TDoSomethingToAPerson，它采用一个类型为TPerson的参数。 程序类型允许您将方法用作另一个方法的参数，即实现回调。 这样，我们将创建两个方法，一个方法将显示对象的Name属性，另一个方法-EmailAdrs属性，它们本身将作为参数传递给常规迭代器。 最后，类型声明部分应如下所示： <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TPerson }</span></span> <span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TDoSomethingToAPerson = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">{ TPersonList }</span></span> <span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function">   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pMethod: TDoSomethingToAPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;   DoSomething: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pMethod: TDoSomethingToAPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   pMethod(TPerson(Items[i])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 现在，要对列表项执行必要的操作，我们需要做两件事。 首先，使用具有由TDoSomethingToAPerson指定的签名的方法来定义必要的操作，其次，使用指向作为参数传递的这些方法的指针编写DoSomething调用。 在表单描述部分，添加两个声明： <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FPersonList: TPersonList;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br> 在这些方法的实现中，我们指出： <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(pData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(pData.EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 按钮处理程序的代码更改如下： <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FPersonList.DoSomething(@DoShowName); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FPersonList.DoSomething(@DoShowEmail); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 已经更好了。 现在，我们的代码中具有三个抽象级别。 通用迭代器是实现对象集合的类的方法。 业务逻辑（到目前为止只是通过ShowMessage输出无尽的消息）被分开放置。 在表示（图形界面）级别，业务逻辑在一行中被调用。 <br><br> 很难想象如何用代码替换ShowMessage的调用，该代码使用TQuery对象的SQL查询将TPerson中的数据保存在关系数据库中。 例如，像这样： <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SavePerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lQuery: TQuery; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lQuery := TQuery.Create(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   lQuery.SQL.Text := <span class="hljs-string"><span class="hljs-string">'insert into people values (:Name, :EMailAdrs)'</span></span>;   lQuery.ParamByName(<span class="hljs-string"><span class="hljs-string">'Name'</span></span>).AsString := pData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>;   lQuery.ParamByName(<span class="hljs-string"><span class="hljs-string">'EMailAdrs'</span></span>).AsString := pData.EMailAdrs;   lQuery.Datababase := gAppDatabase;   lQuery.ExecSQL; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lQuery.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 顺便说一句，这引入了维护数据库连接的新问题。 在我们的请求中，通过某些全局gAppDatabase对象执行与数据库的连接。 但是它将位于何处以及如何工作？ 此外，在迭代器的每一步中，我们都会痛苦地创建TQuery对象，配置连接，执行查询，并且不要忘记释放内存。 最好将这些代码包装在一个类中，该类封装了创建和执行SQL查询以及建立和维护与数据库的连接的逻辑。 <br><br><h3> 步骤3.传递对象而不是将指针传递给回调 </h3><br> 将对象传递给基类的迭代器方法将解决状态维护的问题。 我们将使用单个Execute方法创建抽象的Visitor类TPersonVisitor，并将对象作为参数传递给此方法。 抽象的Visitor界面如下所示： <br><br><pre> <code class="delphi hljs">  <span class="hljs-title"><span class="hljs-title">TPersonVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 接下来，将Iterate方法添加到我们的TPersonList类中： <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TPersonVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 此方法的实现如下： <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TPersonVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   pVisitor.Execute(TPerson(Items[i])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  TPersonVisitor类的已实现Visitor的对象被传递给Iterate方法，并且在遍历每个项目的列表项时，将以TPerson实例作为参数调用指定的Visitor（其execute方法）。 <br><br> 让我们创建Visitor的两个实现-TShowNameVisitor和TShowEmailVistor，它们将执行所需的工作。 以下是补充模块接口部分的方法： <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TShowNameVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TShowNameVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersonVisitor) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TShowEmailVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TShowEmailVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersonVisitor) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 为了简单起见，在它们上执行方法的实现仍将是一行-ShowMessage（pPerson.Name）和ShowMessage（pPerson.EMailAdrs）。 <br><br> 并更改按钮单击处理程序的代码： <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lVis: TPersonVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lVis := TShowNameVisitor.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   FPersonList.Iterate(lVis); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lVis.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lVis: TPersonVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lVis := TShowEmailVisitor.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   FPersonList.Iterate(lVis); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lVis.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 现在，解决了一个问题，我们为自己创造了另一个。 迭代器逻辑封装在单独的类中； 迭代过程中执行的操作都包装在对象中，这使我们可以保存一些有关状态的信息，但是代码的大小已从一行（FPersonList.DoSomething（@DoShowName））增长到每个按钮处理程序的九行。现在它将为我们提供帮助-这是访客管理器，它将负责创建和释放其副本。可能的是，我们可以提供一些在迭代过程中要执行的对象操作，为此，访客管理器将存储其列表并在每个步骤中进行遍历，您可以  。Olnyaya只有选择的操作接下来将清楚地表明了这种做法的好处，我们将使用游人数据在关系数据库中保存为一个简单的数据保存操作可以通过三种不同的运营商的SQL进行：创建，删除和升级。 <br><br><h3> 步骤4.进一步封装访问者 </h3><br> 在继续之前，我们必须封装来访者工作的逻辑，将其与应用程序的业务逻辑分开，以使它不会返回。 为此，将需要三个步骤：创建基类TVisited和TVisitor，然后创建业务对象的基类和业务对象的集合，然后稍微调整我们的特定类TPerson和TPersonList（或TPeople），使它们成为已创建基类的继承人类。 一般而言，类的结构将与以下图表相对应： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bb/f5e/b62/8bbf5eb6201de628050d085c061fe800.png"><br><br>  TVisitor对象实现两种方法：AcceptVisitor函数和Execute过程，将TVisited类型的对象传递到其中。  TVisited对象又使用TVisitor类型的参数实现Iterate方法。 也就是说，TVisited.Iterate必须在传输的TVisitor对象上调用Execute方法，并发送到其自身实例的链接作为参数，如果实例是一个集合，则将为集合中的每个元素调用Execute方法。 由于我们正在开发通用系统，因此AcceptVisitor功能是必需的。 例如，可以将访问者传递给仅使用TPerson类型进行操作的Visitor，例如TDog类的实例，并且必须具有一种机制来防止由于类型不匹配而引起的异常和访问错误。  TVisited类是TPersistent类的后代，因为稍后我们将需要实现与RTTI使用相关的功能。 <br><br> 模块的接口部分现在将如下所示： <br><br><pre> <code class="delphi hljs">TVisited = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TVisited }</span></span> <span class="hljs-title"><span class="hljs-title">TVisited</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersistent) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  TVisitor抽象类的方法将由继承人实现，而TVisited的Iterate方法的一般实现如下所示： <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisited</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> pVisitor.Execute(self); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 同时，该方法被声明为虚拟方法，因为它有可能在继承人中被覆盖。 <br><br><h3> 步骤5.创建一个共享的业务对象和集合 </h3><br> 我们的框架还需要另外两个基类：定义业务对象和此类对象的集合。 将它们称为TtiObject和TtiObjectList。 其中第一个的界面： <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiObject</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisited) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 在开发过程的后期，我们将使此类复杂化，但是对于当前任务，仅一个虚拟构造函数就可以在继承者中覆盖它。 <br><br> 我们计划从TVisited生成TtiObjectList类，以便在祖先已经实现的方法中使用该行为（还有其他继承原因，将在其位置进行讨论）。 另外，没有什么禁止使用<abbr title="作者尚未在手册中实现带有接口的部分，因为这篇文章写于90年代，并且尚未在FreePascal中使用它们的mod。">接口</abbr> （接口）而不是抽象类。 <br><br>  TtiObjectList类的接口部分如下： <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiObjectList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FList: TObjectList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pData: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 如您所见，带有对象元素的容器本身位于protected部分中，并且此类客户无法使用。 该类最重要的部分是重写Iterate方法的实现。 如果在基类中该方法简单地称为pVisitor.Execute（self），则此处的实现与枚举列表有关： <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiObjectList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Iterate(pVisitor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   (FList.Items[i] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TVisited).Iterate(pVisitor); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 其他类方法的实现只需一行代码，而无需考虑自动放置的继承表达式： <br><br><pre> <code class="delphi hljs">Create: FList := TObjectList.Create; Destroy: FList.Free; Clear: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FList) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FList.Clear; Add: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FList) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FList.Add(pData);</code> </pre> <br> 这是整个系统的重要组成部分。 我们有两个基本的业务逻辑类：TtiObject和TtiObjectList。 两者都具有Itisiate方法，将TVisited类的实例传递给该方法。 迭代器本身调用TVisitor类的Execute方法，并将其引用传递给对象本身。 该调用是在继承的顶级类行为中预定义的。 对于容器类，列表中存储的每个对象还具有其Iterate方法，该方法使用TVisitor类型的参数调用，即确保每个特定的Visitor将绕过列表中存储的所有对象以及列表本身作为容器对象。 <br><br><h3> 步骤6.创建访客经理 </h3><br> 因此，回到我们自己在第三步中提出的问题。 由于我们不想每次都创建和销毁访问者的副本，因此管理器的开发将是解决方案。 它应该执行两个主要任务：管理访问者列表（已在各个模块的初始化部分中进行了相应注册），并在访问者收到来自客户端的适当命令后运行它们。 <br> 为了实现管理器，我们将在模块中添加三个附加类：TVisClassRef，TVisMapping和TtiVisitorManager。 <br><br><pre> <code class="delphi hljs">TVisClassRef = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TVisitor;</code> </pre> <br>  TVisClassRef是一种引用类型，它指示特定类的名称-TVisitor的后代。 使用引用类型的含义如下：当调用带有签名的基本Execute方法时 <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TVisited; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pVisClass: TVisClassRef)</span></span></span><span class="hljs-function">,</span></span></code> </pre> <br> 在内部，此方法可以使用类似lVisitor：= pVisClass.Create的表达式来创建特定Visitor的实例，而无需先了解其类型。 也就是说，当将其类的名称作为参数传递时，可以在同一Execute方法内动态创建任何类-TVisitor的后代。 <br><br> 第二类TVisMapping是具有两个属性的简单数据结构：对TVisClassRef类型的引用和字符串属性Command。 需要一个类来比较按其名称执行的操作（一个命令，例如“ save”）和这些命令执行的Visitor类。 将其代码添加到项目中： <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TVisMapping</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FCommand: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FVisitorClass: TVisClassRef; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> VisitorClass: TVisClassRef <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FVisitorClass <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FVisitorClass;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Command: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FCommand <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FCommand; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 最后一个类是TtiVisitorManager。 当我们使用Manager注册Visitor时，将创建TVisMapping类的实例，该实例输入到Manager列表中。 <br> 因此，在管理器中，使用匹配的字符串命令创建了访问者列表，接收到访问者列表后将执行访问者列表。 类接口已添加到模块中： <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiVisitorManager</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FList: TObjectList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pVisitorClass: TVisClassRef)</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pData: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 它的关键方法是RegisterVisitor和Execute。 通常在模块的初始化部分中调用第一个，它描述了Visitor类，并且看起来像这样： <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">initialization</span></span>  gTIOPFManager.VisitorManager.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, TShowNameVisitor);  gTIOPFManager.VisitorManager.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, TShowEMailAdrsVisitor);</code> </pre> <br> 该方法本身的代码如下： <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiVisitorManager</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pVisitorClass: TVisClassRef)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lData: TVisMapping; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lData := TVisMapping.Create; lData.Command := pCommand; lData.VisitorClass := pVisitorClass; FList.Add(lData); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 不难看出，此代码与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Factory</a>模板的Pascal实现非常相似。 <br><br> 另一个重要的Execute方法接受两个参数：用于标识访问者或其身份的命令，以及将调用Iterate方法并带有指向所需访问者实例的链接的数据对象。  Execute方法的完整代码如下： <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiVisitorManager</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pData: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lVisitor: TVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> SameText(pCommand, TVisMapping(FList.Items[i]).Command) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>     lVisitor := TVisMapping(FList.Items[i]).VisitorClass.Create;     <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>       pData.Iterate(lVisitor);     <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>       lVisitor.Free;     <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> 因此，要与一个团队一起运行两个先前注册的访客，我们只需要一行代码： <br><br><pre> <code class="delphi hljs">gTIOPFManager.VisitorManager.Execute(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, FPeople);</code> </pre> <br> 接下来，我们将补充我们的项目，以便您可以调用类似的命令： <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//      gTIOPFManager.VisitorManager.Execute('read', FPeople); //      gTIOPFManager.VisitorManager.Execute('save', FPeople).</span></span></code> </pre> <br><h3> 步骤7.调整业务逻辑类 </h3><br> 为TPerson和TPeople业务对象添加TtiObject和TtiObjectList类的祖先，将使我们可以将迭代器逻辑封装在基类中，而不再需要接触它，此外，还可以将带有数据的对象传输到Visitor Manager。 <br><br> 新的容器类声明将如下所示： <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPeople</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObjectList);</code> </pre> <br> 实际上，TPeople类甚至不需要实现任何东西。 从理论上讲，我们可以完全不用TPeople声明，而是将对象存储在TtiObjectList类的实例中，但是由于我们计划编写仅处理TPeople实例的Visitor，因此需要此类。 在AcceptVisitor函数中，将执行以下检查： <br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPeople.</code> </pre> <br> 对于TPerson类，我们添加TtiObject祖先，并将两个现有属性移至已发布的范围，因为将来我们将需要通过RTTI使用这些属性。 正是在此之后，它将大大减少映射关系数据库中的对象和记录所涉及的代码： <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">published</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><h3> 步骤8.创建一个原型视图 </h3><br>  <b><i>备注</i></b> 。 在原始文章中，GUI基于tiOPF作者为方便使用其delphi框架而制作的组件。 这些是DB Aware组件的类似物，它们是标准控件，例如标签，输入字段，复选框，列表等，但是与tiObject对象的某些属性相关联，其方式与将数据显示组件与数据库表中的字段相关联的方式相同。 随着时间的流逝，框架的作者用这些视觉组件将软件包标记为过时和不受欢迎的。                 (Mediator).          .       ,      ,      GUI    . <br><br>   1     « show»,   2     ,    « save».    memo-       . <br><br>   ,     «show»: <br><br>  — <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TShowVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisitor) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>   — <pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TShowVisitor</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := (pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPerson); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TShowVisitor</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; Form1.Memo1.Lines.Add(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> + <span class="hljs-string"><span class="hljs-string">': '</span></span> + TPerson(pVisited).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  AcceptVisitor ,      TPerson,         .   ,            . <br><br>       .       private   : FPeople  TPeople  VM  TtiVisitorManager.          ,       «show»: <br><br><pre> <code class="delphi hljs">FPeople := TPeople.Create; FillPeople; VM := TtiVisitorManager.Create; VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>,TShowVisitor);</code> </pre> <br> FilPeople —   ,    ,       .       .          FPeople.Free  VM.Free. <br><br>   — ! —   : <br><br><pre> <code class="delphi hljs">Memo1.Clear; VM.Execute(<span class="hljs-string"><span class="hljs-string">'show'</span></span>,FPeople);</code> </pre> <br> ,    .          .        . <br><br><h3>  9.   ,     </h3><br>        ,     .          :       ( AssignFile  ReadLn),    (TStringStream  TFileStream)    TStringList. <br><br>     ,        ,   .         ,      ,              .     TStringList,       — LoadFromFile  SaveToFile.  ,          ,         . <br><br>    TVisFile: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TVisFile</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisitor) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   FList: TStringList;   FFileName: TFileName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>     : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; FList := TStringList.Create; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FileExists(FFileName) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   FList.LoadFromFile(FFileName); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FList.SaveToFile(FFileName); FList.Free; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>   FFileName         (   ,    ,     !).   ,   ,  : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/717/969/104/717969104d4b13d73ba1844fe0c2ddf9.png"><br><br>            TVisFile: TVisTXTFile  TVisCSVFile.      *.csv,       (),  —   ,          .         : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FFileName := <span class="hljs-string"><span class="hljs-string">'contacts.csv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXTFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FFileName := <span class="hljs-string"><span class="hljs-string">'contacts.txt'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br><h3>  10.  -   </h3><br>      ,     ,    .        AcceptVisitor  Execute. AcceptVisitor ,      TPeople: <br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPeople;</code> </pre> <br>  execute   : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXtRead</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-comment"><span class="hljs-comment">//==&gt; TPeople(pVisited).Clear; for i := 0 to FList.Count - 1 do begin   lData := TPerson.Create;   lData.Name := Trim(Copy(FList.Strings[i], 1, 20));   lData.EMailAdrs := Trim(Copy(FList.Strings[i], 21, 80));   TPeople(pVisited).Add(lData); end; end;</span></span></code> </pre> <br>      TPeople,   ,       TStringList,     ,      TPerson       TPeople.    name  emailadrs     . <br><br>     .   ()   TStringList (..   FList.Clear;     inherited), AcceptVisitor ,     TPerson,    ,         .  ,     —    ,    StringList      .    ,             ,         ,    .        SQL     ,    (,   ).         ,      : <br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Tperson;</code> </pre> <br>  execute     StringList ,    :    name  ,     20 ,    emaiadrs: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXTSave</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; FList.Add(PadRight(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>)+PadRight(TPerson(pVisited).EMailAdrs,<span class="hljs-number"><span class="hljs-number">60</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><h3>  11.  - CSV- </h3><br>            TXT        :   CSV    .            ExtractDelimited   strutils,      : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVRead</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; TPeople(pVisited).Clear; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>   lData := TPerson.Create;   lData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> := ExtractDelimited(<span class="hljs-number"><span class="hljs-number">1</span></span>, FList.Strings[i], [<span class="hljs-string"><span class="hljs-string">','</span></span>]);   lData.EMailAdrs := ExtractDelimited(<span class="hljs-number"><span class="hljs-number">2</span></span>, FList.Strings[i], [<span class="hljs-string"><span class="hljs-string">','</span></span>]);   TPeople(pVisited).Add(lData); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVSave</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; FList.Add(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> + <span class="hljs-string"><span class="hljs-string">','</span></span> + TPerson(pVisited).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br> ,   ,          .       : <br><br><pre> <code class="delphi hljs">VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'readTXT'</span></span>, TVisTXTRead); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'saveTXT'</span></span>,TVisTXTSave); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'readCSV'</span></span>,TVisCSVRead); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'saveCSV'</span></span>,TVisCSVSave);</code> </pre> <br>          : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/112/0c2/7c3/1120c27c31300af40162387ac222d33c.png"><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadCSVbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'readCSV'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadTXTbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'readTXT'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveCSVbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'saveCSV'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveTXTbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'saveTXT'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>                .      :     -,   saveTXT  saveCSV.         save,       ,   . <br><br><h3>  12.    </h3><br>      ,           ,             .             ,         (       uses ): <br><br><table><tbody><tr><td>  <br></td><td>  <br></td><td>  <br></td></tr><tr><td> tivisitor.pas <br></td><td>       <br></td><td> TVisitor <br> TVisited <br> TVisMapping <br> TtiVisitorManager <br></td></tr><tr><td> tiobject.pas <br></td><td>   - <br></td><td> TtiObject <br> TtiObjectList <br></td></tr><tr><td> people_BOM.pas <br></td><td>   - <br></td><td> TPerson <br> TPeople <br></td></tr><tr><td> people_SRV.pas <br></td><td>  ,    <br></td><td> TVisFile <br> TVisTXTFile <br> TVisCSVFile <br> TVisCSVSave <br> TVisCSVRead <br> TVisTXTSave <br> TVisTXTRead <br></td></tr></tbody></table><br><h3> 结论 </h3><br>           ,     .    ,  GoF,              .             .       ,   ,             . <br><br> <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">     — </a></b></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441266/">https://habr.com/ru/post/zh-CN441266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN441254/index.html">研讨会“为什么我们要与Kubernetes保持联系以及我们从中获得什么”，2月28日，莫斯科</a></li>
<li><a href="../zh-CN441258/index.html">在Linux上使用eBPF和bpftrace的全功能动态跟踪</a></li>
<li><a href="../zh-CN441260/index.html">神经网络图形如何提供帮助</a></li>
<li><a href="../zh-CN441262/index.html">简单和长期的任务比短期和复杂的任务更能淘汰候选人</a></li>
<li><a href="../zh-CN441264/index.html">Kibana用户指南。 可视化。 第二部分</a></li>
<li><a href="../zh-CN441268/index.html">Ceedling + Eclipse或微控制器的单元测试</a></li>
<li><a href="../zh-CN441270/index.html">首先看一下苹果的FoundationDB</a></li>
<li><a href="../zh-CN441274/index.html">如何成为测试员-必要的知识和技能</a></li>
<li><a href="../zh-CN441278/index.html">如何创建漂亮的调色板</a></li>
<li><a href="../zh-CN441280/index.html">Zimbra Collaboration Suite中的GAL设置</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>