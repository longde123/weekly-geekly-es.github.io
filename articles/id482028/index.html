<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”Š ğŸ™‡ğŸ¾ ğŸ™‡ Dua tombol merah, besi solder dan React: bagaimana kami membuat langkah untuk konferensi IT ğŸ¼ ğŸš¶ğŸ¿ ğŸ˜³</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badoo secara teratur berpartisipasi dengan stan dalam pameran konferensi TI. Karena itu, setiap tahun, kami, bersama kolega - insinyur dan devrels - d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dua tombol merah, besi solder dan React: bagaimana kami membuat langkah untuk konferensi IT</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/482028/"><p>  Badoo secara teratur berpartisipasi dengan stan dalam pameran konferensi TI.  Karena itu, setiap tahun, kami, bersama kolega - insinyur dan devrels - datang dengan sesuatu untuk melakukan hal yang baik sehingga tidak bosan di sela-sela laporan. </p><br><p>  Nama saya Ivan, saya pengembang frontend.  Dalam artikel ini, bersama dengan kolega kami dan penggemar DIY <a href="https://habr.com/ru/users/lilek/" class="user_link">lilek,</a> Yura Lilekov, kami akan memberi tahu Anda bagaimana, menggunakan dua tombol merah, satu mikrokontroler, kode Bereaksi dan 250 kata untuk topik-topik TI, kami membuat game "IT guessing game" dan membuat hangout yang nyaman di Highload ++ dan Heisenbug. </p><br><p><img src="https://habrastorage.org/webt/op/k9/r9/opk9r9az9g7eovtbqkgcra83ntm.png"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Konten: </h1><br><p>  <a href="https://habr.com/ru/company/badoo/blog/482028/">TK nontrivial</a> <br>  <a href="https://habr.com/ru/company/badoo/blog/482028/">Mekanika game dan penilaian</a> <br>  <a href="https://habr.com/ru/company/badoo/blog/482028/">Animasi</a> <br>  <a href="https://habr.com/ru/company/badoo/blog/482028/">Frontend</a> <br>  <a href="https://habr.com/ru/company/badoo/blog/482028/">Perangkat keras: dua tombol merah</a> <br>  <a href="https://habr.com/ru/company/badoo/blog/482028/">Hasil</a> </p><br><h1 id="netrivialnoe-tz">  TK nontrivial </h1><br><p>  Konferensi IT memiliki atmosfer mereka sendiri: ada banyak orang, tidak mudah untuk menangkap dan mempertahankan perhatian mereka di mimbar.  Agar mereka datang kepada kami secara tepat di sela-sela laporan, kami perlu memberi mereka pelajaran yang menarik tetapi tidak rumit. </p><br><p>  Terinspirasi oleh keberhasilan alias TI tahun lalu, kami merumuskan persyaratan berikut untuk permainan baru: </p><br><ul><li>  Itu harus multi-pengguna.  Komunikasi para peserta adalah tugas utama.  Kita tahu bahwa banyak yang datang sendirian dan tidak selalu mudah memulai percakapan dengan orang asing.  Permainan harus memberi kesempatan untuk berbicara satu sama lain dan dengan insinyur Badoo. </li><li>  Sesi harus singkat.  Mungkin ada satu hingga tiga ribu orang di konferensi, dan kami ingin menjangkau sebanyak mungkin peserta. </li><li>  Gamenya harus spektakuler.  Jika seseorang tidak berpartisipasi dalam permainan, maka biarkan dia setidaknya menontonnya.  Bunga ini menarik, membantu untuk memahami esensi dan memutuskan untuk berpartisipasi. </li><li>  Manajemen yang paling sederhana.  Seperti kita semua tahu, jika sesuatu bisa pecah, maka itu pasti akan pecah. </li><li>  Tanpa registrasi dan SMS! </li></ul><br><p>  Setelah melakukan brainstorming, berpikir dalam mimpi dan mencoba mendapatkan inspirasi, kami menemukan "IT Guessing Game" - permainan sederhana dengan kata-kata tentang topik-topik TI. </p><br><p><img src="https://habrastorage.org/webt/8r/p4/5f/8rp45fdtczsizalimesfrnb9kc4.jpeg"></p><br><p>  Apa inti dari: </p><br><ul><li>  dua peserta bermain secara bersamaan. </li><li>  Tugasnya adalah menekan tombol lebih cepat dari lawan dan menebak kata terenkripsi yang ditampilkan di layar. </li><li>  Dua tahap: sederhana ("Pintasan"), di mana kata-kata ditulis kembali ke depan, dan yang sulit ("Pengaduk"), di mana semua huruf dalam kata-kata dicampur. </li><li>  Jika jawabannya benar, satu poin dihitung ke responden.  Salah - skor jatuh ke lawan. </li><li>  Mereka yang mencetak setidaknya N poin dapat berpartisipasi dalam pengundian headphone yang membatalkan kebisingan keren. </li></ul><br><p>  Tampaknya semuanya cukup mudah dan sederhana, tetapi kesulitan ada di depan. </p><br><h1 id="mehanika-igry-i-podschyot-ballov">  Mekanika game dan penilaian </h1><br><p><img src="https://habrastorage.org/webt/wf/vr/e_/wfvre_npwrjlh4duabj8kkxb6og.gif"></p><br><p>  Dari gif ini, cukup jelas seperti apa proses putarannya: </p><br><ol><li>  Kata terenkripsi muncul. </li><li>  Timer mulai selama 10 detik. </li><li>  Jika salah satu pemain menekan tombol, maka penghitung waktu ini berhenti, dan yang lain akan mulai - selama 3 detik.  Selama waktu ini, pemain harus diberi jawaban, jika tidak skor akan diberikan kepada lawan. </li><li>  Jika tidak ada yang menekan tombol, kata akan berubah secara otomatis, dan seluruh proses diulangi lagi. </li></ol><br><p>  Masalah utama yang kami hadapi adalah bagaimana menjaga skor dan merekam pemain.  Kami ingin membuat game secepat mungkin dan tidak memaksa peserta untuk mendaftar di mana saja.  Tapi itu perlu untuk memahami mana dari mereka yang mencetak sejumlah poin dan dapat menerima hadiah utama. </p><br><p>  Kami tidak menemukan mekanika perhitungan pertama kali.  Hanya setelah beberapa tes, menjadi jelas bagaimana membuat game ini nyaman dan sederhana - baik untuk para peserta dan untuk tuan rumah. </p><br><h2 id="provalnye-i-genialnye-idei">  Gagasan yang gagal dan cemerlang </h2><br><h3 id="ideya-1-odin-ball--odna-malenkaya-shokoladka">  Gagasan # 1: satu poin = satu batang cokelat kecil </h3><br><p>  Untuk setiap jawaban yang benar, pada awalnya kami memutuskan untuk memberikan satu batang cokelat.  Pada akhirnya, peserta membawa cokelat (atau setidaknya bungkus permen dari "poin" yang dimakan), dan hanya itu!  Kami menghitung piala, kami mengenali pemenangnya. </p><br><p>  Tetapi ada beberapa poin. </p><br><p>  Pertama: tidak nyaman.  Ternyata tidak mungkin untuk memoderasi permainan dan secara bersamaan menghitung poin, asisten kedua diperlukan.  Ini terlalu mahal dalam hal kekuatan dan waktu orang-orang di stan.  Dan mengingat kecepatan permainan, saya harus benar-benar melempar cokelat kepada para peserta. </p><br><p>  Poin kedua - bagaimana membedakan cokelat saya dari cokelat orang lain?  Pemain bisa bekerja sama dan menumpuk cokelat atau pembungkus permen dari mereka.  Jadi, sirkuit tidak berfungsi!  Selain itu, konferensi berlangsung selama dua hari, dan Anda dapat mengumpulkan cokelat tanpa henti. </p><br><p>  Poin ketiga: Anda membutuhkan terlalu banyak cokelat.  Kami secara eksperimental memeriksa berapa poin skor pemain rata-rata, dan menyadari bahwa setidaknya sebuah kereta membutuhkan cokelat.  Dan kami hanya memiliki kereta kecil. </p><br><p><img src="https://habrastorage.org/webt/1h/j_/8z/1hj_8zp8amb6-taaowqum3y54gm.jpeg"></p><br><h3 id="ideya-2-turnirnaya-tablica">  Gagasan # 2: klasemen </h3><br><p>  Sementara beberapa bermain, yang lain akan merekam diri mereka di klasemen.  Dalam hal ini, kami akan menghadapi semua masalah yang mungkin terjadi: nama, nama, kesalahan penulisan, penulisan tidak terbaca (atau kebutuhan untuk menempatkan monitor besar dan laptop untuk input), keengganan untuk meninggalkan kontak Anda, dan banyak lagi. </p><br><p>  Karena itu, kami terus mencari. </p><br><h3 id="ideya-3-otmetki-na-beydzhah-uchastnikov">  Gagasan # 3: tanda pada lencana peserta </h3><br><p>  Untuk menghilangkan masalah mendaftar pemain, kami menggunakan solusi siap pakai: lencana yang dibagikan kepada semua peserta.  Ini adalah sesuatu yang tidak akan ada yang kalah dan yang dimiliki setiap peserta.  Kami memutuskan untuk menulis akun langsung kepada mereka.  Peserta datang ke penghitungan, melihat lencana, menghitung poin dan menentukan pemenang.  Tetapi ada juga kelemahan dalam skema ini: para pemain bisa "memalsukan" skor akhir pada lencana mereka. </p><br><p>  Kemudian kami benar-benar meninggalkan ide untuk mencatat skor.  Biarkan mereka yang mendapatkan nilai ambang poin menerima tanda khusus di lencana - cap dalam bentuk hati kita - bahwa mereka melewati lingkaran "yang terpilih".  Dan di antara para peserta ini kami akan secara acak menarik hadiah utama.  Dan sisanya masih akan menerima hadiah: stiker, buku catatan, pemegang kartu, dan pembuat keputusan kami. </p><br><p><img src="https://habrastorage.org/webt/_m/hz/u7/_mhzu7f8w8nizwmtpq57u-zdew4.jpeg" alt="Tentu saja, karyawan Badoo tidak berpartisipasi dalam pemberian."><br>  <em>Tentu saja, karyawan Badoo tidak berpartisipasi dalam pemberian.</em> </p><br><p>  Skemanya adalah sebagai berikut: </p><br><ol><li>  Seorang tamu ditandai pada lencana dengan tanda partisipasi: hitam untuk mencapai 20 poin atau ungu hanya untuk bermain.  Tiga upaya dapat dilakukan sehari dan tiga hati diperoleh. </li><li>  Semua pemenang dengan tanda hitam berkumpul pada waktu tertentu di stand, dan dengan bantuan drum lotre tabung hangat kami memainkan headphone di antara mereka. </li></ol><br><p><img src="https://habrastorage.org/webt/gd/ui/bn/gduibngslf724dhlrpftt2ivxua.png"></p><br><p>  Setelah menguji permainan pada orang yang hidup, kami menghitung tanda ambang: untuk mencetak 20 poin dalam permainan itu tidak mudah.  Tetapi dalam setiap dua hari Highload ++, sekitar 15 orang adalah pemenangnya! </p><br><p>  Benar, dalam daftar kata ada beberapa istilah yang dipahami pertama-tama oleh pengembang, jadi untuk konferensi QA Heisenbug kami sepakat pada ambang batas 15 poin.  Mungkin sia-sia: semifinalis ternyata berkali-kali lebih banyak, yang berarti ada lebih sedikit peluang untuk memenangkan headphone. </p><br><p>  PS Pada tahap awal, kami memutuskan bahwa dengan jawaban yang salah, peserta akan kehilangan skor cokelat.  Tapi tidak ada yang suka dirampok sesuatu.  â€œIni cokelat batangan saya, saya mendapatkannya!â€ - penguji permainan pertama marah.  Karena itu, sebagai penalti, kami mulai memberi poin pada lawan. </p><br><p><img src="https://habrastorage.org/webt/ry/yo/y5/ryyoy50ox1-o3zo-hyth8bae_pc.jpeg"></p><br><h1 id="animaciya">  Animasi </h1><br><p>  Kata menebak harus muncul dengan semacam animasi.  Ini memberi kita dua keuntungan: </p><br><ol><li>  Semacam "pemukulan" di antara kata-kata.  Jauh lebih mudah bagi pemain untuk beralih dari satu kata ke kata lain jika ada tindakan di antara mereka.  Ingat game pertarungan lama.  Setiap babak baru dimulai dengan "3..2..1..FIGHT!".  Saya tidak ingin membuat timer lain di sini - kami sudah memilikinya secara massal. </li><li>  Variasi visual.  Kami mencoba membuat permainan sesederhana mungkin, kami tidak memiliki latar belakang animasi dan transisi antar level.  Kami juga tidak bisa menggunakan suara, sehingga tidak mengganggu peserta konferensi lainnya.  Karena itu, animasi diperlukan. </li></ol><br><p>  Dengan dia, tidak semuanya berjalan lancar dengan segera.  Pada uji coba, ada orang-orang licik yang tidak menunggu akhir animasi dan mengklik tombol sebelumnya.  Untuk mengajarkan triknya, kami mulai menghentikan kemunculan kata ketika salah satu pemain menekan tombol secara prematur.  Bagian kata yang belum sempat muncul, dalam hal ini tetap tersembunyi di balik karakter.  Apakah pemain menginginkannya atau tidak, dia harus menjawab.  Sulit menebak kata dengan beberapa huruf, sehingga lawan mendapat poin. </p><br><p>  Seperti apa kata itu jika Anda mengklik tombol sebelumnya: </p><br><p><img src="https://habrastorage.org/webt/nv/gy/cb/nvgycbadg6xh84ufckataq_izri.gif"></p><br><p>  Momen sulit kedua adalah durasi animasi.  Itu selalu berlangsung bersamaan - 1,5 detik.  Jika Anda "menangkap ritme", maka Anda bisa terbiasa menekan tombol lebih cepat dari lawan.  Untuk mengatasi masalah, kami menambahkan variabel acak yang dari 0 hingga 500 ms.  Dalam hal ini, menyesuaikan dengan ritme menjadi jauh lebih sulit. </p><br><h1 id="frontend">  Frontend </h1><br><p>  Saya akan menceritakan sedikit tentang bagian perangkat lunak.  Jika Anda tidak tertarik, langsung ke <a href="https://habr.com/ru/company/badoo/blog/482028/">kisah tentang bagaimana kami mencari tombol merah</a> . </p><br><p> Mekanik permainan ternyata cukup sederhana, dan saya tidak ingin menciptakan sepeda.  Mengambil <code>create-react-app</code> untuk sisi klien.  Namun tantangan itu tetap dibutuhkan. </p><br><p>  Jadi kait!  Hooks muncul di cakrawala sejak lama, tetapi aplikasi mereka di produk Badoo utama membutuhkan pemikiran ulang yang agak serius dari proses pengembangan.  Proyek sampingan kecil adalah batu loncatan besar untuk penggunaannya. </p><br><p>  Tidak ada redux!  Redux adalah hal yang hebat, dan kami menggunakannya dalam pekerjaan kami setiap hari.  Tetapi untuk aplikasi sekecil itu, menggunakan redux tidak dibenarkan.  Selain itu, ada hook <code>useContext</code> baru. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { score, changeScore } = useContext(SessionContext); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { next } = useContext(QuestionsContext); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> steps = useContext(StepsContext);</code> </pre> <br><p>  Ya, alih-alih cerita global, kami mendapat tiga konteks yang tidak bersinggungan sama sekali. </p><br><p>  <code>SessionContext</code> mencetak gol. <br>  <code>StepsContext</code> bertanggung jawab untuk mengganti layar aplikasi: intro, loop, outro ... <br>  <code>QuestionsContext</code> tahu semua tentang pertanyaan: mana yang dijawab, pertanyaan mana yang akan berikutnya, berapa banyak yang tersisa. </p><br><h2 id="provider">  Penyedia </h2><br><p>  Setiap konteks membutuhkan penyedia yang akan mengirimkan data ke komponen akhir.  Sebagai contoh, kami akan menggunakan penyedia sederhana untuk penilaian. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> increment = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">score</span></span></span><span class="hljs-function"> =&gt;</span></span> score + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SessionProvider = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [leftPlayerScore, changeLeftPlayerScore] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [rightPlayerScore, changeRightPlayerScore] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resetScore = useCallback(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { changeLeftPlayerScore(<span class="hljs-number"><span class="hljs-number">0</span></span>); changeRightPlayerScore(<span class="hljs-number"><span class="hljs-number">0</span></span>); }, []); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> changeScore = useCallback(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">player</span></span></span><span class="hljs-function"> =&gt;</span></span> { player === <span class="hljs-string"><span class="hljs-string">'left'</span></span> ? changeLeftPlayerScore(increment) : changeRightPlayerScore(increment); }, []); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> score = { <span class="hljs-attr"><span class="hljs-attr">left</span></span>: leftPlayerScore, <span class="hljs-attr"><span class="hljs-attr">right</span></span>: rightPlayerScore }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">SessionContext.Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">score</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">changeScore</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resetScore</span></span></span></span><span class="xml"><span class="hljs-tag"> }}&gt;</span></span></span><span class="xml"> {props.children} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">SessionContext.Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); };</span></span></code> </pre> <br><p>  Seperti yang dapat Anda lihat dari kode, kami melacak poin secara independen.  Ada keadaan terpisah untuk pemain "kiri" dan "kanan".  Serta fungsi untuk mengelola akun: setel ulang akun dan ubah. </p><br><p>  API penyedia yang dihasilkan sangat sederhana.  Secara umum, hampir semua logika yang terkait dengan penyedia sangat sederhana, jadi kami tidak akan fokus pada itu. </p><br><h2 id="taymery">  Pengatur waktu </h2><br><p>  Komponen babak utama permainan ternyata menarik: ada momen-momen ambigu di dalamnya.  Komponennya sama untuk kedua mode (mundur dan acak - "Pintasan" dan "Mixer"). </p><br><p>  Dari uraian babak, jelas bahwa ada banyak interaksi dengan waktu. </p><br><p>  Pertama, ada timer yang bertanggung jawab atas durasi kata di layar: 10 detik untuk menekan tombol.  Jika tidak ada yang menekan tombol, kata berikutnya muncul secara otomatis. </p><br><p>  Kedua, penghitung waktu yang dimulai ketika salah satu pemain mengklik tombol.  Kemudian dia memiliki 3 detik untuk menebak kata itu. </p><br><p>  Tampaknya tidak ada yang rumit dalam hal ini, jadi kami menulis kode yang tampaknya jelas: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [time, nextTick] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { nextTick(time + <span class="hljs-number"><span class="hljs-number">1</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> clearInterval(id); }, []);</code> </pre> <br><p>  Tapi, seperti yang bisa Anda tebak, ini tidak berhasil.  Itu sama sekali tidak berhasil! </p><br><p>  Timer mencapai 1 dan berhenti pada saat itu.  Faktanya adalah bahwa nilai <code>time</code> lama "dikunci" di dalam fungsi pawang.  Oleh karena itu, dengan setiap centang, <code>setInterval</code> mengacu pada nilai <code>time</code> dari render pertama. </p><br><p>  Ada solusi untuk masalah menggunakan fungsi alih-alih nilai langsung: </p><br><pre> <code class="javascript hljs">nextTick(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">currentTime</span></span></span><span class="hljs-function"> =&gt;</span></span> currentTime + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Ya, dengan begitu kami selalu memiliki nilai "segar" untuk timer.  Tapi kita tidak bisa mendapatkan <code>props</code> "segar", misalnya. </p><br><p>  Jelas, pendekatan yang berbeda harus ditemukan.  Dan keputusan paling pasti adalah membuat fungsi pawang bisa berubah.  Bereaksi memiliki hook <code>useRef</code> khusus untuk <code>useRef</code> . </p><br><p>  Paling sering digunakan untuk bekerja dengan elemen DOM, tetapi ini bukan satu-satunya aplikasi.  Kami dapat "mengingat" variabel apa pun di properti <code>current</code> ini dan memperbaruinya dengan setiap render. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ setCount(count + <span class="hljs-number"><span class="hljs-number">1</span></span>); } useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { savedCallback.current = callback; }); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ savedCallback.current(); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id = setInterval(tick, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> clearInterval(id); }, []);</code> </pre> <br><p>  Ada artikel bagus oleh Dan Abramov tentang bekerja dengan <code>setInterval</code> dan React hooks: <a href="https://overreacted.io/making-setinterval-declarative-with-react-hooks/">Membuat setInterval Declarative dengan React Hooks</a> .  Dia dengan sempurna menggambarkan semua jebakan dan semua tahapan refleksi pada implementasi hook <code>useInterval</code> , yang kami ambil sebagai solusi untuk masalah kami. </p><br><p>  Karena stan dibuka sepanjang konferensi, sesi yang berkelanjutan menggunakan permainan sangat besar.  Halaman itu tidak diperbarui sama sekali (F5), jadi sangat penting untuk memantau memori pada tahap pengembangan.  Seperti yang Anda tahu, kebocoran berjalan beriringan dengan timer, dan jika semua ini dibumbui dengan re-renders dari reaksi, maka akan sangat mudah untuk menulis kode yang memakan memori yang sangat, sangat banyak. </p><br><p>  <code>Countdown</code> dimulai, berhenti, diatur ulang, dan dimulai kembali puluhan (atau mungkin ratusan) kali dalam satu sesi permainan.  Agar tidak repot dengan cek, yang seharusnya banyak, kami menggunakan "trik" yang agak sederhana - kami menambahkan <code>key</code> pada komponen ini. </p><br><pre> <code class="javascript hljs">&lt;QuestionCountdown key={question.text} onComplete={nextQuestion} /&gt;</code> </pre> <br><p>  Kami tidak akan membahas hal ini secara rinci, deskripsi lengkap tentang proses rekonsiliasi reaksi masih dengan Dan Abramov yang sama: <a href="https://overreacted.io/react-as-a-ui-runtime/">Bereaksi sebagai Runtime UI</a> . </p><br><h1 id="apparatnaya-chast-dve-krasnye-knopki">  Perangkat keras: dua tombol merah </h1><br><p>  Jadi, kami telah memenuhi beberapa persyaratan untuk permainan: itu multipemain, cepat dan dengan mekanik sederhana.  Masih menambah hiburannya.  Kisah ini akan diikuti oleh Yura Lilekov <a href="https://habr.com/ru/users/lilek/" class="user_link">lilek</a> - penggemar DIY kami, seorang pembicara konstan dari komunitas, pencipta sayap terbang dan perangkat do-it-yourself lainnya. </p><br><p>  Kami benar-benar ingin menemukan dua tombol mekanis besar.  Dan untuk memastikan yang merah - seperti dalam meme dengan Agutin. </p><br><p>  Sayangnya, semua yang ditemukan di toko online terlalu kecil (diameter 5 cm) atau tidak ada tombol sama sekali.  Tentu saja, ada AliExpress lama yang bagus, tetapi tidak ada waktu untuk menunggu pengiriman. </p><br><p>  Hasilnya, kami menemukan tombol yang tepat di situs agensi kreatif.  Tombol-tombol di suatu tempat di pinggiran kota dilakukan Alexander (ternyata, lulusan Fakultas Radio Elektronika).  Kami menelepon, bertanya mikrokontroler mana yang dijahit ke dalam kotak, dan diminta untuk meninggalkan akses ke sana, karena kami perlu memprogram ulang. </p><br><p>  Alexander, secara sederhana, terkejut dengan pertanyaan seperti itu.  Ketika kami bertanya apakah tombol-tombol itu akan tahan terhadap tekanan para programmer yang antusias, dia meyakinkan kami bahwa tombol-tombol seperti itu ada di mesin slot di "Cosmic" dan mengatasi aliran anak-anak dengan sempurna.  Ke depan, saya akan mengatakan bahwa para insinyur yang dipanaskan menahan tombol juga (hanya baterai yang harus diganti sekali). </p><br><p><img src="https://habrastorage.org/webt/bh/hb/bd/bhhbbdvztsnypogvlbn3jpo3nvg.png"></p><br><h2 id="nachinka">  Isian </h2><br><p>  Tetapi, sayangnya, perangkat yang telah selesai tidak memiliki semua kualitas yang kami butuhkan.  Dan jika Anda masih bisa menghilangkan efek suara dengan memotong kabel ke speaker, maka secara otomatis menentukan tombol mana yang ditekan bukanlah tugas yang mudah.  Opsi sederhana menyarankan sendiri: entah bagaimana menghubungkan perangkat ini ke komputer dan menerjemahkan penekanan tombol-tombol ini ke dalam penekanan tombol pada keyboard. </p><br><p>  Solusi tanpa embel-embel - untuk mengambil keyboard USB lama dan membawa beberapa tombol dengan kabel tambahan dari keyboard ke perangkat - segera diberhentikan sebagai "pertanian kolektif".  Dan menghubungkan kekuatan DIY. </p><br><p>  Setelah beberapa pertimbangan, kami memutuskan untuk menggunakan papan Arduino Pro Micro berdasarkan mikrokontroler ATmega32u4 dari keluarga AVmel dari Atmel dengan ikatan yang diperlukan.  Di papan ini, antara lain, port I / O dan MicroUSB dipisahkan.  Dan yang paling penting - mikrokontroler ATmega32u4 dapat bertindak sebagai perangkat HID, yaitu, dalam kasus kami, meniru penekanan tombol dalam kondisi tertentu. </p><br><p><img src="https://habrastorage.org/webt/me/pn/d9/mepnd9yvzya5fkqdxqgbsvtwgjo.png" alt="(Gambar diambil dari salah satu penjual dari Alibaba.com"></p><br><p>  Untuk memprogram mikrokontroler ini, Anda hanya perlu kabel MicroUSB biasa dan lingkungan pengembangan Arduino IDE. </p><br><p>  Setelah menginstal lingkungan pengembangan, contoh kode paling sederhana akan segera tersedia. </p><br><p>  Misalnya, program yang mengemulasi mengetik pada keyboard ketika tombol ditekan (terhubung ke port input / output) berada di sini: </p><br><p>  File-&gt; Contoh-&gt; USB-&gt; Keyboard-&gt; KeyboardMessage </p><br><p>  Emulasi keystrokes dicapai dengan sangat sederhana: </p><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#include "Keyboard.h" //      void setup() { Keyboard.begin(); //   } void loop() { Keyboard.print("Test"); //   4  delay(1000); //   1  }</span></span></code> </pre> <br><p>  Membaca status port input juga tanpa embel-embel: </p><br><pre> <code class="cmake hljs">int button_pin = <span class="hljs-number"><span class="hljs-number">7</span></span>; //  ,     void setup() { pinMode(button_pin, INPUT); //     } void loop() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (digitalRead(button_pin)) { //   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    } }</code> </pre> <br><p>  Karena port dibuka oleh tegangan, dan bukan oleh arus, arus induksi terkecil di kabel yang beralih dari tombol ke port dapat memberikan hasil positif palsu.  Oleh karena itu, kami menyarankan "menarik" port input dengan resistor resistansi tinggi: arus induksi langsung mengalir melalui itu ke "ground", mencegah perbedaan tegangan tinggi antara input dan "ground" dari terjadi, dan dengan demikian, tidak akan ada pemicu palsu.  Untuk keperluan ini, resistor 5-10 kÎ© sudah cukup, yang terhubung antara input mikrokontroler dan "ground" -nya. </p><br><p>  Dengan demikian, kami mendapatkan skema berikut: </p><br><p><img src="https://habrastorage.org/webt/gt/na/3l/gtna3lp5_d3iag_lzxh115oug6s.png"></p><br><p>  Papan Arduino Pro Micro melalui microUSB terhubung ke laptop dengan bagian perangkat lunak permainan, dua tombol terhubung ke dua input papan dan catu daya umum.  Juga, dua input ini ditarik ke tanah oleh dua resistor. </p><br><p>  Ketika salah satu tombol ditekan, arus dari output catu daya papan melalui tombol menuju ke input papan yang sesuai - dengan demikian kita akan melihat "unit" logis pada input. </p><br><p>  Pada bagian perangkat lunak, kami memutuskan untuk meniru penekanan tombol "panah kiri" dan "panah kanan", dan juga memberikan penundaan selama 4 detik setelah menentukan penekanan, untuk menghindari klik berulang oleh peserta atau mengguncang kontak di tombol. </p><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;Keyboard.h&gt; char leftKey = KEY_LEFT_ARROW; char rightKey = KEY_RIGHT_ARROW; int btn1pin = 7; int btn1value = 0; int btn2pin = 8; int btn2value = 0; void setup() { pinMode(btn1pin, INPUT); pinMode(btn2pin, INPUT); Keyboard.begin(); } void loop() { btn1value = digitalRead(btn1pin); btn2value = digitalRead(btn2pin); if (btn1value == 1 &amp;&amp; btn2value == 1) { //    =    } else if (btn1value == 0 &amp;&amp; btn2value == 0) { //    =    } else if (btn1value == 1) { //    =       4  Keyboard.press(leftKey); delay(100); Keyboard.releaseAll(); delay(4000); } else if (btn2value == 1) { //    =       4  Keyboard.press(rightKey); delay(100); Keyboard.releaseAll(); delay(4000); } }</span></span></code> </pre> <br><p>  Jadi dengan bantuan perangkat sederhana, kami mengajarkan tombol untuk mengidentifikasi pemain yang mengkliknya lebih cepat dari lawan, dan untuk memberi sinyal kepada presenter. </p><br><h2 id="upravlenie">  Manajemen </h2><br><p>  Sepenuhnya manual dan sesederhana mungkin: </p><br><ul><li>  <strong>Spasi</strong> - Kata Selanjutnya </li><li>  <strong>Masukkan</strong> - tampilkan kata yang benar </li><li>  <strong>+</strong> - true (1 poin) </li><li>  <strong>0</strong> - salah (arahkan ke lawan) </li><li>  <strong>Shift</strong> Kiri - Langkah Selanjutnya </li><li>  <strong>Shift</strong> Kanan - langkah sebelumnya </li></ul><br><h1 id="rezultat">  Hasil </h1><br><p>  Semua empat hari konferensi (dua di Highload ++, dua di Heisenbug) di stand Badoo terus-menerus memainkan "IT guessing game".  Semua harapan kami menjadi kenyataan: </p><br><ul><li>  Gim ini menarik perhatian peserta dan penonton: seluruh barisan orang berkumpul di stan.  Sangat menyenangkan bahwa pada hari kedua konferensi jumlah peserta tidak berkurang. </li><li>  Tombol adalah yang teratas!  Tambahkan +100 untuk kesenangan.  Sekalipun para saingan itu saling asing satu sama lain, permainan itu menimbulkan banyak emosi. </li><li>  Gagasan dengan tanda pada lencana berhasil: tidak ada kesulitan menemukan pemenang dan mengumpulkan kontak.  Beberapa orang meminta agar lencana mereka tetap bersih, jadi kami memberi tanda pada pergelangan tangan kami (mereka mudah terhapus). </li><li>  Kami membagikan 14 pasang headphone dan beberapa ratus hadiah kecil.  Tidak ada yang tersisa tanpa hadiah! </li></ul><br><p><img src="https://habrastorage.org/webt/zd/fd/vh/zdfdvheuxobpk3y0st_kbzpkgl0.jpeg"></p><br><div class="spoiler">  <b class="spoiler_title">Untuk berpartisipasi dalam permainan di konferensi, kami menyajikan merch keren</b> <div class="spoiler_text"><p>  <strong>Pembuat keputusan menggunakan magnet.</strong>  Tidak tahu apa yang harus dilakukan dengan tugas - putar disk ajaib!  Kami hanya memiliki beberapa foto yang tersisa, karena kami membagikan semuanya: </p><br><p><img src="https://habrastorage.org/webt/qe/yc/fw/qeycfwgjxk5wad7b4slq5uqgmy0.jpeg"><br>  <em>Untuk insinyur QA</em> </p><br><p><img src="https://habrastorage.org/webt/wy/so/ct/wysoct41vwjzn6qd-lzog7nmo7o.jpeg"><br>  <em>Untuk pengembang</em> </p><br><p>  <strong>Cookie prediksi IT</strong> <br>  Prediksi diciptakan sendiri (52 opsi).  Menjadi kenyataan dengan probabilitas hingga 100%. </p><br><p><img src="https://habrastorage.org/webt/ni/c9/vu/nic9vu9vf1xqh3xb7dyyli-mqni.png"></p><br><p><img src="https://habrastorage.org/webt/av/nf/vm/avnfvmkteect_rwrelfazf8kuau.png"></p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482028/">https://habr.com/ru/post/id482028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482010/index.html">"Epik Baru". Untuk dev, ops dan orang yang ingin tahu</a></li>
<li><a href="../id482012/index.html">Raspberry Pi dan iperf - penguji bandwidth untuk perangkat Smart Home dan IoT</a></li>
<li><a href="../id482014/index.html">Terima dan dekode TV analog menggunakan SDR dan Python</a></li>
<li><a href="../id482020/index.html">R, Monte Carlo, dan tugas perusahaan</a></li>
<li><a href="../id482022/index.html">Lihat saja! 20 film tentang sains dan ilmuwan</a></li>
<li><a href="../id482030/index.html">Vue.js: Kait siklus hidup komponen Anda dan pihak ketiga</a></li>
<li><a href="../id482032/index.html">Kami bermain dengan api: kami menjalankan kode arbitrer pada pengembangan iPhone 7</a></li>
<li><a href="../id482034/index.html">Yandex: ada segalanya ... tentang pengguna</a></li>
<li><a href="../id482038/index.html">Kami merangkum hasil 2019 di Haber Career</a></li>
<li><a href="../id482040/index.html">Fitur program pembuatan profil dalam C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>