<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•î üëè üë®‚Äçüë®‚Äçüëß Das Buch "Hochleistungscode auf der .NET-Plattform. 2. Auflage üë®üèæ‚Äçüîß üëû üö∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Buch erfahren Sie, wie Sie die Leistung von verwaltetem Code maximieren k√∂nnen, idealerweise ohne die Vorteile der .NET-Umgebung zu beeintr√§...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch "Hochleistungscode auf der .NET-Plattform. 2. Auflage</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/458520/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/sl/sj/0d/slsj0dvgahq6ejfp9lenc9s8mzu.jpeg" align="left" alt="Bild"></a>  In diesem Buch erfahren Sie, wie Sie die Leistung von verwaltetem Code maximieren k√∂nnen, idealerweise ohne die Vorteile der .NET-Umgebung zu beeintr√§chtigen oder im schlimmsten Fall eine minimale Anzahl zu opfern.  Sie lernen rationale Programmiermethoden kennen, finden heraus, was zu vermeiden ist und h√∂chstwahrscheinlich, wie Sie die frei verf√ºgbaren Tools verwenden, um das Produktivit√§tsniveau einfach zu messen.  Das Schulungsmaterial enth√§lt nur ein Minimum an Wasser - nur das Notwendigste.  Das Buch gibt genau das, was Sie wissen m√ºssen, es ist relevant und pr√§gnant, enth√§lt nicht zu viel.  Die meisten Kapitel beginnen mit allgemeinen Informationen und Hintergrundinformationen, gefolgt von spezifischen Tipps, die wie ein Rezept aufgebaut sind, und enden mit einem schrittweisen Abschnitt zum Messen und Debuggen f√ºr eine Vielzahl von Szenarien. <br><br>  Auf dem Weg dorthin wird Ben Watson in bestimmte Komponenten der .NET-Umgebung eintauchen, insbesondere in die darauf basierende Common Language Runtime (CLR). Wir werden sehen, wie der Arbeitsspeicher Ihres Computers verwaltet, Code generiert, die Multithread-Ausf√ºhrung organisiert und vieles mehr getan wird .  Sie werden gezeigt, wie die .NET-Architektur gleichzeitig Ihr Software-Tool einschr√§nkt und zus√§tzliche Funktionen bietet und wie sich die Auswahl der Programmierpfade erheblich auf die Gesamtleistung der Anwendung auswirken kann.  Als Bonus wird der Autor Ihnen Geschichten aus der Erfahrung mit der Erstellung sehr gro√üer, komplexer und leistungsstarker .NET-Systeme bei Microsoft in den letzten neun Jahren mitteilen. <br><a name="habracut"></a><br><h3>  Auszug: W√§hlen Sie die entsprechende Thread-Pool-Gr√∂√üe </h3><br>  Im Laufe der Zeit wird der Thread-Pool unabh√§ngig konfiguriert, hat jedoch zu Beginn keinen Verlauf und startet im Ausgangszustand.  Wenn Ihr Softwareprodukt au√üergew√∂hnlich asynchron ist und einen Zentralprozessor erheblich verwendet, kann es unter unerschwinglich hohen Kosten f√ºr den Erststart leiden, bis noch mehr Threads erstellt und verf√ºgbar sind.  Passen Sie die Startparameter so an, dass Sie ab dem Start der Anwendung eine bestimmte Anzahl vorgefertigter Threads zur Hand haben: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> int MinWorkerThreads = <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> int MinIoThreads = <span class="hljs-number"><span class="hljs-number">25</span></span>; ThreadPool.SetMinThreads(MinWorkerThreads, MinIoThreads);</code> </pre> <br>  Sei hier vorsichtig.  Bei Verwendung von Task-Objekten basiert deren Versand auf der Anzahl der daf√ºr verf√ºgbaren Threads.  Wenn zu viele von ihnen vorhanden sind, k√∂nnen Task-Objekte einer √ºberm√§√üigen Planung unterzogen werden, was zumindest zu einer Verringerung der Effizienz des Zentralprozessors aufgrund einer h√§ufigeren Kontextumschaltung f√ºhrt.  Wenn die Arbeitslast nicht so hoch ist, kann der Thread-Pool auf einen Algorithmus umschalten, der die Anzahl der Threads reduziert und auf eine niedrigere als die angegebene Anzahl bringt. <br><br>  Sie k√∂nnen ihre maximale Anzahl auch mit der SetMaxThreads-Methode festlegen. Diese Technik unterliegt jedoch √§hnlichen Risiken. <br><br>  Um die erforderliche Anzahl von Threads herauszufinden, lassen Sie diesen Parameter in Ruhe und analysieren Sie Ihre Anwendung in einem stabilen Zustand mit den Methoden ThreadPool.GetMaxThreads und ThreadPool.GetMinThreads oder Leistungsindikatoren, die die Anzahl der am Prozess beteiligten Threads anzeigen. <br><br><h3>  Fl√ºsse nicht unterbrechen </h3><br>  Das Unterbrechen der Arbeit von Threads ohne Abstimmung mit der Arbeit anderer Threads ist ein ziemlich gef√§hrlicher Vorgang.  Streams m√ºssen sich selbst bereinigen, und wenn sie als Abort-Methode bezeichnet werden, k√∂nnen sie nicht ohne negative Konsequenzen geschlossen werden.  Wenn ein Thread zerst√∂rt wird, befinden sich Teile der Anwendung in einem undefinierten Zustand.  Es w√§re besser, das Programm zum Absturz zu bringen, aber im Idealfall ist ein sauberer Neustart erforderlich. <br><br>  Um einen Thread sicher zu beenden, m√ºssen Sie einen freigegebenen Status verwenden, und die Thread-Funktion selbst muss diesen Status √ºberpr√ºfen, um zu bestimmen, wann er abgeschlossen werden soll.  Sicherheit muss durch Koh√§renz erreicht werden. <br><br>  Im Allgemeinen sollten Sie immer Aufgabenobjekte verwenden - es wird keine API zum Unterbrechen einer Aufgabe bereitgestellt.  Um einen Thread konsistent beenden zu k√∂nnen, m√ºssen Sie, wie bereits erw√§hnt, das CancellationToken-Token verwenden. <br><br><h3>  √Ñndern Sie die Thread-Priorit√§t nicht </h3><br>  Im Allgemeinen ist das √Ñndern der Priorit√§t von Threads ein √§u√üerst erfolgloses Unterfangen.  Unter Windows wird der Thread-Versand entsprechend ihrer Priorit√§tsstufe durchgef√ºhrt.  Wenn Threads mit hoher Priorit√§t immer zur Ausf√ºhrung bereit sind, werden Threads mit niedriger Priorit√§t ignoriert und erhalten selten eine Chance zum Ausf√ºhren.  Indem Sie die Priorit√§t eines Threads erh√∂hen, sagen Sie, dass seine Arbeit Vorrang vor allen anderen Arbeiten haben sollte, einschlie√ülich anderer Prozesse.  Dies ist f√ºr ein stabiles System nicht sicher. <br><br>  Es ist besser, die Priorit√§t des Threads zu verringern, wenn etwas ausgef√ºhrt wird, das bis zum Abschluss von Aufgaben mit normaler Priorit√§t warten kann.  Ein guter Grund, die Priorit√§t eines Threads zu verringern, kann darin bestehen, einen au√üer Kontrolle geratenen Thread zu entdecken, der eine Endlosschleife ausf√ºhrt.  Es ist unm√∂glich, einen Thread sicher zu unterbrechen. Die einzige M√∂glichkeit, einen bestimmten Thread und Prozessorressourcen zur√ºckzugeben, besteht darin, den Prozess neu zu starten.  Bis es m√∂glich wird, den Stream zu schlie√üen und sauber zu machen, ist eine Verringerung der Priorit√§t des au√üer Kontrolle geratenen Streams ein vern√ºnftiger Weg, um die Folgen zu minimieren.  Es sollte beachtet werden, dass selbst Threads mit einer niedrigeren Priorit√§t im Laufe der Zeit garantiert ausgef√ºhrt werden: Je l√§nger ihnen die Starts entzogen werden, desto h√∂her wird ihre dynamische Priorit√§t von Windows festgelegt.  Eine Ausnahme bildet die Leerlaufpriorit√§t THREAD_ - PRIORITY_IDLE, bei der das Betriebssystem die Ausf√ºhrung eines Threads nur dann plant, wenn buchst√§blich nichts mehr zu starten ist. <br><br>  Es kann durchaus berechtigte Gr√ºnde geben, die Priorit√§t des Flusses zu erh√∂hen, beispielsweise die Notwendigkeit, schnell auf seltene Situationen zu reagieren.  Die Verwendung solcher Techniken sollte jedoch sehr vorsichtig sein.  Das Planen von Threads in Windows wird unabh√§ngig von den Prozessen ausgef√ºhrt, zu denen sie geh√∂ren. Daher wird ein Thread mit hoher Priorit√§t aus Ihrem Prozess auf Kosten nicht nur Ihrer anderen Threads, sondern auch aller Threads anderer Anwendungen, die auf Ihrem System ausgef√ºhrt werden, gestartet. <br><br>  Wenn ein Thread-Pool verwendet wird, werden alle Priorit√§ts√§nderungen jedes Mal verworfen, wenn ein Thread in den Pool zur√ºckkehrt.  Wenn Sie bei Verwendung der Task Parallel-Bibliothek weiterhin grundlegende Threads verwalten, sollten Sie ber√ºcksichtigen, dass mehrere Tasks im selben Thread gestartet werden k√∂nnen, bevor sie an den Pool zur√ºckgegeben werden. <br><br><h3>  Thread-Synchronisation und Blockierung </h3><br>  Sobald die Konversation zu mehreren Threads kommt, m√ºssen diese synchronisiert werden.  Die Synchronisierung besteht darin, nur einem Thread Zugriff auf einen gemeinsam genutzten Status zu gew√§hren, z. B. auf ein Klassenfeld.  Normalerweise werden Threads mithilfe von Synchronisationsobjekten wie Monitor, Semaphore, ManualResetEvent usw. synchronisiert. Manchmal werden sie informell als Sperren bezeichnet, und der Synchronisationsprozess in einem bestimmten Thread wird als Sperre bezeichnet. <br><br>  Eine der grundlegenden Wahrheiten von Sperren ist folgende: Sie steigern niemals die Leistung.  Im besten Fall - mit einem gut implementierten Synchronisationsprimitiv und ohne Konkurrenz - kann das Blockieren neutral sein.  Dies f√ºhrt dazu, dass die Ausf√ºhrung n√ºtzlicher Arbeit durch andere Threads gestoppt wird und die CPU-Zeit verschwendet wird, die Kontextwechselzeit erh√∂ht wird und andere negative Konsequenzen entstehen.  Sie m√ºssen sich damit abfinden, denn Korrektheit ist viel wichtiger als einfache Leistung.  Ob das falsche Ergebnis schnell berechnet wird, spielt keine Rolle! <br><br>  Bevor Sie beginnen, das Problem der Verwendung des Schlie√üger√§ts zu l√∂sen, werden wir die grundlegendsten Prinzipien betrachten. <br><br><h3>  Muss ich mich √ºberhaupt um die Leistung k√ºmmern? </h3><br>  Begr√ºnden Sie zun√§chst die Notwendigkeit, die Produktivit√§t zu steigern.  Dies bringt uns zur√ºck zu den in Kapitel 1 beschriebenen Prinzipien. Die Leistung ist nicht f√ºr Ihren gesamten Anwendungscode gleich wichtig.  Nicht jeder Code muss einer Optimierung n-ten Grades unterzogen werden.  In der Regel beginnt alles mit der ‚Äûinneren Schleife‚Äú - dem Code, der am h√§ufigsten oder am kritischsten f√ºr die Leistung ausgef√ºhrt wird - und erstreckt sich in alle Richtungen, bis die Kosten den erhaltenen Nutzen √ºbersteigen.  Es gibt viele Bereiche im Code, die f√ºr die Leistung viel weniger wichtig sind.  Wenn Sie in einer solchen Situation ein Schloss ben√∂tigen, wenden Sie es ruhig an. <br><br>  Und jetzt solltest du vorsichtig sein.  Wenn Ihr unkritischer Code in einem Thread aus einem Thread-Pool ausgef√ºhrt wird und Sie ihn f√ºr eine lange Zeit blockieren, f√ºgt der Thread-Pool m√∂glicherweise weitere Threads ein, um andere Anforderungen zu verarbeiten.  Wenn ein oder zwei Threads dies von Zeit zu Zeit tun, ist das in Ordnung.  Wenn jedoch viele Threads solche Dinge tun, kann ein Problem auftreten, da aus diesem Grund Ressourcen, die die eigentliche Arbeit erledigen m√ºssen, nutzlos ausgegeben werden.  Unbeabsichtigtes Starten eines Programms mit einer erheblichen konstanten Last kann sich negativ auf das System auswirken, selbst wenn Teile mit hoher Leistung aufgrund unn√∂tiger Kontextwechsel oder unangemessener Beteiligung des Thread-Pools unwichtig sind.  Wie in allen anderen F√§llen m√ºssen Messungen durchgef√ºhrt werden, um die Situation zu beurteilen. <br><br><h3>  Ben√∂tigen Sie wirklich ein Schloss? </h3><br>  Der effektivste Verriegelungsmechanismus ist einer, der nicht ist.  Wenn Sie die Notwendigkeit einer Thread-Synchronisierung vollst√§ndig beseitigen k√∂nnen, ist dies der beste Weg, um eine hohe Leistung zu erzielen.  Dies ist ein Ideal, das nicht so einfach zu erreichen ist.  In der Regel bedeutet dies, dass Sie sicherstellen m√ºssen, dass kein ver√§nderbarer gemeinsamer Status vorhanden ist. Jede Anforderung, die Ihre Anwendung durchl√§uft, kann unabh√§ngig von einer anderen Anforderung oder einigen zentralisierten ver√§nderlichen (Lese- / Schreib-) Daten verarbeitet werden.  Diese Funktion ist das beste Szenario, um eine hohe Leistung zu erzielen. <br><br>  Und sei trotzdem vorsichtig.  Mit der Umstrukturierung ist es einfach, √ºber Bord zu gehen und Code in ein chaotisches Chaos zu verwandeln, das niemand, einschlie√ülich Sie selbst, herausfinden kann.  Sie sollten nicht zu weit gehen, es sei denn, eine hohe Produktivit√§t ist wirklich ein kritischer Faktor und kann sonst nicht erreicht werden.  Verwandeln Sie den Code in asynchron und unabh√§ngig, damit er klar bleibt. <br><br>  Wenn mehrere Threads nur aus einer Variablen gelesen werden (und es keine Hinweise zum Schreiben aus einem Stream gibt), ist keine Synchronisierung erforderlich.  Alle Threads k√∂nnen uneingeschr√§nkt zugreifen.  Dies gilt automatisch f√ºr unver√§nderliche Objekte wie Zeichenfolgen oder Werte unver√§nderlicher Typen, kann jedoch f√ºr alle Objekttypen gelten, wenn Sie die Unver√§nderlichkeit ihres Werts beim Lesen durch mehrere Threads garantieren. <br><br>  Wenn mehrere Threads in eine gemeinsam genutzte Variable schreiben, pr√ºfen Sie, ob der synchronisierte Zugriff durch die Verwendung einer lokalen Variablen beseitigt werden kann.  Wenn Sie eine tempor√§re Kopie f√ºr die Arbeit erstellen k√∂nnen, entf√§llt die Notwendigkeit einer Synchronisierung.  Dies ist besonders wichtig f√ºr wiederholten synchronisierten Zugriff.  Nach dem erneuten Zugriff auf die gemeinsam genutzte Variable m√ºssen Sie nach dem einmaligen Zugriff auf die gemeinsam genutzte Variable zum erneuten Zugriff auf die lokale Variable √ºbergehen, wie im folgenden einfachen Beispiel zum Hinzuf√ºgen von Elementen zu einer von mehreren Threads gemeinsam genutzten Sammlung. <br><br><pre> <code class="javascript hljs">object syncObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> object(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> masterList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;long &gt;<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NumTasks</span></span></span><span class="hljs-function"> = 8; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task</span></span></span><span class="hljs-function">[] </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tasks</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NumTasks</span></span></span><span class="hljs-function">]; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">for</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">int i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; NumTasks; i++</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tasks</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">] = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">)=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">5000000</span></span>; j++) { lock (syncObj) { masterList.Add(j); } } }); } Task.WaitAll(tasks);</code> </pre> <br>  Dieser Code kann wie folgt konvertiert werden: <br><br><pre> <code class="javascript hljs">object syncObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> object(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> masterList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;long &gt;<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NumTasks</span></span></span><span class="hljs-function"> = 8; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task</span></span></span><span class="hljs-function">[] </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tasks</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NumTasks</span></span></span><span class="hljs-function">]; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">for</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">int i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; NumTasks; i++</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tasks</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">] = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">)=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;long &gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">5000000</span></span>; j++) { localList.Add(j); } lock (syncObj) { masterList.AddRange(localList); } }); } Task.WaitAll(tasks);</code> </pre> <br>  Auf meinem Computer l√§uft die zweite Version des Codes mehr als doppelt so schnell wie die erste. <br>  Letztendlich ist ein ver√§nderlicher gemeinsamer Staat ein grundlegender Feind der Leistung.  F√ºr die Datensicherheit ist eine Synchronisierung erforderlich, die die Leistung beeintr√§chtigt.  Wenn Ihr Design zumindest die geringste M√∂glichkeit hat, Blockierungen zu vermeiden, stehen Sie kurz vor der Implementierung eines idealen Multithread-Systems. <br><br><h3>  Pr√§ferenzreihenfolge synchronisieren </h3><br>  Bei der Entscheidung, ob irgendeine Art von Synchronisation erforderlich ist, sollte ber√ºcksichtigt werden, dass nicht alle die gleichen Leistungs- oder Verhaltensmerkmale aufweisen.  In den meisten Situationen m√ºssen Sie nur ein Schloss verwenden, und normalerweise sollte dies die urspr√ºngliche Option sein.  Die Verwendung von etwas anderem als Blockieren erfordert intensive Messungen, um zus√§tzliche Komplexit√§t zu rechtfertigen.  Im Allgemeinen betrachten wir die Synchronisationsmechanismen in der folgenden Reihenfolge. <br><br>  1. Lock / Class Monitor - sorgt f√ºr Einfachheit, Verst√§ndlichkeit des Codes und ein ausgewogenes Leistungsverh√§ltnis. <br><br>  2. Das v√∂llige Fehlen der Synchronisation.  Gemeinsame ver√§nderbare Zust√§nde beseitigen, umstrukturieren und optimieren.  Dies ist schwieriger, aber wenn es erfolgreich ist, funktioniert es im Grunde besser als das Anwenden von Blockierung (au√üer wenn Fehler gemacht werden oder die Architektur beeintr√§chtigt wird). <br><br>  3. Einfache Verriegelungsmethoden - In einigen Szenarien ist dies m√∂glicherweise besser geeignet. Sobald die Situation jedoch komplizierter wird, verwenden Sie die Verriegelungssperre. <br><br>  Und schlie√ülich, wenn Sie die Vorteile ihrer Verwendung wirklich nachweisen k√∂nnen, verwenden Sie komplexere, komplexere Schl√∂sser (denken Sie daran: Sie erweisen sich selten als so n√ºtzlich, wie Sie es erwarten): <br><br><ol><li>  asynchrone Sperren (wird sp√§ter in diesem Kapitel erl√§utert); </li><li>  alle anderen. </li></ol><br>  Bestimmte Umst√§nde k√∂nnen die Verwendung einiger dieser Technologien diktieren oder behindern.  Beispielsweise ist es unwahrscheinlich, dass das Kombinieren mehrerer Interlocked-Methoden eine einzelne Lock-Anweisung √ºbertrifft. <br><br>  ¬ªWeitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  25% Rabatt auf Gutschein f√ºr H√§ndler - <b>.NET</b> <br><br>  Nach Bezahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458520/">https://habr.com/ru/post/de458520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458506/index.html">Nicht Portal 3, sondern nah: Quantenteleportation von Informationen innerhalb eines Diamanten</a></li>
<li><a href="../de458508/index.html">Ein Einblick: Graduiertenschule an der EPFL. Teil 4.2: die finanzielle Seite</a></li>
<li><a href="../de458514/index.html">Verst√∂√üe gegen die DSGVO werden aktiver bestraft - neue Bu√ügelder und die Auswirkungen von Vorschriften au√üerhalb der EU</a></li>
<li><a href="../de458516/index.html">Holen Sie sich ein Arbeitsprotokoll von Jira</a></li>
<li><a href="../de458518/index.html">Python verbraucht viel Speicher oder wie kann die Gr√∂√üe von Objekten reduziert werden?</a></li>
<li><a href="../de458524/index.html">VC Wortwolke am Knie</a></li>
<li><a href="../de458530/index.html">Zabbix, Zeitreihen und TimescaleDB</a></li>
<li><a href="../de458532/index.html">Pioniere neuer Technologien: Vadim Artsev erz√§hlte, wie er aufh√∂rte, blind zu sein</a></li>
<li><a href="../de458536/index.html">Python + Pyside2 oder einfach "Rechner"</a></li>
<li><a href="../de458546/index.html">Automation Day oder wie wir die Ebene der Autotests aufbauen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>