<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ†‘ ğŸ§’ğŸ¼ ğŸ¤²ğŸ¼ Berfokus pada kepemilikan ğŸ‘ˆğŸ½ ğŸ† ğŸ§‘ğŸ»â€ğŸ¤â€ğŸ§‘ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan penerjemah: catatan tertanggal 13 Mei 2014, sehingga beberapa detail, termasuk kode sumber, mungkin tidak sesuai dengan keadaan saat ini. Jawa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berfokus pada kepemilikan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418735/"><p>  <em>Catatan</em>  <em>penerjemah: catatan tertanggal 13 Mei 2014, sehingga beberapa detail, termasuk kode sumber, mungkin tidak sesuai dengan keadaan saat ini.</em>  <em>Jawaban atas pertanyaan mengapa penerjemahan dari pos yang sudah lama dibutuhkan adalah nilai dari isinya untuk membentuk pemahaman tentang salah satu konsep dasar bahasa Rust, seperti kelancaran.</em> </p><br><p>  Seiring waktu, saya menjadi yakin bahwa akan lebih baik untuk meninggalkan perbedaan antara variabel lokal yang bisa berubah dan tidak berubah di Rust.  Setidaknya banyak orang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skeptis</a> tentang masalah ini.  Saya ingin menyatakan posisi saya di depan umum.  Saya akan memberikan berbagai motif: filosofis, teknis dan praktis, serta beralih ke pertahanan utama sistem saat ini.  (Catatan: Saya melihat ini sebagai Rust RFC, tetapi memutuskan bahwa nadanya lebih baik untuk posting blog dan saya tidak punya waktu untuk menulis ulang sekarang.) </p><a name="habracut"></a><br><h2 id="poyasnenie">  Penjelasan </h2><br><p>  Saya menulis artikel ini dengan cukup meyakinkan dan percaya bahwa garis yang saya pertahankan akan benar.  Namun, jika kita tidak selesai mendukung sistem saat ini, ini tidak akan menjadi bencana atau sesuatu seperti itu.  Ini memiliki kelebihan, dan secara keseluruhan saya merasa cukup menyenangkan.  Saya hanya berpikir kita bisa memperbaikinya. </p><br><h2 id="odnim-slovom">  Dalam satu kata </h2><br><p> Saya ingin menghapus perbedaan antara variabel lokal yang tidak dapat diubah dan berubah-ubah dan ganti nama <code>&amp;mut</code> pointer ke <code>&amp;my</code> , <code>&amp;only</code> atau <code>&amp;uniq</code> (tidak ada bedanya bagi saya).  Kalau saja tidak ada kata kunci <code>mut</code> . </p><br><h2 id="filosofskiy-motiv">  Motif filosofis </h2><br><p>  Alasan utama saya ingin melakukan ini adalah karena saya percaya ini akan membuat bahasa lebih konsisten dan mudah dimengerti.  Pada dasarnya, ini akan mengarahkan kita kembali dari berbicara tentang kemampuan <em>berubah</em> menjadi berbicara tentang <em>menggunakan alias</em> (yang akan saya sebut "berbagi," lihat di bawah). </p><br><p>  Variabilitas menjadi konsekuensi dari keunikan: "Anda selalu dapat mengubah segala sesuatu yang memiliki akses unik untuk Anda. Data bersama biasanya tidak berubah, tetapi jika perlu, Anda dapat mengubahnya menggunakan semacam jenis <code>Cell</code> ." </p><br><p>  Dengan kata lain, dari waktu ke waktu, menjadi jelas bagi saya bahwa masalah dengan balap data dan keamanan memori muncul ketika Anda menggunakan keduanya alias dan kemampuan berubah-ubah.  Pendekatan fungsional untuk memecahkan masalah ini adalah menghilangkan mutabilitas.  Pendekatan Rust akan menghapus penggunaan alias.  Ini memberi kita cerita yang bisa diceritakan dan itu akan membantu kita mengetahuinya. </p><br><p>  Catatan tentang terminologi: Saya pikir kita harus merujuk pada <em>penggunaan alias</em> sebagai <em>pemisahan</em> ( <em>catatan penerjemah: selanjutnya, di mana-mana alih-alih "aliasing" digunakan "berbagi" dalam arti "pemisahan" atau "kepemilikan bersama", karena tidak ada "penggunaan alias", tidak ada "nama samaran" yang memberikan pemahaman tentang apa yang dipertaruhkan</em> ).  Di masa lalu, kami menghindari ini karena referensi multi-utasnya.  Namun, jika / ketika kita mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rencana</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paralelisasi data</a> yang saya usulkan, maka konotasi ini tidak sepenuhnya tidak tepat.  Bahkan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengingat hubungan erat</a> antara keamanan memori dan balap data, saya benar-benar ingin mempromosikan konotasi ini. </p><br><h2 id="obrazovatelnyy-motiv">  Motif pendidikan </h2><br><p>  Saya pikir aturan saat ini lebih sulit untuk dipahami daripada yang seharusnya.  Tidak jelas, misalnya, bahwa <code>&amp;mut T</code> tidak menyiratkan kepemilikan bersama.  Selain itu, penunjukan <code>&amp;mut T</code> menyiratkan bahwa <code>&amp;T</code> tidak menyiratkan mutabilitas, yang tidak sepenuhnya akurat, karena jenis seperti <code>Cell</code> .  Dan tidak mungkin untuk menyetujui apa yang memanggil mereka ("tautan yang bisa berubah / tidak dapat diubah" adalah yang paling umum, tetapi ini tidak sepenuhnya benar). </p><br><p>  Sebaliknya, jenis seperti <code>&amp;my T</code> atau <code>&amp;only T</code> tampaknya menyederhanakan penjelasan.  Ini adalah <em>tautan unik</em> - tentu saja, Anda tidak dapat memaksa keduanya untuk menunjuk ke tempat yang sama.  Dan <em>mutabilitas</em> adalah hal ortogonal: ia datang dari keunikan, tetapi juga berlaku untuk sel.  Dan tipe <code>&amp;T</code> adalah kebalikannya, <em>tautan bersama</em> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC PR # 58</a> memberikan sejumlah argumen serupa.  Saya tidak akan mengulanginya di sini. </p><br><h2 id="prakticheskiy-motiv">  Motif praktis </h2><br><p>  Saat ini, ada kesenjangan antara pointer yang dipinjam, yang dapat dibagikan atau dapat berubah + unik, dan variabel lokal yang selalu unik, tetapi dapat dapat berubah atau tidak berubah.  Hasil akhir dari ini adalah bahwa pengguna harus memposting iklan <code>mut</code> pada hal-hal yang tidak dapat diedit secara langsung. </p><br><h3 id="lokalnye-peremennye-ne-mogut-byt-smodelirovany-s-ispolzovaniem-ssylok">  Variabel lokal tidak dapat dimodelkan menggunakan referensi </h3><br><p>  Fenomena ini terjadi karena tautan tidak ekspresif seperti variabel lokal.  Secara umum, ini mencegah abstraksi.  Biarkan saya memberi Anda beberapa contoh untuk menjelaskan apa yang saya maksud.  Bayangkan bahwa saya memiliki struktur lingkungan yang menyimpan pointer ke penghitung kesalahan: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span></span> { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Sekarang saya dapat membuat instance dari struktur ini (dan menggunakannya): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  OK, sekarang bayangkan saya ingin memisahkan kode yang memodifikasi <code>env.errors</code> menjadi fungsi yang terpisah.  Saya mungkin berpikir bahwa karena variabel <code>env</code> tidak dinyatakan sebagai dapat diubah, saya dapat menggunakan tautan <code>&amp;</code> immutable: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;env); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helper</span></span></span></span>(env: &amp;Env) { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  } }</span></span></code> </pre> <br><p>  Tapi ini tidak benar.  Masalahnya adalah bahwa <code>&amp;Env</code> adalah tipe kepemilikan bersama ( <em>catatan penerjemah: seperti yang Anda ketahui, lebih dari satu referensi objek yang tidak berubah dapat ada pada suatu waktu</em> ), dan karenanya <code>env.errors</code> muncul di ruang yang memungkinkan kepemilikan terpisah dari objek <code>env</code> .  Agar kode ini berfungsi, saya harus mendeklarasikan <code>env</code> sebagai dapat diubah dan menggunakan tautan <code>&amp;mut</code> ( <em>catatan penerjemah: <code>&amp;mut</code> ) untuk memberi tahu kompiler bahwa <code>env</code> unik dalam kepemilikan, karena hanya satu referensi objek yang dapat berubah yang dapat ada pada suatu waktu dan ras data dikecualikan, tetapi <code>mut</code> karena Anda tidak dapat membuat referensi yang dapat diubah ke objek yang tidak dapat diubah</em> ): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env);</code> </pre> <br><p>  Masalah ini muncul karena kita tahu bahwa variabel lokal itu unik, tetapi kita tidak bisa memasukkan pengetahuan ini ke dalam referensi pinjaman tanpa membuatnya bisa berubah. </p><br><p>  Masalah ini terjadi di sejumlah tempat lain.  Sejauh ini kami telah menulis tentang ini dengan cara yang berbeda, tetapi saya terus dihantui oleh perasaan bahwa kita berbicara tentang istirahat, yang seharusnya tidak boleh. </p><br><h3 id="proverka-tipov-primenitelno-k-zamykaniyam">  Ketik memeriksa penutupan </h3><br><p>  Kami harus mengatasi batasan ini dalam hal penutupan.  Penutupan <em>sebagian besar</em> terbuka dalam struktur seperti <code>Env</code> , tetapi tidak cukup.  Ini karena saya tidak ingin mengharuskan variabel lokal dinyatakan <code>mut</code> jika mereka digunakan via <code>&amp;mut</code> dalam penutupan.  Dengan kata lain, ambil beberapa kode, misalnya: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { do_something(|| *errors += <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><p>  Ekspresi yang menggambarkan penutupan sebenarnya akan membuat instance dari struktur <code>Env</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClosureEnv</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt; { errors: &amp;uniq &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Lihat tautan <code>&amp;uniq</code> .  Ini bukan sesuatu yang bisa dimasuki pengguna akhir.  Ini berarti pointer "unik tetapi tidak selalu bisa berubah".  Ini diperlukan untuk melewati pemeriksaan tipe.  Jika pengguna mencoba menulis struktur ini secara manual, ia harus menulis <code>&amp;mut &amp;mut usize</code> , yang pada gilirannya akan mengharuskan parameter <code>errors</code> dinyatakan sebagai <code>mut errors: &amp;mut usize</code> . </p><br><h3 id="nezapakovannye-zamykaniya-i-procedury">  Penutupan dan prosedur yang tidak dibungkus </h3><br><p>  Saya memperkirakan bahwa pembatasan ini merupakan masalah untuk penutupan yang tidak dibungkus.  Biarkan saya menguraikan desain yang saya pertimbangkan.  Pada dasarnya, idenya adalah ungkapan <code>||</code>  sama dengan beberapa tipe struktural baru yang mengimplementasikan salah satu ciri <code>Fn</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fn</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnMut</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnOnce</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); }</code> </pre> <br><p>  Jenis yang tepat akan dipilih sesuai dengan jenis yang diharapkan, pada hari ini.  Dalam hal ini, konsumen penutupan dapat menulis satu dari dua hal: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;&gt;(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: T) { ... }</code> </pre> <br><p>  Kami ... mungkin ingin memperbaiki sintaks, mungkin menambahkan gula seperti <code>FnMut(usize) -&gt; usize</code> , atau simpan | usize |  -&gt; usize, dll.  Itu tidak begitu penting, penting bahwa kita akan melewati penutupan <em>dengan nilai</em> .  Harap perhatikan bahwa sesuai dengan aturan DST (Jenis Dinamis yang Terkini) saat ini, diizinkan untuk meneruskan jenis berdasarkan nilai sebagai argumen ke <code>FnMut&lt;usize, usize&gt;</code> , oleh karena itu argumen <code>FnMut&lt;usize, usize&gt;</code> adalah DST yang valid dan bukan masalah. </p><br><p>  <em>Selain</em> : proyek ini tidak lengkap, dan saya akan menjelaskan semua detail dalam pesan terpisah. </p><br><p>  Masalahnya adalah bahwa tautan <code>&amp;mut</code> diperlukan untuk memanggil penutupan.  Karena penutupan dilewati oleh nilai, pengguna lagi harus menulis <code>mut</code> tempat yang tampak tidak pada tempatnya: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  Ini adalah masalah yang sama seperti pada contoh <code>Env</code> atas: apa yang <em>sebenarnya</em> terjadi di sini adalah bahwa <code>FnMut</code> hanya menginginkan tautan <em>unik</em> , tetapi karena itu bukan bagian dari sistem tipe, ia meminta tautan yang <em>dapat diubah</em> . </p><br><p>  Sekarang kita mungkin bisa menyiasatinya dengan cara yang berbeda.  Salah satu opsi yang bisa kita lakukan adalah ke <code>||</code>  sintaks tidak akan berkembang menjadi "tipe struktural tertentu", melainkan menjadi "tipe struktural atau penunjuk ke tipe struktural, seperti yang ditentukan oleh inferensi tipe".  Dalam hal ini, penelepon dapat menulis: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  Saya tidak ingin mengatakan bahwa ini adalah akhir dari dunia.  Tetapi ini adalah langkah maju dalam distorsi yang terus meningkat yang harus kita lalui untuk menjaga kesenjangan antara variabel lokal dan referensi. </p><br><h3 id="drugie-chasti-api">  Bagian API lainnya </h3><br><p>  Saya tidak melakukan studi mendalam, tetapi, tentu saja, perbedaan ini merambah di tempat lain.  Misalnya, untuk membaca dari <code>Socket</code> , saya memerlukan pointer yang unik, jadi saya harus menyatakannya bisa berubah.  Karenanya, terkadang ini tidak berhasil: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> socket = Socket::new(); socket.read() <span class="hljs-comment"><span class="hljs-comment">// :   </span></span></code> </pre> <br><p>  Secara alami, menurut saran saya, kode seperti itu akan berfungsi dengan baik.  Anda masih akan menerima pesan kesalahan jika Anda mencoba membaca dari <code>&amp;Socket</code> , tetapi kemudian akan membaca sesuatu seperti "tidak mungkin untuk membuat tautan unik ke tautan bersama", yang secara pribadi saya anggap lebih bisa dimengerti. </p><br><h2 id="no-razve-nam-ne-nuzhen-mut-dlya-bezopasnosti">  Tapi bukankah kita perlu <code>mut</code> untuk keamanan? </h2><br><p>  Tidak, tidak sama sekali.  Program karat akan sama baiknya jika Anda baru saja menyatakan semua binding sebagai <code>mut</code> .  Compiler sangat mampu melacak variabel lokal mana yang berubah pada waktu tertentu - justru karena mereka <em>lokal</em> ke fungsi saat ini.  Apa yang benar-benar diperhatikan oleh sistem tipe adalah keunikan. </p><br><p>  Makna yang saya lihat dalam aturan penerapan <code>mut</code> , dan saya tidak akan menyangkal bahwa ia memiliki nilai, utamanya adalah mereka membantu menyatakan niat.  Yaitu, ketika saya membaca kode, saya tahu variabel mana yang dapat dipindahkan.  Di sisi lain, saya juga menghabiskan banyak waktu membaca kode C ++ dan, sejujurnya, saya tidak pernah memperhatikan bahwa ini adalah batu sandungan utama.  (Hal yang sama berlaku untuk waktu saya habiskan membaca kode di Jawa, JavaScript, Python, atau Ruby.) </p><br><p>  Juga benar bahwa saya terkadang menemukan bug karena saya mendeklarasikan variabel sebagai <code>mut</code> dan lupa mengubahnya.  Saya pikir kita bisa mendapatkan manfaat yang sama dengan lainnya, pemeriksaan yang lebih agresif (misalnya, tidak ada variabel yang digunakan dalam kondisi loop yang berubah dalam tubuh loop).  Saya pribadi tidak ingat berhadapan dengan situasi yang berlawanan: yaitu, jika kompiler mengatakan bahwa sesuatu harus dapat diubah, itu pada dasarnya selalu berarti bahwa saya lupa kata kunci <code>mut</code> suatu tempat.  (Pikirkan: kapan terakhir kali Anda merespons kesalahan kompiler tentang perubahan yang tidak valid dengan melakukan sesuatu selain merestrukturisasi kode untuk membuat perubahan itu valid?) </p><br><h2 id="alternativy">  Alternatif </h2><br><p>  Saya melihat tiga alternatif untuk sistem saat ini: </p><br><ol><li>  Yang saya sajikan di mana Anda hanya membuang "ketidakmampuan" dan hanya melacak keunikan. </li><li>  Satu tempat Anda memiliki tiga jenis referensi: <code>&amp;</code> , <code>&amp;uniq</code> dan <code>&amp;mut</code> .  (Seperti yang saya tulis, ini sebenarnya jenis sistem yang kita miliki saat ini, setidaknya dari sudut pandang pemeriksa pinjaman.) </li><li><p>  Opsi yang lebih ketat, di mana variabel non-mut selalu dianggap terpisah.  Ini berarti Anda harus menulis: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> p = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors; <span class="hljs-comment"><span class="hljs-comment">// ,  `p`   ,  `mut`. *p += 1;</span></span></code> </pre> <br><p>  Anda perlu mendeklarasikan <code>p</code> sebagai <code>mut</code> , karena jika tidak, variabel akan dianggap terpisah, meskipun itu adalah variabel lokal, dan karenanya mengubah <code>*p</code> tidak diperbolehkan.  Apa yang aneh dalam skema ini adalah bahwa variabel lokal TIDAK mengizinkan kepemilikan terpisah, dan kami tahu pasti, karena ketika Anda mencoba untuk membuat aliasnya, itu akan bergerak, destructor akan memulai, dll.  Artinya, kita masih memiliki konsep "dimiliki", yang berbeda dari "tidak memungkinkan kepemilikan yang terpisah." </p><br><p>  Di sisi lain, jika kita menggambarkan sistem ini, mengatakan bahwa kemampuan berubah diwarisi melalui <code>&amp;mut</code> pointer, tanpa gagap tentang kepemilikan bersama, ini mungkin masuk akal. </p><br></li></ol><br><p>  Dari ketiga ini, saya pasti lebih suka No. 1.  Ini adalah yang paling sederhana, dan sekarang saya paling tertarik dengan bagaimana kita dapat menyederhanakan Rust dengan mempertahankan karakternya.  Kalau tidak, saya memberikan preferensi kepada yang kita miliki saat ini. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Pada dasarnya, saya menemukan bahwa aturan saat ini mengenai mutabilitas memiliki beberapa nilai, tetapi harganya mahal.  Mereka adalah sejenis abstraksi yang mengalir: yaitu, mereka menceritakan sebuah kisah sederhana, yang ternyata ternyata tidak lengkap.  Hal ini menyebabkan kebingungan ketika orang beralih dari pemahaman awal, di mana <code>&amp;mut</code> mencerminkan bagaimana kemampuan berubah, menjadi pemahaman penuh: kadang-kadang <code>mut</code> hanya diperlukan untuk memastikan keunikan, dan terkadang mutabilitas dicapai tanpa kata kunci <code>mut</code> . </p><br><p>  Selain itu, kita harus bertindak dengan hati-hati untuk mempertahankan fiksi, yang <code>mut</code> menunjukkan mutabilitas, bukan keunikan.  Kami telah menambahkan kasus khusus bagi peminjam untuk memeriksa penutupan.  Kita harus membuat aturan tentang <code>&amp;mut</code> mutability lebih kompleks secara umum.  Kita harus menambahkan <code>mut</code> pada penutupan agar kita dapat memanggilnya, atau membuat sintaksis penutupan menjadi kurang jelas.  Dan sebagainya. </p><br><p>  Pada akhirnya, semuanya berubah menjadi bahasa yang lebih kompleks secara keseluruhan.  Alih-alih hanya memikirkan kepemilikan bersama dan keunikan, pengguna harus berpikir tentang kepemilikan bersama dan sifat berubah-ubah, dan keduanya entah bagaimana kacau. </p><br><p>  Saya pikir itu tidak layak. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418735/">https://habr.com/ru/post/id418735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418723/index.html">Patch AndroidX</a></li>
<li><a href="../id418725/index.html">Konstanta ajaib</a></li>
<li><a href="../id418727/index.html">Di mana dan bagaimana masuk ke embeddings grafik</a></li>
<li><a href="../id418729/index.html">Semua yang sudah lama Anda minta dalam satu rilis - CLion 2018.2</a></li>
<li><a href="../id418733/index.html">Memvisualisasikan komentar dari saluran YouTube komunitas touhou internasional dan lokal</a></li>
<li><a href="../id418737/index.html">Ablasi laser, kaca telur dan dopant Er2O3</a></li>
<li><a href="../id418739/index.html">Pusat Teknologi Aditif: Printer 3D industri Sistem 3D, Stratasys, SLM, EOS</a></li>
<li><a href="../id418741/index.html">Tambahkan enkripsi dan dorong ke SIP biasa</a></li>
<li><a href="../id418743/index.html">Kisah Tempat Pertama di ML Boot Camp VI</a></li>
<li><a href="../id418751/index.html">Dex mata-mata Cina kurang ajar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>