<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😐 ☃️ 🕯️ 6 façons de masquer des données dans une application Android 🤟🏼 🏄 🕶️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, cher lecteur, j'étudie les applications mobiles depuis un certain temps. La plupart des applications n'essaient pas de me cacher en quelque s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>6 façons de masquer des données dans une application Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436908/"><p>  Bonjour, cher lecteur, j'étudie les applications mobiles depuis un certain temps.  La plupart des applications n'essaient pas de me cacher en quelque sorte leur fonctionnalité "secrète".  Et je suis heureux en ce moment, car je n'ai pas à étudier le code obscurci de quelqu'un. </p><br><p><img src="https://habrastorage.org/webt/v-/hc/cq/v-hccqahz7gg_it346vryqg8pii.png" alt="image"></p><br><p>  Dans cet article, je voudrais partager ma vision de l'obscurcissement, ainsi que parler d'une méthode intéressante pour masquer la logique métier dans les applications avec NDK, que j'ai trouvée relativement récemment.  Donc, si vous êtes intéressé par des exemples en direct de code obscurci dans Android - je demande chat. </p><a name="habracut"></a><br><p>  Sous l'obscurcissement dans le cadre de cet article, on comprend la réduction du code exécutable d'une application Android à un formulaire difficile à analyser.  Il y a plusieurs raisons pour rendre l'analyse de code difficile: </p><br><ol><li>  Aucune entreprise ne veut se faire fourrer dans ses «entrailles». </li><li>  Même si vous avez une application factice, vous pouvez toujours y trouver des choses intéressantes (un exemple avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instagram</a> ). </li></ol><br><p>  De nombreux développeurs résolvent le problème en forçant simplement la configuration ProGuard.  Ce n'est pas la meilleure façon de protéger les données (si c'est la première fois que vous en entendez parler, consultez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki</a> ). </p><br><p>  Je veux donner un exemple, pourquoi la prétendue «protection» avec ProGuard ne fonctionne pas.  Prenez un exemple simple de Google Samples. </p><br><p><img src="https://habrastorage.org/webt/bh/vf/9o/bhvf9o1ft2qjf8j-1og1tdjdi4s.png" alt="image"></p><br><p>  Après avoir connecté ProGuard à une configuration standard, nous obtenons un code décompilé: </p><br><p><img src="https://habrastorage.org/webt/ke/vu/k2/kevuk2vdz6o6m-hy7ukwrfsyusy.png" alt="image"></p><br><p>  «Ohhh, rien n'est clair», disons-nous et nous calmes.  Mais après quelques minutes de basculement entre les fichiers, nous trouvons des morceaux de code similaires: </p><br><p><img src="https://habrastorage.org/webt/fc/jc/kl/fcjcklka1h4yttolcoiszcnoqvu.png" alt="image"></p><br><p>  Dans cet exemple, le code d'application semble plutôt faible (enregistrement des données, création de capture vidéo), donc certaines des méthodes utilisées dans le code d'origine sont facilement comprises même après le traitement avec la configuration ProGuard. </p><br><p>  De plus, jetez un œil aux classes de données dans Kotlin.  La classe de données par défaut crée la méthode «toString», qui contient les noms des variables d'instance et le nom de la classe elle-même. </p><br><p>  Classe de données source: </p><br><p><img src="https://habrastorage.org/webt/q9/u-/vs/q9u-vsnag2z8zjz5fhgc3v5qg3m.png" alt="image"></p><br><p>  Il peut se transformer en friandise pour un revers: </p><br><p><img src="https://habrastorage.org/webt/pn/8x/vv/pn8xvv_otazeei_8kft215qaieu.png" alt="image"><br>  (génération automatique de la méthode toString dans Kotlin) </p><br><p>  Il s'avère que ProGuard se cache loin de tout le code source du projet. </p><br><p>  Si je ne vous ai toujours pas convaincu de l'inefficacité de la protection du code de cette manière, essayons de laisser l'attribut «.source» dans notre projet. </p><br><pre><code class="plaintext hljs">-keepattributes SourceFile</code> </pre> <br><p>  Cette ligne est dans de nombreux projets open source.  Il vous permet de visualiser StackTrace lorsque l'application se bloque.  Cependant, en tirant «.source» du code smali, nous obtenons la hiérarchie entière du projet avec les noms de classe complets. </p><br><p>  Par définition, l'obscurcissement consiste à «mettre le code source sous une forme illisible afin de contrecarrer différents types de réception».  Cependant, ProGuard (lorsqu'il est utilisé avec une configuration standard) ne rend pas le code illisible - il fonctionne comme un minifieur, compressant les noms et jetant des classes supplémentaires hors du projet. </p><br><p>  Une telle utilisation de ProGuard est une solution facile mais pas tout à fait appropriée pour une bonne solution d'obscurcissement.  Un bon développeur doit faire en sorte que le revendeur (ou l'attaquant) ait peur des «caractères chinois», qui sont difficiles à désobfusquer. </p><br><p>  Si vous souhaitez en savoir plus sur ProGuard, je vous propose l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article informatif</a> suivant. </p><br><h2 id="chto-pryachem">  Que cachons-nous </h2><br><p>  Voyons maintenant ce qui est généralement caché dans les applications. </p><br><ul><li>  Clés de chiffrement: </li></ul><br><p><img src="https://habrastorage.org/webt/jf/25/am/jf25amyjucvcyu_e2pw6lcureei.png" alt="image"></p><br><ul><li>  Logique d'application spécifique: </li></ul><br><p><img src="https://habrastorage.org/webt/ke/_k/bb/ke_kbbma_2ykdvu8tqpw3cg8wg4.png" alt="image"></p><br><p>  Quelque chose de plus inattendu peut souvent être caché dans le code (observations de l'expérience personnelle), par exemple: </p><br><ul><li>  Noms des développeurs de projets </li><li>  Chemin complet vers le projet </li><li>  Client_secret pour le protocole Oauth2 </li><li>  Livre PDF «Comment développer pour Android» (probablement à portée de main) </li></ul><br><p>  Maintenant, nous savons ce qui peut se cacher dans les applications Android et pouvons passer à l'essentiel, à savoir comment masquer ces données. </p><br><h2 id="sposoby-sokrytiya-dannyh">  Façons de masquer les données </h2><br><h3 id="variant-1-nichego-ne-skryvat-ostavit-vse-na-vidu">  Option 1: ne cachez rien, laissez tout en vue </h3><br><p>  Dans ce cas, je vous montre juste cette photo :) </p><br><p>  «Aidez Dasha à trouver la logique métier» </p><br><p><img src="https://habrastorage.org/webt/td/bb/mi/tdbbmimmetmzt4exlorkdvmg00w.png" alt="image"></p><br><p>  <em>Cette solution économique et totalement gratuite convient pour:</em> </p><br><ul><li>  <em>Applications simples qui n'interagissent pas avec le réseau et ne stockent pas d'informations sensibles sur les utilisateurs;</em> </li><li>  <em>Applications qui utilisent uniquement l'API publique.</em> </li></ul><br><h3 id="variant-2-ispolzovat-proguard-s-pravilnymi-nastroykami">  Option 2: utilisez ProGuard avec les paramètres corrects </h3><br><p>  Cette décision a toujours droit à la vie, car avant tout elle est simple et gratuite.  Malgré les inconvénients susmentionnés, il présente un avantage considérable: si les règles ProGuard sont correctement configurées, l'application peut vraiment devenir obscurcie. </p><br><p>  Cependant, vous devez comprendre qu'une telle solution après chaque assemblage nécessite que le développeur décompile et vérifie si tout va bien.  Après avoir passé plusieurs minutes à étudier le fichier APK, le développeur (et son entreprise) peuvent avoir plus confiance en la sécurité de leur produit. </p><br><div class="spoiler">  <b class="spoiler_title">Comment étudier le fichier APK</b> <div class="spoiler_text"><p>  La vérification de l'application pour l'obscurcissement est assez simple. </p><br><p>  Afin d'obtenir le fichier APK du projet, il existe plusieurs façons: </p><br><ul><li>  prendre à partir du répertoire du projet (dans Android Studio, le nom du dossier est généralement «build»); </li><li>  installez l'application sur votre smartphone et obtenez l'APK en utilisant l'application «Apk Extractor». </li></ul><br><p>  Après cela, en utilisant l'utilitaire Apktool, nous obtenons le code Smali (instructions pour arriver ici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://ibotpeaches.github.io/Apktool/documentation</a> ) et essayons de trouver quelque chose de suspect dans les lignes du projet.  Soit dit en passant, pour rechercher des codes lisibles, vous pouvez faire le plein de commandes bash prédéfinies. </p></div></div><br><p>  <em>Cette solution convient pour:</em> </p><br><ul><li>  <em>Applications de jouets, applications de boutique en ligne, etc.</em> </li><li>  <em>Les applications qui sont vraiment des clients légers et toutes les données proviennent exclusivement du côté serveur;</em> </li><li>  <em>Les applications qui n'écrivent pas sur toutes leurs bannières «Safe Application No. 1».</em> </li></ul><br><h3 id="variant-3-ispolzovat-open-source-obfuscator">  Option 3: utiliser l'Obfuscateur Open Source </h3><br><p>  Malheureusement, je ne connais pas les très bons masqueurs gratuits pour les applications mobiles.  Et les obscurcisseurs qui peuvent être trouvés sur le réseau peuvent vous apporter beaucoup de maux de tête, car il sera trop difficile d'assembler un tel projet pour de nouvelles versions de l'API. </p><br><p>  Historiquement, les obfuscateurs sympas existants sont fabriqués sous le code machine (pour C / C ++).  De bons exemples: </p><br><ul><li>  Obfuscator-LLVM, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/obfuscator-llvm/obfuscator</a> </li><li>  Movfuscator, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/xoreaxeaxeax/movfuscator</a> </li></ul><br><p>  Par exemple, Movfuscator remplace tous les opcodes par movs, rend le code linéaire, supprimant toutes les branches.  Cependant, il est fortement déconseillé d'utiliser cette méthode d'obscurcissement dans un projet de combat, car alors le code risque de devenir très lent et lourd. </p><br><p>  <em>Cette solution convient aux applications où la partie principale du code est NDK.</em> </p><br><h3 id="variant-4-ispolzovat-proprietarnoe-reshenie">  Option 4: utilisez une solution propriétaire </h3><br><p>  C'est le choix le plus compétent pour les applications sérieuses, en tant que logiciel propriétaire: <br>  a) pris en charge; <br>  b) sera toujours pertinent. </p><br><p>  Un exemple de code obscurci lors de l'utilisation de telles solutions: </p><br><p><img src="https://habrastorage.org/webt/xk/x7/5v/xkx75v1yn0je9uvfy7ttbbwy1iw.png" alt="image"></p><br><p>  Dans cet extrait de code, vous pouvez voir: </p><br><ol><li>  Les noms de variables les plus incompréhensibles (avec la présence de lettres russes); </li><li>  Caractères chinois dans les lignes qui ne précisent pas ce qui se passe réellement dans le projet; </li><li>  Il y a beaucoup de pièges ajoutés au projet («switch», «goto»), qui changent considérablement le flux de code de l'application. </li></ol><br><p>  <em>Cette solution convient pour:</em> </p><br><ul><li>  <em>Les banques</em> </li><li>  <em>Compagnies d'assurance;</em> </li><li>  <em>Opérateurs mobiles, applications de stockage de mots de passe, etc.</em> </li></ul><br><h3 id="variant-5-ispolzovat-react-native">  Option 5: utiliser React-Native </h3><br><p>  J'ai décidé de souligner ce point, car l'écriture d'applications multiplateformes est devenue une activité très populaire. </p><br><p>  En plus d'une très grande communauté, JS possède un très grand nombre d'obscurcisseurs ouverts.  Par exemple, ils peuvent transformer votre application en émoticônes: </p><br><p><img src="https://habrastorage.org/webt/ef/an/kd/efankdx-wuwfmyzhtvsi3-effly.png" alt="image"></p><br><p>  Je voudrais vraiment vous conseiller sur cette solution, mais alors votre projet fonctionnera très peu plus vite qu'une tortue. </p><br><p>  Mais en réduisant l'exigence d'obscurcissement du code, nous pouvons créer un projet vraiment bien protégé.  Alors google "js obfuscator" et obscurcissez notre fichier de bundle de sortie. </p><br><p>  <em>Cette solution convient à ceux qui sont prêts à écrire une application multiplateforme sur React Native.</em> </p><br><div class="spoiler">  <b class="spoiler_title">Xamarin</b> <div class="spoiler_text"><p>  Il serait très intéressant de connaître les obfuscateurs sur Xamarin, si vous avez de l'expérience avec eux, veuillez nous en parler dans les commentaires. </p></div></div><br><h3 id="variant-6-ispolzovat-ndk">  Option 6: utilisez NDK </h3><br><p>  J'ai moi-même souvent dû utiliser NDK dans mon code.  Et je sais que certains développeurs pensent que l'utilisation de NDK sauve leur application des inverseurs.  Ce n'est pas tout à fait vrai.  Vous devez d'abord comprendre comment fonctionne le masquage avec le NDK. </p><br><p><img src="https://habrastorage.org/webt/hq/9e/-k/hq9e-k1lty2u1tv9be3dv0poqiw.png" alt="image"></p><br><p>  Cela s'avère très simple.  Il existe une convention JNI dans le code selon laquelle lorsque vous appelez du code C / C ++ dans un projet, il sera converti comme suit. </p><br><p>  Native Native Class: </p><br><p><img src="https://habrastorage.org/webt/5z/2p/k6/5z2pk6hs0lmfse8dxao4sez47_y.png" alt="image"></p><br><p>  Implémentation de la méthode de somme native: </p><br><p><img src="https://habrastorage.org/webt/jn/cc/km/jncckm1ohdbdkncwgi4mczi4mxw.png" alt="image"></p><br><p>  Implémentation de la méthode native de somme statique: </p><br><p><img src="https://habrastorage.org/webt/mp/ru/df/mprudfyoyvzkj_f8s6vwfhsbvp8.png" alt="image"></p><br><p>  Il devient clair que pour appeler la méthode native, vous utilisez la recherche de fonction <code>Java_&lt;package name&gt;_&lt;Static?&gt;&lt;class&gt;_&lt;method&gt;</code> dans la bibliothèque dynamique. </p><br><p>  Si vous regardez le code Dalvik / ART, nous trouverons les lignes suivantes: </p><br><p><img src="https://habrastorage.org/webt/g2/rk/om/g2rkom7si2csod_xiu3qw7t_khw.png" alt="image"></p><br><p>  ( <a href="">source</a> ) </p><br><p>  Tout d'abord, nous allons générer la ligne suivante <code>Java_&lt;package name&gt;_&lt;class&gt;_&lt;method&gt;</code> partir de l'objet Java, puis essayer de résoudre la méthode dans la bibliothèque dynamique à l'aide de l'appel "dlsym", qui tentera de trouver la fonction dont nous avons besoin dans le NDK. </p><br><p>  C'est ainsi que fonctionne JNI.  Son principal problème est qu'en décompilant la bibliothèque dynamique, nous verrons toutes les méthodes en pleine vue: </p><br><p><img src="https://habrastorage.org/webt/pp/mi/-q/ppmi-qaydf_mtotxyr-q06cjt0c.png" alt="image"></p><br><p>  Donc, nous devons trouver une telle solution pour que l'adresse de la fonction soit obscurcie. </p><br><p>  Au début, j'ai essayé d'écrire des données directement dans notre table JNI, mais j'ai réalisé que les mécanismes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ASLR</a> et les différentes versions d'Android ne me permettraient tout simplement pas de faire fonctionner cette méthode sur tous les appareils.  J'ai alors décidé de découvrir quelles méthodes le NDK fournit aux développeurs. </p><br><p>  Et, <a href="">voilà</a> , il y avait une méthode «RegisterNatives» qui fait exactement ce dont nous avons besoin (appelle la fonction interne <a href="">dvmRegisterJNIMethod</a> ). </p><br><p>  Nous définissons un tableau qui décrit notre méthode native: </p><br><p><img src="https://habrastorage.org/webt/uk/ef/or/ukeforgmtg-unwkwoblwq_1vz4q.png" alt="image"></p><br><p>  Et nous enregistrons notre méthode déclarée dans la fonction JNI_OnLoad (la méthode est appelée après l'initialisation de la bibliothèque dynamique, en <a href="">milliers</a> ): </p><br><p><img src="https://habrastorage.org/webt/s2/ik/-5/s2ik-5gk0vexpigegllnt5vjtw8.png" alt="image"></p><br><p>  Hourra, nous avons nous-mêmes caché la fonction «hideFunc».  Appliquez maintenant notre obfuscateur llvm préféré et profitez de la sécurité du code dans sa forme finale. </p><br><p>  <em>Cette solution convient aux applications qui utilisent déjà NDK (la connexion de NDK apporte beaucoup de difficultés au projet, donc cette solution n'est pas si pertinente pour les applications non NDK).</em> </p><br><h2 id="vyvod">  Conclusion </h2><br><p>  En fait, l'application ne devrait pas stocker de données sensibles, ou elles devraient être accessibles uniquement après l'authentification de l'utilisateur.  Cependant, il arrive que la logique métier oblige les développeurs à stocker des jetons, des clés et des éléments spécifiques de la logique du code dans l'application.  J'espère que cet article vous aidera si vous ne voulez pas partager de telles données sensibles et être un «livre ouvert» pour les scribes. </p><br><p>  Je crois que l'obscurcissement est un élément structurel important de toute application moderne. </p><br><p>  Réfléchissez bien aux problèmes de masquage de code et ne cherchez pas de moyens faciles!  :) </p><br><p>  <em>Soit dit en passant, merci à l'utilisateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">miproblema</a> pour l'aide dans certains problèmes.</em>  <em>Abonnez-vous à sa chaîne de télégramme, c'est intéressant là-bas.</em> </p><br><p>  <em>Et merci également aux utilisateurs de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">sverkunchik</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">SCaptainCAP</a> pour leur aide dans l'édition de l'article.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436908/">https://habr.com/ru/post/fr436908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436892/index.html">Tutoriel React, partie 11: Formation de balisage dynamique et méthode du tableau de cartes</a></li>
<li><a href="../fr436894/index.html">Apocalypse informatique rampante. De nouveaux services cloud laisseront certains ingénieurs sans emploi</a></li>
<li><a href="../fr436896/index.html">docker-pretty-ps - enfin un ps docker lisible</a></li>
<li><a href="../fr436900/index.html">FunTech ML-meetup</a></li>
<li><a href="../fr436904/index.html">Seuil de 32 Ko pour les données dans la ROM des microcontrôleurs AVR</a></li>
<li><a href="../fr436910/index.html">Conseils pour créer des workflows personnalisés dans GitLab CI</a></li>
<li><a href="../fr436912/index.html">Tendances CRM 2019: amusant à lire, dangereux à croire</a></li>
<li><a href="../fr436914/index.html">Problèmes de croissance de démarrage - Surveillance</a></li>
<li><a href="../fr436916/index.html">VShard - mise à l'échelle horizontale dans Tarantool</a></li>
<li><a href="../fr436918/index.html">Création d'un jeu pour Game Boy, partie 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>