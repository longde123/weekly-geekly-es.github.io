<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📇 🚥 👨 Android Jetpack Composer la première impression 🤱🏾 🏂🏿 👿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Après avoir vu un exposé sur Android Jetpack Compose sur Google IO 2019, j'ai voulu l'essayer tout de suite. De plus, l'approche qui y était mise en œ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android Jetpack Composer la première impression</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461101/"><p>  Après avoir vu un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exposé sur Android Jetpack Compose</a> sur Google IO 2019, j'ai voulu l'essayer tout de suite.  De plus, l'approche qui y était mise en œuvre rappelait beaucoup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Flutter, ce qui m'intéressait plus tôt</a> . </p><br><p><img src="https://habrastorage.org/webt/i1/-6/fz/i1-6fzjfxbzx-ajpwg-5y7ey7cq.png"></p><a name="habracut"></a><br><p> La bibliothèque Compose elle-même est au stade pré-alpha, donc peu de documentation et d'articles à ce sujet sont disponibles.  Ensuite, je vais compter sur plusieurs ressources que j'ai réussi à trouver, plus la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèque open source</a> . </p><br><p>  Ces ressources sont: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Développeurs Android dans les coulisses: épisode 115: Jetpack Compose</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Composer à partir des premiers principes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Plonger dans Jetpack Composer</a> </li></ul><br><h1 id="chto-takoe-android-jetpack-compose">  Qu'est-ce que Android Jetpack Compose? </h1><br><p>  Auparavant, l'intégralité de l'interface utilisateur Android était basée sur la classe View.  C'est le cas depuis les débuts d'Android.  Et à cet égard, de nombreux défauts hérités et architecturaux se sont accumulés, qui pourraient être améliorés.  Mais faire cela est assez difficile sans casser tout le code écrit sur leur base. </p><br><p>  Ces dernières années, de nombreux nouveaux concepts sont apparus dans le monde des applications clientes (y compris les tendances Frontend), de sorte que l'équipe de Google est allée radicalement et a réécrit le niveau d'interface utilisateur entier dans Android à partir de zéro.  La bibliothèque Android Jetpack Compose est donc apparue, qui comprend des astuces conceptuelles de React, Litho, Vue, Flutter et bien d'autres. </p><br><p>  Passons en revue certaines des fonctionnalités de l'interface utilisateur existante et comparons-la avec Compose. </p><br><h3 id="1--nezavisimost-ot-relizov-android">  1. Indépendance par rapport aux versions Android </h3><br><p>  L'interface utilisateur existante est étroitement liée à la plate-forme.  Lorsque les premiers composants de Material Design sont apparus, ils ne fonctionnaient qu'avec Android 5 (API21) et versions supérieures.  Pour travailler sur des versions plus anciennes du système, vous devez utiliser la bibliothèque de support. </p><br><p>  Compose fait partie de Jetpack, ce qui le rend indépendant des versions du système et peut être utilisé même dans les anciennes versions d'Android (au moins avec API21). </p><br><h3 id="2-ves-api-na-kotlin">  2. L'ensemble de l'API Kotlin </h3><br><p>  Auparavant, vous deviez gérer différents fichiers pour créer une interface utilisateur.  Nous avons décrit le balisage en xml, puis utilisé le code Java / Kotlin pour le faire fonctionner.  Ensuite, nous sommes revenus sur d'autres fichiers xml afin de définir des thèmes, l'animation, la navigation, ... Et même essayé d'écrire du code en xml (Data Binding). </p><br><p>  L'utilisation de Kotlin vous permet d'écrire des interfaces utilisateur de style déclaratif directement dans du code au lieu de xml. </p><br><h3 id="3-composable--kompozitnyy-ispolzovanie-kompozicii-vmesto-nasledovaniya">  3. Composable = Composite: utiliser la composition au lieu de l'héritage </h3><br><p>  La création d'éléments d'interface utilisateur personnalisés peut être assez lourde.  Nous devons hériter de View ou de son descendant et prendre soin de nombreuses propriétés importantes avant de démarrer correctement.  Par exemple, la classe TextView contient environ 30 000 lignes de code Java.  Cela est dû au fait qu'il contient en lui-même beaucoup de logique inutile héritée par les éléments descendants. </p><br><p>  Composer est venu d'un autre côté, remplaçant l'héritage par la composition. </p><br><p> <code>Padding</code> est le mieux adapté pour illustrer de quoi il s'agit: </p><br><p>  Dans l'interface utilisateur existante, afin de rendre le <code>TextView</code> retrait à <code>30dp</code> : </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/683/ca2/b25/683ca2b253a68f623931819b8185ab89.png" alt="image" width="500"></div><br><p>  nous devons écrire le code suivant: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextView</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@+id/simpleTextView"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"wrap_content"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"wrap_content"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:background</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@color/cyan"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:padding</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"30dp"</span></span></span><span class="hljs-tag"> &lt;</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">------------------------</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">NOTE</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">THIS</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Drag or tap on the seek bar"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  Cela signifie que quelque part dans TextView.java ou ses superclasses, il existe une logique qui sait compter et dessiner des retraits. </p><br><p>  Voyons comment vous pouvez faire de même dans Compose: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// note: the cyan background color is omitted for now to keep it simple Padding(30.dp) { Text("Drag or tap on the seek bar") }</span></span></code> </pre> <br><p>  <strong>Changements</strong> <br>  <code>TextView</code> devenu juste <code>Text()</code> .  La propriété <code>android:padding</code> s'est transformée en un <code>android:padding</code> qui enveloppe le <code>Text</code> . </p><br><p>  <strong>Les avantages</strong> <br>  Ainsi, <code>Text</code> est uniquement responsable du rendu du texte lui-même.  Il ne sait pas compter les retraits.  <code>Padding</code> , en revanche, n'est responsable que du rembourrage et rien de plus.  Il peut être utilisé autour de tout autre élément. </p><br><h3 id="4-odnonapravlennyy-potok-dannyh">  4. Flux de données unidirectionnel </h3><br><p>  Le flux de données unidirectionnel est un concept important si nous parlons, par exemple, de contrôler l'état d'une <code>CheckBox</code> dans un système d'interface utilisateur existant.  Lorsque l'utilisateur appuie sur la <code>CheckBox</code> , son état devient <code>checked = true</code> : la classe met à jour l'état View et appelle un rappel à partir du code qui surveille le changement d'état. </p><br><p>  Ensuite, dans le code lui-même, par exemple, dans <code>ViewModel</code> , vous devez mettre à jour la variable d' <code>state</code> correspondante.  Vous disposez maintenant de deux copies de l'état activé, ce qui peut créer des problèmes.  Par exemple, la modification de la valeur de la variable d' <code>state</code> à l'intérieur du <code>ViewModel</code> entraînera la mise <code>CheckBox</code> jour du <code>CheckBox</code> , qui peut se terminer par une boucle sans fin.  Pour éviter cela, nous devrons trouver une sorte de béquille. </p><br><p>  L'utilisation de Compose aidera à résoudre ces problèmes, car elle est basée sur le principe de l'unicité.  Le changement d'état sera traité dans le cadre: nous donnons simplement le modèle de données vers l'intérieur.  De plus, le composant de Compose ne modifie plus son état de lui-même.  Au lieu de cela, il n'appelle que le rappel, et maintenant c'est la tâche de l'application de changer l'interface utilisateur. </p><br><h3 id="5-uluchshenie-otladki">  5. Amélioration du débogage </h3><br><p>  Étant donné que l'interface utilisateur entière est maintenant écrite dans Kotlin, vous pouvez maintenant déboguer l'interface utilisateur.  Je n'ai pas essayé cela moi-même, mais dans le podcast, ils ont dit que le débogueur et les points d'arrêt fonctionnent dans Compose. </p><br><h1 id="hvatit-slov-pokazhite-kod">  Assez de mots, montrez le code </h1><br><p>  Je sais, je veux voir rapidement à quoi ressemble l'interface utilisateur dans le code (spoiler: très similaire à Flutter si vous avez essayé d'écrire dessus). </p><br><p>  Nous commencerons par créer des <code>View</code> simples, puis comparerons leur apparence dans l'interface utilisateur existante et dans Compose. </p><br><h3 id="1-framelayout-vs-wrap--padding--background">  1. <code>FrameLayout</code> vs <code>Wrap + Padding + Background</code> </h3><br><p>  Nous réutilisons notre exemple ci-dessus et essayons de rendre ce <code>TextView</code> retrait à <code>30dp</code> avec un fond turquoise: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/683/ca2/b25/683ca2b253a68f623931819b8185ab89.png" alt="`TextView` indenté en` 30dp` et fond turquoise" width="500"></div><br><p>  Interface utilisateur existante: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextView</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@+id/simpleTextView"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"wrap_content"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"wrap_content"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:background</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@color/cyan"</span></span></span><span class="hljs-tag"> &lt;</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">--------------</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">NOTE</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">THIS</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:padding</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"30dp"</span></span></span><span class="hljs-tag"> &lt;</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">------------------------</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">AND</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">THIS</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Drag or tap on the seek bar"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  Regardez maintenant le code qui fait la même chose dans Compose: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Wrap { Padding(<span class="hljs-number"><span class="hljs-number">30</span></span>.dp) { DrawRectangle(color = Color.Cyan) Text(<span class="hljs-string"><span class="hljs-string">"Drag or tap on the seek bar"</span></span>) } } }</code> </pre> <br><p>  Voici quelques nouveautés.  Étant donné que <code>Text</code> ne connaît que le rendu du texte, il ne se soucie pas du remplissage et de l'arrière-plan.  Par conséquent, pour les ajouter, nous devons utiliser trois fonctions distinctes: </p><br><ul><li>  <code>DrawRectangle</code> arrière-plan </li><li>  <code>Padding</code> </li><li>  <code>Wrap</code> est une fonction qui superpose des paramètres comme <code>FrameLayout</code> . </li></ul><br><p>  C'est facile.  Mais il est légèrement différent du système d'interface utilisateur existant auquel nous sommes tous habitués. </p><br><h3 id="2-vertikalnyy-linearlayout-vs-column">  2. <code>LinearLayout</code> vs <code>Column</code> </h3><br><p>  Essayons maintenant de faire quelque chose d'équivalent à notre bon vieux <code>LinearLayout</code> . <br>  Pour placer deux éléments l'un en dessous de l'autre, comme dans l'image ci-dessous, nous pouvons utiliser <code>Column</code> : </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32c/9e9/29e/32c9e929e70b2f811aad977075a79e87.png" alt="Deux éléments l'un en dessous de l'autre" width="500"></div><br><p>  Le code ressemblera à ceci: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormDemo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Column(crossAxisAlignment = CrossAxisAlignment.Start) { Text(<span class="hljs-string"><span class="hljs-string">"Click the button below: "</span></span>) Button(text = <span class="hljs-string"><span class="hljs-string">"Next"</span></span>) } }</code> </pre> <br><p>  Imbriqué dans l'élément <code>Column</code> sera situé verticalement l'un au-dessous de l'autre. </p><br><h3 id="2a-otstupy">  2a.  Indentation </h3><br><p>  Vous avez probablement remarqué que le texte et le bouton sont trop proches du bord.  Par conséquent, ajoutez un <code>Padding</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormDemo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Padding(<span class="hljs-number"><span class="hljs-number">10</span></span>.dp) { <span class="hljs-comment"><span class="hljs-comment">//   Column(crossAxisAlignment = CrossAxisAlignment.Start) { Text("Click the button below: ") Button(text = "Next") } } }</span></span></code> </pre> <br><p>  Ça a l'air mieux: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d1/d83/053/4d1d83053a411a9858b0feedab75de4a.png" alt="Deux éléments en retrait l'un au-dessous de l'autre" width="500"></div><br><h3 id="2b-intervaly">  2b.  Intervalles </h3><br><p>  Nous pouvons également ajouter une indentation entre le <code>Text</code> et le <code>Button</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormDemo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Padding(<span class="hljs-number"><span class="hljs-number">10</span></span>.dp) { Column(crossAxisAlignment = CrossAxisAlignment.Start) { Text(<span class="hljs-string"><span class="hljs-string">"Click the button below: "</span></span>) HeightSpacer(<span class="hljs-number"><span class="hljs-number">10</span></span>.dp) <span class="hljs-comment"><span class="hljs-comment">//    Button(text = "Next") } } }</span></span></code> </pre> <br><p>  À quoi ressemble notre écran maintenant: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2be/3d8/709/2be3d8709c5f83c72f15ab9b450e0ba6.png" alt="Deux éléments, l'un en dessous de l'autre, en retrait et espacés" width="500"></div><br><h3 id="2c-gorizontalnyy-linearlayout-vs-row">  2c.  <code>LinearLayout</code> vs <code>Row</code> </h3><br><p>  Placez le deuxième bouton à côté du premier: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/351/842/b31/351842b31ea3fd8ec51a7585ea8efcad.png" alt="Ajout d'un deuxième bouton" width="500"></div><br><p>  Code pour cela: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormDemo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Padding(<span class="hljs-number"><span class="hljs-number">10</span></span>.dp) { Column(crossAxisAlignment = CrossAxisAlignment.Start) { Text(<span class="hljs-string"><span class="hljs-string">"Click the button below: "</span></span>) HeightSpacer(<span class="hljs-number"><span class="hljs-number">10</span></span>.dp) Row { <span class="hljs-comment"><span class="hljs-comment">//   Button(text = "Back") //   WidthSpacer(10.dp) //    Button(text = "Next") } } } }</span></span></code> </pre> <br><p>  À l'intérieur de la <code>Row</code> deux boutons seront horizontaux.  <code>WidthSpacer</code> ajoute une distance entre eux. </p><br><h3 id="2d-gravity-vs-alignment">  2d.  <code>Gravity</code> vs <code>Alignment</code> </h3><br><p>  Alignez nos éléments au centre, comme le fait la <code>gravity</code> dans l'interface utilisateur actuelle.  Pour montrer les différences, je commenterai les anciennes lignes et les remplacerai par de nouvelles: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormDemo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Padding(<span class="hljs-number"><span class="hljs-number">10</span></span>.dp) { <span class="hljs-comment"><span class="hljs-comment">// Column(crossAxisAlignment = CrossAxisAlignment.Start) { Column(crossAxisAlignment = CrossAxisAlignment.Center) { //  Text("Click the button below: ") HeightSpacer(10.dp) // Row { Row(mainAxisSize = FlexSize.Min) { //    Button(text = "Back") WidthSpacer(10.dp) Button(text = "Next") } } } }</span></span></code> </pre> <br><p>  Nous réussirons: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/e5c/ad7/346e5cad7f27352c91076001d2bf5cf0.png" alt="Alignement central" width="500"></div><br><p>  Avec <code>crossAxisAlignment = CrossAxisAlignment.Center</code> les éléments imbriqués seront centrés horizontalement.  Nous devons également définir le paramètre <code>Row</code> sur <code>mainAxisSize = FlexSize.Min</code> , similaire en comportement à <code>layout_width = wrap_content</code> , afin qu'il ne s'étende pas sur l'écran en raison de la valeur par défaut <code>mainAxisSize = FlexSize.Max</code> , qui se comporte comme <code>layout_width = match_parent</code> . </p><br><h3 id="2d-zamechanie">  2d.  Remarque </h3><br><p>  D'après ce que nous avons vu dans les exemples ci-dessus, vous pouvez voir que tous les éléments sont constitués de fonctions distinctes: le <code>padding</code> est une fonction distincte, l' <code>spacer</code> est une fonction distincte, au lieu d'être des propriétés à l'intérieur du <code>Text</code> , du <code>Button</code> ou de la <code>Column</code> . </p><br><p>  Des éléments plus complexes tels que <code>RecyclerView</code> ou <code>ConstraintLayout</code> sont en cours de développement: je n'ai donc pas pu trouver d'exemple avec eux dans les sources de démonstration. </p><br><h3 id="3stili-i-temy">  3. Styles et thèmes </h3><br><p>  Vous avez probablement remarqué que les boutons ci-dessus sont violets par défaut.  En effet, ils utilisent des styles par défaut.  Voyons comment fonctionnent les styles dans Compose. </p><br><p>  Dans les exemples ci-dessus, <code>FormDemo</code> balisé avec l'annotation <code>@Composable</code> .  Je vais maintenant montrer comment cet élément est utilisé dans <code>Activity</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) setContent { CraneWrapper{ MaterialTheme { FormDemo() } } } }</code> </pre> <br><p>  Au lieu de la fonction <code>setContentView()</code> , nous utilisons <code>setContent()</code> , une fonction d'extension de la bibliothèque <code>Compose.kt</code> . </p><br><p>  <code>CraneWrapper</code> contient l'arborescence Composer et donne accès à <code>Context</code> , <code>Density</code> , <code>FocusManager</code> et <code>TextInputService</code> . </p><br><p>  <code>MaterialTheme</code> vous permet de personnaliser le thème des éléments. </p><br><p>  Par exemple, je peux changer la couleur primaire du thème en marron comme suit: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) setContent { CraneWrapper{ <span class="hljs-comment"><span class="hljs-comment">// MaterialTheme { MaterialTheme(colors = MaterialColors(primary = Color.Maroon)) { FormDemo() } } } }</span></span></code> </pre> <br><p>  Maintenant, notre écran ressemblera à ceci: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f1/783/c01/8f1783c0159c45c314c05724969d7000.png" alt="Bordeaux comme couleur primaire" width="500"></div><br><p>  Autres couleurs et polices pouvant être modifiées: <a href="">MaterialTheme.kt # 57</a> </p><br><p>  Rally Activity fournit un bon exemple de la façon de personnaliser un sujet: <a href="">du code source à RallyTheme.kt</a> </p><br><h1 id="chto-posmotretpochitat">  Que voir / lire </h1><br><p>  Si vous en voulez plus, vous pouvez assembler l'exemple de projet selon les <a href="">instructions ici</a> . </p><br><p>  Comme l'écrivent les utilisateurs de Windows, il n'y a maintenant aucun moyen officiel de lancer Compose, mais il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">guide</a> non officiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de kotlinlang Slack</a> . </p><br><p>  Des questions sur Compose peuvent être posées aux développeurs de la chaîne <code>#compose</code> kotlinlang Slack. </p><br><p>  Laissez d'autres liens dans les commentaires - les plus utiles seront ajoutés ici. </p><br><h1 id="vyvody">  Conclusions </h1><br><p>  Le développement de cette bibliothèque bat son plein, donc toutes les interfaces présentées ici sont sujettes à changement.  Il y a encore beaucoup de choses que vous pouvez apprendre dans le code source, comme <code>@Model</code> et le flux de données unidirectionnel (flux de données unidirectionnel).  C'est peut-être un sujet pour de futurs articles. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461101/">https://habr.com/ru/post/fr461101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461087/index.html">Générer des donjons et des grottes pour mon jeu</a></li>
<li><a href="../fr461091/index.html">Lampes LED Camelion</a></li>
<li><a href="../fr461093/index.html">Nouvelles du monde d'OpenStreetMap n ° 469 (07/09/2019 - 07/07/2019)</a></li>
<li><a href="../fr461095/index.html">Apollo Guidance Computer - logiciel d'architecture et de système. Partie 1</a></li>
<li><a href="../fr461099/index.html">Jeu AirAttack! - notre première expérience de développement VR</a></li>
<li><a href="../fr461105/index.html">5 plugins webpack utiles</a></li>
<li><a href="../fr461107/index.html">Dosimètre pour Seryozha. Partie II Tubes du centenaire vs atome pacifique</a></li>
<li><a href="../fr461113/index.html">Cinq ans d'utilisation de C ++ pour des projets de microcontrôleurs en production</a></li>
<li><a href="../fr461121/index.html">Petites expériences multitâches dans un microcontrôleur</a></li>
<li><a href="../fr461125/index.html">La tâche de création de codes numériques séquentiels pour la numérotation des messages dans le code source dans Visual Studio (ex. C #)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>