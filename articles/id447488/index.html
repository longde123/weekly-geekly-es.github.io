<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‚ğŸ½ ğŸ¬ â›„ï¸ Mematahkan Retak Sederhana dengan Ghidra - Bagian 2 ğŸ‘¨ğŸ»â€âœˆï¸ â–¶ï¸ ğŸŒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di bagian pertama artikel, menggunakan Ghidra, kami secara otomatis menganalisis program crack sederhana (yang kami unduh dari crackmes.one). Kami men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mematahkan Retak Sederhana dengan Ghidra - Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447488/">  Di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> artikel, menggunakan Ghidra, kami secara otomatis menganalisis program crack sederhana (yang kami unduh dari crackmes.one).  Kami menemukan cara mengubah nama fungsi "tidak dapat dipahami" tepat di daftar dekompiler, dan juga memahami algoritme program "tingkat atas", mis.  yang dilakukan oleh <b>main ()</b> . <br><br>  Pada bagian ini, kami, seperti yang saya janjikan, akan mengambil analisis fungsi <strong>_construct_key ()</strong> , yang, seperti yang kami <strong>ketahui</strong> , bertanggung jawab untuk membaca file biner yang ditransfer ke program dan memeriksa data yang dibaca. <br><a name="habracut"></a><br><h2>  Langkah 5 - Ikhtisar Fungsi _construct_key () </h2><br>  Mari kita lihat daftar lengkap fungsi ini segera: <br><br><div class="spoiler">  <b class="spoiler_title">Listing _construct_key ()</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ** __cdecl _construct_key(FILE *param_1) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVar1; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sVar2; uint uVar3; uint local_3c; byte local_36; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> local_35; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_34; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *local_30 [<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *local_20; undefined4 local_19; undefined local_15; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **local_14; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_10; local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)__prepare_key(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (local_14 == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { local_19 = <span class="hljs-number"><span class="hljs-number">0</span></span>; local_15 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_19,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,param_1); iVar1 = _text((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;local_19,*(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>],<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iVar1 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { _text(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); _text(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>) == <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; (*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>) == <span class="hljs-number"><span class="hljs-number">5</span></span>)) { local_30[<span class="hljs-number"><span class="hljs-number">0</span></span>] = *local_14; local_30[<span class="hljs-number"><span class="hljs-number">1</span></span>] = *local_14 + <span class="hljs-number"><span class="hljs-number">0x10c</span></span>; local_30[<span class="hljs-number"><span class="hljs-number">2</span></span>] = *local_14 + <span class="hljs-number"><span class="hljs-number">0x218</span></span>; local_30[<span class="hljs-number"><span class="hljs-number">3</span></span>] = *local_14 + <span class="hljs-number"><span class="hljs-number">0x324</span></span>; local_20 = *local_14 + <span class="hljs-number"><span class="hljs-number">0x430</span></span>; local_10 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (local_10 &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { local_35 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_35,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*local_30[local_10] != local_35) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } local_36 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_36,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (local_36 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } *(uint *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>) = (uint)local_36; _text(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,*(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>),param_1); sVar2 = _text(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sVar2 != *(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>)) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } local_3c = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_3c,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); local_3c = local_3c + <span class="hljs-number"><span class="hljs-number">7</span></span>; uVar3 = _text(param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (local_3c &lt; uVar3) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } *(uint *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x108</span></span>) = local_3c; _text(param_1,local_3c,<span class="hljs-number"><span class="hljs-number">0</span></span>); local_10 = local_10 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } local_34 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_34,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)(*local_14 + <span class="hljs-number"><span class="hljs-number">0x53c</span></span>) == local_34) { _text(<span class="hljs-string"><span class="hljs-string">"Markers seem to still exist"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _free_key(local_14); local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _free_key(local_14); local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _free_key(local_14); local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> local_14; }</code> </pre> <br></div></div><br>  Dengan fungsi ini kita akan melakukan hal yang sama seperti sebelumnya dengan <strong>main ()</strong> - untuk permulaan kita akan membahas panggilan fungsi "terselubung".  Seperti yang diharapkan, semua fungsi ini berasal dari pustaka standar C. Saya tidak akan menjelaskan prosedur untuk mengganti nama fungsi lagi - kembali ke bagian pertama artikel, jika perlu.  Sebagai hasil dari penggantian nama, fungsi standar berikut â€œditemukanâ€: <br><br><ul><li>  fread () </li><li>  strncmp () </li><li>  strlen () </li><li>  ftell () </li><li>  fseek () </li><li>  menempatkan () </li></ul><br>  Kami mengganti nama fungsi pembungkus yang sesuai dalam kode kami (yang dengan tersembunyi disembunyikan di belakang kata <strong>_text</strong> ) dengan menambahkan indeks 2 (sehingga tidak akan ada kebingungan dengan fungsi-C asli).  Hampir semua fungsi ini untuk bekerja dengan aliran file.  Tidak mengherankan - pandangan sekilas pada kode sudah cukup untuk memahami bahwa ia secara berurutan membaca data dari suatu file (deskriptor yang diteruskan ke fungsi sebagai satu-satunya parameter) dan membandingkan data yang dibaca dengan array dua dimensi tertentu dari byte <strong>local_14</strong> byte. <br><br>  Mari kita asumsikan bahwa array ini berisi data untuk verifikasi kunci.  Sebut saja, katakan <strong>key_array</strong> .  Karena Hydra memungkinkan Anda untuk mengubah nama tidak hanya fungsi, tetapi juga variabel, kami akan menggunakan ini dan mengubah nama <strong>local_14 yang</strong> tidak dapat dipahami menjadi <strong>key_array</strong> yang lebih dimengerti.  Ini dilakukan dengan cara yang sama seperti untuk fungsi: melalui menu tombol kanan mouse ( <strong>Ganti nama lokal</strong> ) atau dengan tombol <strong>L</strong> dari keyboard. <br><br>  Jadi, segera setelah deklarasi variabel lokal, fungsi tertentu <strong>_prepare_key () dipanggil</strong> : <br><br><pre> <code class="cpp hljs">key_array = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)__prepare_key(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key_array == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { key_array = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; }</code> </pre><br>  Kami akan kembali ke <strong>_prepare_key ()</strong> , ini adalah tingkat ke-3 bersarang dalam hierarki panggilan kami: <strong>main () -&gt; _construct_key () -&gt; _prepare_key ()</strong> .  Sementara itu, kami menerima bahwa itu menciptakan dan entah bagaimana menginisialisasi array dua dimensi "uji" ini.  Dan hanya jika array ini tidak kosong, fungsi melanjutkan kerjanya, sebagaimana dibuktikan oleh blok <b>lain</b> segera setelah kondisi di atas. <br><br>  Selanjutnya, program membaca 4 byte pertama dari file dan membandingkannya dengan bagian yang sesuai dari array <b>key_array</b> .  (Kode di bawah ini setelah penggantian nama, termasuk variabel <b>local_19,</b> saya <b>beri</b> nama <b>pertama_4bytes</b> .) <br><br><pre> <code class="cpp hljs">first_4bytes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   4    */</span></span> fread2(&amp;first_4bytes,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,param_1); <span class="hljs-comment"><span class="hljs-comment">/*   key_array[1][0...3] */</span></span> iVar1 = strncmp2((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;first_4bytes,*(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>],<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iVar1 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ... }</code> </pre><br>  Dengan demikian, eksekusi lebih lanjut hanya terjadi jika 4 byte pertama bersamaan (ingat ini).  Kemudian kita membaca 2 blok 2-byte dari file (dan <b>key_array yang</b> sama digunakan sebagai buffer untuk menulis data): <br><br><pre> <code class="cpp hljs">fread2(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); fread2(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1);</code> </pre><br>  Dan lagi - selanjutnya fungsi hanya berfungsi jika kondisi berikutnya benar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>) == <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; (*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>) == <span class="hljs-number"><span class="hljs-number">5</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//   ... }</span></span></code> </pre><br>  Sangat mudah untuk melihat bahwa yang pertama dari blok 2-byte yang dibaca di atas harus nomor 5, dan yang kedua harus nomor 4 (tipe data <b>pendek</b> hanya menempati 2 byte pada platform 32-bit). <br><br>  Berikutnya adalah ini: <br><br><pre> <code class="cpp hljs">local_30[<span class="hljs-number"><span class="hljs-number">0</span></span>] = *key_array; <span class="hljs-comment"><span class="hljs-comment">// .. key_array[0] local_30[1] = *key_array + 0x10c; local_30[2] = *key_array + 0x218; local_30[3] = *key_array + 0x324; local_20 = *key_array + 0x430;</span></span></code> </pre><br>  Di sini kita melihat bahwa array <b>local_30</b> (dideklarasikan sebagai char * local_30 [4]) berisi offset dari pointer <b>key_array</b> .  Yaitu, <b>local_30</b> adalah larik garis penanda tempat data dari file tersebut mungkin akan dibaca.  Berdasarkan asumsi ini, saya mengganti nama <b>local_30</b> menjadi <b>marker</b> .  Di bagian kode ini, hanya baris terakhir yang tampak sedikit mencurigakan, di mana penugasan offset terakhir (pada indeks 0x430, mis. 1072) dilakukan bukan oleh elemen <b>marker</b> berikutnya, tetapi oleh variabel <b>local_20 yang</b> terpisah ( <b>char *</b> ).  Tapi kita akan mengetahuinya, tetapi untuk sekarang - mari kita lanjutkan! <br><br>  Selanjutnya kita sedang menunggu siklus: <br><br><pre> <code class="cpp hljs"> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// local_10   i while (i &lt; 5) { // ... i = i + 1; }</span></span></code> </pre><br>  Yaitu  Hanya 5 iterasi dari 0 hingga 4 inklusif.  Dalam loop, membaca dari file dan memeriksa kepatuhan dengan array <b>penanda</b> kami segera dimulai: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c_marker = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_35 /*  .    */ fread2(&amp;c_marker, 1, 1, param_1); if (*markers[i] != c_marker) { /*    -      */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  Yaitu, byte berikutnya dari file tersebut dibaca ke dalam variabel <b>c_marker</b> (dalam kode dekompilasi asli - <b>local_35</b> ) dan diperiksa untuk kepatuhan dengan karakter pertama dari elemen <b>penanda</b> ke-i.  Dalam kasus ketidakcocokan, array <b>key_array</b> adalah nol dan pointer ganda kosong dikembalikan.  Lebih jauh di sepanjang kode, kita melihat bahwa ini dilakukan setiap kali data yang dibaca tidak cocok dengan data verifikasi. <br><br>  Tetapi di sini, seperti yang mereka katakan, "anjing dimakamkan."  Mari kita perhatikan siklus ini lebih dekat.  Ini memiliki 5 iterasi, seperti yang kami ketahui.  Anda dapat memeriksa ini jika ingin dengan melihat kode assembler: <br><br><img src="https://habrastorage.org/webt/si/b4/q8/sib4q8jsxe2zyxpxi2gcwy0vfba.png"><br><br><img src="https://habrastorage.org/webt/tr/8q/oh/tr8qoh9ayg-7v9t6rv1vwtsuy_c.png"><br><br>  Memang, perintah CMP membandingkan nilai variabel <b>local_10</b> (kami sudah memiliki <b>i</b> ) dengan angka 4 dan jika nilainya <i>kurang dari atau sama dengan</i> 4 (perintah JLE), transisi ke label <b>LAB_004017eb dibuat</b> , yaitu.  mulai dari tubuh siklus.  Yaitu  kondisi akan terpenuhi untuk <b>i</b> = 0, 1, 2, 3, dan 4 - hanya 5 iterasi!  Semuanya akan baik-baik saja, tetapi <b>marker</b> juga diindeks oleh variabel ini dalam satu lingkaran, dan bagaimanapun, array ini dideklarasikan dengan hanya 4 elemen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *markers [<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre><br>  Jadi, seseorang jelas-jelas berusaha menipu seseorang :) Ingat, saya mengatakan bahwa kalimat ini meragukan? <br><br><pre> <code class="cpp hljs">local_20 = *key_array + <span class="hljs-number"><span class="hljs-number">0x430</span></span>;</code> </pre><br>  Seperti itu saja!  Lihat saja seluruh daftar fungsi dan coba temukan setidaknya satu referensi lagi ke variabel <b>local_20</b> .  Dia tidak ada di sana!  Kami menyimpulkan dari ini: offset ini juga harus disimpan dalam array <b>markers</b> , dan array itu sendiri harus mengandung 5 elemen.  Mari kita perbaiki.  Pergi ke deklarasi variabel, <b>tekan Ctrl + L</b> (ketik ulang variabel) dan dengan berani mengubah ukuran array ke 5: <br><br><img src="https://habrastorage.org/webt/t0/sq/xw/t0sqxw-hbw5dqo9mca3m43r5cei.png"><br><br>  Selesai  Gulir ke bawah ke kode untuk menetapkan offset pointer ke <b>spidol</b> , dan - lihatlah!  - variabel tambahan yang tidak bisa dipahami menghilang dan semuanya jatuh pada tempatnya: <br><br><pre> <code class="cpp hljs">markers[<span class="hljs-number"><span class="hljs-number">0</span></span>] = *key_array; markers[<span class="hljs-number"><span class="hljs-number">1</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x10c</span></span>; markers[<span class="hljs-number"><span class="hljs-number">2</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x218</span></span>; markers[<span class="hljs-number"><span class="hljs-number">3</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x324</span></span>; markers[<span class="hljs-number"><span class="hljs-number">4</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x430</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ...   !</span></span></code> </pre><br>  Kembali ke <b>loop sementara</b> kami (dalam kode sumber ini kemungkinan besar akan <b>untuk</b> , tetapi kami tidak peduli).  Selanjutnya, byte dari file tersebut dibaca lagi dan nilainya diperiksa: <br><br><pre> <code class="cpp hljs">byte n_strlen1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_36 /*  .    */ fread2(&amp;n_strlen1,1,1,param_1); if (n_strlen1 == 0) { /*      */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  OK, <b>n_strlen1</b> ini pasti bukan nol.  Mengapa  Anda akan melihat sekarang, tetapi pada saat yang sama Anda akan mengerti mengapa saya memberi variabel ini nama berikut: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   n_strlen1)  (markers[i] + 0x104) */</span></span> *(uint *)(markers[i] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>) = (uint)n_strlen1; <span class="hljs-comment"><span class="hljs-comment">/*    (n_strlen1)  (--&gt;  ?) */</span></span> fread2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,*(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)(markers[i] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>),param_1); n_strlen2 = strlen2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   sVar2 if (n_strlen2 != *(size_t *)(markers[i] + 0x104)) { /*    (n_strlen2)  == n_strlen1 */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  Saya menambahkan komentar yang semuanya harus jelas.  <b>N_strlen1</b> byte dibaca dari file dan disimpan sebagai urutan karakter (yaitu string) ke dalam array <b>penanda [i]</b> - yaitu, setelah "stop-simbol" yang sesuai, yang sudah ditulis di sana dari <b>key_array</b> .  Menyimpan nilai <b>n_strlen1</b> dalam <b>marker [i]</b> pada offset 0x104 (260) tidak memainkan peran apa pun di sini (lihat baris pertama dalam kode di atas).  Bahkan, kode ini dapat dioptimalkan sebagai berikut (dan tentu saja ini terjadi dalam kode sumber): <br><br><pre> <code class="cpp hljs">fread2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) n_strlen1, param_1); n_strlen2 = strlen2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n_strlen2 != (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) n_strlen1) { ... }</code> </pre><br>  Itu juga memeriksa bahwa panjang dari baris baca adalah <b>n_strlen1</b> .  Ini mungkin tampak tidak perlu, mengingat bahwa parameter ini diteruskan ke fungsi <b>ketakutan</b> , tetapi <b>ketakutan</b> membaca <i>tidak lebih dari</i> begitu banyak byte yang ditentukan dan dapat membaca kurang dari yang ditunjukkan, misalnya, dalam hal memenuhi penanda akhir file (EOF).  Artinya, semuanya ketat: panjang garis (dalam byte) ditunjukkan dalam file, kemudian garis itu sendiri berjalan - dan tepat 5 kali.  Tapi kita maju dari diri kita sendiri. <br><br>  Lebih lanjut menyirami kode ini (yang saya juga segera berkomentar): <br><br><pre> <code class="cpp hljs">uint n_pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_3c /*  .    */ fread2(&amp;n_pos,1,1,param_1); /*   7 */ n_pos = n_pos + 7; /*     */ uint n_filepos = ftell2(param_1); //   uVar3 if (n_pos &lt; n_filepos) { /* n_pos   &gt;= n_filepos */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  Ini masih lebih sederhana di sini: kita mengambil byte berikutnya dari file, menambahkan 7 dan membandingkan nilai yang dihasilkan dengan posisi kursor saat ini dalam aliran file yang diperoleh oleh fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ftell ()</a> .  Nilai <b>n_pos</b> harus tidak kurang dari posisi kursor (mis. Offset dalam byte dari awal file). <br><br>  Baris terakhir dalam loop: <br><br><pre> <code class="cpp hljs">fseek2(param_1,n_pos,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Yaitu  mengatur ulang kursor file (dari awal) ke posisi yang ditunjukkan oleh <b>n_pos</b> oleh fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fseek ()</a> .  OK, kami melakukan semua operasi ini dalam loop 5 kali.  Fungsi <b>_construct_key () diakhiri dengan</b> kode berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_lastmarker = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_34 /*   4    (int32) */ fread2(&amp;i_lastmarker,4,1,param_1); if (*(int *)(*key_array + 0x53c) == i_lastmarker) { /*    == key_array[0][1340] ...   :) */ puts2("Markers seem to still exist"); } else { _free_key(key_array); key_array = (char **)0x0; }</span></span></code> </pre><br>  Dengan demikian, blok data terakhir dalam file harus berupa nilai integer 4-byte dan harus sama dengan nilai pada <b>key_array [0] [1340]</b> .  Dalam hal ini, kami akan menerima pesan ucapan selamat di konsol.  Jika tidak, array kosong masih kembali tanpa pujian :) <br><br><h2>  Langkah 6 - Ikhtisar fungsi __prepare_key () </h2><br>  Kami hanya memiliki satu fungsi yang belum dirakit <b>tersisa</b> - <b>__prepare_key ()</b> .  Kami sudah menduga bahwa di dalamnya data verifikasi dihasilkan dalam bentuk array <b>key_array</b> , yang kemudian digunakan dalam fungsi <b>_construct_key ()</b> untuk memverifikasi data dari file.  Masih mencari tahu data seperti apa di sana! <br><br>  Saya tidak akan menganalisis fungsi ini secara terperinci dan segera memberikan daftar lengkap dengan komentar setelah semua penggantian nama variabel yang diperlukan: <br><br><div class="spoiler">  <b class="spoiler_title">__Prepare_key () daftar fungsi</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ** __prepare_key(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **key_array; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *pvVar1; <span class="hljs-comment"><span class="hljs-comment">/* key_array = new char*[2]; // 2 4-  (char*) */</span></span> key_array = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)calloc2(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key_array == (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { key_array = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pvVar1 = calloc2(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0x540</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* key_array[0] = new char[1340] */</span></span> *key_array = pvVar1; pvVar1 = calloc2(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* key_array[1] = new char[8] */</span></span> key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] = pvVar1; <span class="hljs-comment"><span class="hljs-comment">/* "VOID" */</span></span> *(undefined4 *)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0x404024</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 5  4 (2- ) */</span></span> *(undefined2 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>) = <span class="hljs-number"><span class="hljs-number">5</span></span>; *(undefined2 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>) = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* key_array[0][0] = 'b' */</span></span> *(undefined *)*key_array = <span class="hljs-number"><span class="hljs-number">0x62</span></span>; *(undefined4 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x104</span></span>) = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 'W' */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x218</span></span>) = <span class="hljs-number"><span class="hljs-number">0x57</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 'p' */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x324</span></span>) = <span class="hljs-number"><span class="hljs-number">0x70</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 'l' */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x10c</span></span>) = <span class="hljs-number"><span class="hljs-number">0x6c</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 152 ( ASCII) */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x430</span></span>) = <span class="hljs-number"><span class="hljs-number">0x98</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   = 1122 (int32) */</span></span> *(undefined4 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x53c</span></span>) = <span class="hljs-number"><span class="hljs-number">0x462</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key_array; }</code> </pre><br></div></div><br>  Satu-satunya tempat yang layak dipertimbangkan adalah baris ini: <br><br><pre> <code class="cpp hljs">*(undefined4 *)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0x404024</span></span>;</code> </pre><br>  Bagaimana saya mengerti bahwa di sini terletak garis "BATAL"?  Faktanya adalah 0x404024 adalah alamat di ruang alamat program yang mengarah ke bagian <b>.rdata</b> .  Mengklik dua kali pada nilai ini memungkinkan kita untuk melihat dengan jelas apa yang ada di sana: <br><br><img src="https://habrastorage.org/webt/8a/eu/0j/8aeu0jkpr-ea7euhrlcgvm0rxq8.png"><br><br>  Omong-omong, hal yang sama dapat dipahami dari kode assembler untuk baris ini: <br><br> <code>004015da c7 00 24 MOV dword ptr [EAX], .rdata = 56h V <br> 40 40 00 <br></code> <br>  Data yang sesuai dengan baris VOID ada di bagian paling awal <b>.rdata data</b> (pada titik nol offset dari alamat yang sesuai). <br><br>  Jadi, saat keluar dari fungsi ini, array dua dimensi harus dibentuk dengan data berikut: <br><br> <code>[0] [0]:'b' [268]:'l' [536]:'W' [804]:'p' [1072]:152 [1340]:1122 <br> [1] [0-3]:"VOID" [4-5]:5 [6-7]:4 <br></code> <br><h2>  Langkah 7 - Siapkan biner untuk crack </h2><br>  Sekarang kita dapat memulai sintesis file biner.  Semua data awal ada di tangan kita: <br>  1) data verifikasi ("simbol berhenti") dan posisinya dalam array verifikasi; <br>  2) urutan data dalam file <br><br>  Mari kita kembalikan struktur file yang kita cari sesuai dengan algoritma fungsi <b>_construct_key ()</b> .  Jadi, urutan data dalam file adalah sebagai berikut: <br><br><div class="spoiler">  <b class="spoiler_title">Struktur file</b> <div class="spoiler_text"><ol><li>  4 byte == key_array [1] [0 ... 3] == "VOID" </li><li>  2 byte == key_array [1] [4] == 5 </li><li>  2 byte == key_array [1] [6] == 4 </li><li>  1 byte == key_array [0] [0] == 'b' (token) </li><li>  1 byte == (panjang baris berikutnya) == n_strlen1 </li><li>  n_strlen1 byte == (sembarang string) == n_strlen1 </li><li>  1 byte == (+7 == token berikutnya) == n_pos </li><li>  1 byte == key_array [0] [0] == 'l' (token) </li><li>  1 byte == (panjang baris berikutnya) == n_strlen1 </li><li>  n_strlen1 byte == (sembarang string) == n_strlen1 </li><li>  1 byte == (+7 == token berikutnya) == n_pos </li><li>  1 byte == key_array [0] [0] == 'W' (token) </li><li>  1 byte == (panjang baris berikutnya) == n_strlen1 </li><li>  n_strlen1 byte == (sembarang string) == n_strlen1 </li><li>  1 byte == (+7 == token berikutnya) == n_pos </li><li>  1 byte == key_array [0] [0] == 'p' (token) </li><li>  1 byte == (panjang baris berikutnya) == n_strlen1 </li><li>  n_strlen1 byte == (sembarang string) == n_strlen1 </li><li>  1 byte == (+7 == token berikutnya) == n_pos </li><li>  1 byte == key_array [0] [0] == 152 (token) </li><li>  1 byte == (panjang baris berikutnya) == n_strlen1 </li><li>  n_strlen1 byte == (sembarang string) == n_strlen1 </li><li>  1 byte == (+7 == token berikutnya) == n_pos </li><li>  4 byte == (key_array [1340]) == 1122 </li></ol><br></div></div><br>  Untuk lebih jelasnya, saya membuat di Excel tablet seperti itu dengan data file yang diinginkan: <br><br><img src="https://habrastorage.org/webt/kr/i-/7a/kri-7arjlro0ye_los64uhakbfq.png"><br><br>  Di sini, di baris ke-7 - data itu sendiri dalam bentuk karakter dan angka, di baris ke-6 - representasi heksadesimal mereka, di baris ke-8 - ukuran setiap elemen (dalam bytes), di baris ke-9 - offset relatif ke awal file.  Pandangan ini sangat nyaman karena  memungkinkan Anda untuk memasukkan baris apa pun di file yang akan datang (ditandai dengan isian kuning), sementara nilai-nilai panjang garis-garis ini, serta offset posisi simbol pemberhentian berikutnya dihitung dengan formula secara otomatis, sesuai dengan algoritma program.  Di atas (dalam baris 1-4), struktur array cek <b>key_array ditampilkan</b> . <br><br>  Unggul itu sendiri plus bahan sumber lainnya untuk artikel dapat diunduh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  Pembuatan dan validasi file biner </h3><br>  Satu-satunya yang tersisa adalah membuat file yang diinginkan dalam format biner dan mengumpankannya dengan crack kami.  Untuk menghasilkan file, saya menulis skrip Python sederhana: <br><br><div class="spoiler">  <b class="spoiler_title">Script untuk menghasilkan file</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys, os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess out_str = [<span class="hljs-string"><span class="hljs-string">'!'</span></span>, <span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">' solved'</span></span>, <span class="hljs-string"><span class="hljs-string">' this'</span></span>, <span class="hljs-string"><span class="hljs-string">' crackme!'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(file_path, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> outfile: outfile.write(<span class="hljs-string"><span class="hljs-string">'VOID'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'2h'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'b'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">0</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">0</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos = <span class="hljs-number"><span class="hljs-number">10</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">0</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'l'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">1</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">1</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">1</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'W'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">2</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">2</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">2</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'p'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">3</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">3</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">3</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-number"><span class="hljs-number">152</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">4</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">4</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">4</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'i'</span></span>, <span class="hljs-number"><span class="hljs-number">1122</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> err: print(err) <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(sys.argv) != <span class="hljs-number"><span class="hljs-number">2</span></span>: print(<span class="hljs-string"><span class="hljs-string">'USAGE: {this_script.py} path_to_crackme[.exe]'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.isfile(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]): print(<span class="hljs-string"><span class="hljs-string">'File "{}" unavailable!'</span></span>.format(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> file_path = os.path.splitext(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">'.dat'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: write_file(file_path) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: outputstr = subprocess.check_output(<span class="hljs-string"><span class="hljs-string">'"{}" -f "{}"'</span></span>.format(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>], file_path), stderr=subprocess.STDOUT) print(outputstr.decode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> err: print(err) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: main()</code> </pre><br></div></div><br>  Script mengambil path ke crack sebagai parameter tunggal, kemudian menghasilkan file biner dengan kunci di direktori yang sama dan memanggil crack dengan parameter yang sesuai, menerjemahkan output program ke konsol. <br><br>  Untuk mengonversi data teks menjadi biner, gunakan paket <b>struct</b> .  Metode <b>pack ()</b> memungkinkan Anda untuk menulis data biner dalam format yang menunjukkan tipe data ("B" = "byte", "i" = int, dll.), Dan Anda juga dapat menentukan urutan ("&gt;" = "Besar -endian "," &lt;"=" Little-endian ").  Urutan default adalah Little-endian.  Karena  kami sudah menentukan dalam artikel pertama bahwa ini persis kasus kami, maka kami hanya menunjukkan jenisnya. <br><br>  Semua kode secara keseluruhan mereproduksi algoritma program yang kami temukan.  Sebagai garis yang akan dicetak jika berhasil, saya tentukan "Saya memecahkan crackme ini!"  (Anda dapat memodifikasi skrip ini sehingga memungkinkan untuk menentukan baris apa pun). <br><br>  Periksa output: <br><br><img src="https://habrastorage.org/webt/th/mx/pz/thmxpzy22t8leydwou56w3emrze.png"><br><br>  Hore, semuanya bekerja!  Jadi, setelah sedikit berkeringat dan memilah-milah beberapa fungsi, kami dapat sepenuhnya memulihkan algoritma program dan "memecahkannya".  Tentu saja, ini hanya retakan sederhana, program pengujian, dan bahkan tingkat kesulitan ke-2 (dari 5 yang ditawarkan di situs itu).  Pada kenyataannya, kita akan berurusan dengan hierarki panggilan yang kompleks dan lusinan - ratusan fungsi, dan dalam beberapa kasus - bagian terenkripsi data, kode sampah dan teknik kebingungan lainnya, hingga penggunaan mesin virtual internal dan kode-P ... Tapi ini, seperti yang mereka katakan, sudah cerita yang sama sekali berbeda. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bahan untuk artikel.</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447488/">https://habr.com/ru/post/id447488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447474/index.html">Analog decatron fungsional miniatur untuk replika Harwell Dekatron Computer dan tidak hanya</a></li>
<li><a href="../id447476/index.html">Mengatur LaTeX dalam Teks Sublime</a></li>
<li><a href="../id447478/index.html">Ilusi kekekalan dan kepercayaan sebagai dasar pengembangan tim</a></li>
<li><a href="../id447480/index.html">Hari Kosmonautika 2019: acara berdasarkan kota</a></li>
<li><a href="../id447482/index.html">Sekolah Hukum Cyber. 5-hari hukum digital intensif</a></li>
<li><a href="../id447490/index.html">Cara meningkatkan gaya penulisan Anda dalam bahasa Inggris: 5 tips</a></li>
<li><a href="../id447494/index.html">Keberlanjutan GAN Learning (Menggali lebih dalam)</a></li>
<li><a href="../id447496/index.html">Mengelola Raspberry melalui soket web</a></li>
<li><a href="../id447498/index.html">Laporan foto dari JPoint 2019 + pengumuman Joker 2019 di St. Petersburg</a></li>
<li><a href="../id447500/index.html">Mengapa operator takut dengan eSIM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>