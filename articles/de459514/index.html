<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§æüèæ üí∞ ü§πüèΩ .NET: Tools zum Arbeiten mit Multithreading und Asynchronit√§t. Teil 2 üßë üö∫ üÜë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich ver√∂ffentliche den Originalartikel √ºber Habr, dessen √úbersetzung im Codingsight- Blog ver√∂ffentlicht ist. 

 Ich erstelle weiterhin eine Textversi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Tools zum Arbeiten mit Multithreading und Asynchronit√§t. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459514/">  <i>Ich ver√∂ffentliche den Originalartikel √ºber Habr, dessen √úbersetzung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codingsight-</a> Blog ver√∂ffentlicht ist.</i> <br><br>  Ich erstelle weiterhin eine Textversion meines Vortrags beim Multithreading-Meeting.  Der erste Teil ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier zu</a> finden. Dort ging es mehr um die grundlegenden Tools zum Starten eines Threads oder einer Aufgabe, um M√∂glichkeiten, ihren Status anzuzeigen, und um einige s√º√üe Kleinigkeiten wie PLinq.  In diesem Artikel m√∂chte ich mich mehr auf die Probleme konzentrieren, die in einer Multithread-Umgebung auftreten k√∂nnen, und auf einige M√∂glichkeiten, sie zu l√∂sen. <br><br><h2>  Inhalt </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu freigegebenen Ressourcen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">M√∂gliche Probleme beim Arbeiten in einer Multithread-Umgebung</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deadlock</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rennbedingung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Besch√§ftigt warten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fadenhunger</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synchronisierungswerkzeuge</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verriegelt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monitor.Enter, Monitor.Exit, sperren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpinLock, SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monitor.Wait, Monitor.Pulse [Alle]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ResetEvent-Familie</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schlussfolgerungen</a> </li></ul><br><a name="habracut"></a><br><a name="SharedResources"></a><br><h2>  Informationen zu freigegebenen Ressourcen </h2><br>  Es ist unm√∂glich, ein Programm zu schreiben, das in mehreren Threads funktioniert, aber gleichzeitig keine einzige gemeinsam genutzte Ressource hat:  Selbst wenn es auf Ihrer Abstraktionsebene funktioniert, stellt sich heraus, dass es immer noch eine gemeinsame Ressource gibt, wenn Sie eine oder mehrere Ebenen darunter hinuntergehen.  Ich werde einige Beispiele geben: <br><br>  <b>Beispiel 1:</b> <br><br>  Aus Angst vor m√∂glichen Problemen haben Sie Threads mit verschiedenen Dateien arbeiten lassen.  Per Datei zum Streamen.  Es scheint Ihnen, dass das Programm keine einzige gemeinsame Ressource hat. <br><br>  Nachdem wir mehrere Ebenen tiefer gegangen sind, wissen wir, dass es nur eine Festplatte gibt und deren Treiber oder Betriebssystem die Probleme l√∂sen muss, den Zugriff darauf sicherzustellen. <br><br>  <b>Beispiel 2:</b> <br><br>  Nachdem Sie <i>Beispiel</i> 1 gelesen haben, haben Sie beschlossen, die Dateien auf zwei verschiedenen Remote-Computern mit zwei physisch unterschiedlichen Eisenst√ºcken und Betriebssystemen abzulegen.  Wir halten 2 verschiedene Verbindungen √ºber FTP oder NFS. <br><br>  Nachdem wir einige Ebenen weiter unten sind, haben wir verstanden, dass sich nichts ge√§ndert hat und der Treiber der Netzwerkkarte oder das Betriebssystem des Computers, auf dem das Programm ausgef√ºhrt wird, das Problem des wettbewerbsf√§higen Zugriffs l√∂sen muss. <br><br>  <b>Beispiel 3:</b> <br><br>  Nachdem Sie einen betr√§chtlichen Teil Ihrer Haare verloren haben, um die M√∂glichkeit des Schreibens eines Multithread-Programms zu beweisen, lehnen Sie Dateien vollst√§ndig ab und zerlegen die Berechnungen in zwei verschiedene Objekte, von denen jeweils nur ein Stream f√ºr Links verf√ºgbar ist. <br><br>  Ich h√§mmere das letzte Dutzend N√§gel in den Sarg dieser Idee: Ein Laufzeit- und Garbage Collector, ein Thread-Scheduler, physisch ein RAM und ein Speicher, ein Prozessor sind immer noch gemeinsam genutzte Ressourcen. <br><br>  Wir haben also herausgefunden, dass es unm√∂glich ist, ein Multithread-Programm ohne eine einzige gemeinsam genutzte Ressource auf allen Abstraktionsebenen √ºber die Breite des gesamten Technologie-Stacks zu schreiben.  Gl√ºcklicherweise l√∂st jede der Abstraktionsebenen in der Regel die Probleme des Wettbewerbszugriffs teilweise oder vollst√§ndig oder verbietet sie einfach (Beispiel: Jedes UI-Framework verbietet die Arbeit mit Elementen aus verschiedenen Threads). Daher treten Probleme am h√§ufigsten bei gemeinsam genutzten Ressourcen auf Ihre Abstraktionsebene.  Um sie zu l√∂sen, f√ºhren Sie das Konzept der Synchronisation ein. <br><a name="Problems"></a><br><h2>  M√∂gliche Probleme beim Arbeiten in einer Multithread-Umgebung </h2><br>  Fehler in der Software k√∂nnen in mehrere Gruppen unterteilt werden: <br><br><ol><li>  Das Programm erzeugt kein Ergebnis.  Abst√ºrze oder Einfrieren. </li><li>  Das Programm gibt ein falsches Ergebnis zur√ºck. </li><li>  Das Programm liefert das richtige Ergebnis, erf√ºllt jedoch nicht die eine oder andere nicht funktionierende Anforderung.  L√§uft zu lange oder verbraucht zu viele Ressourcen. </li></ol><br>  In einer Umgebung mit mehreren Threads sind die beiden Hauptprobleme, die die Fehler 1 und 2 verursachen, <b>Deadlock</b> und <b>Race Condition</b> . <br><a name="Deadlock"></a><br><h3>  Deadlock </h3><br>  Deadlock - Deadlock.  Es gibt viele verschiedene Variationen.  Am h√§ufigsten sind die folgenden: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  W√§hrend <b>Thread Nr. 1</b> etwas tat, blockierte <b>Thread Nr. 2</b> Ressource <b>B</b> , etwas sp√§ter blockierte <b>Thread Nr. 1</b> Ressource <b>A</b> und versuchte, Ressource <b>B</b> zu sperren. Leider wird dies niemals passieren, da  <b>Thread 2 gibt</b> Ressource <b>B</b> erst frei, nachdem Ressource <b>A</b> gesperrt wurde <b>.</b> <br><a name="RaceCondition"></a><br><h3>  Rennbedingung </h3><br>  Rennbedingung - Rennbedingung.  Die Situation, in der das Verhalten und das Ergebnis der vom Programm durchgef√ºhrten Berechnungen von der Arbeit des Laufzeit-Thread-Schedulers abh√§ngt. <br>  Die Unannehmlichkeit dieser Situation liegt genau in der Tatsache, dass Ihr Programm m√∂glicherweise nicht nur einmal von hundert oder sogar von einer Million funktioniert. <br><br>  Die Situation wird durch die Tatsache versch√§rft, dass Probleme zusammenpassen k√∂nnen, zum Beispiel: Bei einem bestimmten Verhalten des Thread-Schedulers tritt ein Deadlock auf. <br><br>  Zus√§tzlich zu diesen beiden Problemen, die zu offensichtlichen Fehlern im Programm f√ºhren, gibt es auch Probleme, die m√∂glicherweise nicht zu einem falschen Berechnungsergebnis f√ºhren, aber mehr Zeit oder Verarbeitungsleistung ben√∂tigen, um es zu erhalten.  Zwei dieser Probleme sind: <b>Busy Wait</b> und <b>Thread Starvation</b> . <br><a name="BusyWait"></a><br><h3>  Besch√§ftigt warten </h3><br>  Busy-Wait ist ein Problem, bei dem das Programm Prozessorressourcen nicht f√ºr Berechnungen, sondern zum Warten verbraucht. <br><br>  Oft sieht ein solches Problem im Code ungef√§hr so ‚Äã‚Äãaus: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  Dies ist ein Beispiel f√ºr extrem schlechten Code seitdem  Ein solcher Code belegt vollst√§ndig einen Kern Ihres Prozessors und tut absolut nichts N√ºtzliches.  Dies kann nur dann gerechtfertigt werden, wenn es von entscheidender Bedeutung ist, eine √Ñnderung eines Werts in einem anderen Thread zu verarbeiten.  Und wenn ich schnell spreche, spreche ich √ºber den Fall, dass Sie nicht einmal ein paar Nanosekunden warten k√∂nnen.  In anderen F√§llen, dh in allem, was ein gesundes Gehirn hervorbringen kann, ist es sinnvoller, ResetEvent-Sorten und ihre Slim-Versionen zu verwenden.  √úber sie unten. <br><br>  Vielleicht schl√§gt einer der Leser vor, das Problem des vollst√§ndigen Ladens eines Kerns mit einer nutzlosen Wartezeit zu l√∂sen, indem er der Schleife Konstrukte wie Thread.Sleep (1) hinzuf√ºgt.  Dies wird das Problem wirklich l√∂sen, aber ein anderes schaffen: Die Reaktionszeit auf die √Ñnderung betr√§gt durchschnittlich eine halbe Millisekunde, was nicht viel, aber katastrophal mehr ist, als Sie die Synchronisationsprimitive der ResetEvent-Familie verwenden k√∂nnten. <br><a name="ThreadStarvation"></a><br><h3>  Fadenhunger </h3><br>  Thread-Starvation ist ein Problem, bei dem im Programm zu viele Threads gleichzeitig arbeiten.  Was bedeutet es genau die Flows, die mit Berechnungen besch√§ftigt sind und nicht nur auf eine Antwort von einem IO warten?  Mit diesem Problem geht der gesamte m√∂gliche Leistungsgewinn durch die Verwendung von Threads verloren, weil  Der Prozessor verbringt viel Zeit damit, die Kontexte zu wechseln. <br>  Es ist praktisch, mit verschiedenen Profilern nach solchen Problemen zu suchen. Im Folgenden finden Sie ein Beispiel f√ºr einen Screenshot des im Timeline-Modus gestarteten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotTrace-</a> Profilers. <br><br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(Bild ist anklickbar)</i> <br><br>  In dem Programm, das nicht unter Streaming-Hunger leidet, wird in Diagrammen, die Streams widerspiegeln, keine rosa Farbe angezeigt.  Dar√ºber hinaus ist in der Kategorie Subsysteme klar, dass 30,6% des Programms auf die CPU gewartet haben. <br><br>  Wenn ein solches Problem diagnostiziert wird, wird es ganz einfach gel√∂st: Sie haben zu viele Threads gleichzeitig gestartet, weniger oder nicht alle gleichzeitig gestartet. <br><a name="SyncPrimitives"></a><br><h2>  Synchronisierungswerkzeuge </h2><br><a name="Interlocked"></a><br><h3>  Verriegelt </h3><br>  Dies ist m√∂glicherweise die einfachste Art der Synchronisierung.  Interlocked ist eine Sammlung einfacher atomarer Operationen.  Eine atomare Operation wird eine Operation genannt, zu deren Zeitpunkt nichts passieren kann.  In .NET wird Interlocked durch die gleichnamige statische Klasse mit einer Reihe von Methoden dargestellt, von denen jede eine atomare Operation implementiert. <br><br>  Um den Schrecken nichtatomarer Operationen zu erkennen, schreiben Sie ein Programm, das 10 Threads startet, von denen jeder eine Million Inkremente derselben Variablen erstellt, und drucken Sie am Ende ihrer Arbeit den Wert dieser Variablen aus - leider wird er sich dar√ºber hinaus stark von 10 Millionen unterscheiden Jedes Mal, wenn das Programm gestartet wird, ist es anders.  Dies geschieht, weil selbst eine so einfache Operation wie ein Inkrement nicht atomar ist, sondern das Extrahieren eines Werts aus dem Speicher, das Berechnen eines neuen Werts und das Zur√ºckschreiben umfasst.  Somit k√∂nnen zwei Threads gleichzeitig jede dieser Operationen ausf√ºhren. In diesem Fall geht das Inkrement verloren. <br><br>  Die Interlocked-Klasse bietet Inkrementierungs- / Dekrementierungsmethoden, und es ist leicht zu erraten, was sie tun.  Sie sind praktisch zu verwenden, wenn Sie Daten in mehreren Threads verarbeiten und etwas ber√ºcksichtigen.  Ein solcher Code funktioniert viel schneller als das klassische Schloss.  Wenn Interlocked f√ºr die im letzten Absatz beschriebene Situation verwendet wird, gibt das Programm in jeder Situation stabil 10 Millionen aus. <br><br>  Die CompareExchange-Methode f√ºhrt auf den ersten Blick eine eher nicht offensichtliche Funktion aus, aber all ihre Anwesenheit erm√∂glicht es Ihnen, viele interessante Algorithmen zu implementieren, insbesondere die Familie ohne Sperren. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Die Methode nimmt drei Werte an: Der erste wird als Referenz √ºbergeben, und dies ist der Wert, der in den zweiten ge√§ndert wird. Wenn zum Zeitpunkt des Vergleichs location1 mit compareand √ºbereinstimmt, wird der urspr√ºngliche Wert von location1 zur√ºckgegeben.  Das klingt ziemlich verwirrend, da es einfacher ist, Code zu schreiben, der dieselben Vorg√§nge wie CompareExchange ausf√ºhrt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  Nur eine Implementierung in der Interlocked-Klasse ist atomar.  Das hei√üt, wenn wir solchen Code selbst geschrieben h√§tten, k√∂nnte eine Situation aufgetreten sein, in der die Bedingung location1 == compareand bereits erf√ºllt war, aber als der Ausdruck location1 = value ausgef√ºhrt wurde, hatte ein anderer Thread den Wert von location1 ge√§ndert und er ging verloren. <br><br>  Ein gutes Beispiel f√ºr die Verwendung dieser Methode finden Sie im Code, den der Compiler f√ºr jedes C # -Ereignis generiert. <br><br>  Schreiben wir eine einfache Klasse mit einem MyEvent-Ereignis: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lassen Sie uns</a> das Projekt in der Release-Konfiguration <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> und die Assembly mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotPeek √∂ffnen,</a> wobei die Option Show Compiler Generated Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktiviert ist</a> : <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Hier k√∂nnen Sie sehen, dass der Compiler hinter den Kulissen einen ziemlich ausgekl√ºgelten Algorithmus generiert hat.  Dieser Algorithmus sch√ºtzt vor dem Verlust eines Ereignisabonnements, wenn mehrere Threads dieses Ereignis gleichzeitig abonnieren.  Lassen Sie uns die add-Methode detaillierter schreiben und uns daran erinnern, was die CompareExchange-Methode hinter den Kulissen tut <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  Dies ist bereits etwas klarer, obwohl es wahrscheinlich noch einer Erkl√§rung bedarf.  In Worten w√ºrde ich diesen Algorithmus wie folgt beschreiben: <br><br>  <i>Wenn MyEvent immer noch das gleiche ist wie zu dem Zeitpunkt, als wir mit dem Ausf√ºhren von Delegate.Combine begonnen haben, schreiben Sie darin auf, was Delegate.Combine zur√ºckgibt. Wenn dies nicht der Fall ist, spielen wir es erneut und wiederholen es, bis es herauskommt.</i> <i><br></i> <br><br>  Es geht also kein Event-Abonnement verloren.  Sie m√ºssen ein √§hnliches Problem l√∂sen, wenn Sie pl√∂tzlich ein dynamisches thread-sicheres Array ohne Sperren implementieren m√∂chten.  Wenn mehrere Streams schnell Elemente hinzuf√ºgen, ist es wichtig, dass sie am Ende alle hinzugef√ºgt werden. <br><a name="Lock"></a><br><h3>  Monitor.Enter, Monitor.Exit, sperren </h3><br>  Dies sind die am h√§ufigsten verwendeten Konstrukte f√ºr die Thread-Synchronisation.  Sie implementieren die Idee eines kritischen Abschnitts: Das hei√üt, Code, der zwischen Aufrufen von Monitor.Enter, Monitor.Exit f√ºr eine Ressource geschrieben wurde, kann gleichzeitig in nur einem Thread ausgef√ºhrt werden.  Die lock-Anweisung ist syntaktischer Zucker f√ºr Enter / Exit-Aufrufe, die in try-finally eingeschlossen sind.  Eine nette Funktion beim Implementieren eines kritischen Abschnitts in .NET ist die M√∂glichkeit, ihn f√ºr denselben Stream erneut einzugeben.  Dies bedeutet, dass ein solcher Code ohne Probleme ausgef√ºhrt wird: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  Es ist nat√ºrlich unwahrscheinlich, dass jemand auf diese Weise schreibt, aber wenn Sie diesen Code in mehrere Methoden mit detailliertem Call-Stack einteilen, k√∂nnen Sie mit dieser Funktion einige Wenns sparen.  Um einen solchen Trick zu erm√∂glichen, mussten die .NET-Entwickler eine Einschr√§nkung hinzuf√ºgen - nur eine Instanz eines Referenztyps kann als Synchronisationsobjekt verwendet werden, und jedem Objekt, in das die Stream-ID geschrieben wird, werden implizit mehrere Bytes hinzugef√ºgt. <br><br>  Diese Funktion des kritischen Abschnitts in c # stellt eine interessante Einschr√§nkung f√ºr die Funktionsweise der lock-Anweisung dar: Sie k√∂nnen die await-Anweisung nicht in der lock-Anweisung verwenden.  Zuerst hat es mich √ºberrascht, weil ein √§hnliches Try-finally-Monitor.Enter / Exit-Konstrukt kompiliert wird.  Was ist los?  Hier ist es notwendig, den letzten Absatz noch einmal sorgf√§ltig zu lesen und dann einige Kenntnisse √ºber das Prinzip von async / await hinzuzuf√ºgen: Der Code nach dem Warten wird nicht unbedingt auf demselben Thread wie der Code vor dem Warten ausgef√ºhrt, er h√§ngt vom Synchronisationskontext und dem Vorhandensein oder ab Kein Aufruf von ConfigureAwait.  Daraus folgt, dass Monitor.Exit auf einem anderen Thread als Monitor.Enter ausgef√ºhrt werden kann, wodurch eine <b>SynchronizationLockException</b> ausgel√∂st wird.  Wenn Sie es nicht glauben, k√∂nnen Sie den folgenden Code in einer Konsolenanwendung ausf√ºhren: Es wird eine SynchronizationLockException ausgel√∂st. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  Es ist bemerkenswert, dass in WinForms oder einer WPF-Anwendung dieser Code korrekt funktioniert, wenn er vom Hauptthread aufgerufen wird.  Es wird einen Synchronisationskontext geben, der nach dem Warten eine R√ºckkehr zum UI-Thread implementiert.  In jedem Fall sollten Sie nicht mit dem kritischen Abschnitt im Kontext des Codes spielen, der den Operator await enth√§lt.  In diesen F√§llen ist es besser, Synchronisationsprimitive zu verwenden, auf die sp√§ter noch eingegangen wird. <br><br>  In Bezug auf die Arbeit des kritischen Abschnitts in .NET ist ein weiteres Merkmal seiner Implementierung zu erw√§hnen.  Der kritische Abschnitt in .NET wird in zwei Modi ausgef√ºhrt: im Spin-Wait-Modus und im Kernel-Modus.  Der Spin-Wait-Algorithmus wird zweckm√§√üigerweise als der folgende Pseudocode dargestellt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  Diese Optimierung zielt auf die schnellste Erfassung des kritischen Abschnitts in kurzer Zeit ab, basierend auf der Annahme, dass die Ressource, sobald sie ausgelastet ist, sich selbst freigeben wird.  Wenn dies nicht in kurzer Zeit geschieht, wartet der Thread im Kernel-Modus, was wie die R√ºckkehr einige Zeit in Anspruch nimmt.  .NET-Entwickler haben das Short-Lock-Szenario so weit wie m√∂glich optimiert. Wenn jedoch viele Threads beginnen, den kritischen Abschnitt untereinander zu unterbrechen, kann dies zu einer hohen und pl√∂tzlichen CPU-Auslastung f√ºhren. <br><a name="SpinLock"></a><br><h3>  SpinLock, SpinWait </h3><br>  Da ich den Spin-Wait-Algorithmus erw√§hnt habe, sollten die BCL SpinLock- und SpinWait-Strukturen erw√§hnt werden.  Sie sollten verwendet werden, wenn Grund zu der Annahme besteht, dass es immer die M√∂glichkeit gibt, sehr schnell ein Schloss zu schlie√üen.  Auf der anderen Seite lohnt es sich kaum, sich daran zu erinnern, bevor die Ergebnisse der Profilerstellung zeigen, dass die Verwendung anderer Synchronisationsprimitive der Engpass Ihres Programms ist. <br><a name="Pulse"></a><br><h3>  Monitor.Wait, Monitor.Pulse [Alle] </h3><br>  Dieses Methodenpaar sollte zusammen betrachtet werden.  Mit ihrer Hilfe k√∂nnen verschiedene Producer-Consumer-Szenarien implementiert werden. <br><br>  <i>Producer-Consumer - Ein Entwurfsmuster mit mehreren Prozessen / mehreren Threads, bei dem ein oder mehrere Threads / Prozesse, die Daten erzeugen, und ein oder mehrere Prozesse / Threads, die diese Daten verarbeiten, vorausgesetzt werden.</i>  <i>Verwendet normalerweise eine gemeinsam genutzte Sammlung.</i> <br><br>  Beide Methoden k√∂nnen nur aufgerufen werden, wenn der Thread, der sie verursacht, derzeit gesperrt ist.  Die Wait-Methode hebt die Sperre auf und bleibt h√§ngen, bis ein anderer Thread Pulse aufruft. <br><br>  Um die Arbeit zu demonstrieren, habe ich ein kleines Beispiel geschrieben: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(Ich habe das Bild und nicht den Text verwendet, um die Reihenfolge der Ausf√ºhrung von Anweisungen visuell darzustellen.)</i> <br><br>  <u>Analysieren:</u> Stellen Sie zu Beginn des zweiten Streams eine Verz√∂gerung von 100 ms ein, um sicherzustellen, dass die Ausf√ºhrung sp√§ter beginnt. <br>  - T1: Der Stream der Zeile 2 wird gestartet <br>  - T1: Der Strom der Linie 3 tritt in den kritischen Abschnitt ein <br>  - T1: Linie 6, der Strom schl√§ft ein <br>  - T2: Der Stream der Zeile 3 wird gestartet <br>  - T2: Zeile 4 friert ein, w√§hrend auf einen kritischen Abschnitt gewartet wird <br>  - T1: Zeile 7 gibt den kritischen Abschnitt frei und friert ein, w√§hrend auf den Ausgang von Pulse gewartet wird <br>  - T2: Linie 8 tritt in den kritischen Abschnitt ein <br>  - T2: Zeile 11 benachrichtigt T1 mit der Pulse-Methode <br>  - T2: Zeile 14 verl√§sst den kritischen Abschnitt.  Bis dahin kann T1 die Ausf√ºhrung nicht fortsetzen. <br>  - T1: Linie 15 wacht auf <br>  - T1: Zeile 16 verl√§sst den kritischen Abschnitt <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MSDN</a> hat eine wichtige Bemerkung zur Verwendung von Pulse / Wait-Methoden, n√§mlich: Monitor speichert keine Statusinformationen. Wenn die Pulse-Methode vor dem Aufruf der Wait-Methode aufgerufen wird, kann dies zu einem Deadlock f√ºhren.</i>  <i>Wenn diese Situation m√∂glich ist, ist es besser, eine der Klassen der ResetEvent-Familie zu verwenden.</i> <br><br>  Das vorherige Beispiel zeigt deutlich, wie die Wait / Pulse-Methoden der Monitor-Klasse funktionieren, l√§sst jedoch noch Fragen dar√ºber offen, wann sie verwendet werden sollten.  Ein gutes Beispiel w√§re eine solche Implementierung von BlockingQueue &lt;T&gt;. Andererseits verwendet die Implementierung von BlockingCollection &lt;T&gt; aus System.Collections.Concurrent SemaphoreSlim f√ºr die Synchronisation. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  Dies ist mein geliebtes Synchronisationsprimitiv, dargestellt durch die gleichnamige System.Threading-Namespace-Klasse.  Es scheint mir, dass viele Programme besser funktionieren w√ºrden, wenn ihre Entwickler diese Klasse anstelle der √ºblichen Sperre verwenden w√ºrden. <br><br>  <i>Idee: Viele Threads k√∂nnen lesen, nur ein Schreiben.</i>  <i>Sobald der Stream seinen Wunsch zum Schreiben erkl√§rt, k√∂nnen keine neuen Messwerte gestartet werden, sondern warten, bis die Aufzeichnung abgeschlossen ist.</i>  <i>Es gibt auch das Konzept der aktualisierbaren Lesesperre, das verwendet werden kann, wenn Sie w√§hrend des Lesevorgangs verstehen, dass Sie etwas schreiben m√ºssen. Eine solche Sperre wird in einer atomaren Operation in eine Schreibsperre umgewandelt.</i> <br><br>  <i>Es gibt auch eine ReadWriteLock-Klasse im System.Threading-Namespace, die jedoch f√ºr Neuentwicklungen dringend empfohlen wird.</i>  <i>Mit der schlanken Version k√∂nnen Sie eine Reihe von F√§llen vermeiden, die zu Deadlocks f√ºhren. Au√üerdem k√∂nnen Sie die Sperre schnell erfassen, weil</i>  <i>unterst√ºtzt die Synchronisation im Spin-Wait-Modus, bevor Sie in den Kernel-Modus wechseln.</i> <br><br>  Wenn Sie zum Zeitpunkt des Lesens dieses Artikels noch nichts √ºber diese Klasse wussten, haben Sie sich wahrscheinlich an viele Beispiele aus dem k√ºrzlich geschriebenen Code erinnert, bei denen ein solcher Ansatz zum Sperren es dem Programm erm√∂glichen w√ºrde, effizient zu arbeiten. <br><br>  Die Schnittstelle der ReaderWriterLockSlim-Klasse ist einfach und unkompliziert, ihre Verwendung kann jedoch kaum als bequem bezeichnet werden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  Ich mag es, seine Verwendung in eine Klasse zu packen, was die Verwendung viel bequemer macht. <br>  Idee: Um Read / WriteLock-Methoden zu erstellen, die ein Objekt mit der Dispose-Methode zur√ºckgeben, k√∂nnen diese verwendet werden und unterscheiden sich durch die Anzahl der Zeilen kaum von der √ºblichen Sperre. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Mit einem solchen Trick k√∂nnen Sie einfach weiter schreiben: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  ResetEvent-Familie </h3><br>  Ich f√ºge der Familie die Klassen ManualResetEvent, ManualResetEventSlim, AutoResetEvent hinzu. <br>  Die ManualResetEvent-Klassen, ihre Slim-Version und die AutoResetEvent-Klasse k√∂nnen sich in zwei Zust√§nden befinden: <br>  - In diesem Zustand werden alle Threads, die WaitOne aufgerufen haben, eingefroren (nicht signalisiert), bis das Ereignis in einen signalisierten Zustand √ºbergeht. <br>  - Im abgesenkten Zustand (signalisiert) werden in diesem Zustand alle am WaitOne-Aufruf h√§ngenden Flows freigegeben.  Alle neuen WaitOne-Aufrufe eines heruntergekommenen Ereignisses werden unter bestimmten Bedingungen sofort ausgef√ºhrt. <br><br>  Die AutoResetEvent-Klasse unterscheidet sich von der ManualResetEvent-Klasse darin, dass sie automatisch in einen gespannten Zustand wechselt, nachdem genau ein Thread freigegeben wurde.  Wenn mehrere Threads auf AutoResetEvent warten, gibt der Set-Aufruf im Gegensatz zu ManualResetEvent nur einen beliebigen Thread frei.  ManualResetEvent gibt alle Threads frei. <br><br>  Betrachten Sie ein Beispiel f√ºr AutoResetEvent: <br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br><br>  Das Beispiel zeigt, dass das Ereignis nur dann automatisch in einen gespannten Zustand (nicht signalisiert) versetzt wird, wenn der beim WaitOne-Aufruf h√§ngende Thread losgelassen wird. <br><br>  Die ManualResetEvent-Klasse ist im Gegensatz zu ReaderWriterLock nicht als veraltet markiert und wird nach dem Erscheinen der Slim-Version nicht mehr zur Verwendung empfohlen.  Die schlanke Version dieser Klasse wird effizient f√ºr kurze Erwartungen eingesetzt, wie  Es passiert im Spin-Wait-Modus, die regul√§re Version ist f√ºr lange geeignet. <br><br>  Zus√§tzlich zu den Klassen ManualResetEvent und AutoResetEvent ist auch die Klasse CountdownEvent vorhanden.  Diese Klasse eignet sich f√ºr die Implementierung von Algorithmen, bei denen auf den Teil, der parallelisiert werden konnte, der Teil zum Zusammenf√ºhren der Ergebnisse folgt.  Dieser Ansatz wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fork-Join bezeichnet</a> .  Ein ausgezeichneter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel ist</a> der Arbeit dieser Klasse gewidmet, daher werde ich ihn hier nicht im Detail analysieren. <br><a name="Conclusions"></a><br><h2>  Schlussfolgerungen </h2><br><ul><li>  Bei der Arbeit mit Threads sind zwei Probleme, die zu falschen oder fehlenden Ergebnissen f√ºhren, der Race-Zustand und der Deadlock </li><li>  Die Probleme, die dazu f√ºhren, dass das Programm mehr Zeit oder Ressourcen ben√∂tigt - Thread-Hunger und besch√§ftigtes Warten </li><li>  .NET ist reich an Thread-Synchronisation </li><li>  Es gibt zwei Wartemodi f√ºr Sperren - Spin Wait, Core Wait.  Einige .NET-Thread-Synchronisationsprimitive verwenden beide </li><li>  Interlocked ist eine Reihe von atomaren Operationen, die in sperrfreien Algorithmen verwendet werden und das schnellste Synchronisationsprimitiv sind </li><li>  Der Sperroperator und Monitor.Enter / Exit implementieren die Idee eines kritischen Abschnitts - eines Codeteils, der jeweils nur von einem Thread ausgef√ºhrt werden kann </li><li>  Monitor.Pulse / Wait-Methoden sind praktisch f√ºr die Implementierung von Producer-Consumer-Skripten </li><li>  ReaderWriterLockSlim ist m√∂glicherweise effizienter als das normale Sperren von Skripten, bei denen paralleles Lesen akzeptabel ist </li><li>  Die ResetEvent-Klassenfamilie kann f√ºr die Thread-Synchronisierung n√ºtzlich sein. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459514/">https://habr.com/ru/post/de459514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459500/index.html">HTML ist das Web</a></li>
<li><a href="../de459502/index.html">Wir entwickeln weiterhin eine Abenteuerplattform f√ºr Russen: Schnittstellenfunktionen und Sommerpr√§ferenzen</a></li>
<li><a href="../de459504/index.html">Young Game Designer Course: Wie man das Gleichgewicht von Charakteren und Ausr√ºstung ohne Mathematik z√§hlt</a></li>
<li><a href="../de459506/index.html">Die Abenteuer der schwer fassbaren Malvari, Teil III: Komplizierte VBA-Skripte f√ºr Lachen und Profit</a></li>
<li><a href="../de459508/index.html">5 Folien, die erfahrene Moderatoren ignorieren</a></li>
<li><a href="../de459518/index.html">Python-Aufgabenerkl√§rung mit Vorstellungsgespr√§chen</a></li>
<li><a href="../de459520/index.html">Ein Modell einer nat√ºrlichen Zahlenreihe und ihrer Elemente. Rauten</a></li>
<li><a href="../de459528/index.html">Wie unterrichten wir die franz√∂sische √ñkologie und sammeln Flaschen?</a></li>
<li><a href="../de459530/index.html">Microbiota. Geschichte der Studien- und Forschungsmethoden</a></li>
<li><a href="../de459532/index.html">So w√§hlen Sie eine Zufallszahl von 1 bis 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>