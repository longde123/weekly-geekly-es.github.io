<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏾 💰 🤹🏽 .NET: Tools zum Arbeiten mit Multithreading und Asynchronität. Teil 2 🧑 🚺 🆑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich veröffentliche den Originalartikel über Habr, dessen Übersetzung im Codingsight- Blog veröffentlicht ist. 

 Ich erstelle weiterhin eine Textversi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Tools zum Arbeiten mit Multithreading und Asynchronität. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459514/">  <i>Ich veröffentliche den Originalartikel über Habr, dessen Übersetzung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codingsight-</a> Blog veröffentlicht ist.</i> <br><br>  Ich erstelle weiterhin eine Textversion meines Vortrags beim Multithreading-Meeting.  Der erste Teil ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier zu</a> finden. Dort ging es mehr um die grundlegenden Tools zum Starten eines Threads oder einer Aufgabe, um Möglichkeiten, ihren Status anzuzeigen, und um einige süße Kleinigkeiten wie PLinq.  In diesem Artikel möchte ich mich mehr auf die Probleme konzentrieren, die in einer Multithread-Umgebung auftreten können, und auf einige Möglichkeiten, sie zu lösen. <br><br><h2>  Inhalt </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu freigegebenen Ressourcen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mögliche Probleme beim Arbeiten in einer Multithread-Umgebung</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deadlock</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rennbedingung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschäftigt warten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fadenhunger</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synchronisierungswerkzeuge</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verriegelt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monitor.Enter, Monitor.Exit, sperren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpinLock, SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monitor.Wait, Monitor.Pulse [Alle]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ResetEvent-Familie</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schlussfolgerungen</a> </li></ul><br><a name="habracut"></a><br><a name="SharedResources"></a><br><h2>  Informationen zu freigegebenen Ressourcen </h2><br>  Es ist unmöglich, ein Programm zu schreiben, das in mehreren Threads funktioniert, aber gleichzeitig keine einzige gemeinsam genutzte Ressource hat:  Selbst wenn es auf Ihrer Abstraktionsebene funktioniert, stellt sich heraus, dass es immer noch eine gemeinsame Ressource gibt, wenn Sie eine oder mehrere Ebenen darunter hinuntergehen.  Ich werde einige Beispiele geben: <br><br>  <b>Beispiel 1:</b> <br><br>  Aus Angst vor möglichen Problemen haben Sie Threads mit verschiedenen Dateien arbeiten lassen.  Per Datei zum Streamen.  Es scheint Ihnen, dass das Programm keine einzige gemeinsame Ressource hat. <br><br>  Nachdem wir mehrere Ebenen tiefer gegangen sind, wissen wir, dass es nur eine Festplatte gibt und deren Treiber oder Betriebssystem die Probleme lösen muss, den Zugriff darauf sicherzustellen. <br><br>  <b>Beispiel 2:</b> <br><br>  Nachdem Sie <i>Beispiel</i> 1 gelesen haben, haben Sie beschlossen, die Dateien auf zwei verschiedenen Remote-Computern mit zwei physisch unterschiedlichen Eisenstücken und Betriebssystemen abzulegen.  Wir halten 2 verschiedene Verbindungen über FTP oder NFS. <br><br>  Nachdem wir einige Ebenen weiter unten sind, haben wir verstanden, dass sich nichts geändert hat und der Treiber der Netzwerkkarte oder das Betriebssystem des Computers, auf dem das Programm ausgeführt wird, das Problem des wettbewerbsfähigen Zugriffs lösen muss. <br><br>  <b>Beispiel 3:</b> <br><br>  Nachdem Sie einen beträchtlichen Teil Ihrer Haare verloren haben, um die Möglichkeit des Schreibens eines Multithread-Programms zu beweisen, lehnen Sie Dateien vollständig ab und zerlegen die Berechnungen in zwei verschiedene Objekte, von denen jeweils nur ein Stream für Links verfügbar ist. <br><br>  Ich hämmere das letzte Dutzend Nägel in den Sarg dieser Idee: Ein Laufzeit- und Garbage Collector, ein Thread-Scheduler, physisch ein RAM und ein Speicher, ein Prozessor sind immer noch gemeinsam genutzte Ressourcen. <br><br>  Wir haben also herausgefunden, dass es unmöglich ist, ein Multithread-Programm ohne eine einzige gemeinsam genutzte Ressource auf allen Abstraktionsebenen über die Breite des gesamten Technologie-Stacks zu schreiben.  Glücklicherweise löst jede der Abstraktionsebenen in der Regel die Probleme des Wettbewerbszugriffs teilweise oder vollständig oder verbietet sie einfach (Beispiel: Jedes UI-Framework verbietet die Arbeit mit Elementen aus verschiedenen Threads). Daher treten Probleme am häufigsten bei gemeinsam genutzten Ressourcen auf Ihre Abstraktionsebene.  Um sie zu lösen, führen Sie das Konzept der Synchronisation ein. <br><a name="Problems"></a><br><h2>  Mögliche Probleme beim Arbeiten in einer Multithread-Umgebung </h2><br>  Fehler in der Software können in mehrere Gruppen unterteilt werden: <br><br><ol><li>  Das Programm erzeugt kein Ergebnis.  Abstürze oder Einfrieren. </li><li>  Das Programm gibt ein falsches Ergebnis zurück. </li><li>  Das Programm liefert das richtige Ergebnis, erfüllt jedoch nicht die eine oder andere nicht funktionierende Anforderung.  Läuft zu lange oder verbraucht zu viele Ressourcen. </li></ol><br>  In einer Umgebung mit mehreren Threads sind die beiden Hauptprobleme, die die Fehler 1 und 2 verursachen, <b>Deadlock</b> und <b>Race Condition</b> . <br><a name="Deadlock"></a><br><h3>  Deadlock </h3><br>  Deadlock - Deadlock.  Es gibt viele verschiedene Variationen.  Am häufigsten sind die folgenden: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  Während <b>Thread Nr. 1</b> etwas tat, blockierte <b>Thread Nr. 2</b> Ressource <b>B</b> , etwas später blockierte <b>Thread Nr. 1</b> Ressource <b>A</b> und versuchte, Ressource <b>B</b> zu sperren. Leider wird dies niemals passieren, da  <b>Thread 2 gibt</b> Ressource <b>B</b> erst frei, nachdem Ressource <b>A</b> gesperrt wurde <b>.</b> <br><a name="RaceCondition"></a><br><h3>  Rennbedingung </h3><br>  Rennbedingung - Rennbedingung.  Die Situation, in der das Verhalten und das Ergebnis der vom Programm durchgeführten Berechnungen von der Arbeit des Laufzeit-Thread-Schedulers abhängt. <br>  Die Unannehmlichkeit dieser Situation liegt genau in der Tatsache, dass Ihr Programm möglicherweise nicht nur einmal von hundert oder sogar von einer Million funktioniert. <br><br>  Die Situation wird durch die Tatsache verschärft, dass Probleme zusammenpassen können, zum Beispiel: Bei einem bestimmten Verhalten des Thread-Schedulers tritt ein Deadlock auf. <br><br>  Zusätzlich zu diesen beiden Problemen, die zu offensichtlichen Fehlern im Programm führen, gibt es auch Probleme, die möglicherweise nicht zu einem falschen Berechnungsergebnis führen, aber mehr Zeit oder Verarbeitungsleistung benötigen, um es zu erhalten.  Zwei dieser Probleme sind: <b>Busy Wait</b> und <b>Thread Starvation</b> . <br><a name="BusyWait"></a><br><h3>  Beschäftigt warten </h3><br>  Busy-Wait ist ein Problem, bei dem das Programm Prozessorressourcen nicht für Berechnungen, sondern zum Warten verbraucht. <br><br>  Oft sieht ein solches Problem im Code ungefähr so ​​aus: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  Dies ist ein Beispiel für extrem schlechten Code seitdem  Ein solcher Code belegt vollständig einen Kern Ihres Prozessors und tut absolut nichts Nützliches.  Dies kann nur dann gerechtfertigt werden, wenn es von entscheidender Bedeutung ist, eine Änderung eines Werts in einem anderen Thread zu verarbeiten.  Und wenn ich schnell spreche, spreche ich über den Fall, dass Sie nicht einmal ein paar Nanosekunden warten können.  In anderen Fällen, dh in allem, was ein gesundes Gehirn hervorbringen kann, ist es sinnvoller, ResetEvent-Sorten und ihre Slim-Versionen zu verwenden.  Über sie unten. <br><br>  Vielleicht schlägt einer der Leser vor, das Problem des vollständigen Ladens eines Kerns mit einer nutzlosen Wartezeit zu lösen, indem er der Schleife Konstrukte wie Thread.Sleep (1) hinzufügt.  Dies wird das Problem wirklich lösen, aber ein anderes schaffen: Die Reaktionszeit auf die Änderung beträgt durchschnittlich eine halbe Millisekunde, was nicht viel, aber katastrophal mehr ist, als Sie die Synchronisationsprimitive der ResetEvent-Familie verwenden könnten. <br><a name="ThreadStarvation"></a><br><h3>  Fadenhunger </h3><br>  Thread-Starvation ist ein Problem, bei dem im Programm zu viele Threads gleichzeitig arbeiten.  Was bedeutet es genau die Flows, die mit Berechnungen beschäftigt sind und nicht nur auf eine Antwort von einem IO warten?  Mit diesem Problem geht der gesamte mögliche Leistungsgewinn durch die Verwendung von Threads verloren, weil  Der Prozessor verbringt viel Zeit damit, die Kontexte zu wechseln. <br>  Es ist praktisch, mit verschiedenen Profilern nach solchen Problemen zu suchen. Im Folgenden finden Sie ein Beispiel für einen Screenshot des im Timeline-Modus gestarteten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotTrace-</a> Profilers. <br><br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(Bild ist anklickbar)</i> <br><br>  In dem Programm, das nicht unter Streaming-Hunger leidet, wird in Diagrammen, die Streams widerspiegeln, keine rosa Farbe angezeigt.  Darüber hinaus ist in der Kategorie Subsysteme klar, dass 30,6% des Programms auf die CPU gewartet haben. <br><br>  Wenn ein solches Problem diagnostiziert wird, wird es ganz einfach gelöst: Sie haben zu viele Threads gleichzeitig gestartet, weniger oder nicht alle gleichzeitig gestartet. <br><a name="SyncPrimitives"></a><br><h2>  Synchronisierungswerkzeuge </h2><br><a name="Interlocked"></a><br><h3>  Verriegelt </h3><br>  Dies ist möglicherweise die einfachste Art der Synchronisierung.  Interlocked ist eine Sammlung einfacher atomarer Operationen.  Eine atomare Operation wird eine Operation genannt, zu deren Zeitpunkt nichts passieren kann.  In .NET wird Interlocked durch die gleichnamige statische Klasse mit einer Reihe von Methoden dargestellt, von denen jede eine atomare Operation implementiert. <br><br>  Um den Schrecken nichtatomarer Operationen zu erkennen, schreiben Sie ein Programm, das 10 Threads startet, von denen jeder eine Million Inkremente derselben Variablen erstellt, und drucken Sie am Ende ihrer Arbeit den Wert dieser Variablen aus - leider wird er sich darüber hinaus stark von 10 Millionen unterscheiden Jedes Mal, wenn das Programm gestartet wird, ist es anders.  Dies geschieht, weil selbst eine so einfache Operation wie ein Inkrement nicht atomar ist, sondern das Extrahieren eines Werts aus dem Speicher, das Berechnen eines neuen Werts und das Zurückschreiben umfasst.  Somit können zwei Threads gleichzeitig jede dieser Operationen ausführen. In diesem Fall geht das Inkrement verloren. <br><br>  Die Interlocked-Klasse bietet Inkrementierungs- / Dekrementierungsmethoden, und es ist leicht zu erraten, was sie tun.  Sie sind praktisch zu verwenden, wenn Sie Daten in mehreren Threads verarbeiten und etwas berücksichtigen.  Ein solcher Code funktioniert viel schneller als das klassische Schloss.  Wenn Interlocked für die im letzten Absatz beschriebene Situation verwendet wird, gibt das Programm in jeder Situation stabil 10 Millionen aus. <br><br>  Die CompareExchange-Methode führt auf den ersten Blick eine eher nicht offensichtliche Funktion aus, aber all ihre Anwesenheit ermöglicht es Ihnen, viele interessante Algorithmen zu implementieren, insbesondere die Familie ohne Sperren. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Die Methode nimmt drei Werte an: Der erste wird als Referenz übergeben, und dies ist der Wert, der in den zweiten geändert wird. Wenn zum Zeitpunkt des Vergleichs location1 mit compareand übereinstimmt, wird der ursprüngliche Wert von location1 zurückgegeben.  Das klingt ziemlich verwirrend, da es einfacher ist, Code zu schreiben, der dieselben Vorgänge wie CompareExchange ausführt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  Nur eine Implementierung in der Interlocked-Klasse ist atomar.  Das heißt, wenn wir solchen Code selbst geschrieben hätten, könnte eine Situation aufgetreten sein, in der die Bedingung location1 == compareand bereits erfüllt war, aber als der Ausdruck location1 = value ausgeführt wurde, hatte ein anderer Thread den Wert von location1 geändert und er ging verloren. <br><br>  Ein gutes Beispiel für die Verwendung dieser Methode finden Sie im Code, den der Compiler für jedes C # -Ereignis generiert. <br><br>  Schreiben wir eine einfache Klasse mit einem MyEvent-Ereignis: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lassen Sie uns</a> das Projekt in der Release-Konfiguration <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> und die Assembly mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotPeek öffnen,</a> wobei die Option Show Compiler Generated Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktiviert ist</a> : <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Hier können Sie sehen, dass der Compiler hinter den Kulissen einen ziemlich ausgeklügelten Algorithmus generiert hat.  Dieser Algorithmus schützt vor dem Verlust eines Ereignisabonnements, wenn mehrere Threads dieses Ereignis gleichzeitig abonnieren.  Lassen Sie uns die add-Methode detaillierter schreiben und uns daran erinnern, was die CompareExchange-Methode hinter den Kulissen tut <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  Dies ist bereits etwas klarer, obwohl es wahrscheinlich noch einer Erklärung bedarf.  In Worten würde ich diesen Algorithmus wie folgt beschreiben: <br><br>  <i>Wenn MyEvent immer noch das gleiche ist wie zu dem Zeitpunkt, als wir mit dem Ausführen von Delegate.Combine begonnen haben, schreiben Sie darin auf, was Delegate.Combine zurückgibt. Wenn dies nicht der Fall ist, spielen wir es erneut und wiederholen es, bis es herauskommt.</i> <i><br></i> <br><br>  Es geht also kein Event-Abonnement verloren.  Sie müssen ein ähnliches Problem lösen, wenn Sie plötzlich ein dynamisches thread-sicheres Array ohne Sperren implementieren möchten.  Wenn mehrere Streams schnell Elemente hinzufügen, ist es wichtig, dass sie am Ende alle hinzugefügt werden. <br><a name="Lock"></a><br><h3>  Monitor.Enter, Monitor.Exit, sperren </h3><br>  Dies sind die am häufigsten verwendeten Konstrukte für die Thread-Synchronisation.  Sie implementieren die Idee eines kritischen Abschnitts: Das heißt, Code, der zwischen Aufrufen von Monitor.Enter, Monitor.Exit für eine Ressource geschrieben wurde, kann gleichzeitig in nur einem Thread ausgeführt werden.  Die lock-Anweisung ist syntaktischer Zucker für Enter / Exit-Aufrufe, die in try-finally eingeschlossen sind.  Eine nette Funktion beim Implementieren eines kritischen Abschnitts in .NET ist die Möglichkeit, ihn für denselben Stream erneut einzugeben.  Dies bedeutet, dass ein solcher Code ohne Probleme ausgeführt wird: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  Es ist natürlich unwahrscheinlich, dass jemand auf diese Weise schreibt, aber wenn Sie diesen Code in mehrere Methoden mit detailliertem Call-Stack einteilen, können Sie mit dieser Funktion einige Wenns sparen.  Um einen solchen Trick zu ermöglichen, mussten die .NET-Entwickler eine Einschränkung hinzufügen - nur eine Instanz eines Referenztyps kann als Synchronisationsobjekt verwendet werden, und jedem Objekt, in das die Stream-ID geschrieben wird, werden implizit mehrere Bytes hinzugefügt. <br><br>  Diese Funktion des kritischen Abschnitts in c # stellt eine interessante Einschränkung für die Funktionsweise der lock-Anweisung dar: Sie können die await-Anweisung nicht in der lock-Anweisung verwenden.  Zuerst hat es mich überrascht, weil ein ähnliches Try-finally-Monitor.Enter / Exit-Konstrukt kompiliert wird.  Was ist los?  Hier ist es notwendig, den letzten Absatz noch einmal sorgfältig zu lesen und dann einige Kenntnisse über das Prinzip von async / await hinzuzufügen: Der Code nach dem Warten wird nicht unbedingt auf demselben Thread wie der Code vor dem Warten ausgeführt, er hängt vom Synchronisationskontext und dem Vorhandensein oder ab Kein Aufruf von ConfigureAwait.  Daraus folgt, dass Monitor.Exit auf einem anderen Thread als Monitor.Enter ausgeführt werden kann, wodurch eine <b>SynchronizationLockException</b> ausgelöst wird.  Wenn Sie es nicht glauben, können Sie den folgenden Code in einer Konsolenanwendung ausführen: Es wird eine SynchronizationLockException ausgelöst. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  Es ist bemerkenswert, dass in WinForms oder einer WPF-Anwendung dieser Code korrekt funktioniert, wenn er vom Hauptthread aufgerufen wird.  Es wird einen Synchronisationskontext geben, der nach dem Warten eine Rückkehr zum UI-Thread implementiert.  In jedem Fall sollten Sie nicht mit dem kritischen Abschnitt im Kontext des Codes spielen, der den Operator await enthält.  In diesen Fällen ist es besser, Synchronisationsprimitive zu verwenden, auf die später noch eingegangen wird. <br><br>  In Bezug auf die Arbeit des kritischen Abschnitts in .NET ist ein weiteres Merkmal seiner Implementierung zu erwähnen.  Der kritische Abschnitt in .NET wird in zwei Modi ausgeführt: im Spin-Wait-Modus und im Kernel-Modus.  Der Spin-Wait-Algorithmus wird zweckmäßigerweise als der folgende Pseudocode dargestellt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  Diese Optimierung zielt auf die schnellste Erfassung des kritischen Abschnitts in kurzer Zeit ab, basierend auf der Annahme, dass die Ressource, sobald sie ausgelastet ist, sich selbst freigeben wird.  Wenn dies nicht in kurzer Zeit geschieht, wartet der Thread im Kernel-Modus, was wie die Rückkehr einige Zeit in Anspruch nimmt.  .NET-Entwickler haben das Short-Lock-Szenario so weit wie möglich optimiert. Wenn jedoch viele Threads beginnen, den kritischen Abschnitt untereinander zu unterbrechen, kann dies zu einer hohen und plötzlichen CPU-Auslastung führen. <br><a name="SpinLock"></a><br><h3>  SpinLock, SpinWait </h3><br>  Da ich den Spin-Wait-Algorithmus erwähnt habe, sollten die BCL SpinLock- und SpinWait-Strukturen erwähnt werden.  Sie sollten verwendet werden, wenn Grund zu der Annahme besteht, dass es immer die Möglichkeit gibt, sehr schnell ein Schloss zu schließen.  Auf der anderen Seite lohnt es sich kaum, sich daran zu erinnern, bevor die Ergebnisse der Profilerstellung zeigen, dass die Verwendung anderer Synchronisationsprimitive der Engpass Ihres Programms ist. <br><a name="Pulse"></a><br><h3>  Monitor.Wait, Monitor.Pulse [Alle] </h3><br>  Dieses Methodenpaar sollte zusammen betrachtet werden.  Mit ihrer Hilfe können verschiedene Producer-Consumer-Szenarien implementiert werden. <br><br>  <i>Producer-Consumer - Ein Entwurfsmuster mit mehreren Prozessen / mehreren Threads, bei dem ein oder mehrere Threads / Prozesse, die Daten erzeugen, und ein oder mehrere Prozesse / Threads, die diese Daten verarbeiten, vorausgesetzt werden.</i>  <i>Verwendet normalerweise eine gemeinsam genutzte Sammlung.</i> <br><br>  Beide Methoden können nur aufgerufen werden, wenn der Thread, der sie verursacht, derzeit gesperrt ist.  Die Wait-Methode hebt die Sperre auf und bleibt hängen, bis ein anderer Thread Pulse aufruft. <br><br>  Um die Arbeit zu demonstrieren, habe ich ein kleines Beispiel geschrieben: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(Ich habe das Bild und nicht den Text verwendet, um die Reihenfolge der Ausführung von Anweisungen visuell darzustellen.)</i> <br><br>  <u>Analysieren:</u> Stellen Sie zu Beginn des zweiten Streams eine Verzögerung von 100 ms ein, um sicherzustellen, dass die Ausführung später beginnt. <br>  - T1: Der Stream der Zeile 2 wird gestartet <br>  - T1: Der Strom der Linie 3 tritt in den kritischen Abschnitt ein <br>  - T1: Linie 6, der Strom schläft ein <br>  - T2: Der Stream der Zeile 3 wird gestartet <br>  - T2: Zeile 4 friert ein, während auf einen kritischen Abschnitt gewartet wird <br>  - T1: Zeile 7 gibt den kritischen Abschnitt frei und friert ein, während auf den Ausgang von Pulse gewartet wird <br>  - T2: Linie 8 tritt in den kritischen Abschnitt ein <br>  - T2: Zeile 11 benachrichtigt T1 mit der Pulse-Methode <br>  - T2: Zeile 14 verlässt den kritischen Abschnitt.  Bis dahin kann T1 die Ausführung nicht fortsetzen. <br>  - T1: Linie 15 wacht auf <br>  - T1: Zeile 16 verlässt den kritischen Abschnitt <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MSDN</a> hat eine wichtige Bemerkung zur Verwendung von Pulse / Wait-Methoden, nämlich: Monitor speichert keine Statusinformationen. Wenn die Pulse-Methode vor dem Aufruf der Wait-Methode aufgerufen wird, kann dies zu einem Deadlock führen.</i>  <i>Wenn diese Situation möglich ist, ist es besser, eine der Klassen der ResetEvent-Familie zu verwenden.</i> <br><br>  Das vorherige Beispiel zeigt deutlich, wie die Wait / Pulse-Methoden der Monitor-Klasse funktionieren, lässt jedoch noch Fragen darüber offen, wann sie verwendet werden sollten.  Ein gutes Beispiel wäre eine solche Implementierung von BlockingQueue &lt;T&gt;. Andererseits verwendet die Implementierung von BlockingCollection &lt;T&gt; aus System.Collections.Concurrent SemaphoreSlim für die Synchronisation. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  Dies ist mein geliebtes Synchronisationsprimitiv, dargestellt durch die gleichnamige System.Threading-Namespace-Klasse.  Es scheint mir, dass viele Programme besser funktionieren würden, wenn ihre Entwickler diese Klasse anstelle der üblichen Sperre verwenden würden. <br><br>  <i>Idee: Viele Threads können lesen, nur ein Schreiben.</i>  <i>Sobald der Stream seinen Wunsch zum Schreiben erklärt, können keine neuen Messwerte gestartet werden, sondern warten, bis die Aufzeichnung abgeschlossen ist.</i>  <i>Es gibt auch das Konzept der aktualisierbaren Lesesperre, das verwendet werden kann, wenn Sie während des Lesevorgangs verstehen, dass Sie etwas schreiben müssen. Eine solche Sperre wird in einer atomaren Operation in eine Schreibsperre umgewandelt.</i> <br><br>  <i>Es gibt auch eine ReadWriteLock-Klasse im System.Threading-Namespace, die jedoch für Neuentwicklungen dringend empfohlen wird.</i>  <i>Mit der schlanken Version können Sie eine Reihe von Fällen vermeiden, die zu Deadlocks führen. Außerdem können Sie die Sperre schnell erfassen, weil</i>  <i>unterstützt die Synchronisation im Spin-Wait-Modus, bevor Sie in den Kernel-Modus wechseln.</i> <br><br>  Wenn Sie zum Zeitpunkt des Lesens dieses Artikels noch nichts über diese Klasse wussten, haben Sie sich wahrscheinlich an viele Beispiele aus dem kürzlich geschriebenen Code erinnert, bei denen ein solcher Ansatz zum Sperren es dem Programm ermöglichen würde, effizient zu arbeiten. <br><br>  Die Schnittstelle der ReaderWriterLockSlim-Klasse ist einfach und unkompliziert, ihre Verwendung kann jedoch kaum als bequem bezeichnet werden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  Ich mag es, seine Verwendung in eine Klasse zu packen, was die Verwendung viel bequemer macht. <br>  Idee: Um Read / WriteLock-Methoden zu erstellen, die ein Objekt mit der Dispose-Methode zurückgeben, können diese verwendet werden und unterscheiden sich durch die Anzahl der Zeilen kaum von der üblichen Sperre. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Mit einem solchen Trick können Sie einfach weiter schreiben: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  ResetEvent-Familie </h3><br>  Ich füge der Familie die Klassen ManualResetEvent, ManualResetEventSlim, AutoResetEvent hinzu. <br>  Die ManualResetEvent-Klassen, ihre Slim-Version und die AutoResetEvent-Klasse können sich in zwei Zuständen befinden: <br>  - In diesem Zustand werden alle Threads, die WaitOne aufgerufen haben, eingefroren (nicht signalisiert), bis das Ereignis in einen signalisierten Zustand übergeht. <br>  - Im abgesenkten Zustand (signalisiert) werden in diesem Zustand alle am WaitOne-Aufruf hängenden Flows freigegeben.  Alle neuen WaitOne-Aufrufe eines heruntergekommenen Ereignisses werden unter bestimmten Bedingungen sofort ausgeführt. <br><br>  Die AutoResetEvent-Klasse unterscheidet sich von der ManualResetEvent-Klasse darin, dass sie automatisch in einen gespannten Zustand wechselt, nachdem genau ein Thread freigegeben wurde.  Wenn mehrere Threads auf AutoResetEvent warten, gibt der Set-Aufruf im Gegensatz zu ManualResetEvent nur einen beliebigen Thread frei.  ManualResetEvent gibt alle Threads frei. <br><br>  Betrachten Sie ein Beispiel für AutoResetEvent: <br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br><br>  Das Beispiel zeigt, dass das Ereignis nur dann automatisch in einen gespannten Zustand (nicht signalisiert) versetzt wird, wenn der beim WaitOne-Aufruf hängende Thread losgelassen wird. <br><br>  Die ManualResetEvent-Klasse ist im Gegensatz zu ReaderWriterLock nicht als veraltet markiert und wird nach dem Erscheinen der Slim-Version nicht mehr zur Verwendung empfohlen.  Die schlanke Version dieser Klasse wird effizient für kurze Erwartungen eingesetzt, wie  Es passiert im Spin-Wait-Modus, die reguläre Version ist für lange geeignet. <br><br>  Zusätzlich zu den Klassen ManualResetEvent und AutoResetEvent ist auch die Klasse CountdownEvent vorhanden.  Diese Klasse eignet sich für die Implementierung von Algorithmen, bei denen auf den Teil, der parallelisiert werden konnte, der Teil zum Zusammenführen der Ergebnisse folgt.  Dieser Ansatz wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fork-Join bezeichnet</a> .  Ein ausgezeichneter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel ist</a> der Arbeit dieser Klasse gewidmet, daher werde ich ihn hier nicht im Detail analysieren. <br><a name="Conclusions"></a><br><h2>  Schlussfolgerungen </h2><br><ul><li>  Bei der Arbeit mit Threads sind zwei Probleme, die zu falschen oder fehlenden Ergebnissen führen, der Race-Zustand und der Deadlock </li><li>  Die Probleme, die dazu führen, dass das Programm mehr Zeit oder Ressourcen benötigt - Thread-Hunger und beschäftigtes Warten </li><li>  .NET ist reich an Thread-Synchronisation </li><li>  Es gibt zwei Wartemodi für Sperren - Spin Wait, Core Wait.  Einige .NET-Thread-Synchronisationsprimitive verwenden beide </li><li>  Interlocked ist eine Reihe von atomaren Operationen, die in sperrfreien Algorithmen verwendet werden und das schnellste Synchronisationsprimitiv sind </li><li>  Der Sperroperator und Monitor.Enter / Exit implementieren die Idee eines kritischen Abschnitts - eines Codeteils, der jeweils nur von einem Thread ausgeführt werden kann </li><li>  Monitor.Pulse / Wait-Methoden sind praktisch für die Implementierung von Producer-Consumer-Skripten </li><li>  ReaderWriterLockSlim ist möglicherweise effizienter als das normale Sperren von Skripten, bei denen paralleles Lesen akzeptabel ist </li><li>  Die ResetEvent-Klassenfamilie kann für die Thread-Synchronisierung nützlich sein. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459514/">https://habr.com/ru/post/de459514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459500/index.html">HTML ist das Web</a></li>
<li><a href="../de459502/index.html">Wir entwickeln weiterhin eine Abenteuerplattform für Russen: Schnittstellenfunktionen und Sommerpräferenzen</a></li>
<li><a href="../de459504/index.html">Young Game Designer Course: Wie man das Gleichgewicht von Charakteren und Ausrüstung ohne Mathematik zählt</a></li>
<li><a href="../de459506/index.html">Die Abenteuer der schwer fassbaren Malvari, Teil III: Komplizierte VBA-Skripte für Lachen und Profit</a></li>
<li><a href="../de459508/index.html">5 Folien, die erfahrene Moderatoren ignorieren</a></li>
<li><a href="../de459518/index.html">Python-Aufgabenerklärung mit Vorstellungsgesprächen</a></li>
<li><a href="../de459520/index.html">Ein Modell einer natürlichen Zahlenreihe und ihrer Elemente. Rauten</a></li>
<li><a href="../de459528/index.html">Wie unterrichten wir die französische Ökologie und sammeln Flaschen?</a></li>
<li><a href="../de459530/index.html">Microbiota. Geschichte der Studien- und Forschungsmethoden</a></li>
<li><a href="../de459532/index.html">So wählen Sie eine Zufallszahl von 1 bis 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>