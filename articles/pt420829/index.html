<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÄ üé≠ üë©üèæ‚Äçü§ù‚Äçüë©üèΩ Sistema de trabalho. Vis√£o geral do outro lado üéπ üõï üõÄüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na nova vers√£o unit√°ria de 2018, eles finalmente adicionaram oficialmente o novo sistema de componentes de entidades, ou ECS , que permite trabalhar a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistema de trabalho. Vis√£o geral do outro lado</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420829/">  Na nova vers√£o unit√°ria de 2018, eles finalmente adicionaram oficialmente o novo <b>sistema de componentes de entidades,</b> ou <b>ECS</b> , que permite trabalhar apenas com os dados, em vez do trabalho usual com componentes de objetos. <br><br>  Um sistema de tarefas adicional oferece a voc√™ poder de computa√ß√£o paralela para melhorar o desempenho do seu c√≥digo. <br><a name="habracut"></a><br>  Juntos, esses dois novos sistemas ( <b>ECS</b> e <b>Job System</b> ) oferecem um novo n√≠vel de processamento de dados. <br><br>  Especificamente, neste artigo, n√£o analisarei todo o sistema <b>ECS</b> , atualmente dispon√≠vel como um conjunto de ferramentas baixado separadamente na <b>unidade</b> , mas considerarei apenas o sistema de tarefas e como ele pode ser usado fora do pacote do <b>ECS</b> . <br><br><h3>  Novo sistema </h3><br>  Inicialmente, a <b>unidade</b> costumava ser capaz de usar a computa√ß√£o multithread, mas tudo isso tinha que ser criado pelo desenvolvedor por conta pr√≥pria, para resolver os problemas e solucionar as armadilhas.  E se antes era necess√°rio trabalhar diretamente com coisas como criar threads, fechar threads, pools, sincroniza√ß√£o, agora todo esse trabalho ca√≠a sobre os ombros do mecanismo, e o pr√≥prio desenvolvedor s√≥ precisava criar tarefas e conclu√≠-las. <br><br><h3>  As tarefas </h3><br>  Para executar qualquer c√°lculo no novo sistema, √© necess√°rio usar tarefas que s√£o objetos que consistem em m√©todos e dados para c√°lculo. <br><br>  Como qualquer outro dado no sistema <b>ECS</b> , as tarefas no <b>Job System</b> tamb√©m <b>s√£o</b> representadas como estruturas que herdam uma das tr√™s interfaces. <br><br><h4>  Ijob </h4><br>  A interface de tarefa mais simples que cont√©m um m√©todo <b>Execute</b> que n√£o aceita nada na forma de par√¢metros e n√£o retorna nada. <br><br>  A tarefa em si √© assim: <br><br><div class="spoiler">  <b class="spoiler_title">Ijob</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  No m√©todo <b>Execute</b> , voc√™ pode executar os c√°lculos necess√°rios. <br><br><h4>  IJobParallelFor </h4><br>  Outra interface com o mesmo m√©todo <b>Execute</b> , que por sua vez j√° aceita o <b>√≠ndice</b> num√©rico do par√¢metro. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelFor</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Essa interface <b>IJobParallelFor</b> , diferente da interface <b>IJob</b> , oferece a execu√ß√£o de uma tarefa v√°rias vezes e n√£o apenas a execu√ß√£o, mas divide essa execu√ß√£o em blocos que ser√£o distribu√≠dos entre os threads. <br><br>  <i>N√£o est√° claro</i>  <i>N√£o se preocupe com isso, vou lhe contar mais.</i> <br><br><h4>  IJobParallelForTransform </h4><br>  E a √∫ltima interface especial, que, como o nome indica, √© projetada para trabalhar com essas transforma√ß√µes do objeto.  Ele tamb√©m cont√©m o m√©todo <b>Execute</b> , com o <b>√≠ndice</b> num√©rico do par√¢metro e o par√¢metro <b>TransformAccess</b> onde a posi√ß√£o, o tamanho e a rota√ß√£o da transforma√ß√£o est√£o localizados. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelForTransform</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelForTransform { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index, TransformAccess transform) {} }</code> </pre> <br></div></div><br>  Como voc√™ n√£o pode trabalhar com objetos de <b>unidade</b> diretamente na tarefa, essa interface s√≥ pode processar dados de transforma√ß√£o como uma estrutura <b>TransformAccess</b> separada. <br><br>  Conclu√≠do, agora voc√™ sabe como as estruturas de tarefas s√£o criadas, voc√™ pode continuar praticando. <br><br><h3>  Conclus√£o da tarefa </h3><br>  Vamos criar uma tarefa simples herdada da interface <b>IJob</b> e conclu√≠-la.  Para isso, precisamos de qualquer script simples do <b>MonoBehaviour</b> e da estrutura da tarefa em si. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() {} }</code> </pre> <br></div></div><br>  Agora solte esse script em algum objeto em cena.  No mesmo script ( <b>TestJob</b> ) abaixo, escreveremos a estrutura da tarefa e n√£o esqueceremos de importar as bibliotecas necess√°rias. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Hello parallel world!"</span></span>); } }</code> </pre> <br></div></div><br>  No m√©todo <b>Execute</b> , por exemplo, imprima uma linha simples no console. <br><br>  Agora vamos seguir para o m√©todo <b>Start</b> do script <b>TestJob</b> , onde criaremos uma inst√¢ncia da tarefa e depois a executaremos. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.Schedule().Complete(); } }</code> </pre> <br></div></div><br>  Se voc√™ fez tudo como no exemplo, depois de iniciar o jogo, voc√™ receber√° uma mensagem simples no console, como na figura. <br><br><img src="https://lh6.googleusercontent.com/QQeMBMeZy0HVw0r_D5Q_cH4k6Zzt-HAC6uev1O4pR--mOh96C2TQvw5DTH1X3ZPE7LORJ4wdV5kyKjGiJzVWLFm-HBi8HzSP4-DlbrYa65eRV1RF672uwsLsZvrCKtF5CdaGJ5tj" alt="imagem"><br><br>  O que acontece aqui: depois de chamar o m√©todo <b>Schedule</b> , o planejador coloca a tarefa no identificador e agora pode ser conclu√≠da chamando o m√©todo <b>Complete</b> . <br><br>  Este foi um exemplo de uma tarefa que simplesmente imprimiu texto no console.  Para uma tarefa executar c√°lculos paralelos, √© necess√°rio preench√™-la com dados. <br><br><h3>  Dados na tarefa </h3><br>  Como no sistema <b>ECS</b> , nas tarefas n√£o h√° acesso aos objetos de <b>unidade</b> , voc√™ n√£o pode obter o <b>GameObject</b> na tarefa e alterar seu nome l√°.  Tudo o que voc√™ pode fazer √© transferir alguns par√¢metros separados do objeto para a tarefa, alter√°-los e, ap√≥s concluir a tarefa, aplicar essas altera√ß√µes novamente ao objeto. <br><br>  Existem v√°rias limita√ß√µes para os dados na pr√≥pria tarefa: em primeiro lugar, devem ser estruturas e, em segundo lugar, n√£o devem ser tipos de dados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">convers√≠veis</a> , ou seja, voc√™ n√£o pode passar o mesmo <b>booleano</b> ou <b>string</b> para a tarefa. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float a, b; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { float result = a + b; Debug.Log(result); } }</code> </pre> <br></div></div><br>  E a principal condi√ß√£o: os dados n√£o inclu√≠dos em um cont√™iner s√≥ podem ser acessados ‚Äã‚Äãdentro da tarefa! <br><br><h3>  Contentores </h3><br>  Ao trabalhar com computa√ß√£o multithread, √© necess√°rio, de alguma forma, trocar dados entre threads.  Para poder transferir dados para eles e l√™-los novamente no sistema de tarefas, para esses fins, existem cont√™ineres.  Esses cont√™ineres s√£o apresentados na forma de estruturas comuns e eu trabalho com o princ√≠pio de uma ponte pela qual os dados elementares s√£o sincronizados entre os fluxos. <br><br>  Existem v√°rios tipos de cont√™ineres: <br>  <b>NativeArray</b> .  O tipo de cont√™iner mais simples e usado com mais frequ√™ncia √© apresentado como uma matriz simples com um tamanho fixo. <br>  <b>NativeSlice</b> .  Outro cont√™iner - uma matriz, como √© evidente na tradu√ß√£o, √© projetada para cortar o NativeArray em peda√ßos. <br><br>  Esses s√£o os dois principais cont√™ineres dispon√≠veis sem conectar um sistema <b>ECS</b> .  Em uma vers√£o mais avan√ßada, existem v√°rios outros tipos de cont√™ineres. <br><br>  <b>NativeList</b> .  √â uma lista regular de dados. <br>  <b>NativeHashMap</b> .  Um an√°logo de um dicion√°rio com uma chave e um valor. <br>  <b>NativeMultiHashMap</b> .  O mesmo <b>NativeHashMap</b> com apenas alguns valores em uma chave. <br>  <b>NativeQueue</b>  Lista de filas de dados. <br><br>  Como trabalhamos sem conectar um sistema <b>ECS</b> , apenas o <b>NativeArray</b> e o <b>NativeSlice</b> est√£o dispon√≠veis para <b>n√≥s</b> . <br><br>  Antes de prosseguir para a parte pr√°tica, √© necess√°rio analisar o ponto mais importante - a cria√ß√£o de inst√¢ncias. <br><br><h3>  Criar cont√™ineres </h3><br>  Como eu disse antes, esses cont√™ineres representam uma ponte sobre a qual os dados s√£o sincronizados entre os threads.  O sistema de tarefas abre essa ponte antes de iniciar o trabalho e a fecha ap√≥s sua conclus√£o.  O processo de abertura √© chamado de " <i>aloca√ß√£o</i> " ( <b>Aloca√ß√£o</b> ) ou <i>"aloca√ß√£o de mem√≥ria"</i> , o processo de fechamento √© chamado de " <i>libera√ß√£o de recursos</i> " ( <b>Dispose</b> ). <br><br>  √â a aloca√ß√£o que determina quanto tempo a tarefa pode usar os dados no cont√™iner - em outras palavras, quanto tempo a ponte ficar√° aberta. <br><br>  Para entender melhor esses dois processos, vamos dar uma olhada na figura abaixo. <br><br><img src="https://lh4.googleusercontent.com/6yL2x_ynGZj1C1ukkQlfDZuYKzlvJ4ceAYU9Zyb40xwDzuASeUNB__Od067_3xZkYANEOPl84JoKLyqTPn4hrvQNogbksb7akoQvcWjDLg2yyUJY9eF37uj7TO0YkOL3cQyMsXPu" alt="imagem"><br><br>  A parte inferior mostra o ciclo de vida do encadeamento principal (encadeamento <b>principal</b> ), calculado no n√∫mero de quadros; no primeiro quadro, criamos outro encadeamento paralelo ( <b>novo encadeamento)</b> que existe para um determinado n√∫mero de quadros e, em seguida, √© fechado com seguran√ßa. <br>  No mesmo <b>novo encadeamento,</b> chega <b>a</b> tarefa com o cont√™iner. <br><br>  Agora d√™ uma olhada no topo da imagem. <br><br><img src="https://lh5.googleusercontent.com/1IZ_CMZhX4JfBWBLEuAijf1st_6e7p96EncPomR_jLNhQVbJDvS_o_-gf1emw3glwEGt8y3xXARp4xJJ9qu0WjYTH4asrblwul2rHa_SqQiLzrTTOoDJ5DlomcPBP8qkfCI3w9R8" alt="imagem"><br><br>  A barra branca <b>Aloca√ß√£o</b> mostra a vida √∫til do cont√™iner.  No primeiro quadro, o cont√™iner √© <i>alocado</i> - a ponte √© aberta, at√© o momento em que o cont√™iner n√£o existia, ap√≥s todos os c√°lculos na tarefa terem sido conclu√≠dos, o cont√™iner √© liberado da mem√≥ria e no nono quadro, a ponte √© fechada. <br><br>  Tamb√©m nesta faixa ( <b>Aloca√ß√£o</b> ) existem segmentos de tempo ( <b>Temp</b> , <b>TempJob</b> e <b>Presistent</b> ), cada um desses segmentos mostrando a vida √∫til estimada do cont√™iner. <br><br>  Por que esses segmentos s√£o necess√°rios!?  O fato √© que a execu√ß√£o de uma tarefa por dura√ß√£o pode ser diferente, podemos execut√°-las diretamente no mesmo m√©todo em que a criamos, ou podemos estender o tempo de execu√ß√£o da tarefa, se for bastante complicado, e esses segmentos mostram qu√£o urgente e por quanto tempo a tarefa pode usar os dados no recipiente. <br><br>  <i>Se ainda n√£o estiver claro, analisarei cada tipo de aloca√ß√£o usando um exemplo.</i> <br><br>  Agora podemos passar para a parte pr√°tica da cria√ß√£o de cont√™ineres, para isso, retornamos ao m√©todo <b>Start</b> do script <b>TestJob</b> e criamos uma nova inst√¢ncia do cont√™iner <b>NativeArray</b> e n√£o esquecemos de conectar as bibliotecas necess√°rias. <br><br><h3>  Temp </h3><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; using Unity.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); } }</code> </pre> <br></div></div><br>  Para criar uma nova inst√¢ncia de cont√™iner, voc√™ deve especificar o tamanho e o tipo de aloca√ß√£o em seu construtor.  Este exemplo usa o tipo <b>Temp</b> , pois a tarefa ser√° executada apenas no m√©todo <b>Start</b> . <br><br>  Agora inicialize exatamente a mesma vari√°vel de matriz na estrutura da tarefa <b>SimpleJob</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Feito.  Agora voc√™ pode criar a pr√≥pria tarefa e passar uma inst√¢ncia de matriz para ela. <br><br><div class="spoiler">  <b class="spoiler_title">Iniciar</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; }</code> </pre> <br></div></div><br>  Para executar a tarefa dessa vez, usaremos o identificador <b>JobHandle</b> para obt√™-la chamando o mesmo m√©todo <b>Schedule</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Iniciar</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); }</code> </pre> <br></div></div><br>  Agora voc√™ pode chamar o m√©todo <b>Complete</b> em seu identificador e verificar se a tarefa foi conclu√≠da para exibir o texto no console. <br><br><div class="spoiler">  <b class="spoiler_title">Iniciar</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">" "</span></span>); }</code> </pre> <br></div></div><br>  Se voc√™ executar a tarefa neste formul√°rio, depois de iniciar o jogo, voc√™ receber√° um erro vermelho gordo dizendo que n√£o liberou o cont√™iner da matriz dos recursos ap√≥s a conclus√£o da tarefa. <br><br>  Algo assim. <br><br><img src="https://lh3.googleusercontent.com/EewKhLiPm0_qidpB0-YnlUfbTcIlzOhPw_OXgJqcmm-m9MpAaq96PHSc-FlN7GNArl9JkThBUZEGM9YFIHR5BkkMRUBwTAM6awQAEYGOw45i31irFlXtkT7peTOmjFfoEq_ASONA" alt="imagem"><br><br>  Para evitar isso, chame o m√©todo <b>Dispose</b> no cont√™iner ap√≥s concluir a tarefa. <br><br><div class="spoiler">  <b class="spoiler_title">Iniciar</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">"Complete"</span></span>); array.Dispose(); }</code> </pre> <br></div></div><br>  Ent√£o voc√™ pode reinici√°-lo com seguran√ßa. <br>  Mas a tarefa n√£o faz nada!  - adicione algumas a√ß√µes a ele. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length; i++) { array[i] = i * i; } } }</code> </pre> <br></div></div><br>  No m√©todo <b>Execute</b> , multiplico o √≠ndice de cada elemento da matriz por mim e escrevo de volta na matriz da <b>matriz</b> para imprimir o resultado no console no m√©todo <b>Start</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Iniciar</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(job.array[job.array.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>]); array.Dispose(); }</code> </pre> <br></div></div><br><blockquote>  Qual ser√° o resultado no console se imprimirmos o √∫ltimo elemento da matriz ao quadrado? </blockquote><br>  √â assim que voc√™ pode criar cont√™ineres, coloc√°-los em tarefas e executar a√ß√µes neles. <br><br>  Este foi um exemplo usando o tipo de aloca√ß√£o <b>Temp</b> , o que implica concluir uma tarefa em um quadro.  Esse tipo √© melhor usado quando voc√™ precisa executar c√°lculos rapidamente sem carregar o encadeamento principal, mas precisa ter cuidado se a tarefa for muito complicada ou se houver muitos deles, podem ocorrer flacidez; nesse caso, √© melhor usar o tipo <b>TempJob,</b> que analisarei mais adiante. <br><br><h3>  Tempjob </h3><br>  Neste exemplo, <b>modificarei</b> levemente <b>a</b> estrutura da tarefa <b>SimpleJob</b> e a <b>herdarei de</b> outra interface <b>IJobParallelFor</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Al√©m disso, como a tarefa ser√° executada por mais de um quadro, executaremos e coletaremos os resultados da tarefa nos diferentes m√©todos <b>Awake</b> e <b>Start</b> apresentados na forma de uma rotina.  Para fazer isso, altere um <b>pouco</b> a apar√™ncia da classe <b>TestJob</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() {} IEnumerator Start() {} }</code> </pre> <br></div></div><br>  No m√©todo <b>Awake</b> , criaremos uma tarefa e um cont√™iner de vetor e, no m√©todo <b>Start</b> , produziremos os dados recebidos e liberaremos os recursos. <br><br><div class="spoiler">  <b class="spoiler_title">Desperta</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; }</code> </pre> <br></div></div><br>  Aqui, novamente, um cont√™iner de <b>matriz</b> √© criado com o tipo de aloca√ß√£o <b>TempJob</b> , ap√≥s o qual criamos uma tarefa e obtemos seu identificador chamando o m√©todo <b>Schedule</b> com pequenas altera√ß√µes. <br><br><div class="spoiler">  <b class="spoiler_title">Desperta</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) }</code> </pre> <br></div></div><br>  O primeiro par√¢metro no m√©todo <b>Schedule</b> indica quantas vezes a tarefa ser√° executada. Aqui est√° o mesmo n√∫mero que o tamanho da <b>matriz</b> . <br>  O segundo par√¢metro indica quantos blocos para compartilhar a tarefa. <br><br>  <i>Que outros blocos?</i> <br>  Anteriormente, para concluir uma tarefa, um thread simplesmente chamado m√©todo <b>Execute</b> uma vez, agora √© necess√°rio chamar esse m√©todo 100 vezes, para que o planejador divida essas 100 vezes de repeti√ß√µes em blocos que ele distribui entre os threads para n√£o carregar nenhum thread separado.  No exemplo, cem repeti√ß√µes ser√£o divididas em 5 blocos de 20 repeti√ß√µes cada, ou seja, o planejador presumivelmente distribuir√° esses 5 blocos em 5 threads, onde cada thread chamar√° o m√©todo <b>Execute</b> 20 vezes.  Na pr√°tica, √© claro, n√£o √© fato que o agendador fa√ßa exatamente isso, tudo depende da carga de trabalho do sistema; portanto, talvez todas as 100 repeti√ß√µes ocorram em um √∫nico encadeamento. <br><br>  Agora voc√™ pode chamar o m√©todo <b>Complete</b> no identificador de tarefas. <br><br><div class="spoiler">  <b class="spoiler_title">Desperta</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  Na rotina <b>inicial</b> , verificaremos a execu√ß√£o da tarefa e depois limparemos o cont√™iner. <br><br><div class="spoiler">  <b class="spoiler_title">Iniciar</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.isCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  Agora vamos seguir para as a√ß√µes na pr√≥pria tarefa. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) { float x = index; float y = index; Vector2 vector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(x * x, y * y / (y * <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array[index] = vector; } }</code> </pre> <br></div></div><br>  Ap√≥s concluir a tarefa no m√©todo <b>Iniciar</b> , exiba todos os elementos da matriz no console. <br><br><div class="spoiler">  <b class="spoiler_title">Iniciar</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } foreach(Vector2 vector <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array) { print(vector); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  Feito, voc√™ pode executar e analisar o resultado. <br><br>  Para entender a diferen√ßa entre <b>IJob</b> e <b>IJobParallelFor,</b> d√™ uma olhada nas imagens abaixo. <br>  Por exemplo, no <b>IJob,</b> voc√™ <b>pode</b> usar um loop <b>for</b> simples <b>para</b> executar c√°lculos v√°rias vezes, mas, em qualquer caso, um encadeamento pode chamar o m√©todo <b>Execute</b> apenas uma vez durante toda a dura√ß√£o da tarefa - √© assim que uma pessoa executa centenas das mesmas a√ß√µes seguidas. <br><br><img src="https://lh3.googleusercontent.com/qUadSqRojz1W8kiqtm-xgi-TYeJ9IlVh38o0MrG0mTWnU3j0qTjtTOWa8pkPc0kjPQcTKoqOJtNl6E4Olb5MKCNgUhrsAXGujN0flm_YVoFfEVS9kCCjFOucANAw74Kjq2W_Zzho" alt="imagem"><br><br>  <b>IJobParallelFor</b> oferece n√£o apenas executar uma tarefa em um thread v√°rias vezes, mas tamb√©m distribuir essas repeti√ß√µes entre outros threads. <br><br><img src="https://lh5.googleusercontent.com/-5ggH4tUKWvhz6I8UUi2eGzqY_B_QqA1PA_298vp89xg4v2yC3wn3N9D8TlVOMwWuDM593H_Aw9WZOU-_esyT7vyL4MM17bZaevfiOiYSEUb0I1oT2Fi3cXbBtoc9SuMYIhVnMc7" alt="imagem"><br><br>  Em geral, o tipo de aloca√ß√£o <b>TempJob √©</b> perfeito para a maioria das tarefas executadas em v√°rios quadros. <br><br>  Mas e se voc√™ precisar armazenar dados mesmo depois de concluir uma tarefa, e se depois de receber o resultado n√£o precisar destru√≠-lo imediatamente.  Para isso, √© necess√°rio usar o tipo de aloca√ß√£o <b>Persistente</b> , o que implica a libera√ß√£o de recursos e depois ‚Äú <i>quando necess√°rio!‚Äù</i>  . <br><br><h3>  Persistente </h3><br>  <b>Vamos</b> voltar √† classe <b>TestJob</b> e alter√°-la.  Agora, criaremos tarefas no m√©todo <b>OnEnable</b> , verificaremos sua execu√ß√£o no m√©todo <b>Update</b> e limparemos os recursos no m√©todo <b>OnDisable</b> . <br>  No exemplo, moveremos o objeto no m√©todo <b>Update</b> . Para calcular a trajet√≥ria, usaremos dois cont√™ineres vetoriais - <b>inputArray,</b> nos quais colocaremos a posi√ß√£o atual e o <b>outputArray</b> de onde receberemos os resultados. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; inputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() {} }</code> </pre> <br></div></div><br>  Tamb√©m <b>modificaremos</b> ligeiramente <b>a</b> estrutura da tarefa <b>SimpleJob</b> , herdando-a da interface <b>IJob</b> para execut√°-la uma vez. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Na tarefa em si, trairemos tamb√©m dois cont√™ineres de vetores, um vetor de posi√ß√£o e um delta num√©rico, que mover√£o o objeto para o destino. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; inputArray; [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float delta; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Os atributos <b>ReadOnly</b> e <b>WriteOnly</b> mostram as restri√ß√µes de fluxo nas a√ß√µes associadas aos dados dentro dos cont√™ineres.  <b>O ReadOnly</b> oferece o fluxo apenas para ler dados do cont√™iner, o atributo <b>WriteOnly</b> , pelo contr√°rio, permite que o fluxo <b>grave</b> apenas dados no cont√™iner.  Se voc√™ precisar executar essas duas a√ß√µes ao mesmo tempo com um cont√™iner, n√£o ser√° necess√°rio marc√°-lo com um atributo. <br><br>  Vamos <b>seguir</b> para o m√©todo <b>OnEnable da</b> classe <b>TestJob</b> onde os cont√™ineres ser√£o inicializados. <br><br><div class="spoiler">  <b class="spoiler_title">Onenable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); }</code> </pre> <br></div></div><br>  As dimens√µes dos cont√™ineres ser√£o √∫nicas, pois √© necess√°rio transmitir e receber par√¢metros apenas uma vez.  O tipo de aloca√ß√£o ser√° <b>Persistente</b> . <br>  No m√©todo <b>OnDisable</b> , liberaremos os recursos dos cont√™ineres. <br><br><div class="spoiler">  <b class="spoiler_title">Ondisable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray.Dispose(); }</code> </pre> <br></div></div><br>  Vamos criar um m√©todo <b>CreateJob</b> separado, em que criaremos uma tarefa com seu identificador e l√° a preencheremos com dados. <br><br><div class="spoiler">  <b class="spoiler_title">CreateJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateJob() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.delta = Time.deltaTime; Vector2 position = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position; job.position = position; Vector2 newPosition = position + Vector2.right; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; job.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray; job.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  <i>Na verdade, o <b>inputArray</b> n√£o √© realmente necess√°rio aqui, pois √© poss√≠vel transferir um vetor de dire√ß√£o apenas para a tarefa, mas acho que ser√° melhor entender por que esses atributos <b>ReadOnly</b> e <b>WriteOnly</b> s√£o necess√°rios.</i> <br><br>  No m√©todo <b>Update</b> , verificaremos se a tarefa est√° conclu√≠da, ap√≥s o que aplicamos o resultado obtido √† transforma√ß√£o do objeto e a executamos novamente. <br><br><div class="spoiler">  <b class="spoiler_title">Update</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position = newPosition; CreateJob(); } }</code> </pre> <br></div></div><br>  Antes de iniciar, <b>ajustaremos</b> ligeiramente o m√©todo <b>OnEnable</b> para que a tarefa seja criada imediatamente ap√≥s a inicializa√ß√£o dos cont√™ineres. <br><br><div class="spoiler">  <b class="spoiler_title">Onenable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); CreateJob(); }</code> </pre> <br></div></div><br>  Conclu√≠do, agora voc√™ pode ir para a pr√≥pria tarefa e executar os c√°lculos necess√°rios no m√©todo <b>Execute</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Executar</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; newPosition = Vector2.Lerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position, newPosition, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.delta); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; }</code> </pre> <br></div></div><br>  Para ver o resultado do trabalho, voc√™ pode lan√ßar o script <b>TestJob</b> em algum objeto e executar o jogo. <br><br>  Por exemplo, meu sprite muda gradualmente para a direita. <br><br><div class="spoiler">  <b class="spoiler_title">Anima√ß√£o</b> <div class="spoiler_text"><img src="https://lh3.googleusercontent.com/YCf68msYSI0w6ARjOAeAWsPPhpPOrXC-3jWTfqtlnu1pS1xa9m6FCjTD3DdvcvWi5KSEh_-q6X2yUf62j1FOgSU6d0plX603FOQiydF-yLRQFvbd2YBY-mp8I5p5V4cQH9t7SKPR" alt="imagem"><br></div></div><br>  Em geral, o tipo de aloca√ß√£o <b>Persistent √©</b> √≥timo para cont√™ineres reutiliz√°veis ‚Äã‚Äãque n√£o precisam ser destru√≠dos e recriados todas as vezes. <br><br>  <i>Ent√£o, que tipo de usar!?</i> <br>  O tipo <b>Temp</b> √© melhor usado para executar c√°lculos rapidamente, mas se a tarefa for muito complexa e grande, pode ocorrer folga. <br>  O tipo <b>TempJob √©</b> √≥timo para trabalhar com objetos de <b>unidade</b> , para que voc√™ possa alterar os par√¢metros dos objetos e aplic√°-los, por exemplo, no pr√≥ximo quadro. <br>  O tipo <b>Persistente</b> pode ser usado quando a velocidade n√£o √© importante para voc√™, mas voc√™ s√≥ precisa calcular constantemente algum tipo de dados ao lado, por exemplo, processar dados em uma rede ou o trabalho de uma IA. <br><br><div class="spoiler">  <b class="spoiler_title">Inv√°lido e Nenhum</b> <div class="spoiler_text">  <i>Existem mais dois tipos de aloca√ß√£o <b>Inv√°lido</b> e <b>Nenhum</b> , mas eles s√£o mais necess√°rios para depura√ß√£o e n√£o participam do trabalho.</i> <br></div></div><br><br><h3>  Jobhandle </h3><br>  Separadamente, vale a pena analisar os recursos do identificador de tarefas, porque, al√©m de verificar o processo de execu√ß√£o de tarefas, esse identificador pequeno ainda pode criar redes inteiras de tarefas por meio de depend√™ncias (embora eu prefira cham√°-las de filas mais). <br><br>  Por exemplo, se voc√™ precisar executar duas tarefas em uma determinada sequ√™ncia, para isso, basta anexar o identificador de uma tarefa ao identificador de outra. <br><br>  Parece algo assim. <br><br><img src="https://lh3.googleusercontent.com/K62BSMljveR8lED8wCuCUCuLN6zyNlXS8RQybQuztrT_FMalHHSP7oMGIDf6xUcjXAMqRG3njvHIJ4FPL_tU1uSZr5XQDmCOPyM_YJye2i_z58lIPAkflcia511L2ILI72In61aT" alt="imagem"><br><br>  Cada identificador individual cont√©m inicialmente sua pr√≥pria tarefa, mas quando combinados, obtemos um novo identificador com duas tarefas. <br><br><div class="spoiler">  <b class="spoiler_title">Iniciar</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { Job jobA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleA = jobA.Schedule(); Job jobB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleB = jobB.Schedule(); JobHandle result = JobHandle.CombineDependecies(handleA, handleB); result.Complete(); }</code> </pre> <br></div></div><br>  Mais ou menos. <br><br><div class="spoiler">  <b class="spoiler_title">Iniciar</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); handle = job.Schedule(handle); } handle.Complete(); }</code> </pre> <br></div></div><br>  A sequ√™ncia de execu√ß√£o √© salva e o planejador n√£o iniciar√° a pr√≥xima tarefa at√© que esteja convencido da anterior, mas √© importante lembrar que a propriedade do <b>identificador</b> IsCompleted aguardar√° a conclus√£o de todas as tarefas. <br><br><h2>  Conclus√£o </h2><br><h3>  Contentores </h3><br><ol><li>  Ao trabalhar com dados em cont√™ineres, n√£o se esque√ßa de que s√£o estruturas, portanto, qualquer substitui√ß√£o de dados no cont√™iner n√£o os altera, mas os cria novamente. </li><li>  <i>O que acontece se voc√™ definir o tipo de aloca√ß√£o Temp e n√£o limpar os recursos ap√≥s a conclus√£o da tarefa?</i>  O erro </li><li>  <i>Posso criar meus pr√≥prios cont√™ineres?</i>  √â poss√≠vel que as unidades descritas detalhadamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o</a> processo de cria√ß√£o de cont√™ineres personalizados aqui, mas √© melhor pensar algumas vezes: vale a pena, talvez haja cont√™ineres comuns suficientes!? </li></ol><br><h4>  Seguran√ßa! </h4><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dados est√°ticos.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√£o tente usar dados est√°ticos em uma tarefa ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aleat√≥ria</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e outros), qualquer acesso a dados est√°ticos violar√° a seguran√ßa do sistema. Na verdade, no momento, voc√™ pode acessar dados est√°ticos, mas apenas se tiver certeza de que eles n√£o mudam durante o trabalho - ou seja, eles s√£o completamente est√°ticos e somente leitura. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando usar o sistema de tarefas?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todos esses exemplos dados aqui no artigo s√£o apenas condicionais e mostram como trabalhar com esse sistema, e n√£o quando us√°-lo. O sistema de tarefas pode ser usado sem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voc√™ precisa entender que o sistema tamb√©m consome recursos no trabalho e que, por qualquer motivo, imediatamente escreve tarefas, criar montes de cont√™ineres √© simplesmente in√∫til - tudo se tornar√° ainda pior. Por exemplo, recalcular um array com um tamanho de 10 mil elementos n√£o ser√° correto - levar√° mais tempo para o agendador funcionar, mas recalcular todos os pol√≠gonos de um grande terrane ou mesmo ger√°-lo √© a solu√ß√£o certa, voc√™ pode dividir o terrane em tarefas e processar cada um em um fluxo separado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, se voc√™ est√° constantemente envolvido em c√°lculos complexos em projetos e constantemente procura novas oportunidades para tornar esse processo menos intensivo em recursos, o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job System</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© exatamente isso que voc√™ precisa. </font><font style="vertical-align: inherit;">Se voc√™ trabalha constantemente com c√°lculos complexos inseparavelmente de objetos e deseja que seu c√≥digo funcione mais rapidamente e seja suportado na maioria das plataformas, o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definitivamente o ajudar√° com isso. </font><font style="vertical-align: inherit;">Se voc√™ criar projetos apenas para o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebGL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , isso n√£o √© para voc√™, no momento, o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job System</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o suporta o trabalho em navegadores, embora isso n√£o seja um problema para unitecs, mas para os pr√≥prios desenvolvedores. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://www.google.com/url%3Fq%3D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte com todos os exemplos</font></font></a> <cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420829/">https://habr.com/ru/post/pt420829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420815/index.html">Como "decodificar o mundo digital" explodiu no corredor: os 10 principais relat√≥rios do DotNext 2018 Piter</a></li>
<li><a href="../pt420819/index.html">As 10 principais ferramentas Python para aprendizado de m√°quina e ci√™ncia de dados</a></li>
<li><a href="../pt420821/index.html">Regra 10: 1 em programa√ß√£o e reda√ß√£o</a></li>
<li><a href="../pt420825/index.html">Hoje ser√° a primeira partida entre os profissionais OpenAI e Dota 2 (pessoas vencidas). Entendemos como o bot funciona</a></li>
<li><a href="../pt420827/index.html">Crie um projeto simples do maven usando Java EE + WildFly10 + JPA (Hibernate) + Postgresql + EJB + IntelliJ IDEA</a></li>
<li><a href="../pt420831/index.html">O dispositivo para a emiss√£o de cookies "Cook 3000"</a></li>
<li><a href="../pt420833/index.html">Principais erros de monetiza√ß√£o de aplicativos [e como corrigi-los]</a></li>
<li><a href="../pt420837/index.html">Teste de matrizes RAID de software para dispositivos NVMe usando a metodologia SNIA</a></li>
<li><a href="../pt420841/index.html">Hotfix pr√©-hospitalar ou ‚ÄúHey Swagger! Onde est√£o meus erros?</a></li>
<li><a href="../pt420843/index.html">7 de setembro de Ecaterimburgo - uma reuni√£o para desenvolvedores .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>