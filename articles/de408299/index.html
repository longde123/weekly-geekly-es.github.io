<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüëß‚Äçüëß ü§úüèæ üó°Ô∏è L√∂sen des Kachelproblems mit dem SAT-Solver anhand des Pentamino-Beispiels ü§ß üßëüèæ ‚ùî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich auf ein Pentomino-Spiel stie√ü, bei dem es notwendig war, 13 Zahlen in ein Quadrat von 8 mal 8 zu setzen. Nach einer bestimmten Zeit, in der ic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L√∂sen des Kachelproblems mit dem SAT-Solver anhand des Pentamino-Beispiels</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/408299/"> Als ich auf ein Pentomino-Spiel stie√ü, bei dem es notwendig war, 13 Zahlen in ein Quadrat von 8 mal 8 zu setzen. Nach einer bestimmten Zeit, in der ich erfolglos versuchte, dieses Problem zu l√∂sen, entschied ich, dass es notwendig war, ein Programm zu schreiben, das dies f√ºr mich tun w√ºrde.  Dazu musste ein L√∂sungsalgorithmus gew√§hlt werden.  Das erste, was mir in den Sinn kommt, ist der √ºbliche Algorithmus von Zweigen und R√§ndern, wenn die Figuren nacheinander nebeneinander gestapelt werden (der Algorithmus mit tanzenden Links ist hier nicht geeignet, da die Figuren unterschiedlich sind).  Verschiedene Heuristiken werden normalerweise verwendet, um diesen Algorithmus zu beschleunigen. Beispielsweise wird eine Verzweigung mit der geringsten Anzahl von Optionen bevorzugt.  Sie k√∂nnen andere Heuristiken in diesen Algorithmus einbauen und implementieren, aber hier dachte ich, dass viele verschiedene Tricks zur Beschleunigung der L√∂sung solcher Probleme bereits in SAT-L√∂sern implementiert wurden.  Daher ist es notwendig, die Aufgabe in die entsprechende mathematische Sprache zu √ºbersetzen und eine Art SAT-L√∂ser zu verwenden.  Wie dies implementiert wurde und was die resultierenden Ergebnisse sind, kann unter dem Schnitt gelesen werden. <br><a name="habracut"></a><br>  Am Anfang m√∂chte ich Sie daran erinnern, was das Spiel Pentamino ist.  Dies ist ein quadratisches 8x8-Feld, das mit 13 Figuren gekachelt werden muss - 12 Kringel, die aus 5 Quadraten und einer 2x2-Figur bestehen: <br><br><img src="https://ic.pics.livejournal.com/andyplekhanov/66030250/59907/59907_900.jp" alt="Bild"><br><br>  Hier ist zu sagen, was das Boolesche Erf√ºllbarkeitsproblem oder das SAT-Problem ist.  Im Allgemeinen kann es als das Finden solcher Werte von Booleschen Variablen formuliert werden, in denen der gegebene Ausdruck wahr wird.  Im Allgemeinen ist dies eine vollst√§ndige NP-Aufgabe, es gibt jedoch viele Tricks, die helfen, sie effektiv zu l√∂sen.  Zu diesem Zweck wurden viele spezielle Anwendungen entwickelt, die als SAT-L√∂ser bezeichnet werden.  Ich werde einen SAT-Solver namens Minisat verwenden.  Um dieses Problem zu l√∂sen, muss der Eingabeausdruck in konjunktiver Normalform umgeschrieben werden, dh in Form eines Produkts logischer Variablensummen.  Jede Klammer in konjunktiver Normalform wird hier als Klausel bezeichnet, die das logische ‚Äûoder‚Äú einiger Literale ist, dh boolesche Variablen oder deren Verweigerung.  Zum Beispiel: <br><br>  (x1 V nicht x3) (x2 V x4) (x2 V x3 V nicht X4) <br><br>  Ich musste die Kachelaufgabe in die SAT-Aufgabe √ºbersetzen.  Nehmen Sie eine Pentamino-Figur und bringen Sie sie auf alle m√∂glichen Arten ins Spiel, einschlie√ülich Verschiebungen, Drehungen und Reflexionen.  F√ºr jede solche Position der Figur ordnen wir eine boolesche Variable zu und wir gehen davon aus, dass, wenn in unserer endg√ºltigen L√∂sung diese Figur an dieser bestimmten Position vorhanden ist, die Variable wahr und wenn nicht falsch ist.  Wir machen das f√ºr alle Figuren. <br><br>  Lassen Sie uns nun eine Formel erstellen, die unser Problem beschreibt, dh wir werden unseren Variablen tats√§chlich Einschr√§nkungen auferlegen.  Das erste, was Sie tun m√ºssen, ist sicherzustellen, dass alle Zellen unseres Spielfelds mit mindestens einer Figur bedeckt sind.  Zu diesem Zweck finden wir f√ºr jede Zelle von 64 alle Abbildungen und Positionen dieser Abbildungen, die diese Zelle abdecken, und setzen aus den Variablen, die diesen Positionen der Abbildungen zugeordnet sind, eine Klausel.  Das zweite, was zu tun ist, ist, den Schnittpunkt von Formen zu beseitigen.  Dies kann in einem doppelten Zyklus erfolgen, indem einfach alle m√∂glichen Positionen aller Figuren aussortiert werden und bestimmt wird, ob das Paar gemeinsame Zellen hat.  Wenn dies der Fall ist, √ºberschneiden sie sich und Sie m√ºssen eine Klausel der Form hinzuf√ºgen (nicht x_i V nicht x_j), wobei x_i die der ersten Position zugewiesene Variable und x_j die zweite Position ist.  Diese Klausel gilt, wenn x_i und x_j nicht gleichzeitig gleich eins sind, dh Schnittpunkte ausschlie√üen.  Und schlie√ülich ist zu ber√ºcksichtigen, dass jede Figur nur einmal auf dem Spielfeld vorhanden sein kann.  Dazu gehen wir auch alle Positionen jeder Figur in einem Doppelzyklus durch und machen f√ºr jedes Positionspaar derselben Figur eine Klausel √§hnlich der vorherigen, die aus zwei Negativen besteht.  Das hei√üt, wenn zwei identische Figuren erscheinen (aber an unterschiedlichen Positionen), wird eine dieser Klauseln falsch sein und dementsprechend eine solche L√∂sung ausschlie√üen. <br><br>  Es war alles eine Theorie, und jetzt wollen wir weiter √ºben.  Jede Figur hat eine Zahl von 1 bis d, um sie von anderen zu unterscheiden und bequem zu drucken.  Erstellen Sie dann eine Matrix des Spielfelds und codieren Sie die entsprechenden Zellen des Spielfelds als belegt / nicht belegt von der Figur: <br><br> <code>. . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . 1 1 . . . . . <br> 1 1 . . . . . . <br> . 1 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 3 . . . . . . . <br> 3 . . . . . . . <br> 3 . . . . . . . <br> 3 3 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 4 . . . . . . . <br> 4 . . . . . . . <br> 4 4 . . . . . . <br> . 4 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 5 5 . . . . . . <br> 5 5 . . . . . . <br> 5 . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 6 6 6 . . . . . <br> . 6 . . . . . . <br> . 6 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 7 . 7 . . . . . <br> 7 7 7 . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 8 . . . . . . . <br> 8 . . . . . . . <br> 8 8 8 . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . 9 . . . . . <br> . 9 9 . . . . . <br> 9 9 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . a . . . . . . <br> aaa . . . . . <br> . a . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> b . . . . . . . <br> bb . . . . . . <br> b . . . . . . . <br> b . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . cc . . . . . <br> . c . . . . . . <br> cc . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> dd . . . . . . <br> dd . . . . . . <br></code> <br>  Jetzt ist es f√ºr jedes St√ºck notwendig, alle m√∂glichen Positionen auf dem Spielfeld durch Verschiebungen, Drehungen und Reflexionen zu finden.  Beginnen wir mit Drehungen und Reflexionen.  Insgesamt gibt es 8 m√∂gliche Transformationen von Windungen und Reflexionen, einschlie√ülich einer trivialen Transformation, bei der die Figur intakt bleibt.  F√ºr diese Transformationen erstelle ich 8 entsprechende Matrizen, wie unten gezeigt.  Nach der Drehung oder Reflexion kann die Figur √ºber das Spielfeld hinausgehen, sodass Sie sie wieder auf das Spielfeld zur√ºckbringen m√ºssen.  Es sollte auch ber√ºcksichtigt werden, dass sich einige Zahlen nach der Transformation in sich selbst verwandeln k√∂nnen, und solche F√§lle sollten ausgeschlossen werden.  Ich f√ºge der Orientierungsklasse einzigartige Optionen hinzu.  Das Ergebnis ist der folgende Code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dimension_ = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_SIZE = dimension_ * dimension_; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MATRIX_SIZE; i++ ) { matrix[ i ] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; dimension_; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix, matrix + MATRIX_SIZE, matrix1 ); matrix1[ i ] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = dimension_; j &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * dimension_; j++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !matrix1[ j - dimension_ ] ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix1, matrix1 + MATRIX_SIZE, matrix2 ); matrix2[ j ] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NUMBER = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; dimension_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>; l &lt; NUMBER; l++ ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix2, matrix2 + MATRIX_SIZE, matrix3 ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( l &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; l1 &lt; dimension_; l1++ ) { matrix3[ l1 ] = -matrix3[ l1 ]; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( l &amp; <span class="hljs-number"><span class="hljs-number">2</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l1 = dimension_; l1 &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * dimension_; l1++ ) { matrix3[ l1 ] = -matrix3[ l1 ]; } } Orientation * orientation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Orientation( figure ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Point *&gt;::const_iterator h = figure-&gt;points().begin(); h != figure-&gt;points().end(); ++h ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point * p = *h; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i1 &lt; dimension_; i1++ ) { x = x + p-&gt;coord( i1 ) * matrix3[ i1 ]; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i1 &lt; dimension_; i1++ ) { y = y + p-&gt;coord( i1 ) * matrix3[ dimension_ + i1 ]; } <span class="hljs-function"><span class="hljs-function">Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( x, y )</span></span></span></span>; orientation-&gt;createPoint( p1.coord( <span class="hljs-number"><span class="hljs-number">0</span></span> ), p1.coord( <span class="hljs-number"><span class="hljs-number">1</span></span> ) ); } orientation-&gt;moveToOrigin(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isUnique( orientations, orientation ) ) { orientations.push_back( orientation ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> orientation; } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix3; } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix2; } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix1; }</code> </pre><br>  Dieser Code wird auf jede der Figuren angewendet, und dann werden die empfangenen eindeutigen Ausrichtungen entlang der x- und y-Achse verschoben, wodurch alle m√∂glichen Positionen jeder Figur erzeugt werden.  Als Ergebnis haben wir f√ºr jede der Figuren die folgende Anzahl unterschiedlicher Positionen: <br><br> <code>---------- Figure 1 <br> Count = 288 <br> ---------- Figure 2 <br> Count = 64 <br> ---------- Figure 3 <br> Count = 280 <br> ---------- Figure 4 <br> Count = 280 <br> ---------- Figure 5 <br> Count = 336 <br> ---------- Figure 6 <br> Count = 144 <br> ---------- Figure 7 <br> Count = 168 <br> ---------- Figure 8 <br> Count = 144 <br> ---------- Figure 9 <br> Count = 144 <br> ---------- Figure a <br> Count = 36 <br> ---------- Figure b <br> Count = 280 <br> ---------- Figure c <br> Count = 144 <br> ---------- Figure d <br> Count = 49 <br></code> <br>  Dann weisen wir jeder m√∂glichen Position eine boolesche Variable zu und erstellen eine Formel, wie oben beschrieben.  Danach rufen wir minisat direkt aus der Anwendung auf, die eine L√∂sung zur√ºckgibt - eine Menge unserer Variablen mit den zugewiesenen Werten true oder false.  Da wir wissen, welchen Positionen diese Variablen zugewiesen wurden, drucken wir die L√∂sung: <br><br> <code>bbbb 3 3 3 3 <br> ddbc 8 8 8 3 <br> dd 1 ccc 8 2 <br> 5 5 1 1 1 c 8 2 <br> 5 5 5 1 4 4 4 2 <br> 7 7 a 4 4 9 6 2 <br> 7 aaa 9 9 6 2 <br> 7 7 a 9 9 6 6 6 <br></code> <br><img src="https://ic.pics.livejournal.com/andyplekhanov/66030250/60414/60414_900.jpg" alt="Bild"><br><br><h2>  Was weiter </h2><br>  Darauf einzugehen w√§re nat√ºrlich nicht so interessant.  Daher stellte sich f√ºr mich zun√§chst die Frage, wie viele verschiedene L√∂sungen existieren, die sich nicht in trivialen Wendungen und Reflexionen des Spielfelds unterscheiden.  Zu diesem Zweck gibt es im SAT-Solver einen Modus, mit dem Sie Klauseln hinzuf√ºgen k√∂nnen, ohne vorhandene Informationen zu verlieren. Dies beschleunigt den Prozess erheblich, als ob die L√∂sung von Grund auf neu gesucht worden w√§re.  Die folgende L√∂sung kann durch Hinzuf√ºgen einer Klausel gefunden werden, die die Negation aller in der vorherigen L√∂sung vorhandenen Variablen enth√§lt.  Nachdem ich dieses Verfahren hinzugef√ºgt und die neue L√∂sung mit den vorherigen verglichen hatte, wobei ich die Wendungen und Reflexionen des Spielfelds ber√ºcksichtigte, erhielt ich 1364 verschiedene Optionen. <br><br>  Eine weitere interessante Erweiterung, die ich implementiert habe, war das Studium verschiedener anderer Formen des Spielfelds und der Figuren.  Und schlie√ülich war das Studium dreidimensionaler Spielfelder sehr interessant.  Dies ist jedoch ein Thema f√ºr einen anderen Artikel. <br><br><h2>  Update </h2><br><br>  Nach dem Hinzuf√ºgen einer zus√§tzlichen Bedingung: F√ºr jede Figur einer Klausel - sollte es mindestens eine Position dieser Figur im Spielfeld geben, ist die Berechnung viel schneller geworden.  Au√üerdem wurde ein Fehler behoben, wodurch die Anzahl aller m√∂glichen eindeutigen Optionen 16146 betr√§gt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de408299/">https://habr.com/ru/post/de408299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de408285/index.html">User Survey Geektimes</a></li>
<li><a href="../de408287/index.html">Wer ist f√ºr einen Unfall mit einem autonomen Auto verantwortlich? Wann werden wir autonomes KAMAZ auf den Stra√üen sehen?</a></li>
<li><a href="../de408289/index.html">Futuristische Benutzeroberfl√§che des neuen Tesla Model 3</a></li>
<li><a href="../de408291/index.html">Auf dem Zwergplaneten Ceres k√∂nnte in der Vergangenheit ein Ozean existieren</a></li>
<li><a href="../de408297/index.html">Wie Synchronschauspieler funktionieren: Teil 2</a></li>
<li><a href="../de408301/index.html">DJI droht dem Gericht mit einem Cybersicherheitsspezialisten, der Schl√ºssel f√ºr den Zugriff auf Unternehmenskonten auf GitHub entdeckt hat</a></li>
<li><a href="../de408303/index.html">Eine kurze Geschichte des elektronischen Papiers: Evolution und Perspektiven</a></li>
<li><a href="../de408305/index.html">Das neuronale Netz von Stanford diagnostiziert Lungenentz√ºndung im R√∂ntgenbild besser als √Ñrzte</a></li>
<li><a href="../de408307/index.html">Raise3D: 3D-Druck ersetzt die traditionelle Schuhherstellung</a></li>
<li><a href="../de408311/index.html">Protonen und Neutronen: Gedr√§nge in der Materie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>