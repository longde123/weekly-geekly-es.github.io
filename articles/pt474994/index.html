<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèùÔ∏è üèæ ‚ú® Como cortar um mon√≥lito em servi√ßos e manter o desempenho dos caches na mem√≥ria sem perder a consist√™ncia üöä ü§ß üë®üèΩ‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal. Meu nome √© Alexander, sou desenvolvedor Java no grupo de empresas Tinkoff. 

 Neste artigo, quero compartilhar minha experi√™ncia na solu√ß...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como cortar um mon√≥lito em servi√ßos e manter o desempenho dos caches na mem√≥ria sem perder a consist√™ncia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/474994/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/io/g8/yg/iog8ygcpquu5zvi7xmlsecbbwmu.png"></div><br>  Ol√° pessoal.  Meu nome √© Alexander, sou desenvolvedor Java no grupo de empresas Tinkoff. <br><br>  Neste artigo, quero compartilhar minha experi√™ncia na solu√ß√£o de problemas associados √† sincroniza√ß√£o do estado de caches em sistemas distribu√≠dos.  N√≥s os encontramos, dividindo nosso aplicativo monol√≠tico em <s>microsservi√ßos</s> .  Obviamente, falaremos sobre o armazenamento em cache de dados no n√≠vel da JVM, porque com os caches externos, os problemas de sincroniza√ß√£o s√£o resolvidos fora do contexto do aplicativo. <br><br>  Neste artigo, falarei sobre nossa experi√™ncia de mudar para uma arquitetura orientada a servi√ßos, acompanhada de uma mudan√ßa para o Kubernetes, e sobre a solu√ß√£o de problemas relacionados.  Consideraremos a abordagem para organizar o sistema de cache distribu√≠do In-Memory Data Grid (IMDG), suas vantagens e desvantagens, por causa do qual decidimos escrever nossa pr√≥pria solu√ß√£o. <br><br>  Este artigo discute um projeto cujo back-end √© escrito em Java.  Portanto, tamb√©m falaremos sobre padr√µes no campo de cache tempor√°rio na mem√≥ria.  Discutimos a especifica√ß√£o JSR-107, a especifica√ß√£o JSR-347 com falha e os recursos de armazenamento em cache no Spring.  Bem-vindo ao gato! <br><a name="habracut"></a><br><br><h1>  E vamos cortar o aplicativo em servi√ßos ... </h1><br>  Vamos seguir para a arquitetura orientada a servi√ßos e para o Kubernetes - foi o que decidimos h√° pouco mais de 6 meses.  Por um longo tempo, nosso projeto foi um mon√≥lito, muitos problemas relacionados √† d√≠vida t√©cnica acumulada e escrevemos novos m√≥dulos de aplicativos como servi√ßos separados.  Como resultado, a transi√ß√£o para uma arquitetura orientada a servi√ßos e um corte de mon√≥lito era inevit√°vel. <br><br>  Nosso aplicativo √© carregado, em m√©dia 500 rps chega a servi√ßos da web (no pico atinge 900 rps).  Para coletar todo o modelo de dados em resposta a cada solicita√ß√£o, √© necess√°rio ir aos v√°rios caches v√°rias centenas de vezes. <br><br>  Tentamos acessar o cache remoto no m√°ximo tr√™s vezes por solicita√ß√£o, dependendo do conjunto de dados necess√°rio, e nos caches internos da JVM, a carga atinge 90.000 rps por cache.  Temos cerca de 30 desses caches para uma variedade de entidades e o DTO-shki.  Em alguns caches carregados, n√£o podemos nem mesmo excluir o valor, pois isso pode levar a um aumento no tempo de resposta dos servi√ßos da web e a uma falha no aplicativo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mn/db/2v/mndb2vp6ot9byy_fqysaooom6j0.png"></div><br>  √â assim que parece o monitoramento de carga, removido dos caches internos em cada n√≥ durante o dia.  De acordo com o perfil de carregamento, √© f√°cil ver que a maioria das solicita√ß√µes s√£o dados de leitura.  Um carregamento de grava√ß√£o uniforme √© devido √† atualiza√ß√£o de valores em caches em uma determinada frequ√™ncia. <br><br>  O tempo de inatividade n√£o √© v√°lido para nosso aplicativo.  Portanto, com a finalidade de uma implanta√ß√£o cont√≠nua, sempre equilibramos todo o tr√°fego recebido em dois n√≥s e implantamos o aplicativo usando o m√©todo Rolling Update.  O Kubernetes se tornou nossa solu√ß√£o ideal de infraestrutura ao mudar para servi√ßos.  Assim, resolvemos v√°rios problemas ao mesmo tempo. <br><br><h3>  O problema de solicitar e configurar constantemente a infraestrutura para novos servi√ßos </h3><br>  Nos foi dado um espa√ßo para nome no cluster para cada circuito, que temos tr√™s: dev - para desenvolvedores, qa - para testadores, prod - para clientes. <br><br>  Com o espa√ßo para nome real√ßado, a adi√ß√£o de um novo servi√ßo ou aplicativo se resume a escrever quatro manifestos: Implanta√ß√£o, Servi√ßo, Ingress e ConfigMap. <br><br><h3>  Alta toler√¢ncia de carga </h3><br>  Os neg√≥cios est√£o em expans√£o e em constante crescimento - h√° um ano, a carga m√©dia era duas vezes menor que a atual. <br><br>  A escala horizontal no Kubernetes permite nivelar as economias de escala com o aumento da carga de trabalho do projeto desenvolvido. <br><br><h3>  Manuten√ß√£o, coleta e monitoramento de logs </h3><br>  A vida se torna muito mais f√°cil quando n√£o h√° necessidade de adicionar logs ao sistema de registro ao adicionar cada n√≥, configurar a cerca de m√©tricas (a menos que voc√™ tenha um sistema de monitoramento por push), executar configura√ß√µes de rede e simplesmente instalar o software necess√°rio para a opera√ß√£o. <br><br>  Obviamente, tudo isso pode ser automatizado usando o Ansible ou o Terraform, mas no final, escrever v√°rios manifestos para cada servi√ßo √© muito mais f√°cil. <br><br><h3>  Alta confiabilidade </h3><br>  O mecanismo interno do k8s de amostras de vitalidade e prontid√£o permite que voc√™ n√£o se preocupe com o fato de o aplicativo come√ßar a ficar mais lento ou parar completamente de responder. <br><br>  O Kubernetes agora controla o ciclo de vida dos pods de lareira que cont√™m cont√™ineres de aplicativos e o tr√°fego direcionado a eles. <br><br>  Juntamente com as comodidades descritas, precisamos resolver v√°rios problemas para tornar os servi√ßos adequados para a escala horizontal e o uso de um modelo de dados comum para muitos servi√ßos.  Foi necess√°rio resolver dois problemas: <br><br><ol><li>  <b>O estado do aplicativo.</b>  Quando o projeto √© implantado no cluster k8s, os pods com cont√™ineres da nova vers√£o do aplicativo come√ßam a ser criados que n√£o est√£o relacionados ao estado dos pods da vers√£o anterior.  Novos pods de aplicativos podem ser criados em servidores de cluster arbitr√°rios que atendem √†s restri√ß√µes especificadas.  Al√©m disso, agora todos os cont√™ineres de aplicativos em execu√ß√£o no pod do Kubernetes podem ser destru√≠dos a qualquer momento, se o probe Liveness disser que precisa ser reiniciado. </li><li>  <b>Consist√™ncia de dados.</b>  √â necess√°rio manter a consist√™ncia e a integridade dos dados entre si em todos os n√≥s.  Isso √© especialmente verdadeiro se v√°rios n√≥s funcionarem em um √∫nico modelo de dados.  √â inaceit√°vel que, quando solicita√ß√µes para diferentes n√≥s do aplicativo na resposta, dados inconsistentes cheguem ao cliente. </li></ol><br>  No desenvolvimento moderno de sistemas escal√°veis, a arquitetura Stateless √© a solu√ß√£o para os problemas acima.  N√≥s nos livramos do primeiro problema movendo todas as estat√≠sticas para o armazenamento em nuvem S3. <br><br>  No entanto, devido √† necessidade de agregar um modelo de dados complexo e economizar tempo de resposta de nossos servi√ßos da web, n√£o podemos nos recusar a armazenar dados em caches na mem√≥ria.  Para resolver o segundo problema, eles criaram uma biblioteca para sincronizar o estado dos caches internos de n√≥s individuais. <br><br><h1>  Sincronizamos caches em n√≥s separados </h1><br>  Como dados iniciais, temos um sistema distribu√≠do composto por N n√≥s.  Cada n√≥ possui cerca de 20 caches na mem√≥ria, cujos dados s√£o atualizados v√°rias vezes por hora. <br><br>  A maioria dos caches possui uma pol√≠tica de atualiza√ß√£o de dados TTL (tempo de vida √∫til); alguns dados s√£o atualizados com uma opera√ß√£o CRON a cada 20 minutos devido ao alto carregamento.  A carga de trabalho nos caches varia de v√°rios milhares de rps √† noite a v√°rias dezenas de milhares durante o dia.  A carga de pico, como regra, n√£o excede 100.000 rps.  O n√∫mero de registros no armazenamento tempor√°rio n√£o excede v√°rias centenas de milhares e √© colocado no heap de um n√≥. <br><br>  Nossa tarefa √© obter consist√™ncia de dados entre o mesmo cache em n√≥s diferentes, bem como o menor tempo de resposta poss√≠vel.  Considere o que geralmente h√° maneiras de resolver esse problema. <br><br>  A primeira e mais simples solu√ß√£o que vem √† mente √© colocar todas as informa√ß√µes em um cache remoto.  Nesse caso, voc√™ pode se livrar completamente do estado do aplicativo, n√£o pensar nos problemas de obter consist√™ncia e ter um √∫nico ponto de acesso a um data warehouse tempor√°rio. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ez/zm/bg/ezzmbg3cuvhczrwpwmh5hg5a0-o.png"></div><br>  Esse m√©todo de armazenamento tempor√°rio de dados √© bastante simples, e n√≥s o usamos.  Armazenamos em cache parte dos dados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Redis</a> , que √© um armazenamento de dados NoSQL na RAM.  No Redis, geralmente registramos uma estrutura de resposta de servi√ßo da Web e, para cada solicita√ß√£o, precisamos enriquecer esses dados com informa√ß√µes relevantes, para as quais precisamos enviar v√°rias centenas de solicita√ß√µes ao cache local. <br><br>  Obviamente, n√£o podemos retirar os dados dos caches internos para armazenamento remoto, pois o custo de transmiss√£o de um volume de tr√°fego pela rede n√£o nos permitir√° atingir o tempo de resposta necess√°rio. <br><br>  A segunda op√ß√£o √© usar um IMDG ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">In-Memory Data Grid</a> ), que √© um cache distribu√≠do na mem√≥ria.  O esquema dessa solu√ß√£o √© o seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l7/ku/k9/l7kuk9uaiuydck1hs1boeykflys.png"></div><br>  A arquitetura IMDG √© baseada no princ√≠pio de Particionamento de Dados de caches internos de n√≥s individuais.  De fato, isso pode ser chamado de tabela de hash distribu√≠da em um cluster de n√≥s.  O IMDG √© considerado uma das implementa√ß√µes mais r√°pidas de armazenamento distribu√≠do tempor√°rio. <br><br>  Existem muitas implementa√ß√µes do IMDG, sendo a mais popular a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hazelcast</a> .  O cache distribu√≠do permite armazenar dados na RAM em v√°rios n√≥s de aplicativos com um n√≠vel aceit√°vel de confiabilidade e preserva√ß√£o da consist√™ncia, o que √© alcan√ßado pela replica√ß√£o de dados. <br><br>  A tarefa de construir um cache distribu√≠do n√£o √© f√°cil, no entanto, o uso de uma solu√ß√£o IMDG pronta para n√≥s pode ser um bom substituto para os caches da JVM e eliminar os problemas de replica√ß√£o, consist√™ncia e distribui√ß√£o de dados entre todos os n√≥s de aplicativos. <br><br>  A maioria dos fornecedores de IMDG para aplicativos Java implementa o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JSR-107</a> , a API Java padr√£o para trabalhar com caches internos.  Em geral, esse padr√£o tem uma hist√≥ria bastante grande, que discutirei em mais detalhes abaixo. <br><br>  Era uma vez id√©ias para implementar sua interface para interagir com o IMDG - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JSR 347</a> .  Mas a implementa√ß√£o dessa API n√£o recebeu suporte suficiente da comunidade Java e agora temos uma interface √∫nica para interagir com os caches na mem√≥ria, independentemente da arquitetura do nosso aplicativo.  Bom ou ruim √© outra quest√£o, mas nos permite ignorar completamente todas as dificuldades de implementar um cache distribu√≠do na mem√≥ria e trabalhar com ele como um cache de um aplicativo monol√≠tico. <br><br>  Apesar das vantagens √≥bvias do uso do IMDG, essa solu√ß√£o ainda √© mais lenta que o cache da JVM padr√£o, devido √† sobrecarga de garantir a replica√ß√£o cont√≠nua dos dados distribu√≠dos entre v√°rios n√≥s da JVM, al√©m de fazer o backup desses dados.  No nosso caso, a quantidade de dados para armazenamento tempor√°rio n√£o era t√£o grande, os dados com margem cabiam na mem√≥ria de um aplicativo; portanto, sua aloca√ß√£o em v√°rias JVMs parecia uma solu√ß√£o desnecess√°ria.  E o tr√°fego de rede adicional entre n√≥s de aplicativos sob cargas pesadas pode afetar significativamente o desempenho e aumentar o tempo de resposta dos servi√ßos da web.  No final, decidimos escrever nossa pr√≥pria solu√ß√£o para esse problema. <br><br>  Deixamos os caches na mem√≥ria como um armazenamento tempor√°rio de dados e, para manter a consist√™ncia, usamos o gerenciador de filas RabbitMQ.  Adotamos o padr√£o de design comportamental <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúPublisher - Subscriber‚Äù</a> e mantivemos a relev√¢ncia dos dados excluindo o registro modificado do cache de cada n√≥.  O esquema da solu√ß√£o √© o seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/05/y9/di/05y9dihavtlltrsgxxnkvuj5bhs.png"></div><br>  O diagrama mostra um cluster de N n√≥s, cada um com um cache de mem√≥ria padr√£o.  Todos os n√≥s usam um modelo de dados comum e devem ser consistentes.  No primeiro acesso ao cache por uma chave arbitr√°ria, o valor no cache est√° ausente e colocamos o valor real do banco de dados nele.  Com qualquer altera√ß√£o - exclua o registro. <br><br>  As informa√ß√µes reais na resposta do cache aqui s√£o fornecidas pela sincroniza√ß√£o da exclus√£o de uma entrada quando ela √© alterada em qualquer um dos n√≥s.  Cada n√≥ no sistema possui uma fila no gerenciador de filas RabbitMQ.  A grava√ß√£o em todas as filas √© feita atrav√©s de um ponto de acesso comum do tipo T√≥pico.  Isso significa que as mensagens enviadas ao T√≥pico se enquadram em todas as filas associadas a ele.  Portanto, ao alterar o valor em qualquer n√≥ do sistema, esse valor ser√° exclu√≠do do armazenamento tempor√°rio de cada n√≥ e o acesso subsequente iniciar√° a grava√ß√£o do valor atual no cache do banco de dados. <br><br>  A prop√≥sito, um mecanismo PUB / SUB semelhante existe no Redis.  Mas, na minha opini√£o, ainda √© melhor usar o gerenciador de filas para trabalhar com filas, e o RabbitMQ foi perfeito para nossa tarefa. <br><br><h1>  Norma JSR 107 e sua implementa√ß√£o </h1><br>  A API Java Cache padr√£o para armazenamento tempor√°rio de dados na mem√≥ria (especifica√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JSR-107</a> ) tem um hist√≥rico bastante longo, desenvolvida por 12 anos. <br><br>  Durante tanto tempo, as abordagens para o desenvolvimento de software mudaram, os mon√≥litos foram substitu√≠dos pela arquitetura de microsservi√ßos.  Devido a uma falta t√£o longa de especifica√ß√µes para a API de cache, houve at√© pedidos para desenvolver caches de API para sistemas distribu√≠dos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JSR-347</a> (grades de dados para a plataforma Java).  Por√©m, ap√≥s o t√£o esperado lan√ßamento do JSR-107 e o lan√ßamento do JCache, a solicita√ß√£o para criar uma especifica√ß√£o separada para sistemas distribu√≠dos foi retirada. <br><br>  Nos √∫ltimos 12 anos no mercado, o local para armazenamento tempor√°rio de dados mudou de HashMap para ConcurrentHashMap com o lan√ßamento do Java 1.5 e, mais tarde, surgiram muitas implementa√ß√µes de c√≥digo aberto do cache na mem√≥ria. <br><br>  Ap√≥s o lan√ßamento do JSR-107, as solu√ß√µes dos fornecedores come√ßaram a implementar gradualmente a nova especifica√ß√£o.  Para o JCache, existem at√© fornecedores especializados em cache distribu√≠do - os pr√≥prios Data Grids, cuja especifica√ß√£o nunca foi implementada. <br><br>  Considere o que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">consiste o</a> pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">javax.cache</a> e como obter uma inst√¢ncia de cache para nosso aplicativo: <br><pre><code class="java hljs">CachingProvider provider = Caching.getCachingProvider(<span class="hljs-string"><span class="hljs-string">"org.cache2k.jcache.provider.JCacheProvider"</span></span>); CacheManager cacheManager = provider.getCacheManager(); CacheConfiguration&lt;Integer, String&gt; config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MutableConfiguration&lt;Integer, String&gt;() .setTypes(Integer.class, String.class) .setReadThrough(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) . . .; Cache&lt;Integer, String&gt; cache = cacheManager.createCache(cacheName, config);</code> </pre> <br>  Aqui, o cache √© um carregador de inicializa√ß√£o para o CachingProvider. <br><br>  No nosso caso, o JCacheProvider, que √© a implementa√ß√£o cache2k do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SPI do</a> provedor JSR-107, ser√° carregado do ClassLoader.  Para o carregador, talvez voc√™ n√£o precise especificar a implementa√ß√£o do provedor, mas ele tentar√° carregar a implementa√ß√£o que <br><blockquote>  META-INF / services / javax.cache.spi.CachingProvider </blockquote><br>  De qualquer forma, no ClassLoader, deve haver uma √∫nica implementa√ß√£o CachingProvider. <br><br>  Se voc√™ usar a biblioteca javax.cache sem nenhuma implementa√ß√£o, uma exce√ß√£o ser√° lan√ßada ao tentar criar o JCache.  O objetivo do provedor √© criar e gerenciar o ciclo de vida do CacheManager, que, por sua vez, √© respons√°vel por gerenciar e configurar os caches.  Portanto, para criar um cache, voc√™ deve seguir o seguinte caminho: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/lp/fs/fxlpfsdfmlifqegpwtaynhiakt8.png"></div><br>  Os caches padr√£o criados usando o CacheManager devem ter uma configura√ß√£o compat√≠vel com a implementa√ß√£o.  O CacheConfiguration padr√£o com par√¢metros fornecido pelo javax.cache pode ser estendido para uma implementa√ß√£o espec√≠fica do CacheProvider. <br><br>  Hoje, existem dezenas de implementa√ß√µes diferentes da especifica√ß√£o JSR-107: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ehcache</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Goiaba</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cafe√≠na</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cache2k</a> .  Muitas implementa√ß√µes s√£o In-Memory Data Grid em sistemas distribu√≠dos - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hazelcast</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Oracle Coherence</a> . <br><br>  Tamb√©m h√° muitas implementa√ß√µes de armazenamento tempor√°rio que n√£o oferecem suporte √† API padr√£o.  Por um longo tempo em nosso projeto, usamos o Ehcache 2, que n√£o √© compat√≠vel com o JCache (a implementa√ß√£o da especifica√ß√£o apareceu no Ehcache 3).  A necessidade de uma transi√ß√£o para uma implementa√ß√£o compat√≠vel com JCache apareceu com a necessidade de monitorar o status dos caches na mem√≥ria.  Usando o MetricRegistry padr√£o, foi poss√≠vel fixar o monitoramento apenas com a ajuda da implementa√ß√£o JCacheGaugeSet, que coleta m√©tricas do JCache padr√£o. <br><br>  Como escolher a implementa√ß√£o de cache na mem√≥ria apropriada para o seu projeto?  Talvez voc√™ deva prestar aten√ß√£o ao seguinte: <br><br><ol><li>  Voc√™ precisa de suporte para a especifica√ß√£o JSR-107. </li><li>  Tamb√©m vale a pena prestar aten√ß√£o na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">velocidade da</a> implementa√ß√£o selecionada.  Sob cargas pesadas, o desempenho dos caches internos pode ter um impacto significativo no tempo de resposta do seu sistema. </li><li>  Suporte na primavera.  Se voc√™ usar a estrutura conhecida em seu projeto, vale a pena considerar o fato de que nem toda implementa√ß√£o de cache da JVM possui um CacheManager compat√≠vel no Spring. </li></ol><br>  Se voc√™ estiver usando ativamente o Spring em seu projeto, assim como n√≥s, ent√£o para o cache de dados, provavelmente seguir√° a abordagem orientada a aspectos (AOP) e usar√° a anota√ß√£o @Cacheable.  O Spring usa seu pr√≥prio CacheManager SPI para os aspectos funcionarem.  O seguinte bean √© necess√°rio para que os caches de primavera funcionem: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> org.springframework.cache.<span class="hljs-function"><span class="hljs-function">CacheManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CachingProvider provider = Caching.getCachingProvider(); CacheManager cacheManager = provider.getCacheManager(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JCacheCacheManager(cacheManager); }</code> </pre><br>  Para trabalhar com caches no paradigma AOP, considera√ß√µes transacionais tamb√©m devem ser consideradas.  O cache de primavera deve necessariamente suportar o gerenciamento de transa√ß√µes.  Para isso, o Spring CacheManager herda as propriedades AbstractTransactionSupportingCacheManager, que podem ser usadas para sincronizar opera√ß√µes de put / evict executadas em uma transa√ß√£o e execut√°-las somente ap√≥s o comprometimento de uma transa√ß√£o bem-sucedida. <br><br>  O exemplo acima mostra o uso do wrapper JCacheCacheManager para o gerenciador de especifica√ß√µes de cache.  Isso significa que qualquer implementa√ß√£o JSR-107 tamb√©m tem compatibilidade com o Spring CacheManager.  Esse √© outro motivo para escolher um cache de mem√≥ria com suporte para a especifica√ß√£o JSR do seu projeto.  Mas se esse suporte ainda n√£o for necess√°rio, mas eu realmente quero usar o @Cacheable, voc√™ ter√° suporte para mais duas solu√ß√µes de cache interno: EhCacheCacheManager e CaffeineCacheManager. <br><br>  Ao escolher a implementa√ß√£o do cache na mem√≥ria, n√£o levamos em considera√ß√£o o suporte do IMDG para sistemas distribu√≠dos, como mencionado anteriormente.  Para manter o desempenho dos caches da JVM em nosso sistema, criamos nossa pr√≥pria solu√ß√£o. <br><br><h1>  Limpando caches em um sistema distribu√≠do </h1><br>  IMDGs modernos usados ‚Äã‚Äãem projetos com arquitetura de microsservi√ßos permitem distribuir dados na mem√≥ria entre todos os n√≥s em funcionamento do sistema usando o particionamento de dados escal√°vel com o n√≠vel de redund√¢ncia necess√°rio. <br><br>  Nesse caso, h√° muitos problemas associados √† sincroniza√ß√£o, consist√™ncia dos dados e assim por diante, sem mencionar o aumento no tempo de acesso ao armazenamento tempor√°rio.  Esse esquema √© redundante se a quantidade de dados usada se encaixar na RAM de um n√≥ e, para manter a consist√™ncia dos dados, basta excluir essa entrada em todos os n√≥s para qualquer altera√ß√£o no valor do cache. <br><br>  Ao implementar essa solu√ß√£o, vem √† mente a id√©ia de usar algum EventListener, no JCache, existe um CacheEntryRemovedListener para o evento de excluir uma entrada do cache.  Parece que √© suficiente adicionar sua pr√≥pria implementa√ß√£o do Ouvinte, que enviar√° mensagens para o t√≥pico quando o registro for exclu√≠do, e o cache eut√©tico em todos os n√≥s estiver pronto - desde que cada n√≥ escute eventos da fila associada ao t√≥pico geral, conforme mostrado no diagrama acima. <br><br>  Ao usar essa solu√ß√£o, os dados em n√≥s diferentes ser√£o inconsistentes devido ao fato de que EventLists em qualquer processo de implementa√ß√£o do JCache ap√≥s o evento ocorrer.  Ou seja, se n√£o houver registro no cache local para a chave especificada e houver um registro para a mesma chave em qualquer outro n√≥, o evento n√£o ser√° enviado ao t√≥pico. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_a/ev/5c/_aev5cw333ni_cnstj5elxbowhw.png"></div><br>  Considere outras maneiras de capturar o evento de um valor ser exclu√≠do do cache local. <br><br>  No pacote javax.cache.event, ao lado de EventListeners, tamb√©m h√° um CacheEntryEventFilter, que, de acordo com o JavaDoc, √© usado para verificar qualquer evento CacheEntryEvent antes de enviar esse evento ao CacheEntryListener, seja um registro, exclus√£o, atualiza√ß√£o ou evento relacionado √† expira√ß√£o do registro. em cache.  Ao usar o filtro, nosso problema permanecer√°, pois a l√≥gica ser√° executada ap√≥s o log do evento CacheEntryEvent e ap√≥s a opera√ß√£o CRUD no cache. <br><br>  No entanto, √© poss√≠vel capturar o in√≠cio de um evento para excluir um registro do cache.  Para fazer isso, use a ferramenta interna do JCache que permite usar as especifica√ß√µes da API para gravar e carregar dados de uma fonte externa, se eles n√£o estiverem no cache.  Existem duas interfaces para isso no pacote javax.cache.integration: <br><br><ul><li>  CacheLoader - para carregar os dados solicitados pela chave, se n√£o houver entradas no cache. </li><li>  CacheWriter - para usar a grava√ß√£o, exclus√£o e atualiza√ß√£o de dados em um recurso externo ao invocar as opera√ß√µes de cache correspondentes. </li></ul><br>  Para garantir consist√™ncia, os m√©todos CacheWriter s√£o at√¥micos em rela√ß√£o √† opera√ß√£o de cache correspondente.  Parece que encontramos uma solu√ß√£o para o nosso problema. <br><br>  Agora, podemos manter a consist√™ncia da resposta dos caches na mem√≥ria nos n√≥s ao usar nossa implementa√ß√£o do CacheWriter, que envia eventos para o t√≥pico do RabbitMQ sempre que houver alguma altera√ß√£o no registro no cache local. <br><br><h1>  Conclus√£o </h1><br>  Ao desenvolver qualquer projeto, ao procurar uma solu√ß√£o adequada para problemas emergentes, √© preciso levar em considera√ß√£o sua especificidade.  No nosso caso, os recursos caracter√≠sticos do modelo de dados do projeto, o c√≥digo herdado herdado e a natureza da carga n√£o permitiram o uso de nenhuma das solu√ß√µes existentes para o problema de armazenamento em cache distribu√≠do. <br><br>  √â muito dif√≠cil tornar uma implementa√ß√£o universal aplic√°vel a qualquer sistema desenvolvido.  Para cada uma dessas implementa√ß√µes, existem condi√ß√µes ideais de uso.  No nosso caso, as especificidades do projeto levaram √† solu√ß√£o descrita neste artigo.  Se algu√©m tiver um problema semelhante, ficaremos felizes em compartilhar nossa solu√ß√£o e public√°-la no GitHub. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt474994/">https://habr.com/ru/post/pt474994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt474982/index.html">Tutorial JavaFX: FXML e SceneBuilder</a></li>
<li><a href="../pt474984/index.html">RabbitMQ vs. Kafka: Failover e alta disponibilidade</a></li>
<li><a href="../pt474988/index.html">Bem-vindo ao Mitap: Carreiras na Data Science for Beginners</a></li>
<li><a href="../pt474990/index.html">Pr√°tica dif√≠cil: como criar uma rede Wi-Fi em um parque da cidade</a></li>
<li><a href="../pt474992/index.html">An√°lise de baterias de laptop com defeito. Notas para motociclistas el√©tricos</a></li>
<li><a href="../pt474996/index.html">O resumo dos eventos de TI em novembro (parte dois)</a></li>
<li><a href="../pt475000/index.html">Testando publicamente as solu√ß√µes Ethereum Cloud e Cloud Privacy and Scalability</a></li>
<li><a href="../pt475002/index.html">O trabalho n√£o √© um lobo, parte 2. Passe pelo chefe e sobreviva em liberdade condicional</a></li>
<li><a href="../pt475004/index.html">Quanto ganharam os desenvolvedores de diferentes qualifica√ß√µes no primeiro semestre de 2019</a></li>
<li><a href="../pt475006/index.html">Como criar um servi√ßo de compara√ß√£o de documentos em um prot√≥tipo em 28 horas e ganhar um hackathon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>