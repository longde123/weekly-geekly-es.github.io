<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≤ üèè üíâ Warum Go schlecht f√ºr dumme Programmierer ist üÜî ‚õπüèΩ ü§üüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Artikel wurde als Antwort auf einen zuvor ver√∂ffentlichten Antipodenartikel geschrieben. 





 In den letzten mehr als zwei Jahren habe ich mit G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum Go schlecht f√ºr dumme Programmierer ist</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448932/"><p>  Der Artikel wurde als Antwort auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen</a> zuvor ver√∂ffentlichten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Antipodenartikel</a> geschrieben. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ac9/24e/5c8/ac924e5c8c90275379b035cfa5b1f23b.jpg" alt="Bild"></p><br><p>  In den letzten mehr als zwei Jahren habe ich mit Go einen speziellen RADIUS-Server mit einem entwickelten Abrechnungssystem implementiert.  Dabei lerne ich die Feinheiten der Sprache selbst.  Die Programme selbst sind sehr einfach und nicht der Zweck, einen Artikel zu schreiben, aber die Erfahrung mit Go selbst verdient es, ein paar Worte zu seiner Verteidigung zu sagen.  Go wird zu einer immer beliebteren Sprache f√ºr seri√∂sen, skalierbaren Code.  Die Sprache wird in Google erstellt und dort aktiv verwendet.  Zusammenfassend glaube ich aufrichtig, dass das Go-Sprachdesign f√ºr dumme Programmierer schlecht ist. </p><a name="habracut"></a><br><h1>  Entwickelt f√ºr schwache Programmierer? </h1><br><blockquote>  Schwaches Gerede √ºber Probleme.  Starkes Gespr√§ch √ºber Ideen und Tr√§ume ... </blockquote><p>  Go ist sehr einfach zu erlernen, so einfach, dass Sie den Code mit wenig oder gar keiner Vorbereitung lesen k√∂nnen.  Diese Funktion der Sprache wird in vielen Unternehmen der Welt verwendet, wenn der Code zusammen mit Nicht-Kernspezialisten (Managern, Kunden usw.) gelesen wird.  Dies ist sehr praktisch f√ºr Methoden wie Design Driven Development. </p><br><p>  Selbst unerfahrene Programmierer beginnen nach ein oder zwei Wochen, ziemlich anst√§ndigen Code zu produzieren.  Das Buch, das ich Go studiert habe, hei√üt ‚ÄûGo Programming‚Äú (geschrieben von Mark Summerfield).  Das Buch ist sehr gut, es ber√ºhrt viele Nuancen der Sprache.  Nach unn√∂tig komplizierten Sprachen wie Java, PHP ist der Mangel an Magie erfrischend.  Fr√ºher oder sp√§ter haben viele eingeschr√§nkte Programmierer den Wunsch, alte Methoden in einem neuen Bereich anzuwenden.  Ist das wirklich notwendig? </p><br><p>  Rob Pike (der Hauptideologe der Sprache) hat Go als eine Industriesprache geschaffen, die einfach zu lesen und effektiv zu verwenden ist.  Die Sprache ist auf maximale Produktivit√§t in gro√üen Teams ausgelegt, und daran besteht kein Zweifel.  Viele unerfahrene Programmierer beklagen, dass ihnen viele Funktionen fehlen.  Dieser Wunsch nach Einfachheit war eine bewusste Entscheidung der Sprachentwickler, und um vollst√§ndig zu verstehen, wof√ºr es war, m√ºssen wir die Motivation der Entwickler und das, was sie in Go erreicht haben, verstehen. </p><br><p>  Warum wurde es so einfach gemacht?  Hier sind ein paar Zitate von Rob Pike: </p><br><blockquote>  Der entscheidende Punkt hierbei ist, dass unsere Programmierer keine Forscher sind.  Sie sind normalerweise sehr jung, kommen nach der Schule zu uns, vielleicht haben sie Java, C / C ++ oder Python studiert.  Sie sind nicht in der Lage, eine herausragende Sprache zu verstehen, aber gleichzeitig m√∂chten wir, dass sie gute Software erstellen.  Deshalb sollte Sprache leicht zu verstehen und zu lernen sein. <br><br>  Er sollte vertraut sein, grob gesagt wie C.  Google-Programmierer beginnen ihre Karriere fr√ºh und sind haupts√§chlich mit Verfahrenssprachen vertraut, insbesondere mit der C-Familie.  Das Erfordernis einer schnellen Produktivit√§t in einer neuen Programmiersprache bedeutet, dass die Sprache nicht zu radikal sein sollte. <br></blockquote><p>  Kluge Worte, richtig? </p><br><h1>  Artefakte der Einfachheit </h1><br><blockquote>  Einfachheit ist eine notwendige Voraussetzung f√ºr das Sch√∂ne.  Leo Tolstoi. </blockquote><p>  Einfach zu sein ist eines der wichtigsten Ziele in jedem Design.  Wie Sie wissen, ist ein perfektes Projekt kein Projekt, bei dem nichts hinzugef√ºgt werden muss, sondern eines, bei dem nichts entfernt werden muss.  Viele glauben, dass ein komplexes Werkzeug ben√∂tigt wird, um komplexe Aufgaben zu l√∂sen (oder sogar auszudr√ºcken).  Dies ist jedoch nicht so.  Nehmen Sie zum Beispiel die PERL-Sprache.  Die Ideologen der Sprache glaubten, dass ein Programmierer mindestens drei verschiedene M√∂glichkeiten haben sollte, um ein Problem zu l√∂sen.  Die Ideologen der Go-Sprache gingen einen anderen Weg, sie entschieden, dass ein Weg genug ist, um das Ziel zu erreichen, aber wirklich gut.  Dieser Ansatz hat eine ernsthafte Grundlage: Der einzige Weg ist leichter zu lernen und schwerer zu vergessen. </p><br><p>  Viele Migranten beklagen, dass die Sprache keine eleganten Abstraktionen enth√§lt.  Ja, aber das ist einer der Hauptvorteile der Sprache.  Die Sprache enth√§lt ein Minimum an Magie - daher sind keine tiefen Kenntnisse erforderlich, um das Programm zu lesen.  Die Ausf√ºhrlichkeit des Codes ist √ºberhaupt kein Problem.  Ein gut geschriebenes Golang-Programm wird vertikal mit wenig oder keiner Strukturierung gelesen.  Au√üerdem ist die Lesegeschwindigkeit eines Programms mindestens eine Gr√∂√üenordnung schneller als das Schreiben.  Wenn Sie der Meinung sind, dass der gesamte Code eine einheitliche Formatierung aufweist (ausgef√ºhrt mit dem integrierten Befehl gofmt), ist das Lesen einiger zus√§tzlicher Zeilen √ºberhaupt kein Problem. </p><br><h1>  Nicht sehr ausdrucksstark </h1><br><blockquote>  Kunst toleriert nicht, wenn sie seine Freiheit einschr√§nkt.  Genauigkeit liegt nicht in seiner Verantwortung. </blockquote><p>  Aufgrund des Wunsches nach Einfachheit fehlen Go Konstruktionen, die in anderen Sprachen f√ºr Menschen, die an sie gew√∂hnt sind, als etwas Nat√ºrliches wahrgenommen werden.  Das mag zun√§chst etwas unpraktisch sein, aber dann merkt man, dass das Programm um ein Vielfaches einfacher und eindeutiger zu lesen ist. </p><br><p>  Ein Konsolendienstprogramm, das stdin oder eine Datei aus Befehlszeilenargumenten liest, sieht beispielsweise folgenderma√üen aus: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bufio"</span></span> <span class="hljs-string"><span class="hljs-string">"flag"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { flag.Parse() scanner := newScanner(flag.Args()) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { text += scanner.Text() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := scanner.Err(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } fmt.Println(text) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newScanner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(flags []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bufio</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scanner</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(flags) == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bufio.NewScanner(os.Stdin) } file, err := os.Open(flags[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bufio.NewScanner(file) }</code> </pre> <br><p>  Obwohl die L√∂sung f√ºr dasselbe Problem in der D-Sprache etwas k√ºrzer aussieht, ist es nicht einfacher zu lesen </p><br><pre> <code class="plaintext hljs">import std.stdio, std.array, std.conv; void main(string[] args) { try { auto source = args.length &gt; 1 ? File(args[1], "r") : stdin; auto text = source.byLine.join.to!(string); writeln(text); } catch (Exception ex) { writeln(ex.msg); } }</code> </pre> <br><h1>  Kopiere die H√∂lle </h1><br><blockquote>  Der Mensch tr√§gt die H√∂lle in sich.  Martin Luther. </blockquote><p>  Anf√§nger beschweren sich st√§ndig √ºber Go wegen des Mangels an Generika.  Um dieses Problem zu beheben, verwenden die meisten von ihnen das direkte Kopieren von Code.  Zum Beispiel glauben solche ungl√ºcklichen Fachleute, dass die Funktion zum Zusammenfassen der Liste von Ganzzahlen nur durch einfaches Kopieren und Einf√ºgen f√ºr jeden Datentyp implementiert werden kann. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64Sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x := <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(list); x++ { result += list[x] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(result) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32Sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x := <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(list); x++ { result += list[x] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(result) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { list32 := []<span class="hljs-keyword"><span class="hljs-keyword">int32</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} list64 := []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} fmt.Println(int32Sum(list32)) fmt.Println(int64Sum(list64)) }</code> </pre> <br><p>  Die Sprache verf√ºgt √ºber ausreichende Mittel, um solche Konstruktionen zu implementieren.  Zum Beispiel ist die allgemeine Programmierung in Ordnung. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> list { res = fn(res, val) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32Sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a - b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> list { res = fn(res, val) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64Sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a - b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { list32 := []<span class="hljs-keyword"><span class="hljs-keyword">int32</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} list64 := []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} fmt.Println(Eval32(list32, int32Add)) fmt.Println(Eval64(list64, int64Add)) fmt.Println(Eval64(list64, int64Sub)) }</code> </pre> <br><p>  Und obwohl sich herausstellte, dass unser Code etwas l√§nger als der vorherige Fall war, wurde er verallgemeinert.  Daher wird es f√ºr uns nicht schwierig sein, alle arithmetischen Operationen zu implementieren. </p><br><p>  Viele werden sagen, dass das D-Programm deutlich k√ºrzer aussieht und richtig sein wird. </p><br><pre> <code class="plaintext hljs">import std.stdio; import std.algorithm; void main(string[] args) { [1, 2, 3, 4, 5].reduce!((a, b) =&gt; a + b).writeln; }</code> </pre> <br><p>  Es ist jedoch nur k√ºrzer, aber nicht korrekter, da das Fehlerbehandlungsproblem in der D-Implementierung vollst√§ndig ignoriert wird. </p><br><p>  Im wirklichen Leben verringert sich die L√ºcke schnell, wenn die Komplexit√§t der Logik zunimmt.  Noch schneller wird die L√ºcke kleiner, wenn eine Aktion erforderlich ist, die nicht mit Standard-Sprachoperatoren ausgef√ºhrt werden kann. </p><br><p>  In Bezug auf Unterst√ºtzbarkeit, Erweiterbarkeit und Lesbarkeit gewinnt meiner Meinung nach die Go-Sprache, obwohl sie an Ausf√ºhrlichkeit verliert. </p><br><p>  Die verallgemeinerte Programmierung bietet uns in einigen F√§llen unbestreitbare Vorteile.  Dies zeigt deutlich das Sortierpaket.  Um eine Liste zu sortieren, reicht es f√ºr uns aus, die Schnittstelle sort.Interface zu implementieren. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"sort"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Names []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ns Names)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Len</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ns) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ns Names)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Less</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ns[i] &lt; ns[j] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ns Names)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { ns[i], ns[j] = ns[j], ns[i] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { names := Names{<span class="hljs-string"><span class="hljs-string">"London"</span></span>, <span class="hljs-string"><span class="hljs-string">"Berlin"</span></span>, <span class="hljs-string"><span class="hljs-string">"Rim"</span></span>} sort.Sort(names) }</code> </pre> <br><p>  Wenn Sie ein Open Source-Projekt verwenden und den Befehl grep "interface {}" -R ausf√ºhren, werden Sie sehen, wie oft verwirrte Schnittstellen verwendet werden.  Die engstirnigen Genossen werden sofort sagen, dass dies alles auf den Mangel an Generika zur√ºckzuf√ºhren ist.  Dies ist jedoch bei weitem nicht immer der Fall.  Nehmen Sie zum Beispiel die Sprache DELPHI.  Trotz derselben Generika enth√§lt es einen speziellen Typ VARIANT f√ºr Operationen mit beliebigen Datentypen.  Go macht das Gleiche. </p><br><h1>  Von einer Waffe auf Spatzen </h1><br><blockquote>  Und eine Zwangsjacke muss der Gr√∂√üe des Wahnsinns entsprechen.  Stanislav Lets. </blockquote><p>  Viele Fans von Extremsportarten k√∂nnen sagen, dass Go einen anderen Mechanismus zur Schaffung von Generika hat - Reflexion.  Und sie werden Recht haben ... aber nur in seltenen F√§llen. </p><br><p>  Rob Pike warnt uns: </p><br><blockquote>  Dies ist ein leistungsstarkes Tool, das mit Vorsicht verwendet werden sollte.  Es sollte vermieden werden, bis es unbedingt notwendig ist. <br></blockquote><p>  Wikipedia sagt uns Folgendes: </p><br><blockquote>  Reflexion bedeutet einen Prozess, bei dem ein Programm zur Laufzeit seine eigene Struktur und sein eigenes Verhalten verfolgen und √§ndern kann.  Das der Reflexion zugrunde liegende Programmierparadigma wird als reflexive Programmierung bezeichnet.  Dies ist eine Art Metaprogrammierung. <br></blockquote><p>  Wie Sie wissen, m√ºssen Sie jedoch f√ºr alles bezahlen.  In diesem Fall ist es: </p><br><ul><li>  Schwierigkeiten beim Schreiben von Programmen </li><li>  Programmausf√ºhrungsgeschwindigkeit </li></ul><br><p>  Daher sollte die Reflexion als gro√ükalibrige Waffe mit Vorsicht eingesetzt werden.  Die gedankenlose Verwendung von Reflexion f√ºhrt zu unlesbaren Programmen, konstanten Fehlern und geringer Geschwindigkeit.  Genau das ist, dass der Snob-Programmierer seinen Code vor anderen, pragmatischeren und bescheideneren Kollegen zur Schau stellen k√∂nnte. </p><br><h1>  Kulturgep√§ck von C?  Nein, aus mehreren Sprachen! </h1><br><blockquote>  Zusammen mit dem Staat bleiben den Erben Schulden. </blockquote><p>  Trotz der Tatsache, dass viele glauben, dass die Sprache vollst√§ndig auf dem Erbe von C basiert, ist dies nicht der Fall.  Die Sprache hat viele Aspekte der besten Programmiersprachen aufgenommen. </p><br><h2>  Syntax </h2><br><p>  Zun√§chst basiert die Syntax grammatikalischer Konstruktionen auf der Syntax der C-Sprache.  Die DELPHI-Sprache hatte jedoch auch einen signifikanten Einfluss.  Wir sehen also, dass die √ºbersch√ºssigen Klammern vollst√§ndig entfernt werden, was die Lesbarkeit des Programms erheblich beeintr√§chtigt.  Au√üerdem enth√§lt die Sprache den Operator :: =, der der DELPHI-Sprache inh√§rent ist.  Das Konzept der Pakete stammt aus Sprachen wie ADA.  Die Deklaration nicht verwendeter Entit√§ten ist der Sprache PROLOG entlehnt. </p><br><h2>  Semantik </h2><br><p>  Die Semantik der DELPHI-Sprache wurde als Grundlage f√ºr Pakete verwendet.  Jedes Paket kapselt Daten und Code und enth√§lt private und √∂ffentliche Einheiten.  Auf diese Weise k√∂nnen Sie die Paketschnittstelle auf ein Minimum reduzieren. </p><br><p>  Die Implementierungsoperation nach Delegierungsmethode wurde von DELPHI ausgeliehen. </p><br><h2>  Zusammenstellung </h2><br><p>  Kein Wunder, dass es einen Witz gibt: Go wurde entwickelt, w√§hrend das C-Programm kompiliert wurde.  Eine der St√§rken der Sprache ist die ultraschnelle Kompilierung.  Die Idee wurde von DELPHI entlehnt.  Au√üerdem entspricht jedes Go-Paket dem DELPHI-Modul.  Diese Pakete werden nur bei Bedarf neu kompiliert.  Daher ist es nach der n√§chsten Bearbeitung nicht erforderlich, das gesamte Programm zu kompilieren, es reicht jedoch aus, nur die ge√§nderten Pakete und Pakete in Abh√§ngigkeit von diesen ge√§nderten Paketen neu zu kompilieren (und dies nur, wenn sich die Paketschnittstellen ge√§ndert haben). </p><br><h2>  Hochwertige Designs </h2><br><p>  Die Sprache enth√§lt viele verschiedene Konstrukte auf hoher Ebene, die in keiner Weise mit Sprachen auf niedriger Ebene wie C assoziiert sind. </p><br><ul><li>  Linien </li><li>  Tabellen-Hash </li><li>  Scheiben </li><li>  Das Tippen von Enten stammt aus Sprachen wie RUBY (die leider viele nicht verstehen und nicht in vollem Umfang nutzen). </li></ul><br><h2>  Speicherverwaltung </h2><br><p>  Die Speicherverwaltung verdient im Allgemeinen einen separaten Artikel.  Wenn in Sprachen wie C ++ die Kontrolle vollst√§ndig dem Entwickler √ºberlassen bleibt, wurde in sp√§teren Sprachen wie DELPHI ein Referenzz√§hlmodell verwendet.  Bei diesem Ansatz waren zyklische Verbindungen nicht zul√§ssig, da verlorene Cluster gebildet wurden. Daher ist die Erkennung solcher Cluster (wie in C #) in Go integriert.  Dar√ºber hinaus ist der Garbage Collector effektiver als die meisten derzeit bekannten Implementierungen und kann bereits f√ºr viele Echtzeitaufgaben verwendet werden.  Die Sprache selbst erkennt Situationen, in denen ein Wert zum Speichern einer Variablen auf dem Stapel zugewiesen werden kann.  Dies reduziert die Belastung des Speichermanagers und erh√∂ht die Geschwindigkeit des Programms. </p><br><h2>  Parallelit√§t und Wettbewerb </h2><br><p>  Die Parallelit√§t und Wettbewerbsf√§higkeit der Sprache ist nicht zu loben.  Keine einfache Sprache kann mit der Go-Sprache auch nur aus der Ferne konkurrieren.  Fairerweise ist anzumerken, dass das Modell nicht von den Autoren der Sprache erfunden wurde, sondern einfach aus der guten alten ADA-Sprache entlehnt wurde.  Die Sprache ist in der Lage, Millionen paralleler Verbindungen unter Verwendung aller CPUs zu verarbeiten, w√§hrend sie bei komplexen Multithread-Code-Problemen mit Deadlocks und Race-Bedingungen in der Gr√∂√üenordnung weniger h√§ufig vorkommt. </p><br><h1>  Zus√§tzliche Vorteile </h1><br><blockquote>  Wenn dies von Vorteil ist, wird jeder selbstlos. </blockquote><p>  Die Sprache bietet uns auch eine Reihe von unbestrittenen Vorteilen: </p><br><ul><li>  Die einzige ausf√ºhrbare Datei nach dem Erstellen des Projekts vereinfacht die Bereitstellung von Anwendungen erheblich. </li><li>  Statische Typisierung und Typinferenz k√∂nnen die Anzahl der Fehler im Code erheblich reduzieren, auch ohne Tests zu schreiben.  Ich kenne einige Programmierer, die √ºberhaupt nicht auf das Schreiben von Tests verzichten und gleichzeitig die Qualit√§t ihres Codes nicht wesentlich beeintr√§chtigt. </li><li>  Sehr einfache Cross-Kompilierung und hervorragende Portabilit√§t der Standardbibliothek, was die Entwicklung plattform√ºbergreifender Anwendungen erheblich vereinfacht. </li><li>  RE2-regul√§re Ausdr√ºcke sind threadsicher und haben vorhersehbare Laufzeiten. </li><li>  Eine leistungsstarke Standardbibliothek, mit der die meisten Projekte auf Frameworks von Drittanbietern verzichten k√∂nnen. </li><li>  Die Sprache ist leistungsf√§hig genug, um sich auf das Problem zu konzentrieren, und nicht auf Methoden, um es zu l√∂sen, und gleichzeitig niedrig genug, um das Problem effizient zu l√∂sen. </li><li>  Das Go-√ñkosystem enth√§lt bereits sofort einsatzbereite Tools f√ºr alle Gelegenheiten: Tests, Dokumentation, Paketverwaltung, leistungsstarke Linters, Codegenerierung, einen Detektor f√ºr Rennbedingungen usw. </li><li>  Go Version 1.11 verf√ºgt jetzt √ºber ein integriertes semantisches Abh√§ngigkeitsmanagement, das auf beliebten VCS-Hosts basiert.  Alle Tools, aus denen sich das Go-√ñkosystem zusammensetzt, verwenden diese Dienste, um Code von ihnen auf einen Schlag herunterzuladen, zu kompilieren und zu installieren.  Und das ist gro√üartig.  Mit dem Aufkommen von Version 1.11 wurde auch das Problem mit der Paketversionierung vollst√§ndig behoben. </li><li>  Da die Hauptidee der Sprache darin besteht, Magie zu reduzieren, ermutigt die Sprache Entwickler, die Fehlerbehandlung explizit zu behandeln.  Und das ist richtig, denn sonst wird er die Fehlerbehandlung einfach ganz vergessen.  Eine andere Sache ist, dass die meisten Entwickler die Fehlerbehandlung absichtlich ignorieren und es vorziehen, den Fehler einfach weiterzuleiten, anstatt sie zu verarbeiten. </li><li>  Die Sprache implementiert die klassische OOP-Methodik nicht, da es in Go keine Virtualit√§t in ihrer reinen Form gibt.  Dies ist jedoch kein Problem bei der Verwendung von Schnittstellen.  Das Fehlen von OOP verringert die Eintrittsbarriere f√ºr Anf√§nger erheblich. </li></ul><br><h1>  Einfache Vorteile f√ºr die Gemeinschaft </h1><br><blockquote>  Komplizieren ist einfach, Vereinfachen ist schwierig. </blockquote><p>  Go wurde so konzipiert, dass es einfach und hervorragend ist.  Es wurde f√ºr intelligente Programmierer geschrieben, die alle Vorteile der Teamarbeit verstehen und die endlose Variabilit√§t der Sprachen auf Unternehmensebene satt haben.  Mit einem relativ kleinen Satz syntaktischer Konstruktionen in seinem Arsenal unterliegt es praktisch keinen √Ñnderungen im Laufe der Zeit. Daher haben Entwickler viel Zeit speziell f√ºr die Entwicklung und nicht f√ºr ein endloses Studium von Sprachinnovationen frei. </p><br><p>  Unternehmen haben auch eine Reihe von Vorteilen: Eine niedrige Einstiegsschwelle erm√∂glicht es Ihnen, schnell einen Spezialisten zu finden, und die Unver√§nderlichkeit der Sprache erm√∂glicht es Ihnen, nach 10 Jahren denselben Code zu verwenden. </p><br><h1>  Fazit </h1><br><blockquote>  Die gro√üe Gehirngr√∂√üe hat noch keinen einzigen Elefanten zum Nobelpreistr√§ger gemacht. </blockquote><p>  F√ºr jene Programmierer, deren pers√∂nliches Ego den Teamgeist √ºberwiegt, sowie f√ºr Theoretiker, die akademische Aufgaben und endlose "Selbstverbesserung" lieben, ist die Sprache wirklich schlecht, weil sie eine universelle Handwerkssprache ist, die es nicht erlaubt, √§sthetische Freude am Ergebnis ihrer Arbeit zu haben und sich zu zeigen ein Fachmann vor Kollegen (vorausgesetzt, wir messen den Geist genau anhand dieser Kriterien und nicht anhand des IQ-Koeffizienten).  Wie alles im Leben ist es eine Frage der pers√∂nlichen Priorit√§ten.  Wie alle lohnenden Innovationen hat die Sprache bereits einen langen Weg von der universellen Verleugnung zur Massenerkennung zur√ºckgelegt.  Sprache ist in ihrer Einfachheit genial, aber wie Sie wissen, ist alles Geniale einfach! </p><br><h1>  Zusammenfassung </h1><br><p>  Unter all der scharfen Kritik an Go fallen vor allem folgende Aussagen auf: </p><br><ul><li>  Keine Generika.  Wenn wir uns die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statistiken der</a> beliebtesten Sprachen ansehen, stellen wir fest, dass die H√§lfte der zehn wichtigsten Sprachen keine Generika enth√§lt.  Generika werden meist nur in Containern ben√∂tigt.  Daher ist der Gewinn von ihnen nicht zu gro√ü. </li><li>  Andere Sprachen wie Rust sind viel besser (zumindest in XXX-Site-Kategorien).  Wenn wir uns die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statistiken der</a> beliebtesten Sprachen ansehen, werden wir Rust √ºberhaupt nicht in der Liste finden, oder es wird irgendwo unter der Bewertung liegen.  Pers√∂nlich mag ich Rust, aber ich habe mich f√ºr Go entschieden. </li><li>  XXX hat so ein Br√∂tchen.  Dies ist die Kehrseite der M√ºnze der Einfachheit.  Ob es ein Nachteil ist oder nicht, muss jeder entscheiden.  Die Entwickler des Projekts bevorzugten jedoch die Einfachheit. </li><li>  Sie werden Go 2.0 ver√∂ffentlichen, dann werden wir sehen.  Diese Position wird von Beobachtern eingenommen, nicht von Praktizierenden. </li><li>  Nicht ausdrucksstark genug.  Ich stimme zu, in einigen Bereichen ist Ausdruckskraft lahm, aber im Allgemeinen ist es eine einfache und konsistente Sprache.  Dar√ºber hinaus sind wir aufgrund der Armut der Sprache gezwungen, der Architektur der entwickelten Anwendung mehr Aufmerksamkeit zu schenken, was sich positiv auf ihre Flexibilit√§t auswirkt. </li></ul><br><p>  Tats√§chlich dachte der Artikel nicht √ºber die syntaktischen Vorteile der Go-Sprache nach, sondern √ºber einen kurzen √úberblick √ºber ihre Vorteile f√ºr die Teamarbeit und die effektive Entwicklung des zu entwickelnden Projekts.  Es wurde davon ausgegangen, dass der Artikel in Bezug auf spezifischere Probleme fortgesetzt worden w√§re.  Aufgrund des mangelnden Interesses an dem Thema wird es jedoch h√∂chstwahrscheinlich keine Fortsetzung geben. </p><br><h1>  Ein Experiment </h1><br><blockquote>  Glauben Sie nicht den Worten - weder Ihren noch Fremden, sondern den Taten - sowohl Ihren als auch den Fremden. </blockquote><p>  <em>Der letzte Teil richtet sich ausschlie√ülich an Personen, die sich als konstruktiv denkende Optimisten betrachten und dies mit ihren eigenen Angelegenheiten best√§tigen k√∂nnen.</em>  <em>Der Rest des Publikums, bitte √ºberspringen Sie diesen Teil.</em> </p><br><p>  Dieses Experiment wurde von Freunden inspiriert, die behaupteten, dass alle konstruktiv denkenden Optimisten die Weiten unseres Landes lange (zumindest virtuell) verlassen und sich beispielsweise f√ºr Stack Overflow entschieden h√§tten, und hier blieben meistens Snobs.  Lange Zeit habe ich ihnen nicht geglaubt, deshalb habe ich beschlossen, dieses Experiment durchzuf√ºhren. <br>  Auf dem Hub wurden mehrere Artikel ver√∂ffentlicht, die das Ergebnis der Analyse der Kommentare sind, zu denen ich zitiere. </p><br><ul><li>  In der Tat wurde die Hypothese meiner Freunde best√§tigt, aber es gibt immer noch angemessene Leute unter den Stra√üenh√§ndlern, obwohl ihr Prozentsatz schnell sinkt.  Juri Bykow nennt solche Menschen " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Narren</a> ", auf denen das ganze Land ruht.  Ihm zufolge ist ihr Prozentsatz gering (etwa 2%).  Ich bin nicht so pessimistisch und ich denke, dass es viel mehr davon gibt. </li><li>  Das Gesetz der Medien.  Destruktive Informationen sind von viel gr√∂√üerem Interesse als konstruktive Informationen. </li><li>  Die Psychologie der Menge.  Dies ist eine schreckliche Sache, es macht sogar ein missbr√§uchliches Schaf aus einer angemessenen Person.  Ein Mann in einer Menschenmenge ist kein Mann mehr.  Von Objektivit√§t kann keine Rede sein.  Keine logischen Argumente, keine ma√ügeblichen Quellen oder Pr√§zedenzf√§lle betreffen ihn mehr. </li><li>  Verantwortung und Straflosigkeit.  Menschen sind bereit, andere zu dem√ºtigen, um sich selbst zu erh√∂hen (zumindest in ihren eigenen Augen).  Vor allem, wenn Sie nicht antworten m√ºssen (was einfacher sein k√∂nnte - klicken Sie auf das Minuszeichen und Sie m√ºssen nicht einmal einen Kommentar schreiben).  Worte und Taten haben so viel gemeinsam wie zwischen einem Kanal und einem Abwasserkanal. </li><li>  Eitelkeit.  Die meisten Snobs sind bereit, sich in irgendeiner Weise abzuheben.  Sie haben keine Angst vor moralischen Barrieren. </li><li>  Pessimismus  Im Gegensatz zu westlichen L√§ndern (und insbesondere Amerika) herrschen im Land pessimistische Gef√ºhle vor.  Wie Sie wissen, sucht ein Optimist nach M√∂glichkeiten inmitten von Schwierigkeiten, und ein Pessimist sucht nach Schwierigkeiten unter Chancen.  In unserem Land achtet fast niemand auf die positiven Eigenschaften von irgendetwas. </li><li>  Professionalit√§t und Weltanschauung.  Die meisten Menschen w√§hlen Werkzeuge als Selbstzweck und nicht als Mittel zum Zweck.  Die Leute haben vergessen, wie man mit Informationen arbeitet.  Die Menschen sehen keine W√§lder hinter den B√§umen.  Aus einer Reihe von Informationen k√∂nnen sie die Hauptgedanken nicht extrahieren.  Niemand m√∂chte aus einer anderen, f√ºr sich selbst nicht standardm√§√üigen Sichtweise schauen.  Dissens wird unterdr√ºckt.  Es wird hier nicht akzeptiert. </li><li>  Freundlichkeit und Respekt.  Gelobte freundliche Gruppen existieren nur in Worten.  Agile Entwicklungswerte sind nur auf dem Papier. </li><li>  Heuchelei.  Sie k√∂nnen dazu im Allgemeinen einen separaten Artikel schreiben. </li><li>  Prinzip.  Es gibt Leute, die die richtige Frage stellen: ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was zum Teufel mache ich?</a>  ‚Äù, Nicht jeder versteht jedoch, dass f√ºr uns aufgrund des Mangels an Prinzipien ein momentanes egoistisches Interesse wichtiger ist als alle unsere Prinzipien zusammen.  Es ist am einfachsten, alles den Umst√§nden zuzuschreiben und zu sagen, dass nichts von uns abh√§ngt. </li></ul><br><p>  <strong>Mit tiefem Respekt und Sympathie f√ºr alle konstruktiv denkenden Optimisten.</strong> </p><br><p>  Adverax </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448932/">https://habr.com/ru/post/de448932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448916/index.html">Grid oder Flexbox?</a></li>
<li><a href="../de448918/index.html">Webkomponenten: 9 wissenswerte Projekte im Jahr 2019</a></li>
<li><a href="../de448920/index.html">Verwenden der JavaScript-Konsole in Browsern</a></li>
<li><a href="../de448922/index.html">K√ºnstliche Intelligenz verbessert die Grafikqualit√§t alter Videospiele und macht es wirklich gut</a></li>
<li><a href="../de448926/index.html">10 M√∂glichkeiten, um IT-Infrastruktur f√ºr alle zu sparen</a></li>
<li><a href="../de448934/index.html">Kostenlose Links oder Freizeitaktivit√§ten zum Websitebesitzer</a></li>
<li><a href="../de448936/index.html">Formalisierung der Sprache. Einige √úberlegungen</a></li>
<li><a href="../de448938/index.html">Nach dem Hackathon in Nischni Nowgorod</a></li>
<li><a href="../de448940/index.html">Dell Latitude 5491: Ein robuster Unternehmens-Laptop mit einem leistungsstarken Prozessor</a></li>
<li><a href="../de448942/index.html">Kryptow√§hrung: lebt oder stirbt?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>