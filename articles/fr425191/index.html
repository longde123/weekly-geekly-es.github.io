<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚û°Ô∏è ‚öóÔ∏è üí≤ Fastware üßïüèª üéôÔ∏è üë®üèª‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Andrei Alexandrescu est une v√©ritable l√©gende vivante. Il s'agit d'une personne qui a apport√© une contribution significative √† l'histoire des langages...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fastware</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/425191/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Andrei Alexandrescu</a> est une v√©ritable l√©gende vivante.  Il s'agit d'une personne qui a apport√© une contribution significative √† l'histoire des langages de programmation modernes et des techniques g√©n√©ralis√©es et de m√©taprogrammation.  Combien d'exemplaires ont √©t√© cass√©s dans les discussions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur les</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">normes de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conception</a> et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">codage</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ modernes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">101</a> (√©crites avec les armoiries C ++ exceptionnelles de Sutter), et d'autres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livres et articles</a> .  En tant que co-auteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">du langage D</a> , il a eu l'occasion non seulement de th√©oriser, mais aussi de faire de son r√™ve une r√©alit√© - et, ce qui est caract√©ristique, il l'a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">incarn√©</a> . <br><br>  Maintenant, vous tenez dans ses mains un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> de la conf√©rence DotNext 2018 Piter, qui parle des technologies d'optimisation modernes.  Qu'est-ce que .NET a √† voir avec cela?  Il s'agit d'un rapport fondamental d'une personne qui a optimis√© toute sa vie.  Si les performances sont importantes pour vous, vous devez les regarder (ou lire cet article).  Bienvenue au chat! <br><br><img width="100%" src="https://habrastorage.org/webt/9_/mg/9m/9_mg9mjeeamxyknlbdqeg4ukoa4.jpeg"><br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZazBhE1IQd0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  L'art du benchmarking </h1><br>  Je voudrais discuter avec vous de plusieurs sujets li√©s √† l'analyse comparative.  Pour commencer, r√©p√©tons quelques choses de base.  <b>La loi d'Amdahl</b> fait partie des classiques de l'informatique, elle est principalement utilis√©e dans le calcul parall√®le, mais fonctionne dans tout syst√®me complexe.  Si nous voulons am√©liorer le travail d'un certain syst√®me, nous devons commencer l√† o√π les principaux probl√®mes de ce syst√®me sont concentr√©s.  La loi elle-m√™me est √©vidente: si un composant repr√©sente 20% du syst√®me, alors l'am√©lioration maximale des performances du syst√®me qui peut √™tre obtenue en optimisant le fonctionnement de ce composant uniquement est de 20%.  Trop souvent, je dois rencontrer des gens (bien s√ªr, nos lecteurs ne leur appartiennent pas) qui font des choses comme l'optimisation de l'analyse en ligne de commande.  Ces op√©rations prennent les 10 premi√®res microsecondes de votre programme, et les gens analysent leur complexit√© algorithmique et sont horrifi√©s si le temps est quadratique. <br><br>  Comme vous le savez probablement, avant de commencer l'optimisation, il est n√©cessaire de profiler l'application et de s√©lectionner des points chauds.  Ici, il faut dire √† propos de la <b>loi de Ladma</b> (ce n'est pas un vrai nom de famille, et Amdal, relu).  Vous devez concentrer vos efforts sur la composante qui m√®ne au plus grand investissement de temps.  Il doit √™tre d√©plac√© en dehors de l'application, effectuer les travaux n√©cessaires, revenir en arri√®re et tester √† nouveau.  La raison pour laquelle vous devez le faire est que, tr√®s souvent, une am√©lioration des performances de 20% est le r√©sultat de dix am√©liorations de 2%.  Et dans le cadre d'un grand syst√®me, il est impossible de mesurer une si petite am√©lioration.  Pour cela, le composant doit √™tre test√© dans une suite de tests.  Une am√©lioration de 20% des performances de l'un des principaux composants du syst√®me peut signifier une am√©lioration de 5% pour le syst√®me dans son ensemble, et pour certains domaines, c'est un excellent r√©sultat.  N'oubliez pas que les optimisations peuvent avoir un certain nombre d'effets globaux. Par cons√©quent, sur la base des r√©sultats de l'analyse comparative s√©lective, vous devez √™tre tr√®s prudent lorsque vous tirez des conclusions sur le fonctionnement du syst√®me dans son ensemble. <br><br>  Une erreur que nos lecteurs ne sont pas s√ªrs de commettre, mais qui est g√©n√©ralement assez courante: les gens mesurent la vitesse d'assemblage du d√©bogage.  Cela ne devrait jamais √™tre fait.  Cela revient √† se f√¢cher √† cause de la faible vitesse de l'escargot lors des courses: il n'est pas destin√© √† une telle comp√©tition, il a d'autres objectifs dans la vie.  Une autre erreur, un peu moins √©vidente: les gens mesurent d'abord les performances de base du syst√®me, et imm√©diatement apr√®s cela effectuent un benchmarking.  Mais apr√®s avoir collect√© la base de r√©f√©rence, de nombreuses ressources sont r√©chauff√©es.  Par exemple, les fichiers ouverts sont mis en m√©moire tampon et restent en m√©moire (au moins sous Linux).  Ainsi, le deuxi√®me test ne sera plus rapide que parce qu'il est lanc√© apr√®s le premier.  Cela se produit m√™me avec des appels malloc.  Apr√®s ces appels, le syst√®me ne revient pas √† son √©tat d'origine m√™me si des appels de lib√©ration de m√©moire sont effectu√©s.  La configuration interne, la mise en cache et les fonctionnalit√©s utilis√©es par l'allocateur de m√©moire permettent aux appels malloc suivants de s'ex√©cuter beaucoup plus rapidement.  M√™me sans tenir compte de l'effet du cache, malloc se souvient que, par exemple, certaines fonctions ont allou√© de la m√©moire pour des objets de 4 kilo-octets plusieurs fois, ce qui signifie que vous devez avoir une liste libre avec une taille d'√©l√©ment de 4 kilo-octets.  Ou un autre exemple: les recherches DNS sont mises en cache pour √™tre r√©utilis√©es apr√®s la premi√®re requ√™te.  Si possible, lors de l'analyse comparative, vous devez red√©marrer l'ensemble du processus √† chaque fois, du d√©but √† la fin. <br><br>  Par exemple, afin de remettre compl√®tement le syst√®me dans son √©tat d'origine, dans le cas de fichiers, ils doivent √™tre ouverts sur un disque s√©par√©, qui, apr√®s la fin du test, doit √™tre supprim√© (si je comprends bien, cela peut √™tre fait sous Windows).  L'op√©ration n'est pas facile, mais dans la plupart des cas n√©cessaire. <br><br>  Poursuivant la conversation sur les erreurs lors de l'optimisation, j'ai d√ª faire face √† de tels cas lorsque les co√ªts d'impression sont inclus dans les r√©sultats des tests.  Il y a des erreurs de proc√©dure lorsque plus d'une chose est modifi√©e avant chaque mesure, ce qui viole les principes les plus fondamentaux d'une exp√©rience scientifique, car il n'est pas clair quel effet vous mesurez.  Une autre erreur grave est lorsque certains rares cas sont optimis√©s, ce qui conduit √† une pessimisation dans d'autres situations. <br><br><img src="https://habrastorage.org/webt/rs/fj/lf/rsfjlfl8ndtxzczw96ur5jyeijo.jpeg"><br><br>  Voici un exemple avec Stack Overflow.  L'auteur trie souvent des donn√©es d√©j√† tri√©es et est surpris, car la fonction `is_sorted 'est √©videmment beaucoup plus rapide que` sort.  Pourquoi alors dans `trier la premi√®re ligne n'est pas` si is_sorted retourne?  Vous optimisez un cas extr√™mement rare, des donn√©es compl√®tement tri√©es, et tous ceux qui ont au moins un √©l√©ment non tri√© devront supporter les co√ªts de cette optimisation.  Cela ne vaut pas la peine. <br><br>  Je pense que je n‚Äôai pas √† prouver depuis longtemps que les architectures concurrentes actuelles sont extr√™mement complexes: changement de fr√©quence dynamique, interruption par d‚Äôautres processus, virtualisation, etc.  Par cons√©quent, il est presque impossible d'obtenir le m√™me temps lors de la mesure, vos indicateurs trembleront toujours.  Par cons√©quent, il ne faut pas se fier √† des choses qui semblent √©videntes.  Disons, il peut nous sembler √©vident que moins d'instructions signifient un code plus rapide, et ce n'est pas toujours vrai.  Il peut √©galement sembler que l'utilisation des donn√©es stock√©es sera toujours plus rapide que la r√©ex√©cution des calculs, donc si vous mettez en cache les r√©sultats, tout ira bien.  Comme dans le cas pr√©c√©dent, il ne peut pas √™tre √©nonc√© sans √©quivoque, tout comme l'inverse ne peut √™tre √©nonc√© sans condition - tout d√©pend du contexte.  √âvidemment, vous ne devriez avoir qu'une chose: tout doit √™tre mesur√©.  Si vous mesurez tout, vous obtiendrez de meilleurs r√©sultats que des experts ayant des connaissances qui ne prennent pas de mesures. <br><br>  Il existe un certain nombre de pratiques assez fiables, dont la discussion peut vous conduire √† des r√©flexions int√©ressantes.  Nous devons commencer par le fait que les math√©matiques ne vous laisseront pas tomber.  Il permet de montrer que des syst√®mes √† diff√©rentes vitesses peuvent √™tre √©quivalents.  Les math√©matiques donnent des r√®gles pour montrer l'√©quivalence de certaines choses et identifier certaines propri√©t√©s, et m√™me si elles ne sont pas biais√©es, peu importe ce qui est int√©ressant et ce qui ne l'est pas.  Beaucoup de gens pensent que l'optimisation est bas√©e sur la connaissance du code machine et du travail avec les bits, mais en fait elle a beaucoup de math√©matiques, car vous prouvez qu'un syst√®me plus rapide est √©quivalent √† un syst√®me plus lent. <br><br>  Une autre r√®gle g√©n√©rale est que les ordinateurs aiment les choses ennuyeuses.  Avez-vous besoin de vous multiplier par deux vecteurs, un milliard d'√©l√©ments chacun?  C'est une t√¢che id√©ale pour un ordinateur, tout l'√©quipement qu'il contient est sp√©cialement aff√ªt√© pour ce genre de t√¢ches.  Pour analyser ces donn√©es, en fonction d'eux pour construire une expression r√©guli√®re - je ne veux pas le faire.  Les ordinateurs n'aiment pas les choses comme les branches, les d√©pendances, les appels indirects, bref - ils n'aiment pas le code intelligent, ils aiment le code ennuyeux.  Les ordinateurs n'aiment pas l'enregistrement indirect - un probl√®me complexe avec lequel les personnes impliqu√©es dans le fer luttent depuis longtemps et ne peuvent pas r√©soudre. <br><br>  Une autre r√®gle est que vous devez privil√©gier les op√©rations les moins puissantes, en d'autres termes, pr√©f√©rer l'ajout √† la multiplication et la multiplication √† l'exponentiation.  Encore une fois, les math√©matiques sont utiles ici. <br><br>  Enfin, la derni√®re r√®gle - le plus petit, le plus beau.  La petite taille permet aux ordinateurs de tirer le meilleur parti de leurs avantages, car ils pr√©f√®rent que les donn√©es, et en particulier les instructions, soient proches les unes des autres.  Les r√©sultats de plusieurs mesures de la vitesse de l'application seront toujours diff√©rents, vous aurez une certaine distribution des r√©sultats.  Habituellement, nous prenons simplement la moyenne de ces quelques r√©sultats.  Mais le probl√®me est qu'en raison des sp√©cificit√©s des ordinateurs, la moyenne inclura beaucoup de bruit.  Lorsque Bill Gates prend le bus, en moyenne, chaque passager d'un bus est un milliardaire.  Cela semble g√©nial, mais c'est peu de confort pour une personne sans-abri voyageant dans le m√™me bus.  Une situation similaire se produit avec les interruptions: l'op√©ration de multiplication prend des nanosecondes, mais lorsque vous effectuez de nombreuses mesures de telles op√©rations, l'une d'entre elles aura in√©vitablement une interruption de deux millisecondes.  La diff√©rence est de trois ordres de grandeur, et pourtant, les d√©veloppeurs n'en tiennent pas toujours compte. <br><br>  Donc, je le r√©p√®te: le bruit dans les ordinateurs est toujours additif;  pour les gens, cela peut sembler insignifiant, mais pour le microcr√©dit, il est important, et la moyenne arithm√©tique comprendra beaucoup de bruit.  Au lieu de la moyenne, vous avez besoin d'un indicateur qui ne mesurera que le temps que vous pouvez en quelque sorte influencer.  Si nous abordons cette question du point de vue des math√©matiques, nous verrons que nous devons trouver une valeur qui correspondra au plus grand nombre de mesures que nous ayons faites.  En d'autres termes, nous avons besoin d'un mod.  Cela nous am√®ne imm√©diatement au probl√®me: que se passe-t-il si vous prenez le mod quicksort?  Si l'algorithme est probabiliste ou si les donn√©es sont al√©atoires, alors il n'y aura presque jamais de mode.  La densit√© des valeurs sera presque la m√™me dans tout le spectre.  Dans ce cas, nous rejetons simplement les 5% des mesures les plus importantes et apr√®s cela nous prenons la valeur moyenne - ou le maximum, dans ce dernier cas nous aurons un plafond qui ne sera pas d√©pass√© dans 95% des cas.  Presque toujours, il y aura un sujet assis dans l'ancien sous-sol avec un modem lent, dans lequel chaque page se chargera pendant une heure.  Purement humains, nous sympathisons bien s√ªr avec lui, mais nous ne pouvons techniquement pas aider tout le monde - par cons√©quent, les 5% de cas restants doivent √™tre n√©glig√©s.  En g√©n√©ral, lors de la r√©solution de probl√®mes de r√©seau, nous nous concentrons souvent sur le 95e centile, car il est impossible de se concentrer sur le 100e.  Le centi√®me centile signifie le r√©sultat le plus lent de toutes les mesures collect√©es - ce n'est pas informatif. <br><br><h1>  Remplacer les branches par l'arithm√©tique </h1><br>  Comment, j'esp√®re, il est devenu clair que la mesure n'est pas un probl√®me facile.  Regardons quelques exemples et commen√ßons par essayer de remplacer la ramification par l'arithm√©tique.  Nous parlons de cas o√π nous avons besoin d'une instruction if, mais l'utiliser trop souvent n'est pas souhaitable.  Au lieu de cela, nous int√©grerons le r√©sultat de la branche en tant que valeur 0/1.  Le code sera lin√©aire, l'ordinateur n'aura qu'√† le parcourir du d√©but √† la fin, sans penser √† l'√©tape suivante. <br><br>  Essayons de r√©soudre le probl√®me suivant: transf√©rer les plus bas de chaque quartile du tableau vers le premier quartile.  En d'autres termes, le tableau doit √™tre divis√© en quatre parties et la valeur minimale de chaque partie doit √™tre plac√©e au d√©but du tableau. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = p.Length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = n / <span class="hljs-number"><span class="hljs-number">4</span></span>, k = n / <span class="hljs-number"><span class="hljs-number">2</span></span>, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * n / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; n / <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[k] &lt; p[m]) m = k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[l] &lt; p[m]) m = l; Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Ci-dessus est le code de base.  Soit dit en passant, je peux fi√®rement signaler que j'ai traduit ces exemples en C # et qu'ils ont √©t√© compil√©s avec succ√®s.  Le code lui-m√™me est assez simple: `m est affect√© √† l'index de la plus petite des deux valeurs situ√©es aux indices` i et` j, puis une affectation similaire est r√©p√©t√©e deux fois de plus, en fonction des deux autres indices.  Enfin, la valeur √† l'indice `m est invers√©e dans le tableau avec la valeur √† l'indice` i.  Comme vous pouvez le voir, nous contournons le tableau √† l'aide de quatre variables inductives. <br><br>  Le probl√®me de tester un tel algorithme sera int√©ressant et pas √©vident.  Nous devrons le tester non pas sur un ensemble de donn√©es, mais sur des donn√©es qui pourraient survenir dans divers cas.  Par exemple, sur des donn√©es qui ressemblent √† des tuyaux d'un organe: augmentez d'abord, puis diminuez;  sur des donn√©es al√©atoires avec une distribution uniforme;  sur un ensemble al√©atoire de z√©ros et de uns - √† partir de donn√©es al√©atoires, la diff√©rence est qu'il y aura de nombreuses valeurs en double;  sur des donn√©es d√©j√† tri√©es;  enfin, sur des donn√©es obtenues par des mesures r√©elles de certains ph√©nom√®nes physiques.  Ce sera une approche s√©rieuse pour mesurer la vitesse d'un algorithme, et elle est g√©n√©ralement accept√©e par les personnes qui √©tudient les algorithmes. <br><br>  Essayons d'am√©liorer le code que nous venons de rencontrer. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = n / <span class="hljs-number"><span class="hljs-number">4</span></span>, k = n / <span class="hljs-number"><span class="hljs-number">2</span></span>, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * n / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; q; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[k] &lt; p[m]) m = k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[l] &lt; p[m]) m = l; Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Comme premi√®re optimisation, nous essaierons d'√©viter une r√©p√©tition excessive des op√©rations, pour cela nous supprimons plusieurs op√©rations de division de la boucle - divisant `n par 2 et 4 et divisant 3 *` n par 4. Mais apr√®s cette optimisation, nous d√©couvrons que les calculs n'√©taient pas pour nous le principal probl√®me: le code ne deviendra pas plus rapide, bien qu'il soit plus compact.  Dans le meilleur des cas, nous obtiendrons une am√©lioration d'un demi pour cent. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = q, k = <span class="hljs-number"><span class="hljs-number">2</span></span> * q, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; q; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[k] &lt;= p[l] ? k : l; Swap(ref p[i], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Le deuxi√®me changement que nous apporterons au code est de r√©duire les d√©pendances.  Dans la version pr√©c√©dente de l'algorithme, l'attribution de `m √†` k ou` l d√©pend de la valeur affect√©e √†` m ligne ci-dessus.  Pour r√©duire le nombre de `m d√©pendances, nous calculons s√©par√©ment` m0 et` m1, puis les comparons.  Lorsque j'ai effectu√© cette optimisation, j'esp√©rais une am√©lioration significative de la vitesse de l'algorithme, mais au final, il s'est av√©r√© √™tre nul.  Mais, √† mon avis, il est important de garder le nombre de d√©pendances au minimum, c'est pourquoi j'ai enregistr√© le code. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i] &lt;= p[i + q] ? i : i + q; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[i + <span class="hljs-number"><span class="hljs-number">2</span></span> * q] &lt;= p[i + <span class="hljs-number"><span class="hljs-number">3</span></span> * q] ? i + <span class="hljs-number"><span class="hljs-number">2</span></span> * q : i + <span class="hljs-number"><span class="hljs-number">3</span></span> * q; Swap(ref p[i], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Essayons maintenant de r√©duire le nombre de variables inductives de quatre √† une, et nous calculerons les trois autres de mani√®re arithm√©tique, car elles sont en relation constante les unes avec les autres.  C'est assez simple: au lieu de `k, nous aurons` i + q, au lieu des deux autres variables -` i + 2 * q et` i + 3 * q.  J'avais √©galement de grands espoirs pour cette optimisation, mais, comme la pr√©c√©dente, elle n'a donn√© aucun r√©sultat √† temps.  Cela prouve encore une fois l'importance des mesures: sans elles, je pourrais me vanter d'avoir consid√©rablement am√©lior√© le fonctionnement de l'algorithme, et j'aurais des arguments tr√®s significatifs. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = q; i &lt; q2: ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i - q] &lt; p[i] ? i - q : i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[i + q2] &lt; p[i + q] ? i + q2 ? i + q; Swap(ref p[i - q], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  √Ä la quatri√®me tentative, nous restructurons le cycle pour √©liminer la multiplication par 3. Cela nous donnera une am√©lioration de 3%.  Le r√©sultat n'est toujours pas impressionnant.  Ensuite, essayez de vous d√©barrasser des op√©rateurs ternaires. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns: value if flag is true, 0 otherwise static int optional(bool flag, int value) { return -Convert.ToInt32(flag) &amp; value; }</span></span></code> </pre> <br>  Pour ce faire, je voudrais vous pr√©senter une nouvelle fonction - `static int optionnel (bool flag, int value).  Il convertit la valeur bool√©enne d'entr√©e en Int32, multiplie par -1 et la transmet √† l'op√©rateur ET au niveau du bit avec la deuxi√®me valeur d'entr√©e.  Si le drapeau d'entr√©e √©tait faux, alors dans int32 ce sera 0, et apr√®s toutes les conversions sur la sortie, nous aurons toujours 0. Si le drapeau d'entr√©e √©tait vrai, dans int32 ce sera 1, multipli√© par -1 nous obtenons FFFFFFFF, qui apr√®s le bit ¬´Et¬ª avec n'importe quel nombre donnera ce deuxi√®me num√©ro.  Veuillez noter qu'il n'y a aucune instruction if n'importe o√π, le code est sans branchement, c'est ennuyeux pour un ordinateur (bien qu'il nous semble juste complexe). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = q; i &lt; q2; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = i - optional(p[i - q] &lt;= p[i], q); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = i + q + optional(p[i + q2] &lt; p[i + q], q); Swap(ref p[i - q], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Nous remplacerons les op√©rateurs ternaires par cette fonction optionnelle, nous l'int√©grerons dans le calcul.  Nous l'appliquons deux fois, et dans le troisi√®me cas, laissons le point d'interrogation.  Ainsi, au lieu de quatre contr√¥les dans ce cycle, je n'en aurai qu'un. <br><br><img src="https://habrastorage.org/webt/qo/wp/--/qowp---fgvtqsgddipqokwb_k3o.jpeg"><br><br>  D'apr√®s les r√©sultats de mesure que vous voyez sur la diapositive, il est clair √† quel point il √©tait important de tester l'algorithme sur plusieurs ensembles de donn√©es diff√©rents.  Sur un ensemble, nous ne comprendrions rien.  Sur les donn√©es al√©atoires et r√©elles, nous avons plus d'une double acc√©l√©ration, sur les tuyaux d'orgue et les donn√©es tri√©es, nous avons un l√©ger ralentissement.  Cela est d√ª au fait que dans le cas de donn√©es tri√©es pour le pr√©dicteur de transition, il n'y aura pas de surprise, il pr√©dira avec une pr√©cision de 100%.  Dans le cas des tuyaux d'orgue, nous aurons une mauvaise pr√©diction au milieu de l'ensemble de donn√©es - encore une fois, une tr√®s grande pr√©cision.  En revanche, avec des donn√©es al√©atoires, la diff√©rence entre nos deux approches sera √©norme.  Nous avons remplac√© tous les contr√¥les impr√©visibles par une logique simple.  Ici, nous revenons √† une v√©rit√© simple: les ordinateurs sont con√ßus pour l'informatique, comme son nom l'indique (informatique - informatique).  Ramification, affichage d'images sur l'√©cran - tout cela, ils fonctionnent bien pire.  Il est beaucoup plus simple d'ex√©cuter ¬´et¬ª au niveau du bit que de passer l'instruction if. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = i + optional(p[i + q] &lt; p[i], q); m += optional(p[i + q2] &lt; p[m], q); m += optional(p[i + q2 + q] &lt; p[m], q); Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Ayant finalement obtenu un r√©sultat positif de l'optimisation, nous allons essayer de remplacer le dernier op√©rateur ternaire par notre fonction `optionnelle.  Cette fois, le gain de vitesse sera faible.  Pour comprendre pourquoi cela se produit, vous devez regarder le code g√©n√©r√©.  Dans la version pr√©c√©dente du code, o√π le point d'interrogation √©tait toujours pr√©sent, le compilateur avait d√©j√† trouv√© un moyen d'ex√©cuter le code sans branchement.  Et quand il arrive √† l'op√©rateur ternaire, il pourrait d√©j√† le pr√©dire.  Remplacer ce dernier morceau par `facultatif donnera un code un peu pire.  Par cons√©quent, je le r√©p√®te, il est important de prendre des mesures √† chaque fois. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns: v1 if flag is true, v2 otherwise static int ifelse(bool flag, int v1, int v2) { return (-Convert.ToInt32(flag) &amp; v1) | ((Convert.ToInt32(flag) - 1) &amp; v2); }</span></span></code> </pre><br>  Une autre fonctionnalit√© que je voudrais vous recommander est `ifelse sans branches, que vous voyez maintenant √† l'√©cran.  Certes, je n'ai pas pu r√©aliser avec elle les am√©liorations de performances dans notre exemple.  Si 0 lui est transmis comme indicateur, la premi√®re ligne sera 0;  dans le second, nous soustrayons 1 de 0 dans Int32 et obtenons FFFFFFFF, apr√®s quoi cette valeur est pass√©e au bit "Et" avec l'argument de fonction `v2, qui nous donnera cet argument lui-m√™me sans changements;  enfin, les premi√®re et deuxi√®me lignes sont pass√©es au ¬´OU¬ª au niveau du bit, ce qui, encore une fois, nous donnera ¬´v2.  Si le drapeau est 1, alors la premi√®re ligne sera √©gale √† `v1;  dans le second, nous soustrayons 1 de 1 et obtenons 0, √† la suite de quoi la ligne enti√®re sera 0, et 0 et `v1 dans le bit OR 'donnera' v1. <br><br>  J'esp√®re qu'une telle ¬´ifelse sans fonction de branchement int√©ressera les personnes impliqu√©es dans le backend - pour l'instant, les compilateurs modernes pour une raison quelconque n'utilisent pas cette approche.  Avec ces fonctions, vous pouvez r√©organiser les algorithmes afin que les compilateurs les comprennent pour vous, car vous √™tes plus intelligent et plus cr√©atif que votre compilateur. <br><br><h1>  Grande intersection d'ensemble </h1><br>  Modifiez un peu le sujet de notre conversation et passez √† l'intersection de grands ensembles.  Jusqu'√† pr√©sent, nous parlions d'op√©rateurs individuels, nous allons maintenant cr√©er de nouveaux algorithmes, nous devrons donc nous distraire des d√©tails et ouvrir nos esprits √† une perspective plus large.  Je suppose que vous connaissez le tri par fusion, multipliez deux vecteurs et recherchez des √©l√©ments communs √† deux vecteurs tri√©s.  Deux ensembles tri√©s sont parcourus, et lorsque des √©l√©ments √©gaux sont en eux, cela est consid√©r√© comme une correspondance.  Si l'un des deux √©l√©ments compar√©s est plus petit, il se d√©place.  Cet algorithme est assez simple, mais tr√®s courant - probablement le plus utilis√© au monde.  Il est utilis√© dans toutes les requ√™tes de plusieurs mots, chacune de ces requ√™tes est l'intersection de deux ensembles.  Cet algorithme, en particulier, utilise Google et devrait √©galement √™tre appliqu√© √† toutes les requ√™tes de base de donn√©es. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a1.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> || a2.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a1[i1] &lt; a2[i2]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i1 == a1.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a2[i2] &lt; a1[i1]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i2 == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { t[i++] = a1[i1]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i1 == a1.Length || ++i2 == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>: } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Jetez un ≈ìil √† l'impl√©mentation de base de cet algorithme.  Si les deux jeux d'entr√©es sont vides, alors, √©videmment, nous retournons 0. Ensuite, nous commen√ßons une boucle infinie, dans laquelle, s'il y a correspondance, nous augmentons le r√©sultat de 1 et v√©rifions si le cycle doit √™tre termin√©.  Au lieu d'une boucle infinie, on pourrait utiliser l'instruction for et sp√©cifier la condition pour y terminer la boucle.  Mais cela signifierait un travail suppl√©mentaire.  Dans l'impl√©mentation que vous voyez sur la diapositive, dans la premi√®re branche, nous avons `if (a1 [i1] &lt;a2 [i2]), apr√®s quoi il y a une augmentation de` i1 de 1, et nous ne pouvons que v√©rifier` i1.  De m√™me, dans la deuxi√®me branche, il suffit de cocher `i2.  Les deux valeurs doivent √™tre v√©rifi√©es uniquement dans la troisi√®me branche.  Si cette v√©rification √©tait au d√©but du cycle, nous ferions le travail suppl√©mentaire. <br><br>  Essayons d'am√©liorer cette impl√©mentation.  Pour le moment, sa complexit√© algorithmique est lin√©aire, en fonction de deux arguments d'entr√©e.  Dans l'apprentissage automatique, il faut souvent trouver l'intersection d'ensembles tr√®s diff√©rents les uns des autres en taille ou en statistiques.  Par exemple, vous disposez d'un vecteur d'entr√©e long et d'un vecteur d'entit√© court que vous v√©rifiez.  Dans notre code, il peut y avoir un million d'enregistrements en ¬´a1 et mille en¬ª a2.  Dans ce cas, nous ne sommes pas pr√™ts √† parcourir un million d'√©tapes pour terminer cet algorithme.  La plus grande charge sera ici sur la ligne de code suivante: `if (++ i1 == a1.length) break.  Juste avant cela, une comparaison se produit, puis dans cette ligne, il y a un incr√©ment de la valeur;  il s'agit essentiellement d'une recherche lin√©aire.  Nous parcourons le vecteur long √† la recherche d'√©l√©ments du court.  Dans le pire des cas, nous effectuerons de nombreuses recherches de ce type, en se d√©pla√ßant lentement le long du vecteur. <br><br>  Essayons d'am√©liorer cet algorithme.  Eh bien, si ce n'est pas une recherche lin√©aire, alors le binaire est meilleur, non?  Utilisons le binaire.  Son avantage est qu'il donne l'indice du plus grand des plus petits √©l√©ments. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i1 != a1.Length; ++i1) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = Bsearch(a2, a1[i1]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; --m; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(a2[m] &lt; a1[i1])) t[i++] = a1[i1]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre><br>  Le code ci-dessus est une impl√©mentation de notre algorithme de recherche binaire.  Mais ce n'est pas tr√®s efficace.  La pire situation ici sera lorsque la recherche binaire √©chouera √† chaque fois.  Et cela se produira dans des sc√©narios assez importants - par exemple, lorsque les deux ensembles sont identiques.  Vous, comme un imb√©cile, coupez des cercles avec une recherche binaire, alors que vous n'avez qu'√† parcourir le premier algorithme lin√©aire.  Pourquoi la recherche binaire, lorsque l'√©l√©ment souhait√© - √† chaque fois ici, le premier de la liste? <br><br>  Comment faire fonctionner l'algorithme avec succ√®s sur des donn√©es identiques et diff√©rentes?  La v√©rification de toutes les donn√©es sera trop co√ªteuse pour les ressources.  Je ferai une r√©serve qu'il ne s'agit pas de donn√©es compl√®tement identiques, mais tr√®s similaires, avec des statistiques similaires, les tailles peuvent √©galement varier.  Vous pouvez v√©rifier les quelques √©l√©ments suivants.  La solution √©vidente est de r√©duire votre recherche.  Lorsque nous effectuons une recherche binaire, alors, apr√®s avoir trouv√© un √©l√©ment, nous ne nous int√©ressons plus aux √©l√©ments plus petits que lui, puisque le deuxi√®me vecteur est √©galement tri√©.  Ainsi, nous pouvons √† chaque fois r√©duire notre zone de recherche, en √©liminant moins tous les √©l√©ments de l'√©l√©ment trouv√©. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i1 != a1.Length; ++i1) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = Bsearch(a2, i2, a2.Length, a1[i1]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == i2) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(a2[m - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; a1[i1])) t[i++] = a1[i1]; i2 = m + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Voici la mise en ≈ìuvre de cette approche.  Vous voyez que nous effectuons une recherche binaire √† chaque fois pour une partie du tableau d'origine commen√ßant par `i2 et se terminant par` a2.length.  Comme `i2 augmentera √† chaque recherche, la zone de recherche sera r√©duite. <br><br>  La prochaine optimisation que je voudrais impl√©menter ici est li√©e √† l'algorithme de recherche au galop.  Il s'agit essentiellement d'une recherche binaire avec une √©tape diff√©rente.  Dans le cas de la recherche binaire, nous commen√ßons √† chaque fois par le milieu - mais pensons que lorsque nous recherchons un nom dans l'annuaire t√©l√©phonique, nous ne l'ouvrons pas au milieu?  Si le nom de famille d‚Äôune personne commence, disons, sur ¬´B¬ª, nous ouvrirons le livre plus pr√®s du d√©but.  Ce principe est impl√©ment√© dans une recherche galopante: on commence √† explorer les donn√©es dans le sens ascendant avec un pas croissant exponentiellement apr√®s chaque v√©rification: d'abord 1, puis 2, puis 4. Cela nous donne une bonne complexit√© algorithmique.  Si le pas grandissait lin√©airement, la complexit√© serait quadratique.  Lorsque nous ¬´sautons¬ª l'√©l√©ment que nous recherchons, nous effectuons une recherche binaire normale sur le segment restant, qui sera petite et n'affectera pas de mani√®re significative le temps d'ex√©cution de l'algorithme.  Ainsi, nous combinons tous les avantages des deux approches.  Mise en place d'un tel algorithme: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GBsearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step = <span class="hljs-number"><span class="hljs-number">1</span></span>;; step *= <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= j) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; v) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i + step &gt;= j) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bsearch(a, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, J, v); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i + step] &gt; v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bsearch(a, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, i + step, v); i += step + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Nous discutons maintenant de la mise √† l'√©chelle, c'est-√†-dire que nous essayons de trouver l'intersection de plus de deux ensembles.  Pour chaque recherche de plusieurs mots, il faudra trouver l'intersection de plusieurs ensembles.  Pour ce faire, on peut par exemple comparer les deux premiers ensembles, puis leur intersection avec le troisi√®me et ainsi de suite.  Mais ce n'est pas une solution optimale.  Nous devons prendre les premiers √©l√©ments de tous les ensembles et trouver le plus petit d'entre eux, qui devra ensuite √™tre d√©plac√©.  Nous avons besoin d'une structure de donn√©es qui nous permet de trouver le plus petit des nombreux √©l√©ments et qui a une complexit√© constante.  Une telle structure de donn√©es est un tas.  Mais ce sera un groupe √©trange, il ne sera pas bas√© sur un tableau physique.  Ce sera imaginaire, nous n'y organiserons que les premiers √©l√©ments de nos d√©cors.  Une fois que nous avons trouv√© le plus petit √©l√©ment du tas, nous pouvons toujours rechercher tous les autres ensembles. <br><br>  Le travail sur les sujets dont nous discutons aujourd'hui dans la pratique a une forme plut√¥t artisanale.  En pratique, nous aurons le plus souvent plusieurs ensembles, pas seulement deux, et beaucoup de travail a √©t√© √©crit sur ce sujet.  L'algorithme classique ici est SVS, dans lequel nous regroupons les ensembles, prenons les deux plus petits et choisissons le plus court comme candidat.  Vous trouverez ici un bon aper√ßu de ce sujet.  Les probl√®mes li√©s aux ensembles crois√©s, au produit scalaire des vecteurs clairsem√©s, au tri par fusion, √† toute forme de comparaison avec l'image dans le temps deviennent de plus en plus int√©ressants.  L'algorithme que je vous ai montr√© s'est r√©v√©l√© tr√®s utile.  Merci de votre attention. <br><br><blockquote>  Andrei Alexandrescu ne viendra pas √† DotNext 2018 Moscou, mais Jeffrey Richter, Greg Young, Pavel Yosifovich et d'autres seront l√†.  Les noms des conf√©renciers et les sujets des rapports peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , et les billets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Rejoignez-nous maintenant! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425191/">https://habr.com/ru/post/fr425191/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425175/index.html">Un peu sur les cartes son avec synth√©tiseurs FM OPL2 / 3 pour PC ...</a></li>
<li><a href="../fr425177/index.html">Apprenez les tactiques, techniques et connaissances communes contradictoires (ATT @ CK). Tactiques d'entreprise. 3e partie</a></li>
<li><a href="../fr425179/index.html">Les stars de YouTube commencent √† s'√©puiser au travail: ¬´l'attrait du plus int√©ressant des travaux s'est estomp√©¬ª</a></li>
<li><a href="../fr425181/index.html">Frankie Zapata pour The Verge: ¬´Le turbor√©acteur aidera √† faire fondre le scepticisme du b√©ton arm√©¬ª</a></li>
<li><a href="../fr425187/index.html">Intel PAC avec FPGA Stratix 10 SX - acc√©l√©rateur pour les t√¢ches importantes</a></li>
<li><a href="../fr425195/index.html">Les listes noire, blanche et grise prot√®gent la s√©curit√© de l'entreprise</a></li>
<li><a href="../fr425197/index.html">Estimation des co√ªts d'un projet de mise en ≈ìuvre IdM - Comment anticiper les surprises</a></li>
<li><a href="../fr425199/index.html">Ce qui prot√®ge les acheteurs contre la fraude au paiement sans contact</a></li>
<li><a href="../fr425201/index.html">¬´Je lutte contre le syndrome des imposteurs depuis trois ans¬ª - 10 questions pour un programmeur, num√©ro 7</a></li>
<li><a href="../fr425203/index.html">Ancienne vuln√©rabilit√© UPnP d'une nouvelle fa√ßon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>