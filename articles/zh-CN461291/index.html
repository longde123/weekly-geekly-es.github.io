<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤭 🚴🏾 👩🏼‍🤝‍👨🏿 Golang：特定的性能问题 🤽🏽 🐥 👩🏾‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Go语言越来越受欢迎。 确信会议越来越多，例如GolangConf ，并且该语言是十项收入最高的技术之一。 因此，谈论其特定问题（例如性能）已经很有意义。 除了所有编译语言的常见问题外，Go都有自己的。 它们与优化器，堆栈，类型系统和多任务模型相关联。 解决这些问题的方法和解决方法有时非常具体。 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang：特定的性能问题</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461291/">  Go语言越来越受欢迎。 确信会议越来越多，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GolangConf</a> ，并且该语言<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">是十项</a>收入最高的技术之一。 因此，谈论其特定问题（例如性能）已经很有意义。 除了所有编译语言的常见问题外，Go都有自己的。 它们与优化器，堆栈，类型系统和多任务模型相关联。 解决这些问题的方法和解决方法有时非常具体。 <br><br>  <strong>丹尼尔·波多尔斯基</strong> （ <strong>Daniel Podolsky</strong> ）虽然是Go的传教士，但在他身上也遇到了很多奇怪的事情。 收集并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试</a>所有奇怪且最重要的是有趣的东西，然后在HighLoad ++中进行讨论。 该报告的文字记录将包括数字，图形，代码示例，分析器结果，以不同语言对相同算法的性能进行比较-以及其他所有内容，因此我们讨厌“优化”一词。 笔录中不会有任何启示-它们是从如此简单的语言中获得的-一切都可以在报纸上阅读。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8UESXMJwTpc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <strong>关于演讲者。</strong>  <b>Daniil Podolsky</b> ：26年的经验，有20年的运营经验，包括该小组的负责人，还有5年的Go编程经验。  <b>Kirill Danshin</b> ： <b>Gramework的</b>创建者，维护者，快速HTTP，Black Go-mage。 <br><br>  <em>该报告是由丹尼尔·波多尔斯基（Daniil Podolsky）和基里尔·丹辛（Kirill Danshin）共同编写的，但丹尼尔（Daniel）提出了报告，而西里尔（Cyril）在精神上提供了帮助。</em> <br><br><h2> 语言构造 </h2><br> 我们有<code>direct</code>的性能标准。 这是一个使变量递增且不再执行任何操作的函数。 <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   var testInt64 int64 func BenchmarkDirect(b *testing.B) { for i := 0; i &lt; bN; i++ { incDirect() } } func incDirect() { testInt64++ }</span></span></code> </pre> <br>  <b>每个操作</b>的功能结果为<b>1.46 ns</b> 。 这是最小的选择。 每次操作快于1.5 ns，可能无法正常工作。 <br><br><h3> 推迟我们如何爱他 </h3><br> 许多人知道并喜欢使用延迟语言构造。 我们经常像这样使用它。 <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDefer() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> incDirect() }</code> </pre> <br> 但是您不能那样使用它！ 每个操作每次延迟吃掉40 ns。 <br><br><pre> <code class="plaintext hljs">//   BenchmarkDirect-4 2000000000 1.46 / // defer BenchmarkDefer-4 30000000 40.70 /</code> </pre> <br> 我以为是因为内联？ 也许内联是如此之快？ <br><br>  Direct是内联的，而defer函数不能内联。 因此，编译了一个没有内联的单独的测试函数。 <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectNoInline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectNoInline() } } <span class="hljs-comment"><span class="hljs-comment">//go:noinline func incDirectNoInline() { testInt64++ }</span></span></code> </pre> <br> 一切都没有改变，延迟花了相同的40 ns。 推迟亲爱的，但不是灾难性的。 <br><br><blockquote> 如果函数花费的时间少于100 ns，则可以不延迟进行操作。 </blockquote><br> 但是，如果该功能花费的时间超过一微秒，则完全一样-您可以使用defer。 <br><br><h3> 通过引用传递参数 </h3><br> 考虑一个流行的神话。 <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectByPointer(&amp;testInt64) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { *n++ }</code> </pre> <br> 一切都没有改变-没有什么值得。 <br><br><pre> <code class="plaintext hljs">//     BenchmarkDirectByPointer-4 2000000000 1.47 / BenchmarkDeferByPointer-4 30000000 43.90 /</code> </pre> <br> 每次延迟除了3 ns之外，但这会因波动而被撇销。 <br><br><h3> 匿名函数 </h3><br> 有时，新手会问：“匿名函数贵吗？” <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectAnonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { testInt64++ }() } }</code> </pre> <br><blockquote> 匿名函数并不昂贵，它需要40.4 ns。 </blockquote><br><h3> 介面 </h3><br> 有一个实现它的接口和结构。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Inc() } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { n <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *testTypeStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.n++ }</code> </pre> <br> 使用增量方法有三个选项。 直接来自Struct： <code>var testStruct = testTypeStruct{}</code> 。 <br><br> 在相应的具体接口中： <code>var testInterface testTypeInterface = &amp;testStruct</code> 。 <br><br> 使用运行时接口转换： <code>var testInterfaceEmpty interface{} = &amp;testStruct</code> 。 <br><br> 下面是运行时界面的直接转换和使用。 <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterface.Inc() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterfaceRuntime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterfaceEmpty.(testTypeInterface).Inc() } }</code> </pre> <br><blockquote> 因此，该接口不花费任何费用。 </blockquote><br><pre> <code class="plaintext hljs">//  BenchmarkStruct-4 2000000000 1.44 / BenchmarkInterface-4 2000000000 1.88 / BenchmarkInterfaceRuntime-4 200000000 9.23 /</code> </pre> <br><br> 运行时界面转换是值得的，但并不昂贵-您无需明确拒绝。 但是，请尽可能尝试不使用它。 <br><br>  <b>神话：</b> <br><br><ul><li> 取消引用-取消引用指针-免费。 </li><li> 匿名功能是免费的。 </li><li> 接口是免费的。 </li><li> 运行时界面转换-不是免费的。 </li></ul><br><h3> 切换，地图和切片 </h3><br> 每个Go的新手都会问，如果用map替换switch会发生什么。 会更快吗？ <br><br> 开关有不同的尺寸。 我测试了三种尺寸：小号10例，中号100例，大号1000例。 在实际的生产代码中找到了1000个案例的开关。 当然，没有人会用手书写它们。 这是自动生成的代码，通常是类型开关。 在两种类型上进行了测试：int和string。 看来结果会更加清楚。 <br><br>  <strong>一点开关。</strong> 最快的选择是实际开关。 紧随其后的是slice，其中相应的整数索引包含对该函数的引用。  Map在int或string上都不是领导者。 <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntSmall-4 </td><td>  5亿 </td><td>  3.26 ns /运算 </td></tr><tr><td>  BenchmarkMapIntSmall-4 </td><td>  1亿 </td><td>  11.70 ns /运算 </td></tr><tr><td>  BenchmarkSliceIntSmall-4 </td><td>  5亿 </td><td>  3.85 ns /运算 </td></tr><tr><td>  BenchmarkSwitchStringSmall-4 </td><td>  1亿 </td><td>  12.70 ns / op </td></tr><tr><td>  BenchmarkMapStringSmall-4 </td><td>  1亿 </td><td>  15.60 ns /运算 </td></tr></tbody></table></div><br> 打开字符串比int慢得多。 如果您可以不切换到字符串而是切换到int，则可以这样做。 <br><br>  <strong>中间开关。</strong> 开关本身仍然可以控制int，但是slice已经超过了它。 地图仍然不好。 但是在字符串键上，映射比切换要快-符合预期。 <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntMedium-4 </td><td>  3亿 </td><td>  4.55 ns /运算 </td></tr><tr><td>  BenchmarkMapIntMedium-4 </td><td>  1亿 </td><td>  17.10 ns /运算 </td></tr><tr><td>  BenchmarkSliceIntMedium-4 </td><td>  3亿 </td><td>  3.76 ns /运算 </td></tr><tr><td>  BenchmarkSwitchStringMedium-4 </td><td>  50,000,000 </td><td>  28.50 ns /运算 </td></tr><tr><td>  BenchmarkMapStringMedium-4 </td><td>  1亿 </td><td>  20.30 ns /运算 </td></tr></tbody></table></div><br>  <strong>大开关。</strong> 一千个案例表明，在“按字符串切换”提名中，地图无条件获胜。 从理论上讲，slice赢了，但实际上，我建议您在此处使用相同的开关。 即使考虑到映射具有带特殊哈希函数的整数键，映射仍然很慢。 通常，此功能不执行任何操作。  int本身具有int的哈希值。 <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntLarge-4 </td><td>  1亿 </td><td>  13.6 ns /运算 </td></tr><tr><td>  BenchmarkMapIntLarge-4 </td><td>  50,000,000 </td><td>  34.3 ns /运算 </td></tr><tr><td>  BenchmarkSliceIntLarge-4 </td><td>  1亿 </td><td>  12.8 ns /运算 </td></tr><tr><td>  BenchmarkSwitchStringLarge-4 </td><td>  20,000,000 </td><td>  100.0 ns /运算 </td></tr><tr><td>  BenchmarkMapStringLarge-4 </td><td>  30000000 </td><td>  37.4 ns /运算 </td></tr></tbody></table></div><br>  <strong>结论</strong> 映射仅在数量较大而不是整数条件下更好。 我确信在int以外的任何条件下，它的行为都将与string相同。 当条件为整数时，Slice总是会转向。 如果您想以2 ns的速度“加速”程序，请使用它。 <br><br><h2> 程序间交互 </h2><br> 主题很复杂，我进行了许多测试，并将介绍最具启发性的测试。 我们知道以下<strong>机构间互动的方式</strong> 。 <br><br><ul><li> 原子的 这些是适用性有限的方法-您可以替换指针或使用int。 </li><li> 自Java以来​​，互斥量已​​被广泛使用。 </li><li> 频道是GO特有的。 </li><li> 缓冲通道-缓冲通道。 </li></ul><br> 当然，我在争夺一种资源的大量goroutines上进行了测试。 但是他为自己选择了三个作为指示：一点-100，中等-1000和很多-10000。 <br><br>  <strong>负载曲线不同</strong> 。 有时所有gorutin都想写一个变量，但这很少见。 通常，毕竟有些写，有些读。 在大多数读者（占90％的阅读者）中，有90％是写作。 <br><br> 这是使用的代码，因此为通道提供服务的goroutine可以提供对变量的读取和写入操作。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> n, ok := &lt;-cw: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { wgc.Done() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } testInt64 += n <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cr &lt;- testInt64: } } }()</code> </pre> <br> 如果一条消息通过我们编写的渠道到达我们，我们将执行该消息。 如果通道关闭，则完成goroutin。 在任何时候，我们都准备好写入其他goroutine用于读取的通道。 <br><div class="scrollable-table"><table><tbody><tr><td>  Benchmarkmutex-4 </td><td>  1亿 </td><td>  16.30 ns /运算 </td></tr><tr><td>  Benchmarkatomic-4 </td><td>  200000000 </td><td>  6.72 ns /运算 </td></tr><tr><td>  Benchmarkcan-4 </td><td>  5,000,000 </td><td>  239.00 ns /运算 </td></tr></tbody></table></div><br> 这是一个goroutine的数据。 通道测试是在两个goroutine上执行的：一个过程处理Channel，另一个过程写入该Channel。 这些选项已经过测试。 <br><br><ul><li> 直接写入变量。 </li><li> 互斥锁获取日志，写入变量并释放日志。 </li><li> 原子通过原子写入变量。 它不是免费的，但仍然比Mutex的一种garutin便宜得多。 </li></ul><br> 使用少量的goroutine，Atomic是一种有效且快速的同步方式，这不足为奇。  Direct不在这里，因为我们需要同步，而同步却没有提供。 但是，原子当然有缺陷。 <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkMutexFew-4 </td><td>  30000 </td><td>  55894 ns /运算 </td></tr><tr><td>  BenchmarkAtomicFew-4 </td><td>  100,000 </td><td>  14585 ns /运算 </td></tr><tr><td>  BenchmarkChanFew-4 </td><td>  5000 </td><td>  323859 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFew-4 </td><td>  5000 </td><td>  341321 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullFew-4 </td><td>  20000 </td><td>  70052 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyReadFew-4 </td><td>  30000 </td><td>  56402 ns /运算 </td></tr><tr><td>  BenchmarkAtomicMostlyReadFew-4 </td><td>  1,000,000 </td><td>  2094 ns /运算 </td></tr><tr><td>  BenchmarkChanMostlyReadFew-4 </td><td>  3000 </td><td>  442689 ns /运算 </td></tr><tr><td>  BenchmarkChanBufferedMostlyReadFew-4 </td><td>  3000 </td><td>  449,666 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyReadFew-4 </td><td>  5000 </td><td>  442,708 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyWriteFew-4 </td><td>  20000 </td><td>  79708 ns /运算 </td></tr><tr><td>  BenchmarkAtomicMostlyWriteFew-4 </td><td>  100,000 </td><td>  13358 ns /运算 </td></tr><tr><td>  BenchmarkChanMostlyWriteFew-4 </td><td>  3000 </td><td>  449,556 ns /运算 </td></tr><tr><td>  BenchmarkChanBufferedMostlyWriteFew-4 </td><td>  3000 </td><td>  445423 ns /运算 </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyWriteFew-4 </td><td>  3000 </td><td>  414626 ns /运算 </td></tr></tbody></table></div><br> 接下来是Mutex。 我期望Channel可以和Mutex一样快，但是不可以。 <br><br><blockquote> 通道比Mutex贵一个数量级。 </blockquote><br> 而且，Channel和缓冲Channel的价格大致相同。 还有Channel，缓冲区永远不会溢出。 它比缓冲区溢出的便宜一个数量级。 仅当Channel中的缓冲区未满时，它的成本在数量级上与Mutex差不多。 这是我从测试中获得的期望。 <br><br> 在任何负载配置文件上都重复了此图以及其成本分配情况-在MostlyRead和MostlyWrite上均如此。 此外，完整的MostlyRead Channel的费用与未完成的费用相同。 而MostlyWrite的缓冲通道（其中缓冲区未满）的成本与其余通道相同。 我无法说出为什么-我尚未研究此问题。 <br><br><h2> 传递参数 </h2><br>  <strong>如何更快地传递参数-通过引用还是通过值？</strong> 让我们来看看。 <br><br> 我进行了如下检查-将嵌套类型设为1到10。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TP001 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TV002 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S001 TV001 I002 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S002 TV001 }</code> </pre> <br> 第十个嵌套类型将具有10个int64字段，而上一个嵌套的嵌套类型也将为10。 <br><br> 然后他编写了创建嵌套类型的函数。 <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTP001</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TP001</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;TP001{ I001: rand.Int63(), } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTV002</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TV002</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TV002{ I001: rand.Int63(), S001: NewTV001(), I002: rand.Int63(), S002: NewTV001(), } }</code> </pre> <br> 为了进行测试，我使用了三种类型的选项：带有嵌套2的小号，带有嵌套3的中号，带有嵌套5的大号。我不得不在晚上进行带有嵌套10的非常大的测试，但是图片与5完全相同。 <br><br>  <b>在函数中，按值传递的速度至少是按引用传递的速度的两倍</b> 。 这是由于以下事实：按值传递不会加载转义分析。 因此，我们分配的变量在堆栈上。 对于运行时和垃圾收集器而言，它便宜得多。 虽然他可能没有时间连接。 这些测试持续了几秒钟-垃圾收集器可能仍处于睡眠状态。 <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkCreateSmallByValue-4 </td><td>  200,000 </td><td>  8942 ns / op </td></tr><tr><td>  BenchmarkCreateSmallByPointer-4 </td><td>  100,000 </td><td>  15985 ns /运算 </td></tr><tr><td>  BenchmarkCreateMediuMByValue-4 </td><td>  2000 </td><td>  862317 ns /运算 </td></tr><tr><td>  BenchmarkCreateMediuMByPointer-4 </td><td>  2000 </td><td>  1228130 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByValue-4 </td><td>  30 </td><td>  47398456 ns /运算 </td></tr><tr><td>  BenchmarkCreateLargeByPointer-4 </td><td>  20 </td><td>  61928751 ns / op </td></tr></tbody></table></div><br><h2> 黑魔法 </h2><br> 你知道这个程序会输出什么吗？ <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { a, b <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(A) aa = <span class="hljs-number"><span class="hljs-number">0</span></span> ab = <span class="hljs-number"><span class="hljs-number">1</span></span> z := (*(*<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>)(unsafe.Pointer(a))) fmt.Println(z) }</code> </pre> <br> 程序的结果取决于执行程序的体系结构。 在小端（例如AMD64）上，程序将显示 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>32</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhixcoGqGtoTFLFctKBD8lF6At2J2A#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhixcoGqGtoTFLFctKBD8lF6At2J2A#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhixcoGqGtoTFLFctKBD8lF6At2J2A#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>32</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ {32} </script>  。 在大端上，一个。 结果是不同的，因为在小字节序上，此单位出现在数字的中间，在大字节序上-在结尾。 <br><br> 世界上仍然有处理器进行字节序交换，例如Power PC。 在推断不安全技巧的作用之前，有必要在启动时找出计算机上配置了哪些字节序。 例如，如果您编写了将在某些IBM多处理器服务器上执行的Go代码。 <br><br> 我引用此代码来解释为什么我考虑所有不安全的黑魔法。 您不需要使用它。 但是西里尔认为这是必要的。 这就是为什么。 <br><br> 有一个功能与GOB相同的功能-Go Binary Marshaller。 这是编码器，但不安全。 <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encodeMut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { sz := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data) * <span class="hljs-number"><span class="hljs-number">8</span></span> dh := (*header)(unsafe.Pointer(&amp;data)) rh := &amp;header{ data: dh.data, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>: sz, <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>: sz, } res = *(*[]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(unsafe.Pointer(&amp;rh)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br> 实际上，它需要一块内存并从中绘制一个字节数组。 <br><br> 这甚至不是命令-这是两个命令。 因此，西里尔·丹辛（Cyril Danshin）在编写高性能代码时，会毫不犹豫地进入程序的胆量并使之不安全。 <br><br><div class="scrollable-table"><table><tbody><tr><td> 基准球4 </td><td>  200,000 </td><td>  8466 ns /运算 </td><td>  120.94 MB /秒 </td></tr><tr><td>  BenchmarkUnsafeMut-4 </td><td>  50,000,000 </td><td>  37 ns / op </td><td>  27691.06 MB /秒 </td></tr></tbody></table></div><blockquote> 我们将在10月7日的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GolangConf</a>上讨论Go的更多特定功能，该会议是为那些使用Go进行专业开发的人以及认为使用该语言作为替代语言的人的会议。  Daniil Podolsky只是计划委员会的成员，如果您想对本文进行辩论或揭示相关问题，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提交</a>报告<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">申请</a> 。 <br><br> 对于其他所有方面，关于高性能，当然是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HighLoad ++</a> 。 我们也在那里接受申请。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">订阅</a>新闻时事，并及时了解我们所有针对Web开发人员的会议的新闻。 </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN461291/">https://habr.com/ru/post/zh-CN461291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN461281/index.html">在chroot环境中为Red Hat（RHEL / CentOS）设置BIND DNS服务器的演练7</a></li>
<li><a href="../zh-CN461283/index.html">软件体系结构和系统设计：概述和资源指南</a></li>
<li><a href="../zh-CN461285/index.html">5种主要采样算法</a></li>
<li><a href="../zh-CN461287/index.html">在基于启发式和变异的战术游戏中开发狡猾的AI</a></li>
<li><a href="../zh-CN461289/index.html">已发布CLion 2019.2：嵌入式开发支持，MSVC调试器，搜索未使用的头文件</a></li>
<li><a href="../zh-CN461297/index.html">现代有针对性的攻击是什么样的</a></li>
<li><a href="../zh-CN461299/index.html">PC如何通过成功的软件征服媒体行业：讨论Pro Tools和Media Composer</a></li>
<li><a href="../zh-CN461303/index.html">将Troika卡用作强制性医疗保险</a></li>
<li><a href="../zh-CN461305/index.html">公司网络和MitM。 第二部分</a></li>
<li><a href="../zh-CN461307/index.html">我们邀请您参加VK Hackathon2019。今年的奖金池为200万卢布。</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>