<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüíº üôÇ üë®üèæ‚Äçüéì DSL interno y √°rboles de expresi√≥n: creaci√≥n din√°mica de funciones de serializaci√≥n, copia, clonaci√≥n, igualdad (Parte I) üèûÔ∏è üç∫ üî©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo se centra en el uso dual de la API de √°rboles de expresi√≥n : para analizar expresiones y generar c√≥digo. El an√°lisis de expresiones ayud...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DSL interno y √°rboles de expresi√≥n: creaci√≥n din√°mica de funciones de serializaci√≥n, copia, clonaci√≥n, igualdad (Parte I)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419759/"><p><img src="https://habrastorage.org/webt/_c/m3/gr/_cm3grewmg9yewpcch1nqkl2ho8.png"></p><br><p>  Este art√≠culo se centra en el uso dual de la API de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rboles de expresi√≥n</a> : para analizar expresiones y generar c√≥digo.  El an√°lisis de expresiones ayuda a construir estructuras de presentaci√≥n (tambi√©n son estructuras de presentaci√≥n del lenguaje <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interno</a> orientado a problemas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DSL interno</a> ), y la generaci√≥n de c√≥digo le permite crear din√°micamente funciones efectivas: conjuntos de instrucciones especificadas por estructuras de presentaci√≥n. </p><br><p> Demostrar√© la creaci√≥n din√°mica de <strong>iteradores</strong> de <strong>propiedades: serializar, copiar, clonar, iguales</strong> .  Usando serializar como ejemplo, le mostrar√© c√≥mo optimizar la serializaci√≥n (en comparaci√≥n con los serializadores de transmisi√≥n) en la situaci√≥n cl√°sica en la que se utiliza el conocimiento "preliminar" para mejorar el rendimiento.  La idea es que llamar al serializador de transmisi√≥n siempre perder√° la funci√≥n de "no transmisi√≥n", sabiendo exactamente qu√© nodos de √°rbol deben moverse.  Al mismo tiempo, dicho serializador se crea "no a mano" sino de forma din√°mica, sino de acuerdo con las reglas de omisi√≥n predefinidas.  <strong>El DSL Inernal propuesto resuelve el problema de una descripci√≥n compacta de las reglas para atravesar las estructuras de √°rbol de los objetos por sus propiedades / propiedades (y en el caso general: atravesar el √°rbol de c√≥mputo con el nombre de los nodos)</strong> .  El punto de referencia del serializador es modesto, pero es importante porque agrega al enfoque construido alrededor del uso de un <strong>DSL</strong> interno espec√≠fico <strong>incluye</strong> (un dialecto de Incluir / EntoncesIncluir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EF Core</a> ) y el uso del DSL interno en su conjunto, la persuasi√≥n necesaria. </p><a name="habracut"></a><br><h2 id="vvedenie">  Introduccion </h2><br><p>  Compara: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(){X=<span class="hljs-number"><span class="hljs-number">-1</span></span>,Y=<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var json2 = $"{{\"X\":{pX}, \"Y\":{pY}}}";</span></span></code> </pre> <br><p>  El segundo m√©todo es obviamente m√°s r√°pido (los nodos son conocidos y est√°n "abarrotados de c√≥digo"), mientras que el m√©todo es, por supuesto, m√°s complicado.  Pero cuando obtiene este c√≥digo como una funci√≥n (generada y compilada din√°micamente), la complejidad est√° oculta (incluso lo que no est√° claro est√° oculto <br>  d√≥nde est√° la reflexi√≥n y d√≥nde est√° el tiempo de ejecuci√≥n de generaci√≥n de c√≥digo). </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(){X=<span class="hljs-number"><span class="hljs-number">-1</span></span>,Y=<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var formatter = JsonManager.ComposeFormatter&lt;Point&gt;(); var json2 = formatter(p);</span></span></code> </pre> <br><p>  Aqu√≠ <code>JsonManager.ComposeFormatter</code> es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta real</a> .  La regla por la cual se genera la omisi√≥n de estructura durante la serializaci√≥n no es obvia, pero suena as√≠ "con los par√°metros predeterminados, para los tipos de valores personalizados rodean todos los campos del primer nivel".  Si lo configura expl√≠citamente: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    var formatter2 = JsonManager.ComposeFormatter&lt;Point&gt;( chain=&gt;chain .Include(e=&gt;eX) .Include(e=&gt;eY) // DSL Includes )</span></span></code> </pre> <br><p>  Esta es la descripci√≥n de los metadatos a trav√©s de DSL Incluye.  DSL ha iluminado el an√°lisis de los pros y los contras de describir metadatos, pero ahora ignorando la forma de grabar metadatos, enfatizo que C # proporciona la capacidad de compilar y compilar el "serializador ideal" usando Expression Trees. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥mo lo hace: una gran cantidad de c√≥digo y una gu√≠a de generaci√≥n de c√≥digo de Expression Trees ...</b> <div class="spoiler_text"><p>  transici√≥n del <code>formatter</code> al <code>serilizer</code> (hasta ahora sin √°rboles de expresi√≥n): </p><br><pre> <code class="cs hljs"> Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer = ... <span class="hljs-comment"><span class="hljs-comment">// later string formatter(Point p) { var stringBuilder = new StringBuilder(); serializer(stringBuilder, p); return stringBuilder.ToString(); }</span></span></code> </pre> <br><p>  A su vez, el <code>serializer</code> se construye as√≠ (si est√° configurado con c√≥digo est√°tico): </p><br><pre> <code class="cs hljs">Expression&lt;Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; serializerExpression = SerializeAssociativeArray(sb, p, (sb1, t1) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString) ); Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer = serializerExpression.Compile();</code> </pre> <br><p>  ¬øPor qu√© es tan "funcional", por qu√© no puedes serializar dos campos a trav√©s de un punto y coma?  En resumen: porque esta expresi√≥n se puede asignar a una variable del tipo <code>Expression&lt;Func&lt;StringBuilder, Box, bool&gt;&gt;</code> , pero no se permite el punto y coma. <br>  ¬øPor qu√© no podr√≠a escribir directamente <code>Func&lt;StringBuilder, Point, bool&gt; serializer = (sb,p)=&gt;SerializeAssociativeArray(sb,p,...</code> ? Es posible, pero no estoy demostrando la creaci√≥n de un delegado, sino un ensamblado (en este caso, c√≥digo est√°tico) √°rbol de expresi√≥n, con una compilaci√≥n para el delegado en el futuro, en uso pr√°ctico, <code>serializerExpression</code> se establecer√° de una manera completamente diferente, din√°micamente (a continuaci√≥n). </p><br><p>  Pero lo que es importante en la soluci√≥n en s√≠: <code>SerializeAssociativeArray</code> acepta una matriz de <code>params Func&lt;..&gt; propertySerializers</code> acuerdo con el n√∫mero de nodos que se omitir√°n.  Eludir algunos de ellos puede establecerlo SerializeValueProperty serializadores de hojas (aceptando el formateador <code>SerializeValueToString</code> ), y otros nuevamente por <code>SerializeAssociativeArray</code> (es decir, ramas), y as√≠ se construye un iterador (√°rbol) del recorrido. </p><br><p>  Si Point conten√≠a la propiedad NextPoint: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> = SerializeAssociativeArray(sb, p, (sb1, t1) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"NextPoint"</span></span>, o =&gt; o.NextPoint, (sb4, t4) =&gt;SerializeAssociativeArray(sb1, p1, (sb1, t1) =&gt; SerializeValueProperty(sb2, t2, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb2, t2, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString) ) ) );</code> </pre> <br><p>  El dispositivo de las tres funciones <code>SerializeAssociativeArray</code> , <code>SerializeValueProperty</code> , <code>SerializeValueToString</code> no <code>SerializeValueToString</code> complicado: </p><br><div class="spoiler">  <b class="spoiler_title">Serializar ...</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeAssociativeArray&lt;T&gt;(StringBuilder stringBuilder, T t, <span class="hljs-keyword"><span class="hljs-keyword">params</span></span> Func&lt;StringBuilder, T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;[] propertySerializers) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'{'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertySerializer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> propertySerializers) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notEmpty = propertySerializer(stringBuilder, t); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notEmpty) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!@<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">','</span></span>); } }; stringBuilder.Length--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (@<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'}'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeValueProperty&lt;T, TProp&gt;(StringBuilder stringBuilder, T t, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName, Func&lt;T, TProp&gt; getter, Func&lt;StringBuilder, TProp, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TProp : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'"'</span></span>).Append(propertyName).Append(<span class="hljs-string"><span class="hljs-string">'"'</span></span>).Append(<span class="hljs-string"><span class="hljs-string">':'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = getter(t); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notEmpty = serializer(stringBuilder, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!notEmpty) stringBuilder.Length -= (propertyName.Length + <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> notEmpty; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeValueToString&lt;T&gt;(StringBuilder stringBuilder, T t) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stringBuilder.Append(t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> </div></div><br><p>  Aqu√≠ no se dan muchos detalles (soporte de lista, tipo de referencia y anulable).  Y sin embargo, est√° claro que realmente obtengo <em>json</em> en la salida, y todo lo dem√°s es a√∫n m√°s que las funciones est√°ndar <code>SerializeArray</code> , <code>SerializeNullable</code> , <code>SerializeRef</code> . </p><br><p>  Era un √°rbol de expresi√≥n est√°tico, no din√°mico, no <em>evaluado en C #</em> . </p><br><p>  Puede ver c√≥mo Expression Tree se construye din√°micamente en dos pasos: </p><br><h4 id="shag-1---decompilerom-posmotret-na-kod-prisvoennyy-expressiont">  Paso 1: el descompilador observa el c√≥digo asignado por <code>Expression&lt;T&gt;</code> </h4><br><p><img src="https://habrastorage.org/webt/ox/p3/g2/oxp3g2newr9bhr3oba5bajcrkco.png"></p><br><p>  Por supuesto, esto te sorprender√° la primera vez.  Nada est√° claro, pero puedes ver c√≥mo las primeras cuatro l√≠neas forman algo como: </p><br><pre> <code class="cs hljs">(<span class="hljs-string"><span class="hljs-string">"sb"</span></span>,<span class="hljs-string"><span class="hljs-string">"t"</span></span>) .. SerializeAssociativeArray..</code> </pre> <br><p>  Luego se captura la conexi√≥n con el c√≥digo fuente.  Y debe quedar claro que si domina un registro de este tipo (combinando 'Expression.Const', 'Expression.Parameter', 'Expression.Call', 'Expression.Lambda', <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">etc.</a> ) realmente puede componer din√°micamente, cualquier bypass de nodos (basado en metadatos).  Esto es <em>eval en C #</em> . </p><br><h4 id="shag-2----shodit-po-etoy-ssylkehttpsgithubcomdashboardcoderoutinesblobmastertestsconsoleappsclrmdautomationprogramcsl99-l194">  Paso 2: sigue <a href="">este enlace</a> , </h4><br><p>  El mismo c√≥digo de descompilador, pero compilado por man. </p><br><p>  Solo el autor del int√©rprete est√° obligado a participar en este bordado de cuentas.  Todas estas artes permanecen dentro de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la biblioteca de serializaci√≥n</a> .  Es importante conocer la idea de que puede proporcionar bibliotecas que generen din√°micamente funciones compiladas eficientes en C # (y .NET Standard). </p></div></div><br><p>  Sin embargo, un serializador de transmisi√≥n superar√° una funci√≥n generada din√°micamente si llama a la compilaci√≥n cada vez antes de la serializaci√≥n (la compilaci√≥n dentro de <code>ComposeFormatter</code> es una operaci√≥n costosa), pero puede guardar el enlace y reutilizarlo: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Func&lt;Point, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; formatter = JsonManager.ComposeFormatter&lt;Point&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Point p</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var json2 = formatter(p); return json2; }</span></span></code> </pre> <br><p>  Si necesita crear y guardar un serializador de tipo an√≥nimo para su reutilizaci√≥n, necesita infraestructura adicional: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;Point&gt; list</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// there json formatter will be build only for first call // and assigned to cachedFormatter.Formatter // in all next calls cachedFormatter.Formatter will be used. // since building of formatter is determenistic it is lock free var json3 = list.Select(e=&gt; {X:eX, Sum:e.X+EY}) .ToJson(cachedFormatter, e=&gt;e.Sum); return json3; }</span></span></code> </pre> <br><p>  Despu√©s de eso, tenemos en cuenta con confianza la primera microoptimizaci√≥n para nosotros y acumulamos, acumulamos, acumulamos ... Qui√©n es el chiste, qui√©n no, pero antes de pasar a la pregunta de que el nuevo serializador es nuevo, soluciono la ventaja obvia: ser√° m√°s r√°pido. </p><br><h2 id="chto-vzamen">  ¬øQu√© a cambio? </h2><br><p>  El DSL incluye int√©rprete en serilize (y de la misma manera es posible en iteradores equals, copy, clone, y esto tambi√©n se tratar√°) requiri√≥ los siguientes costos: </p><br><p>  <strong>1</strong> - costos de la infraestructura para almacenar enlaces a c√≥digo compilado. </p><br><p>  Estos costos generalmente no son necesarios, como lo es el uso de Expression Trees con compilaci√≥n: el int√©rprete puede crear un serializador en reflejos e incluso lamerlo tanto que se acercar√° a la velocidad en t√©rminos de serializadores de flujo (por cierto, copie, clone y los iguales no se recopilan a trav√©s de √°rboles de expresi√≥n, ni se lamen, no existe tal tarea, a diferencia de superar a ServiceStack y Json.NET en el marco de la tarea bien entendida de optimizar la serializaci√≥n en json, una condici√≥n necesaria para presentar una nueva soluci√≥n). </p><br><p>  <strong>2</strong> : debe tener en cuenta las fugas de abstracciones y un problema similar: cambios en la sem√°ntica en comparaci√≥n con las soluciones existentes. </p><br><p>  Por ejemplo, Point e IEnumerable necesitan dos serializadores diferentes para serializar. <br></p><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter1 = JsonManager.ComposeFormatter&lt;Point&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter2 = JsonManager.ComposeEnumerableFormatter&lt;Point&gt;(); <span class="hljs-comment"><span class="hljs-comment">// but not // var formatter2 = JsonManager.ComposeEnumerableFormatter&lt;List&lt;Point&gt;&gt;();</span></span></code> </pre> <br><p>  O: "¬øfunciona el cierre?".  Funciona, solo el nodo necesita establecer un nombre (√∫nico): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> DATEFORMAT= <span class="hljs-string"><span class="hljs-string">"YYYY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter3 = JsonManager.ComposeFormatter&lt;Record&gt;( chain =&gt; chain .Include(i =&gt; i.RecordId) .Include(i =&gt; i.CreatedAt.ToString(DATEFORMAT) , <span class="hljs-string"><span class="hljs-string">"CreatedAt"</span></span>); );</code> </pre> <br><p>  Este comportamiento lo dicta el dispositivo interno del int√©rprete <code>ComposeFormatter</code> . </p><br><p>  Los costos de este tipo son el mal inevitable.  Adem√°s, se descubre que al expandir la funcionalidad y expandir el alcance del DSL interno, tambi√©n aumentan las fugas de abstracci√≥n.  Ciertamente oprimir√° al desarrollador de DSL interno, aqu√≠ debe abastecerse de un estado de √°nimo filos√≥fico. </p><br><p>  Para el usuario, las fugas de abstracci√≥n se superan mediante el conocimiento de los detalles t√©cnicos de DSL interno ( <em>¬øqu√© esperar?</em> ) Y la riqueza de la funcionalidad de un DSL particular y sus int√©rpretes ( <em>¬øqu√© a cambio?</em> ).  Por lo tanto, la respuesta a la pregunta: "¬øvale la pena crear y usar DSL interno?", Solo puede haber una historia sobre la funcionalidad de un DSL particular, sobre todos sus detalles y comodidades, y sus posibles aplicaciones (int√©rpretes), es decir.  Una historia sobre la superaci√≥n de los costos. </p><br><p>  Con todo esto en mente, vuelvo a la efectividad de un DSL en particular. </p><br><p>  Se logra una eficiencia significativamente mayor cuando el objetivo es reemplazar el triple (DTO, transformar en DTO, serializar DTO) con una funci√≥n de serializaci√≥n generada y detallada localmente.  Al final, el objeto de funci√≥n dualismo le permite decir "DTO es una funci√≥n" y establecer un objetivo: aprender c√≥mo establecer una funci√≥n DTO. </p><br><p>  La serializaci√≥n debe configurarse: </p><br><ol><li>  Desv√≠e el √°rbol (para describir los nodos a trav√©s de los cuales tendr√° lugar la serializaci√≥n, por cierto, esto resuelve el problema de los enlaces circulares), en el caso de las hojas, asigne un formateador (por tipo). </li><li>  La regla para incluir hojas (si no se especifican): ¬øpropiedad frente a campos?  solo lectura? </li><li>  Para poder especificar tanto una rama (un nodo con navegaci√≥n) como una hoja no es solo MemberExpression ( <code>e=&gt;e.Name</code> ), sino generalmente cualquier funci√≥n (`e =&gt; e.Name.ToUpper ()," MyMemberName ") - establece el formateador en un formato espec√≠fico nodo. </li></ol><br><p>  Otras opciones para aumentar la flexibilidad: </p><br><ol><li>  serializar una hoja que contiene una cadena json "tal cual" (formateador de cadena especial); </li><li>  establecer formateadores en grupos, es decir  ramas enteras, en esta rama como esta, en otra de una manera diferente (por ejemplo, fechas aqu√≠ con tiempo y en esta sin tiempo). </li></ol><br><p>  En todas partes, las construcciones involucradas: omiten el √°rbol, la rama, la hoja y todo esto se puede escribir usando DSL Incluye. </p><br><h2 id="dsl-includes">  DSL incluye </h2><br><p>  Como todos est√°n familiarizados con EF Core, el significado de las siguientes expresiones debe capturarse de inmediato (este es un subconjunto de xpath). </p><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// DSL Includes Include&lt;User&gt; include1 = chain=&gt; chain .IncludeAll(e =&gt; e.Groups) .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) // EF Core syntax // https://docs.microsoft.com/en-us/ef/core/querying/related-data var users = context.Users .Include(blog =&gt; blog.Groups) .Include(blog =&gt; blog.Roles) .ThenInclude(blog =&gt; blog.Privileges);</span></span></code> </pre> <br><p>  Aqu√≠ est√°n los nodos "con navegaci√≥n" - "ramas". <br>  La respuesta a la pregunta de qu√© nodos "hojas" (campos / propiedades) se incluyen en el √°rbol as√≠ definido: ninguno.  Para incluir hojas, debe enumerarlas expl√≠citamente: </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include2 = chain=&gt; chain .Include(e =&gt; e.UserName) <span class="hljs-comment"><span class="hljs-comment">// leaf member .IncludeAll(e =&gt; e.Groups) .ThenInclude(e =&gt; e.GroupName) // leaf member .IncludeAll(e =&gt; e.Roles) .ThenInclude(e =&gt; e.RoleName) // leaf member .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) .ThenInclude(e =&gt; e.PrivilegeName) // leaf member</span></span></code> </pre><br><p>  O agregue din√°micamente por la regla, a trav√©s de un int√©rprete especializado: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Func&lt;ChainNode, MemberInfo&gt; rule = ... var include2 = IncludeExtensions.AppendLeafs(include1, rule);</span></span></code> </pre> <br><p>  Aqu√≠ la regla es una regla que puede seleccionarse mediante ChainNode.  por tipo de expresi√≥n devuelta por el nodo (ChainNode - representaci√≥n interna de DSL incluye, que se discutir√° m√°s adelante) propiedades (MemberInfo) para participar en la serializaci√≥n, p.  solo la propiedad, o solo la propiedad de lectura / escritura, o solo aquellas para las que hay un formateador, puede seleccionar de una lista de tipos, e incluso la expresi√≥n de inclusi√≥n en s√≠ misma puede establecer una regla (si enumera nodos de hoja, es decir, la forma de uni√≥n de √°rbol) . </p><br><p>  O ... d√©jelo a discreci√≥n del int√©rprete de usuario, quien decide qu√© hacer con los nodos.  DSL incluye es solo un registro de metadatos; la forma de interpretar este registro depende del int√©rprete.  Puede interpretar los metadatos como quiera, hasta ignorarlos.  Algunos int√©rpretes realizar√°n la acci√≥n ellos mismos, mientras que otros construir√°n una funci√≥n lista para realizarlos (a trav√©s de Expression Tree, o incluso Reflection.Emit).  Un buen DSL interno est√° dise√±ado para uso universal y la existencia de muchos int√©rpretes, cada uno de los cuales tiene sus propios detalles, sus propias filtraciones de abstracci√≥n. <br>  El c√≥digo que usa DSL interno puede ser muy diferente de lo que era antes. </p><br><h4 id="out-of-the-box">  Fuera de la caja </h4><br><p>  Integraci√≥n con EF Core. <br>  La tarea en ejecuci√≥n es "cortar los enlaces c√≠clicos", para iniciar solo lo que se especifica en la expresi√≥n de inclusi√≥n: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetJson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbContext = GetEfCoreContext()) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> json = EfCoreExtensions.ToJsonEf&lt;User&gt;(cachedFormatter1, dbContext, chain=&gt;chain .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges)); } }</code> </pre> <br><p>  <code>ToJsonEf</code> acepta la secuencia de navegaci√≥n, cuando se serializa, la usa (selecciona las hojas seg√∫n la regla "predeterminada para EF Core", es decir, la propiedad de lectura / escritura p√∫blica), est√° interesado en el modelo, donde string / json usa formateadores de campo para insertar como est√° por defecto (byte [] por cadena, fecha y hora en ISO, etc.).  Por lo tanto, debe realizar IQuardable por debajo de s√≠ mismo. </p><br><p>  En el caso de que el resultado se transforme, las reglas cambian: no hay necesidad de usar DSL Incluye para especificar la navegaci√≥n (si no hay reutilizaci√≥n de la regla), se usa otro int√©rprete y la configuraci√≥n se realiza localmente: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetJson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbContext = GetEfCoreContext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> json = dbContext.ParentRecords <span class="hljs-comment"><span class="hljs-comment">// back to EF core includes // but .Include(include1) also possible .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) .Select(e =&gt; new { FieldA: e.FieldA, FieldJson:"[1,2,3]", Role: e.Roles().First() }) .ToJson(cachedFormatter1, chain =&gt; chain.Include(e =&gt; e.Role), LeafRuleManager.DefaultEfCore, config: rules =&gt; rules .AddRule&lt;string[]&gt;(GetStringArrayFormatter) .SubTree( chain =&gt; chain.Include(e =&gt; e.FieldJson), stringAsJsonLiteral: true) // json as is .SubTree( chain =&gt; chain.Include(e =&gt; e.Role), subRules =&gt; subRules .AddRule&lt;DateTime&gt;( dateTimeFormat: "YYYMMDD", floatingPointFormat: "N2" ) ), ), useToString: false, // no default ToString for unknown leaf type (throw exception) dateTimeFormat: "YYMMDD", floatingPointFormat: "N2" } }</span></span></code> </pre> <br><p>  Est√° claro que todos estos detalles, todo esto es "por defecto", pueden tenerse en cuenta solo si realmente lo necesita y / o si este es su propio int√©rprete.  Por otro lado, volvemos nuevamente a las ventajas: el DTO no est√° manchado por el c√≥digo, est√° especificado por una funci√≥n espec√≠fica, los int√©rpretes son universales.  El c√≥digo se est√° volviendo m√°s peque√±o, eso es bueno. </p><br><p>  <strong>Es necesario advertir</strong> : aunque parece que el conocimiento preliminar siempre est√° disponible en ASP, y un serializador de transmisi√≥n no es algo muy necesario en el mundo de la web, donde incluso las bases de datos transmiten datos en json, pero el uso de DSL incluye en ASP MVC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no es la historia m√°s f√°cil</a> .  C√≥mo combinar la programaci√≥n funcional con ASP MVC merece un estudio aparte. </p><br><p>  En este art√≠culo me limitar√© a las complejidades de DSL Incluye, mostrar√© tanto la nueva funcionalidad como la fuga de abstracciones para mostrar que el problema del an√°lisis de "costos y adquisiciones" es realmente agotable. </p><br><h2 id="esche-bolshe-dsl-includes">  M√°s DSL incluye </h2><br><pre> <code class="cs hljs">Include&lt;Point&gt; include = chain =&gt; chain.Include(e=&gt;eX).Include(e=&gt;eY);</code> </pre> <br><p>  Esto difiere de EF Core Incluye funciones est√°ticas integradas que no pueden asignarse a variables y pasarse como par√°metros.  DSL incluye a s√≠ mismo naci√≥ de la necesidad de pasar "incluir" en mi implementaci√≥n de la plantilla de repositorio sin degradar la informaci√≥n de tipo que habr√≠a aparecido cuando se estandarizaron en cadenas. </p><br><p>  La diferencia m√°s dram√°tica a√∫n est√° en la cita.  EF Core incluye - inclusi√≥n de propiedades de navegaci√≥n (nodos de ramas), DSL incluye - registro de recorrido de un √°rbol de c√°lculos, asignando un nombre (ruta) al resultado de cada c√°lculo. </p><br><p>  La representaci√≥n interna de EF Core incluye es una lista de cadenas recibidas por MemberExpression.Member (La expresi√≥n especificada por <code>e=&gt;User.Name</code> solo puede ser [MemberExpression] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://msdn.microsoft.com/en-us/library/system.linq.expressions. memberexpression (v = vs. 110) .aspx</a> y en vistas internas solo se guarda la l√≠nea de <code>Name</code> ). </p><br><p>  En DSL Incluye, la representaci√≥n interna son las clases <a href="">ChainNode y ChainMemberNode</a> que <a href="">guardan la</a> expresi√≥n <a href="">completa</a> (por ejemplo, <code>e=&gt;User.Name</code> ), que, tal como est√°, est√° integrada en el √Årbol de expresiones.  Es precisamente a partir de esto que DSL incluye admite campos y tipos de valores de usuario y llamadas a funciones: </p><br><p>  Ejecuci√≥n de funciones: </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .Include(i =&gt; i.Email.ToUpper(),<span class="hljs-string"><span class="hljs-string">"EAddress"</span></span>);</code> </pre> <br><p>  Qu√© hacer con esto depende del int√©rprete.  CreateFormatter- devolver√° {"UserName": "John", "EAddress": "JOHN@MAIL.COM"} </p><br><p>  La ejecuci√≥n tambi√©n puede ser √∫til para establecer un recorrido sobre estructuras anulables. </p><br><pre> <code class="cs hljs">Include&lt;StrangePointF&gt; include = chain =&gt; chain .Include(e =&gt; e.NextPoint) <span class="hljs-comment"><span class="hljs-comment">// NextPoint is nullable struct .ThenIncluding(e =&gt; e.Value.X) .ThenInclude(e =&gt; e.Value.Y); // but not this way (abstraction leak) // Include&lt;StrangePointF&gt; include // = chain =&gt; chain // now this can throw an exception // .Include(e =&gt; e.NextPoint.Value) // .ThenIncluding(e =&gt; eX) // .ThenInclude(e =&gt; eY);</span></span></code> </pre> <br><p>  DSL incluye tambi√©n tiene una entrada corta para la soluci√≥n de varios niveles ThenIncluding. </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .IncludeAll(i =&gt; i.Groups) <span class="hljs-comment"><span class="hljs-comment">// ING-form - doesn't change current node .ThenIncluding(e =&gt; e.GroupName) // leaf .ThenIncluding(e =&gt; e.GroupDescription) // leaf .ThenInclude(e =&gt; e.AdGroup); // leaf</span></span></code> </pre> <br><p>  comparar con </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.GroupName) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.GroupDescription) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.AdGroup);</code> </pre> <br><p>  Y aqu√≠ tambi√©n hay una fuga de abstracci√≥n.  Si escribiera la navegaci√≥n en este formulario, sabr√≠a c√≥mo funciona un int√©rprete que llamar√° QuaryableExtensions.  Y traduce las llamadas a Incluir y luego a Incluir para incluir "cadena".  Qu√© puede importar (debes tenerlo en cuenta). </p><br><p>  <strong>El √°lgebra incluye expresiones</strong> . </p><br><p>  Incluir expresiones puede ser: </p><br><div class="spoiler">  <b class="spoiler_title">Comparar</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b1 = InlcudeExtensions.IsEqualTo(include1, include2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b2 = InlcudeExtensions.IsSubTreeOf(include1, include2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b3 = InlcudeExtensions.IsSuperTreeOf(include1, include2);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Clon</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> include2 = InlcudeExtensions.Clone(include1);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Fusionar</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> include3 = InlcudeExtensions.Merge(include1, include2);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Convertir a listas XPath - Todos los caminos a las hojas</b> <div class="spoiler_text"><pre> <code class="cs hljs">IReadOnlyCollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; paths1 = InlcudeExtensions.ListLeafXPaths(include); <span class="hljs-comment"><span class="hljs-comment">// as xpaths IReadOnlyCollection&lt;string[]&gt; paths2 = InlcudeExtensions.ListLeafKeyPaths(include); // as string[]</span></span></code> </pre> </div></div><br><p>  etc. </p><br><p>  La buena noticia es: no hay fugas de abstracciones, el nivel de abstracci√≥n pura se alcanza aqu√≠.  Hay metadatos y trabajo con metadatos. </p><br><h2 id="dialektika">  Dial√©ctica </h2><br><p>  DSL incluye le permite alcanzar un nuevo nivel de abstracci√≥n, pero en el momento del logro, se forma una necesidad de pasar al siguiente nivel: generar expresiones de inclusi√≥n ellos mismos. </p><br><p>  En este caso, no es necesario generar DSL como una cadena fluida, solo necesita crear estructuras de representaci√≥n internas. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChainNode(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Point)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> child = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChainPropertyNode( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), expression: <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Point).CreatePropertyLambda(<span class="hljs-string"><span class="hljs-string">"X"</span></span>), memberName:<span class="hljs-string"><span class="hljs-string">"X"</span></span>, isEnumerable:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, parent:root ); root.Children.Add(<span class="hljs-string"><span class="hljs-string">"X"</span></span>, child); <span class="hljs-comment"><span class="hljs-comment">// or there is number of extension methods eg: var child = root.AddChild("X"); Include&lt;Point&gt; include = ChainNodeExtensions.ComposeInclude&lt;Point&gt;(root);</span></span></code> </pre> <br><p>  Tambi√©n puede pasar estructuras de presentaci√≥n a int√©rpretes.  ¬øPor qu√©, entonces, incluye el registro DSL fluido?  Esta es una pregunta puramente especulativa, la respuesta a la cual: porque en la pr√°ctica, para desarrollar una representaci√≥n interna (y tambi√©n se desarrolla) solo se obtiene con el desarrollo de DSL (es decir, un breve registro expresivo conveniente para el c√≥digo est√°tico).  Una vez m√°s, esto se dir√° m√°s cerca de la conclusi√≥n. </p><br><h2 id="copy-clone-equals">  Copiar, clonar, igual </h2><br><p>  Todo lo anterior es cierto para los int√©rpretes de inclusi√≥n de expresiones que implementan <strong>copia</strong> , <strong>clonaci√≥n</strong> , iteradores <strong>iguales</strong> . </p><br><div class="spoiler">  <b class="spoiler_title">Igual a</b> <div class="spoiler_text"><p>  Comparaci√≥n solo en hojas de la expresi√≥n Incluir. <br>  Problema sem√°ntico oculto: evaluar o no ordenar en la lista </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.Include(e=&gt;e.UserId).IncludeAll(e=&gt;e.Groups).ThenInclude(e=&gt;e.GroupId) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b1 = ObjectExtensions.Equals(user1, user2, include); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b2 = ObjectExtensions.EqualsAll(userList1, userList2, include);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Clon</b> <div class="spoiler_text"><p>  Pase a trav√©s de los nodos de expresi√≥n.  Se copian las propiedades que coinciden con la regla. </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.Include(e=&gt;e.UserId).IncludeAll(e=&gt;e.Groups).ThenInclude(e=&gt;e.GroupId) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newUser = ObjectExtensions.Clone(user1, include, leafRule1); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newUserList = ObjectExtensions.CloneAll(userList1, leafRule1);</code> </pre> <br><p>  Puede haber un int√©rprete que seleccionar√° la hoja de incluye.  ¬øPor qu√© se hace a trav√©s de una regla separada?  Lo que era similar a la sem√°ntica de ObjectExtensions.Copy </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Copia</b> <div class="spoiler_text"><p>  Pase a trav√©s de nodos: una rama de expresi√≥n e identificaci√≥n por nodos hoja.  Se copian las propiedades que coinciden con la regla (similar a Clonar). </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.IncludeAll(e=&gt;e.Groups); ObjectExtensions.Copy(user1, user2, include, supportedLeafsRule); ObjectExtensions.CopyAll(userList1, userList2, include, supportedLeafsRule);</code> </pre> <br><p>  Puede haber un int√©rprete que seleccionar√° la hoja de incluye.  ¬øPor qu√© se hace a trav√©s de una regla separada?      ObjectExtensions.Copy (   ‚Äî  include   ,  supportedLeafsRule ‚Äî   ). </p></div></div><br><p>  copy / clone   : </p><br><ol><li>   readonly ,     Tuple&lt;,&gt;  Anonymous Type.    ,     . </li><li>   (. IEnumerable   ) ‚Äî  public   . </li><li>  expression  include-,       ‚Äî  . </li><li> "  "    . </li></ol><br><p>  DSL                   , ..               . ,     <code>Tuple&lt;,&gt;</code> , ..  c readonly ,   <code>ValueTuple&lt;,&gt;</code> c writabale      (      ). </p><br><p>  ,         (    Expression Trees) Includes  ‚Äî  .     Include DSL  . </p><br><p>    Detach, FindDifferences  .. </p><br><h2 id="pochemu-run-time-a-ne-cs-sgenerirovannyy-do-nachala-kompilyacii">  run-time,   .cs    ? </h2><br><p>    .cs  ,   ,   <em>run-time</em>   : </p><br><ol><li>       ( ,  , source control). </li><li>     , ,  ,   ‚Äî     . </li><li>         . </li><li>   "  ".  dev time   ,     : ""      ""   ,  ""    , ,  ""   . </li></ol><br><p>   Roslyn',          .    Typescript  (  DTO  , ..   ) ‚Äî   DSL Includes  Roslyn' ( ) ‚Äî      typescript ( ).  " "    " "  .cs (   Expression Trees). </p><br><p> :   run time ‚Äî   ,  .             (        Expression Trees). </p><br><h2 id="problemy-s-effektivnostyu-skompilirovannyh-funkciy-expression-trees">      Expression Trees </h2><br><p>   Internal DSL   Expression Tree    : </p><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>LambdaExpression.Compile</code></a>    <em>Lambda</em> .     ,  .    ,   "" expression tree,   CallExpression    ‚Äî  LambdaExpression,   (.  LambdaExpression)    ConstantExpression.    ,  " /" ‚Äî      ,    Expression Trees. </p><br></li><li><p>       <em>ssmbly</em> ,     ( 10    )    ( assembly  ,    ‚Äî  ). , ,  ,      ‚Äî  . </p><br></li></ol><br><p>     ,        (  ),     ,       .    :       .   ‚Äî  ‚Äî   .cs     . </p><br><h2 id="benchmark-serializacii">   </h2><br><p>  ‚Äî     600   15   .  JSON.NET, ServiceStack    reflection' GetProperties(). </p><br><p> dslComposeFormatter ‚Äî ComposeFormatter   ,   <a href=""></a> . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BenchmarkDotNet</a> =v0.10.14, OS=Windows 10.0.17134 <br> Intel Core i5-2500K CPU 3.30GHz (Sandy Bridge), 1 CPU, 4 logical and 4 physical cores <br> .NET Core SDK=2.1.300 </p><br><table><thead><tr><th> Method </th><th> Mean </th><th> Error </th><th> StdDev </th><th> Min </th><th> Max </th><th> Median </th><th> Allocated </th></tr></thead><tbody><tr><td> dslComposeFormatter </td><td> 2.208 ms </td><td> 0.0093 ms </td><td> 0.0078 ms </td><td> 2.193 ms </td><td> 2.220 ms </td><td> 2.211 ms </td><td> 849.47 KB </td></tr><tr><td> JsonNet_Default </td><td> 2.902 ms </td><td> 0.0160 ms </td><td> 0.0150 ms </td><td> 2.883 ms </td><td> 2.934 ms </td><td> 2.899 ms </td><td> 658.63 KB </td></tr><tr><td> JsonNet_NullIgnore </td><td> 2.944 ms </td><td> 0.0089 ms </td><td> 0.0079 ms </td><td> 2.932 ms </td><td> 2.960 ms </td><td> 2.942 ms </td><td> 564.97 KB </td></tr><tr><td> JsonNet_DateFormatFF </td><td> 3.480 ms </td><td> 0.0121 ms </td><td> 0.0113 ms </td><td> 3.458 ms </td><td> 3.497 ms </td><td> 3.479 ms </td><td> 757.41 KB </td></tr><tr><td> JsonNet_DateFormatSS </td><td> 3.880 ms </td><td> 0.0139 ms </td><td> 0.0130 ms </td><td> 3.854 ms </td><td> 3.899 ms </td><td> 3.877 ms </td><td> 785.53 KB </td></tr><tr><td> ServiceStack_SerializeToString </td><td> 4.225 ms </td><td> 0.0120 ms </td><td> 0.0106 ms </td><td> 4.201 ms </td><td> 4.243 ms </td><td> 4.226 ms </td><td> 805.13 KB </td></tr><tr><td> fake_expressionManuallyConstruted </td><td> 54.396 ms </td><td> 0.1758 ms </td><td> 0.1644 ms </td><td> 54.104 ms </td><td> 54.629 ms </td><td> 54.383 ms </td><td> 7401.58 KB </td></tr></tbody></table><br><p> fake_expressionManuallyConstruted ‚Äî expression      ( ). </p><br><h2 id="formalizaciya">  </h2><br><p>   DSL   : <strong>   DSL      ;    Internal DSL   run-time</strong> . </p><br><p> Expression Tree         <em></em>   .NET Standard . </p><br><p>     Expression Trees  <em> </em>     Internal DSL    Fluent API.      #      . </p><br><p>         fluent   (   Expression Trees),      Internal DSL  #     fluent,      ""   Expression Trees. </p><br><p> <strong>Expression Trees</strong>  <strong>DSL Includes</strong>      (  ,      ),      /  run-time ‚Äî  (run-time ). </p><br><p>  <strong>Internal DSL</strong>       :   -  <strong>serialize</strong> , <strong>copy</strong> , <strong>clone</strong> , <strong>equals</strong>        <strong>       ""</strong> .   ,      " ",      .    :  includes    (   ) ,       (       ,  ). </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>   DSL Includes    DTO           ‚Äî   ( json).        ,    ,    ,   " ",        .   =   . </p><br><p>       Internal DSL       ,   DSL,      Internal DSL (    Expression)         (     Expression Tree). </p><br><p>  DSL Includes  json  ComposeFormatter    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DashboardCodes.Routines</a>   nuget  GitHub. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419759/">https://habr.com/ru/post/es419759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es419735/index.html">Examinando la se√±al I / Q con SDR usando Adobe Audition</a></li>
<li><a href="../es419743/index.html">¬øQu√© hay de malo en los art√≠culos populares que dicen que foo es m√°s r√°pido que bar?</a></li>
<li><a href="../es419745/index.html">G√©nero cl√°sico de IA: ML se busca en la poes√≠a</a></li>
<li><a href="../es419747/index.html">DJI Ronin S - Primer lanzamiento y caracter√≠sticas clave</a></li>
<li><a href="../es419757/index.html">Traducci√≥n del libro de Andrew Un, Pasi√≥n por el aprendizaje autom√°tico, cap√≠tulos 1 - 14</a></li>
<li><a href="../es419763/index.html">Ejemplos de c√°lculo del "factor de disponibilidad" para conjuntos de equipos de red</a></li>
<li><a href="../es419765/index.html">El curso "Lenguajes de programaci√≥n web" (basado en Ruby) de MSTU. N.E. Bauman en el canal Technostream</a></li>
<li><a href="../es419767/index.html">El creador de Wikipedia responde preguntas: programaci√≥n, sue√±o, libros, consejos para la vida</a></li>
<li><a href="../es419769/index.html">WireGuard "vendr√°" al kernel de Linux, ¬øpor qu√©?</a></li>
<li><a href="../es419771/index.html">Resumen de tecnolog√≠a financiera: el Banco Central acelera la recopilaci√≥n de datos biom√©tricos de los clientes, las criptomonedas est√°n cayendo y el mercado de Internet de las cosas est√° creciendo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>