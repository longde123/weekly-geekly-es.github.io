<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ üõçÔ∏è ü§¥üèø Nous pompons les crochets React √† l'aide de FRP üë©üèª‚Äç‚öñÔ∏è üçº üë®üèæ‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apr√®s avoir ma√Ætris√© les crochets, de nombreux d√©veloppeurs de React ont connu l'euphorie, obtenant enfin une bo√Æte √† outils simple et pratique qui vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous pompons les crochets React √† l'aide de FRP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445214/"><p>  Apr√®s avoir ma√Ætris√© les crochets, de nombreux d√©veloppeurs de React ont connu l'euphorie, obtenant enfin une bo√Æte √† outils simple et pratique qui vous permet d'impl√©menter des t√¢ches avec beaucoup moins de code.  Mais cela signifie-t-il que les crochets standard useState et useReducer propos√©s hors de la bo√Æte sont tout ce dont nous avons besoin pour g√©rer l'√©tat? </p><br><p>  √Ä mon avis, dans leur forme brute, leur utilisation n'est pas tr√®s pratique, ils peuvent plus probablement √™tre consid√©r√©s comme la base pour construire des crochets de gestion d'√©tat vraiment pratiques.  Les d√©veloppeurs de React eux-m√™mes encouragent fortement le d√©veloppement de crochets personnalis√©s, alors pourquoi ne pas le faire?  Sous la coupe, nous examinerons un exemple tr√®s simple et compr√©hensible de ce qui ne va pas avec les crochets ordinaires et comment ils peuvent √™tre am√©lior√©s, √† tel point qu'ils refusent compl√®tement de les utiliser sous leur forme pure. </p><a name="habracut"></a><br><p>  Il y a un certain champ pour entrer, conditionnellement, un nom.  Et il y a un bouton en cliquant sur lequel on doit faire une demande au serveur avec le nom saisi (une certaine recherche).  Il semblerait que cela pourrait √™tre plus facile?  Cependant, la solution est loin d'√™tre √©vidente.  La premi√®re impl√©mentation na√Øve: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(name)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre> <br><p>  Qu'est-ce qui ne va pas ici?  Si l'utilisateur, saisissant quelque chose dans le champ, envoie le formulaire deux fois, seule la premi√®re demande fonctionnera pour nous, car  au deuxi√®me clic, la demande ne changera pas et useEffect ne fonctionnera pas.  Si nous imaginons que notre application est un service de recherche de billets, et que l'utilisateur peut √† certains intervalles envoyer le formulaire encore et encore sans apporter de modifications, alors une telle impl√©mentation ne fonctionnera pas pour nous!  L'utilisation du nom comme d√©pendance pour useEffect est √©galement inacceptable, sinon le formulaire sera envoy√© imm√©diatement lorsque le texte change.  Eh bien, vous devez faire preuve d'ing√©niosit√©. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(!request)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  Maintenant, √† chaque clic, nous changerons la signification de la demande √† l'oppos√©, ce qui permettra d'obtenir le comportement souhait√©.  C'est une b√©quille tr√®s petite et innocente, mais cela rend le code quelque peu d√©routant √† comprendre.  Peut-√™tre maintenant il vous semble que je suce le probl√®me de mon doigt et gonfle son √©chelle.  Eh bien, pour savoir si c'est vrai ou non, vous devez comparer ce code avec d'autres impl√©mentations qui offrent une approche plus expressive. </p><br><p>  Regardons cet exemple au niveau th√©orique en utilisant l'abstraction des threads.  Il est tr√®s pratique pour d√©crire l'√©tat des interfaces utilisateur.  Nous avons donc deux flux: les donn√©es saisies dans le champ de texte (nom $), et un flux de clics sur le bouton d'envoi du formulaire (cliquez sur $).  √Ä partir d'eux, nous devons cr√©er un troisi√®me flux combin√© de demandes vers le serveur. </p><br><pre> <code class="plaintext hljs">name$ __(C)____(Ca)_____(Car)____________________(Carl)___________ click$ ___________________________()______()________________()_____ request$ ___________________________(Car)___(Car)_____________(Carl)_</code> </pre> <br><p>  Voici le comportement que nous devons atteindre.  Chaque flux a deux aspects: la valeur qu'il poss√®de et le moment auquel les valeurs le traversent.  Dans diverses situations, nous pouvons avoir besoin de l'un ou l'autre aspect, ou des deux.  Vous pouvez comparer cela avec le rythme et l'harmonie de la musique.  Les flux pour lesquels seul le temps de r√©ponse est essentiel sont √©galement appel√©s signaux. </p><br><p>  Dans notre cas, le clic $ est un signal pur: peu importe la valeur qui le traverse (ind√©fini / vrai / √©v√©nement / quoi que ce soit), il n'est important que lorsque cela se produit.  Nom de cas $ <br>  le contraire: ses changements n'entra√Ænent aucun changement dans le syst√®me, mais nous pourrions avoir besoin de sa signification √† un moment donn√©.  Et √† partir de ces deux flux, nous devons faire le troisi√®me, en prenant de la premi√®re fois, de la deuxi√®me valeur. </p><br><p>  Dans le cas de Rxjs, nous avons un op√©rateur presque pr√™t √† l'emploi pour cela: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> click$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request$ = click$.pipe(withLatestFrom(name$), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[name]</span></span></span><span class="hljs-function">) =&gt;</span></span> fromPromise(fetch(...))));</code> </pre> <br><p>  Cependant, l'utilisation pratique de Rx dans React peut √™tre assez g√™nante.  Une option plus appropri√©e est la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mrr</a> , construite sur les m√™mes principes fonctionnels-r√©actifs que Rx, mais sp√©cialement adapt√©e pour une utilisation avec React sur le principe de la "r√©activit√© totale" et connect√©e comme un crochet. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> useMrr <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mrr/hooks'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">result</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.result), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input value={state.name} onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('submit')}/&gt; { state.result &amp;&amp; &lt;div&gt;Result: { state.result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  L'interface useMrr est similaire √† useState ou useReducer: elle retourne un objet d'√©tat (valeurs de tous les threads) et un setter afin de mettre des valeurs dans les threads.  Mais √† l'int√©rieur, tout est un peu diff√©rent: chaque champ d'√©tat (= stream), √† l'exception de ceux dans lesquels nous mettons des valeurs directement √† partir des √©v√©nements DOM, est d√©crit par une fonction et une liste de threads parents, dont le changement entra√Ænera le recalcul de l'enfant.  Dans ce cas, les valeurs des threads parents seront substitu√©es dans la fonction.  Si nous voulons simplement obtenir la valeur du flux, mais ne pas r√©pondre √† son changement, alors nous √©crivons un "moins" devant le nom, comme dans le cas du nom. </p><br><p>  Nous avons obtenu le comportement souhait√©, essentiellement, en une seule ligne.  Mais ce n'est pas seulement de la bri√®vet√©.  Comparons plus en d√©tail les r√©sultats obtenus, et tout d'abord par rapport √† un param√®tre tel que la lisibilit√© et la clart√© du code r√©sultant. </p><br><p>  Dans mrr, vous pourrez s√©parer presque compl√®tement la ¬´logique¬ª du ¬´mod√®le¬ª: vous n'aurez pas √† √©crire de gestionnaires imp√©ratifs complexes dans JSX.  Tout est extr√™mement d√©claratif: nous mappons simplement l'√©v√©nement DOM au flux correspondant, pratiquement sans conversion (pour les champs d'entr√©e, la valeur e.target.value est extraite automatiquement, sauf indication contraire), et d√©j√† dans la structure useMrr nous d√©crivons comment les flux de base sont form√©s filiales.  Ainsi, dans le cas de transformations de donn√©es synchrones et asynchrones, nous pouvons toujours facilement suivre la fa√ßon dont notre valeur est form√©e. </p><br><p>  Compar√© √† Px: nous n'avions m√™me pas besoin d'utiliser des op√©rateurs suppl√©mentaires: si, par cons√©quent, les fonctions mrr re√ßoivent une promesse, elles attendront automatiquement jusqu'√† ce qu'elles se r√©solvent et mettent les donn√©es re√ßues dans le flux.  De plus, au lieu de withLatestFrom, nous avons utilis√© <br>  √©coute passive (signe moins), ce qui est plus pratique.  Imaginez qu'en plus du nom, nous devrons envoyer d'autres champs.  Ensuite, dans mrr, nous ajouterons un autre flux √† √©coute passive: </p><br><pre> <code class="javascript hljs">result: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname</span></span></span><span class="hljs-function">) =&gt;</span></span> fetch(...), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'-surname'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>],</code> </pre> <br><p>  Et dans Rx, vous devez en sculpter un de plus avec LatestFrom avec une carte, ou combiner d'abord le nom et le pr√©nom en un seul flux. </p><br><p>  Mais revenons aux crochets et mrr.  Un enregistrement plus lisible des d√©pendances, qui montre toujours comment les donn√©es sont form√©es, est peut-√™tre l'un des principaux avantages.  L'interface useEffect actuelle ne permet fondamentalement pas de r√©pondre aux flux de signaux, c'est pourquoi <br>  Je dois trouver des rebondissements diff√©rents. </p><br><p>  Un autre point est que l'option des crochets ordinaires comporte des rendus suppl√©mentaires.  Si l'utilisateur vient de cliquer sur le bouton, cela n'entra√Æne pas encore de modifications de l'interface utilisateur que la r√©action doit dessiner.  Cependant, un rendu sera appel√©.  Dans la variante avec mrr, l'√©tat retourn√© ne sera mis √† jour que lorsqu'une r√©ponse du serveur est d√©j√† arriv√©e.  √âconomiser sur les matchs, dites-vous?  Eh bien, peut-√™tre.  Mais pour moi personnellement, le principe de ¬´se restituer dans toute situation incompr√©hensible¬ª, qui est √† la base des crochets de base, provoque le rejet. </p><br><p>  Les rendus suppl√©mentaires signifient une nouvelle formation de gestionnaires d'√©v√©nements.  Au fait, ici, les crochets ordinaires sont tous mauvais.  Non seulement les gestionnaires sont imp√©ratifs, mais ils doivent √©galement √™tre r√©g√©n√©r√©s √† chaque rendu.  Et il ne sera pas possible d'utiliser pleinement la mise en cache ici, car  de nombreux gestionnaires doivent √™tre verrouill√©s sur les variables de composants internes.  Les gestionnaires mrr sont plus d√©claratifs et la mise en cache est d√©j√† int√©gr√©e √† mrr: set ('name') ne sera g√©n√©r√© qu'une seule fois et sera remplac√© √† partir du cache pour les rendus suivants. </p><br><p>  Avec une augmentation de la base de code, les gestionnaires imp√©ratifs peuvent devenir encore plus encombrants.  Disons que nous devons √©galement indiquer le nombre de soumissions de formulaires effectu√©es par l'utilisateur. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, makeRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [clicks, setClicks] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; { makeRequest(!request); setClicks(clicks + 1); }}/&gt;&lt;br /&gt; Clicked: { clicks } &lt;/div&gt;; }</code> </pre><br><p>  Pas tr√®s beau.  Vous pouvez bien s√ªr rendre le gestionnaire en tant que fonction distincte √† l'int√©rieur du composant.  La lisibilit√© augmentera, mais le probl√®me de la r√©g√©n√©ration de la fonction √† chaque rendu restera, ainsi que le probl√®me de l'imp√©rativit√©.  En substance, il s'agit d'un code proc√©dural r√©gulier, malgr√© la croyance r√©pandue que l'API React √©volue progressivement vers une approche fonctionnelle. </p><br><p>  √Ä ceux √† qui l'ampleur du probl√®me semble exag√©r√©e, je peux r√©pondre que, par exemple, les d√©veloppeurs du React eux-m√™mes sont conscients du probl√®me de la g√©n√©ration excessive de gestionnaires, nous offrant imm√©diatement une b√©quille sous la forme d'utilisation de Callback. </p><br><p>  Sur mrr: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('makeRequest')}/&gt; &lt;/div&gt;; }</code> </pre><br><p>  UseReducer est une alternative plus pratique, vous permettant d'abandonner l'imp√©ratif des gestionnaires.  Mais d'autres probl√®mes importants demeurent: le manque de travail avec les signaux (puisque le m√™me useEffect sera responsable des effets secondaires), ainsi que la pire lisibilit√© lors des conversions asynchrones (en d'autres termes, il est plus difficile de tracer la relation entre les champs du magasin, en raison du m√™me useEffect )  Si dans mrr le graphique de d√©pendance entre les champs d'√©tat (threads) est imm√©diatement clairement visible, dans les crochets, vous devez tourner les yeux de haut en bas un peu. </p><br><p>  En outre, le partage de useState et useReducer dans le m√™me composant n'est pas tr√®s pratique (l√† encore, il y aura des gestionnaires imp√©ratifs complexes qui changeront quelque chose dans useState <br>  et action d'envoi), √† cause de quoi, tr√®s probablement, avant de d√©velopper le composant, vous devrez accepter l'une ou l'autre option. </p><br><p>  Bien entendu, l'examen de tous les aspects peut encore se poursuivre.  Afin de ne pas d√©passer le cadre de l'article, j'aborderai en d√©tail certains points moins importants. </p><br><p>  Journalisation centralis√©e, d√©bogage.  √âtant donn√© que dans mrr, tous les flux sont contenus dans un concentrateur, pour le d√©bogage, il suffit d'ajouter un indicateur: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$log</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); ...</code> </pre> <br><p>  Apr√®s cela, toutes les modifications apport√©es aux flux seront affich√©es dans la console.  Pour acc√©der √† l'√©tat entier (c'est-√†-dire aux valeurs actuelles de tous les threads), il existe un pseudo-flux $ state: </p><br><pre> <code class="javascript hljs">a: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, click, result }</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... }, <span class="hljs-string"><span class="hljs-string">'$state'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>],</code> </pre> <br><p>  Ainsi, si vous avez besoin ou si vous √™tes tr√®s habitu√© au style √©ditorial, vous pouvez √©crire dans le style de l'√©diteur dans mrr, en retournant une nouvelle valeur de champ en fonction de l'√©v√©nement et de tout l'√©tat pr√©c√©dent.  Mais l'inverse (√©crire sur useReducer ou un √©diteur dans le style mrr) ne fonctionnera pas, faute de r√©activit√©. </p><br><p>  Travaillez avec le temps.  Rappelez-vous deux aspects des flux: le sens et le temps de r√©ponse, l'harmonie et le rythme?  Donc, travailler avec le premier dans les crochets ordinaires est assez simple et pratique, mais avec le second - non.  En travaillant dans le temps, j'entends la formation de fili√®res d'enfants, dont le ¬´rythme¬ª est diff√©rent du parent.  Il s'agit principalement de toutes sortes de filtres, debowns, trotl, etc.  Tout cela, vous devrez probablement le mettre en ≈ìuvre vous-m√™me.  Dans mrr, vous pouvez utiliser des instructions pr√©d√©finies pr√™tes √† l'emploi.  Le gentleman set mrr est inf√©rieur √† la vari√©t√© d'op√©rateurs Rx, mais il a une d√©nomination plus intuitive. </p><br><p>  Interaction entre les composants.  Je me souviens que dans l'√©diteur, il √©tait consid√©r√© comme une bonne pratique de cr√©er une seule histoire.  Si nous utilisons useReducer dans de nombreux composants, <br>  Il peut y avoir un probl√®me d'organisation de l'interaction entre les parties.  Sur mrr, les flux peuvent librement ¬´circuler¬ª d'un composant √† un autre, que ce soit vers le haut ou vers le bas de la hi√©rarchie, mais cela ne cr√©era pas de probl√®mes en raison de l'approche d√©clarative.  Plus de d√©tails <br>  cette rubrique, ainsi que d'autres fonctionnalit√©s de l'API mrr, sont d√©crites dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Acteurs + FRP dans React</a> </p><br><h3 id="vyvody">  Conclusions </h3><br><p>  Les nouveaux crochets React sont excellents et simplifient nos vies, mais ils pr√©sentent certains d√©fauts qu'un crochet polyvalent de niveau sup√©rieur (gestion de l'√©tat) peut corriger.  UseMrr de la biblioth√®que mrr fonctionnelle-r√©active a √©t√© propos√© et consid√©r√© comme tel. </p><br><p>  Probl√®mes et leurs solutions: </p><br><ul><li>  recomptages inutiles des donn√©es √† chaque rendu (en mrr sont absents en raison de la r√©activit√© bas√©e sur la pouss√©e) </li><li>  rendus suppl√©mentaires lorsqu'un changement d'√©tat n'entra√Æne pas de changement dans l'interface utilisateur </li><li>  mauvaise lisibilit√© du code avec les conversions asynchrones (par rapport aux conversions synchrones).  Dans mrr, le code asynchrone n'est pas inf√©rieur au synchrone en termes de lisibilit√© et d'expressivit√©.  La plupart des probl√®mes discut√©s dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©cent article sur useEffect</a> sur mrr sont fondamentalement impossibles </li><li>  gestionnaires imp√©ratifs qui ne sont pas toujours mis en cache (dans mrr, ils sont automatiquement mis en cache, presque toujours peuvent √™tre mis en cache, d√©claratifs) </li><li>  utiliser useState et useReducer en m√™me temps peut cr√©er un code g√™nant </li><li>  manque d'outils pour convertir les flux dans le temps (anti-rebond, acc√©l√©rateur, condition de course) </li></ul><br><p>  Sur de nombreux points, on peut affirmer qu'ils peuvent √™tre r√©solus par des crochets personnalis√©s.  Mais c'est pr√©cis√©ment ce qui est propos√©, mais au lieu d'impl√©mentations disparates, pour chaque t√¢che distincte, une solution globale et coh√©rente est propos√©e. </p><br><p>  De nombreux probl√®mes sont devenus trop familiers pour que nous soyons clairement reconnus.  Par exemple, les conversions asynchrones ont toujours sembl√© plus compliqu√©es et d√©routantes que les conversions synchrones, et les crochets en ce sens ne sont pas pires que les approches ant√©rieures (√©diteurs, etc.).  Pour r√©aliser cela comme un probl√®me, vous devez d'abord voir d'autres approches qui offrent une meilleure solution. </p><br><p>  Cet article ne vise pas √† imposer des vues sp√©cifiques, mais plut√¥t √† attirer l'attention sur le probl√®me.  Je suis s√ªr que d'autres solutions existent ou sont en cours de cr√©ation qui peuvent devenir une alternative valable, mais qui ne sont pas encore largement connues.  L'API React Cache √† venir peut √©galement faire une grande diff√©rence.  Je me ferai un plaisir de critiquer et de discuter dans les commentaires. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les personnes</a> int√©ress√©es peuvent √©galement regarder une pr√©sentation sur ce sujet sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kyivjs</a> le 28 mars. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445214/">https://habr.com/ru/post/fr445214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445204/index.html">Conversion en continu des bases de donn√©es Firebird 2.5 au format ODS12 (Firebird 3.0)</a></li>
<li><a href="../fr445206/index.html">R√©duisez les temps d'arr√™t lors de la mise √† niveau de Zimbra</a></li>
<li><a href="../fr445208/index.html">Niveaux de maturit√© informatique d'entreprise</a></li>
<li><a href="../fr445210/index.html">Colonie de crypto-monnaie</a></li>
<li><a href="../fr445212/index.html">NetBIOS entre les mains d'un pirate</a></li>
<li><a href="../fr445220/index.html">AMD Radeon VII: puce haut de gamme (partie 3)</a></li>
<li><a href="../fr445222/index.html">Recevez une offre en 1 jour √† l'√©quipe back-end lors de la Cosmonautics Day</a></li>
<li><a href="../fr445226/index.html">Le d√©veloppement d'une fus√©e capable d'atteindre la lune co√ªtera √† la Russie 740 milliards de roubles</a></li>
<li><a href="../fr445228/index.html">Cryptographie en Java. Classe Mac</a></li>
<li><a href="../fr445230/index.html">D√©but des inscriptions √† la II conf√©rence informatique pour d√©butants SMARTRHINO-2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>