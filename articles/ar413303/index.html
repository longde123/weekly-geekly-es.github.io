<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥧 👩🏿 🏇🏿 قصة مشكلة: أقصر مذكرة جافا سكريبت 🏴󠁧󠁢󠁳󠁣󠁴󠁿 💚 🏆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="كان ذلك في المساء عشية مؤتمر HolyJS السنوي في سانت بطرسبرغ. كانت شركتنا راعيًا لعدة سنوات: وبناءً عليه ، لديها أيضًا موقفها الخاص مع اهتمامات مثيرة لل...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>قصة مشكلة: أقصر مذكرة جافا سكريبت</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/413303/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/bn/ca/u1/bncau1_hr7wuzgyelj-ebncmyl4.png" alt="الصورة"></p><br><p style=";text-align:right;direction:rtl">  كان ذلك في المساء عشية مؤتمر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">HolyJS</a> السنوي في سانت بطرسبرغ.  كانت شركتنا راعيًا لعدة سنوات: وبناءً عليه ، لديها أيضًا موقفها الخاص مع اهتمامات مثيرة للاهتمام للعقل الفضول لمطوري الرعاية.  عندما كانت الدورة الرئيسية جاهزة وتم استعراض جميع المهام واستكمالها من قبل المحامين ، قررت أن أرمي لزملائي بعض الطعام الفكري في الليل: </p><br><blockquote style=";text-align:right;direction:rtl">  كتابة مفكرة - وظيفة الديكور التي تحفظ نتائج تنفيذ دالة ملفوفة لمنع تكرار العمليات الحسابية.  لديك 50 حرفًا فقط. </blockquote><p style=";text-align:right;direction:rtl">  اللغة ، بالطبع ، هي <strong>JavaScript</strong> .  المهمة نفسها هي مهمة كلاسيكية ، لكن الحد الأقصى المكون من 50 حرفًا أصبح تحديًا حقيقيًا. </p><br><p style=";text-align:right;direction:rtl">  في فواصل اليوم الأول من المؤتمر ، ناقشنا الخيارات لتحقيق الهدف ، وتقليل الاستجابة تدريجياً.  توجت كل هذه الضجة بفكرة مشاركة المهمة مع جميع المشاركين في المؤتمر ، وفي اليوم الثاني تصورنا المهمة (انظر الملحق) وبدأنا في توزيع النماذج على أولئك الذين أرادوا.  ونتيجة لذلك ، حصلنا على حوالي 40 حلًا وأصبحنا مقتنعين مرة أخرى بالمجتمع الاستثنائي لمطوري js ، لكن سجل <strong>Dmitry Kataev</strong> (SEMrush) المكون من <strong>53</strong> حرفًا بقي.  دعونا نكتشف ذلك! </p><a name="habracut"></a><br><h3 id="privychnaya-realizaciya" style=";text-align:right;direction:rtl">  التنفيذ المعتاد </h3><br><pre style=";text-align:right;direction:rtl"><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cache = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cache.hasOwnProperty(key)) { cache[key] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache[key]; } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>190</strong> حرفًا تقريبًا </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  Memoize - Memoizer لدينا </li><li style=";text-align:right;direction:rtl">  و - وظيفة مزخرفة ومغلفة </li><li style=";text-align:right;direction:rtl">  دالة ناتجة </li></ul><br><p style=";text-align:right;direction:rtl">  للحصول على الإجابة - حجم الوظيفة - نستخدم: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs">memoize.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).length</code> </pre> <br><p style=";text-align:right;direction:rtl">  عند تقييم حجم دالة ، نولي اهتماما لجسمها وقائمة المعلمات.  إذا كانت الوظيفة مجهولة ، فلن يؤخذ الإعلان في الاعتبار. </p><br><p style=";text-align:right;direction:rtl">  اختبارات بسيطة لاختبار الصحة بعد الإساءة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = memoize(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inc = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function"> =&gt;</span></span> ox + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><table style=";text-align:right;direction:rtl"><thead><tr><th>  لا. </th><th>  استدعاء دالة </th><th>  نتيجة التنفيذ في وحدة التحكم </th></tr></thead><tbody><tr><td>  1. </td><td> <code>log(false)</code> </td> <td>  &gt; خطأ </td></tr><tr><td>  2. </td><td> <code>log('2', {x:1})</code> </td> <td>  &gt; "2" ، {x: 1} </td></tr><tr><td>  3. </td><td> <code>log(false)</code> </td> <td>  لا شيء ، حيث تم تنفيذ الوظيفة بالفعل لهذه القيم. </td></tr><tr><td>  4. </td><td> <code>log('2', {x:1})</code> </td> <td>  لا شيء ، حيث تم تنفيذ الوظيفة بالفعل لهذه القيم. </td></tr><tr><td>  5. </td><td> <code>inc({x:1})</code> </td> <td>  2 </td></tr><tr><td>  6. </td><td> <code>inc({x:2})</code> </td> <td>  3 </td></tr></tbody></table><br><p style=";text-align:right;direction:rtl">  بعد ذلك ، سيتم تمييز نتيجة كل تنفيذ بنتيجة الاختبار. </p><br><h3 id="chistaya-realizaciya" style=";text-align:right;direction:rtl">  التنفيذ الصافي </h3><br><p style=";text-align:right;direction:rtl">  بادئ ذي بدء ، أريد التخلص من <em>إعلان الوظيفة</em> لصالح وظيفة السهم ، نظرًا لأننا لسنا مهتمين <em>بهذا</em> السياق ، فنحن لا نناشد <em>الحجج ، وبصفتنا</em> مُنشئ لا ننوي الاتصال به من خلال <em>جديد</em> .  في الوقت نفسه ، سنقوم بتخفيض أسماء المتغيرات المحلية المستخدمة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>154</strong> ، اجتياز الاختبارات </p><br><p style=";text-align:right;direction:rtl">  ثم يمكننا تنفيذ عملية مماثلة مع الدالة الناتجة ، ولكننا بحاجة إلى <em>الحجج</em> .  هنا يأتي <em>عامل الانتشار</em> إلى الإنقاذ ، مما يسمح لنا باستبدال الكائن القابل للتكرار للحجج بمتغير الصفيف <em>a</em> .  بالإضافة إلى ذلك ، لن نقوم بتمرير <em>هذا</em> السياق إلى الوظيفة التي يتم تزيينها: إذا لزم الأمر ، <em>Function.prototype.bind</em> أو بوليفيل سيساعدنا. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f(...a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>127</strong> ، اجتازت الاختبارات </p><br><p style=";text-align:right;direction:rtl">  ننتقل الآن إلى نص الدالة الناتجة.  من الواضح أن العثور على المفتاح في ذاكرة التخزين المؤقت وإرجاع القيمة أمر مرهق.  لنحاول تقليل الطريقة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k] || (c[k] = f(...a)); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>101</strong> ، انخفض الاختباران 3 و 4 </p><br><p style=";text-align:right;direction:rtl">  هنا نتخلى عن طريقة <em>hasOwnProperty</em> .  يمكننا تحمل ذلك ، لأن نتيجة إجراء تسلسل لمجموعة من الحجج عبر <em>JSON.stringify</em> ستكون دائمًا "[...]" ومن غير المحتمل أن <em>تظهر</em> هذه الخاصية في ذاكرة التخزين المؤقت للنموذج الأولي ( <em>Object</em> ). </p><br><p style=";text-align:right;direction:rtl">  بعد ذلك ، نستخدم ميزة عامل التشغيل "المنطقي" أو لإرجاع التعبير الأول إذا كان يمكن تحويله إلى " <em>صواب"</em> ، أو غير ذلك ، الثاني مع حساب الوظيفة السابقة. </p><br><p style=";text-align:right;direction:rtl">  وهنا سقطنا الاختبارين 3 و 4. حدث هذا لأن وحدة <em>التحكم</em> بالوظيفة المزخرفة لا تعرض قيمة: ستكون النتيجة <em>غير محددة</em> .  نضع هذا في ذاكرة التخزين المؤقت ، وعندما نحاول التحقق من ميزة الانفصال عندما نطلق عليها مرة أخرى ، يتم عرض <em>خطأ</em> ضمنيًا في المعامل الأول ، وبالتالي نصل إلى الثانية ، مما يؤدي إلى استدعاء الوظيفة.  سيحدث هذا التأثير لجميع النتائج التي تم اختزالها إلى <em>false</em> : <em>0 ، "" ، null ، NaN</em> ، إلخ. </p><br><p style=";text-align:right;direction:rtl">  بدلاً من OR <em>وإذا كانت العبارة ،</em> يمكننا استخدام عامل ثلاثي مشروط: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.hasOwnProperty(k) ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>118</strong> اجتازت الاختبارات </p><br><p style=";text-align:right;direction:rtl">  تخفيض طفيف جدا.  ولكن ماذا لو كنت تستخدم <em>الخريطة</em> كمخزن بدلاً من كائن بسيط؟  هناك أيضا طريقة قصيرة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c.has(k) ?c :c.set(k, f(...a))).get(k); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>121</strong> اجتازت الاختبارات </p><br><p style=";text-align:right;direction:rtl">  فشل الحد تماما.  لكن تجاهل <em>الخريطة على</em> الفور لا يستحق ذلك.  يسمح لك هذا التطبيق بتخزين القيمة الأساسية باستخدام الكائنات كمفتاح.  وهذا يعني ، هل يجب أن نتخلى عن <em>JSON.stringify</em> على الإطلاق؟ </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> (c.has(a) ?c :c.set(a, f(...a))).get(a); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>83</strong> ، انخفض الاختباران 3 و 4 </p><br><p style=";text-align:right;direction:rtl">  تبدو واعدة جدا!  ومع ذلك ، بدأ الاختباران 3 و 4 في الانخفاض مرة أخرى ، وذلك لأن مقارنة المفاتيح في كائن <em>الخريطة</em> يتم تنفيذها باستخدام خوارزمية <em>SameValueZero</em> .  إذا حذفت التفاصيل باستخدام <em>NaN و -0</em> و <em>0</em> ، فستعمل بالمثل <em>مع عامل المقارنة الصارم</em> ( <em>===</em> ).  ولدينا مجموعة جديدة من الحجج (وبالتالي كائن) لكل استدعاء للدالة الملتفة ، حتى بنفس القيم.  تتم المقارنة وفقًا لمرجع الكائن ، وبالتالي <em>لن</em> تجد طريقة <em>Map.prototype.has</em> أي شيء. </p><br><p style=";text-align:right;direction:rtl">  وبالتالي ، فإن استخدام <em>الخريطة</em> لم يقلل من <em>قدرتنا على الملكية</em> أو <em>JSON.stringify</em> . </p><br><p style=";text-align:right;direction:rtl">  في <em>عامل</em> يأتي الإنقاذ ، الذي يتحقق من وجود خاصية في كائن أو في سلسلة من نماذجها الأولية.  تم شرح سبب عدم الخوف من البحث في النماذج الأولية أعلاه. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>105</strong> اجتازت الاختبارات </p><br><p style=";text-align:right;direction:rtl">  يتكون نص كل من المذكرة والوظيفة الناتجة من تعبيرين مع الحاجة إلى تعريف المتغير المحلي وتهيئته قبل المنطق في <em>بيان الإرجاع</em> .  هل من الممكن اختزال نص دالة السهم إلى تعبير واحد هنا؟  بالطبع ، باستخدام <em>نمط IIFE</em> ( <em>التعبير عن الوظيفة التي يتم استدعاؤها فورًا</em> ): </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> (...a) =&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function"> =&gt;</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] : c[k] = f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)) )({});</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>82</strong> اجتازت الاختبارات </p><br><p style=";text-align:right;direction:rtl">  حان الوقت للتخلص من المساحات الإضافية: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)))({});</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>68</strong> اجتياز الاختبارات </p><br><p style=";text-align:right;direction:rtl">  من الواضح أن عنق الزجاجة الآن هو طريقة <em>JSON.stringify</em> الطويلة ، التي تقوم بتسلسل الكائن بشكل متكرر إلى سلسلة JSON ، والتي نستخدمها كمفتاح.  في الواقع ، نحن لا نحتاج إلى وظيفة تسلسل ، ولكن وظيفة تجزئة يمكننا من خلالها التحقق من المساواة بين الكائنات ، لأنها تعمل بلغات أخرى.  ولكن ، لسوء الحظ ، لا يوجد حل أصلي في JavaScript ، ومن الواضح أن polyphile المكتوب ذاتيًا على <em>hashCode</em> في النموذج الأولي <em>للكائن</em> خارج النطاق. </p><br><p style=";text-align:right;direction:rtl">  همم ، لماذا علينا أن نسلسل أنفسنا؟  عند إضافة عنصر إلى كائن بواسطة المفتاح ، سيتم استدعاء toString بشكل ضمني.  نظرًا لأننا رفضنا استخدام كائن <em>الوسيطات</em> القابلة للتكرار لصالح الصفيف من خلال <em>عامل الانتشار</em> ، فلن يتم استدعاء <em>toString</em> من <em>Object.prototype</em> ، ولكن من <em>Array.prototype</em> ، حيث يتم إعادة تعريفه وفصل عناصره بفواصل.  وهكذا ، للحصول على مجموعة مختلفة من الحجج نحصل على مفتاح مختلف. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[a]:c[a]=f(...a))({});</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>44</strong> ، انخفض الاختبار 6 </p><br><p style=";text-align:right;direction:rtl">  الاختبار 6 بدأ للتو في الانخفاض. يبدو أن القيمة المرتجعة هي نتيجة استدعاء دالة سابق في الاختبار 5. لماذا يحدث هذا؟  نعم ، تجاوزنا المكالمة إلى <em>String</em> لكائن <em>الوسيطات</em> ، لكننا لم نأخذ في الاعتبار أن أي وسيطة يمكن أن تكون أيضًا كائنًا معقدًا ، حيث <em>ننادي toString</em> التي نحصل منها على <em>[كائن الكائن]</em> المفضل لدى الجميع.  هذا يعني أن الوسيطات {x: 1} و {x: 2} ستستخدم نفس المفتاح في التجزئة. </p><br><p style=";text-align:right;direction:rtl">  <em>بدا btoa</em> المستخدم للتحويل إلى base64 منافسًا جيدًا لوظيفة التسلسل.  لكنه يقود أولاً إلى الخيط ، لذلك لا توجد فرصة.  فكرنا في اتجاه إنشاء URI ، وتشكيل <em>ArrayBuffer</em> ، أي وظائف للحصول على تجزئة أو قيمة متسلسلة.  لكنهم بقوا في مكانهم. </p><br><p style=";text-align:right;direction:rtl">  بالمناسبة ، <em>JSON.stringify</em> له خصائصه الخاصة: <em>Infinity ، NaN ، غير محدد ،</em> سيتم <em>طرح</em> <em>الرمز</em> إلى قيمة <em>خالية</em> .  وينطبق الشيء نفسه على الوظائف.  إذا أمكن ، يحدث استدعاء ضمني لـ <em>JSON</em> من الكائن ، وسيتم تمثيل <em>الخريطة</em> <em>والتعيين</em> بواسطة العناصر التي تم تعدادها ببساطة.  إنه مفهوم ، بالنظر إلى التنسيق النهائي: JSON. </p><br><p style=";text-align:right;direction:rtl">  ماذا بعد ذلك؟ </p><br><h3 id="toksichnaya-dorabotka" style=";text-align:right;direction:rtl">  تعديل سامة </h3><br><p style=";text-align:right;direction:rtl">  كلنا نحب بالتأكيد وظائف نقية ، ولكن في مواجهة المشكلة ، فإن مثل هذا الشرط لا يستحق ذلك.  وهذا يعني أن الوقت قد حان لإضافة قليل من الآثار الجانبية. </p><br><p style=";text-align:right;direction:rtl">  أولاً ، لماذا لا تبدأ ذاكرة التخزين المؤقت على النحو التالي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs">(f,c={})=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>66</strong> اجتياز الاختبارات </p><br><p style=";text-align:right;direction:rtl">  هنا نستخدم <em>المعلمة الافتراضية</em> في وظيفة السهم.  بالطبع ، نعطي العميل الفرصة لضبط ذاكرة التخزين المؤقت ، فماذا؟  لكننا قللنا حرفين. </p><br><p style=";text-align:right;direction:rtl">  وإلا كيف يمكنني بدء ذاكرة تخزين مؤقت لتزيين الوظيفة؟  الإجابة الصحيحة: لماذا نحتاج إلى البدء بها؟  لماذا لا تستخدم شيئًا جاهزًا في سياق دالة ليتم لفها.  ولكن ماذا لو كانت الوظيفة نفسها؟  نعلم جميعًا أن الوظائف في JavaScript هي أيضًا كائنات: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>59</strong> اجتازت الاختبارات </p><br><p style=";text-align:right;direction:rtl">  هنا <em>سوف تحمينا JSON.stringify</em> من التقاطع مع الخصائص والأساليب الأخرى للكائن (الوظيفة) ، مع التفاف الوسيطات في "[...]". </p><br><p style=";text-align:right;direction:rtl">  في هذه اللحظة بالذات ، <em>لم</em> يعد نموذج <em>IIFE الذي تم</em> تطبيقه سابقًا يبرر نفسه.  ولكن هناك حاجة ماسة إلى الاحتفاظ بتعبير واحد لوظيفة السهم لتجنب عبارة <em>الإرجاع</em> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a),k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a));</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>57</strong> اجتياز الاختبارات </p><br><p style=";text-align:right;direction:rtl">  نظرًا لأننا لا نستخدم <em>عبارة block</em> في دالة السهم ، فلا يمكننا الإعلان عن متغير ( <em>var</em> أو <em>let</em> ) ، ولكن يمكننا استخدام السياق العام - التأثير الجانبي!  هنا الصراع لديه بالفعل بعض الفرص ليكون. </p><br><p style=";text-align:right;direction:rtl">  باستخدام <em>عامل الفاصلة ،</em> نقوم بربط تعبيرين في واحد: يتم تقييم المعاملات من اليسار إلى اليمين ، والنتيجة هي قيمة الأخير. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a))<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a);</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>54</strong> اجتياز الاختبارات </p><br><p style=";text-align:right;direction:rtl">  لذا ، من خلال إعادة ترتيب قوس واحد فقط ، تخلصنا من ثلاثة أحرف في وقت واحد.  سمح لنا <em>عامل التجميع</em> عند حساب المفتاح بدمج معاملي التعبير في تعبير واحد فقط ، وأزال قوس الإغلاق المسافة قبل <em>عامل التشغيل</em> . </p><br><p style=";text-align:right;direction:rtl">  وأخيرًا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>f[k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)]=k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f(...a);</code> </pre> <br><p style=";text-align:right;direction:rtl">  النتيجة: <strong>53</strong> اجتازت الاختبارات </p><br><p style=";text-align:right;direction:rtl">  لماذا لا تحسب المفتاح عند الوصول إلى القيمة.  وبعد ذلك - نفس العامل الثلاثي والمهمة.  المجموع: 53 حرفا! </p><br><p style=";text-align:right;direction:rtl">  هل من الممكن إزالة الأحرف الثلاثة المتبقية؟ </p><br><h3 id="osmyslenie" style=";text-align:right;direction:rtl">  الفهم </h3><br><p style=";text-align:right;direction:rtl">  لماذا كل هذا؟  توضح هذه المهمة البسيطة وسلسلة التحويلات اللاحقة من المعتاد إلى غير اللائق عددًا كبيرًا من ميزات لغة جافا سكريبت.  في مناقشاتنا ، تطرقنا إلى أشياء مثل: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تعبير دالة السهم </li><li style=";text-align:right;direction:rtl">  تحديد نطاق المعجم و IIFE </li><li style=";text-align:right;direction:rtl">  كائن الحجج الشبيهة بالصفيف </li><li style=";text-align:right;direction:rtl">  الانتشار أو الفاصلة أو عوامل التشغيل </li><li style=";text-align:right;direction:rtl">  عامل مقارنة صارم </li><li style=";text-align:right;direction:rtl">  JSON.stringify &amp; toString </li><li style=";text-align:right;direction:rtl">  في المشغل و hasOwnProperty </li><li style=";text-align:right;direction:rtl">  عامل تجميع وبيان كتلة </li><li style=";text-align:right;direction:rtl">  كائن الخريطة </li><li style=";text-align:right;direction:rtl">  وشيء آخر </li></ul><br><p style=";text-align:right;direction:rtl">  مثل هذه القصص هي سبب جيد للانغماس في دراسة تفاصيل اللغة ، والمساعدة على فهمها بشكل أفضل (أو العكس).  وبطبيعة الحال ، للمتعة فقط! </p><br><h3 id="prilozhenie" style=";text-align:right;direction:rtl">  التطبيق </h3><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/a8/n5/qp/a8n5qppehvlrsk6lmflpijrazjg.jpeg" alt="الصورة"></p><br><p style=";text-align:right;direction:rtl">  <em>في مغامراته ، غالبًا ما يضطر ريك إلى معايرة مدفع البوابة.</em>  <em>يستغرق الإجراء وقتًا ، ولكن غالبًا ما يتكرر الإدخال.</em>  <em>يحاول العالم حفظ النتائج التي تم الحصول عليها بالفعل مرة واحدة حتى لا يتم إجراء الحسابات بشكل متكرر ، ولكن إدمان الكحول وشيخوخة الشيخوخة يؤثر بشدة على ذاكرته.</em>  <em>طلب من Morty تحسين وحدة إعدادات البندقية ، مضيفًا وظيفة Memoizer.</em>  <em>يجب أن تحفظ هذه الوظيفة نتائج الوظيفة التي يتم تزيينها لمنع تكرار الحسابات.</em>  <em>مورتي هو الوحيد الذي يخشى من الوظائف الطويلة.</em>  <em>ساعده في حل المشكلة <strong>بأكبر قدر ممكن</strong> .</em>  <em>يمكن للدالة التي يتم تزيينها أن تأخذ أعدادًا صحيحة ، وسلاسل ، منطقية ، وكائنات كحجج.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar413303/">https://habr.com/ru/post/ar413303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar413287/index.html">DocumentFragment: ما هو وكيف (لا) محاربته</a></li>
<li><a href="../ar413289/index.html">أتمتة مراكز البيانات أو "تمرد الآلات"</a></li>
<li><a href="../ar413291/index.html">كتاب "التعلم العميق في بايثون"</a></li>
<li><a href="../ar413293/index.html">نزوح كبير من صناعة ألعاب الفيديو</a></li>
<li><a href="../ar413297/index.html">خطوط الويب المتغيرة</a></li>
<li><a href="../ar413305/index.html">البطاريات و Gigafactory و Northvolt و Siemens. الغرباء T</a></li>
<li><a href="../ar413307/index.html">اكتشف ESET مصرفي BackSwap باستخدام طريقة معالجة المتصفح الجديدة</a></li>
<li><a href="../ar413309/index.html">رشيق الجانب المظلم</a></li>
<li><a href="../ar413311/index.html">نقل تطبيق الويب الخاص بك من JavaScript خالص إلى Vue.js</a></li>
<li><a href="../ar413315/index.html">نظام المناخ في الشقة بيديك - الجزء 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>