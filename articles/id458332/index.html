<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕓 🙆🏿 🌎 Pemrograman asinkron - kinerja async: pahami biaya async dan tunggu 🐎 👨🏾 🔤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini cukup kuno, tetapi tidak kehilangan relevansinya. Ketika datang ke async / menunggu, tautan ke sana biasanya muncul. Saya tidak dapat mene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman asinkron - kinerja async: pahami biaya async dan tunggu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458332/"><p>  Artikel ini cukup kuno, tetapi tidak kehilangan relevansinya.  Ketika datang ke async / menunggu, tautan ke sana biasanya muncul.  Saya tidak dapat menemukan terjemahan ke dalam bahasa Rusia, saya memutuskan untuk membantu seseorang yang tidak lancar. </p><br><hr><br><p> Pemrograman asinkron telah lama menjadi kerajaan pengembang paling berpengalaman dengan keinginan masokisme - mereka yang memiliki cukup waktu luang, kecenderungan dan kemampuan psikis untuk memikirkan panggilan balik dari panggilan balik dalam aliran eksekusi non-linear.  Dengan munculnya Microsoft .NET Framework 4.5, C # dan Visual Basic membuat kita semua tidak sinkron, jadi manusia biasa sekarang dapat menulis metode asinkron hampir semudah yang sinkron.  Panggilan balik tidak lagi diperlukan.  Tidak ada lagi kode marshaling yang eksplisit dari satu konteks sinkronisasi ke yang lain.  Tidak ada lagi kekhawatiran tentang bagaimana hasil eksekusi atau pengecualian bergerak.  Tidak perlu trik yang mendistorsi sarana bahasa pemrograman untuk kenyamanan mengembangkan kode asinkron.  Singkatnya, tidak ada lagi masalah dan sakit kepala. </p><a name="habracut"></a><br><p>  Tentu saja, meskipun sekarang mudah untuk mulai menulis metode asinkron (lihat artikel oleh Eric Lippert dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mads Torgersen</a> di <em>Majalah MSDN</em> ini <em>[OKTOBER 2011]</em> ), diperlukan pemahaman untuk melakukan ini dengan benar. apa yang terjadi di bawah tenda.  Setiap kali bahasa atau pustaka meningkatkan tingkat abstraksi yang dapat digunakan pengembang, ini pasti disertai dengan biaya tersembunyi yang mengurangi produktivitas.  Dalam banyak kasus, biaya ini dapat diabaikan, sehingga mereka dapat diabaikan dalam kebanyakan kasus oleh sebagian besar programmer.  Namun, pengembang yang maju harus sepenuhnya memahami biaya apa yang ada untuk mengambil tindakan yang diperlukan dan menyelesaikan masalah yang mungkin terjadi jika mereka muncul dengan sendirinya.  Ini diperlukan saat menggunakan alat pemrograman asinkron dalam C # dan Visual Basic. </p><br><p>  Pada artikel ini, saya akan menjelaskan input dan output dari metode asinkron, menjelaskan bagaimana metode asinkron diterapkan, dan membahas beberapa biaya yang lebih kecil.  Perhatikan bahwa ini bukan rekomendasi untuk mengubah kode yang dapat dibaca menjadi sesuatu yang sulit dipertahankan, atas nama optimasi dan kinerja mikro.  Ini hanya pengetahuan yang akan membantu mendiagnosis masalah yang mungkin Anda temui, dan seperangkat alat untuk mengatasi masalah ini.  Selain itu, artikel ini didasarkan pada pratinjau .NET Framework versi 4.5, dan mungkin detail implementasi spesifik dapat berubah pada rilis final. </p><br><h4 id="poluchit-udobnuyu-model-myshleniya">  Dapatkan model berpikir yang nyaman </h4><br><p>  Selama beberapa dekade, programmer telah menggunakan bahasa pemrograman tingkat tinggi C #, Visual Basic, F # dan C ++ untuk mengembangkan aplikasi yang produktif.  Pengalaman ini memungkinkan programmer untuk mengevaluasi biaya berbagai operasi dan mendapatkan pengetahuan tentang teknik pengembangan terbaik.  Sebagai contoh, dalam kebanyakan kasus, memanggil metode sinkron relatif ekonomis, terutama jika kompiler dapat menanamkan isi metode dipanggil langsung ke titik panggilan.  Oleh karena itu, pengembang terbiasa memecah kode menjadi metode yang kecil dan mudah dirawat, tanpa harus khawatir tentang konsekuensi negatif dari peningkatan jumlah panggilan.  Model pemikiran programmer ini dirancang untuk menangani pemanggilan metode. </p><br><p>  Dengan munculnya metode asinkron, model pemikiran baru diperlukan.  C # dan Visual Basic dengan kompiler mereka dapat membuat ilusi bahwa metode asinkron berfungsi sebagai mitra sinkronnya, meskipun semuanya benar-benar salah di dalam.  Kompiler menghasilkan sejumlah besar kode untuk pemrogram, sangat mirip dengan template standar yang ditulis pengembang untuk mendukung asinkron selama waktu yang diperlukan untuk melakukannya dengan tangan.  Selain itu, kode yang dihasilkan oleh kompiler berisi panggilan ke fungsi pustaka dari .NET Framework, lebih lanjut mengurangi jumlah pekerjaan yang perlu dilakukan oleh seorang programmer.  Untuk memiliki model pemikiran yang tepat dan menggunakannya untuk membuat keputusan yang tepat, penting untuk memahami apa yang dihasilkan oleh kompiler untuk Anda. </p><br><h4 id="bolshe-razmer-metodov-menshe-vyzovov">  Lebih banyak metode, lebih sedikit panggilan </h4><br><p>  Saat bekerja dengan kode sinkron, menjalankan metode dengan konten kosong praktis tidak berharga.  Untuk metode asinkron, ini tidak terjadi.  Pertimbangkan metode asinkron ini, yang terdiri dari satu instruksi (dan yang, karena kurangnya pernyataan menunggu, akan dieksekusi secara serempak): </p><br><pre><code class="plaintext hljs">public static async Task SimpleBodyAsync() { Console.WriteLine("Hello, Async World!"); }</code> </pre> <br><p>  Decompiler bahasa perantara (IL) akan mengungkapkan isi sebenarnya dari fungsi ini setelah kompilasi, menghasilkan sesuatu yang mirip dengan Gambar 1. Apa yang merupakan one-liner sederhana diubah menjadi dua metode, salah satunya milik kelas tambahan dari mesin negara.  Yang pertama adalah metode rintisan yang memiliki tanda tangan yang mirip dengan yang ditulis oleh programmer (metode ini memiliki nama yang sama, cakupan yang sama, dibutuhkan parameter yang sama dan mengembalikan jenis yang sama), tetapi tidak mengandung kode yang ditulis oleh programmer.  Ini hanya berisi pelat standar untuk pengaturan awal.  Kode pengaturan awal menginisialisasi mesin negara yang diperlukan untuk mewakili metode asinkron, dan mulai menggunakan panggilan ke metode utilitas MoveNext.  Jenis objek mesin negara berisi variabel dengan status eksekusi metode asinkron, yang memungkinkan Anda untuk menyimpannya saat beralih antara titik-titik tunggu asinkron.  Ini juga berisi kode yang ditulis oleh seorang programmer, dimodifikasi untuk memastikan transfer hasil eksekusi dan pengecualian ke objek Tugas yang dikembalikan;  memegang posisi saat ini dalam metode sehingga eksekusi dapat dilanjutkan dari posisi ini setelah melanjutkan, dll. </p><br><p>  <strong>Gambar 1</strong> Templat Metode Asinkron </p><br><pre> <code class="plaintext hljs">[DebuggerStepThrough] public static Task SimpleBodyAsync() { &lt;SimpleBodyAsync&gt;d__0 d__ = new &lt;SimpleBodyAsync&gt;d__0(); d__.&lt;&gt;t__builder = AsyncTaskMethodBuilder.Create(); d__.MoveNext(); return d__.&lt;&gt;t__builder.Task; } [CompilerGenerated] [StructLayout(LayoutKind.Sequential)] private struct &lt;SimpleBodyAsync&gt;d__0 : &lt;&gt;t__IStateMachine { private int &lt;&gt;1__state; public AsyncTaskMethodBuilder &lt;&gt;t__builder; public Action &lt;&gt;t__MoveNextDelegate; public void MoveNext() { try { if (this.&lt;&gt;1__state == -1) return; Console.WriteLine("Hello, Async World!"); } catch (Exception e) { this.&lt;&gt;1__state = -1; this.&lt;&gt;t__builder.SetException(e); return; } this.&lt;&gt;1__state = -1; this.&lt;&gt;t__builder.SetResult(); } ... }</code> </pre> <br><p>  Ketika Anda bertanya-tanya berapa banyak biaya panggilan ke metode asinkron, ingat pola ini.  Blok coba / tangkap dalam metode MoveNext diperlukan untuk mencegah kemungkinan upaya untuk menanamkan metode ini oleh JIT oleh kompiler, jadi setidaknya kita mendapatkan biaya pemanggilan metode, sementara saat menggunakan metode sinkron, kemungkinan besar panggilan ini tidak akan (asalkan konten minimalis).  Kami akan menerima beberapa panggilan ke prosedur Framework (misalnya, SetResult).  Serta beberapa operasi tulis di bidang objek mesin negara.  Tentu saja, kita perlu membandingkan semua biaya ini dengan biaya Console.WriteLine, yang mungkin akan menang (mereka termasuk biaya penguncian, I / O, dll.) Perhatikan optimasi yang dibuat lingkungan untuk Anda.  Sebagai contoh, objek mesin negara diimplementasikan sebagai struct.  Struktur ini akan dikotak dalam tumpukan terkelola hanya jika metode perlu menjeda eksekusi, menunggu operasi selesai, dan ini tidak akan pernah terjadi dalam metode sederhana ini.  Jadi pola metode asinkron ini tidak akan membutuhkan alokasi memori dari heap.  Compiler dan runtime akan mencoba meminimalkan jumlah operasi alokasi memori. </p><br><h4 id="kogda-ne-nuzhno-ispolzovat-async">  Ketika tidak menggunakan Async </h4><br><p>  .NET Framework mencoba menghasilkan implementasi yang efisien untuk metode asinkron menggunakan berbagai metode optimisasi.  Namun demikian, pengembang, berdasarkan pengalaman mereka, sering menerapkan metode optimasi mereka, yang dapat berisiko dan tidak praktis untuk otomatisasi oleh kompiler dan runtime, ketika mereka mencoba menggunakan pendekatan universal.  Jika Anda tidak melupakan hal ini, penolakan untuk menggunakan metode async bermanfaat dalam sejumlah kasus tertentu, khususnya, ini berlaku untuk metode di perpustakaan yang dapat digunakan dengan pengaturan yang lebih baik.  Biasanya ini terjadi ketika diketahui dengan pasti bahwa metode ini dapat dijalankan secara serempak, karena data yang menjadi sandarannya sudah siap. </p><br><p>  Saat membuat metode asinkron, pengembang .NET Framework menghabiskan banyak waktu untuk mengoptimalkan jumlah operasi manajemen memori.  Ini diperlukan karena manajemen memori menimbulkan biaya terbesar dalam kinerja infrastruktur asinkron.  Operasi mengalokasikan memori untuk suatu objek biasanya relatif murah.  Mengalokasikan memori untuk objek mirip dengan mengisi keranjang dengan produk di supermarket - Anda tidak menghabiskan apa pun saat Anda memasukkannya ke dalam kereta.  Pengeluaran terjadi ketika Anda membayar di kasir, mengeluarkan dompet Anda dan memberikan uang yang layak.  Dan jika alokasi memori mudah, pengumpulan sampah selanjutnya dapat sangat memengaruhi kinerja aplikasi.  Saat Anda memulai pengumpulan sampah, pemindaian dan penandaan objek yang saat ini berada di memori tetapi tidak memiliki tautan dilakukan.  Semakin banyak objek ditempatkan, semakin lama waktu yang dibutuhkan untuk menandainya.  Selain itu, semakin besar jumlah benda berukuran besar yang ditempatkan, semakin sering pengumpulan sampah diperlukan.  Aspek bekerja dengan memori ini memiliki dampak global pada sistem: semakin banyak sampah yang dihasilkan oleh metode asinkron, semakin lambat aplikasi berjalan, bahkan jika mikrotest tidak menunjukkan biaya yang signifikan. </p><br><p>  Untuk metode asinkron yang menunda pelaksanaannya (menunggu data yang belum siap), lingkungan harus membuat objek bertipe Tugas, yang akan dikembalikan dari metode, karena objek ini berfungsi sebagai referensi unik untuk panggilan.  Namun, seringkali panggilan metode asinkron dapat dibuat tanpa penangguhan.  Kemudian runtime dapat kembali dari cache objek Tugas yang sebelumnya diselesaikan, yang digunakan lagi dan lagi tanpa perlu membuat objek Tugas baru.  Benar, ini hanya diperbolehkan dalam kondisi tertentu, misalnya, ketika metode asinkron mengembalikan objek non-universal (non-generik) Tugas, Tugas, atau ketika Tugas universal ditentukan oleh jenis referensi TResult, dan null dikembalikan dari metode.  Meskipun daftar kondisi ini berkembang dari waktu ke waktu, masih lebih baik jika Anda tahu bagaimana operasi dilaksanakan. <br></p><p>  Pertimbangkan implementasi jenis ini sebagai MemoryStream.  MemoryStream diwarisi dari Stream, dan mendefinisikan kembali metode baru yang diimplementasikan dalam .NET 4.5: ReadAsync, WriteAsync dan FlushAsync, untuk menyediakan optimasi kode spesifik memori.  Karena operasi baca dilakukan dari buffer yang terletak di memori, yaitu, sebenarnya itu adalah salinan dari area memori, kinerja terbaik adalah jika ReadAsync dijalankan dalam mode sinkron.  Implementasi ini dalam metode asinkron mungkin terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">public override async Task&lt;int&gt; ReadAsync(byte [] buffer, int offset, int count, CancellationToken cancellationToken) { cancellationToken.ThrowIfCancellationRequested(); return this.Read(buffer, offset, count); }</code> </pre> <br><p>  Cukup sederhana.  Dan karena Read adalah panggilan sinkron, dan metode ini tidak memiliki pernyataan menunggu untuk mengendalikan harapan, semua panggilan ke ReadAsync ini akan benar-benar dieksekusi secara sinkron.  Sekarang mari kita lihat kasus standar menggunakan utas, misalnya, operasi penyalinan: </p><br><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead); }</code> </pre> <br><p>  Harap perhatikan bahwa dalam contoh ReadAsync yang diberikan, aliran sumber selalu dipanggil dengan parameter panjang buffer yang sama, yang berarti sangat mungkin bahwa nilai pengembalian (jumlah byte yang dibaca) juga akan diulang.  Kecuali dalam beberapa keadaan yang jarang, penerapan ReadAsync tidak mungkin menggunakan objek Tugas yang di-cache sebagai nilai balik, tetapi Anda bisa melakukannya. </p><br><p>  Pertimbangkan opsi implementasi lain untuk metode ini, yang ditunjukkan pada Gambar 2. Menggunakan keunggulan dari aspek yang melekat dalam skrip standar untuk metode ini, kita dapat mengoptimalkan implementasi dengan mengecualikan operasi alokasi memori, yang tidak mungkin diharapkan dari runtime.  Kita dapat sepenuhnya menghilangkan kehilangan memori dengan mengembalikan objek Tugas yang sama yang digunakan dalam panggilan ReadAsync sebelumnya jika jumlah byte yang sama terbaca.  Dan untuk operasi tingkat rendah seperti itu, yang kemungkinan akan sangat cepat dan akan dipanggil berulang kali, optimasi ini akan memiliki efek yang signifikan, terutama dalam jumlah pengumpulan sampah. </p><br><p>  <strong>Gambar 2</strong> Optimasi pembuatan tugas </p><br><pre> <code class="plaintext hljs">private Task&lt;int&gt; m_lastTask; public override Task&lt;int&gt; ReadAsync(byte [] buffer, int offset, int count, CancellationToken cancellationToken) { if (cancellationToken.IsCancellationRequested) { var tcs = new TaskCompletionSource&lt;int&gt;(); tcs.SetCanceled(); return tcs.Task; } try { int numRead = this.Read(buffer, offset, count); return m_lastTask != null &amp;&amp; numRead == m_lastTask.Result ? m_lastTask : (m_lastTask = Task.FromResult(numRead)); } catch(Exception e) { var tcs = new TaskCompletionSource&lt;int&gt;(); tcs.SetException(e); return tcs.Task; } }</code> </pre> <br><p>  Metode pengoptimalan yang serupa dengan menghilangkan pembuatan objek Task yang tidak perlu dapat digunakan jika caching diperlukan.  Pertimbangkan metode yang dirancang untuk mengambil konten halaman web dan cache untuk referensi di masa mendatang.  Sebagai metode asinkron, ini dapat ditulis sebagai berikut (menggunakan perpustakaan System.Net.Http.dll baru untuk .NET 4.5): </p><br><pre> <code class="plaintext hljs">private static ConcurrentDictionary&lt;string,string&gt; s_urlToContents; public static async Task&lt;string&gt; GetContentsAsync(string url) { string contents; if (!s_urlToContents.TryGetValue(url, out contents)) { var response = await new HttpClient().GetAsync(url); contents = response.EnsureSuccessStatusCode().Content.ReadAsString(); s_urlToContents.TryAdd(url, contents); } return contents; }</code> </pre> <br><p>  Ini adalah implementasi dahi.  Dan untuk panggilan GetContentsAsync yang tidak menemukan data dalam cache, overhead pembuatan objek Tugas baru dapat diabaikan dibandingkan dengan biaya menerima data melalui jaringan.  Namun, dalam hal mendapatkan data dari cache, biaya ini menjadi signifikan jika Anda hanya membungkus dan memberikan data lokal yang tersedia. <br></p><p>  Untuk menghilangkan biaya ini (jika perlu untuk mencapai kinerja tinggi), Anda dapat menulis ulang metode seperti yang ditunjukkan pada Gambar 3. Sekarang kita memiliki dua metode: metode publik sinkron dan metode pribadi asinkron, yang didelegasikan oleh publik.  Koleksi Kamus sekarang menyimpan cache objek Tugas yang dibuat, bukan isinya, sehingga upaya di masa mendatang untuk mengambil konten halaman yang sebelumnya berhasil diperoleh dapat dilakukan dengan hanya mengakses koleksi untuk mengembalikan objek Tugas yang ada.  Di dalam, Anda dapat mengambil keuntungan dari menggunakan metode ContinueWith dari objek Task, yang memungkinkan kami untuk menyimpan objek yang dieksekusi dalam koleksi - dalam kasus pemuatan halaman berhasil.  Tentu saja, kode ini lebih kompleks dan membutuhkan banyak pengembangan dan dukungan, seperti biasa ketika mengoptimalkan kinerja: Anda tidak ingin menghabiskan waktu menulisnya sampai pengujian kinerja menunjukkan bahwa komplikasi ini mengarah pada peningkatannya, yang mengesankan dan jelas.  Perbaikan apa yang sebenarnya akan tergantung pada metode aplikasi.  Anda dapat mengambil test suite yang mensimulasikan kasus penggunaan umum dan mengevaluasi hasilnya untuk menentukan apakah game tersebut layak untuk ditiru. </p><br><p>  <strong>Gambar 3</strong> Tugas cache secara manual </p><br><pre> <code class="plaintext hljs">private static ConcurrentDictionary&lt;string,Task&lt;string&gt;&gt; s_urlToContents; public static Task&lt;string&gt; GetContentsAsync(string url) { Task&lt;string&gt; contents; if (!s_urlToContents.TryGetValue(url, out contents)) { contents = GetContentsInternalAsync(url); contents.ContinueWith(delegate { s_urlToContents.TryAdd(url, contents); }, CancellationToken.None, TaskContinuationOptions.OnlyOnRanToCompletion | TaskContinuatOptions.ExecuteSynchronously, TaskScheduler.Default); } return contents; } private static async Task&lt;string&gt; GetContentsInternalAsync(string url) { var response = await new HttpClient().GetAsync(url); return response.EnsureSuccessStatusCode().Content.ReadAsString(); }</code> </pre> <br><p>  Metode optimasi lain yang terkait dengan objek Tugas adalah untuk menentukan apakah akan mengembalikan objek seperti itu dari metode asinkron sama sekali.  Baik C # dan Visual Basic mendukung metode asinkron yang mengembalikan nilai nol (kosong), dan mereka tidak membuat objek Tugas sama sekali.  Metode asinkron di pustaka harus selalu mengembalikan Tugas dan Tugas, karena ketika mendesain pustaka Anda tidak bisa tahu bahwa mereka tidak akan digunakan menunggu penyelesaian.  Namun, ketika mengembangkan aplikasi, metode yang mengembalikan batal dapat menemukan tempatnya.  Alasan utama untuk keberadaan metode tersebut adalah untuk menyediakan lingkungan berbasis event yang ada, seperti ASP.NET dan Windows Presentation Foundation (WPF).  Menggunakan async dan menunggu, metode ini membuatnya mudah untuk mengimplementasikan penangan tombol, acara pemuatan halaman, dll.  Jika Anda bermaksud menggunakan metode asinkron dengan void, berhati-hatilah dengan menangani pengecualian: pengecualian dari itu akan muncul di setiap SynchronizationContext yang aktif pada saat metode dipanggil. <br></p><h4 id="ne-zabyvayte-o-kontekste">  Jangan lupakan konteksnya </h4><br><p>  Ada banyak konteks berbeda dalam .NET Framework: LogicalCallContext, SynchronizationContext, HostExecutionContext, SecurityContext, ExecutionContext, dan lainnya (jumlah raksasa mereka mungkin menyarankan bahwa pembuat Framework secara finansial termotivasi secara finansial untuk membuat konteks baru, tetapi saya tahu pasti tidak demikian).  Beberapa konteks ini sangat memengaruhi metode asinkron, tidak hanya dalam hal fungsionalitas, tetapi juga dalam kinerja. </p><br><p>  <strong>SynchronizationContext</strong> SynchronizationContext memainkan peran penting untuk metode asinkron.  "Konteks sinkronisasi" hanyalah abstraksi untuk memastikan bahwa permintaan delegasi dengan spesifikasi perpustakaan atau lingkungan tertentu dikerahkan.  Misalnya, WPF memiliki DispatcherSynchronizationContext untuk mewakili utas antarmuka pengguna (UI) untuk Dispatcher: mengirim delegasi ke konteks sinkronisasi ini menyebabkan delegasi ini harus antri untuk dieksekusi oleh Dispatcher di utasnya.  ASP.NET menyediakan AspNetSynchronizationContext yang digunakan untuk memastikan bahwa operasi asinkron yang terlibat dalam memproses permintaan ASP.NET dijamin akan dieksekusi secara berurutan dan terikat pada keadaan HttpContext yang benar.  Baik, dll  Secara umum, ada sekitar 10 spesialisasi SynchronizationContext di .NET Framework, beberapa terbuka, beberapa internal. </p><br><p>  Saat menunggu Tugas atau objek dari jenis lain yang .NET Framework dapat mengimplementasikannya, objek yang menunggu (misalnya, TaskAwaiter) menangkap Konteks Sinkronisasi saat ini pada saat penantian (tunggu) dimulai.  Setelah menunggu, jika SynchronizationContext ditangkap, kelanjutan metode asinkron dikirim ke konteks sinkronisasi ini.  Karena itu, pemrogram yang menulis metode asinkron yang dipanggil dari aliran UI tidak perlu secara manual memanggil kembali ke aliran UI untuk memperbarui kontrol UI: Kerangka melakukan marshaling ini secara otomatis. </p><br><p>  Sayangnya, marsaling ini ada harganya.  Untuk pengembang aplikasi yang menggunakan menunggu untuk menerapkan aliran kontrol mereka, marshaling otomatis adalah solusi yang tepat.  Perpustakaan sering memiliki cerita yang sangat berbeda.  Untuk pengembang aplikasi, marshaling ini terutama diperlukan untuk kode untuk mengontrol konteks di mana ia dijalankan, misalnya, untuk mengakses kontrol UI atau untuk mengakses HttpContext sesuai dengan permintaan ASP.NET yang diperlukan.  Namun, perpustakaan umumnya tidak diharuskan untuk memenuhi persyaratan seperti itu.  Akibatnya, marsaling otomatis seringkali membawa biaya tambahan yang sama sekali tidak perlu.  Mari kita lihat lagi kode yang menyalin data dari satu aliran ke yang lain: </p><br><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead); }</code> </pre> <br><p>  Jika salinan ini dipanggil dari aliran UI, setiap operasi baca dan tulis akan memaksa eksekusi untuk kembali ke aliran UI.  Dalam kasus megabyte data di sumber dan aliran yang membaca dan menulis secara tidak sinkron (yaitu, sebagian besar implementasinya), ini berarti sekitar 500 switch dari aliran latar belakang ke aliran UI.  Untuk menangani perilaku ini di jenis Tugas dan Tugas, metode ConfigureAwait dibuat.  Metode ini menerima parameter continueOnCapturedContext dari tipe boolean yang mengontrol marshaling.  Jika benar (default), tunggu secara otomatis mengembalikan kontrol ke Konteks Synchronization.  Jika salah digunakan, konteks sinkronisasi akan diabaikan, dan lingkungan akan terus menjalankan operasi asinkron di utas tempat terputus.  Menerapkan logika ini akan memberikan versi yang lebih efisien dari kode copy antar utas: <br></p><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length).ConfigureAwait(false)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead).ConfigureAwait(false); }</code> </pre> <br><p>  Untuk pengembang perpustakaan, akselerasi seperti itu sendiri sudah cukup untuk selalu berpikir tentang menggunakan ConfigureAwait, dengan pengecualian kondisi langka di mana perpustakaan cukup tahu tentang runtime dan perlu menjalankan metode dengan akses ke konteks yang benar. </p><br><p>  Selain kinerja, ada alasan lain bahwa Anda perlu menggunakan ConfigureAwait saat mengembangkan perpustakaan.  Bayangkan bahwa metode CopyStreamToStreamAsync, diimplementasikan dengan versi kode tanpa ConfigureAwait, dipanggil dari aliran UI di WPF, misalnya, seperti ini: </p><br><pre> <code class="plaintext hljs">private void button1_Click(object sender, EventArgs args) { Stream src = …, dst = …; Task t = CopyStreamToStreamAsync(src, dst); t.Wait(); // deadlock! }</code> </pre> <br><p>  Dalam hal ini, programmer harus menulis button1_Click sebagai metode asinkron di mana operator menunggu diharapkan untuk mengeksekusi Tugas, dan tidak menggunakan metode Tunggu sinkron objek ini.  Metode Tunggu perlu digunakan dalam banyak kasus lain, tetapi hampir selalu merupakan kesalahan untuk menggunakannya menunggu di aliran UI, seperti yang ditunjukkan di sini.  Metode Tunggu tidak akan kembali sampai Tugas selesai.  Dalam kasus CopyStreamToStreamAsync, aliran asinkronnya mencoba mengembalikan eksekusi dengan mengirim data ke Konteks Synchronization yang diambil, dan tidak dapat menyelesaikan sampai transfer tersebut selesai (karena mereka perlu melanjutkan operasinya).  Tetapi kiriman ini, pada gilirannya, tidak dapat dieksekusi, karena utas UI yang harus menanganinya diblokir oleh panggilan Tunggu.  Ini adalah ketergantungan siklus yang menyebabkan kebuntuan.  Jika CopyStreamToStreamAsync diimplementasikan dengan ConfigureAwait (false), tidak akan ada ketergantungan dan pemblokiran. </p><br><p>  <strong>ExecutionContext</strong> ExecutionContext adalah bagian penting dari .NET Framework, tetapi masih sebagian besar programmer tidak menyadari keberadaannya. ExecutionContext –  ,        SecurityContext  LogicalCallContext,   ,         .  ,    ThreadPool.QueueUserWorkItem, Task.Run, Delegate.BeginInvoke, Stream.BeginRead, WebClient.DownloadStringAsync      Framework,    ExecutionContext   ExecutionContext.Run ( ). ,  ,  ThreadPool.QueueUserWorkItem,  Windows  (identity),           WaitCallback.   ,   Task.Run    LogicalCallContext,         LogicalCallContext    Action. ExecutionContext     . </p><br><p>  Framework    ,          ExecutionContext,     ,      .     Windows      LogicalCallContext     .     (WindowsIdentity.Impersonate  CallContext.LogicalSetData)               . </p><br><h4 id="osvobodites-ot-sborki-musora">     </h4><br><p>        .    C#  Visual Basic     ,        .          await.  ,      ,    -   .   C#  Visual Basic  («»)      ,     await  (boxed)  ,     . </p><br><p>                  .   ,     . ,       ,     ,     . </p><br><p>       C#  Visual Basic      ,      . ,     </p><br><pre> <code class="plaintext hljs">public static async Task FooAsync() { var dto = DateTimeOffset.Now; var dt = dto.DateTime; await Task.Yield(); Console.WriteLine(dt); }</code> </pre> <br><p>    dto      await,     .    ,  , -    dto: </p><br><p> <strong>Figure 4</strong>    </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Sequential), CompilerGenerated] private struct &lt;FooAsync&gt;d__0 : &lt;&gt;t__IStateMachine { private int &lt;&gt;1__state; public AsyncTaskMethodBuilder &lt;&gt;t__builder; public Action &lt;&gt;t__MoveNextDelegate; public DateTimeOffset &lt;dto&gt;5__1; public DateTime &lt;dt&gt;5__2; private object &lt;&gt;t__stack; private object &lt;&gt;t__awaiter; public void MoveNext(); [DebuggerHidden] public void &lt;&gt;t__SetMoveNextDelegate(Action param0); }</code> </pre> <br><p>         ,     .   ,     ,  , ,        .       ,        : </p><br><pre> <code class="plaintext hljs">public static async Task FooAsync() { var dt = DateTimeOffset.Now.DateTime; await Task.Yield(); Console.WriteLine(dt); }</code> </pre> <br><p>  ,   .NET (GC)    ,  ,      ,  :      0,  ,    ,     (.NET GC    0, 1  2).      ,    GC        .     ,  ,   ,    ,     ,     ,   .     0,   ,    ,   .   ,     ,         ,    . </p><br><p>                (        ,       ).    JIT   ,        ,               ,        ,      .          ,    ,        .   ,      ,  ,     ,     .   ,          ,     .  ,  C#  Visual Basic        ,       ,     . </p><br><h4 id="izbegayte-slozhnosti">   </h4><br><p>  C#  Visual Basic  ,       awaits:  .   await      ,     Task  ,       ,  . ,   ,      : <br></p><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { return Sum(await a, await b, await c); } private static int Sum(int a, int b, int c) { return a + b + c; }</code> </pre> <br><p>  C#     “await b”    Sum.      await,       Sum,  -       async ,   «»     await.    ,       await       .   ,  ,       CLR,    ,      ,       .         ,                 &lt;&gt;t__stack.         ,   ,   Tuple&lt;int, int&gt;             &lt;&gt;__stack.  ,     ,    ,          . ,    SumAsync : </p><br><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { int ra = await a; int rb = await b; int rc = await c; return Sum(ra, rb, rc); }</code> </pre> <br><p>            ,   ra, rb  rc,    .  ,    :                   .          ,           ,        ,    .  ,           ,    ,       ,          . </p><br><p> ,        ,        .      Sum   ,    await   ,       .     ,    await   ,  .      await  ,      Task.WhenAll: </p><br><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { int [] results = await Task.WhenAll(a, b, c); return Sum(results[0], results[1], results[2]); }</code> </pre> <br><p>  Task.WhenAll  Task&lt;TResult[]&gt;,    ,       ,     ,       .           .     ,         WhenAll,    Task  Task.        ,          ,    ,   ,   ,    WhenAll ,    .         WhenAll,     , ,   params,       .    ,  ,         .   Figure 5 <br></p><p> <strong>Figure 5</strong>     </p><br><pre> <code class="plaintext hljs">public static Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { return (a.Status == TaskStatus.RanToCompletion &amp;&amp; b.Status == TaskStatus.RanToCompletion &amp;&amp; c.Status == TaskStatus.RanToCompletion) ? Task.FromResult(Sum(a.Result, b.Result, c.Result)) : SumAsyncInternal(a, b, c); } private static async Task&lt;int&gt; SumAsyncInternal(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { await Task.WhenAll((Task)a, b, c).ConfigureAwait(false); return Sum(a.Result, b.Result, c.Result); }</code> </pre> <br><h4 id="asinhronnost-i-proizvoditelnost">    </h4><br><p>      ,           .  ,         .            ,            . ,      ,     :      ,      ,      /          ,       .     .NET Framework              ,       .   ,       .NET Framework,     .  ,  ,       Framework,   ,     ,  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458332/">https://habr.com/ru/post/id458332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458312/index.html">Akademi Android di Moskow: Kursus Lanjutan</a></li>
<li><a href="../id458316/index.html">Yandex Retro Games Battle 2019 - mengembangkan game untuk ZX Spectrum</a></li>
<li><a href="../id458324/index.html">Semua yang Anda butuhkan untuk memulai dengan Vue.js</a></li>
<li><a href="../id458328/index.html">Cara menduplikasi tujuan dari Yandex.Metrica di Google Analytics</a></li>
<li><a href="../id458330/index.html">Tidak ada batasan untuk kesempurnaan: bagaimana antarmuka saraf membantu manusia</a></li>
<li><a href="../id458334/index.html">Replikasi berkelanjutan dari PostgreSQL Lama ke Baru dengan Slony</a></li>
<li><a href="../id458336/index.html">Siklus penuh pengembangan produk TI menggunakan contoh proyek: peran tim, tugas pelanggan, tahapan</a></li>
<li><a href="../id458338/index.html">Manajer Keamanan Aplikasi. Pengembang atau keamanan?</a></li>
<li><a href="../id458342/index.html">Tekstur, atau apa yang perlu Anda ketahui untuk menjadi Artis Permukaan. Bagian 1. Pixel</a></li>
<li><a href="../id458344/index.html">Menggunakan Pesan Asinkron untuk Meningkatkan Ketersediaan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>