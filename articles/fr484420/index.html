<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèæ üí• ü§úüèº Changements dans l'antichita BattlEye populaire et moyens de les contourner üë©üèø‚Äçüè´ üë®üèæ‚Äçüéì ‚ÜïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mises √† jour majeures du code shell BattlEye 
 Le temps passe, les anti-cheats changent, et pour augmenter l'efficacit√© du produit, des fonctions y ap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Changements dans l'antichita BattlEye populaire et moyens de les contourner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484420/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/c7/fe/zdc7ferp6hnuf19n_aid_mh4tca.png"></div><br><h2>  Mises √† jour majeures du code shell BattlEye </h2><br>  Le temps passe, les anti-cheats changent, et pour augmenter l'efficacit√© du produit, des fonctions y apparaissent et disparaissent.  Il y a un an, j'ai pr√©par√© une description d√©taill√©e du shellcode BattlEye dans mon <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">blog</a> , et cette partie de l'article sera un simple reflet des changements apport√©s au shellcode. <br><br><h2>  Horodatages sur liste noire </h2><br>  Dans une r√©cente analyse de BattlEye, il n'y avait que deux horodatages de compilation dans la liste des interdictions fant√¥mes, et il semble que les d√©veloppeurs aient d√©cid√© d'en ajouter beaucoup plus: <br><br> <code>0x5B12C900 (action_x64.dll) <br> 0x5A180C35 (TerSafe.dll, Epic Games) <br> 0xFC9B9325 (?) <br> 0x456CED13 (d3dx9_32.dll) <br> 0x46495AD9 (d3dx9_34.dll) <br> 0x47CDEE2B (d3dx9_32.dll) <br> 0x469FF22E (d3dx9_35.dll) <br> 0x48EC3AD7 (D3DCompiler_40.dll) <br> 0x5A8E6020 (?) <br> 0x55C85371 (d3dx9_32.dll) <br> 0x456CED13 (?) <br> 0x46495AD9 (D3DCompiler_40.dll) <br> 0x47CDEE2B (D3DX9_37.dll) <br> 0x469FF22E (?) <br> 0x48EC3AD7 (?) <br> 0xFC9B9325 (?) <br> 0x5A8E6020 (?) <br> 0x55C85371 (?)</code> <br> <br>  Je n'ai pas pu identifier les horodatages restants, et les deux <b>0xF *******</b> sont les hachages cr√©√©s par les assemblys d√©terministes Visual Studio.  Merci √† @mottikraus et T0B1 d'avoir identifi√© des horodatages. <br><a name="habracut"></a><br><h2>  V√©rifications des modules </h2><br>  Comme l'analyse principale l'a montr√©, la caract√©ristique cl√© de BattlEye est l'√©num√©ration des modules, et √† partir du moment de la derni√®re analyse, un autre module a √©t√© ajout√© √† la liste: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::misc::module_unknown1() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetProcAddress(current_module, <span class="hljs-string"><span class="hljs-string">"NSPStartup"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0x1B20</span></span> || optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0xE70</span></span> || optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0x1A38</span></span> || timestamp &gt;= <span class="hljs-number"><span class="hljs-number">0x5C600000</span></span> &amp;&amp; timestamp &lt; <span class="hljs-number"><span class="hljs-number">0x5C700000</span></span>) { report_module_unknown report = {}; report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span>; report.report_id = <span class="hljs-number"><span class="hljs-number">0x35</span></span>; report.val1 = <span class="hljs-number"><span class="hljs-number">0x5C0</span></span>; report.timestamp = timestamp; report.image_size = optional_header.size_of_image; report.entrypoint = optional_header.address_of_entry_point; report.directory_size = optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size; battleye::report(&amp;report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(report), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br>  Il s'agit probablement de la d√©tection de certaines DLL de proxy, car la taille de la table de redirection est v√©rifi√©e ici. <br><br><h2>  Titres de fen√™tres </h2><br>  Dans l'analyse pr√©c√©dente, divers fournisseurs de triche ont √©t√© marqu√©s avec des noms de fen√™tre, mais depuis lors, le shellcode a cess√© de v√©rifier ces en-t√™tes de fen√™tre.  La liste des titres des fen√™tres a √©t√© compl√®tement remplac√©e par: <br><br> <code>Chod's <br> Satan5</code> <br> <br><h2>  Noms des images </h2><br>  BattlEye est connu pour utiliser des m√©thodes de d√©tection tr√®s primitives, et l'une d'entre elles est une liste noire de noms d'images.  Chaque ann√©e, la liste des noms d'images interdits s'allonge, et au cours des 11 derniers mois, cinq nouveaux ont √©t√© ajout√©s: <br><br> <code>frAQBc8W.dll <br> C:\\Windows\\mscorlib.ni.dll <br> DxtoryMM_x64.dll <br> Project1.dll <br> OWClient.dll <br></code> <br>  Il est √† noter que la pr√©sence d'un module avec un nom correspondant √† l'un des √©l√©ments de la liste ne signifie pas que vous serez imm√©diatement banni.  Le moteur de g√©n√©ration de rapports transmet √©galement des informations de module de base, qui sont tr√®s probablement utilis√©es pour distinguer les tricheurs des collisions sur le serveur BattlEye. <br><br><h2>  7 zips </h2><br>  7-Zip a √©t√© largement utilis√© et continue d'√™tre utilis√© par les participants √† la sc√®ne de triche comme remplissage de m√©moire pour les vides de code (codes-caves).  BattlEye essaie de r√©soudre ce probl√®me en effectuant un <b>tr√®s</b> mauvais contr√¥le d'int√©grit√©, qui a chang√© depuis mon article pr√©c√©dent: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_7zip() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"..\\..\\Plugins\\ZipUtility\\ThirdParty\\7zpp\\dll\\Win64\\7z.dll"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// --- REMOVED --- // if (module_handle &amp;&amp; *(int*)(module_handle + 0x1000) != 0xFF1441C7) // --- ADDED --- if (module_handle &amp;&amp; *(int*)(module_handle + 0x1008) != 0x83485348) { sevenzip_report.unknown_1 = 0; sevenzip_report.report_id = 0x46; sevenzip_report.unknown_2 = 0; sevenzip_report.data1 = *(__int64*)(module_handle + 0x1000; sevenzip_report.data2 = *(__int64*)(module_handle + 0x1008; battleye::report(&amp;sevenzip_report, sizeof(sevenzip_report), false); } }</span></span></code> </pre> <br>  Il semble que les d√©veloppeurs de BattlEye aient devin√© que mon article pr√©c√©dent a conduit de nombreux utilisateurs √† contourner cette v√©rification en copiant simplement les octets souhait√©s √† l'emplacement v√©rifi√© par BattlEye.  Comment ont-ils r√©gl√© la situation?  Nous avons d√©cal√© la v√©rification de huit octets et avons continu√© √† utiliser la m√™me mauvaise m√©thode de v√©rification de l'int√©grit√©.  La partition ex√©cutable en lecture seule, et tout ce que vous avez √† faire est de t√©l√©charger 7-Zip √† partir du disque et de comparer les partitions d√©plac√©es entre elles;  s'il y a des √©carts, alors quelque chose ne va pas.  S√©rieusement, les gars, effectuer des v√©rifications d'int√©grit√© n'est pas si difficile. <br><br><h2>  V√©rification du r√©seau </h2><br>  √ânum√©rer la table TCP fonctionne toujours, mais apr√®s avoir publi√© une analyse pr√©c√©dente qui a critiqu√© les d√©veloppeurs pour avoir signal√© les adresses IP Cloudflare, ils ont toujours supprim√© cette v√©rification.  Anti-cheat rapporte toujours le port que xera.ph utilise pour la connexion, mais les d√©veloppeurs ont ajout√© une nouvelle v√©rification pour d√©terminer si le processus avec la connexion a une protection active (probablement cela se fait en utilisant le gestionnaire). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> network::scan_tcp_table { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(local_port_buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(local_port_buffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (iteration_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; iteration_index; &lt; <span class="hljs-number"><span class="hljs-number">500</span></span> ++iteration_index) { <span class="hljs-comment"><span class="hljs-comment">// GET NECESSARY SIZE OF TCP TABLE auto table_size = 0; GetExtendedTcpTable(0, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0); // ALLOCATE BUFFER OF PROPER SIZE FOR TCP TABLE auto allocated_ip_table = (MIB_TCPTABLE_OWNER_MODULE*)malloc(table_size); if (GetExtendedTcpTable(allocated_ip_table, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0) != NO_ERROR) goto cleanup; for (entry_index = 0; entry_index &lt; allocated_ip_table-&gt;dwNumEntries; ++entry_index) { // --- REMOVED --- // const auto ip_address_match_1 = // allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656B1468; // 104.20.107.101 // // const auto ip_address_match_2 = // allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656C1468; // 104.20.108.101 // +++ ADDED +++ const auto target_process = OpenProcess(QueryLimitedInformation, 0, ip_table-&gt;table[entry_index].dwOwningPid); const auto protected = target_process == INVALID_HANDLE &amp;&amp; GetLastError() == 0x57; if (!protected) { CloseHandle(target_process); return; } const auto port_match = allocated_ip_table-&gt;table[entry_index].dwRemotePort == 20480; for (port_index = 0; port_index &lt; 10 &amp;&amp; allocated_ip_table-&gt;table[entry_index].dwLocalPort != local_port_buffer[port_index]; ++port_index) { if (local_port_buffer[port_index]) continue tcp_table_report.unknown = 0; tcp_table_report.report_id = 0x48; tcp_table_report.module_id = 0x5B9; tcp_table_report.data = BYTE1(allocated_ip_table-&gt;table[entry_index].dwLocalPort) | (LOBYTE(allocated_ip_table-&gt;table[entry_index.dwLocalPort) &lt;&lt; 8; battleye::report(&amp;tcp_table_report, sizeof(tcp_table_report), false); local_port_buffer[port_index] = allocated_ip_table-&gt;table[entry_index].dwLocalPort; break } } cleanup: // FREE TABLE AND SLEEP free(allocated_ip_table); Sleep(10 } }</span></span></code> </pre> <br>  Merci IChooseYou et r√©sum√© <br><br><h2>  BattlEye Stack Bypass </h2><br>  Les jeux de piratage sont un jeu constant de chat et de souris, donc les rumeurs de nouveaux tours se propagent comme un feu.  Dans cette partie, nous examinerons les nouvelles techniques heuristiques qui ont √©t√© r√©cemment ajout√©es √† notre arsenal par un grand fournisseur d'anti-triche BattlEye.  Le plus souvent, ces techniques sont appel√©es marche en pile.  Habituellement, ils sont impl√©ment√©s en traitant une fonction et en parcourant la pile pour savoir qui a sp√©cifiquement appel√© cette fonction.  Pourquoi avez-vous besoin de faire √ßa?  Comme tout autre programme, les hacks de jeux vid√©o ont un ensemble de fonctions bien connues qu'ils utilisent pour obtenir des informations √† partir du clavier, les afficher sur la console ou calculer certaines expressions math√©matiques.  De plus, les hacks de jeux vid√©o adorent cacher leur existence, que ce soit en m√©moire ou sur disque, afin que les logiciels anti-triche ne les trouvent pas.  Mais ce que les programmes de triche oublient, c'est qu'ils appellent r√©guli√®rement des fonctions d'autres biblioth√®ques, et cela peut √™tre utilis√© pour d√©tecter heuristiquement des tricheurs inconnus.  En impl√©mentant le moteur de travers√©e de pile pour des fonctions telles que <code>std::print</code> , nous pouvons trouver ces tricheurs m√™me s'ils sont masqu√©s. <br><br>  BattlEye a <strong>mis en place un</strong> ¬´contournement de pile¬ª, malgr√© le fait que cela n'a pas √©t√© annonc√© publiquement et au moment de la publication de l'article, il n'y avait que des rumeurs.  Faites attention aux guillemets - ce que vous verrez ici n'est pas vraiment un vrai tour de pile, mais juste une combinaison de v√©rification de l'adresse de retour et du vidage du programme appelant.  Une v√©ritable impl√©mentation de travers√©e de pile traverserait la pile et g√©n√©rerait une vraie pile d'appels. <br><br>  Comme je l'ai expliqu√© dans un article pr√©c√©dent sur BattlEye, le syst√®me anti-triche diffuse dynamiquement le shellcode dans le jeu lorsqu'il est en cours d'ex√©cution.  Ces codes shell ont des tailles et des t√¢ches diff√©rentes et ne sont pas transmis simultan√©ment.  Une propri√©t√© remarquable d'un tel syst√®me est que les chercheurs doivent analyser dynamiquement l'anti-triche pendant le match multijoueur, ce qui complique la d√©termination des caract√©ristiques de cet anti-triche.  Il permet √©galement √† l'anti-triche d'appliquer diverses mesures √† diff√©rents utilisateurs, par exemple, pour transf√©rer un module plus profond√©ment invasif uniquement √† une personne qui a un taux inhabituellement √©lev√© de meurtres et de d√©c√®s, etc. <br><br>  L'un de ces codes shell, BattlEye, est charg√© d'effectuer cette analyse de pile;  nous l'appellerons <em>shellcode8kb</em> car il est l√©g√®rement plus petit que <em>shellcodemain</em> , que j'ai document√© <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">ici</a> .  Ce petit code shell utilisant la fonction <strong>AddVectoredExceptionHandler</strong> pr√©pare un gestionnaire d'exceptions vectoris√©, puis d√©finit des interruptions d'interruption sur les fonctions suivantes: <br><br> <code>GetAsyncKeyState <br> GetCursorPos <br> IsBadReadPtr <br> NtUserGetAsyncKeyState <br> GetForegroundWindow <br> CallWindowProcW <br> NtUserPeekMessage <br> NtSetEvent <br> sqrtf <br> __stdio_common_vsprintf_s <br> CDXGIFactory::TakeLock <br> TppTimerpExecuteCallback</code> <br> <br>  Pour ce faire, il parcourt simplement la liste des fonctions standard, en d√©finissant la premi√®re instruction de la fonction correspondante sur <strong>int3</strong> , qui est utilis√©e comme point d'arr√™t.  Apr√®s avoir d√©fini un point d'arr√™t, tous les appels √† la fonction correspondante passent par le gestionnaire d'exceptions, qui a un acc√®s complet aux registres et √† la pile.  Ayant cet acc√®s, le gestionnaire d'exceptions vide l'adresse du programme appelant depuis le haut de la pile, et si l'une des conditions heuristiques est remplie, 32 octets de la fonction appelante sont vid√©s et envoy√©s au serveur BattlEye avec l'identifiant de rapport <strong>0x31</strong> : <br><br><pre> <code class="cpp hljs">__int64 battleye::exception_handler(_EXCEPTION_POINTERS *exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exception-&gt;ExceptionRecord-&gt;ExceptionCode != STATUS_BREAKPOINT) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> caller_function = *(__int64 **)exception-&gt;ContextRecord-&gt;Rsp; MEMORY_BASIC_INFORMATION caller_memory_information = {}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> desired_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// QUERY THE MEMORY PAGE OF THE CALLER const auto call_failed = NtQueryVirtualMemory( GetCurrentProcess(), caller_function, MemoryBasicInformation, &amp;caller_memory_information, sizeof(caller_memory_information), &amp;desired_size) &lt; 0; // IS THE MEMORY SOMEHOW NOT COMMITTED? (WOULD SUGGEST VAD MANIPULATIUON) const auto non_commit = caller_memory_information.State != MEM_COMMIT; // IS THE PAGE EXECUTABLE BUT DOES NOT BELONG TO A PROPERLY LOADED MODULE? const auto foreign_image = caller_memory_information.Type != MEM_IMAGE &amp;&amp; caller_memory_information.RegionSize &gt; 0x2000; // IS THE CALL BEING SPOOFED BY NAMAZSO? const auto spoof = *(_WORD *)caller_function == 0x23FF; // jmp qword ptr [rbx] // FLAG ALL ANBORMALITIES if (call_failed || non_commit || foreign_image || spoof) { report_stack.unknown = 0; report_stack.report_id = 0x31; report_stack.hook_id = hook_id; report_stack.caller = (__int64)caller_function; report_stack.function_dump[0] = *caller_function; report_stack.function_dump[1] = caller_function[1]; report_stack.function_dump[2] = caller_function[2]; report_stack.function_dump[3] = caller_function[3]; if (!call_failed) { report_stack.allocation_base = caller_memory_information.AllocationBase; report_stack.base_address = caller_memory_information.BaseAddress; report_stack.region_size = caller_memory_information.RegionSize; report_stack.type_protect_state = caller_memory_information.Type | caller_memory_information.Protect | caller_memory_information.State; } battleye::report(&amp;report_stack, sizeof(report_stack), false); return -1; } }</span></span></code> </pre> <br>  Comme nous pouvons le voir, le gestionnaire d'exceptions vide toutes les fonctions appelantes en cas de changement non c√©r√©monieux dans la page m√©moire ou lorsque la fonction n'appartient pas √† un module de processus connu (le type de page m√©moire MEM_IMAGE n'a pas √©t√© d√©fini par les mappeurs manuels).  Il d√©charge √©galement les fonctions d'appel lorsqu'il ne parvient pas √† appeler <strong>NtQueryVirtualMemory</strong> afin que les tricheurs ne se lient pas √† cet appel syst√®me et masquent leur module du vidage de la pile.  La derni√®re condition est en fait assez int√©ressante, elle marque toutes les fonctions d'appel qui utilisent le <strong>gadget jmp qword ptr [rbx]</strong> - la m√©thode utilis√©e pour "usurper l'adresse de retour".  Il a √©t√© <a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/268039-x64-return-address-spoofing-source-explanation.html">publi√© par</a> mon surnom de membre co-secr√©taire namazso.  Il semble que les d√©veloppeurs de BattlEye ont vu que les gens utilisent cette m√©thode d'usurpation d'identit√© dans leurs jeux et ont d√©cid√© de viser directement.  Il convient de mentionner ici que la m√©thode d√©crite par namazsos fonctionne bien, utilisez simplement un gadget diff√©rent, ou compl√®tement diff√©rent, ou simplement un registre diff√©rent - cela n'a pas d'importance. <br><br>  Conseil du d√©veloppeur BattlEye: Le <code>CDXGIFactory::TakeLock</code> dans votre m√©moire est incorrect car vous avez (accidentellement ou intentionnellement) activ√© le remplissage CC, qui est tr√®s diff√©rent √† chaque compilation.  Pour une compatibilit√© maximale, vous devez supprimer le rembourrage (le premier octet de la signature) et vous aurez donc probablement plus de tricheurs :) <br><br>  La structure compl√®te envoy√©e au serveur BattlEye ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unaligned</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">battleye_stack_report</span></span></span><span class="hljs-class"> {</span></span> __int8 unknown; __int8 report_id; __int8 val0; __int64 caller; __int64 function_dump[<span class="hljs-number"><span class="hljs-number">4</span></span>]; __int64 allocation_base; __int64 base_address; __int32 region_size; __int32 type_protect_state; };</code> </pre> <br><h2>  Reconnaissance de l'hyperviseur dans BattlEye </h2><br>  Le jeu du chat et de la souris dans le domaine des jeux de piratage continue d'√™tre une source d'innovation dans les exploits et la lutte contre les tricheurs.  L'utilisation de la technologie de virtualisation dans les jeux de piratage a commenc√© √† se d√©velopper activement apr√®s l'av√®nement d'hyperviseurs aussi faciles √† utiliser que <a href="https://github.com/tandasat/DdiMon">DdiMon</a> Satoshi Tanda et <a href="https://github.com/wbenny/hvpp">hvpp</a> Peter Benes.  Ces deux projets sont utilis√©s par la plupart des tricheurs r√©mun√©r√©s de la sc√®ne des hackers souterrains en raison du seuil d'entr√©e bas et de la documentation d√©taill√©e.  Ces versions devraient acc√©l√©rer la course aux armements dans le domaine des hyperviseurs, qui commence maintenant √† se manifester dans la communaut√© des hackers de jeux.  Voici ce que l'administrateur de l'une des plus grandes communaut√©s de piratage de jeux avec le surnom <a href="https://www.unknowncheats.me/">wlan</a> dit √† propos de cette situation: <br><br><blockquote>  Avec l'av√®nement des syst√®mes d'hyperviseur pr√™ts √† l'emploi pour les jeux de piratage, il est devenu in√©vitable que les anti-tricheurs comme BattlEye se concentrent sur la reconnaissance g√©n√©ralis√©e de la virtualisation. </blockquote><br>  L'utilisation r√©pandue d'hyperviseurs est due aux r√©centes am√©liorations de l'anti-triche, qui ont laiss√© aux pirates tr√®s peu d'opportunit√©s de modifier les jeux de mani√®re traditionnelle.  La popularit√© des hyperviseurs peut s'expliquer par la simplicit√© d'√©viter l'anti-triche, car la virtualisation simplifie le masquage des informations √† l'aide de m√©canismes tels que les <a href="https://revers.engineering/syscall-hooking-via-extended-feature-enable-register-efer/">hooks d'appel syst√®me</a> et la <a href="https://www.anandtech.com/show/2480/10">virtualisation MMU</a> . <br><br>  R√©cemment, BattlEye a impl√©ment√© la reconnaissance des hyperviseurs courants comme les plates-formes mentionn√©es ci-dessus (DdiMon, hvpp) en utilisant la d√©tection bas√©e sur le temps.  Cette reconnaissance tente de d√©tecter des valeurs de temps d'instruction CPUID non standard.  CPUID est une instruction relativement peu co√ªteuse sur un √©quipement r√©el, ne n√©cessitant g√©n√©ralement que deux cents cycles, et dans un environnement virtuel, son ex√©cution peut prendre dix fois plus longtemps en raison d'op√©rations inutiles caus√©es par le moteur d'introspection.  Le moteur d'introspection est diff√©rent d'un √©quipement r√©el, qui effectue simplement l'op√©ration de la mani√®re attendue, car sur la base d'un crit√®re arbitraire, il suit et modifie conditionnellement les donn√©es renvoy√©es √† l'invit√©. <br><br>  <strong>Fait amusant:</strong> CPUID est activement utilis√© dans ces proc√©dures de reconnaissance temporaire car il s'agit d'une instruction avec une sortie inconditionnelle, ainsi que d'une instruction avec une s√©rialisation non privil√©gi√©e.  Cela signifie que le CPUID est utilis√© comme une <a href="https://en.wikipedia.org/wiki/Memory_barrier">barri√®re</a> et garantit le respect des instructions avant et apr√®s;  en m√™me temps, les horaires deviennent ind√©pendants de la r√©organisation habituelle des instructions.  Vous pouvez √©galement utiliser des instructions telles que <a href="https://www.felixcloutier.com/x86/xsetbv">XSETBV</a> , qui effectuent √©galement une sortie inconditionnelle, mais pour garantir une synchronisation ind√©pendante, cela n√©cessitera une sorte d'instruction de barri√®re afin qu'aucune r√©organisation ne se produise avant ou apr√®s, ce qui affecte la fiabilit√© des temporisations. <br><br><h4>  La reconnaissance </h4><br>  Voici la proc√©dure de reconnaissance du module BattlEye ¬´BEClient2¬ª;  J'ai effectu√© sa r√©tro-ing√©nierie et recr√©√© le code en pseudo-C, puis je l'ai post√© sur <a href="https://twitter.com/vm_call">Twitter</a> .  Le lendemain de mon tweet, les d√©veloppeurs de BattlEye ont chang√© de fa√ßon inattendue l'obscurcissement de BEClient2, esp√©rant apparemment que cela m'emp√™cherait d'analyser le module.  L'obfuscation pr√©c√©dente n'a pas chang√© depuis plus d'un an, mais a chang√© le lendemain de mon tweet √† ce sujet - une vitesse impressionnante. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::take_time() { <span class="hljs-comment"><span class="hljs-comment">// SET THREAD PRIORITY TO THE HIGHEST const auto old_priority = SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL); // CALCULATE CYCLES FOR 1000MS const auto timestamp_calibrator = __rdtsc(); Sleep(1000); const auto timestamp_calibration = __rdtsc() - timestamp_calibrator; // TIME CPUID auto total_time = 0; for (std::size_t count = 0; count &lt; 0x6694; count++) { // SAVE PRE CPUID TIME const auto timestamp_pre = __rdtsc(); std::uint32_t cpuid_data[4] = {}; __cpuid(cpuid_data, 0); // SAVE THE DELTA total_time += __rdtsc() - timestamp_pre; } // SAVE THE RESULT IN THE GLOBAL REPORT TABLE battleye::report_table[0x1A8] = 10000000 * total_time / timestamp_calibration / 0x65; // RESTORE THREAD PRIORITY SetThreadPriority(GetCurrentThread(), old_priority); }</span></span></code> </pre> <br>  Comme je l'ai dit ci-dessus, c'est la technique de reconnaissance la plus courante utilisant des instructions intercept√©es inconditionnellement.  Cependant, il est vuln√©rable au faux temps, et nous en parlerons en d√©tail dans la section suivante. <br><br><h4>  Contournement de reconnaissance </h4><br>  Cette m√©thode de reconnaissance a des probl√®mes.  Premi√®rement, il est sujet √† un faux temps, ce qui se fait g√©n√©ralement de deux mani√®res: en d√©calant le TSC dans VMCS ou en diminuant le TSC √† chaque ex√©cution du CPUID.  Il existe de nombreuses autres fa√ßons de g√©rer les attaques bas√©es sur le temps, mais ces derni√®res sont beaucoup plus faciles √† impl√©menter, car vous pouvez garantir que le temps d'ex√©cution de l'instruction se situera dans un ou deux cycles d'horloge de synchronisation d'ex√©cution sur un √©quipement r√©el.  La difficult√© de d√©couvrir cette technique de contrefa√ßon temporelle d√©pend de l'exp√©rience du d√©veloppeur.  Dans la section suivante, nous examinerons la contrefa√ßon temporelle et l'am√©lioration de l'impl√©mentation cr√©√©e dans BattlEye.  La deuxi√®me raison de ce d√©faut de m√©thode de reconnaissance est que le d√©lai CPUID (runtime) dans diff√©rents processeurs est tr√®s diff√©rent selon la valeur de la feuille.  Cela peut prendre jusqu'√† 70 √† 300 cycles d'horloge pour se terminer.  Le troisi√®me probl√®me avec cette proc√©dure de reconnaissance est d'utiliser SetThreadPriority.  Cette fonction Windows est utilis√©e pour d√©finir la valeur de priorit√© d'un descripteur de flux donn√©, cependant, le syst√®me d'exploitation n'√©coute pas toujours la demande.  Cette fonction est simplement une suggestion pour augmenter la priorit√© du thread, et il n'y a aucune garantie que cela se produira.  Ainsi, il est possible que cette m√©thode soit affect√©e par des interruptions ou d'autres processus. <br><br>  Dans ce cas, il est facile de contourner la reconnaissance, et la technique d√©crite de contrefa√ßon de temps d√©joue efficacement cette m√©thode de reconnaissance.  Si les d√©veloppeurs de BattlEye souhaitent am√©liorer cette m√©thode, la section suivante fournit quelques recommandations. <br><br><h4>  Am√©lioration </h4><br>  Cette fonctionnalit√© peut √™tre am√©lior√©e de plusieurs mani√®res.  Tout d'abord, vous pouvez d√©sactiver intentionnellement les interruptions et forcer la priorit√© d'un thread en modifiant CR8 en IRQL le plus √©lev√©.  Il serait √©galement id√©al d'isoler cette v√©rification dans un c≈ìur de processeur.  Autre am√©lioration: vous devez utiliser diff√©rents temporisateurs, mais beaucoup d'entre eux ne sont pas aussi pr√©cis que TSC, mais il existe un tel temporisateur appel√© APERF, ou Actual Performance Clock.  Je recommande ce temporisateur car il est plus difficile de tricher avec lui et il n'accumule un compteur que lorsque le processeur logique est √† l'√©tat d'alimentation C0.  Il s'agit d'une excellente alternative √† l'utilisation de TSC.  Vous pouvez √©galement utiliser l'ACPI, HPET, le minuteur PIT, le minuteur GPU, le minuteur NTP ou le minuteur PPERF, qui est similaire √† APERF, mais compte les mesures per√ßues comme des instructions d'ex√©cution.  L'inconv√©nient de ceci est que vous devez activer HWP, qui peut √™tre d√©sactiv√© par l'op√©rateur interm√©diaire, et donc il est inutile. <br><br>  Voici une version am√©lior√©e de la proc√©dure de reconnaissance qui devrait √™tre effectu√©e dans le noyau: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::take_time() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cpuid_regs[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {}; _disable(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_pre = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; __cpuid(&amp;cpuid_regs, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_post = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_diff = aperf_post - aperf_pre; <span class="hljs-comment"><span class="hljs-comment">// CPUID IET ARRAY STORE // BATTLEYE REPORT TABLE STORE _enable(); }</span></span></code> </pre> <br>  <strong>Remarque:</strong> IET signifie Instruction Execution Time. <br><br>  Cependant, la proc√©dure peut toujours √™tre tr√®s peu fiable pour d√©tecter les hyperviseurs courants, car les temps d'ex√©cution CPUID peuvent varier consid√©rablement.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il serait pr√©f√©rable de comparer l'IET des deux instructions. L'un d'eux devrait avoir un d√©lai d'ex√©cution plus long que le CPUID. Par exemple, il peut s'agir de FYL2XP1 - une instruction arithm√©tique qui prend un peu plus de temps √† compl√©ter que l'IET moyen de l'instruction CPUID. De plus, il ne provoque aucun pi√®ge dans l'hyperviseur et son temps peut √™tre mesur√© de mani√®re fiable. En utilisant ces deux fonctions, la fonction de profilage pourrait cr√©er un tableau pour stocker les instructions IET CPUID et FYL2XP1. En utilisant le temporisateur APERF, il serait possible d'obtenir l'horloge initiale d'une instruction arithm√©tique, d'ex√©cuter l'instruction et de calculer le delta de l'horloge pour celle-ci. Les r√©sultats pourraient √™tre stock√©s dans la matrice IET pour N cycles de profilage, obtenant la valeur moyenne et r√©p√©tant le processus pour le CPUID. Si le temps d'ex√©cution de l'instruction CPUID est plus long que l'instruction arithm√©tique,il s'agit alors d'un signe fiable que le syst√®me est virtuel, car une instruction arithm√©tique ne peut en aucun cas passer plus de temps que l'ex√©cution du CPUID pour obtenir des informations sur le fabricant ou la version. Une telle proc√©dure de reconnaissance pourra √©galement d√©tecter ceux utilisant le d√©calage / mise √† l'√©chelle TSC.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je r√©p√®te, les d√©veloppeurs devraient forcer l'activation de la liaison au c≈ìur de calcul pour effectuer cette v√©rification sur un seul c≈ìur, d√©sactiver les interruptions et forcer IRQL √† d√©finir la valeur maximale pour garantir des donn√©es coh√©rentes et fiables. </font><font style="vertical-align: inherit;">Il serait surprenant que les d√©veloppeurs de BattlEye d√©cident de l'impl√©menter, car cela n√©cessite beaucoup plus d'efforts. </font><font style="vertical-align: inherit;">Dans le pilote du noyau, BattlEye mange deux autres routines de reconnaissance de machine virtuelle, mais c'est un sujet pour un autre article.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484420/">https://habr.com/ru/post/fr484420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484408/index.html">RUTM Era</a></li>
<li><a href="../fr484410/index.html">Habitudes utiles des d√©veloppeurs</a></li>
<li><a href="../fr484412/index.html">Processeur NXP S32G pour l'architecture √©lectronique automobile moderne</a></li>
<li><a href="../fr484414/index.html">Choix d'un archiveur pour les journaux de sauvegarde</a></li>
<li><a href="../fr484418/index.html">PDG Motoriki Ilya Chekh: Parfois, ils attendent un travail id√©al des proth√®ses exp√©rimentales, puis ils sont d√©√ßus</a></li>
<li><a href="../fr484424/index.html">Nvidia Orin - une puce pour les v√©hicules robotiques</a></li>
<li><a href="../fr484426/index.html">Moi et mon cyclomoteur. Mise √† l'√©chelle de l'inefficacit√©</a></li>
<li><a href="../fr484428/index.html">Choisir une id√©e de startup sans investisseur: au contraire</a></li>
<li><a href="../fr484430/index.html">Les premi√®res lunettes VR compatibles HDR au monde: ce que l'on sait du prototype de Panasonic</a></li>
<li><a href="../fr484436/index.html">Open Source ingrat: le d√©veloppeur du serveur web le plus rapide a supprim√© son r√©f√©rentiel - Mise √† jour importante</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>