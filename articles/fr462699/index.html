<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏽 🛐 🤱🏼 Maillage de service, «Plan de données» et «Plan de contrôle» (Plan de données de maillage de service par rapport au plan de contrôle) 🆔 🤳🏾 🌙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article "Service mesh data plane vs control plane" par Matt Klein . 



 Cette fois, j'ai voulu et ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Maillage de service, «Plan de données» et «Plan de contrôle» (Plan de données de maillage de service par rapport au plan de contrôle)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462699/">  Bonjour, Habr!  Je vous présente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Service mesh data plane vs control plane"</a> par <b>Matt Klein</b> . <br><br><img src="https://habrastorage.org/webt/oa/ar/bu/oaarbu82bai5hzqqe0l2f-qeupg.png"><br><br>  Cette fois, j'ai voulu et traduit la description des deux composants du maillage de service, le plan de données et le plan de contrôle.  Cette description m'a semblé la plus compréhensible et la plus intéressante, et surtout menant à la compréhension de "Est-ce même nécessaire?" <br><br>  Comme l'idée d'un «maillage de service» est devenue de plus en plus populaire au cours des deux dernières années (article original 10 octobre 2017) et que le nombre de participants dans l'espace a augmenté, j'ai constaté une augmentation proportionnelle de la confusion parmi toute la communauté technique concernant la façon de comparer et opposer différentes solutions. <br><a name="habracut"></a><br>  La situation est mieux décrite dans la série de tweets suivante que j'ai écrite en juillet: <br><blockquote>  Confusion avec le maillage de service (maillage de service) n ° 1: Linkerd ~ = Nginx ~ = Haproxy ~ = Envoy.  Aucun d'eux n'est égal à Istio.  Istio est quelque chose de complètement différent.  1 / </blockquote><blockquote>  Les premiers ne sont que des avions de données.  Ils ne font rien.  Ils doivent être réglés pour quelque chose de plus.  2 / </blockquote><blockquote>  Istio est un exemple de plan de contrôle qui relie des pièces entre elles.  Il s'agit d'un calque différent.  / fin </blockquote>  Les tweets précédents mentionnaient plusieurs projets différents (Linkerd, NGINX, HAProxy, Envoy et Istio), mais, plus important encore, présentaient les concepts généraux d'un plan de données, d'un maillage de service et d'un plan de contrôle.  Dans ce billet, je prendrai un peu de recul et dirai ce que j'entends par les termes «plan de données» et «plan de contrôle» à un niveau très élevé, puis je dirai comment les termes se rapportent aux projets mentionnés dans les tweets. <br><br><h1>  Qu'est-ce qu'un maillage de service (vraiment)? </h1><br><img src="https://habrastorage.org/webt/3q/gw/dd/3qgwdd_ljaphirr4nlb9bdcghmc.png"><br>  <b>Figure 1: Présentation du maillage de service</b> <br><br>  <b>La figure 1</b> illustre le concept d'un maillage de service au niveau le plus élémentaire.  Il existe quatre clusters de services (AD).  Chaque instance de service est associée à un serveur proxy local.  Tout le trafic réseau (HTTP, REST, gRPC, Redis, etc.) provenant d'une seule instance d'application est transmis via un serveur proxy local aux clusters de services externes correspondants.  Ainsi, l'instance d'application ne connaît pas le réseau dans son ensemble et ne connaît que son proxy local.  En fait, le réseau du système distribué était éloigné du service. <br><br><h1>  Plan de données </h1><br>  Dans un maillage de service, un serveur proxy situé localement pour l'application effectue les tâches suivantes: <br><br><ul><li>  <b>Découverte de service</b>  Quels services / services / applications sont disponibles pour votre application? </li><li>  <b>Contrôle de santé</b>  Les instances de service retournées par la découverte de service sont-elles opérationnelles et prêtes à accepter le trafic réseau?  Cela peut inclure des contrôles d'intégrité actifs (par exemple, vérification de la réponse / healthcheck) et passifs (par exemple, en utilisant 3 erreurs 5xx consécutives comme indication de l'état malsain du service). </li><li>  <b>Acheminement</b>  Après avoir reçu une demande à "/ foo" du service REST, vers quel cluster de services la demande doit-elle être envoyée? </li><li>  <b>Équilibrage de charge</b>  Une fois qu'un cluster de services a été sélectionné pendant le routage, vers quelle instance du service la demande doit-elle être envoyée?  Quel délai?  Quels paramètres de coupure de circuit?  Si la demande échoue, doit-elle être répétée? </li><li>  <b>Authentification et autorisation</b>  Pour les demandes entrantes, le service appelant peut-il être cryptographiquement reconnu / autorisé à l'aide de mTLS ou d'un autre mécanisme?  S'il est identifié / autorisé, est-il autorisé à appeler l'opération demandée (point d'extrémité) dans le service ou doit-on renvoyer une réponse non authentifiée? </li><li>  <b>Observabilité</b>  Pour chaque demande, des statistiques détaillées, des journaux / journaux et des données de trace distribuées doivent être générées afin que les opérateurs puissent comprendre le flux de trafic distribué et les problèmes de débogage à mesure qu'ils surviennent. </li></ul><br>  Pour tous les points précédents du réseau de service (maillage de service), le plan de données est responsable.  En fait, le proxy local au service (side-car) est un plan de données.  En d'autres termes, le plan de données est responsable de la diffusion, de la transmission et de la surveillance conditionnelles de chaque paquet de réseau envoyé au service ou envoyé à partir de celui-ci. <br><br><h1>  L'avion de contrôle </h1><br>  L'abstraction du réseau fournie par le proxy local dans le plan de données est magique (?).  Cependant, comment le proxy connaît-il réellement la route "/ foo" vers le service B?  Comment utiliser les données de découverte de service remplies de demandes de proxy?  Comment les paramètres d'équilibrage de charge, de temporisation, de coupure de circuit, etc. sont-ils configurés?  Comment déployer l'application en utilisant la méthode bleu / vert (bleu / vert) ou la méthode de transfert progressif du trafic?  Qui configure les paramètres d'authentification et d'autorisation à l'échelle du système? <br><br>  Tous les éléments ci-dessus sont gérés par le plan de contrôle du maillage de service.  <i>Le plan de contrôle accepte un ensemble de serveurs proxy isolés sans état et les transforme en un système distribué</i> . <br><br>  Je pense que la raison pour laquelle de nombreux technologues trouvent confus les concepts séparés du plan de données et du plan de contrôle est que, pour la plupart des gens, le plan de données est familier, tandis que le plan de contrôle est étranger / incompréhensible.  Nous travaillons depuis longtemps avec des routeurs et des commutateurs réseau physiques.  Nous comprenons que les packages / demandes doivent aller du point A au point B, et que nous pouvons utiliser du matériel et des logiciels pour cela.  La nouvelle génération de proxys logiciels est tout simplement les versions tendances des outils que nous utilisons depuis longtemps. <br><br><img src="https://habrastorage.org/webt/ty/xa/re/tyxareqql4_ndfv1unsjrh0fx78.png"><br>  <b>Figure 2: Plan de contrôle humain</b> <br><br>  Cependant, nous utilisons depuis longtemps le plan de contrôle, bien que la plupart des opérateurs de réseaux n'associent cette partie du système à aucun composant technologique.  La raison en est simple: <br>  <b>La plupart des avions de contrôle utilisés aujourd'hui sont ... nous</b> . <br><br>  <b>La figure 2</b> montre ce que j'appelle le «plan de contrôle humain».  Dans ce type de déploiement, qui est encore très courant, l'opérateur humain, probablement grincheux, crée des configurations statiques - potentiellement à l'aide de scripts - et les déploie à l'aide d'une sorte de processus spécial sur tous les proxys.  Ensuite, les proxys commencent à utiliser cette configuration et commencent à traiter le plan de données à l'aide des paramètres mis à jour. <br><br><img src="https://habrastorage.org/webt/nm/tj/dt/nmtjdtcwt4e22o_ow0gjns7sv9c.png"><br>  <b>Figure 3: Plan de contrôle de maillage de service avancé</b> <br><br>  <b>La figure 3</b> montre le plan de contrôle «étendu» du maillage de service.  Il se compose des parties suivantes: <br><br><ul><li>  <b>L'Humain</b> : Il y a encore une personne (espérons-le moins en colère) qui prend des décisions de haut niveau concernant l'ensemble du système. </li><li>  <b>Contrôle de l'interface utilisateur du plan</b> : une personne interagit avec un certain type d'interface utilisateur pour contrôler le système.  Il peut s'agir d'un portail Web, d'une application de ligne de commande (CLI) ou d'une autre interface.  À l'aide de l'interface utilisateur, l'opérateur a accès à des paramètres de configuration globale du système tels que: <br><ul><li>  Gestion du déploiement, bleu / vert et / ou avec transfert progressif du trafic </li><li>  Paramètres d'authentification et d'autorisation </li><li>  Spécifications de la table de routage, par exemple, lorsque l'application A demande des informations sur "/ foo", que se passe-t-il </li><li>  Paramètres d'équilibrage de charge, tels que les délais d'attente, les tentatives, les paramètres de coupure de circuit, etc. </li></ul></li><li>  <b>Planificateur de charge de travail</b> : les services sont lancés dans l'infrastructure via un certain type de système de planification / orchestration, tel que Kubernetes ou Nomad.  L'ordonnanceur est responsable du chargement du service avec son serveur proxy local. </li><li>  <b>Découverte de service</b>  Lorsque le planificateur démarre et arrête les instances de service, il signale l'état d'intégrité au système de découverte de service. </li><li>  <b>API de configuration de proxy Sidecar</b> : les proxys locaux extraient dynamiquement l'état de divers composants du système selon le modèle «finalement cohérent» sans intervention de l'opérateur.  L'ensemble du système, composé de toutes les instances de services en cours d'exécution et des serveurs proxy locaux, converge finalement en un seul écosystème.  L'API du plan de données Envoy est un exemple de la façon dont cela fonctionne dans la pratique. </li></ul><br>  Essentiellement, l'objectif du plan de contrôle est d'établir une politique qui sera finalement adoptée par le plan de données.  Des avions de contrôle plus avancés retireront plus de parties de certains systèmes de l'opérateur et nécessiteront moins de contrôle manuel, à condition qu'ils fonctionnent correctement! .. <br><br><h1>  Plan de données et plan de contrôle.  Résumé du plan de données et du plan de contrôle </h1><br><ul><li>  <b>Plan de données de maillage de service</b> : affecte chaque paquet / demande dans le système.  Responsable de la découverte des applications / services, des contrôles d'intégrité, du routage, de l'équilibrage de charge, de l'authentification / autorisation et de l'observabilité. </li><li>  <b>Plan de contrôle du maillage de service</b> : fournit une politique et une configuration pour tous les plans de données de travail au sein du réseau de service.  Ne touche aucun paquet / demande dans le système.  Le plan de contrôle transforme tous les plans de données en un système distribué. </li></ul><br><h1>  Paysage actuel du projet </h1><br>  Après avoir compris l'explication ci-dessus, regardons l'état actuel du projet «service mesh». <br><br><ul><li>  Avions de <b>données</b> : Linkerd, NGINX, HAProxy, Envoy, Traefik </li><li>  Avions de <b>contrôle</b> : Istio, Nelson, SmartStack </li></ul><br>  Au lieu de procéder à une analyse approfondie de chacune des solutions ci-dessus, je m'attarderai brièvement sur certains points qui, à mon avis, causent actuellement la plus grande confusion dans l'écosystème. <br><br>  Au début de 2016, Linkerd a été l'un des premiers serveurs proxy pour le plan de données pour le maillage de service et a fait un travail fantastique de sensibilisation et d'attention au modèle de conception de maillage de service.  Environ 6 mois après cela, Envoy a rejoint Linkerd (bien qu'il soit avec Lyft depuis la fin de 2015).  Linkerd et Envoy sont deux des projets les plus souvent mentionnés lors des discussions sur les réseaux de services. <br><br>  Istio a été annoncé en mai 2017.  Les objectifs du projet Istio sont très similaires au plan de contrôle étendu illustré à la <b>figure 3</b> .  Envoy for Istio est le serveur proxy par défaut.  Ainsi, Istio est le plan de contrôle et Envoy est le plan de données.  En peu de temps, Istio a causé beaucoup d'agitation et d'autres avions de données ont commencé à s'intégrer en remplacement d'Envoy (Linkerd et NGINX ont tous deux démontré leur intégration avec Istio).  Le fait que vous puissiez utiliser différents plans de données dans le même plan de contrôle signifie que le plan de contrôle et le plan de données ne sont pas nécessairement étroitement liés.  Une API telle que l'API du plan de données universel Envoy peut former un pont entre deux parties du système. <br><br>  Nelson et SmartStack aident à illustrer davantage la séparation du plan de contrôle et du plan de données.  Nelson utilise Envoy comme proxy et construit un plan de contrôle fiable du maillage de service basé sur la pile HashiCorp, c'est-à-dire  Nomade etc.  SmartStack est peut-être le premier d'une nouvelle vague de réseaux de services.  SmartStack forme un plan de contrôle autour d'un HAProxy ou NGINX, démontrant la possibilité de découpler un plan de contrôle d'un maillage de service et d'un plan de données. <br><br>  Une architecture de microservices avec un maillage de service attire plus l'attention (à droite!), Et de plus en plus de projets et de fournisseurs commencent à travailler dans cette direction.  Au cours des prochaines années, nous verrons de nombreuses innovations à la fois dans le plan de données et le plan de contrôle, ainsi que le mélange des divers composants.  À terme, l'architecture de microservice devrait devenir plus transparente et magique (?) Pour l'opérateur. <br>  J'espère de moins en moins ennuyé. <br><br><h1>  Points clés (points clés à retenir) </h1><br><ul><li>  Un maillage de service (maillage de service) se compose de deux parties différentes: un plan de données et un plan de contrôle.  Les deux composants sont requis et sans eux, le système ne fonctionnera pas. </li><li>  Tout le monde connaît le plan de contrôle, et maintenant vous pouvez être le plan de contrôle! </li><li>  Tous les avions de données se font concurrence en termes de fonctions, de performances, de configurabilité et d'extensibilité. </li><li>  Tous les avions de contrôle rivalisent de fonction, de configurabilité, d'extensibilité et de convivialité. </li><li>  Un seul plan de contrôle peut contenir les abstractions et les API correctes afin que plusieurs plans de données puissent être utilisés. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462699/">https://habr.com/ru/post/fr462699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462689/index.html">DISKOBALL: compétitions de lancer de disques durs, 23 août, Moscou</a></li>
<li><a href="../fr462691/index.html">Comment migrer d'AD vers LDAP lors de l'utilisation de Zimbra</a></li>
<li><a href="../fr462693/index.html">En route vers des applications durables avec le générateur de site statique PSKOV comme exemple</a></li>
<li><a href="../fr462695/index.html">Matériel en tant que composants Web</a></li>
<li><a href="../fr462697/index.html">uWSGI pour aider les métriques. Rapport Yandex</a></li>
<li><a href="../fr462701/index.html">Bibliothèque de générateur de code assembleur pour microcontrôleurs AVR. 2e partie</a></li>
<li><a href="../fr462703/index.html">Le tourniquet «le moins cher» de Russie contrôlé depuis un smartphone</a></li>
<li><a href="../fr462705/index.html">Top 5 des bugs dans mes applications ReactJS</a></li>
<li><a href="../fr462707/index.html">Kubernetes lance les outils de développement d'applications</a></li>
<li><a href="../fr462709/index.html">Test de mutation en PHP: une mesure qualitative pour la couverture du code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>