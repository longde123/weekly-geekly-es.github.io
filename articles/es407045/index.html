<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê£ üêä üëã Una breve introducci√≥n al desarrollo de aplicaciones de microcontroladores stm32 üò∑ üåä üëßüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muy a menudo las personas recurren a m√≠ con una solicitud para ayudarlos a comenzar con los microcontroladores de la familia stm32. Respondiendo a sus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una breve introducci√≥n al desarrollo de aplicaciones de microcontroladores stm32</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/407045/">  Muy a menudo las personas recurren a m√≠ con una solicitud para ayudarlos a comenzar con los microcontroladores de la familia stm32.  Respondiendo a sus preguntas y ayud√°ndoles con sus proyectos, me di cuenta de que ser√≠a mejor escribir un art√≠culo que fuera √∫til para todos los que quieran comenzar a programar microcontroladores stm32.  A pesar de todas sus muchas caracter√≠sticas, los controladores stm32 tienen un umbral de entrada bastante alto, que para muchos no est√° disponible.  En este art√≠culo, intentar√© darle al lector una gu√≠a detallada sobre c√≥mo crear proyectos en stm32 y c√≥mo organizar su programa. <br><br>  Usando el microcontrolador stm32f103c8t6 y el m√≥dulo de p√≠ldora azul como ejemplo, veremos la estructura de un proyecto t√≠pico para el entorno de desarrollo IAR y crearemos un firmware que funcione. <br><br>  Todos los que est√©n interesados ‚Äã‚Äãen comenzar a trabajar con stm32, bienvenidos a cat. <br><a name="habracut"></a><br><h4>  ¬øQu√© necesitamos para seguir trabajando? </h4><br>  Todos los ejemplos que siguen se realizaron en el entorno de trabajo IAR Embedded para el entorno ARM v7.30.  El entorno est√° instalado en Windows XP, que est√° instalado en la m√°quina virtual VirtualBOX lanzada desde Mac OS X El capit√°n.  Tambi√©n se utiliza el programador ST-LINK, que se conecta a la tableta de pastillas azul comprada en AliExpress por ~ 120‚ÇΩ. <br><br>  Para crear un proyecto t√≠pico necesitar√°s: <br><br><ul><li>  <b>M√≥dulo de p√≠ldora azul o similar</b> <br><br>  Se ubican f√°cilmente en AliExpress con la solicitud "placa stm32f103c8t6" y cuestan alrededor de 100 rublos. <br><div style="text-align:center;"><img src="https://habrastorage.org/web/729/f10/a78/729f10a784994ac5ba9c0f2ed34731ab.jpg" width="500"></div><br></li><li>  <b>Programador ST-Link</b> <br><br>  Tambi√©n est√° f√°cilmente disponible en AliExpress a pedido de "stlink v2" y tambi√©n cuesta alrededor de 100 rublos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/ca3/e8f/74b/ca3e8f74bb65475eb9b93fb6c9c4f7ba.jpg" width="500"></div><br>  Hay una versi√≥n m√°s completa, que est√° dise√±ada para conectar un conector de cinta est√°ndar IDC20 <br><div style="text-align:center;"><img src="https://habrastorage.org/web/fda/5fb/237/fda5fb237daf4826a9375fb34c7e548e.jpg" width="500"></div><br></li><li>  <b>Entorno de desarrollo IAR 7.30 o posterior</b> <br><br>  La versi√≥n limitada 8.10 se puede descargar desde el sitio web oficial. <br></li><li>  <b>Una plantilla de proyecto que contiene todos los componentes necesarios.</b> <br><br>  La plantilla se puede descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠.</a> <br></li><li>  <b>STDPeripheralLibrary3.5.0 Referencia de funciones</b> <br><br>  El proyecto incluye una biblioteca de funciones StdPeriph3.5.0.  Un poco viejo para proyectos serios, pero para principiantes es bastante simple y evita un dolor de cabeza cuando se trabaja con la periferia del microcontrolador.  Se puede descargar el manual en formato WinHelp (CHM) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desde aqui</a> <br></li><li>  <b>RM0008 Manual de referencia</b> <br><br>  Manual de referencia para microcontroladores de la familia stm32f103c8.  El libro de referencia contiene una descripci√≥n del n√∫cleo y la periferia del microcontrolador, su arquitectura y descripciones de registros.  Es aconsejable, con el tiempo, leer a lo largo y ancho y saber c√≥mo funciona cada componente perif√©rico.  Si eres partidario de CMSIS desnudo, entonces sin este PDF no puedes hacerlo.  Si eres el novato que usa Perlib, entonces a√∫n necesitas leer c√≥mo funciona este o aquel m√≥dulo perif√©rico.  Puede descargar la referencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del sitio web de STMicroelectonics</a> <br></li></ul><br><h4>  Plantilla de proyecto </h4><br>  La plantilla de proyecto adjunta no se tom√≥ completamente de alg√∫n lugar de Internet, sino que se cre√≥ con nuestras propias manos a partir de ejemplos que fueron a PeripheralLibrary, archivos del paquete CMSIS y nuestras propias mejoras.  La plantilla del proyecto no contiene archivos que pertenecen a ning√∫n entorno de desarrollo y se puede utilizar para cualquiera de ellos (no lo he probado, pero supongo que s√≠). <br><br>  Una descripci√≥n detallada de la estructura del directorio puede parecer demasiado complicada para los principiantes, sin embargo, estudiarla tambi√©n ser√° √∫til. <br><br><div class="spoiler">  <b class="spoiler_title">Estructura del directorio del proyecto</b> <div class="spoiler_text"><ul><li>  <b>config</b> <br>  <i>stm32f10x_conf.h</i> <br><br>  Este archivo pertenece al paquete StdPeripheral y contiene la inclusi√≥n de archivos de encabezado utilizados en el proyecto perif√©rico del microcontrolador.  Se supone que el programador comentar√° los archivos no utilizados, dependiendo del proyecto.  Por defecto, todos los archivos est√°n incluidos. <br></li><li>  <b>n√∫cleo</b> <br><br>  Este directorio contiene archivos CMSIS que son espec√≠ficos del n√∫cleo del procesador ARM CortexM3. <br></li><li>  <b>perlib</b> <br><br>  Este directorio contiene los archivos de encabezado y el c√≥digo fuente de la biblioteca Perlib en los directorios <i>inc</i> y <i>src</i> . <br></li><li>  <b>inicio</b> <br><br>  Estos son los archivos con el c√≥digo de inicializaci√≥n principal del controlador, que instalan los controladores de interrupci√≥n del n√∫cleo ARM y llaman a las funciones de inicializaci√≥n del sistema de reloj del n√∫cleo y la inicializaci√≥n PLL.  Cada tipo de microcontrolador tiene su propio archivo separado. <br><br>  El c√≥digo en este archivo se ejecuta ANTES de que se llame a la funci√≥n main () de su programa. <br>  Los controladores de interrupci√≥n del n√∫cleo ARM, as√≠ como las funciones de inicializaci√≥n del reloj, no se almacenan en estos archivos, solo se llaman.  Y se almacenan en los archivos del directorio del sistema, que se discutir√°n m√°s adelante. <br><br>  Por ejemplo, para que el microcontrolador stm32f103c8t6 funcione a 72 MHz, y no a los 8 MHz predeterminados, debe conectar el archivo <i>startup_stm32f10x_md.s</i> en el proyecto. <br></li><li>  <b>sistema</b> <br><br>  Este directorio contiene archivos que contienen todas las funciones de la inicializaci√≥n inicial del sistema, los controladores de interrupci√≥n del n√∫cleo ARM, as√≠ como descripciones de los nombres y campos de los registros del microcontrolador. <br><br>  <i>stm32f10x.h</i> <br><br>  Este es un archivo del paquete CMSIS que contiene direcciones, nombres de registros y sus campos para la periferia del microcontrolador.  Cada m√≥dulo perif√©rico se presenta aqu√≠ como una estructura, cuyos campos son registros.  Tambi√©n define constantes y m√°scaras de bits para los campos de registro. <br><br>  <i>stm32f10x_it</i> <br><br>  Los controladores de interrupci√≥n del kernel ARM se escriben aqu√≠.  Con la excepci√≥n del controlador SysTick, que utilic√© para calcular los intervalos de tiempo, estos controladores de interrupci√≥n est√°n vac√≠os.  Si, de repente, su proyecto requiere el manejo de interrupciones del n√∫cleo, entonces este archivo es solo para usted. <br><br>  <b>No confunda el manejo de interrupciones del n√∫cleo del procesador y el manejo de interrupciones perif√©ricas.</b>  <b>Las interrupciones perif√©ricas, como un temporizador o USART, deben realizarse en sus propios archivos de proyecto, que usted mismo escribe y agrega a la ra√≠z del directorio del proyecto.</b> <br><br>  <i>system_stm32f10x</i> <br><br>  Estos dos archivos contienen las mismas funciones de inicializaci√≥n del reloj del n√∫cleo y las funciones del reloj PLL que se invocan desde el archivo de inicializaci√≥n en el directorio de inicio.  A saber, las funciones SystemInit y SystemCoreClockUpdate. <br></li></ul><br></div></div><br><h4>  Crear un proyecto </h4><br>  Para crear nuestro primer proyecto, primero debe crear una carpeta para √©l.  Llam√©moslo EX01. <br>  Lanzamos IAR y en el men√∫ <b>Proyecto</b> , seleccione <b>Crear nuevo proyecto</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Figura 1. Crear un nuevo proyecto</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/c67/e37/c9c/c67e37c9c977478bacbf677bd8891e63.jpg"><br></div></div><br>  El valor de la cadena de herramientas debe dejarse en ARM, y seleccionamos la plantilla de proyecto C ‚Üí principal.  Luego, haga clic en Aceptar. <br><br><div class="spoiler">  <b class="spoiler_title">Figura 2. Guardar un proyecto vac√≠o</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/bcb/580/f3c/bcb580f3cf9345988716dc873e1ccde0.jpg"><br></div></div><br>  Aparecer√° una ventana para guardar el proyecto.  En √©l, debe seleccionar la carpeta creada anteriormente.  Vamos a nombrar el proyecto ex01.  Ahora puede hacer clic en <b>Guardar</b> . <br><br>  Como resultado, se crear√° un archivo principal vac√≠o y un proyecto vac√≠o, que a√∫n no contiene ninguna configuraci√≥n.  El siguiente paso es guardar el espacio de trabajo para que no interfiera con nuestras preguntas en el futuro.  Haga clic en <b>Archivo ‚Üí Guardar espacio de trabajo</b> .  Ll√°melo ex01 y haga clic en <b>Guardar</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Figura 3. Guardar el espacio de trabajo</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/318/79b/2e5/31879b2e57824c01845fbf01a107f25b.png"><br></div></div><br>  Ahora estamos listos para usar la plantilla del proyecto.  C√≥pielo del archivo a nuestra carpeta EX01. <br><br><div class="spoiler">  <b class="spoiler_title">Figura 4. Copiar archivos de una plantilla a un nuevo proyecto</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/857/328/568/8573285685844c26b24171bd6e22efcc.jpg"><br></div></div><br>  Los archivos principales que crearon la plantilla del proyecto deben reemplazarse con archivos del proyecto. <br><br>  Despu√©s de copiar la plantilla del proyecto, debe configurar el proyecto en s√≠. <br><br>  Para hacer esto, seleccione el men√∫ <b>Proyecto ‚Üí Opciones</b> .  Se abrir√° una ventana que contendr√° una lista de categor√≠as de opciones a la izquierda, cada una de las cuales tendr√° ciertos marcadores. <br><br>  Seleccione la categor√≠a <b>Opciones generales</b> y la pesta√±a <b>Destino</b> en ella.  En el grupo <b>Variante</b> del <b>procesador</b> , seleccione la opci√≥n <b>Dispositivo</b> y haga clic en el bot√≥n para seleccionar un dispositivo espec√≠fico al lado.  En nuestro caso, ser√° ST ‚Üí STM32F103 ‚Üí ST STM32F103x8. <br><br><div class="spoiler">  <b class="spoiler_title">Figura 5. Selecci√≥n del dispositivo de destino para el proyecto</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/fc8/d85/19a/fc8d8519a25742309611690c941e4853.jpg"><br></div></div><br>  La siguiente categor√≠a que requiere nuestra atenci√≥n es la categor√≠a del <b>compilador C / C ++</b> y la pesta√±a <b>Preprocesador</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Figura 6. Configuraci√≥n de marcadores del preprocesador</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/993/df8/ed3/993df8ed3a04468692671738119e9347.jpg"><br></div></div><br>  El bloque de <b>directorios de inclusi√≥n adicional</b> debe completarse con enlaces a los directorios de la plantilla del proyecto. <br><br>  <b>PreIncluir archivo,</b> debe seleccionar el archivo de configuraci√≥n de la biblioteca PerLib, y los <b>s√≠mbolos definidos deben</b> especificarse con STM32F10X_MD para que los archivos de inicializaci√≥n establezcan el reloj del n√∫cleo correcto y configuren correctamente el PLL. <br><br>  Como usamos ST-Link v2 como programador, debe elegir el controlador que usar√° el entorno de desarrollador.  Seleccione la categor√≠a <b>Depuraci√≥n</b> y la pesta√±a <b>Configuraci√≥n</b> , en la que seleccione <b>Controlador ST-Link</b> en la lista desplegable. <br><br><div class="spoiler">  <b class="spoiler_title">Figura 7. Elecci√≥n de una herramienta de depuraci√≥n</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/280/f5c/b81/280f5cb81ba84c0790fd3f7f7d413015.jpg"><br></div></div><br>  Ahora necesita configurar la carga del firmware al controlador.  Puede hacerlo en la misma categor√≠a, en la pesta√±a <b>Descargar</b> .  Estamos interesados ‚Äã‚Äãen las opciones de <b>Verify download</b> and <b>Use flash loader</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Figura 8. Configuraci√≥n de par√°metros de carga de firmware en el microcontrolador</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/330/0af/4d7/3300af4d78fe436687c4a39dfc530d2f.jpg"><br></div></div><br>  Como elegimos ST-Link como un medio para cargar firmware al controlador y depurarlo, debe configurar su controlador para que funcione con nuestro controlador.  La placa Blue Pill no tiene un conector JTAG completo que pueda funcionar utilizando el protocolo JTAG completo.  En su lugar, utilizaremos su modo simplificado, que se llama SWD.  Este modo JTAG usa solo tres l√≠neas.  Estos son GND, SWDCLK y SWDIO.  De manera predeterminada, el modo JTAG completo est√° habilitado, por lo que debemos cambiarlo a SWD y configurar la frecuencia central a 72MHz. <br>  En la lista de categor√≠as, seleccione <b>ST-LINK</b> y cambie la opci√≥n en el grupo <b>Interfaz</b> a SWD. <br><br>  Ahora puede hacer <b>clic</b> en <b>Aceptar</b> , nuestro proyecto est√° configurado. <br><br><div class="spoiler">  <b class="spoiler_title">Figura 9. Configuraci√≥n del controlador ST-LINK</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/60e/e90/b49/60ee90b49dce4987bbca7c96ff28e25a.jpg"><br></div></div><br>  Ahora queda por hacer la √∫ltima, pero muy importante acci√≥n, antes de comenzar a compilar nuestro primer programa.  Debe agregar archivos de la plantilla al proyecto. <br><br>  Los archivos se agregan al proyecto en el panel Espacio de trabajo.  Ya hay un archivo principal all√≠, sin embargo, necesitamos agregar PerLib, as√≠ como uno de los archivos de inicializaci√≥n del directorio de inicio y los archivos de inicializaci√≥n del directorio del sistema.  Podr√≠amos lanzar un mont√≥n, pero luego tendr√≠amos que sufrir y si el proyecto crece demasiado, entonces ese basurero ser√° muy dif√≠cil. <br><br>  El entorno de desarrollo IAR le permite crear grupos de archivos.  Los grupos son un concepto puramente virtual.  Solo le permiten organizar archivos en un proyecto.  Los grupos no tienen nada que ver con los directorios del disco. <br><br>  Crearemos grupos para cada directorio desde la plantilla del proyecto y colocaremos los archivos de la plantilla all√≠. <br><br>  Primero, cree el grupo de configuraci√≥n y coloque el archivo stm32f10x_conf.h del directorio de configuraci√≥n en √©l. <br>  Para hacer esto, haga clic derecho en el nombre del proyecto en la ventana del Espacio de trabajo y seleccione Agregar ‚Üí Agregar grupo en el men√∫ desplegable.  Nombre del grupo Config. <br><br>  Para agregar archivos a este grupo, haga clic derecho sobre √©l y seleccione Agregar ‚Üí Agregar archivos.  En la ventana que se abre, abra la carpeta de configuraci√≥n y seleccione el archivo stm32f10x_conf.h. <br><br><img src="https://habrastorage.org/web/e13/e92/013/e13e92013b8e4a96b544d5626dcda21f.jpg"><br><br>  Del mismo modo, agregamos el contenido de las carpetas Perlib, Startup y System.  No necesita agregar la carpeta Core, solo hay archivos de encabezado que est√°n disponibles en la biblioteca Perlib agregada. <br><br><div class="spoiler">  <b class="spoiler_title">Figura 11. Vista completa de un proyecto vac√≠o y totalmente configurado</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/02f/09d/d52/02f09dd5286d4b17a1e2ea6d6c1e3542.jpg"><br></div></div><br>  Ahora el proyecto est√° completamente listo para un mayor desarrollo. <br><br><h4>  Poco de teor√≠a </h4><br>  Muchos programadores principiantes est√°n acostumbrados al hecho de que el programa consiste en un ciclo en el que las funciones se llaman una tras otra.  La siguiente funci√≥n se llama solo despu√©s de que la anterior haya completado completamente su trabajo.  Este paradigma lo ofrece Arduino o varios art√≠culos con lecciones para principiantes.  Sin embargo, los proyectos grandes rara vez tienen un solo subproceso.  Como regla general, un firmware m√°s o menos serio puede tener varios subprocesos. <br><br>  Los microcontroladores, para organizar subprocesos m√∫ltiples, utilizan sistemas operativos en tiempo real (RTOS), como ThreadX o FreeRTOS.  Todos ellos le permiten crear muchos de esos ciclos en los que las funciones se ejecutan una tras otra, solo los ciclos funcionan al mismo tiempo.  Al igual que varios Arduins embistieron en un microcontrolador. <br><br>  Con todo su poder, el RTOS introduce ciertas dificultades.  Por ejemplo, cada hilo tiene su propia pila, su propia √°rea de memoria.  Si varios subprocesos necesitan acceder a la misma ubicaci√≥n de memoria, deben sincronizar sus acciones utilizando mutexes o sem√°foros.  El uso incorrecto de los objetos de sincronizaci√≥n puede conducir a puntos muertos o inversiones de prioridades de subprocesos.  Adem√°s, el procesamiento de las interrupciones desde la periferia tambi√©n requiere atenci√≥n especial en un entorno de subprocesos m√∫ltiples, ya que surge el problema de guardar la pila y elegir las condiciones bajo las cuales la llamada de interrupci√≥n no destruye la pila de flujo interrumpido.  Y el controlador de interrupciones en s√≠ tambi√©n debe funcionar hasta el final. <br><br>  El RTOS asigna un peque√±o intervalo de tiempo a cada subproceso.  Despu√©s de este intervalo, el RTOS cambia a la siguiente secuencia (no importa si la anterior ha completado sus acciones o no) y as√≠ sucesivamente.  Las diferentes transmisiones pueden recibir diferentes intervalos de tiempo, seg√∫n su prioridad.  Este tipo de subprocesamiento m√∫ltiple se denomina desplazamiento. <br><br>  Para ordenar los flujos y transferirles el control durante un breve intervalo de tiempo, el componente RTOS, denominado "programador", es responsable. <br><br>  Es dif√≠cil para los programadores novatos dominar de inmediato los enormes y complejos perif√©ricos de stm32 y al mismo tiempo tambi√©n aprender RTOS. <br><br>  Afortunadamente, hay formas de hacer aplicaciones multiproceso sin ning√∫n tipo de RTOS.  Para esto, el "multihilo cooperativo" viene en nuestra ayuda.  El multiproceso cooperativo le permite realizar proyectos multiproceso relativamente peque√±os sin la participaci√≥n de RTOS. <br><br>  ¬øCu√°l es la esencia del multihilo cooperativo?  Con este subprocesamiento m√∫ltiple, cada subproceso requiere tanto tiempo de procesador como sea necesario, pero no lo suficiente para completar toda su tarea a la vez.  Esto presenta requisitos muy estrictos para el estilo de escritura de las aplicaciones cooperativas de subprocesos m√∫ltiples. <br><br>  El multihilo cooperativo tiene varias ventajas y desventajas.  La elecci√≥n del paradigma de subprocesos m√∫ltiples depende completamente del desarrollador y los requisitos de la tarea que realiza. <br>  Las principales ventajas de los subprocesos m√∫ltiples cooperativos son la ausencia de un planificador, una sola pila para todos los subprocesos, la ausencia de la necesidad de sincronizar subprocesos y la simplicidad de las interrupciones de procesamiento desde la periferia. <br><br>  Desafortunadamente, tambi√©n hay desventajas.  En particular, la congelaci√≥n de uno de los hilos conducir√° a la congelaci√≥n de todo el programa en su conjunto.  Adem√°s, la ortograf√≠a incorrecta de uno o m√°s subprocesos puede provocar un retraso en la ejecuci√≥n del resto.  Y esta no es una lista completa. <br><br><h4>  Estructura cooperativa de aplicaci√≥n multiproceso </h4><br>  Las aplicaciones cooperativas de subprocesos m√∫ltiples se basan en una m√°quina de estado.  No lo describir√© en detalle, ya que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ya se describe en detalle.  Sin embargo, explicar√© brevemente la esencia.  Una m√°quina de estados es un objeto abstracto, cuyo n√∫mero de estados es finito.  Un objeto pasa de un estado a otro, ya sea bajo la influencia de factores externos o debido a procesos internos.  En nuestro caso, un subproceso de aplicaci√≥n cooperativa es una implementaci√≥n de una m√°quina de estados. <br><br>  Una secuencia tiene una lista de estados.  En cada estado, se realiza una acci√≥n corta o nada.  La conmutaci√≥n de estados puede llevarse a cabo llamando a funciones externas o cuando surgen condiciones en las que ya no es posible encontrar el flujo en el estado actual y se requiere la conmutaci√≥n a otro estado. <br><br>  Durante varios a√±os de trabajo con microcontroladores stm32, he desarrollado una estructura de una aplicaci√≥n cooperativa de subprocesos m√∫ltiples, que quiero presentarles. <br><br>  Cada secuencia es un m√≥dulo separado (archivo de encabezado y archivo de c√≥digo). <br><br>  El m√≥dulo tiene funciones p√∫blicas, cuyos prototipos est√°n registrados en el archivo de encabezado y privados, cuya llamada es imposible desde el exterior.  Cada m√≥dulo tiene al menos dos funciones p√∫blicas: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XXX_Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XXX_Control</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  La funci√≥n XXX_Init () se llama antes del bucle principal en la funci√≥n main (), y la funci√≥n XXX_Control () se llama en el bucle principal de la funci√≥n principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   XXX XXX_Init(); //   YYY YYY_Init(); //   ZZZ ZZZ_Init(); while(true){ XXX_Control(); YYY_Control(); ZZZ_Control(); } }</span></span></code> </pre><br>  Un archivo de m√≥dulo XXX podr√≠a verse as√≠: <br><br>  <b>xxx.c</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"xxx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> XXX_WATER_MAX_THRESHOLD 100500 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> XXX_WATER_MIN_THRESHOLD 9000 typedef enum{ idle, state1, state2, : stateX, }XXX_States; static XXX_States xxxCurrentState = idle; static int xxxToiletWaterLevel=0; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//---------    -------- void private_init1() { } void private_init2() { } void private_measureLevel() { } void private_flush() { } void private_superFlush() { } //--------    --------- void XXX_Init() { xxxCurrentState=idle; } void XXX_Reset() { private_superFlush(); xxxCurrentState=idle; } void XXX_Control() { switch(xxxCurrentState) { case idle: private_measureLevel(); if(xxxToiletWaterLevel&gt;XXX_WATER_MIN_THRESHOLD) xxxCurrentState=state1; break; case state1: if(xxxToiletWaterLevel&lt;XXX_WATER_MAX_THRESHOLD) { private_flush(); xxxCurrentState=idle; } else xxxCurrentState=state2; break; case state2: //   break; } }</span></span></span></span></code> </pre><br><h4>  Ejemplo de aplicaci√≥n cooperativa de subprocesos m√∫ltiples </h4><br>  Para no ser demasiado abstracto, imaginemos un verdadero desaf√≠o.  Supongamos que tenemos un flujo que parpadea un LED (dos veces por segundo), que est√° conectado por un c√°todo al puerto PC13.  Tambi√©n tenemos una secuencia que recibe comandos a trav√©s del puerto serie.  Si llega el car√°cter '0' (0x30), el parpadeo se detiene y se env√≠a un signo '-' al cliente.  Si llega el car√°cter '1' (0x31), el parpadeo se enciende y el car√°cter '*' se devuelve al cliente.  Al presionar cualquier otra tecla, se devuelve el car√°cter 'E'. <br><br>  Colocaremos el flujo de control del LED que parpadea en los archivos modLed.h y modLed.c.  Este hilo est√° inicialmente en estado inactivo y no hace nada.  Sin embargo, su funci√≥n p√∫blica MODLED_command, cuando se recibe el argumento modled_on, cambia el estado de la secuencia a <br>  modled_st_on.  En este estado, el flujo enciende el LED, recuerda el valor inicial del contador global_count y entra en el estado de espera modled_st_wait1.  En este estado, comprueba constantemente el valor actual del contador global_count, y cuando la diferencia entre la cuenta actual y la cuenta inicial es MODLED_BLINK_DELAY_ON, la secuencia cambia al estado modled_st_off.  En este estado, la transmisi√≥n apaga el LED, recuerda el valor actual de la cuenta y cambia al estado modled_st_wait2.  En este estado, el subproceso tambi√©n compara el valor actual del contador global_count con el inicial, y cuando la diferencia es MODLED_BLINK_DELAY_OFF pasa al estado modled_st_on.  Y as√≠ continuar√° hasta que alguien llame a la funci√≥n MODLED_command con el argumento modled_off.  Luego, la funci√≥n cambiar√° el estado de la secuencia a modled_st_clamp.  El hilo apagar√° el LED y pasar√° al estado modled_st_idle. <br><br>  La inicializaci√≥n del flujo modelado comienza en la funci√≥n principal llamando a la funci√≥n MODLED_init ().  Esta funci√≥n inicializa el puerto GPIOC y establece el estado inicial de la secuencia.  Luego, en el bucle, se llama constantemente a la funci√≥n MODLED_control (), que en una iteraci√≥n realiza una verificaci√≥n del estado actual y realiza peque√±as acciones para ello. <br><br>  El flujo de control del puerto serie es id√©ntico. <br><br>  Tiene funciones privadas de inicializaci√≥n de puertos GPIO y m√≥dulo USART1.  Adem√°s, dentro est√° oculto el controlador de interrupciones del m√≥dulo perif√©rico USART1, en el que se almacena el byte recibido actual y el estado de la secuencia se establece en moduart_st_command. <br><br>  Inicialmente, la secuencia de moduart est√° en el estado moduart_st_idle, en el que est√° esperando que se reciba un byte.  Tan pronto como se recibe un byte y se almacena en una variable, el controlador de interrupci√≥n cambia el estado del flujo a moduart_st_command y el flujo verifica el byte recibido.  Si el byte recibido es el comando '0', se llama a la funci√≥n MODLED_command con el argumento modled_off y se devuelve el car√°cter '-'.  Si el byte recibido es el comando '1', se llama a la funci√≥n MODLED_command con el argumento modled_on y se devuelve el car√°cter '*'.  En otros casos, el car√°cter 'E' simplemente se devuelve. <br><br>  La inicializaci√≥n de la secuencia MODUART tambi√©n se produce en el archivo principal, llamando a la funci√≥n MODUART_init ().  Esta funci√≥n inicializa el puerto y el m√≥dulo perif√©rico USART1 y pone la transmisi√≥n en modo de espera.  En el bucle principal, se llama a la funci√≥n de control del flujo MODUART_control (), que verifica el estado actual y ejecuta un peque√±o fragmento de c√≥digo asociado con su procesamiento. <br><br>  Todo el secreto de las aplicaciones cooperativas de subprocesos m√∫ltiples es precisamente crear peque√±as piezas de c√≥digo para cada estado. <br><br>  <b>Global_count variable</b> <br><br>  Probablemente valga la pena una discusi√≥n por separado sobre esta variable global_count. <br><br>  El archivo de inicializaci√≥n <i>startup \ startup_stm32f10x_md.s</i> contiene una tabla de interrupci√≥n del microcontrolador.  Contiene las direcciones de los manejadores para todas las interrupciones perif√©ricas. <br>  y granos.  Sin embargo, las interrupciones en la periferia solo ocurren cuando la periferia se inicializa.  Por lo tanto, inicialmente, los controladores apuntan a ap√©ndices temporales.  Pero los controladores de interrupci√≥n del n√∫cleo Cortex M3 realmente existen y est√°n contenidos en el <i>archivo system \ stm32f10x_it</i> .  Una de esas interrupciones es la interrupci√≥n del temporizador del sistema SysTick.  RTOS utiliza este temporizador para invocar el programador de tareas.  Pero, lo uso para llamar a la funci√≥n TimingDelay_Decrement, que est√° realmente definida en el archivo principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------------------------- //   volatile unsigned long global_count=0; //       SysTick,  //    stm32f10x_it.c void TimingDelay_Decrement(void) { //    global_count++; if (TimingDelay != 0x00) { TimingDelay--; } }</span></span></code> </pre><br>  Al comienzo de la funci√≥n principal est√° configurando la frecuencia del temporizador SysTick a 1 ms.  Por lo tanto <br>  cada mil√©sima de segundo en el controlador de interrupci√≥n SysTick, el contador aumentar√°. <br><br>  Basta recordar los valores de este contador y su diferencia dar√° el intervalo de tiempo entre comprobaciones en milisegundos.  Por lo tanto, un contador puede usarse para soportar intervalos de tiempo en cualquier cantidad de hilos sin llamar a un Retraso de bloqueo. <br><br><h4>  Ep√≠logo </h4><br>  Es posible que existan soluciones m√°s simples para conectar PeripheralLib y los archivos de inicializaci√≥n del reloj inicial.  Por ejemplo, las opciones en la configuraci√≥n del proyecto de otros entornos de desarrollo o constantes que obligan al entorno de desarrollo a cargarlas autom√°ticamente al compilarlas.  Sin embargo, este m√©todo, que cit√© aqu√≠ como ejemplo, es bastante visual en s√≠ mismo y permite, si es necesario, cambiar los par√°metros de inicializaci√≥n del microcontrolador con bastante rapidez.  Por ejemplo, rehaga el reloj desde el generador interno. <br><br>  En comparaci√≥n con otras "luces intermitentes de LED en stm32", que se encuentran en Internet, la m√≠a result√≥ ser bastante engorrosa.  Sin embargo, en una plantilla as√≠, comienzo proyectos nuevos y complejos y pasar 2-5 minutos cre√°ndolo no me parece una p√©rdida tan terrible. <br><br><div class="spoiler">  <b class="spoiler_title">El c√≥digo fuente del archivo modLed.h</b> <div class="spoiler_text">  Archivo ModLed.h <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __MODLED_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __MODLED_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x.h"</span></span></span><span class="hljs-meta"> typedef enum{ modled_off, modled_on, }MODLED_Commands; void MODLED_init(); void MODLED_command(MODLED_Commands aCmd); void MODLED_control(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">El c√≥digo fuente del archivo modLed.c</b> <div class="spoiler_text">  Archivo ModLed.c <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"modLed.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      #define MODLED_BLINK_DELAY_ON 250 #define MODLED_BLINK_DELAY_OFF 250 //   typedef enum{ modled_st_idle, modled_st_on, modled_st_wait1, modled_st_off, modled_st_wait2, modled_st_clamp, }MODLED_States; //  ,    1  . extern unsigned long global_count; static MODLED_States modledState=modled_st_idle; static uint32_t modledStart, modledEnd; /* PC13 - led (Open drain) */ void modled_init_gpio() { //    GPIOC RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); GPIO_DeInit(GPIOC); GPIO_InitTypeDef gpio; GPIO_StructInit(&amp;gpio); /*  Blue Pill    ,   PC13. :  PC13      (3 )           .    . */ //   ,  . gpio.GPIO_Mode=GPIO_Mode_Out_OD; gpio.GPIO_Speed=GPIO_Speed_2MHz; gpio.GPIO_Pin=GPIO_Pin_13; GPIO_Init(GPIOC, &amp;gpio); //   GPIO_WriteBit(GPIOC, GPIO_Pin_13, Bit_SET); } void MODLED_init() { modled_init_gpio(); modledState=modled_st_idle; modledStart=global_count; } //   . void MODLED_command(MODLED_Commands aCmd) { switch(aCmd) { case modled_on: modledState=modled_st_on; break; case modled_off: modledState=modled_st_clamp; break; } } void MODLED_control() { switch(modledState) { case modled_st_idle: break; case modled_st_on: //     GPIO_WriteBit(GPIOC, GPIO_Pin_13, Bit_RESET); //     modledStart=global_count; //       modledState=modled_st_wait1; break; case modled_st_wait1: //    modledEnd=global_count; //           if((modledEnd-modledStart)&gt;=MODLED_BLINK_DELAY_ON) { //         modledState=modled_st_off; } break; case modled_st_off: //   GPIO_WriteBit(GPIOC, GPIO_Pin_13, Bit_SET); //     modledStart=global_count; //       modledState=modled_st_wait2; break; case modled_st_wait2: //    modledEnd=global_count; //           if((modledEnd-modledStart)&gt;=MODLED_BLINK_DELAY_OFF) { //         modledState=modled_st_on; } break; case modled_st_clamp: //       GPIO_WriteBit(GPIOC, GPIO_Pin_13, Bit_SET); modledState=modled_st_idle; break; default: modledState=modled_st_idle; } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">El c√≥digo fuente del archivo modUart.h</b> <div class="spoiler_text">  Archivo ModUart.h <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __MOD_UART_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __MOD_UART_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x.h"</span></span></span><span class="hljs-meta"> void MODUART_init(); void MODUART_control(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">El c√≥digo fuente del archivo modUart.c</b> <div class="spoiler_text">  Archivo ModUart.c <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"modUart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"modLed.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODUART_BAUDRATE 115200 typedef enum{ moduart_st_idle, moduart_st_command, }MODUART_STATES; static MODUART_STATES moduartState=moduart_st_idle; static uint16_t moduartCmd=0; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PA9 UART1_TX PA10 UART1_RX */</span></span></span><span class="hljs-meta"> void moduart_init_gpio() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); //    GPIOA RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitTypeDef gpio; GPIO_StructInit(&amp;gpio); gpio.GPIO_Mode=GPIO_Mode_AF_PP; gpio.GPIO_Speed=GPIO_Speed_2MHz; gpio.GPIO_Pin=GPIO_Pin_9; GPIO_Init(GPIOA, &amp;gpio); gpio.GPIO_Mode=GPIO_Mode_IN_FLOATING; gpio.GPIO_Pin=GPIO_Pin_10; GPIO_Init(GPIOA, &amp;gpio); } void moduart_init_uart1() { //     UART1 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); USART_InitTypeDef uart; USART_StructInit(&amp;uart); uart.USART_BaudRate=MODUART_BAUDRATE; uart.USART_HardwareFlowControl=USART_HardwareFlowControl_None; uart.USART_Mode=USART_Mode_Rx|USART_Mode_Tx; uart.USART_Parity=USART_Parity_No; uart.USART_StopBits=USART_StopBits_1; uart.USART_WordLength=USART_WordLength_8b; USART_Init(USART1, &amp;uart); //     // --     USART1 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //         NVIC_EnableIRQ(USART1_IRQn); //   USART1. USART_Cmd(USART1, ENABLE); } //    USART1 void USART1_IRQHandler() { //    if(USART_GetITStatus(USART1, USART_IT_RXNE)!=RESET) { //    USART_ClearITPendingBit(USART1, USART_IT_RXNE); //    moduartCmd = USART_ReceiveData(USART1); moduartState = moduart_st_command; } } void moduart_processCmd() { //   uint16_t r = 'E'; switch(moduartCmd) { //    case '0': { MODLED_command(modled_off); r = '-'; } break; //    case '1': { MODLED_command(modled_on); r = '*'; } break; } //    USART_SendData(USART1, r); moduartCmd=0; } void MODUART_init() { moduartState=moduart_st_idle; moduart_init_gpio(); moduart_init_uart1(); } void MODUART_control() { switch(moduartState) { case moduart_st_idle: break; case moduart_st_command: moduart_processCmd(); moduartState=moduart_st_idle; break; default: moduartState=moduart_st_idle; } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">El c√≥digo fuente del archivo main.c</b> <div class="spoiler_text">  Archivo main.c <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"modUart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"modLed.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Imported value static __IO uint32_t TimingDelay; RCC_ClocksTypeDef RCC_Clocks; int main() { RCC_GetClocksFreq(&amp;RCC_Clocks); //   SysTick      SysTick_Config(RCC_Clocks.HCLK_Frequency / 1000); //    MODLED_init(); //     MODUART_init(); do{ //      MODLED_control(); //      MODUART_control(); }while(1); #pragma diag_suppress=Pe111 return 0; } //------------------------------------------------------------------- void Delay(__IO uint32_t nCount) { TimingDelay = nCount; while(TimingDelay != 0); } //------------------------------------------------------------------- //   volatile unsigned long global_count=0; //       SysTick,  //    stm32f10x_it.c void TimingDelay_Decrement(void) { //    global_count++; if (TimingDelay != 0x00) { TimingDelay--; } } //------------------------------------------------------------------- #ifdef USE_FULL_ASSERT void assert_failed(uint8_t *file, uint32_t line) { while(1){} } #endif</span></span></span></span></code> </pre><br></div></div><br>  El proyecto completo se puede descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde aqu√≠</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es407045/">https://habr.com/ru/post/es407045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es407035/index.html">En Rusia, m√°s caro. C√≥mo ahorrar dinero comprando un iPhone 8</a></li>
<li><a href="../es407037/index.html">Silicon Valley: lo que ha cambiado en tres a√±os, parte 2</a></li>
<li><a href="../es407039/index.html">Lockheed Martin revela plan para la estaci√≥n orbital marciana y el m√≥dulo de aterrizaje</a></li>
<li><a href="../es407041/index.html">Agua caliente todo el tiempo con el hervidor de agua inteligente Xiaomi MiJia</a></li>
<li><a href="../es407043/index.html">Dr. Fraudster: el ascenso y la ca√≠da de un famoso cient√≠fico que enga√±√≥ a casi todos</a></li>
<li><a href="../es407047/index.html">IP57 vs IPX8, o el √∫nico lector verdaderamente "todoterreno" del mundo</a></li>
<li><a href="../es407049/index.html">Malas noticias: los peces comen mucho pl√°stico; pero a√∫n peor es que les puede gustar</a></li>
<li><a href="../es407051/index.html">El d√≠a que la Tierra discuti√≥</a></li>
<li><a href="../es407053/index.html">Un poco sobre el calor interno.</a></li>
<li><a href="../es407055/index.html">¬øTe mueves m√°s r√°pido que la velocidad de la luz? - nada es m√°s f√°cil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>