<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏼 🤵🏽 👩🏼‍🤝‍👨🏿 Gambaran keseluruhan pengujian unit 🌵 ⏏️ ➕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini bukan panduan tentang karakter apa yang perlu Anda masukkan dalam editor kode untuk mendapatkan tes unit. Ini adalah makanan untuk pikiran, yang h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gambaran keseluruhan pengujian unit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/412695/"><img src="https://habrastorage.org/webt/di/az/zt/diazzt3uova8gflxtil7ecuxggu.png"><br><br>  Ini bukan panduan tentang karakter apa yang perlu Anda masukkan dalam editor kode untuk mendapatkan tes unit.  Ini adalah makanan untuk pikiran, yang harus dikonsumsi <b>sebelum</b> mengambil tindakan ini. <br><br>  Topik pengujian unit tidak sesederhana kelihatannya.  Banyak dari kita pengembang datang ke unit testing di bawah tekanan dari pelanggan, karyawan, kolega, idola mereka, dan sebagainya.  Kami dengan cepat memahami nilainya, dan, setelah menyelesaikan persiapan teknis, kami melupakan gambaran umum, jika sama sekali, sama sekali.  Pada artikel ini, saya akan membahas secara singkat tentang apa itu pengujian unit, dan apa yang tidak, baik secara umum maupun dalam PHP, dan pada saat yang sama saya akan menjelaskan tempat pengujian unit apa dalam lingkup QA. <br><a name="habracut"></a><br><h2>  Apa itu pengujian? </h2><br>  Sebelum mempelajari tes unit, Anda perlu mempelajari teori pengujian itu sendiri agar tidak membuat kesalahan seperti yang dilakukan oleh penulis dari salah satu kerangka kerja PHP yang paling populer: mereka menunjukkan tes integrasi di situs web mereka dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyebutnya</a> tes unit.  Tidak, Laravel, ini bukan tes unit.  Meskipun ini tidak menghentikan saya, saya masih mencintai kerangka ini. <br><br>  Pengujian perangkat lunak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">didefinisikan</a> sebagai "penyelidikan yang dilakukan untuk memberikan informasi kepada pihak yang berkepentingan tentang kualitas produk."  Ini bertentangan dengan "pengujian perangkat lunak adalah pemborosan anggaran proyek oleh pengembang yang tidak melakukan hal penting dan kemudian meminta lebih banyak waktu dan uang, karena" tidak ada "yang bisa sangat mahal."  Tidak ada yang baru di sini. <br><br>  Inilah sejarah singkat saya untuk menjadi ujian: <br><br><ul><li>  1822 - Mesin perbedaan (Charles Babbage). </li><li>  1843 - Mesin analitik (Ada Lovelace). </li><li>  1878 - Edison memperkenalkan istilah "bug." </li><li>  1957 - Pengujian dan debugging program (Charles Baker). </li><li>  1958 - Tim pengujian perangkat lunak pertama (Gerald Weinberg). </li><li>  1968 - Crisis PO (Friedrich Bauer). </li><li>  1970-an - Model air terjun, model relasional, dekomposisi, analisis kritis ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Walkthrough</a> ), desain dan inspeksi kode, kualitas dan metrik, pola desain. </li><li>  1980-an - Analisis CRUD, arsitektur sistem, autotesting, model-V, keandalan, biaya kualitas, metode penggunaan, pola desain OOP. </li><li>  1990-an - Scrum, pengujian kegunaan, MoSCoW, pengujian heuristik, otomatisasi dan pengujian perangkat lunak. </li></ul><br>  Jika Anda berhubungan dengan generasi milenium seperti saya, Anda mungkin kagum bahwa tim penguji ada PANJANG sebelum Anda dilahirkan.  Berhentilah sejenak, tarik napas, hembuskan napas, tenang. <br>  Sejarah menunjukkan bagaimana jenis pengujian yang dianggap "cukup baik" untuk pihak yang berkepentingan berubah dari waktu ke waktu.  Perkiraan fase yang dipandu selama pengujian: <br><br><ul><li>  ... - 1956 debugging </li><li>  1957 - 1978 Demonstrasi </li><li> 1979 - 1982 kehancuran </li><li>  Perkiraan 1983 - 1987 </li><li>  1988 - ... pencegahan </li></ul><br>  Oleh karena itu, pengujian unit diperlukan untuk <b>mencegah</b> perbedaan antara proyek dan implementasi. <br><br><h2>  Apa sebenarnya pengujian itu? </h2><br>  Ada beberapa klasifikasi pengujian perangkat lunak.  Untuk lebih memahami tempat pengujian unit, saya hanya akan menyebutkan pendekatan yang paling luas. <br><br>  Tes adalah: statis dan dinamis, "kotak" (kotak putih, kotak hitam, kotak abu-abu), level dan tipe.  Setiap pendekatan menggunakan kriteria klasifikasi yang berbeda. <br><br><h2>  Pengujian statis dan dinamis </h2><br>  Pengujian statis dilakukan tanpa eksekusi kode.  Ini termasuk proofreading, verifikasi, revisi kode (ketika mengamati pekerjaan pemrograman pasangan lain), analisis kritis, inspeksi, dan sebagainya. <br><br>  Pengujian dinamis untuk mendapatkan hasil yang benar membutuhkan eksekusi kode.  Misalnya, untuk <b>tes unit</b> , integrasi, sistem, penerimaan, dan tes lainnya.  Artinya, pengujian dilakukan dengan menggunakan data dinamis, input dan output. <br><br><h2>  Pendekatan kotak </h2><br>  Menurut pendekatan ini, semua pengujian perangkat lunak dibagi menjadi tiga jenis kotak: <br><br><ul><li>  Pengujian <b>kotak putih</b> memverifikasi struktur dan modul internal, mengabaikan fungsionalitas yang diharapkan untuk pengguna akhir.  Ini bisa berupa pengujian API, injeksi kesalahan, <b>pengujian unit</b> , pengujian integrasi. </li><li>  Pengujian <b>black box</b> lebih tertarik pada <b>apa yang dilakukan</b> perangkat lunak, dan bukan <b>bagaimana</b> melakukannya.  Ini berarti bahwa penguji tidak diharuskan untuk memahami objek pengujian atau memahami cara kerjanya di bawah tenda.  Jenis pengujian ini ditujukan untuk pengguna akhir, pengalaman mereka berinteraksi dengan antarmuka yang terlihat.  Kotak hitam meliputi pengujian berbasis model, pengujian penggunaan, tabel transisi negara, pengujian spesifikasi, dll. </li><li>  Pengujian tipe " <b>kotak abu-abu</b> " dirancang dengan pengetahuan tentang algoritma perangkat lunak dan struktur data (kotak putih), tetapi dilakukan di tingkat pengguna (kotak hitam).  Ini termasuk pengujian regresi dan pengujian pola. </li></ul><br>  Sekarang, untuk membingungkan Anda, saya akan mengatakan bahwa <b>pengujian unit</b> juga dapat berlaku untuk "kotak hitam", karena Anda dapat memahami modul yang sedang diuji, tetapi tidak untuk keseluruhan sistem.  Meskipun bagi saya itu masih merupakan "kotak putih", dan saya sarankan Anda setuju dengan ini. <br><br><h2>  Tingkat tes </h2><br>  Jumlah mereka bervariasi, biasanya dalam kisaran 4 hingga 6, dan mereka semua berguna.  Nama-nama juga bisa berbeda, tergantung pada budaya yang diadopsi oleh perusahaan, Anda mungkin tahu tes "integrasi" sebagai "fungsional", tes "sistem" sebagai "otomatis", dan sebagainya.  Untuk kesederhanaan, saya akan menjelaskan 5 level: <br><br><ol><li>  <b>Pengujian unit</b> </li><li>  Pengujian Integrasi. </li><li>  Menguji antarmuka komponen. </li><li>  Pengujian sistem. </li><li>  Pengujian penerimaan operasional. </li></ol><br>  <b>Pengujian unit menguji</b> fungsionalitas potongan kode tertentu, biasanya satu fungsi pada satu waktu.  Pengujian integrasi memeriksa antarmuka antara komponen sehingga modul yang dirakit bersama membentuk sistem yang berfungsi sebagaimana dimaksud.  Ini adalah poin penting, karena sejumlah besar tes, yang disebut tes unit, sebenarnya adalah tes integrasi, dan pengembang menganggapnya sebagai modul.  Jika Anda bermaksud menggunakan beberapa modul - ini sedang menguji integrasi di antara mereka, dan bukan modul itu sendiri.  Antarmuka komponen pengujian memeriksa data yang ditransfer antara modul yang berbeda.  Sebagai contoh, kami menerima data dari modul 1 - diperiksa - ditransfer ke modul 2 - diperiksa.  Pengujian sistem adalah pengujian ujung-ke-ujung untuk memverifikasi kepatuhan dengan semua persyaratan.  Pengujian penerimaan operasional dilakukan untuk memverifikasi kesiapan operasional.  Itu tidak fungsional, hanya kemudahan servis dari layanan yang diperiksa, apakah ada subsistem yang merusak lingkungan dan layanan lainnya. <br><br><h2>  Jenis Pengujian </h2><br>  Setiap jenis pengujian, terlepas dari levelnya, juga dapat dibagi menjadi jenis lain.  Ada lebih dari 20 tipe umum.  Yang paling umum: <br><br><ul><li>  <b>Pengujian regresi</b> . </li><li>  Tes penerimaan. </li><li>  Pengujian asap </li><li>  Uat </li><li>  <b>Pengujian yang merusak</b> . </li><li>  Pengujian kinerja. </li><li>  <b>Pengujian berkelanjutan</b> . </li><li>  Pengujian kegunaan. </li><li>  Pengujian keamanan. </li></ul><br>  Dari namanya jelas mengapa pengujian jenis ini atau itu dimaksudkan.  Bold adalah unit test dalam PHP.  Jika Anda benar-benar ingin, maka Anda dapat menerapkan masing-masing persyaratan ini ke unit testing.  Namun, variasi utama dari tes unit adalah tes regresi, yang memeriksa apakah semua modul sistem dieksekusi dengan benar setelah membuat perubahan pada kode. <br><br>  Sekarang Anda tahu bahwa tes unit bersifat dinamis, termasuk dalam kelas "kotak putih", dilakukan pada level modul, merupakan tes regresi, tetapi tes modular dapat dipahami sebagai banyak jenis tes.  Jadi apa sebenarnya tes unit? <br><br><h2>  Apa itu pengujian unit? </h2><br>  Model-V adalah representasi grafis dari tingkat di atas, jenis dan tujuannya dalam siklus hidup pengembangan perangkat lunak. <br><br><img src="https://habrastorage.org/webt/-z/sk/ee/-zskeemvq28-zgepwlt7cbd6xjw.jpeg"><br><br>  Setelah memeriksa dan menyetujui persyaratan terperinci untuk produk, ketika mereka mulai menulis kode, tes unit menjadi garis pertahanan pertama terhadap segala ketidakkonsistenan.  Oleh karena itu, perusahaan yang memahami apa yang mereka lakukan memaksa pengembang untuk menggunakan tes unit atau bahkan TDD, karena jauh lebih murah untuk memperbaiki bug pada tahap awal daripada yang lebih baru. <br><br>  Dan ini adil.  Tes unit memiliki banyak keunggulan.  Mereka adalah: <br><br><ul><li>  Isolasi setiap bagian dari program dan periksa kebenarannya. </li><li>  Bantu mendeteksi masalah sejak dini. </li><li>  Mereka membuat pengembang berpikir dalam hal input, output, dan kondisi yang salah. </li><li>  Mereka memberikan kode tampilan yang mudah untuk pengujian, memfasilitasi refactoring di masa depan. </li><li>  Sederhanakan integrasi Modul kerja (!). </li><li>  Ganti sebagian dokumentasi teknis. </li><li>  Terpaksa memisahkan antarmuka dari implementasi. </li><li>  Mereka membuktikan bahwa kode modul berfungsi seperti yang diharapkan (setidaknya secara matematis). </li><li>  Dapat digunakan sebagai suite uji regresi tingkat rendah. </li><li>  Menunjukkan kemajuan dalam integrasi sistem yang tidak lengkap. </li><li>  Kurangi biaya perbaikan bug (dengan TDD - bahkan lebih). </li><li>  Mereka memungkinkan Anda untuk meningkatkan arsitektur aplikasi dengan menentukan tanggung jawab modul. </li><li>  Jika Anda dapat mengujinya, maka Anda dapat melampirkan ke sistem Anda. </li><li>  Pengujian unit MENYENANGKAN! </li></ul><br>  Namun, ada beberapa batasan yang Anda pikirkan, mungkin ketika membaca daftar ini: <br><br><ul><li>  Pengujian unit tidak menangkap kesalahan integrasi. </li><li>  Setiap ekspresi Boolean membutuhkan setidaknya dua tes, dan jumlahnya tumbuh dengan cepat. </li><li>  Tes unit sama buggy dengan kode yang mereka uji. </li><li>  Menghubungkan tes ke beberapa kerangka kerja atau pustaka tertentu dapat membatasi alur kerja. </li><li>  Sebagian besar tes ditulis setelah pengembangan selesai.  Menyedihkan.  Gunakan TDD! </li><li>  Mungkin setelah sedikit refactoring, sistem akan bekerja seperti sebelumnya, tetapi pengujiannya akan gagal. </li><li>  Biaya pengembangan terus meningkat. </li><li>  Human error: mengomentari tes yang rusak. </li><li>  Human error: menambahkan solusi ke kode khusus untuk lulus tes unit. </li></ul><br>  Yang terakhir paling banyak membunuh saya.  (Hampir) di setiap proyek, langsung dalam kode sumber aplikasi yang bekerja, saya menemukan baris seperti "jika itu adalah unit test, memuat database SQLite pengganti, jika tidak memuat database lain", atau "jika itu adalah unit test, jangan kirim email, jika tidak kirim ”, dan seterusnya.  Jika aplikasi Anda memiliki arsitektur yang buruk, jangan berpura-pura bahwa Anda dapat memperbaiki perangkat lunak yang buruk dengan tes lulus yang baik, itu tidak akan menjadi lebih baik dari ini. <br><br>  Saya sering berdiskusi dengan kolega dan klien apakah unit test yang bagus itu.  Dia: <br><br><ul><li>  Cepat </li><li>  Otomatis. </li><li>  Sepenuhnya mengontrol semua dependensinya. </li><li>  Dapat diandalkan: dapat diluncurkan dalam urutan apa pun, terlepas dari tes lainnya. </li><li>  Ini hanya dapat dijalankan di memori (tidak ada interaksi dengan database, baca / tulis dalam sistem file). </li><li>  Selalu mengembalikan hasil tunggal. </li><li>  Nyaman untuk membaca dan iringan. </li><li>  Tidak menguji konfigurasi SUT (sistem sedang diuji). </li><li>  Memiliki TUNGGAL TUNGGAL yang jelas. </li><li>  Itu bernama baik (dan cukup dimengerti untuk menghindari debugging hanya demi mencari tahu apa yang gagal). </li></ul><br>  Bagi mereka yang menyeringai setelah membaca "otomatis": Saya tidak bermaksud mengintegrasikan PHPUnit atau JUnit ke dalam pipa CI.  Intinya adalah bahwa jika Anda mengubah kode, simpan dan jangan tahu apakah modul lulus tes mereka, maka mereka tidak otomatis, tetapi harus.  Pilihan yang menang adalah pelacakan file. <br><br><h2>  Apa yang harus dikenai pengujian unit? </h2><br>  Dalam sistem normal, tes unit perlu ditulis untuk: <br><br><ul><li>  Modul - bagian yang tidak dapat dipisahkan dari sistem yang melakukan satu tugas (fungsi, metode, kelas). </li><li>  Metode publik. </li><li>  Metode yang dilindungi, tetapi hanya dalam kasus yang jarang dan ketika tidak ada yang melihat. </li><li>  Bug dan perbaikannya. </li></ul><br>  Definisi uji unit tergantung pada pengembang yang menulis kode.  Dalam PHP, ini hampir selalu merupakan metode atau fungsi kelas, karena itu adalah <b>bagian dari perangkat lunak yang tidak terpisahkan yang masuk akal sendiri</b> .  Beberapa kali saya melihat bagaimana pengembang menggunakan array miniclasses satu metode sebagai modul tunggal.  Ini masuk akal jika fungsionalitas minimal membutuhkan banyak objek. <br><br>  Jadi Anda sendiri dapat menentukan modul apa yang cocok untuk Anda.  Atau Anda dapat menguji metode satu per satu, membuat hidup lebih mudah bagi pria yang kemudian akan bekerja dengan kode tersebut. <br><br>  Jika Anda tidak melakukan pengujian unit, saya mengusulkan untuk melakukan ini setelah bug besar berikutnya.  Periksa metode mana yang akan dikaitkan, tulis tes gagal dengan argumen dan hasil yang benar, perbaiki bug, jalankan uji unit lagi.  Jika dilewatkan, Anda dapat yakin bahwa bug ini harus diperbaiki untuk terakhir kalinya (dengan mempertimbangkan skenario input spesifik Anda). <br><br>  Pendekatan ini membuat pengujian unit lebih mudah dipahami.  Analisis setiap metode secara terpisah.  Penyedia data dapat membantu menentukan input dan output untuk setiap skenario yang mungkin muncul di pikiran Anda, jadi apa pun yang terjadi, Anda akan tahu apa yang diharapkan. <br><br><h2>  Apa yang TIDAK perlu diuji </h2><br>  Agak sulit untuk menentukan bahwa Anda tidak perlu menguji.  Saya mencoba menyusun daftar elemen yang <b>tidak perlu</b> dikenai pengujian unit: <br><br><ul><li>  Fungsionalitas di luar ruang lingkup modul (!) </li><li>  Integrasi modul dengan modul lain (!) </li><li>  Perilaku yang tidak diinsulasi (dependensi yang tidak dapat digerakkan, database nyata, jaringan) </li><li>  Metode pribadi yang aman. </li><li>  Metode statis. </li><li>  Perpustakaan eksternal. </li><li>  Kerangka kerja Anda. </li></ul><br>  Saya yakin bahwa pengujian unit tidak boleh diterapkan pada hal-hal di atas, kecuali untuk metode statis.  Saya suka berargumen bahwa statis, pada dasarnya, berarti proseduralitas, dan dalam banyak kasus proseduralitas bersifat global.  Jika metode statis memanggil metode statis lain, maka ketergantungan ini tidak dapat ditimpa.  Ini berarti bahwa Anda sekarang menguji secara terpisah.  Dan kemudian ini bukan lagi pengujian unit.  Di sisi lain, ini adalah bagian dari kode yang dapat hidup sendiri, ia memiliki tujuan, dan perlu diuji untuk memastikan bahwa tidak peduli bagian mana dari sistem bodoh ini yang diuji bagian dari kode panggilan, ia tidak akan rusak.  Oleh karena itu, saya percaya bahwa Anda dapat menguji metode statis jika Anda yakin bahwa hasil tes Anda tidak dapat diubah oleh tes lain, dan bahwa bahasa atau kerangka kerja memungkinkan Anda untuk menguji secara asli. <br><br><h2>  Bagaimana cara menulis unit test? </h2><br><ul><li>  Tulis kode yang sesuai untuk pengujian unit, lalu ujilah. </li><li>  Tulis kode yang sesuai untuk pengujian unit, lalu ujilah. </li><li>  Tulis kode yang sesuai untuk pengujian unit, lalu ujilah. </li></ul><br>  Jika "maka uji" itu tidak cukup, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laracasts.com</a> memiliki video yang sangat bagus tentang pengujian unit PHP.  Ada banyak situs yang didedikasikan untuk tugas yang sama dalam bahasa lain.  Saya tidak melihat alasan untuk menjelaskan bagaimana saya melakukan pengujian unit, karena alat berubah cukup cepat, dan ketika Anda membaca teks ini, saya dapat beralih dari PHPUnit ke Kahlan.  Atau tidak.  Siapa tahu. <br><br>  Tetapi untuk menjawab pertanyaan pertama (bagaimana menulis kode yang cocok untuk pengujian unit) jauh lebih mudah, dan situasinya tidak banyak berubah seiring waktu: <br><br><ul><li>  <b>PADAT</b> </li><li>  <b>KERING</b> </li><li>  Kurangnya kata kunci <b>baru</b> di konstruktor. </li><li>  Tidak adanya <b>loop</b> dalam konstruktor (dan transisi, jika ditentukan). </li><li>  Kurangnya metode statis, parameter, kelas. </li><li>  Kurangnya metode setup (): objek harus diinisialisasi penuh setelah konstruksi. </li><li>  Kurangnya singleton (status global) dan antipattern lain yang tidak dapat diuji. </li><li>  Kurangnya objek mahakuasa (objek Tuhan). </li><li>  Kurangnya kelas dengan fungsionalitas campuran (kelas perhatian campuran). </li><li>  Tidak ada dependensi tersembunyi. </li></ul><br>  Sekarang, dengan mengetahui apa itu unit test dan apa yang bukan, apa yang Anda butuhkan dan apa yang tidak perlu Anda uji, tempat tes apa yang diambil dalam siklus hidup pengembangan perangkat lunak, akan lebih mudah bagi Anda untuk mengimplementasikannya.  Masih menemukan kerangka atau pustaka yang Anda sukai.  Jika ragu, ambil kerangka / bahasa standar de facto. <br><br>  Kesimpulannya: unit test sangat penting bagi pengembang dan bisnis.  Mereka perlu ditulis, ada metode terbukti yang akan membantu Anda dengan mudah menutupi modul dengan tes, terutama dengan menyiapkan modul itu sendiri.  Tetapi semua teknik ini tidak masuk akal tanpa sepengetahuan teori pengujian yang dijelaskan dalam artikel ini.  Anda harus dapat membedakan tes unit dari tes jenis lain.  Dan ketika Anda memiliki pemahaman yang jelas di kepala Anda, maka akan menjadi lebih mudah bagi Anda untuk menulis tes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412695/">https://habr.com/ru/post/id412695/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412685/index.html">Unity GPU Path Tracing - Bagian 2</a></li>
<li><a href="../id412687/index.html">Terapkan IdM. Prosedur dan sarana teknis - dari dasar hingga IdM</a></li>
<li><a href="../id412689/index.html">Analitik TI prediktif merampingkan pemantauan aplikasi terdistribusi</a></li>
<li><a href="../id412691/index.html">Lelucon 5 tahun di Facebook atau sejarah forensik</a></li>
<li><a href="../id412693/index.html">Tulis kode yang mudah dihapus dan didebug</a></li>
<li><a href="../id412697/index.html">IoT sebagai bidang studi universal untuk universitas teknis multidisiplin</a></li>
<li><a href="../id412699/index.html">Penjelasan sederhana tentang prinsip-prinsip SOLID</a></li>
<li><a href="../id412701/index.html">Pemanas paling cerdas</a></li>
<li><a href="../id412703/index.html">Pada konferensi dengan Veeam: ulasan tentang VeeamON 2018 dan undangan untuk Forum VeeamON di Moskow</a></li>
<li><a href="../id412705/index.html">Meretas sistem: bagaimana kami mengubah pemilihan dan adaptasi pengembang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>