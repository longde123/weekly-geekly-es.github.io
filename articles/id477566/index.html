<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧 👩🏾‍🔬 👨‍🎤 Huawei Cloud: hari ini berawan di PVS-Studio 🈚️ 💦 🙏🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di abad ini, semua orang telah mendengar layanan cloud. Banyak perusahaan telah menguasai segmen pasar ini dan menciptakan layanan cloud mereka di ber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Huawei Cloud: hari ini berawan di PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/477566/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ac/bd2/47b/2acbd247b999e7f8e9e45f77181e2f06.png" alt="Gambar 2"></div><br>  Di abad ini, semua orang telah mendengar layanan cloud.  Banyak perusahaan telah menguasai segmen pasar ini dan menciptakan layanan cloud mereka di berbagai arah.  Tim kami juga baru-baru ini tertarik pada layanan ini dalam hal mengintegrasikan penganalisa kode PVS-Studio dengan mereka.  Kami pikir pembaca reguler kami sudah menebak jenis proyek apa yang akan kami periksa kali ini.  Pilihannya jatuh pada kode layanan cloud dari Huawei. <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Jika Anda mengikuti tim PVS-Studio, Anda mungkin memperhatikan bahwa baru-baru ini kami sangat tertarik dengan teknologi cloud.  Kami telah menerbitkan beberapa artikel yang berkaitan dengan topik ini: <br><br><ul><li>  <a href="https://www.viva64.com/ru/b/0670/">PVS-Studio pergi ke awan: Azure DevOps</a> </li><li>  <a href="https://www.viva64.com/ru/b/0636/">PVS-Studio pergi ke awan: Travis CI</a> </li><li>  <a href="https://www.viva64.com/ru/b/0676/">PVS-Studio pergi ke awan: CircleCI</a> </li><li>  <a href="https://www.viva64.com/ru/b/0686/">PVS-Studio beralih ke cloud: GitLab CI / CD</a> </li></ul><br>  Jadi, ketika saya mengambil proyek lain yang menarik untuk artikel yang akan datang, saya menerima tawaran pekerjaan dari <a href="https://www.huawei.com/en/">Huawei</a> melalui pos.  Ketika mengumpulkan informasi tentang perusahaan ini, ternyata mereka memiliki layanan cloud sendiri, tetapi yang utama adalah bahwa kode sumber layanan ini tersedia secara bebas di GitHub.  Ini adalah alasan utama untuk memilih perusahaan ini untuk artikel ini.  Seperti kata seorang bijak Tiongkok: "Kecelakaan tidak disengaja." <br><br>  Sekarang sedikit tentang analisa kami.  PVS-Studio adalah penganalisa kode statis yang mengidentifikasi kesalahan dan kerentanan dalam kode sumber program yang ditulis dalam C, C ++, C # dan Java.  Alat analisa bekerja pada platform Windows, Linux dan macOS.  Selain plugin untuk lingkungan pengembangan klasik seperti Visual Studio atau IntelliJ IDEA, penganalisa memiliki kemampuan untuk berintegrasi dengan SonarQube dan Jenkins: <br><br><ul><li>  <a href="https://www.viva64.com/ru/m/0037/">Integrasi hasil analisis PVS-Studio ke SonarQube</a> </li><li>  <a href="https://www.viva64.com/ru/m/0048/">Luncurkan PVS-Studio di Jenkins</a> </li></ul><br><h2>  Analisis proyek </h2><br>  Dalam proses mencari informasi untuk artikel tersebut, saya menemukan bahwa Huawei memiliki <a href="https://developer.huaweicloud.com/en-us">pusat pengembang</a> tempat Anda dapat memperoleh informasi, panduan, dan kode sumber untuk layanan cloud mereka.  Berbagai bahasa pemrograman digunakan untuk membuat layanan ini, tetapi bahasa seperti Go, Java, dan Python ternyata menjadi yang paling populer. <br><br>  Karena saya berspesialisasi dalam Jawa, proyek-proyek tersebut dipilih sesuai dengan itu.  Sumber proyek yang dianalisis dalam artikel dapat diperoleh di <a href="https://github.com/huaweicloud/">huaweicloud</a> repositori GitHub. <br><br>  Untuk menganalisis proyek, saya hanya perlu melakukan beberapa tindakan: <br><br><ul><li>  Dapatkan proyek dari repositori; </li><li>  Gunakan <a href="https://www.viva64.com/ru/m/0044/">instruksi</a> untuk memulai penganalisis Java dan memulai analisis pada masing-masing proyek. </li></ul><br>  Setelah menganalisis proyek, kami berhasil memilih hanya tiga yang ingin saya perhatikan.  Ini disebabkan oleh fakta bahwa ukuran proyek Jawa yang tersisa terlalu kecil. <br><br>  Hasil analisis proyek (jumlah peringatan dan jumlah file): <br><br><ul><li>  <a href="https://github.com/huaweicloud/huaweicloud-sdk-java">huaweicloud-sdk-java</a> : 31 - Tinggi, 2 - Sedang dan 16 - Rendah, 2.700+ file. </li><li>  <a href="https://github.com/huaweicloud/huaweicloud-dis-agent">huaweicloud-dis-agent</a> : 7 - Tinggi, 6 - Sedang dan 6 - Rendah, 100+ file. </li><li>  <a href="https://github.com/huaweicloud/huaweicloud-sdk-java-dis">huaweicloud-sdk-java-dis</a> : 15 - Tinggi, 6 - Sedang dan 16 - Rendah, 270+ file. </li></ul><br>  Ada beberapa peringatan, jadi secara umum kita dapat mengatakan tentang kualitas kode yang baik.  Selain itu, tidak semua operasi adalah kesalahan yang valid.  Ini disebabkan oleh fakta bahwa penganalisa kadang-kadang tidak memiliki informasi yang cukup untuk membedakan kode yang benar dari yang salah.  Oleh karena itu, diagnostik penganalisa ditingkatkan setiap hari dengan bantuan informasi yang diterima dari pengguna.  Lihat juga artikel " <a href="https://www.viva64.com/ru/b/0488/">Bagaimana dan mengapa analisa statis melawan positif palsu</a> ." <br><br>  Dalam proses menganalisis proyek, saya memilih peringatan yang paling menarik, yang akan saya bahas dalam artikel ini. <br><br><h2>  Urutan inisialisasi lapangan </h2><br>  Siklus inisialisasi Kelas <a href="https://www.viva64.com/ru/w/v6050/">V6050</a> hadir.  Inisialisasi 'INSTANCE' muncul sebelum inisialisasi 'LOG'.  UntrustedSSL.java (32), UntrustedSSL.java (59), UntrustedSSL.java (33) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UntrustedSSL INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UntrustedSSL(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(UntrustedSSL.class); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { LOG.error(t.getMessage(), t); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Jika ada pengecualian terjadi dalam konstruktor kelas <i>UntrustedSSL</i> , informasi tentang pengecualian ini dicatat di <i>blok tangkap</i> menggunakan <i>LOG</i> logger.  Namun, karena urutan inisialisasi bidang statis, <i>LOG</i> pada saat inisialisasi bidang <i>INSTANCE</i> belum diinisialisasi.  Oleh karena itu, ketika mencatat informasi pengecualian di konstruktor, <i>NullPointerException</i> akan dilempar.  Pengecualian ini adalah penyebab <i>pengecualian ExceptionInInitializerError</i> lain yang dilemparkan jika pengecualian terjadi saat menginisialisasi bidang statis.  Semua yang diperlukan untuk menyelesaikan masalah yang dijelaskan adalah menempatkan inisialisasi <i>LOG</i> sebelum inisialisasi <i>INSTANCE</i> . <br><br><h2>  Kesalahan ketik yang tak terlihat </h2><br>  <a href="https://www.viva64.com/ru/w/v6005/">V6005</a> Variabel 'this.metricSchema' ditugaskan untuk dirinya sendiri.  OpenTSDBSchema.java (72) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenTSDBSchema</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JsonProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"metric"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SchemaField&gt; metricSchema; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMetricsSchema</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;SchemaField&gt; metricsSchema)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.metricSchema = metricSchema; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } public void setMetricSchema(List&lt;SchemaField&gt; metricSchema) { this.metricSchema = metricSchema; } .... }</span></span></code> </pre> <br>  Kedua metode mengatur bidang <i>metricSchema</i> , tetapi nama metode berbeda dengan karakter seseorang.  Programmer menamai argumen metode ini sesuai dengan nama metode tersebut.  Akibatnya, pada baris yang ditunjukkan oleh penganalisa, bidang <i>metricSchema</i> ditugaskan untuk dirinya sendiri, dan argumen dari metode <i>metricsSchema</i> tidak digunakan. <br><br>  <a href="https://www.viva64.com/ru/w/v6005/">V6005</a> Variabel 'menangguhkan' ditugaskan untuk dirinya sendiri.  SuspendTransferTaskRequest.java (77) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuspendTransferTaskRequest</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> suspend; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSuspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> suspend)</span></span></span><span class="hljs-function"> </span></span>{ suspend = suspend; } .... }</code> </pre> <br>  Berikut adalah kesalahan dangkal yang terkait dengan kecerobohan, yang menyebabkan penugasan argumen itu sendiri terjadi.  Akibatnya, nilai argumen yang tiba tidak akan ditugaskan ke bidang <i>menangguhkan</i> , seperti tersirat.  Dengan benar: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSuspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> suspend)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.suspend = suspend; }</code> </pre> <br><h2>  Kondisi yang ditentukan sebelumnya </h2><br>  Seperti yang sering terjadi, aturan <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> mendahului dalam hal jumlah peringatan. <br><br>  Ekspresi <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> 'firewallPolicyId == null' selalu salah.  FirewallPolicyServiceImpl.java (125) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FirewallPolicy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFirewallRuleFromPolicy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String firewallPolicyId, String firewallRuleId)</span></span></span><span class="hljs-function"> </span></span>{ checkNotNull(firewallPolicyId); checkNotNull(firewallRuleId); checkState(!(firewallPolicyId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; firewallRuleId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>), <span class="hljs-string"><span class="hljs-string">"Either a Firewall Policy or Firewall Rule identifier must be set"</span></span>); .... }</code> </pre> <br>  Dalam metode ini, argumen diperiksa untuk <i>null</i> oleh metode <i>checkNotNull</i> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CanIgnoreReturnValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkNotNull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T reference)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reference == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NullPointerException(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference; } }</code> </pre> <br>  Setelah memeriksa argumen dengan metode <i>checkNotNull</i> , Anda dapat 100% yakin bahwa argumen yang diteruskan ke metode ini bukan <i>nol</i> .  Karena kedua argumen untuk metode <i>removeFirewallRuleFromPolicy</i> diperiksa oleh metode <i>checkNotNull</i> , tidak masuk akal untuk memeriksa argumen untuk <i>nilai</i> <i>null</i> lagi.  Namun, ekspresi dilewatkan ke metode <i>checkState</i> sebagai argumen pertama, di mana argumen <i>firewallPolicyId</i> dan <i>firewallRuleId</i> diperiksa ulang untuk <i>null</i> . <br><br>  Peringatan serupa dikeluarkan untuk <i>firewallRuleId</i> : <br><br><ul><li>  Ekspresi V6007 'firewallRuleId == null' selalu salah.  FirewallPolicyServiceImpl.java (125) </li></ul><br>  Ekspresi <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> 'filteringParams! = Null' selalu benar.  NetworkPolicyServiceImpl.java (60) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Invocation&lt;NetworkServicePolicies&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildInvocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, String&gt; filteringParams)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filteringParams == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> servicePoliciesInvocation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filteringParams != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return servicePoliciesInvocation; }</span></span></code> </pre> <br>  Dalam metode ini, jika argumen <i>filteringParams</i> adalah <i>nol</i> , maka metode keluar dan mengembalikan nilai.  Oleh karena itu, tes yang ditunjukkan oleh penganalisa akan selalu benar, yang berarti bahwa tes ini tidak masuk akal. <br><br>  Serupa terjadi di 13 kelas: <br><br><ul><li>  Ekspresi V6007 'filteringParams! = Null' selalu benar.  PolicyRuleServiceImpl.java (58) </li><li>  Ekspresi V6007 'filteringParams! = Null' selalu benar.  GroupServiceImpl.java (58) </li><li>  Ekspresi V6007 'filteringParams! = Null' selalu benar.  ExternalSegmentServiceImpl.java (57) </li><li>  Ekspresi V6007 'filteringParams! = Null' selalu benar.  L3policyServiceImpl.java (57) </li><li>  Ekspresi V6007 'filteringParams! = Null' selalu benar.  PolicyRuleSetServiceImpl.java (58) </li><li>  dan seterusnya ... </li></ul><br><h2>  Referensi kosong </h2><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a> Potensi null dereference dari 'm.blockDeviceMapping'.  NovaServerCreate.java (390) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ServerCreateBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blockDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BlockDeviceMappingCreate blockDevice)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (blockDevice != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; m.blockDeviceMapping == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { m.blockDeviceMapping = Lists.newArrayList(); } m.blockDeviceMapping.add(blockDevice); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return this; }</span></span></code> </pre> <br>  Dalam metode ini, inisialisasi bidang referensi <i>m.blockDeviceMapping</i> tidak <i>akan</i> terjadi jika argumen <i>blockDevice</i> adalah <i>nol</i> .  Bidang ini diinisialisasi hanya dalam metode ini, jadi ketika metode <i>add</i> dipanggil, bidang <i>m.blockDeviceMapping</i> akan melempar <i>NullPointerException</i> . <br><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a> Potensi dereferensi nol dari 'FileId.get (path)' dalam fungsi '&lt;init&gt;'.  TrackedFile.java (140), TrackedFile.java (115) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FileFlow&lt;?&gt; flow, Path path)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(flow, path, FileId.get(path), ....); }</code> </pre> <br>  Hasil dari metode statis <i>FileId.get (path)</i> diteruskan ke konstruktor dari kelas <i>TrackedFile</i> sebagai argumen ketiga.  Tetapi metode ini dapat mengembalikan <i>nol</i> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FileId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Files.exists(file)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } .... }</code> </pre> <br>  Dalam konstruktor yang dipanggil melalui <i>ini</i> , argumen <i>id</i> tidak berubah sampai digunakan pertama kali: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., ...., FileId id, ....)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... FileId newId = FileId.get(path); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!id.equals(newId)) { .... } }</code> </pre> <br>  Oleh karena itu, jika <i>nol</i> dilewatkan ke metode sebagai argumen ketiga, pengecualian akan terjadi. <br><br>  Situasi serupa terjadi dalam kasus lain: <br><br><ul><li>  V6008 Potensi null dereference dari 'buffer'.  PublishingQueue.java (518) </li></ul><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a> Potensi null dereference dari 'dataTmpFile'.  CacheManager.java (91) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putToCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PutRecordsRequest putRecordsRequest)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dataTmpFile.createNewFile(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } catch (IOException e) { LOGGER.error("Failed to create cache tmp file, return.", e); return ; } } .... }</span></span></code> </pre> <br>  Dan lagi NPE.  Sejumlah pemeriksaan dalam pernyataan bersyarat memungkinkan objek <i>dataTmpFile</i> nol untuk dereferencing lebih lanjut.  Saya pikir ada dua kesalahan ketik di sini, dan cek harus benar-benar seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !dataTmpFile.exists())</code> </pre> <br><h2>  Substring dan angka negatif </h2><br>  <a href="https://www.viva64.com/ru/w/v6009/">V6009</a> Fungsi 'substring' dapat menerima nilai '-1' sementara nilai non-negatif diharapkan.  Periksa argumen: 2. RemoveVersionProjectIdFromURL.java (37) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String url)</span></span></span><span class="hljs-function"> </span></span>{ String urlRmovePojectId = url.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, url.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urlRmovePojectId.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, urlRmovePojectId.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); }</code> </pre> <br>  Dapat dipahami bahwa URL diteruskan ke metode ini sebagai string, yang tidak divalidasi dengan cara apa pun.  Setelah string ini dipangkas beberapa kali menggunakan metode <i>lastIndexOf</i> .  Jika <i>lastIndexOf</i> tidak menemukan kecocokan dalam string, itu akan mengembalikan -1.  Ini akan melempar <i>StringIndexOutOfBoundsException</i> , karena argumen ke metode <i>substring</i> harus berupa angka non-negatif.  Agar metode berfungsi dengan benar, Anda harus menambahkan validasi argumen input atau memverifikasi bahwa hasil dari <i>metodeIndexOf terakhir</i> bukan angka negatif. <br><br>  Berikut adalah beberapa tempat lain di mana ini terjadi: <br><br><ul><li>  V6009 Fungsi 'substring' dapat menerima nilai '-1' sementara nilai non-negatif diharapkan.  Periksa argumen: 2. RemoveProjectIdFromURL.java (37) </li><li>  V6009 Fungsi 'substring' dapat menerima nilai '-1' sementara nilai non-negatif diharapkan.  Periksa argumen: 2. RemoveVersionProjectIdFromURL.java (38) </li></ul><br><h2>  Hasil yang terlupakan </h2><br>  <a href="https://www.viva64.com/ru/w/v6010/">V6010</a> Nilai kembali fungsi 'concat' diperlukan untuk dimanfaatkan.  AKSK.java (278) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildCanonicalHost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(URL url)</span></span></span><span class="hljs-function"> </span></span>{ String host = url.getHost(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port = url.getPort(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span>) { host.concat(<span class="hljs-string"><span class="hljs-string">":"</span></span> + Integer.toString(port)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> host; }</code> </pre> <br>  Saat menulis kode ini, tidak diperhitungkan bahwa memanggil metode <i>concat</i> tidak <i>akan</i> mengubah string <i>host</i> karena ketidakmampuan objek-objek dari tipe <i>String</i> .  Agar metode berfungsi dengan benar, Anda harus menetapkan hasil metode <i>concat</i> ke variabel <i>host</i> di blok <i>if</i> .  Dengan benar: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span>) { host = host.concat(<span class="hljs-string"><span class="hljs-string">":"</span></span> + Integer.toString(port)); }</code> </pre> <br><h2>  Variabel yang tidak digunakan </h2><br>  'URL' <a href="https://www.viva64.com/ru/w/v6021/">V6021</a> variabel tidak digunakan.  TriggerV2Service.java (95) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteAllTriggersForFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String functionUrn)</span></span></span><span class="hljs-function"> </span></span>{ checkArgument(!Strings.isNullOrEmpty(functionUrn), ....); String url = ClientConstants.FGS_TRIGGERS_V2 + ClientConstants.URI_SEP + functionUrn; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deleteWithResponse(uri(triggersUrlFmt, functionUrn)).execute(); }</code> </pre> <br>  Dalam metode ini, variabel <i>url</i> tidak digunakan setelah inisialisasi.  Kemungkinan besar, variabel <i>url</i> harus diteruskan ke metode <i>uri</i> sebagai argumen kedua alih-alih <i>functionUrn</i> , karena variabel <i>functionUrn</i> terlibat dalam inisialisasi variabel <i>url</i> . <br><br><h2>  Argumen tidak digunakan dalam konstruktor </h2><br>  <a href="https://www.viva64.com/ru/w/v6022/">V6022</a> Parameter 'returnType' tidak digunakan di dalam tubuh konstruktor.  HttpRequest.java (68) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpReQuest</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ .... Class&lt;R&gt; returnType; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., Class&lt;R&gt; returnType)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// &lt;= { this.endpoint = endpoint; this.path = path; this.method = method; this.entity = entity; } .... public Class&lt;R&gt; getReturnType() { return returnType; } .... }</span></span></span></span></code> </pre> <br>  Dalam konstruktor ini, mereka lupa menggunakan argumen <i>returnType</i> dan menetapkan nilainya ke bidang <i>returnType</i> .  Oleh karena itu, ketika memanggil metode <i>getReturnType</i> , objek yang dibuat oleh konstruktor ini akan mengembalikan nilai default <i>nol</i> , meskipun itu kemungkinan besar dimaksudkan untuk mendapatkan objek yang sebelumnya diteruskan ke konstruktor. <br><br><h2>  Fungsionalitas yang sama </h2><br>  <a href="https://www.viva64.com/ru/w/v6032/">V6032</a> Aneh bahwa tubuh metode 'aktifkan' sepenuhnya setara dengan tubuh metode lain 'nonaktifkan'.  ServiceAction.java (32), ServiceAction.java (36) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String binary; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String host; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String binary, String host)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.binary = binary; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.host = host; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ServiceAction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String binary, String host)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// &lt;= return new ServiceAction(binary, host); } public static ServiceAction disable(String binary, String host) { // &lt;= return new ServiceAction(binary, host); } .... }</span></span></code> </pre> <br>  Kehadiran dua metode yang identik bukanlah kesalahan, tetapi fakta bahwa dua metode melakukan tindakan yang sama setidaknya aneh.  Melihat nama-nama metode di atas, kita dapat mengasumsikan bahwa mereka melakukan tindakan yang berlawanan.  Faktanya, kedua metode melakukan hal yang sama - mereka membuat dan mengembalikan objek <i>ServiceAction</i> .  Kemungkinan besar, metode <i>menonaktifkan</i> dibuat dengan menyalin kode metode <i>aktifkan</i> , tetapi lupa untuk mengubah tubuh metode. <br><br><h2>  Lupa memeriksa hal utama </h2><br>  <a href="https://www.viva64.com/ru/w/v6060/">V6060</a> Referensi 'params' digunakan sebelum diverifikasi terhadap nol.  DomainService.java (49), DomainService.java (46) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Domains </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, String&gt; params)</span></span></span><span class="hljs-function"> </span></span>{ Preconditions.checkNotNull(params.get(<span class="hljs-string"><span class="hljs-string">"page_size"</span></span>), ....); Preconditions.checkNotNull(params.get(<span class="hljs-string"><span class="hljs-string">"page_number"</span></span>), ....); Invocation&lt;Domains&gt; domainInvocation = get(Domains.class, uri(<span class="hljs-string"><span class="hljs-string">"/domains"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (params != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return domainInvocation.execute(this.buildExecutionOptions(Domains.class)); }</span></span></code> </pre> <br>  Dalam metode ini, kami memutuskan untuk memeriksa konten struktur tipe <i>Map</i> untuk ketimpangan <i>nol</i> .  Untuk melakukan ini, argumen <i>params</i> memanggil metode <i>get</i> dua kali, yang hasilnya diteruskan ke metode <i>checkNotNull</i> .  Segalanya tampak logis, tetapi bagaimanapun caranya!  <i>Jika</i> , argumen <i>params</i> diperiksa untuk <i>null</i> .  Setelah itu dapat diasumsikan bahwa argumen input mungkin <i>nol</i> , tetapi sebelum pemeriksaan ini, metode <i>get</i> dipanggil <i>params</i> dua kali.  Jika <i>null</i> dilewatkan sebagai argumen untuk metode ini, maka pertama kali metode <i>get</i> dipanggil, pengecualian akan dilemparkan. <br><br>  Situasi serupa terjadi di tiga tempat lagi: <br><br><ul><li>  V6060 Referensi 'params' digunakan sebelum diverifikasi terhadap nol.  DomainService.java (389), DomainService.java (387) </li><li>  V6060 Referensi 'params' digunakan sebelum diverifikasi terhadap nol.  DomainService.java (372), DomainService.java (369) </li><li>  V6060 Referensi 'params' digunakan sebelum diverifikasi terhadap nol.  DomainService.java (353), DomainService.java (350) </li></ul><br><h2>  Kesimpulan </h2><br>  Perusahaan besar modern saat ini tidak dapat melakukannya tanpa menggunakan layanan cloud.  Sejumlah besar orang menggunakan layanan ini, sehingga kesalahan sekecil apa pun dalam layanan dapat menyebabkan masalah bagi banyak orang, serta biaya tambahan bagi perusahaan untuk memperbaiki konsekuensi dari kesalahan ini.  Dalam mengembangkannya, selalu perlu memperhitungkan faktor manusia, karena siapa pun cepat atau lambat membuat kesalahan, dan artikel ini adalah contohnya.  Itu sebabnya Anda harus menggunakan semua alat yang mungkin untuk meningkatkan kualitas kode. <br><br>  PVS-Studio tentu saja akan memberi tahu Huawei tentang hasil pemeriksaan layanan cloud mereka sehingga pengembang perusahaan ini dapat mempelajarinya lebih detail. <br><br>  Penggunaan satu kali analisis kode statis yang ditunjukkan dalam artikel tidak dapat menunjukkan semua kelebihannya.  Informasi lebih rinci tentang cara menggunakan analisis statis dengan benar dapat ditemukan di <a href="https://www.viva64.com/ru/b/0594/">sini</a> dan di <a href="https://www.viva64.com/ru/b/0639/">sini</a> .  Anda dapat mengunduh penganalisa PVS-Studio di <a href="https://www.viva64.com/ru/pvs-studio-download/">sini</a> . <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/477558/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Valery Komarov.  <a href="https://habr.com/en/company/pvs-studio/blog/477558/">Huawei Cloud: Berawan di PVS-Studio Hari Ini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477566/">https://habr.com/ru/post/id477566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477554/index.html">Zona domain .ORG dijual ke perusahaan swasta. Publik memanggil ICANN untuk mengakhiri kontrak</a></li>
<li><a href="../id477558/index.html">Huawei Cloud: Berawan di PVS-Studio Hari Ini</a></li>
<li><a href="../id477560/index.html">Ubah pola pikir Anda dengan SwiftUI</a></li>
<li><a href="../id477562/index.html">Desain antarmuka untuk game, menggambar paket ikon</a></li>
<li><a href="../id477564/index.html">Klien yang kompleks: bagaimana melindungi tim Anda dari mereka</a></li>
<li><a href="../id477568/index.html">Layanan pengembalian tanpa syarat mudah. Pos Rusia</a></li>
<li><a href="../id477578/index.html">Bagaimana memilih bahasa pemrograman untuk membuat aplikasi Android</a></li>
<li><a href="../id477580/index.html">Kerangka PHP Terbaik untuk Pengembangan Web</a></li>
<li><a href="../id477584/index.html">Klasik abadi: apa yang harus dipelajari oleh game aksi modern dari DOOM</a></li>
<li><a href="../id477590/index.html">Menyematkan kode dan bahaya perangkat lunak bajakan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>