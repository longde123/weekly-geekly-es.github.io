<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🔧 😙 👆🏼 初学者指针基础 🦓 👨‍❤️‍👨 🕳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 
 如今，由于技术的改进和价格便宜，内存和处理能力的数量正在稳定增长。 

 根据摩尔定律： 
 每24个月，放置在集成电路芯片上的晶体管数量将增加一倍。  请注意，两个参数已更改： 



- 晶体管数 
- 模块尺寸 
 在RAM（DRAM）的数量上预计有相同的原理。 

 现在的内存问题...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>初学者指针基础</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456318/"><h2> 引言 </h2><br> 如今，由于技术的改进和价格便宜，内存和处理能力的数量正在稳定增长。 <br><br> 根据摩尔定律： <br><blockquote> 每24个月，放置在集成电路芯片上的晶体管数量将增加一倍。 </blockquote> 请注意，两个参数已更改： <br><br><ul><li> 晶体管数 </li><li> 模块尺寸 </li></ul><br> 在RAM（DRAM）的数量上预计有相同的原理。 <br><br> 现在的内存问题已经不那么尖锐了，因为过去10年中每个内存的内存量增加了16倍。 <br><a name="habracut"></a><br> 大多数高级编程语言（PL）已经“开箱即用”，隐藏了程序员对内存的工作。 而且，由于这个问题正在睡眠中，因此出现了新的程序员阶层，他们不了解<s>或不想了解</s>内存工作的工作方式。 <br><br> 在本主题中，我们将使用C ++语言的示例来考虑使用内存的要点，因为它是支持直接使用内存并支持OOP的少数命令式语言之一。 <br><br><h2>  IT是做什么用的？ </h2><br><blockquote> 在这里值得一提的是，本文是为刚开始使用C ++或只想了解动态内存的人们而设计的。 </blockquote><br> 在运行时，任何程序都会在DRAM中为其自身保留一块内存。 所有其他DRAM可用空间称为<u>“堆”</u> （英文“ Heap”）。 执行期间为满足程序需要而分配的内存恰好是从堆中分配的，这称为动态内存分配。 <br><br> 整个问题是，如果在不再需要分配内存时不进行清理，则可能会发生所谓的内存泄漏，您的系统<u>（程序）会</u>简单地挂起。 类似于停在路中间的汽车，因为有人忘记按时加油。 <br><br><div class="spoiler">  <b class="spoiler_title">你应该已经知道的</b> <div class="spoiler_text"> 大多数现代PL都配备了垃圾收集器，并自行清除内存。 <br> 但是，C ++已将自己确立为性能最快的API之一，部分原因是其中所有内存处理都是手动完成的。 <br></div></div><br><br><h2> 新增和删除 </h2><br> 内存分配可以是静态的，也可以是动态的。 静态内存分配在程序编译期间称为一次性内存分配，并且静态内存量在运行时不会更改。 一个经典的例子是整数变量或数组的声明。 但是，如果程序员事先不知道容器中需要多少个元素，该怎么办？ <br> 当有必要根据程序需要组织内存分配时，建议使用动态内存。 <br>  <i>new</i>运算符负责在C ++中分配动态内存，而<i>delete</i>负责清除它。 <br>  <i>new</i>运算符将其操作结果返回指向该类新实例的指针。 <br> 语法是这样的： <br><br>  |  <b>数据类型（T1）指针</b> |  * |  <b>指针名称</b> | = <i>新</i> |  <b>输入T1</b> |; <br><br> 在<i>new</i>运算符之后，您可以使用构造函数，例如，初始化类的字段。 <br> 值得注意的是，当程序员失去对其分配的控制权时，也会发生相同的内存泄漏。 <br><blockquote> 重要的是要记住： <br> 如果您忘记了清除“已用”不必要元素的动态内存，那么迟早会有一个关键时刻，那就是根本无处可去。 </blockquote><br> 内存分配及其清理的示例： <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main{ <span class="hljs-comment"><span class="hljs-comment">// ,       new int *ptr = new int(); //   cout&lt;&lt;*ptr&lt;&lt;endl; // ,     delete ptr; //  delete     ,         return 0; }</span></span></code> </pre> <br><br> 由于主题非常广泛，因此本文将不讨论所谓的“智能”指针，而是简而言之：“智能指针部分地自动为程序员清除了内存。” <br><br><h2> 指针 </h2><br> 指针负责在C ++中使用动态内存。 这是一个食欲宠坏初学者的话题。 <br><br> 您可以使用<b>*</b>运算符声明一个指针。 默认情况下，它将指向内存的某个随机区域。 为了能够访问所需的内存区域，我们需要将链接（运算符<b>＆</b> ）传递给所需的变量。 <br><br> 指针本身只是一个存储单元的地址，要访问存储在该单元中的数据，必须将其取消引用。 <br><h3> 重要撤退 </h3><br><blockquote> 如果您尝试显示指针而不进行解引用，那么将显示该存储区的地址，而不是其指向的存储区中的值。 <br> 要取消引用指针，只需将<b>*</b>运算符放在其名称的前面。 </blockquote><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,          int* pNum= new int(1) ; cout&lt;&lt;*pNum&lt;&lt;endl; //    ,        ,       (   int   ) pNum++; cout&lt;&lt;*pNum&lt;&lt;endl; // ,         return 0; }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/ka/bg/0k/kabg0kkojm0kefvksto7cye60ps.png"><br><br> 看这样的例子，我想问：“如果您可以立即派生一个变量，为什么这甚至是必要的？” <br><br> 另一个例子： <br><br> 我们有一个Programmers类，该类描述了<s>不了解指针</s>的一组程序员的成员<s>。</s> <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Programmers</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Programmers(){} Programmers(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iWeight, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iAge){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;weight = iWeight; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;age = iAge; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> weight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     Programmers int size = 9; Programmers *prog [size]; //  Programmers Programmers *ptr = nullptr; //     Programmers       //          for (int i =0;i&lt;size;i++) { ptr=new Programmers(i+100,i); prog[i]=ptr; } return 0; }</span></span></code> </pre> <br> 这样，我们就可以随意操纵记忆。 这就是为什么在使用内存时，您可以“脚踏实地”。 应该注意的是，使用指针的速度要快得多，因为值本身不会被复制，而是只分配了指向特定地址的链接。 <br><br> 顺便说一句，这种流行的关键字提供了指向当前类对象的指针。  <s>这些指针无处不在。</s> <br><br>  <b>日常生活中的指针示例：</b> <br><br> 想象一下在餐厅点菜的情况。 要下订单，您只需指向菜单中的菜肴，您便会做好准备。 同样，其他来餐厅的访客在菜单中指示所需的物品。 因此，菜单中的每一行都是指向菜的烹饪功能的指针，并且该指针是在菜单本身的设计阶段创建的。 <br><br><div class="spoiler">  <b class="spoiler_title">功能指针示例</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      void Chicken(){ cout&lt;&lt;"Wait 5 min...Chicken is cooking"&lt;&lt;endl; } void JustWater(){ cout&lt;&lt;"Take your water"&lt;&lt;endl; } int main() { //    void   void (*ptr)(); ptr = Chicken; ptr(); ptr=JustWater; ptr(); return 0; }</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ja/kn/0p/jakn0pthuo6au9wx9w_uqlfbd00.png"><br></div></div><br> 回到我们的程序员。 假设现在我们需要将类字段带到<b>专用</b>部分，以适应OOP封装的原理，然后我们需要使用<b>getter</b>来获取对这些字段的读取访问权限。 但是，假设我们没有2个字段，而是100个，为此，我们需要为每个字段编写自己的访问器吗？ <br><br><div class="spoiler">  <b class="spoiler_title">扰流板</b> <div class="spoiler_text"> 好吧，当然不是，我什至不明白你为什么打开这个扰流板。 <br></div></div><br> 为此，我们将创建一个类型为void的“访问器”，并通过引用将参数传递给它。 通过引用传递参数的含义是不复制参数的值，而只传输实际参数的地址。 因此，当改变这样一个自变量的值时，当前自变量的存储单元中的数据也将改变。 <br> 这也会影响整体性能，因为按引用传递参数要比按值传递更快。 这更不用说大量的元素了。 <br><br> 例如，内部的<i>getParams</i>方法将更改传入的参数，并且它们将更改它们的值，包括从调用它所在的作用域在内的值。 <br> 指针将帮助我们导航数组。 根据数据结构理论，我们知道数组是内存的连续区域，其元素一个接一个地排列。 <br> 这意味着，如果将指针的值更改为元素在数组中占据的字节数，则可以到达每个元素，直到指针超出数组的边界为止。 <br> 创建另一个指针，该指针指向<u>程序员</u>数组的第一个元素。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Programmers</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Programmers(){} Programmers(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iWeight, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iAge){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;weight = iWeight; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;age = iAge; } <span class="hljs-comment"><span class="hljs-comment">//    ,   main     void getParams(int &amp;w, int &amp;a){ w=weight; a=age; } private: int weight; int age; }; int main() { int size = 9; Programmers *prog [size]; Programmers *ptr=nullptr; for (int i =0;i&lt;size;i++) { ptr=new Programmers(i+100,i); prog[i]=ptr; } int w,a; int count = 9; //    //        Programmers **iter = prog; for (int i=0;i&lt;count;i++) { ptr = *iter++; ptr-&gt;getParams(w,a); if(*(iter-1) != nullptr){ delete *(iter-1); ptr = nullptr; } cout&lt;&lt;w&lt;&lt;"\t"&lt;&lt;a&lt;&lt;endl; } return 0; }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/6q/9v/pi/6q9vpiibfo8zddb4znzbfkqcvuu.png"><br><br> 在此示例中，我想向您传达一个事实，即当您更改指针地址的值时，您可以访问内存的另一个区域。 <br><br> 数据结构，例如列表，向量等。 基于指针的，因此称为动态数据结构。 并且要遍历它们，使用迭代器更为正确。 迭代器是指向数据结构元素的指针，并提供对容器元素的访问。 <br><br><h3> 总结 </h3><br> 了解了指针的主题之后，使用内存就成为编程中令人愉快的一部分，并且总体上似乎对机器如何使用内存以及如何对其进行管理有了详细的了解。 从某种意义上说，“处理内存”这一概念背后有一种哲学。 触手可及的是，即使是很小的电容器，也可以改变板上的电荷。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456318/">https://habr.com/ru/post/zh-CN456318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456302/index.html">为什么我们更喜欢CSS（-变量）而不是SASS（$变量）？</a></li>
<li><a href="../zh-CN456304/index.html">如何在1分钟内在PyPI上发布控制台实用程序</a></li>
<li><a href="../zh-CN456306/index.html">微电子技术触手可及：摩尔定律，行销方式以及为什么纳米现在不相同。 第三部分</a></li>
<li><a href="../zh-CN456310/index.html">后勤行动，单独收集可回收物品</a></li>
<li><a href="../zh-CN456316/index.html">前端每周摘要（2019年6月10日至16日）</a></li>
<li><a href="../zh-CN456320/index.html">上周第369期（2019年6月10日至16日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN456334/index.html">当之无愧的长生不老的游戏</a></li>
<li><a href="../zh-CN456336/index.html">开发React应用程序时使用Redux的11个技巧</a></li>
<li><a href="../zh-CN456340/index.html">关于自由职业者团队如何编写全栈JavaScript应用程序的故事</a></li>
<li><a href="../zh-CN456342/index.html">一种语言统治一切</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>