<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÜ üë©üèæ‚ÄçüöÄ üï£ G√©n√©ration efficace de nombres dans un intervalle donn√© üöÆ üí∞ üòΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La grande majorit√© de mes articles sur la g√©n√©ration de nombres al√©atoires traitaient principalement des propri√©t√©s de divers sch√©mas de g√©n√©ration. C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>G√©n√©ration efficace de nombres dans un intervalle donn√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg" alt="image"></div><br>  La grande majorit√© de mes articles sur la g√©n√©ration de nombres al√©atoires traitaient principalement des propri√©t√©s de divers sch√©mas de g√©n√©ration.  Cela peut s'av√©rer inattendu, mais les performances de l'algorithme de randomisation peuvent d√©pendre non pas du sch√©ma de g√©n√©ration choisi, mais d'autres facteurs.  Dans cet article (qui m'a inspir√© un excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de Daniel Lemyr</a> ), nous √©tudierons les principales raisons de la baisse des performances de g√©n√©ration de nombres al√©atoires, qui l'emportent souvent sur les performances du moteur PRN. <br><br>  Imaginez cette situation: <br><br>  Comme devoirs, Juan et Sasha impl√©mentent le m√™me algorithme randomis√© en C ++, qui s'ex√©cutera sur le m√™me ordinateur universitaire et avec un seul ensemble de donn√©es.  Leur code est presque identique et ne diff√®re que par la g√©n√©ration de nombres al√©atoires.  Juan est press√© pour ses cours de musique, alors il a simplement choisi le tourbillon de Mersenne.  Sasha, d'autre part, a pass√© quelques heures de recherche suppl√©mentaires.  Sasha a effectu√© des comparaisons de plusieurs des PRNG les plus rapides, qu'il a r√©cemment appris des r√©seaux sociaux, et a choisi le plus rapide.  Lors de la r√©union, Sasha √©tait impatient de se vanter et il a demand√© √† Juan: "Quel syst√®me PRNG avez-vous utilis√©?" <br><br>  "Personnellement, je viens de prendre le vortex de Mersenne - il est int√©gr√© dans la langue et semble fonctionner assez bien." <br><br>  "Ha!", R√©pondit Sasha.  ¬´J'ai utilis√© <code>jsf32</code> .  Il est bien plus rapide que l'ancien et lent tourbillon de Mersenne!  Mon programme se d√©roule en 3 minutes 15 secondes! ¬ª <br><br>  "Hmm, pas mal, mais le mien peut le faire en moins d'une minute", dit Juan en haussant les √©paules.  ¬´Eh bien, je dois aller au concert.  Voulez-vous venir avec moi? " <br><br>  "Non", r√©pond Sasha.  "J'ai ... euh ... besoin de revoir mon code." <br><br>  Cette situation fictive g√™nante n'est <em>pas</em> particuli√®rement fictive;  il est bas√© sur des r√©sultats r√©els.  Si votre algorithme randomis√© ne fonctionne pas aussi vite que nous le souhaiterions et que le goulot d'√©tranglement semble √™tre la g√©n√©ration de nombres al√©atoires, alors, curieusement, le probl√®me peut ne pas √™tre dans le g√©n√©rateur de nombres al√©atoires! <br><a name="habracut"></a><br><h3>  Introduction: les nombres al√©atoires dans la pratique </h3><br>  La plupart des g√©n√©rateurs de nombres al√©atoires modernes de haute qualit√© cr√©ent des mots machine remplis de bits al√©atoires, c'est-√†-dire qu'ils g√©n√®rent g√©n√©ralement des nombres dans l'intervalle [0..2 <sup>32</sup> ) ou [0..2 <sup>64</sup> ).  Mais dans de nombreux cas d'utilisation, les utilisateurs ont besoin de nombres dans un certain intervalle - par exemple, pour lancer un d√© ou choisir une carte √† jouer au hasard, les nombres sont n√©cessaires en petits intervalles constants.  Cependant, de nombreux algorithmes, du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m√©lange</a> et de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©chantillonnage du r√©servoir</a> aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arbres de recherche binaire randomis√©s,</a> n√©cessitent des nombres provenant d'autres intervalles. <br><br><h3>  Les m√©thodes </h3><br>  Nous examinerons de nombreuses m√©thodes diff√©rentes.  Pour simplifier la discussion, au lieu de g√©n√©rer des nombres dans l'intervalle [ <em>i</em> .. <em>j</em> ) ou [ <em>i</em> .. <em>j</em> ], nous allons g√©n√©rer des nombres dans l'intervalle [0 .. <em>k</em> ).  Avec un tel sch√©ma, nous pouvons, par exemple, g√©n√©rer des nombres dans l'intervalle [ <em>i</em> .. <em>j</em> ) en fixant <em>k</em> = <em>j</em> - <em>i</em> , en g√©n√©rant un nombre dans l'intervalle [0 .. <em>k</em> ), puis en y ajoutant <em>i</em> . <br><br><h4>  Outils C ++ int√©gr√©s </h4><br>  De nombreuses langues ont des outils int√©gr√©s pour obtenir un nombre al√©atoire dans un intervalle sp√©cifi√©.  Par exemple, pour supprimer une carte d'un jeu de 52 cartes dans des langages de script tels que Perl et Python, nous pouvons √©crire respectivement <code>int(rand(52))</code> et <code>random.randint(0,52)</code> .  [Remarque  Utilisateur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">CryptoPirate</a> : <i>Il me semble qu'une erreur ici, en Python randint (a, b) g√©n√®re des nombres de a √† b dont b.</i>  <i>Et comme il y a 52 cartes dans le jeu et que la premi√®re est ¬´0¬ª, ce devrait √™tre random.randint (0,51)</i> .] En C ++, nous pouvons utiliser <code>uniform_int_distribution</code> m√™me <code>uniform_int_distribution</code> . <br><br>  Le code C ++ pour impl√©menter cette approche est simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt; dist(<span class="hljs-number"><span class="hljs-number">0</span></span>, range<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dist(rng); }</code> </pre> <br>  Habituellement, l'une des techniques d√©crites ci-dessous est utilis√©e dans les outils int√©gr√©s, mais la plupart des utilisateurs utilisent simplement ces outils, sans penser √† ce qui se passe ¬´sous le capot¬ª, estimant que ces outils sont correctement con√ßus et assez efficaces.  En C ++, les outils int√©gr√©s sont plus complexes car ils devraient pouvoir fonctionner avec des moteurs de g√©n√©ration assez arbitraires - un g√©n√©rateur qui produit des valeurs dans la plage de -3 √† 17 peut √™tre tout √† fait valide et peut √™tre utilis√© avec <code>std::uniform_int_distribution</code> pour cr√©er des nombres dans n'importe quel intervalle, par exemple [0..1000).  Autrement dit, les outils C ++ int√©gr√©s sont trop compliqu√©s pour la plupart des cas o√π ils sont utilis√©s. <br><br><h4>  Le reste classique de la division (asym√©trique) </h4><br>  Passons d'une approche trop simplifi√©e √† une approche trop simpliste. <br><br>  Lorsque j'ai √©tudi√© la programmation, nous avons g√©n√©r√© des nombres dans l'intervalle (par exemple, pour s√©lectionner une carte dans un jeu de 52 cartes) en utilisant l'op√©rateur restant.  Pour obtenir le nombre dans l'intervalle [0..52), nous avons √©crit <code>rand() % 52</code> . <br><br>  En C ++, cette approche peut √™tre impl√©ment√©e comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rng() % range; }</code> </pre> <br>  Malgr√© la simplicit√© de cette approche, elle d√©montre la raison pour laquelle obtenir des nombres dans le bon intervalle est g√©n√©ralement une t√¢che lente - elle n√©cessite une division (pour calculer le reste obtenu par l'op√©rateur <code>%</code> ).  La division est g√©n√©ralement au moins un ordre de grandeur plus lente que les autres op√©rations arithm√©tiques, de sorte qu'une seule op√©ration arithm√©tique prend plus de temps que tout le travail effectu√© par un PRNG rapide. <br><br>  Mais en plus de la faible vitesse, elle est √©galement <em>asym√©trique</em> .  Pour comprendre pourquoi <code>rand() % 52</code> renvoie des nombres asym√©triques, supposons que <code>rand()</code> cr√©e des nombres dans l'intervalle [0..2 <sup>32</sup> ), et notez que 52 ne divise pas compl√®tement 2 <sup>32</sup> , il le divise 82 595 524 fois avec le reste 48. Autrement dit, si nous utilisons <code>rand() % 52</code> , nous aurons 82 595 525 fa√ßons de s√©lectionner les 48 premi√®res cartes du jeu et seulement 82 595 524 fa√ßons de s√©lectionner les quatre derni√®res cartes.  En d'autres termes, il y a un biais de 0,00000121% par rapport √† ces quatre derni√®res cartes (peut-√™tre que ce sont des rois!).  Quand j'√©tais √©tudiant et que j'√©crivais des devoirs sur le lancer de d√©s ou le tirage de cartes, personne ne se souciait g√©n√©ralement de ces petites distorsions, mais avec une augmentation de l'intervalle, la distorsion cro√Æt de fa√ßon lin√©aire.  Pour un PRNG 32 bits, un intervalle limit√© de moins de 2 <sup>24</sup> a un biais de moins de 0,5%, mais au-dessus de 2 <sup>31 un</sup> d√©calage de 50% - certains nombres reviendront deux fois plus souvent que d'autres. <br><br>  Dans cet article, nous consid√©rerons principalement les techniques qui utilisent des strat√©gies pour √©liminer une erreur syst√©matique, mais il vaut probablement la peine de dire que pour un PRNG 64 bits, la valeur de biais dans les applications normales est probablement n√©gligeable. <br><br>  Un autre probl√®me peut √™tre que certains g√©n√©rateurs ont des bits faibles faibles.  Par exemple, les familles GPRS Xoroshiro + et Xoshiro + ont des bits bas qui ne passent pas les tests statistiques.  Lorsque nous ex√©cutons <code>% 52</code> (car 52 est pair), nous passons le bit de poids faible directement √† la sortie. <br><br><h4>  Multiplier les nombres √† virgule flottante (asym√©trique) </h4><br>  Une autre technique courante consiste √† utiliser un PRNG qui g√©n√®re des nombres √† virgule flottante dans l'intervalle [0..1) avec la conversion ult√©rieure de ces nombres √† l'intervalle souhait√©.  Cette approche est utilis√©e en Perl, il est <a href="">recommand√© d'</a> utiliser <code>int(rand(10))</code> pour g√©n√©rer un entier dans l'intervalle [0..10) en g√©n√©rant un nombre √† virgule flottante suivi d'un arrondi. <br><br>  En C ++, cette approche est √©crite comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rng_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> zeroone = <span class="hljs-number"><span class="hljs-number">0x1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>p<span class="hljs-number"><span class="hljs-number">-32</span></span> * rng(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range * zeroone; }</code> </pre> <br>  (Notez que <code>0x1.0p-32</code> est une constante binaire √† virgule flottante pour 2 <sup>-32</sup> , que nous utilisons pour convertir un entier al√©atoire dans l'intervalle [0..2 <sup>32</sup> ) pour doubler dans l'intervalle unitaire;  √† la place, nous pouvons effectuer une telle conversion en utilisant <code>ldexp(rng(), -32)</code> , mais quand j'ai √©valu√© cette approche, cela s'est av√©r√© beaucoup plus lent.) <br><br>  Cette approche est aussi biais√©e que le reste classique de la division, mais le biais appara√Æt diff√©remment.  Par exemple, si nous s√©lectionnions des nombres dans l'intervalle [0..52), alors les nombres 0, 13, 26 et 39 se produiraient une fois moins souvent que les autres. <br><br>  Cette version, lors de la g√©n√©ralisation √† 64 bits, est encore plus d√©sagr√©able, car elle n√©cessite un type √† virgule flottante dont la mantisse est d'au moins 64 bits.  Sur les machines x86 avec Linux et macOS, nous pouvons utiliser le <code>long double</code> pour tirer parti des nombres √† virgule flottante x86 de pr√©cision accrue qui ont une mantisse 64 bits, mais le <code>long double</code> pas universellement port√© sur tous les syst√®mes - dans certains syst√®mes, le <code>long double</code> √©quivaut au <code>double</code> . <br><br>  Il y a un bon c√¥t√© - cette approche est plus rapide que les solutions r√©siduelles pour les PRNG avec des bits faibles faibles. <br><br><h4>  Multiplication enti√®re (asym√©trique) </h4><br>  La m√©thode de multiplication peut √™tre adapt√©e √† l'arithm√©tique √† virgule fixe plut√¥t qu'√† flottante.  En fait, nous multiplions simplement constamment par 2 <sup>32</sup> , <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br>  Il peut sembler que cette version n√©cessite une arithm√©tique 64 bits, sur les processeurs x86, un bon compilateur compilera ce code dans une instruction <code>mult</code> 32 bits (ce qui nous donne deux valeurs de sortie 32 bits, dont l'une est la valeur de retour).  On peut s'attendre √† ce que cette version soit rapide, mais elle est asym√©trique exactement comme la m√©thode de multiplication des nombres √† virgule flottante. <br><br><h4>  Division de baisse (pas de biais) </h4><br>  Nous pouvons modifier le sch√©ma de multiplication √† virgule flottante en sch√©ma bas√© sur la division.  Au lieu de multiplier <code>x * range / 2**32</code> nous calculons <code>x / (2**32 / range)</code> .  Comme nous travaillons avec l'arithm√©tique des nombres entiers, l'arrondi dans cette version sera effectu√© diff√©remment et g√©n√©rera parfois des valeurs en dehors de l'intervalle souhait√©.  Si nous rejetons ces valeurs (par exemple, nous en d√©barrassons et g√©n√©rons de nouvelles valeurs), nous obtenons ainsi une technique sans distorsion. <br><br>  Par exemple, dans le cas du retrait d'une carte √† l'aide d'un PRNG 32 bits, nous pouvons g√©n√©rer un nombre 32 bits et le diviser par 2 32/52 = 82 595 524 pour s√©lectionner une carte.  Cette technique fonctionne si la valeur al√©atoire du PRNG 32 bits est inf√©rieure √† 52 √ó 82595524 = 2 32/32 - 48. Si la valeur al√©atoire du PRNR est l'une des 48 derni√®res valeurs de la partie sup√©rieure de l'intervalle du g√©n√©rateur, vous devez alors la supprimer et en chercher une autre. <br><br>  Notre code pour cette version utilise une astuce avec la division de 2 <sup>32</sup> par <code>range</code> sans utiliser de math√©matiques 64 bits.  Pour un calcul direct de <code>2**32 / range</code> nous devons repr√©senter le nombre 2 <sup>32</sup> , qui est trop grand (par un!) Pour repr√©senter un entier 32 bits.  Au lieu de cela, nous prenons en compte que pour les entiers non sign√©s, la <code>range</code> op√©ration de n√©gation unaire calcule une valeur positive de 2 <sup>32</sup> - <code>range</code> ;  en divisant cette valeur par <code>range</code> , nous obtenons une r√©ponse inf√©rieure √† <code>2**32 / range</code> . <br><br>  Par cons√©quent, le code C ++ pour g√©n√©rer des nombres √† l'aide de la division et de la suppression ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates divisor = 2**32 / range uint32_t divisor = ((-range) / range) + 1; if (divisor == 0) // overflow, it's really 2**32 return 0; for (;;) { uint32_t val = rng() / divisor; if (val &lt; range) return val; } }</span></span></code> </pre> <br>  Bien s√ªr, cette approche n√©cessite deux op√©rations lentes bas√©es sur la division, qui sont g√©n√©ralement plus lentes que les autres op√©rations arithm√©tiques, vous ne devez donc pas vous attendre √† ce qu'elle soit rapide. <br><br><h4>  Le reste de la division (double) sans distorsions - technique OpenBSD </h4><br>  Nous pouvons √©galement adopter l'approche de baisse pour √©liminer le biais dans la m√©thode du reste de division classique.  Dans l'exemple avec les cartes √† jouer, nous devons √† nouveau supprimer 48 valeurs.  Dans cette version, au lieu de supprimer les 48 <em>derni√®res</em> valeurs, nous rejetons (de mani√®re √©quivalente) les 48 <em>premi√®res</em> valeurs. <br><br>  Voici l'impl√©mentation de cette approche en C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br>  Cette technique supprime le biais, mais elle n√©cessite deux op√©rations de division chronophages avec le reste de chaque valeur de sortie (et vous pouvez avoir besoin d'un g√©n√©rateur interne pour cr√©er plusieurs nombres).  Par cons√©quent, il faut s'attendre √† ce que la m√©thode soit environ deux fois plus lente que l'approche asym√©trique classique. <br><br>  <a href=""><code> arc4random_uniform</code> OpenBSD <code> arc4random_uniform</code></a> (qui est √©galement utilis√© sur OS X et iOS) utilise cette strat√©gie. <br><br><h4>  Reste de division (simple) sans biais - m√©thodologie Java </h4><br>  Java utilise une approche diff√©rente pour g√©n√©rer un nombre dans un intervalle qui utilise une seule op√©ration de division restante, √† l'exception de cas assez rares de rejet du r√©sultat.  Code: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rng_t&amp; rng, uint32_t range)</span></span></span><span class="hljs-function"> </span></span>{ uint32_t x, r; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng(); r = x % range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x - r &gt; (-range)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre> <br>  Pour comprendre pourquoi cette option fonctionne, vous devez r√©fl√©chir un peu.  Contrairement √† la version pr√©c√©dente, bas√©e sur les r√©sidus, qui √©limine les biais en supprimant une partie des valeurs les plus basses du moteur de g√©n√©ration interne, cette version filtre les valeurs de la partie sup√©rieure de l'intervalle du moteur. <br><br><h4>  Multiplication d'entiers asym√©triques - M√©thode Lemira </h4><br>  De la m√™me mani√®re que nous avons supprim√© le biais de la m√©thode du reste de la division, nous pouvons √©liminer le biais de la technique de multiplication des nombres entiers.  Cette technique a √©t√© invent√©e par Lemyr. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><h4>  Drop bitmask (no skew) - Apple technique </h4><br>  Dans notre derni√®re approche, la division et les op√©rations restantes sont compl√®tement √©limin√©es.  Au lieu de cela, il utilise une op√©ration de masquage simple pour obtenir un nombre al√©atoire dans l'intervalle [0..2 <sup><em>k</em></sup> ), o√π <em>k</em> est la plus petite valeur, telle que 2 <sup><em>k est</em></sup> sup√©rieur √† l'intervalle.  Si la valeur est trop grande pour notre intervalle, nous la rejetons et essayons d'en obtenir une autre.  Le code est illustr√© ci-dessous: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask = ~<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); --range; mask &gt;&gt;= __builtin_clz(range|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng() &amp; mask; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt; range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br>  Cette approche a √©t√© adopt√©e par Apple lorsque (dans la version macOS Sierra) elle a effectu√© <a href="">sa propre r√©vision</a> du code <code>arc4random_uniform</code> . <br><br><h3>  Analyse comparative des techniques de base </h3><br>  Nous avons maintenant plusieurs approches qui peuvent √™tre √©valu√©es.  Malheureusement, lorsque nous sommes pr√©occup√©s par les co√ªts d'une op√©ration √† division unique, l'analyse comparative devient une chose non triviale.  Aucune r√©f√©rence ne peut prendre en compte tous les facteurs affectant le domaine d'application, et rien ne garantit que la meilleure option pour votre application sera certainement la meilleure pour la mienne. <br><br>  Nous utilisons trois rep√®res et testons les techniques avec de nombreux PRNG diff√©rents. <br><br><h4>  Benchmark Large-Shuffle </h4><br>  La r√©f√©rence la plus √©vidente est probablement le mixage.  Dans cette r√©f√©rence, nous simulons un mixage √† grande √©chelle.  Pour trier un tableau de taille <em>N,</em> nous devons g√©n√©rer des nombres dans les intervalles [0 .. <em>N</em> ), [0 .. ( <em>N</em> -1)), ..., [0..1).  Dans ce cas-ci, nous supposerons que <em>N</em> est le nombre maximum possible (pour <code>uint32_t</code> il est 2 <sup>32</sup> -1).  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; }</code> </pre> <br>  Notez que nous ¬´utilisons¬ª chaque nombre en l'ajoutant √† la <code>sum</code> (afin qu'il ne soit pas jet√© par optimisation), mais nous n'effectuons aucun mixage pour nous concentrer sur la g√©n√©ration de nombres. <br><br>  Pour tester la g√©n√©ration 64 bits, nous avons un test similaire, mais il ne sera pas pratique d'effectuer un test correspondant au m√©lange d'un tableau de taille 2 <sup>64</sup> - 1 (car il faudra plusieurs milliers d'ann√©es pour compl√©ter ce plus grand benchmark).  Au lieu de cela, nous traversons l'int√©gralit√© de l'intervalle 64 bits, mais g√©n√©rons le m√™me nombre de valeurs de sortie que dans le test 32 bits.  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bound = (<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(i)&lt;&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>) | i; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bval = bounded_rand(rng, bound ); assert(bval &lt; bound); sum += bval; }</code> </pre> <br><h5>  R√©sultats du tourbillon de Mersenne </h5><br>  Les r√©sultats ci-dessous montrent les performances de cette r√©f√©rence pour chacune des m√©thodes que nous avons examin√©es lors de l'utilisation du vortex de Mersenne et du test sur 32 bits (en utilisant <code>std::mt19937</code> de <code>libstdc++</code> ) et du code 64 bits similaire (en utilisant <code>std:mt19937_64</code> de <code>libstdc++</code> )  Les r√©sultats sont la moyenne g√©om√©trique de 15 s√©ries avec diff√©rentes valeurs de graine, qui est ensuite normalis√©e de sorte que la m√©thode du reste de la division classique ait un seul temps d'ex√©cution. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/3eb/53f/b9f3eb53f894a14ac2698f44090b23a6.svg"></div><br>  Il peut sembler que nous ayons des r√©ponses claires sur les performances - il semble que vous pouvez construire des techniques pour leur perfection et vous demander √† quoi pensaient les d√©veloppeurs de <code>libstdc++</code> lorsqu'ils ont √©crit une impl√©mentation aussi terrible pour les nombres 32 bits.  Mais, comme c'est souvent le cas avec l'analyse comparative, la situation est plus compliqu√©e qu'il n'y para√Æt d'apr√®s ces r√©sultats.  Premi√®rement, il existe un risque que les r√©sultats soient sp√©cifiques au vortex de Mersenne, nous allons donc √©tendre les nombreux PRNG test√©s.  Deuxi√®mement, il peut y avoir un probl√®me subtil avec l'indice de r√©f√©rence lui-m√™me.  Voyons d'abord la premi√®re question. <br><br><h5>  R√©sultats des diff√©rents PRNG </h5><br>  Nous testerons des <code>arc4_rand32</code> 32 bits avec les <code>arc4_rand32</code> , <code>chacha8r</code> , <code>gjrand32</code> , <code>jsf32</code> , <code>mt19937</code> , <code>pcg32</code> , <code>pcg32_fast</code> , <code>sfc32</code> , <code>splitmix32</code> , <code>xoroshiro64+</code> , <code>xorshift*64/32</code> <code>xoshiro128+</code> , <code>xoshiro128+</code> et <code>xoshiro128**</code> , et <code>xoshiro128**</code> <code>gjrand64</code> <code>jsf64</code> , <code>mcg128</code> , <code>mcg128_fast</code> , <code>mt19937_64</code> , <code>pcg64</code> , <code>pcg64_fast</code> , <code>sfc64</code> , <code>splitmix64</code> , <code>xoroshiro128+</code> , <code>xorshift*128/64</code> <code>xoshiro256+</code> , <code>xoshiro256+</code> et <code>xoshiro256*</code> .  Ces kits nous donneront des PRN lents et beaucoup de tr√®s rapides. <br><br>  Voici les r√©sultats: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2dc/8c8/f1a/2dc8c8f1af9aa517a92260e7cbd3a73e.svg"></div><br>  Nous pouvons voir les principales diff√©rences par rapport aux r√©sultats avec le vortex de Mersenne.  Des PRNG plus rapides d√©placent l'√©quilibre vers le code de d√©limitation, et donc la diff√©rence entre les diff√©rentes approches devient plus prononc√©e, en particulier dans le cas des PRNR 64 bits.  Avec un ensemble plus large de <code>libstc++</code> impl√©mentation de <code>libstc++</code> cesse de para√Ætre si terrible. <br><br><h5>  Conclusions </h5><br>  Dans ce benchmark d'une marge importante, l'approche bas√©e sur la multiplication avec biais gagne en vitesse.  Il existe de nombreuses situations dans lesquelles les limites seront petites par rapport √† la taille du PRNG, et les performances sont absolument critiques.  Dans de telles situations, un l√©ger biais est peu susceptible d'avoir un effet notable, mais la vitesse PRNG aura.  Un tel exemple est Quicksort avec un point de r√©f√©rence al√©atoire.  Parmi les m√©thodes biais√©es, la technique du masque bitmap semble prometteuse. <br><br>  Mais avant de tirer des conclusions s√©rieuses, nous devons souligner l'√©norme probl√®me de cette r√©f√©rence - la plupart du temps est consacr√© √† des limites tr√®s √©lev√©es, ce qui donne tr√®s probablement une importance excessive √† de grands intervalles.  Par cons√©quent, nous devons passer au deuxi√®me rep√®re. <br><br><h4>  Benchmark Small-Shuffle </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ce benchmark est similaire au pr√©c√©dent, mais effectue beaucoup moins de ¬´mixage matriciel¬ª (multiple). </font></font> Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; } }</code> </pre> <br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©sultats du tourbillon de Mersenne </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/d3b/4bd/6c5d3b4bdb5f2e45cd805a051d79ab9a.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©sultats des diff√©rents PRNG </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/9ae/8c0/45a9ae8c040cb4d297fe82f00fa06e3c.svg"></div><br><h5>  Conclusions </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cette r√©f√©rence √©vite de trop insister sur les grandes fronti√®res et refl√®te plus pr√©cis√©ment les cas d'utilisation r√©els, mais rejette d√©sormais compl√®tement les grandes fronti√®res. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark pour tous les intervalles </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette r√©f√©rence vise √† √©viter les inconv√©nients des deux pr√©c√©dents; </font><font style="vertical-align: inherit;">il effectue des tests √† chaque taille de la puissance de deux pour que chaque taille soit pr√©sente, mais son influence n'est pas surestim√©e.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bit = <span class="hljs-number"><span class="hljs-number">1</span></span>; bit != <span class="hljs-number"><span class="hljs-number">0</span></span>; bit &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">0x1000000</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bound = bit | (i &amp; (bit - <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, bound); assert(bval &lt; bound); sum += bval; } }</code> </pre> <br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©sultats du tourbillon de Mersenne </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/65c/447/f3465c447f9b19b430bb43533a655c2f.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©sultats des diff√©rents PRNG </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/c58/2a2/64bc582a2fde24fd0faedbeaabb9f64c.svg"></div><br><h5>  Conclusions </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bon nombre de nos constatations demeurent inchang√©es. </font><font style="vertical-align: inherit;">La m√©thode asym√©trique est rapide si nous pouvons supporter l'erreur, et le sch√©ma de masque de bits semble √™tre un bon choix moyen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pourrions mettre fin √† cela si nous ne voulions pas revenir en arri√®re, jeter un regard critique sur notre code et y apporter des modifications.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apportez des am√©liorations </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† ce point, toutes les m√©thodes d'√©limination de l'inclinaison n√©cessitaient l'utilisation d'une op√©ration de division r√©siduelle suppl√©mentaire, c'est pourquoi elles sont ex√©cut√©es beaucoup plus lentement que les m√©thodes d'inclinaison. </font><font style="vertical-align: inherit;">Il serait utile de r√©duire cet avantage.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chute bas√©e sur un seuil plus rapide </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Certains de nos algorithmes ont du code utilisant une valeur de seuil, par exemple: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'il est </font></font><code>range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">petit par rapport √† l'intervalle de sortie PRNG, le plus souvent le nombre sera </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beaucoup plus grand que le</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seuil. </font><font style="vertical-align: inherit;">Autrement dit, si nous pouvons ajouter une estimation pr√©liminaire du seuil, qui peut √™tre un peu plus, nous √©conomiserons sur l'op√©ration co√ªteuse de prendre le reste de la division. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code suivant g√®re cette t√¢che:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> r = rng(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (r &lt; t) r = rng(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r % range; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette modification peut √™tre appliqu√©e √† la fois au ¬´double Mod sans distorsions¬ª (voir ci-dessus) et √† la ¬´multiplication enti√®re sans distorsions¬ª. </font><font style="vertical-align: inherit;">L'id√©e a √©t√© invent√©e par Lemir, qui l'a appliqu√©e √† la deuxi√®me m√©thode (mais pas √† la premi√®re).</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©sultats de r√©f√©rence √† grande √©chelle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette optimisation conduit √† une am√©lioration significative des r√©sultats du benchmark 64 bits (dans lequel le mod est encore plus lent), mais d√©grade en fait l√©g√®rement les performances du benchmark 32 bits. </font><font style="vertical-align: inherit;">Malgr√© les am√©liorations, la m√©thode bitmask gagne toujours.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb4/61d/b52/bb461db52be4a7d983dd7f97844179c0.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©sultats des tests de r√©f√©rence √† petite √©chelle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'un autre c√¥t√©, ce changement acc√©l√®re consid√©rablement le rep√®re de petit shuffle pour la m√©thode de multiplication enti√®re et la m√©thode du double reste de division. </font><font style="vertical-align: inherit;">Dans les deux cas, leurs performances se rapprochent davantage des r√©sultats des options sans distorsions. </font><font style="vertical-align: inherit;">Les performances de la m√©thode des r√©sidus doubles (OpenBSD) sont d√©sormais quasiment √©gales aux performances de la m√©thode des r√©sidus simples (Java).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/2bd/fe2/f072bdfe2660cf0f8789b124a8f02646.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©sultats de r√©f√©rence pour tous les intervalles </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous constatons une am√©lioration similaire de l'indice de r√©f√©rence pour tous les intervalles. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/219/b1d/add/219b1daddfa6a55a2cb485b3ae774016.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il semble que nous pouvons annoncer un nouveau gagnant universel: une m√©thode optimis√©e pour multiplier les entiers Lemire sans biais. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimisation du reste de la division </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En r√®gle g√©n√©rale, un calcul </font></font><code>a % b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√©cessite une division, mais dans les situations o√π le </font></font><code>a &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©sultat est simple </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la division n'est pas requise. </font><font style="vertical-align: inherit;">Et quand </font></font><code>a/2 &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le r√©sultat est simple </font></font><code>a - b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Par cons√©quent, au lieu de calculer</font></font><br><br><pre> <code class="cpp hljs">a %= b;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous pouvons accomplir </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) { a -= b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) a %= b; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le co√ªt de la division est si important que l'augmentation du co√ªt de ce code plus complexe peut se justifier par un gain de temps d√ª au manque de division. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©sultats de r√©f√©rence √† grande √©chelle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ajout de cette optimisation am√©liore consid√©rablement les r√©sultats du test de r√©f√©rence √† grand shuffle. </font><font style="vertical-align: inherit;">Ceci est encore plus visible dans le code 64 bits, o√π l'op√©ration de prise du reste est plus co√ªteuse. </font><font style="vertical-align: inherit;">La m√©thode du double reste (style OpenBSD) affiche les versions avec optimisations pour une seule op√©ration restante et pour les deux.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e1a/669/c56e1a669836477e46f870bd1bc7a6c9.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans cette r√©f√©rence, le masque de bits est toujours le gagnant, mais la fronti√®re entre celui-ci et l'approche de Lemira s'est consid√©rablement r√©tr√©cie. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©sultats des tests de r√©f√©rence √† petite √©chelle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ajout de cette optimisation n'augmente pas les performances de la r√©f√©rence de petit shuffle, donc la question reste de savoir si elle ajoute des co√ªts importants. </font><font style="vertical-align: inherit;">Dans certains cas, non; dans d'autres, les co√ªts augmentent l√©g√®rement.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/4db/b65/6fa4dbb65b9a3f6c6f9e8ba4f7b455db.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©sultats de r√©f√©rence pour tous les intervalles </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans la r√©f√©rence pour tous les intervalles, les changements sont √©galement faibles. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0e/ae7/758/e0eae77583cc457a9e923540ad954257.svg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bonus: r√©sultats de la comparaison du DSRP </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La raison principale de l'utilisation d'un grand nombre de PRNG pour tester les sch√©mas de num√©rotation √† intervalles √©tait d'√©viter la distorsion involontaire des r√©sultats en raison des particularit√©s du fonctionnement des sch√©mas PRNG individuels. </font><font style="vertical-align: inherit;">Mais nous pouvons utiliser les m√™mes r√©sultats de tests internes pour comparer les sch√©mas de g√©n√©ration eux-m√™mes.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG avec sortie 32 bits </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le graphique ci-dessous montre les performances de divers sch√©mas de g√©n√©ration 32 bits, moyenn√©es pour toutes les m√©thodes et quinze ex√©cutions, normalis√©es aux performances du vortex Mersenne 32 bits: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'une part, je suis heureux de voir que c'est </font></font><code>pcg32_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vraiment rapide - il n'a √©t√© vaincu que par une petite version de Xoroshiro (qui ne passe pas les tests statistiques). </font><font style="vertical-align: inherit;">Mais cela montre aussi pourquoi je me f√¢che rarement √† cause des performances des DSRP polyvalents modernes √† hautes performances - la diff√©rence entre les diff√©rentes m√©thodes est tr√®s insignifiante. </font><font style="vertical-align: inherit;">En particulier, les quatre circuits les plus rapides pr√©sentent des performances inf√©rieures √† 5%, et je pense que cela est simplement d√ª au ¬´bruit¬ª.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG avec sortie de nombres 64 bits </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le graphique montre les performances de divers sch√©mas de g√©n√©ration 64 bits en moyenne parmi toutes les techniques et quinze cycles normalis√©s aux performances du vortex Mersenne 32 bits. Il peut sembler √©trange que la normalisation soit effectu√©e √† l'aide du vortex Mersenne 32 bits, mais cela nous permet de voir les co√ªts suppl√©mentaires li√©s √† l'utilisation de la g√©n√©ration 64 bits dans les cas o√π la g√©n√©ration 32 bits est suffisante.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/16c/b24/92816cb249e7f76c4ed4e11c65f67475.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces r√©sultats confirment qu'elle est </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incroyablement rapide, mais les quatre derni√®res techniques ne diff√®rent √† nouveau que d'environ 5%, il est donc difficile de choisir parmi les m√©thodes les plus rapides. </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>pcg64_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit √™tre plus lent </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car leurs g√©n√©rateurs de base sont des g√©n√©rateurs congruents lin√©aires 128 bits (LCG) et des g√©n√©rateurs congruents multiplicatifs 128 bits (MCG, MCG). Bien qu'ils ne soient pas les techniques les plus rapides de cet ensemble, ils sont </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toujours 20% plus rapides que le vortex Mersenne 64 bits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais peut-√™tre plus important encore, ces r√©sultats montrent √©galement que si vous n'avez pas besoin d'une sortie 64 bits, un PRNG 64 bits est g√©n√©ralement plus lent qu'un 32 bits.</font></font><br><br><h3>  Conclusions </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä partir de nos benchmarks, nous pouvons voir que la transition des PRNG standard (par exemple, le vortex Mersenne 32 bits) vers des PRNP plus rapides a r√©duit le temps d'ex√©cution des benchmarks de 45%. </font><font style="vertical-align: inherit;">Mais le passage de la m√©thode standard de recherche du nombre dans l'intervalle √† notre m√©thode la plus rapide nous a permis de r√©duire le temps de r√©f√©rence d'environ 66%; </font><font style="vertical-align: inherit;">en d'autres termes, jusqu'√† un tiers de l'heure d'origine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√©thode la plus rapide (sans distorsions) est la m√©thode Lemira (avec mon optimisation suppl√©mentaire). </font><font style="vertical-align: inherit;">Le voici:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = -range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) { t -= range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) t %= range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t) { x = rng(); m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'utilisation de la m√©thode Lemira am√©liorera davantage les performances de la plupart des algorithmes randomis√©s que le passage d'un moteur de g√©n√©ration rapide √† un moteur plus rapide. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Annexes: notes de test </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code de tous les tests est publi√© sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Au total, j'ai test√© 23 m√©thodes pour </font></font><code>bounded_rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliser 26 PRN diff√©rents (13 PRN 32 bits et 13 64 bits), dans deux compilateurs (GCC 8 et LLVM 6), ce qui m'a donn√© 26 * 23 * 2 = 1196 fichiers ex√©cutables, chacun dont il a √©t√© effectu√© avec les m√™mes 15 semences, ce qui donne 1196 * 15 = 17 940 s√©ries de tests uniques, dans chacune desquelles trois rep√®res sont combin√©s. Fondamentalement, j'ai effectu√© des tests sur une machine √† 48 c≈ìurs avec quatre processeurs Xeon E7-4830v3 √† 2,1 GHz. L'ex√©cution d'un ensemble complet de tests a pris un peu moins d'un mois de temps processeur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au final, nous revenons √† la situation depuis l'introduction de l'article. Imaginez que Sasha a utilis√© </font></font><code>jsf32.STD-libc++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et Juan -</font></font><code>mt19937.BIASED_FP_MULT_SCALE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans le benchmark 3, ce dernier prend 69,6% de temps en moins. </font><font style="vertical-align: inherit;">Autrement dit, le temps de cette situation fictive est bas√© sur des donn√©es de la r√©alit√©.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455702/">https://habr.com/ru/post/fr455702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455692/index.html">ASZP: le restyling ou le th√©√¢tre commence par un cintre</a></li>
<li><a href="../fr455694/index.html">Architecture de facturation de nouvelle g√©n√©ration: transition vers Tarantool</a></li>
<li><a href="../fr455696/index.html">L'√©tat √©lectronique du futur. 2e partie</a></li>
<li><a href="../fr455698/index.html">Le livre "Comment JavaScript fonctionne"</a></li>
<li><a href="../fr455700/index.html">4 astuces qui nous ont aid√©s √† optimiser le frontend</a></li>
<li><a href="../fr455710/index.html">Pourquoi chez Leroy Merlin, avons-nous besoin de notre propre service de d√©veloppement russe pour 200 personnes</a></li>
<li><a href="../fr455714/index.html">Exportez automatiquement Google Forms vers Notion √† l'aide d'IFTTT et de Django</a></li>
<li><a href="../fr455716/index.html">15 meilleures pratiques pour le d√©ploiement de logiciels de Business Intelligence</a></li>
<li><a href="../fr455720/index.html">Comment nous construisons l'interface utilisateur pour les syst√®mes publicitaires</a></li>
<li><a href="../fr455722/index.html">Python consomme beaucoup de m√©moire ou comment r√©duire la taille des objets?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>