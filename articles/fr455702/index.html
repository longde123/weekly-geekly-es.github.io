<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐆 👩🏾‍🚀 🕣 Génération efficace de nombres dans un intervalle donné 🚮 💰 😽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La grande majorité de mes articles sur la génération de nombres aléatoires traitaient principalement des propriétés de divers schémas de génération. C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Génération efficace de nombres dans un intervalle donné</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg" alt="image"></div><br>  La grande majorité de mes articles sur la génération de nombres aléatoires traitaient principalement des propriétés de divers schémas de génération.  Cela peut s'avérer inattendu, mais les performances de l'algorithme de randomisation peuvent dépendre non pas du schéma de génération choisi, mais d'autres facteurs.  Dans cet article (qui m'a inspiré un excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de Daniel Lemyr</a> ), nous étudierons les principales raisons de la baisse des performances de génération de nombres aléatoires, qui l'emportent souvent sur les performances du moteur PRN. <br><br>  Imaginez cette situation: <br><br>  Comme devoirs, Juan et Sasha implémentent le même algorithme randomisé en C ++, qui s'exécutera sur le même ordinateur universitaire et avec un seul ensemble de données.  Leur code est presque identique et ne diffère que par la génération de nombres aléatoires.  Juan est pressé pour ses cours de musique, alors il a simplement choisi le tourbillon de Mersenne.  Sasha, d'autre part, a passé quelques heures de recherche supplémentaires.  Sasha a effectué des comparaisons de plusieurs des PRNG les plus rapides, qu'il a récemment appris des réseaux sociaux, et a choisi le plus rapide.  Lors de la réunion, Sasha était impatient de se vanter et il a demandé à Juan: "Quel système PRNG avez-vous utilisé?" <br><br>  "Personnellement, je viens de prendre le vortex de Mersenne - il est intégré dans la langue et semble fonctionner assez bien." <br><br>  "Ha!", Répondit Sasha.  «J'ai utilisé <code>jsf32</code> .  Il est bien plus rapide que l'ancien et lent tourbillon de Mersenne!  Mon programme se déroule en 3 minutes 15 secondes! » <br><br>  "Hmm, pas mal, mais le mien peut le faire en moins d'une minute", dit Juan en haussant les épaules.  «Eh bien, je dois aller au concert.  Voulez-vous venir avec moi? " <br><br>  "Non", répond Sasha.  "J'ai ... euh ... besoin de revoir mon code." <br><br>  Cette situation fictive gênante n'est <em>pas</em> particulièrement fictive;  il est basé sur des résultats réels.  Si votre algorithme randomisé ne fonctionne pas aussi vite que nous le souhaiterions et que le goulot d'étranglement semble être la génération de nombres aléatoires, alors, curieusement, le problème peut ne pas être dans le générateur de nombres aléatoires! <br><a name="habracut"></a><br><h3>  Introduction: les nombres aléatoires dans la pratique </h3><br>  La plupart des générateurs de nombres aléatoires modernes de haute qualité créent des mots machine remplis de bits aléatoires, c'est-à-dire qu'ils génèrent généralement des nombres dans l'intervalle [0..2 <sup>32</sup> ) ou [0..2 <sup>64</sup> ).  Mais dans de nombreux cas d'utilisation, les utilisateurs ont besoin de nombres dans un certain intervalle - par exemple, pour lancer un dé ou choisir une carte à jouer au hasard, les nombres sont nécessaires en petits intervalles constants.  Cependant, de nombreux algorithmes, du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mélange</a> et de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">échantillonnage du réservoir</a> aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arbres de recherche binaire randomisés,</a> nécessitent des nombres provenant d'autres intervalles. <br><br><h3>  Les méthodes </h3><br>  Nous examinerons de nombreuses méthodes différentes.  Pour simplifier la discussion, au lieu de générer des nombres dans l'intervalle [ <em>i</em> .. <em>j</em> ) ou [ <em>i</em> .. <em>j</em> ], nous allons générer des nombres dans l'intervalle [0 .. <em>k</em> ).  Avec un tel schéma, nous pouvons, par exemple, générer des nombres dans l'intervalle [ <em>i</em> .. <em>j</em> ) en fixant <em>k</em> = <em>j</em> - <em>i</em> , en générant un nombre dans l'intervalle [0 .. <em>k</em> ), puis en y ajoutant <em>i</em> . <br><br><h4>  Outils C ++ intégrés </h4><br>  De nombreuses langues ont des outils intégrés pour obtenir un nombre aléatoire dans un intervalle spécifié.  Par exemple, pour supprimer une carte d'un jeu de 52 cartes dans des langages de script tels que Perl et Python, nous pouvons écrire respectivement <code>int(rand(52))</code> et <code>random.randint(0,52)</code> .  [Remarque  Utilisateur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">CryptoPirate</a> : <i>Il me semble qu'une erreur ici, en Python randint (a, b) génère des nombres de a à b dont b.</i>  <i>Et comme il y a 52 cartes dans le jeu et que la première est «0», ce devrait être random.randint (0,51)</i> .] En C ++, nous pouvons utiliser <code>uniform_int_distribution</code> même <code>uniform_int_distribution</code> . <br><br>  Le code C ++ pour implémenter cette approche est simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt; dist(<span class="hljs-number"><span class="hljs-number">0</span></span>, range<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dist(rng); }</code> </pre> <br>  Habituellement, l'une des techniques décrites ci-dessous est utilisée dans les outils intégrés, mais la plupart des utilisateurs utilisent simplement ces outils, sans penser à ce qui se passe «sous le capot», estimant que ces outils sont correctement conçus et assez efficaces.  En C ++, les outils intégrés sont plus complexes car ils devraient pouvoir fonctionner avec des moteurs de génération assez arbitraires - un générateur qui produit des valeurs dans la plage de -3 à 17 peut être tout à fait valide et peut être utilisé avec <code>std::uniform_int_distribution</code> pour créer des nombres dans n'importe quel intervalle, par exemple [0..1000).  Autrement dit, les outils C ++ intégrés sont trop compliqués pour la plupart des cas où ils sont utilisés. <br><br><h4>  Le reste classique de la division (asymétrique) </h4><br>  Passons d'une approche trop simplifiée à une approche trop simpliste. <br><br>  Lorsque j'ai étudié la programmation, nous avons généré des nombres dans l'intervalle (par exemple, pour sélectionner une carte dans un jeu de 52 cartes) en utilisant l'opérateur restant.  Pour obtenir le nombre dans l'intervalle [0..52), nous avons écrit <code>rand() % 52</code> . <br><br>  En C ++, cette approche peut être implémentée comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rng() % range; }</code> </pre> <br>  Malgré la simplicité de cette approche, elle démontre la raison pour laquelle obtenir des nombres dans le bon intervalle est généralement une tâche lente - elle nécessite une division (pour calculer le reste obtenu par l'opérateur <code>%</code> ).  La division est généralement au moins un ordre de grandeur plus lente que les autres opérations arithmétiques, de sorte qu'une seule opération arithmétique prend plus de temps que tout le travail effectué par un PRNG rapide. <br><br>  Mais en plus de la faible vitesse, elle est également <em>asymétrique</em> .  Pour comprendre pourquoi <code>rand() % 52</code> renvoie des nombres asymétriques, supposons que <code>rand()</code> crée des nombres dans l'intervalle [0..2 <sup>32</sup> ), et notez que 52 ne divise pas complètement 2 <sup>32</sup> , il le divise 82 595 524 fois avec le reste 48. Autrement dit, si nous utilisons <code>rand() % 52</code> , nous aurons 82 595 525 façons de sélectionner les 48 premières cartes du jeu et seulement 82 595 524 façons de sélectionner les quatre dernières cartes.  En d'autres termes, il y a un biais de 0,00000121% par rapport à ces quatre dernières cartes (peut-être que ce sont des rois!).  Quand j'étais étudiant et que j'écrivais des devoirs sur le lancer de dés ou le tirage de cartes, personne ne se souciait généralement de ces petites distorsions, mais avec une augmentation de l'intervalle, la distorsion croît de façon linéaire.  Pour un PRNG 32 bits, un intervalle limité de moins de 2 <sup>24</sup> a un biais de moins de 0,5%, mais au-dessus de 2 <sup>31 un</sup> décalage de 50% - certains nombres reviendront deux fois plus souvent que d'autres. <br><br>  Dans cet article, nous considérerons principalement les techniques qui utilisent des stratégies pour éliminer une erreur systématique, mais il vaut probablement la peine de dire que pour un PRNG 64 bits, la valeur de biais dans les applications normales est probablement négligeable. <br><br>  Un autre problème peut être que certains générateurs ont des bits faibles faibles.  Par exemple, les familles GPRS Xoroshiro + et Xoshiro + ont des bits bas qui ne passent pas les tests statistiques.  Lorsque nous exécutons <code>% 52</code> (car 52 est pair), nous passons le bit de poids faible directement à la sortie. <br><br><h4>  Multiplier les nombres à virgule flottante (asymétrique) </h4><br>  Une autre technique courante consiste à utiliser un PRNG qui génère des nombres à virgule flottante dans l'intervalle [0..1) avec la conversion ultérieure de ces nombres à l'intervalle souhaité.  Cette approche est utilisée en Perl, il est <a href="">recommandé d'</a> utiliser <code>int(rand(10))</code> pour générer un entier dans l'intervalle [0..10) en générant un nombre à virgule flottante suivi d'un arrondi. <br><br>  En C ++, cette approche est écrite comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rng_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> zeroone = <span class="hljs-number"><span class="hljs-number">0x1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>p<span class="hljs-number"><span class="hljs-number">-32</span></span> * rng(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range * zeroone; }</code> </pre> <br>  (Notez que <code>0x1.0p-32</code> est une constante binaire à virgule flottante pour 2 <sup>-32</sup> , que nous utilisons pour convertir un entier aléatoire dans l'intervalle [0..2 <sup>32</sup> ) pour doubler dans l'intervalle unitaire;  à la place, nous pouvons effectuer une telle conversion en utilisant <code>ldexp(rng(), -32)</code> , mais quand j'ai évalué cette approche, cela s'est avéré beaucoup plus lent.) <br><br>  Cette approche est aussi biaisée que le reste classique de la division, mais le biais apparaît différemment.  Par exemple, si nous sélectionnions des nombres dans l'intervalle [0..52), alors les nombres 0, 13, 26 et 39 se produiraient une fois moins souvent que les autres. <br><br>  Cette version, lors de la généralisation à 64 bits, est encore plus désagréable, car elle nécessite un type à virgule flottante dont la mantisse est d'au moins 64 bits.  Sur les machines x86 avec Linux et macOS, nous pouvons utiliser le <code>long double</code> pour tirer parti des nombres à virgule flottante x86 de précision accrue qui ont une mantisse 64 bits, mais le <code>long double</code> pas universellement porté sur tous les systèmes - dans certains systèmes, le <code>long double</code> équivaut au <code>double</code> . <br><br>  Il y a un bon côté - cette approche est plus rapide que les solutions résiduelles pour les PRNG avec des bits faibles faibles. <br><br><h4>  Multiplication entière (asymétrique) </h4><br>  La méthode de multiplication peut être adaptée à l'arithmétique à virgule fixe plutôt qu'à flottante.  En fait, nous multiplions simplement constamment par 2 <sup>32</sup> , <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br>  Il peut sembler que cette version nécessite une arithmétique 64 bits, sur les processeurs x86, un bon compilateur compilera ce code dans une instruction <code>mult</code> 32 bits (ce qui nous donne deux valeurs de sortie 32 bits, dont l'une est la valeur de retour).  On peut s'attendre à ce que cette version soit rapide, mais elle est asymétrique exactement comme la méthode de multiplication des nombres à virgule flottante. <br><br><h4>  Division de baisse (pas de biais) </h4><br>  Nous pouvons modifier le schéma de multiplication à virgule flottante en schéma basé sur la division.  Au lieu de multiplier <code>x * range / 2**32</code> nous calculons <code>x / (2**32 / range)</code> .  Comme nous travaillons avec l'arithmétique des nombres entiers, l'arrondi dans cette version sera effectué différemment et générera parfois des valeurs en dehors de l'intervalle souhaité.  Si nous rejetons ces valeurs (par exemple, nous en débarrassons et générons de nouvelles valeurs), nous obtenons ainsi une technique sans distorsion. <br><br>  Par exemple, dans le cas du retrait d'une carte à l'aide d'un PRNG 32 bits, nous pouvons générer un nombre 32 bits et le diviser par 2 32/52 = 82 595 524 pour sélectionner une carte.  Cette technique fonctionne si la valeur aléatoire du PRNG 32 bits est inférieure à 52 × 82595524 = 2 32/32 - 48. Si la valeur aléatoire du PRNR est l'une des 48 dernières valeurs de la partie supérieure de l'intervalle du générateur, vous devez alors la supprimer et en chercher une autre. <br><br>  Notre code pour cette version utilise une astuce avec la division de 2 <sup>32</sup> par <code>range</code> sans utiliser de mathématiques 64 bits.  Pour un calcul direct de <code>2**32 / range</code> nous devons représenter le nombre 2 <sup>32</sup> , qui est trop grand (par un!) Pour représenter un entier 32 bits.  Au lieu de cela, nous prenons en compte que pour les entiers non signés, la <code>range</code> opération de négation unaire calcule une valeur positive de 2 <sup>32</sup> - <code>range</code> ;  en divisant cette valeur par <code>range</code> , nous obtenons une réponse inférieure à <code>2**32 / range</code> . <br><br>  Par conséquent, le code C ++ pour générer des nombres à l'aide de la division et de la suppression ressemble à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates divisor = 2**32 / range uint32_t divisor = ((-range) / range) + 1; if (divisor == 0) // overflow, it's really 2**32 return 0; for (;;) { uint32_t val = rng() / divisor; if (val &lt; range) return val; } }</span></span></code> </pre> <br>  Bien sûr, cette approche nécessite deux opérations lentes basées sur la division, qui sont généralement plus lentes que les autres opérations arithmétiques, vous ne devez donc pas vous attendre à ce qu'elle soit rapide. <br><br><h4>  Le reste de la division (double) sans distorsions - technique OpenBSD </h4><br>  Nous pouvons également adopter l'approche de baisse pour éliminer le biais dans la méthode du reste de division classique.  Dans l'exemple avec les cartes à jouer, nous devons à nouveau supprimer 48 valeurs.  Dans cette version, au lieu de supprimer les 48 <em>dernières</em> valeurs, nous rejetons (de manière équivalente) les 48 <em>premières</em> valeurs. <br><br>  Voici l'implémentation de cette approche en C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br>  Cette technique supprime le biais, mais elle nécessite deux opérations de division chronophages avec le reste de chaque valeur de sortie (et vous pouvez avoir besoin d'un générateur interne pour créer plusieurs nombres).  Par conséquent, il faut s'attendre à ce que la méthode soit environ deux fois plus lente que l'approche asymétrique classique. <br><br>  <a href=""><code> arc4random_uniform</code> OpenBSD <code> arc4random_uniform</code></a> (qui est également utilisé sur OS X et iOS) utilise cette stratégie. <br><br><h4>  Reste de division (simple) sans biais - méthodologie Java </h4><br>  Java utilise une approche différente pour générer un nombre dans un intervalle qui utilise une seule opération de division restante, à l'exception de cas assez rares de rejet du résultat.  Code: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rng_t&amp; rng, uint32_t range)</span></span></span><span class="hljs-function"> </span></span>{ uint32_t x, r; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng(); r = x % range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x - r &gt; (-range)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre> <br>  Pour comprendre pourquoi cette option fonctionne, vous devez réfléchir un peu.  Contrairement à la version précédente, basée sur les résidus, qui élimine les biais en supprimant une partie des valeurs les plus basses du moteur de génération interne, cette version filtre les valeurs de la partie supérieure de l'intervalle du moteur. <br><br><h4>  Multiplication d'entiers asymétriques - Méthode Lemira </h4><br>  De la même manière que nous avons supprimé le biais de la méthode du reste de la division, nous pouvons éliminer le biais de la technique de multiplication des nombres entiers.  Cette technique a été inventée par Lemyr. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><h4>  Drop bitmask (no skew) - Apple technique </h4><br>  Dans notre dernière approche, la division et les opérations restantes sont complètement éliminées.  Au lieu de cela, il utilise une opération de masquage simple pour obtenir un nombre aléatoire dans l'intervalle [0..2 <sup><em>k</em></sup> ), où <em>k</em> est la plus petite valeur, telle que 2 <sup><em>k est</em></sup> supérieur à l'intervalle.  Si la valeur est trop grande pour notre intervalle, nous la rejetons et essayons d'en obtenir une autre.  Le code est illustré ci-dessous: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask = ~<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); --range; mask &gt;&gt;= __builtin_clz(range|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng() &amp; mask; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt; range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br>  Cette approche a été adoptée par Apple lorsque (dans la version macOS Sierra) elle a effectué <a href="">sa propre révision</a> du code <code>arc4random_uniform</code> . <br><br><h3>  Analyse comparative des techniques de base </h3><br>  Nous avons maintenant plusieurs approches qui peuvent être évaluées.  Malheureusement, lorsque nous sommes préoccupés par les coûts d'une opération à division unique, l'analyse comparative devient une chose non triviale.  Aucune référence ne peut prendre en compte tous les facteurs affectant le domaine d'application, et rien ne garantit que la meilleure option pour votre application sera certainement la meilleure pour la mienne. <br><br>  Nous utilisons trois repères et testons les techniques avec de nombreux PRNG différents. <br><br><h4>  Benchmark Large-Shuffle </h4><br>  La référence la plus évidente est probablement le mixage.  Dans cette référence, nous simulons un mixage à grande échelle.  Pour trier un tableau de taille <em>N,</em> nous devons générer des nombres dans les intervalles [0 .. <em>N</em> ), [0 .. ( <em>N</em> -1)), ..., [0..1).  Dans ce cas-ci, nous supposerons que <em>N</em> est le nombre maximum possible (pour <code>uint32_t</code> il est 2 <sup>32</sup> -1).  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; }</code> </pre> <br>  Notez que nous «utilisons» chaque nombre en l'ajoutant à la <code>sum</code> (afin qu'il ne soit pas jeté par optimisation), mais nous n'effectuons aucun mixage pour nous concentrer sur la génération de nombres. <br><br>  Pour tester la génération 64 bits, nous avons un test similaire, mais il ne sera pas pratique d'effectuer un test correspondant au mélange d'un tableau de taille 2 <sup>64</sup> - 1 (car il faudra plusieurs milliers d'années pour compléter ce plus grand benchmark).  Au lieu de cela, nous traversons l'intégralité de l'intervalle 64 bits, mais générons le même nombre de valeurs de sortie que dans le test 32 bits.  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bound = (<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(i)&lt;&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>) | i; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bval = bounded_rand(rng, bound ); assert(bval &lt; bound); sum += bval; }</code> </pre> <br><h5>  Résultats du tourbillon de Mersenne </h5><br>  Les résultats ci-dessous montrent les performances de cette référence pour chacune des méthodes que nous avons examinées lors de l'utilisation du vortex de Mersenne et du test sur 32 bits (en utilisant <code>std::mt19937</code> de <code>libstdc++</code> ) et du code 64 bits similaire (en utilisant <code>std:mt19937_64</code> de <code>libstdc++</code> )  Les résultats sont la moyenne géométrique de 15 séries avec différentes valeurs de graine, qui est ensuite normalisée de sorte que la méthode du reste de la division classique ait un seul temps d'exécution. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/3eb/53f/b9f3eb53f894a14ac2698f44090b23a6.svg"></div><br>  Il peut sembler que nous ayons des réponses claires sur les performances - il semble que vous pouvez construire des techniques pour leur perfection et vous demander à quoi pensaient les développeurs de <code>libstdc++</code> lorsqu'ils ont écrit une implémentation aussi terrible pour les nombres 32 bits.  Mais, comme c'est souvent le cas avec l'analyse comparative, la situation est plus compliquée qu'il n'y paraît d'après ces résultats.  Premièrement, il existe un risque que les résultats soient spécifiques au vortex de Mersenne, nous allons donc étendre les nombreux PRNG testés.  Deuxièmement, il peut y avoir un problème subtil avec l'indice de référence lui-même.  Voyons d'abord la première question. <br><br><h5>  Résultats des différents PRNG </h5><br>  Nous testerons des <code>arc4_rand32</code> 32 bits avec les <code>arc4_rand32</code> , <code>chacha8r</code> , <code>gjrand32</code> , <code>jsf32</code> , <code>mt19937</code> , <code>pcg32</code> , <code>pcg32_fast</code> , <code>sfc32</code> , <code>splitmix32</code> , <code>xoroshiro64+</code> , <code>xorshift*64/32</code> <code>xoshiro128+</code> , <code>xoshiro128+</code> et <code>xoshiro128**</code> , et <code>xoshiro128**</code> <code>gjrand64</code> <code>jsf64</code> , <code>mcg128</code> , <code>mcg128_fast</code> , <code>mt19937_64</code> , <code>pcg64</code> , <code>pcg64_fast</code> , <code>sfc64</code> , <code>splitmix64</code> , <code>xoroshiro128+</code> , <code>xorshift*128/64</code> <code>xoshiro256+</code> , <code>xoshiro256+</code> et <code>xoshiro256*</code> .  Ces kits nous donneront des PRN lents et beaucoup de très rapides. <br><br>  Voici les résultats: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2dc/8c8/f1a/2dc8c8f1af9aa517a92260e7cbd3a73e.svg"></div><br>  Nous pouvons voir les principales différences par rapport aux résultats avec le vortex de Mersenne.  Des PRNG plus rapides déplacent l'équilibre vers le code de délimitation, et donc la différence entre les différentes approches devient plus prononcée, en particulier dans le cas des PRNR 64 bits.  Avec un ensemble plus large de <code>libstc++</code> implémentation de <code>libstc++</code> cesse de paraître si terrible. <br><br><h5>  Conclusions </h5><br>  Dans ce benchmark d'une marge importante, l'approche basée sur la multiplication avec biais gagne en vitesse.  Il existe de nombreuses situations dans lesquelles les limites seront petites par rapport à la taille du PRNG, et les performances sont absolument critiques.  Dans de telles situations, un léger biais est peu susceptible d'avoir un effet notable, mais la vitesse PRNG aura.  Un tel exemple est Quicksort avec un point de référence aléatoire.  Parmi les méthodes biaisées, la technique du masque bitmap semble prometteuse. <br><br>  Mais avant de tirer des conclusions sérieuses, nous devons souligner l'énorme problème de cette référence - la plupart du temps est consacré à des limites très élevées, ce qui donne très probablement une importance excessive à de grands intervalles.  Par conséquent, nous devons passer au deuxième repère. <br><br><h4>  Benchmark Small-Shuffle </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ce benchmark est similaire au précédent, mais effectue beaucoup moins de «mixage matriciel» (multiple). </font></font> Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; } }</code> </pre> <br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Résultats du tourbillon de Mersenne </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/d3b/4bd/6c5d3b4bdb5f2e45cd805a051d79ab9a.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Résultats des différents PRNG </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/9ae/8c0/45a9ae8c040cb4d297fe82f00fa06e3c.svg"></div><br><h5>  Conclusions </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cette référence évite de trop insister sur les grandes frontières et reflète plus précisément les cas d'utilisation réels, mais rejette désormais complètement les grandes frontières. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark pour tous les intervalles </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette référence vise à éviter les inconvénients des deux précédents; </font><font style="vertical-align: inherit;">il effectue des tests à chaque taille de la puissance de deux pour que chaque taille soit présente, mais son influence n'est pas surestimée.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bit = <span class="hljs-number"><span class="hljs-number">1</span></span>; bit != <span class="hljs-number"><span class="hljs-number">0</span></span>; bit &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">0x1000000</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bound = bit | (i &amp; (bit - <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, bound); assert(bval &lt; bound); sum += bval; } }</code> </pre> <br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Résultats du tourbillon de Mersenne </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/65c/447/f3465c447f9b19b430bb43533a655c2f.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Résultats des différents PRNG </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/c58/2a2/64bc582a2fde24fd0faedbeaabb9f64c.svg"></div><br><h5>  Conclusions </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bon nombre de nos constatations demeurent inchangées. </font><font style="vertical-align: inherit;">La méthode asymétrique est rapide si nous pouvons supporter l'erreur, et le schéma de masque de bits semble être un bon choix moyen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pourrions mettre fin à cela si nous ne voulions pas revenir en arrière, jeter un regard critique sur notre code et y apporter des modifications.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apportez des améliorations </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'à ce point, toutes les méthodes d'élimination de l'inclinaison nécessitaient l'utilisation d'une opération de division résiduelle supplémentaire, c'est pourquoi elles sont exécutées beaucoup plus lentement que les méthodes d'inclinaison. </font><font style="vertical-align: inherit;">Il serait utile de réduire cet avantage.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chute basée sur un seuil plus rapide </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Certains de nos algorithmes ont du code utilisant une valeur de seuil, par exemple: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'il est </font></font><code>range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">petit par rapport à l'intervalle de sortie PRNG, le plus souvent le nombre sera </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beaucoup plus grand que le</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seuil. </font><font style="vertical-align: inherit;">Autrement dit, si nous pouvons ajouter une estimation préliminaire du seuil, qui peut être un peu plus, nous économiserons sur l'opération coûteuse de prendre le reste de la division. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code suivant gère cette tâche:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> r = rng(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (r &lt; t) r = rng(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r % range; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette modification peut être appliquée à la fois au «double Mod sans distorsions» (voir ci-dessus) et à la «multiplication entière sans distorsions». </font><font style="vertical-align: inherit;">L'idée a été inventée par Lemir, qui l'a appliquée à la deuxième méthode (mais pas à la première).</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Résultats de référence à grande échelle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette optimisation conduit à une amélioration significative des résultats du benchmark 64 bits (dans lequel le mod est encore plus lent), mais dégrade en fait légèrement les performances du benchmark 32 bits. </font><font style="vertical-align: inherit;">Malgré les améliorations, la méthode bitmask gagne toujours.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb4/61d/b52/bb461db52be4a7d983dd7f97844179c0.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Résultats des tests de référence à petite échelle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'un autre côté, ce changement accélère considérablement le repère de petit shuffle pour la méthode de multiplication entière et la méthode du double reste de division. </font><font style="vertical-align: inherit;">Dans les deux cas, leurs performances se rapprochent davantage des résultats des options sans distorsions. </font><font style="vertical-align: inherit;">Les performances de la méthode des résidus doubles (OpenBSD) sont désormais quasiment égales aux performances de la méthode des résidus simples (Java).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/2bd/fe2/f072bdfe2660cf0f8789b124a8f02646.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Résultats de référence pour tous les intervalles </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous constatons une amélioration similaire de l'indice de référence pour tous les intervalles. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/219/b1d/add/219b1daddfa6a55a2cb485b3ae774016.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il semble que nous pouvons annoncer un nouveau gagnant universel: une méthode optimisée pour multiplier les entiers Lemire sans biais. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimisation du reste de la division </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En règle générale, un calcul </font></font><code>a % b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nécessite une division, mais dans les situations où le </font></font><code>a &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">résultat est simple </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la division n'est pas requise. </font><font style="vertical-align: inherit;">Et quand </font></font><code>a/2 &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le résultat est simple </font></font><code>a - b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Par conséquent, au lieu de calculer</font></font><br><br><pre> <code class="cpp hljs">a %= b;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous pouvons accomplir </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) { a -= b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) a %= b; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le coût de la division est si important que l'augmentation du coût de ce code plus complexe peut se justifier par un gain de temps dû au manque de division. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Résultats de référence à grande échelle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ajout de cette optimisation améliore considérablement les résultats du test de référence à grand shuffle. </font><font style="vertical-align: inherit;">Ceci est encore plus visible dans le code 64 bits, où l'opération de prise du reste est plus coûteuse. </font><font style="vertical-align: inherit;">La méthode du double reste (style OpenBSD) affiche les versions avec optimisations pour une seule opération restante et pour les deux.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e1a/669/c56e1a669836477e46f870bd1bc7a6c9.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans cette référence, le masque de bits est toujours le gagnant, mais la frontière entre celui-ci et l'approche de Lemira s'est considérablement rétrécie. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Résultats des tests de référence à petite échelle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ajout de cette optimisation n'augmente pas les performances de la référence de petit shuffle, donc la question reste de savoir si elle ajoute des coûts importants. </font><font style="vertical-align: inherit;">Dans certains cas, non; dans d'autres, les coûts augmentent légèrement.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/4db/b65/6fa4dbb65b9a3f6c6f9e8ba4f7b455db.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Résultats de référence pour tous les intervalles </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans la référence pour tous les intervalles, les changements sont également faibles. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0e/ae7/758/e0eae77583cc457a9e923540ad954257.svg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bonus: résultats de la comparaison du DSRP </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La raison principale de l'utilisation d'un grand nombre de PRNG pour tester les schémas de numérotation à intervalles était d'éviter la distorsion involontaire des résultats en raison des particularités du fonctionnement des schémas PRNG individuels. </font><font style="vertical-align: inherit;">Mais nous pouvons utiliser les mêmes résultats de tests internes pour comparer les schémas de génération eux-mêmes.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG avec sortie 32 bits </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le graphique ci-dessous montre les performances de divers schémas de génération 32 bits, moyennées pour toutes les méthodes et quinze exécutions, normalisées aux performances du vortex Mersenne 32 bits: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'une part, je suis heureux de voir que c'est </font></font><code>pcg32_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vraiment rapide - il n'a été vaincu que par une petite version de Xoroshiro (qui ne passe pas les tests statistiques). </font><font style="vertical-align: inherit;">Mais cela montre aussi pourquoi je me fâche rarement à cause des performances des DSRP polyvalents modernes à hautes performances - la différence entre les différentes méthodes est très insignifiante. </font><font style="vertical-align: inherit;">En particulier, les quatre circuits les plus rapides présentent des performances inférieures à 5%, et je pense que cela est simplement dû au «bruit».</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG avec sortie de nombres 64 bits </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le graphique montre les performances de divers schémas de génération 64 bits en moyenne parmi toutes les techniques et quinze cycles normalisés aux performances du vortex Mersenne 32 bits. Il peut sembler étrange que la normalisation soit effectuée à l'aide du vortex Mersenne 32 bits, mais cela nous permet de voir les coûts supplémentaires liés à l'utilisation de la génération 64 bits dans les cas où la génération 32 bits est suffisante.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/16c/b24/92816cb249e7f76c4ed4e11c65f67475.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces résultats confirment qu'elle est </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incroyablement rapide, mais les quatre dernières techniques ne diffèrent à nouveau que d'environ 5%, il est donc difficile de choisir parmi les méthodes les plus rapides. </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>pcg64_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être plus lent </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car leurs générateurs de base sont des générateurs congruents linéaires 128 bits (LCG) et des générateurs congruents multiplicatifs 128 bits (MCG, MCG). Bien qu'ils ne soient pas les techniques les plus rapides de cet ensemble, ils sont </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toujours 20% plus rapides que le vortex Mersenne 64 bits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais peut-être plus important encore, ces résultats montrent également que si vous n'avez pas besoin d'une sortie 64 bits, un PRNG 64 bits est généralement plus lent qu'un 32 bits.</font></font><br><br><h3>  Conclusions </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À partir de nos benchmarks, nous pouvons voir que la transition des PRNG standard (par exemple, le vortex Mersenne 32 bits) vers des PRNP plus rapides a réduit le temps d'exécution des benchmarks de 45%. </font><font style="vertical-align: inherit;">Mais le passage de la méthode standard de recherche du nombre dans l'intervalle à notre méthode la plus rapide nous a permis de réduire le temps de référence d'environ 66%; </font><font style="vertical-align: inherit;">en d'autres termes, jusqu'à un tiers de l'heure d'origine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La méthode la plus rapide (sans distorsions) est la méthode Lemira (avec mon optimisation supplémentaire). </font><font style="vertical-align: inherit;">Le voici:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = -range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) { t -= range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) t %= range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t) { x = rng(); m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'utilisation de la méthode Lemira améliorera davantage les performances de la plupart des algorithmes randomisés que le passage d'un moteur de génération rapide à un moteur plus rapide. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Annexes: notes de test </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code de tous les tests est publié sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Au total, j'ai testé 23 méthodes pour </font></font><code>bounded_rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliser 26 PRN différents (13 PRN 32 bits et 13 64 bits), dans deux compilateurs (GCC 8 et LLVM 6), ce qui m'a donné 26 * 23 * 2 = 1196 fichiers exécutables, chacun dont il a été effectué avec les mêmes 15 semences, ce qui donne 1196 * 15 = 17 940 séries de tests uniques, dans chacune desquelles trois repères sont combinés. Fondamentalement, j'ai effectué des tests sur une machine à 48 cœurs avec quatre processeurs Xeon E7-4830v3 à 2,1 GHz. L'exécution d'un ensemble complet de tests a pris un peu moins d'un mois de temps processeur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au final, nous revenons à la situation depuis l'introduction de l'article. Imaginez que Sasha a utilisé </font></font><code>jsf32.STD-libc++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et Juan -</font></font><code>mt19937.BIASED_FP_MULT_SCALE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans le benchmark 3, ce dernier prend 69,6% de temps en moins. </font><font style="vertical-align: inherit;">Autrement dit, le temps de cette situation fictive est basé sur des données de la réalité.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455702/">https://habr.com/ru/post/fr455702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455692/index.html">ASZP: le restyling ou le théâtre commence par un cintre</a></li>
<li><a href="../fr455694/index.html">Architecture de facturation de nouvelle génération: transition vers Tarantool</a></li>
<li><a href="../fr455696/index.html">L'état électronique du futur. 2e partie</a></li>
<li><a href="../fr455698/index.html">Le livre "Comment JavaScript fonctionne"</a></li>
<li><a href="../fr455700/index.html">4 astuces qui nous ont aidés à optimiser le frontend</a></li>
<li><a href="../fr455710/index.html">Pourquoi chez Leroy Merlin, avons-nous besoin de notre propre service de développement russe pour 200 personnes</a></li>
<li><a href="../fr455714/index.html">Exportez automatiquement Google Forms vers Notion à l'aide d'IFTTT et de Django</a></li>
<li><a href="../fr455716/index.html">15 meilleures pratiques pour le déploiement de logiciels de Business Intelligence</a></li>
<li><a href="../fr455720/index.html">Comment nous construisons l'interface utilisateur pour les systèmes publicitaires</a></li>
<li><a href="../fr455722/index.html">Python consomme beaucoup de mémoire ou comment réduire la taille des objets?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>