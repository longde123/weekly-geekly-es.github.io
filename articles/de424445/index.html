<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏾 🧑🏿‍🤝‍🧑🏽 🚼 Neil Fords Übersetzung von Microservices als evolutionäre Architektur 🏆 👩🏿‍✈️ ✊🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben eine Übersetzung eines Artikels von Neil Ford, einem Systemarchitekten und ideologischen Vordenker bei ThoughtWorks, einem Softwareentwicklu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Neil Fords Übersetzung von Microservices als evolutionäre Architektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/luxoft/blog/424445/">  Wir haben eine Übersetzung eines Artikels von Neil Ford, einem Systemarchitekten und ideologischen Vordenker bei ThoughtWorks, einem Softwareentwicklungsunternehmen, das Softwaretests und Bereitstellungsprozesse automatisiert, vorbereitet. <br><br><img align="left" width="140" src="https://habrastorage.org/webt/gi/gn/cm/gigncmbcb8gysz-vdgyt7izb12g.jpeg">  Neil ist ein anerkannter Softwareentwicklungsexperte, der an der Schnittstelle zwischen agilem Design und Systemarchitektur arbeitet.  Er ist Autor zahlreicher Artikel, Bücher, Dutzende von Videopräsentationen und spricht auf führenden Entwicklerkonferenzen.  Sie können seine Arbeit auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nealford.com sehen</a> . <br><a name="habracut"></a><br><h2>  Microservices als evolutionäre Architektur </h2><br>  Die Microservice-Architektur erobert schnell die Welt.  Im März organisierte der O'Reilly-Verlag seine erste O'Reilly-Software-Architekturkonferenz.  Fast 60% der Berichte widmeten sich bestimmten Aspekten der Nutzung von Mikrodiensten.  Warum wurde dieser besondere Baustil plötzlich so beliebt? <br><br>  Die Microservice-Architektur ist ein neuer architektonischer Entwurfsstil, der nach DevOps entstanden ist und kontinuierliche Softwarebereitstellungspraktiken beinhaltet.  Es ist auch ein Beispiel für eine evolutionäre Architektur, die dem Prinzip allmählicher, kontinuierlicher Änderungen in mehreren Dimensionen auf der strukturellen Ebene einer Anwendung folgt.  Dieser Artikel beschreibt einige der wichtigsten Merkmale und Prinzipien dieser Familie von Architekturstilen. <br><br><h2>  Evolutionäre Architektur </h2><br>  Früher glaubte man, dass die Elemente der Architektur "nach ihrer Entstehung sehr schwer zu ändern sind".  Allmählicher Wandel ist das Hauptprinzip der evolutionären Architektur.  Es zieht allgemeine Aufmerksamkeit auf sich, gerade weil Änderungen in der Architektur immer schwer vorhersehbar und sehr kostspielig waren.  Wenn die Möglichkeit von evolutionären Änderungen in die Architektur selbst integriert ist, wird ihre Implementierung viel einfacher und billiger, was zu Änderungen in der Softwareentwicklung und den Release-Praktiken beiträgt und die allgemeine Prozessflexibilität erhöht. <br><br>  Die Microservice-Architektur stimmt voll und ganz mit dieser Idee überein, da sie über begrenzte <i>Kontexte verfügt</i> , die gemäß Eric Evans 'Domain Driven Design logisch zugeordnet und als physisch separate Komponenten implementiert sind.  Diese Trennung wird durch die Implementierung von DevOps-Praktiken wie Bereitstellung, Test und automatisierte Bereitstellung virtueller Maschinen erreicht.  Da jeder Dienst von allen anderen Diensten (auf struktureller Ebene) getrennt ist, ist das Ersetzen eines Mikrodienstes durch einen anderen so einfach wie das Austauschen von Legowürfeln. <br><br><h2>  Merkmale der evolutionären Architektur </h2><br>  Evolutionäre Architekturen weisen eine Reihe gemeinsamer Merkmale auf.  All diese Merkmale werden in einem bevorstehenden Buch über evolutionäre Architektur beschrieben.  In diesem Artikel geben wir nur einige davon. <br><br><h3>  Modularität und Konnektivität </h3><br>  Die Möglichkeit, Komponenten innerhalb genau definierter Grenzen gemeinsam zu nutzen, bietet Entwicklern bei Bedarf den Vorteil einer kontinuierlichen Änderung.  Wenn die Architektur nicht entworfen wurde und das System wie ein großer Schlammballen aussieht ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Big Ball of Mud-Architektur</a> ), sind evolutionäre Änderungen unmöglich, da es in einer solchen Struktur keine unterscheidbaren Teile gibt. <br><img src="https://habrastorage.org/webt/tb/ll/no/tbllnoetavmhatzxhtqqzfipcvy.png"><br><br>  <i>[Die Beziehung zwischen den Klassen (Punkte um den Umfang) in einem großen Schmutzbündel aus einem unbenannten Kundenprojekt.]</i> <br><br>  Eine falsche Komponentenverbindung behindert die Entwicklung des Systems aufgrund der Tatsache, dass Änderungen unvorhersehbar andere Teile des Systems beeinflussen können.  Alle evolutionären Architekturen bieten ein gewisses Maß an Modularität, normalerweise auf der Ebene der technischen Architektur (z. B. Schichtarchitektur). <br><br><h3>  Organisation rund um Geschäftsmöglichkeiten </h3><br>  Beeinflusst von den Prinzipien des themenorientierten Designs in modernen erfolgreichen Architekturen wird zunehmend Modularität auf Domänenebene eingesetzt.  Eine service-basierte Architektur unterscheidet sich von einer herkömmlichen serviceorientierten Architektur (SOA) hauptsächlich in ihrer Service-Allokationsstrategie.  Serviceorientierte Architektur ist streng nach technischen Ebenen unterteilt, während serviceorientierte Architekturen hauptsächlich in Teilen des durch Microservices definierten Themenbereichs erstellt werden. <br><br><h3>  Die Experimente </h3><br>  Die Durchführung von Experimenten ist einer der wesentlichen Vorteile, die die evolutionäre Architektur für Unternehmen bietet.  Die Möglichkeit, auf einfache Weise kleine Änderungen an Anwendungen vorzunehmen, ermöglicht die Verwendung gängiger kontinuierlicher Bereitstellungsverfahren wie A / B-Tests, Tests für eine begrenzte Gruppe von Benutzern (Canary Release) und andere.  Microservice-Architekturen werden häufig auf der Grundlage von Routing-Serviceaufrufen erstellt, sodass mehrere Versionen des Service innerhalb eines gesamten Ökosystems verwendet werden können.  Dies eröffnet wiederum große Möglichkeiten zum Experimentieren und zur Änderung bestehender Funktionen.  Letztendlich wird bei der Entwicklung von Geschäftsanwendungen weniger Zeit für die Erörterung von Plänen und Rückständen aufgewendet, und die Entwicklung erfolgt hauptsächlich im Rahmen des schnellen Hypothesentests. <br><br><h2>  Prinzipien der evolutionären Architektur </h2><br>  Ein vollständigeres Bild der evolutionären Architektur kann erhalten werden, indem man sich mit ihren Grundprinzipien vertraut macht.  Diese Prinzipien beziehen sich auf verschiedene Merkmale sowohl der Architektur selbst als auch ihrer Entwurfsmethoden.  Ein Teil der Prinzipien bezieht sich auf die Wahl des Zeitpunkts, zu dem architektonische Entscheidungen im Prozess des Systemdesigns getroffen werden. <br><br><h3>  Fitnessfunktion </h3><br>  Es ist notwendig, zwischen emergenter (als Ergebnis des Designprozesses gebildeter) und evolutionärer Architektur zu unterscheiden - dies ist äußerst wichtig.  Wie evolutionäre Berechnungsmethoden (wie genetische Algorithmen) setzt die architektonische Fitnessfunktion ein Ziel bei der architektonischen Gestaltung.  Bei einigen Systemen ist die Hauptanforderung eine lange Betriebszeit, bei anderen eine hohe Leistung oder Sicherheit. <br><br><img src="https://habrastorage.org/webt/kh/c3/_g/khc3_gz_0ocw-kpiakepfit73ak.png"><br>  <i>[Radarkarte zur Hervorhebung wichtiger Fitnessfunktionen, die für dieses Softwaresystem relevant sind.]</i> <i><br></i> <br>  Wenn Sie die Fitnessfunktion für ein bestimmtes System vorab festlegen, hilft dies in Zukunft, rechtzeitig die richtigen Entscheidungen zu treffen.  Für verschiedene Architekturlösungen können Sie Fitnessfunktionen berechnen. Wenn der Wert besser wird, bedeutet dies, dass sich die Architektur in die richtige Richtung entwickelt. <br><br><h3>  Aufmerksamkeit auf Schmerzpunkte </h3><br>  Viele der Arbeitsmethoden, die bei der kontinuierlichen Bereitstellung von Software und der Entwicklung einer sich entwickelnden Architektur verwendet werden, basieren auf dem von der eXtreme Programming-Community formulierten Prinzip der „Beachtung von Schwachstellen“.  Wenn in der Entwurfsarbeit Momente auftreten, die zu Problemquellen (Schmerzpunkten) werden können, müssen diese so schnell wie möglich beachtet werden.  Dies wird dazu beitragen, potenzielle Probleme im Voraus zu identifizieren und in einem funktionierenden Zustand zu beseitigen.  Gängige kontinuierliche Bereitstellungsverfahren wie die Bereitstellungspipeline, die automatische Bereitstellung virtueller Maschinen und die Datenbankmigration beim Entwerfen einer evolutionären Architektur vereinfachen die Beseitigung von Schwachstellen während der Änderungsphase erheblich. <br><br><h3>  Entscheidungspunkt </h3><br>  Der Hauptunterschied zwischen traditioneller und evolutionärer Architektur besteht darin, dass wichtige Entscheidungen getroffen werden.  Diese Entscheidungen können sich auf die Anwendungsstruktur, den Technologie-Stack, einzelne Tools oder Kommunikationsmuster beziehen.  Beim Entwerfen einer traditionellen Architektur werden solche Entscheidungen in der Anfangsphase getroffen, bevor der Code geschrieben wird.  Bei der Entwicklung der evolutionären Architektur werden Entscheidungen so spät wie möglich getroffen, im letzten Moment, wenn sie noch akzeptabel sind.  Der Vorteil einer späteren Entscheidungsfindung besteht darin, dass an dieser Stelle möglicherweise zusätzliche Informationen verfügbar sind.  Die Kosten dieser Methode umfassen die Kosten einer möglichen Verfeinerung der Architektur nach einer Entscheidung.  Diese Kosten können durch geeignete Abstraktionen reduziert werden, können aber dennoch auftreten.  Die Kosten für Entscheidungen in der Anfangsphase sind jedoch ebenfalls sehr real.  Treffen Sie zum Beispiel die Entscheidung, ein Messaging-Tool auszuwählen.  Verschiedene Tools unterstützen unterschiedliche Funktionen.  Wenn wir ein leistungsfähigeres Werkzeug als nötig wählen, erhalten wir eine schlecht konzipierte Architektur, die zwangsläufig weiterentwickelt werden muss.  Diese "technische Verschuldung", die sich aus der Auswahl des falschen Tools ergibt, wird eine zusätzliche Belastung für die Entwickler sein. <br><br>  Natürlich besteht das Hauptproblem im letztmöglichen Moment einer Entscheidung darin, festzustellen, wann es kommt.  Konzentrieren Sie sich dazu auf die Funktion der Fitness.  Zunächst müssen Entscheidungen getroffen werden, die einen erheblichen Einfluss auf die Auswahl der Architektur oder der Gestaltungselemente haben können, sowie Entscheidungen, die den Gesamterfolg des Projekts erheblich beeinflussen.  Die negativen Auswirkungen einer Verzögerung einer solchen Entscheidung überwiegen häufig die möglichen Vorteile einer späteren Entscheidung. <br><br><h2>  Fazit </h2><br>  Softwarearchitekten sollten die Entscheidungen über den Entwurf der zu entwickelnden Systeme in der Regel anhand verschiedener Arten von Diagrammen erläutern.  Architekturentwickler geraten häufig in die Falle, Softwarearchitektur als die Gleichung darzustellen, die sie lösen müssen.  Mit vielen kommerziellen Tools, die von Softwarearchitekten angeboten werden, können Sie die Architektur formell in Form von Quadraten, Linien und Pfeilen beschreiben.  Obwohl solche Diagramme nützlich sein mögen, bieten sie nur eine zweidimensionale Darstellung, eine Momentaufnahme der idealen Welt, aber wir leben in einer vierdimensionalen Realität. <br><br>  Um ein solches zweidimensionales Diagramm mit Leben zu füllen, muss es spezifiziert werden.  Das <i>ORM-</i> Label in einem zweidimensionalen Diagramm wird zu <i>Hibernate v4.2.17</i> , wodurch die <i>betreffende</i> Welt dreidimensional wird.  Wenn Sie einen Plan für die Implementierung in der Produktion haben und sechs Monate später auf die unvermeidliche Version von <i>Hibernate v4.3.0.1 aktualisieren</i> , sind Sie bereit für die vierdimensionale Welt.  Viele Architekten erkennen nicht, dass eine statische Ansicht der Architektur eine kurze Lebensdauer hat.  Das Softwareuniversum existiert in einem Stream-Zustand, es ist dynamisch, nicht statisch.  Architektur ist keine Gleichung, sondern eine Momentaufnahme eines laufenden Prozesses. <br><br>  Praktiken der kontinuierlichen Softwarebereitstellung und von DevOps haben gezeigt, dass Probleme aufgrund eines Mangels an Verständnis für die Anstrengungen entstehen, die zur Implementierung und Unterstützung der Architektur erforderlich sind.  Die Implementierung der Architektur ist nur der erste Schritt.  <b>Architektur bleibt eine Abstraktion, bis sie in die Tat umgesetzt wird.</b>  Mit anderen Worten, die langfristige Rentabilität einer Architektur kann nur beurteilt werden, wenn Sie sie nicht nur implementiert, sondern auch mindestens einmal geändert haben.  Und vielleicht haben sie es geschafft, die Überraschungen auf dem Weg zu bewältigen. <br>  Das Verständnis der Betriebsfähigkeiten eines Softwarearchitekten ist entscheidend für die Entwicklung einer evolutionären Architektur.  Die evolutionäre Entwicklung der Architektur wirkt sich auf die Merkmale ihrer Implementierung aus und muss daher bei der Fertigstellung berücksichtigt werden.  Die Anforderungen des kontinuierlichen Bereitstellungsprozesses für die Architektur zielen darauf ab, ihre Visualisierung zu verbessern und Änderungen zu vereinfachen.  Auf diese Weise verbessert die kontinuierliche Bereitstellung die Fähigkeiten der evolutionären Architektur. <br><br>  Am 19. November kommt Neil Ford mit einer Meisterklasse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zum Erstellen einer evolutionären Softwarearchitektur</a> nach Moskau. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424445/">https://habr.com/ru/post/de424445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424433/index.html">Warum Hacker Mikrotik und wie ich 100.000 RouterOS vor einem Botnetz versteckt habe</a></li>
<li><a href="../de424435/index.html">Ölbohrzoo: Ordnung schaffen</a></li>
<li><a href="../de424437/index.html">Ulme. Bequem und umständlich. Json.Encoder und Json.Decoder</a></li>
<li><a href="../de424441/index.html">Was ist neu im ersten CTP von SQL Server 2019?</a></li>
<li><a href="../de424443/index.html">Vivaldi 2.0 zu unseren Gunsten</a></li>
<li><a href="../de424447/index.html">Lisp mit Pascal oder der Programmiersprache 8501. gewürzt</a></li>
<li><a href="../de424453/index.html">Lerne OpenGL. Lektion 6.2 - Physikalisches Rendern. Analytische Lichtquellen</a></li>
<li><a href="../de424455/index.html">Intel Optane - Jetzt 1,5 Terabyte</a></li>
<li><a href="../de424457/index.html">IDA Pro aktualisieren. Bootloader in Python schreiben lernen</a></li>
<li><a href="../de424459/index.html">Erfolgsgeschichte oder DEV + DEVOPS + OPS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>