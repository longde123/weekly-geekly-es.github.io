<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº üéä üßëüèæ Entropiecodierung rANS oder wie man einen eigenen Archivierer schreibt üßõüèº üé¢ üßî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel kann f√ºr diejenigen von Interesse sein, die sich mit Datenkomprimierung besch√§ftigen oder einen eigenen Archivierer schreiben m√∂chten. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entropiecodierung rANS oder wie man einen eigenen Archivierer schreibt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/441814/">  Dieser Artikel kann f√ºr diejenigen von Interesse sein, die sich mit Datenkomprimierung besch√§ftigen oder einen eigenen Archivierer schreiben m√∂chten. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/jz/w8/xk/jzw8xkq1k6enudm8xozmna6m3ia.jpeg"></a> <br><br>  Der Artikel basiert haupts√§chlich auf den Materialien des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blogs</a> , das von Fabian Giesen gepflegt wird. <br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br>  Die Entropiecodierungsmethode rANS ( <b>r</b> ange + ANS) ist das Geschwister des FSE-Algorithmus, √ºber den ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuvor geschrieben habe</a> .  Die Abk√ºrzung ANS bedeutet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asymmetric Numeral Systems</a> , und der Wortbereich im Namen weist auf die √Ñhnlichkeit dieser Methode mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intervallcodierung hin</a> .  Der Autor von rANS ist <a href="">Yarek Duda</a> . <br><br>  Mit der rANS-Methode k√∂nnen Sie bei sehr hoher Geschwindigkeit eine nahezu optimale Komprimierung erzielen.  Dabei ist rANS nicht schlechter als FSE, was nicht verwunderlich ist: Beide Algorithmen basieren auf einer gemeinsamen theoretischen Basis.  Der rANS-Algorithmus ist jedoch viel einfacher zu implementieren als FSE. <br><br>  Zuerst wird es einen langen ‚Äûtheoretischen‚Äú Teil geben, und dann werden wir versuchen, einen einfachen Archivierer zu schreiben. <br><br><h2>  Methodenbeschreibung </h2><br>  Die Funktionsweise des Algorithmus wird durch die folgenden einfachen Formeln bestimmt: <br><br>  <b>Codierung:</b> <code>C(s,x): x := (x / Fs) * M + Bs + (x % Fs)</code> <br>  <b>Decodierung:</b> <code>D(x): s = sym[x % M], x := Fs * (x / M) + (x % M) - Bs</code> <br><br>  Lassen Sie uns sie im Detail analysieren. <br><br>  Die Codierungsfunktion <b>C (s, x)</b> empf√§ngt das zu codierende Zeichen <b>s</b> (sei es eine ganze Zahl) und den aktuellen Zustand des Codierers <b>x</b> (auch eine ganze Zahl). <br><br>  <b>F <sub>s</sub></b> - Symbolfrequenz <b>s</b> .  Die obige Division durch Fs ist eine ganze Zahl. <br>  <b>M</b> ist die Summe der H√§ufigkeiten aller Symbole des Alphabets ( <b>M =</b> Œ£ <b>F <sub>s</sub></b> ). <br>  <b>In <sub>s</sub></b> der Beginn des Intervalls, das dem codierten Zeichen entspricht (in der folgenden Abbildung). <br>  <b>x</b> % <b>Fs</b> ist der Rest der Division von <b>x</b> durch <b>F <sub>s</sub></b> . <br><br>  Das Funktionsprinzip ist das gleiche wie bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">arithmetischen Codierung</a> : Wir nehmen das Segment <b>[</b> 0, <b>M)</b> und teilen es in Teile, so dass jedes Zeichen <b>s</b> einem Intervall entspricht, dessen Gr√∂√üe der H√§ufigkeit des Zeichens <b>F <sub>s entspricht</sub></b> .  Das Auftreten des Wertes <b>x% M</b> in einem beliebigen Intervall bezeichnet die Codierung des entsprechenden Symbols. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6i/vl/ql/6ivlqldcqlkeuwsxu6fcypus39o.png"></div><br>  Initialisieren Sie zu Beginn der Codierung <b>x mit</b> einem beliebigen geeigneten Wert und berechnen Sie dann die Funktion <b>C (s, x)</b> f√ºr alle codierten Zeichen nacheinander. <br><br>  Jede Berechnung der Funktion <b>C (s, x)</b> erh√∂ht den Wert von <b>x</b> .  Wenn es zu gro√ü wird, sollten Sie die Daten in der Ausgabe sichern: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt;= x_max) {   writeToStream(x % b); <span class="hljs-comment"><span class="hljs-comment">//     x /= b; //  x }</span></span></code> </pre> <br>  Dieser Schritt wird als <i>Renormierung bezeichnet</i> .  Danach k√∂nnen Sie mit dem Codieren fortfahren. <br><br>  Oben im Code erschienen neue Konstanten: <b>x_max</b> und <b>b</b> .  <b>Theoretisch</b> h√§ngen die Zahlen <b>M</b> , <b>b</b> und <b>x_max</b> durch einige Beziehungen zusammen. In der Praxis ist es jedoch am effektivsten, die folgenden Werte zu verwenden, wenn der Zustand uint32 f√ºr den Zustand <code>x</code> : <br><br>  <b>M</b> = 2 ^ <b>k</b> , wobei <b>k</b> &lt;= 16 ist <br>  <b>b</b> = 2 ^ 16 (halb so gro√ü wie uint32) <br><br>  Die Wahl von <b>M</b> = 2 ^ <b>k</b> beruht auf der Tatsache, dass es in der Decodierungsfunktion eine Division durch <b>M</b> gibt, so dass die Division mit dem Rest durch bitweise Operationen ersetzt werden kann. <br><br>  Der Wert von <b>k</b> wird aus den folgenden √úberlegungen ausgew√§hlt: Je gr√∂√üer er ist, desto h√∂her ist die Genauigkeit von <b>F <sub>s</sub></b> und desto effizienter ist die Komprimierung.  In diesem Fall muss ein gewisser Aufwand f√ºr das Speichern der Frequenztabelle ber√ºcksichtigt werden, sodass es sich nicht immer lohnt, die Maximalwerte von <b>k zu verwenden</b> . <br><br>  Der Wert von <b>x_max</b> sollte so sein, dass kein √úberlauf auftritt.  Basierend auf der Codierungsfunktion erhalten wir <b>x</b> &lt; <b>uint32_max</b> * <b>Fs</b> / <b>M</b> oder einen etwas anderen Weg: <b>x_max</b> &lt;= ( <b>b</b> * <b>L</b> ) * <b>Fs</b> / <b>M</b> , wobei <b>L</b> &lt;= <b>uint32_max</b> / <b>b</b> .  Im realen Code hat die Bedingung die Form x / b&gt; = L / M * Fs, um einen √úberlauf in den Berechnungen zu vermeiden. <br><br>  Der Wert <b>b</b> = 2 ^ 16 (halb so gro√ü wie uint32) wird so gew√§hlt, dass, wenn <b>x</b> <b>x_max</b> √ºberschreitet, eine Division durch <b>b</b> ausreicht, um weiterzuarbeiten.  Infolgedessen endet die <code>while</code> nach der ersten Iteration, was bedeutet, dass sie durch ein einfaches <code>if</code> . <br><br>  Infolgedessen hat die Codierungsfunktion die folgende Form: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RansState; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RANS_L = <span class="hljs-number"><span class="hljs-number">1u</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> k = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   constexpr uint32_t RANS_M = 1u &lt;&lt; k; // M = 2^k //   s void RansEnc(RansState&amp; x, uint32_t s, RansOutBuf&amp; out) {   assert(x &gt;= RANS_L); //        uint32 Fs = freq[s]; //   s   uint32 Bs = range_start[s]; //   s   assert(Fs &gt; 0 &amp;&amp; Fs &lt;= RANS_M);     // renormalize   if ((x &gt;&gt; 16) &gt;= (RANS_L &gt;&gt; k) * Fs) { // x / b &gt;=  L / M * Fs       out.put( x &amp; 0xffff );       x &gt;&gt;= 16;   }   x = ((x / Fs) &lt;&lt; k) + Bs + (x % Fs); // C(s,x)     assert(x &gt;= RANS_L); //      }</span></span></code> </pre> <br>  Am Ende der Codierung m√ºssen Sie den Wert von <b>x</b> speichern, da die Decodierung von dort aus beginnt.  Und ja, wir werden vom Ende bis zum Anfang dekodieren, dh vom letzten codierten Zeichen bis zum ersten.  (In einem Artikel √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FSE wird</a> dieser Punkt ausreichend ausf√ºhrlich erl√§utert.) <br><br>  Ich m√∂chte etwas n√§her darauf eingehen, wie die Codierungsformel funktioniert. <br><br><pre> <code class="cpp hljs">x := (x / Fs) * M + Bs + (x % Fs)</code> </pre> <br>  Nach der Berechnung von ( <code>x / Fs) * M</code> enth√§lt die Variable <b>x</b> die <b>k</b> niedrigstwertigen Bits (denken Sie daran, dass <b>M</b> = 2 ^ <b>k ist</b> ).  Das Hinzuf√ºgen von <code>+ Bs + (x % Fs)</code> schreibt im Wesentlichen einen bestimmten Wert aus dem <i>Intervall des</i> Zeichens <b>s</b> in diese Bits, da <b>Bs</b> der Beginn des Intervalls ist und (x% Fs) die Zahl innerhalb dieses Intervalls ist (die Gr√∂√üe des Intervalls ist Fs).  Somit k√∂nnen wir beim Decodieren das codierte Zeichen durch das Intervall bestimmen, in das es f√§llt (x% M). <br><br>  <b>Dekodierung</b> <br><br>  Fahren wir mit der Dekodierungsfunktion fort. <br><br><pre> <code class="cpp hljs">D(x): s = sym[x % M], x := Fs * (x / M) + (x % M) - Bs</code> </pre> <br>  Wie wir oben bereits verstanden haben, wird das gew√ºnschte Zeichen <b>s</b> durch den Rest der Division <b>x</b> % <b>M bestimmt.</b>  In welchem ‚Äã‚ÄãIntervall der Wert (x% M) gefallen ist, wurde ein solches Zeichen codiert. <br><br>  Zuvor haben wir speziell M = 2 ^ k definiert, um die Decodierungsfunktion zu vereinfachen.  Es endete so: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RansDecode(RansState&amp; x, RansInBuf&amp; in) {   assert(x &gt;= RANS_L); <span class="hljs-comment"><span class="hljs-comment">//       uint32_t x_mod = x &amp; (RANS_M - 1); // = x % M   //  ,    x_mod,     assert(x_mod &lt; dct.size());   uint32_t s = dct[x_mod]; //     uint32 Fs = freq[s]; //   s   uint32 Bs = range_start[s]; //    s   x = (x &gt;&gt; k) * Fs + x_mod - Bs;     // renormalize   if (x &lt; RANS_L) {       x = (x &lt;&lt; 16) | in.read16(); //  16    }     assert(x &gt;= RANS_L); //     return s; }</span></span></code> </pre> <br>  Die Decodierung beginnt mit demselben <b>x</b> , das am Ende der Codierung erhalten wurde.  Dazu muss es zusammen mit den codierten Daten gespeichert werden. <br><br>  Am Ende der Decodierung sollte der Zustand des Decodierers <b>x</b> genau dem der Codierung entsprechen.  Im Allgemeinen muss <b>x</b> bei jedem Schritt genau das gleiche sein wie beim entsprechenden Codierungsschritt.  Diese Tatsache hilft beim Debuggen sehr. <br><br>  Wie Sie sehen k√∂nnen, funktioniert die Dekodierung schneller als die Kodierung, da keine Teilungsoperationen vorhanden sind. <br><br>  Der schwierigste Moment in der Decodierungsfunktion ist die Methode zur Bestimmung, in welchem ‚Äã‚ÄãIntervall der Wert gefallen ist (x% M). <br><br>  Die einfachste und schnellste Methode ist die Verwendung der <b>sym []</b> -Tabelle, Gr√∂√üe <b>M.</b>  In diesem Fall erhalten wir eine Tabelle mit der gleichen Gr√∂√üe wie im FSE-Algorithmus, mit dem Unterschied, dass in rANS die Tabelle nicht ‚Äûverwechselt‚Äú wird, die Zeichen in Ordnung sind und eine solche Tabelle viel einfacher zu erstellen ist. <br><br>  Der Hauptnachteil dieses Ansatzes ist die Gr√∂√üe der <b>Sym-</b> Tabelle, die mit zunehmendem <b>k</b> exponentiell w√§chst. <br><br><h2>  Alias-Methode </h2><br>  Eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alias-Methode</a> wurde erfunden, um den Treffer in einem Intervall effizienter zu bestimmen.  Mit dieser Methode k√∂nnen Sie das gew√ºnschte Intervall anhand kleiner Tabellen schnell bestimmen - anhand der Anzahl der Zeichen im Alphabet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kv/v0/gu/kvv0guji6nfuxxr6mcjorxxsv9a.png"></div><br>  Eine lange und ausf√ºhrliche Erkl√§rung finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pfeile, W√ºrfel und M√ºnzen</a> .  Ich werde das Wesentliche der Methode kurz beschreiben: Wir nehmen ein St√ºck des l√§ngsten Intervalls und h√§ngen es an das k√ºrzeste Intervall an, sodass die Gesamtgr√∂√üe genau <b>M</b> / <b>N</b> betr√§gt (wobei <b>N</b> die Anzahl der Zeichen im Alphabet ist).  Es stellt sich heraus, dass Sie, wenn Sie dies nacheinander tun, immer <b>N</b> Paare der Gr√∂√üe <b>M</b> / <b>N erhalten.</b> <br><br>  Nat√ºrlich muss <b>M</b> durch <b>N</b> teilbar sein <b>.</b>  Und wenn wir uns daran erinnern, dass wir <b>M</b> = 2 ^ <b>k haben</b> , dann stellt sich heraus, dass die Gr√∂√üe des Alphabets auch eine Zweierpotenz ist.  Dies ist kein Problem, da Sie das Alphabet jederzeit mit nicht verwendeten Zeichen mit einer H√§ufigkeit von Null auf die gew√ºnschte Gr√∂√üe erg√§nzen k√∂nnen. <br><br>  Die Tatsache, dass das Zeichenintervall in mehrere Teile unterteilt ist, erschwert den Codierungsvorgang ein wenig, aber nicht viel.  Wenn Sie sich an die FSE erinnern, waren die Intervalle dort im Allgemeinen √ºber den gesamten Bereich verteilt, als h√§tte ein verr√ºckter Mixer daran gearbeitet, und nichts hat funktioniert =) <br><br>  Das gew√ºnschte Intervall zu bestimmen ist nicht schwierig: Teilen Sie <b>x</b> durch <b>N</b> und fallen Sie in eines der Paare.  Als n√§chstes vergleichen wir den Rest der Division von <b>x% N</b> mit der Grenze zwischen den Segmenten in einem Paar und fallen entweder in ein Intervall oder in ein anderes. <br><br><h2>  Wir versuchen es in der Praxis </h2><br>  Wir werden den Code des <a href="">fertigen Beispiels verwenden</a> . <br><br>  Wir nehmen die Daten zur Komprimierung aus der Datei: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> in_size; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* in_bytes = read_file(<span class="hljs-string"><span class="hljs-string">"book1"</span></span>, &amp;in_size);</code> </pre> <br>  <b>1.</b> Zuerst m√ºssen Sie sich f√ºr <b>die Datenstruktur</b> entscheiden. <br><br>  Wir verwenden die einfachste Option: Wir codieren ein Byte mit dem Alphabet [0 ... 255]. <br><br>  <b>2.</b> Im n√§chsten Schritt bestimmen Sie die <b>H√§ufigkeit der</b> Alphabetzeichen: <br><br>  (Funktion <code>stats.count_freqs</code> ) <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; in_size; i++) {   freqs[in_bytes[i]]++; }</code> </pre> <br>  <b>3.</b> Wir haben also Symbolfrequenzen, aber jetzt m√ºssen wir sie <b>normalisieren</b> , dh proportional verringern (oder erh√∂hen), so dass wir insgesamt M = 2 ^ k erhalten.  Dies ist keine so einfache Aufgabe, wie es scheint, daher verwenden wir eine vorgefertigte Funktion: <br><br><pre> <code class="plaintext hljs">stats.normalize_freqs(...);</code> </pre> <br>  √úbrigens m√ºssen Sie den Wert von <b>k</b> bestimmen.  Da unser Alphabet aus 256 Zeichen besteht, sollten <b>k</b> weniger als 8 nicht genommen werden.  Nehmen Sie zuerst das Maximum - 16 und versuchen Sie es sp√§ter mit anderen Werten. <br><br>  <b>4.</b> Erstellen Sie eine <b>Alias-Tabelle</b> : <br><br><pre> <code class="cpp hljs">stats.make_alias_table();</code> </pre> <br>  <b>5. Wir</b> codieren <b>vom Ende</b> , um dann in der normalen Reihenfolge zu decodieren. <br><br><pre> <code class="cpp hljs">RansState rans; <span class="hljs-comment"><span class="hljs-comment">//  rANS,    x RansEncInit(&amp;rans); //    uint8_t* ptr = out_buf + out_max_size; // *end* of output buffer for (size_t i = in_size; i &gt; 0; i--) { // NB: working in reverse!   int s = in_bytes[i - 1];   RansEncPutAlias(&amp;rans, &amp;ptr, &amp;stats, s, prob_bits); } //   .     . RansEncFlush(&amp;rans, &amp;ptr);</span></span></code> </pre> <br>  Ferner decodiert das Referenzbeispiel komprimierte Daten unter Verwendung vorgefertigter Statistiken.  Im wirklichen Leben m√ºssen Sie zum Dekodieren eine Tabelle mit Frequenzen (Statistiken) zusammen mit komprimierten Daten speichern.  Im einfachsten Fall m√ºssen Sie N * k Bits daf√ºr ausgeben. <br><br>  Schauen wir uns, wie oben versprochen, die Komprimierungsergebnisse f√ºr verschiedene Werte von k an (im Code ist es <code>prob_bits</code> ), wobei wir die Zunahme der Gr√∂√üe aufgrund der Aufzeichnung der H√§ufigkeitstabelle ber√ºcksichtigen: <br><br>  ( <i>Original</i> <i>book1</i> <i>Dateigr√∂√üe</i> : 768771) <br>  k = 16: 435059 + 512 = 435571 Bytes <br>  k = <b>15</b> : 435078 + 480 = <b>435558</b> Bytes <br>  k = 14: 435113 + 448 = 435561 Bytes <br>  k = 13: 435239 + 416 = 435655 Bytes <br>  k = 12: 435603 + 384 = 435987 Bytes <br>  k = 11: 436530 + 352 = 436882 Bytes <br>  k = 10: 440895 + 320 = 441215 Bytes <br>  k = 9: 453418 + 288 = 453706 Bytes <br>  k = 8: 473126 + 256 = 473382 Bytes <br><br>  Sie k√∂nnen sehen, dass die Komprimierung umso besser ist, je h√∂her k ist.  Ab einem bestimmten Punkt (bei k = 16) √ºberwiegt jedoch der Overhead der Frequenztabelle die Vorteile einer Erh√∂hung der Genauigkeit.  Wenn Sie eine kleinere Datei komprimieren, wird dieser Effekt auf kleinerem k angezeigt. <br><br>  Sie m√ºssen auch ein paar Worte √ºber den Trick "Interleaved RANS" sagen, der <a href="">in diesem Beispiel</a> zus√§tzlich implementiert wird.  Die Idee ist, dass die abwechselnde Verwendung von zwei unabh√§ngigen Zustandsvariablen die Prozessorparallelit√§t besser nutzt.  Dadurch ist die Dekodierung noch schneller. <br><br>  Abschlie√üend m√∂chte ich darauf hinweisen, dass die ausgew√§hlte Dateikomprimierungsmethode zu einfach ist.  Die Merkmale der Daten werden nicht ber√ºcksichtigt, weshalb die Komprimierung bei weitem nicht optimal ist.  Wenn Sie sich die Eingabe genau ansehen, k√∂nnen Sie feststellen, dass einige <i>Buchstabenkombinationen</i> h√§ufiger als andere sind und einige √ºberhaupt nicht vorkommen.  Durch diese Tatsache kann die Komprimierung erheblich verbessert werden.  Dies ist jedoch ein Thema f√ºr einen separaten Artikel. <br><br><h2>  Nachwort </h2><br>  Warum einen eigenen Archivierer schreiben, wenn es viele bew√§hrte Dienstprogramme gibt?  Die Antwort ist ganz einfach: Archivare, die auf ein bestimmtes Format zugeschnitten sind, komprimieren viel besser. <br><br>  Bei der Entwicklung von Spielen bei <b>Playrix verlassen</b> wir uns h√§ufig auf die Notwendigkeit, die Build-Gr√∂√üe zu reduzieren.  Spiele entwickeln sich st√§ndig weiter, die Menge an Inhalten w√§chst und der Platz ist begrenzt. <br><br>  Bei einem <s>sehns√ºchtigen</s> Blick auf die Ressourcen stellten wir erneut fest, dass einige Dateien aufgrund ihrer Struktur viel besser komprimiert werden k√∂nnen als zip.  W√§hrend der Experimente ist es uns gelungen, die Gr√∂√üe unseres eigenen Animationsformats erheblich zu reduzieren. Au√üerdem gibt es einige Verschiebungen bei der Komprimierung von Grafikdateien. <br><br>  Bei der Entwicklung von Komprimierungsalgorithmen ist ein universeller Entropiecodierer wie rANS oder FSE ein unverzichtbares Werkzeug.  Es √ºbernimmt vollst√§ndig die Aufgabe, Zeichen mit der geringsten Anzahl von Bits zu schreiben, sodass sich der Entwickler auf die Hauptdetails des Algorithmus konzentrieren kann.  Und es funktioniert sowohl beim Codieren als auch beim Decodieren sehr schnell. <br><br>  Ich hoffe, dieser Artikel hilft Ihnen, rANS kennenzulernen und in Ihren Projekten zu verwenden. <br><br><h2>  Referenzen </h2><br>  Hier sehen Sie Arbeitsbeispiele f√ºr die rANS-Implementierung (mit verschiedenen Optimierungsoptionen): <br><br>  Fabian Giesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/rygorous/ryg_rans</a> <br><br>  Sie k√∂nnen interessante Details und Details auf Fabians Blog lesen (auf Englisch): <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rANS Notizen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RANS mit statischen Wahrscheinlichkeitsverteilungen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RANS in der Praxis</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441814/">https://habr.com/ru/post/de441814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441804/index.html">Wo kann man Kindern Programmieren beibringen?</a></li>
<li><a href="../de441806/index.html">VPN ohne VPN oder eine Geschichte √ºber die unkonventionelle Verwendung von SSH</a></li>
<li><a href="../de441808/index.html">Wir laden Sie am 6. M√§rz zum ElixirLangMoscow Meetup # 9 ein</a></li>
<li><a href="../de441810/index.html">Eclipse f√ºr Mikrocontroller (STM32) + FreeRTOS Task Aware Debugger</a></li>
<li><a href="../de441812/index.html">Go Meetup Live-Streaming auf Acronis</a></li>
<li><a href="../de441816/index.html">Die franz√∂sischen Beh√∂rden verh√§ngten gegen die UBS Bank eine Geldstrafe von 4 Milliarden US-Dollar, weil sie Kunden dabei half, Steuern zu vermeiden</a></li>
<li><a href="../de441818/index.html">Ausgewogene Site-Leistung. Teil 2: Technische Optimierung</a></li>
<li><a href="../de441820/index.html">Horror Devotion aus Steam entfernt - die Ursache ist wieder Winnie the Pooh, Xi Jinping und Chinas Wut √ºber politische Obert√∂ne</a></li>
<li><a href="../de441824/index.html">Brandmanagement als Teil der Arbeit des Leiters</a></li>
<li><a href="../de441826/index.html">Was passiert auf dem Audio-Streaming-Markt? Diskussion √ºber die Entwicklung von Streaming-Plattformen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>