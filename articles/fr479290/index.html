<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶å üêó ü§≥üèæ Algorithmes de recherche du volume et du centre de masse d'un poly√®dre ‚úùÔ∏è üë®üèø‚Äçüöí ‚ù§Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout le monde conna√Æt probablement cet algorithme, mais ¬´les autorit√©s me cachaient¬ª. J'ai trouv√© sa description verbale sur la troisi√®me page du mote...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithmes de recherche du volume et du centre de masse d'un poly√®dre</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479290/">  Tout le monde conna√Æt probablement cet algorithme, mais ¬´les autorit√©s me cachaient¬ª.  J'ai trouv√© sa description verbale sur la troisi√®me page du moteur de recherche dans l'archive des traductions automatiques du forum anglophone.  Il me semble que sa description d√©taill√©e (et avec le code) est digne de habrosta. <br><br>  Ainsi, par exemple, vous devez g√©n√©rer des foules pour un jouet et quelque part dans le processus pour √©liminer ceux qui ne sont pas debout.  Pour ce faire, vous devez trouver le centre de masse de la foule (et c'est presque la m√™me chose que trouver son volume) et vous assurer qu'il se trouve quelque part au-dessus des jambes de la foule. <br><br><img src="https://habrastorage.org/webt/mg/o0/1j/mgo01jfkte64gkwjovk8xisnzsm.jpeg"><br><a name="habracut"></a><br>  Un mob est un poly√®dre, pour simplifier, nous consid√©rons qu'un poly√®dre n'est compos√© que de triangles (dans l'algorithme √† l'int√©rieur se trouve la <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D1%2583%25D0%25BB%25D0%25B0_%25D0%25BF%25D0%25BB%25D0%25BE%25D1%2589%25D0%25B0%25D0%25B4%25D0%25B8_%25D0%2593%25D0%25B0%25D1%2583%25D1%2581%25D1%2581%25D0%25B0" rel="nofollow">formule de l'aire gaussienne</a> , vous pouvez donc l'√©tendre pour n'importe quel poly√®dre, mais pourquoi ...).  De plus, le poly√®dre ne devrait pas avoir d'auto-intersections et limiter le volume ferm√©, comme il sied √† des poly√®dres d√©cents. <br><br><img src="https://habrastorage.org/webt/xt/pl/lu/xtplludmrhnnpocxqv0ughwqilo.png"><br>  <i>(enfin, comme √ßa)</i> <br><br>  Un petit UPD expliquant pourquoi sur le KDPV la foule de droite n'est pas OK, mais la gauche OK: <br>  La bonne image n'est pas OK parce que la foule va tomber en avant, parce que  son centre de masse s'√©tend au-del√† de la zone d'appui.  La zone de support d'un polygone se tenant sur la surface est d√©finie comme le polygone minimum √† l'int√©rieur duquel tous les points de la surface sont situ√©s.  Dans le cas de gauche, la zone du support est d√©cal√©e vers le centre de masse et plus (parce que les pattes de dinosaure sont plus grandes), et dans l'image de droite, la zone elle-m√™me est plus petite et plus proche de la queue. <br>  Le rapport de la zone de r√©f√©rence au centre de masse sera quelque chose comme ceci: <br><img src="https://habrastorage.org/webt/gs/fz/x8/gsfzx8ju0ggexquycogdnpp-jwk.jpeg"><br><br>  Je vais commencer tout de suite avec le code de recherche de volume (Python, entr√©e - une liste de points et une matrice de transition): <br><br><div class="spoiler">  <b class="spoiler_title">du code</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RecSetDirsTriangles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(para, Connects, TR)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ,           """</span></span> <span class="hljs-comment"><span class="hljs-comment">#1.   , ,     for i in range(0,len(Connects)): if i != para[0] and i != para[1] and Connects[i][para[0]] and Connects[i][para[1]]: #  ! fl = 1 for T in TR: if i in T and para[1] in T and para[0] in T: fl = 0 #    break if fl: # ! TR += [(para[1],para[0],i)] Recc((para[0], i) , Connects, TR) Recc((i, para[1]) , Connects, TR) def FindV(dots, Connects): """ .   - dots     [x, y, z], Connects -  , Connects[i][j]=1      i, j,  =0 """ #1.      TR = [] for i in range(1,len(Connects)):#        - if Connects[i][0]: for j in range(i+1, len(Connects)): if Connects[0][j] and Connects[i][j]: TR += [(0,i,j)] break RecSetDirsTriangles((0,i),Connects, TR) break print(" : ", len(TR)) #2.        V = 0 for T in TR: ''' : x1y2 x2y3 x3y1 x2y1 x3y2 x1y3''' S = 0.5 * (dots[T[0]][0]*dots[T[1]][1] + dots[T[1]][0]*dots[T[2]][1] + dots[T[2]][0]*dots[T[0]][1] - dots[T[1]][0]*dots[T[0]][1] - dots[T[2]][0]*dots[T[1]][1] - dots[T[0]][0]*dots[T[2]][1]) #S   +  -    ,    V += S*(dots[T[0]][2] + dots[T[1]][2] + dots[T[2]][2])/3 #    ... return math.fabs(V)</span></span></code> </pre> <br></div></div><br>  L'essence de l'algorithme est de consid√©rer les volumes de figures qui forment les faces du poly√®dre qui ¬´tombent¬ª sur le plan xy.  Pour ce faire, vous devez conna√Ætre la zone de projection du triangle et le signe avec lequel ajouter le volume de la figure (prisme tronqu√©).  En fait, si les triangles sont command√©s √† l'avance, le volume et le signe sont r√©duits √† un seul calcul. <br><br>  Par cons√©quent, la premi√®re chose qu'une fonction r√©cursive collecte des triangles est son entr√©e.  Assemble de telle mani√®re que lorsque vous regardez √† l'ext√©rieur d'un poly√®dre, les directions pour contourner les triangles sont les m√™mes (id√©alement dans le sens antihoraire; si vous prenez les directions dans le sens horaire, le r√©sultat sera correct, mais n√©gatif - par cons√©quent, le module de volume est donn√© au retour). <br><br>  C'est tr√®s simple √† r√©aliser - nous prenons un triangle (points a1, a2, a3), recherchons ses voisins et listons deux sommets correspondants dans l'ordre inverse (par exemple, comme ceci: a2, a1, b1). <br>  Il s'av√®re quelque chose comme ceci: <br><br><img src="https://habrastorage.org/webt/ar/-k/zv/ar-kzv2kd0qceid5m47na1xyvmi.png"><br><br>  Maintenant, si nous projetons un tel triangle sur le plan xy, alors l'ordre de travers√©e pour la projection du triangle "sup√©rieur" co√Øncidera avec celui initialement s√©lectionn√©, et l'ordre de travers√©e pour la projection du triangle "inf√©rieur" changera de direction.  En cons√©quence, cela changera le signe et l'aire de ce triangle, calcul√©s par la formule de Gauss.  Ici, le triangle ¬´inf√©rieur¬ª - un concept conditionnel - signifie que le volume imm√©diatement en dessous n'est pas inclus dans le volume du poly√®dre.  Le triangle ¬´inf√©rieur¬ª d'un poly√®dre non convexe peut √™tre sup√©rieur √† celui ¬´sup√©rieur¬ª. <br><br>  Apr√®s ces √©tapes pr√©liminaires, pour calculer le volume total du poly√®dre, il suffit d'ajouter (en tenant compte du signe, qui est obtenu "par lui-m√™me") tous les volumes des prismes tronqu√©s collect√©s sur les faces et les projections de ces faces sur le plan xy.  Et les volumes de prismes sont consid√©r√©s comme le produit de l'aire (gaussienne, avec un signe) et les coordonn√©es z moyennes arithm√©tiques des sommets du triangle. <br><br>  Si le poly√®dre coupe le plan xy, alors lors du calcul du volume, tous les signes s'annulent et le r√©sultat reste correct (il suffit de prendre les hauteurs de prisme sans module). <br><br><img src="https://habrastorage.org/webt/ll/lt/qk/llltqkv7v0i-r-i_50mzu0jqage.jpeg"><br>  <i>(en quelque sorte le prisme tronqu√© "sup√©rieur" ressemble)</i> <br><br>  Avec la recherche du centre de masse, tout est √† peu pr√®s le m√™me.  De m√™me, nous devons trouver les centres de masse pour chaque prisme tronqu√© et r√©sumer en coordonn√©es, en multipliant par le volume du prisme (on suppose que la masse est r√©partie uniform√©ment dans tout le volume et que l'un peut √™tre remplac√© par un autre).  Pour trouver le centre de masse d'un prisme tronqu√©, il est n√©cessaire de calculer les centres de masse de deux t√©tra√®dres (+1 fonction) et d'un prisme ordinaire.  L'algorithme "ne se d√©t√©riore pas non plus" si le poly√®dre traverse le plan xy (et ici pourrait √™tre une reproduction de Magritte). <br><br><img src="https://habrastorage.org/webt/tm/cz/fm/tmczfmf_yneom5ureeng0eny85a.jpeg"><br>  <i>(ces deux t√©tra√®dres, marqu√©s en rouge et rouge, ainsi qu'un prisme triangulaire (sous le t√©tra√®dre rouge) forment le prisme tronqu√© souhait√©. Nous devons trouver les centres de masse et les volumes des trois figures. Les d√©signations correspondent √† peu pr√®s aux d√©signations du code)</i> <br><br>  Code qui compte ceci et cela: <br><br><div class="spoiler">  <b class="spoiler_title">un peu plus de code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RecSetDirsTriangles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(para, Connects, TR)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#1.   , ,     for i in range(0,len(Connects)): if i != para[0] and i != para[1] and Connects[i][para[0]] and Connects[i][para[1]]: #  ! fl = 1 for T in TR: if i in T and para[1] in T and para[0] in T: fl = 0 break if fl: # ! TR += [(para[1],para[0],i)] Recc((para[0], i) , Connects, TR) Recc((i, para[1]) , Connects, TR) def TetrV(mas):#dot1, dot2, dot3, dot4): """   """ M = np.zeros((3,3),float) for i in range(1,4): for j in range(0,3): M[i-1][j] = mas[i][j] - mas[0][j] #print(M) return math.fabs(np.linalg.det(M)/6) def FindVandCM(dots, Connects): """     """ #1.      TR = [] for i in range(1,len(Connects)): #        - if Connects[i][0]: for j in range(i+1, len(Connects)): if Connects[0][j] and Connects[i][j]: TR += [(0,i,j)] break RecSetDirsTriangles((0,i),Connects, TR) break print(" : ", len(TR)) #2.   ,          V = 0 CM = [0, 0, 0] for T in TR: ''' : x1y2 x2y3 x3y1 x2y1 x3y2 x1y3''' S = 0.5 * (dots[T[0]][0]*dots[T[1]][1] + dots[T[1]][0]*dots[T[2]][1] + dots[T[2]][0]*dots[T[0]][1] - dots[T[1]][0]*dots[T[0]][1] - dots[T[2]][0]*dots[T[1]][1] - dots[T[0]][0]*dots[T[2]][1]) #S   +  -    ,    V += S*(dots[T[0]][2] + dots[T[1]][2] + dots[T[2]][2])/3 #    ... #c        c1 = ((dots[T[0]][0] + dots[T[1]][0] + dots[T[2]][0])/3, (dots[T[0]][1]+ dots[T[1]][1]+ dots[T[2]][1])/3) #    hm = min([dots[T[0]][2] , dots[T[1]][2] , dots[T[2]][2]]) hM = max([dots[T[0]][2] , dots[T[1]][2] , dots[T[2]][2]]) indM = [dots[T[0]][2] , dots[T[1]][2] , dots[T[2]][2]].index(hM) indm = [dots[T[0]][2] , dots[T[1]][2] , dots[T[2]][2]].index(hm) V3 = S * hm if indM == indm: # ! CM[0] += V3*c1[0] CM[1] += V3*c1[1] CM[2] += V3*hm/2 continue L = [0,1,2] L.remove(indM) L.remove(indm) indmidle = L[0] dots1 = [dots[T[0]], dots[T[1]], dots[T[2]], (dots[T[indM]][0], dots[T[indM]][1] , hm)] #  V1 = TetrV(dots1) if S &lt; 0: V1 = -V1 V2 = S * ( dots[T[indmidle]][2] - hm)/3 #V3 = S * hm CM[0] += V1*((dots[T[0]][0] + dots[T[1]][0] + dots[T[2]][0] + dots[T[indM]][0])/4) + V2*((dots[T[0]][0] + dots[T[1]][0] + dots[T[2]][0] + dots[T[indmidle]][0])/4) + V3*c1[0] CM[1] += V1*((dots[T[0]][1] + dots[T[1]][1] + dots[T[2]][1] + dots[T[indM]][1])/4) + V2*((dots[T[0]][1] + dots[T[1]][1] + dots[T[2]][1] + dots[T[indmidle]][1])/4) + V3*c1[1] CM[2] += V1*((dots[T[0]][2] + dots[T[1]][2] + dots[T[2]][2] + hm)/4) + V2*((dots[T[0]][2] + dots[T[1]][2] + dots[T[2]][2] + hm)/4) + V3*hm/2 CM[0] = CM[0]/V CM[1] = CM[1]/V CM[2] = CM[2]/V return (math.fabs(V), CM)</span></span></code> </pre><br></div></div><br>  Un morceau de l'algorithme o√π les directions des triangles sont consid√©r√©es et utilis√©es pour comprendre le volume externe et interne est un mouvement tr√®s fort, il peut √™tre utilis√© beaucoup lorsque vous travaillez avec des poly√®dres.  Par exemple, si vous avez besoin de calculer la direction des normales "out" - il suffit de conna√Ætre la direction "antihoraire" pour une face - et le tour est jou√©! <br><br><img src="https://habrastorage.org/webt/hz/rh/3y/hzrh3yrdahhv8ei7gvmxsutzprc.jpeg"><br>  <i>(devinez le film!)</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479290/">https://habr.com/ru/post/fr479290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479278/index.html">Cent √† cinq cents chiffres du nombre pi sur le genou</a></li>
<li><a href="../fr479282/index.html">Si les donn√©es ne tiennent pas en m√©moire. M√©thodes les plus simples</a></li>
<li><a href="../fr479284/index.html">La maison que le robot a construite</a></li>
<li><a href="../fr479286/index.html">√âcriture d'une application Web simple √† l'aide de Spring MVC, Spring Data JPA et Hibernate</a></li>
<li><a href="../fr479288/index.html">Pourquoi impl√©menter Service Desk et comment choisir une solution pour votre entreprise</a></li>
<li><a href="../fr479292/index.html">Comment enseigner √† un r√©seau de neurones √† reproduire la physique des jeux</a></li>
<li><a href="../fr479294/index.html">Sortie de GitLab 12.5 avec la cr√©ation de clusters EKS et le panneau environnement</a></li>
<li><a href="../fr479296/index.html">Comment j'ai arr√™t√© de ha√Ør et suis tomb√© amoureux du d√©veloppement</a></li>
<li><a href="../fr479298/index.html">Antipatterns PostgreSQL: CTE x CTE</a></li>
<li><a href="../fr479300/index.html">√âcologie et centres de donn√©es. Comme en Russie et √† l'√©tranger, les ¬´donn√©es vertes¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>