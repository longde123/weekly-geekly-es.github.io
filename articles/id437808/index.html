<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛽️ 😡 🌼 Perf dan flamegraf 🧝🏼 🤰 😖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Topik meningkatkan kinerja sistem operasi dan menemukan kemacetan semakin populer. Dalam artikel ini, kita akan berbicara tentang satu alat untuk mene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perf dan flamegraf</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/437808/"><img src="https://habrastorage.org/webt/pa/ue/x8/pauex8un6--wep6-1ehqvmciieg.png"><br><br>  Topik meningkatkan kinerja sistem operasi dan menemukan kemacetan semakin populer.  Dalam artikel ini, kita akan berbicara tentang satu alat untuk menemukan tempat-tempat ini menggunakan contoh tumpukan blok di Linux dan satu kasus pemecahan masalah host. <br><br><h2>  Contoh 1. Tes </h2><br><h3>  Tidak ada yang berhasil </h3><br>  Pengujian di departemen kami adalah sintetis pada perangkat keras produk, dan pengujian perangkat lunak aplikasi selanjutnya.  Kami menerima drive Intel Optane untuk pengujian.  Kami sudah menulis tentang pengujian drive Optane <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di blog kami</a> . <br><br>  Disk dipasang di server standar yang dibangun untuk waktu yang relatif lama di bawah salah satu proyek cloud. <br><a name="habracut"></a><br>  Selama pengujian, disk menunjukkan dirinya tidak dalam cara terbaik: selama pengujian dengan kedalaman antrian 1 permintaan per 1 aliran, dalam blok 4Kbytes sekitar ~ 70Kiops.  Dan ini berarti waktu respons sangat besar: sekitar 13 mikrodetik per permintaan! <br><br>  Aneh, karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasinya</a> menjanjikan "Latensi - Baca 10 µs", dan kami mendapat 30% lebih, perbedaannya cukup signifikan.  Disk itu disusun ulang ke platform lain, perakitan yang lebih "segar" yang digunakan dalam proyek lain. <br><br><h3>  Mengapa ini berhasil? </h3><br>  Ini lucu, tetapi drive pada platform baru berfungsi sebagaimana mestinya.  Performa meningkat, latensi menurun, CPU per rak, 1 aliran per permintaan, blok 4K byte, ~ 106Kiops pada ~ 9 mikrodetik per permintaan. <br><br>  Dan kemudian saatnya <s>membandingkan pengaturan</s> untuk mendapatkan <b>perf</b> dari <b>kaki</b> lebar.  Bagaimanapun, kita bertanya-tanya mengapa demikian?  Dengan <b>perf,</b> Anda dapat: <br><br><ul><li>  Ambil bacaan penghitung perangkat keras: jumlah panggilan instruksi, cache salah, cabang yang diprediksi salah, dll.  (Acara PMU) </li><li>  Hapus informasi dari poin perdagangan statis, jumlah kejadian </li><li>  Melakukan penelusuran dinamis </li></ul><br>  Untuk verifikasi, kami menggunakan pengambilan sampel CPU. <br><br>  Intinya adalah bahwa <b>perf</b> dapat mengkompilasi seluruh jejak tumpukan program yang sedang berjalan.  Secara alami, menjalankan <b>perf</b> akan menyebabkan penundaan dalam pengoperasian seluruh sistem.  Tetapi kita memiliki flag <i>-F #</i> , di mana <i>#</i> adalah frekuensi sampling, diukur dalam Hz. <br><br>  Penting untuk dipahami bahwa semakin tinggi frekuensi pengambilan sampel, semakin besar kemungkinan untuk menangkap panggilan ke fungsi tertentu, tetapi semakin banyak rem yang dibawa profiler ke sistem.  Semakin rendah frekuensinya, semakin besar kemungkinan kita tidak akan melihat bagian dari tumpukan. <br><br>  Ketika memilih frekuensi, Anda perlu dipandu oleh akal sehat dan satu trik - cobalah untuk tidak mengatur frekuensi genap, agar tidak masuk ke situasi ketika beberapa pekerjaan yang berjalan pada timer dengan frekuensi ini masuk ke dalam sampel. <br><br>  Poin lain yang awalnya menyesatkan - perangkat lunak harus dikompilasi dengan flag <i>-fno-omit-frame-pointer</i> , jika ini, tentu saja, mungkin.  Jika tidak, dalam penelusuran, alih-alih nama fungsi, kita akan melihat nilai yang <i>tidak diketahui</i> .  Untuk beberapa perangkat lunak, simbol debugging datang sebagai paket terpisah, misalnya, <i>someutil-dbg</i> .  Anda disarankan untuk menginstalnya sebelum menjalankan <b>perf</b> . <br><br>  Kami melakukan tindakan berikut: <br><br><ul><li>  Diambil fio dari git: //git.kernel.dk/fio.git, tag fio-3.9 </li><li>  Menambahkan <em>opsi -fno-omit-frame-pointer</em> ke CPPFLAGS di Makefile </li><li>  Diluncurkan <em>make -j8</em> </li></ul><br><pre><code class="bash hljs">perf record -g ~/fio/fio --name=<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> --rw=randread --bs=4k --ioengine=pvsync2 --filename=/dev/nvme0n1 --direct=1 --hipri --filesize=1G</code> </pre> <br>  Opsi -g diperlukan untuk menangkap tumpukan jejak. <br><br>  Anda dapat melihat hasilnya dengan perintah: <br><br><pre> <code class="bash hljs">perf report -g fractal</code> </pre> <br>  Opsi <i>fraktal -g</i> diperlukan sehingga persentase yang mencerminkan jumlah sampel dengan fungsi ini dan ditunjukkan oleh <b>perf</b> relatif terhadap fungsi panggilan, jumlah panggilan yang diambil sebagai 100%. <br><br>  Menjelang akhir tumpukan panggilan fio pada platform "fresh build", kita akan melihat: <br><br><img src="https://habrastorage.org/webt/_y/pn/jb/_ypnjb3xkf3urq140p0qssevtku.png"><br><br>  Dan pada platform "bangunan lama": <br><br><img src="https://habrastorage.org/webt/gq/kx/ul/gqkxulpyxspbmfudoxhh7ysdv1e.png"><br><br>  Hebat!  Tapi saya ingin flamegraf cantik. <br><br><h3>  Membangun flamegrams </h3><br>  Untuk menjadi cantik, ada dua alat: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flamegraph yang</a> relatif lebih statis </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flamescope</a> , yang memungkinkan untuk memilih periode waktu tertentu dari sampel yang dikumpulkan.  Ini sangat berguna ketika kode pencarian memuat CPU dengan semburan pendek. </li></ul><br>  Utilitas ini menerima <b>skrip perf&gt; hasil</b> sebagai masukan. <br><br>  Unduh <i>hasil</i> dan kirim melalui pipa ke <i>svg</i> : <br><br><pre> <code class="bash hljs">FlameGraph/stackcollapse-perf.pl ./result | FlameGraph/flamegraph.pl &gt; ./result.svg</code> </pre> <br>  Buka di browser dan nikmati gambar yang bisa diklik. <br><br>  Anda dapat menggunakan metode lain: <br><br><ol><li>  Tambahkan <i>hasil</i> ke flamescope / example / </li><li>  Jalankan python ./run.py </li><li>  Kami pergi melalui browser ke port 5000 host lokal </li></ol><br><h3>  Apa yang kita lihat pada akhirnya? </h3><br>  Seorang fio yang baik menghabiskan banyak waktu dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemungutan suara</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/o1/zg/wy/o1zgwy-l6idzwcxniq16ndbskvo.png"></div><br>  Orang jahat menghabiskan waktu di mana saja, tetapi tidak dalam pemungutan suara: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3z/er/bz/3zerbzvtrpwznzewdteyf6bexfq.png"></div><br>  Pada pandangan pertama, tampaknya polling tidak berfungsi pada host lama, tetapi di mana-mana kernel 4,15 dari rakitan yang sama dan polling diaktifkan secara default pada disk NVMe.  Periksa apakah polling diaktifkan di <b>sysfs</b> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># cat /sys/class/block/nvme0n1/queue/io_poll 1</span></span></code> </pre> <br>  Selama pengujian, panggilan ke <i>preadv2</i> dengan flag <i>RWF_HIPRI digunakan</i> - kondisi yang diperlukan agar polling berfungsi.  Dan, jika Anda mempelajari dengan hati-hati grafik nyala (atau tangkapan layar sebelumnya dari output <b>laporan perf</b> ), Anda dapat menemukannya, tetapi itu membutuhkan waktu yang sangat sedikit. <br><br>  Hal kedua yang terlihat adalah tumpukan panggilan yang berbeda untuk fungsi submit_bio () dan kurangnya panggilan io_schedule ().  Mari kita lihat lebih dekat perbedaan di dalam submit_bio (). <br><br>  Platform lambat "bangunan lama": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/ba/ew/sdbaewdxmxq2qqy7w6xwlkmpuia.png"></div><br>  Platform cepat "segar": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_a/d2/_w/_ad2_wholhggbeewyuoxvqdpuas.png"></div><br>  Tampaknya pada platform lambat, permintaan berjalan jauh ke perangkat, pada saat yang sama masuk ke <b>scheduler Kyber</b> .  Anda dapat membaca lebih lanjut tentang penjadwal I / O di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel kami</a> . <br><br>  Setelah <b>kyber</b> dimatikan, uji <b>fio</b> yang sama menunjukkan latensi rata-rata sekitar 10 mikrodetik, seperti yang dinyatakan dalam spesifikasi.  Hebat! <br><br>  Tapi dari mana perbedaan mikrodetik lain berasal? <br><br><h3>  Dan jika sedikit lebih dalam? </h3><br>  Seperti yang telah disebutkan, <b>perf</b> memungkinkan Anda mengumpulkan statistik dari penghitung perangkat keras.  Mari kita coba melihat jumlah cache yang salah dan instruksi per siklus: <br><br><pre> <code class="bash hljs">perf <span class="hljs-built_in"><span class="hljs-built_in">stat</span></span> -e cycles,instructions,cache-references,cache-misses,bus-cycles /root/fio/fio --clocksource=cpu --name=<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=10</code> </pre> <br><img src="https://habrastorage.org/webt/ue/pc/fo/uepcfo8up5ehpvqb1ophotqjzb8.png"><br><br><img src="https://habrastorage.org/webt/p5/ln/al/p5lnalg0u05xtvc5792ghegtv34.png"><br><br>  Hal ini dapat dilihat dari hasil bahwa platform cepat mengeksekusi lebih banyak instruksi untuk siklus CPU dan memiliki persentase cache yang lebih rendah selama eksekusi.  Tentu saja, kami tidak akan membahas operasi platform perangkat keras yang berbeda dalam kerangka artikel ini. <br><br><h2>  Contoh 2. Bahan makanan </h2><br><h3>  Ada yang salah </h3><br>  Dalam pekerjaan sistem penyimpanan data terdistribusi, peningkatan beban pada CPU pada salah satu host diamati dengan peningkatan lalu lintas masuk.  Host adalah teman sebaya, teman sebaya, dan memiliki perangkat keras dan perangkat lunak yang identik. <br><br>  Mari kita lihat beban CPU: <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># pidstat -p 1441734 1 Linux 3.13.0-96-generic (lol) 10/10/2018 _x86_64_ (24 CPU) 09:23:30 PM UID PID %usr %system %guest %CPU CPU Command 09:23:44 PM 0 1441734 23.00 1.00 0.00 24.00 4 ceph-osd 09:23:45 PM 0 1441734 85.00 34.00 0.00 119.00 4 ceph-osd 09:23:46 PM 0 1441734 0.00 130.00 0.00 130.00 4 ceph-osd 09:23:47 PM 0 1441734 121.00 0.00 0.00 121.00 4 ceph-osd 09:23:48 PM 0 1441734 28.00 82.00 0.00 110.00 4 ceph-osd 09:23:49 PM 0 1441734 4.00 13.00 0.00 17.00 4 ceph-osd 09:23:50 PM 0 1441734 1.00 6.00 0.00 7.00 4 ceph-osd</span></span></code> </pre> <br>  Masalahnya muncul pada 09:23:46 dan kita melihat bahwa prosesnya bekerja di ruang kernel secara eksklusif untuk seluruh detik.  Mari kita lihat apa yang terjadi di dalam. <br><br><h3>  Kenapa sangat lambat? </h3><br>  Dalam hal ini, kami mengambil sampel dari keseluruhan sistem: <br><br><pre> <code class="bash hljs">perf record -a -g -- sleep 22 perf script &gt; perf.results</code> </pre> <br>  Opsi <i>-a</i> diperlukan di sini agar <b>perf dapat</b> menghapus jejak dari semua CPU. <br><br>  Buka <b>perf.hasil</b> dengan <b>flamescope</b> untuk melacak momen peningkatan beban CPU. <br><br><div class="spoiler">  <b class="spoiler_title">Peta panas</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ao/db/hq/aodbhqbwotkcwaq99bvmbznkbrg.png"></div><br></div></div><br>  Di depan kita ada "peta panas", kedua sumbu (X dan Y) yang mewakili waktu. <br><br>  Pada sumbu X, ruang dibagi menjadi detik, dan pada sumbu Y, menjadi segmen 20 milidetik dalam waktu X detik, Waktu berjalan dari bawah ke atas dan dari kiri ke kanan.  Kotak paling terang memiliki jumlah sampel terbesar.  Artinya, CPU saat ini bekerja paling aktif. <br><br>  Sebenarnya, kami tertarik dengan titik merah di tengah.  Pilih dengan mouse, klik dan lihat apa yang disembunyikannya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gv/kk/ko/gvkkkomg9vl7u1ylpwx7h8pceqc.png"></div><br>  Secara umum, sudah terlihat bahwa masalahnya adalah <i>tcp_recvmsg</i> dan <i>skb_copy_datagram_iovec</i> operasi lambat di dalamnya. <br><br>  Untuk kejelasan, bandingkan dengan sampel host lain yang jumlah lalu lintasnya sama tidak menyebabkan masalah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v6/_j/72/v6_j72zqvscfolhkaipeoyx9lg8.png"></div><br>  Berdasarkan fakta bahwa kami memiliki jumlah lalu lintas masuk yang sama, platform identik yang telah bekerja untuk waktu yang lama tanpa henti, kami dapat mengasumsikan bahwa masalah muncul di sisi besi.  Fungsi <i>skb_copy_datagram_iovec</i> menyalin data dari struktur kernel ke struktur di ruang pengguna untuk diteruskan ke aplikasi.  Mungkin ada masalah dengan memori host.  Pada saat yang sama, tidak ada kesalahan dalam log. <br><br>  Kami me-restart platform.  Saat memuat BIOS, kami melihat pesan tentang bilah memori yang rusak.  Penggantian, host mulai dan masalah dengan CPU kelebihan beban tidak lagi direproduksi. <br><br><h2>  Catatan tambahan </h2><br><h3>  Performa sistem dengan perf </h3><br>  Secara umum, pada sistem yang sibuk, menjalankan <b>perf</b> dapat menyebabkan keterlambatan dalam memproses permintaan.  Ukuran penundaan ini juga tergantung pada beban di server. <br><br>  Mari kita coba cari penundaan ini: <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /root/fio/fio --clocksource=cpu --name=test --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=1 test: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=pvsync2, iodepth=1 fio-3.9-dirty Starting 1 process Jobs: 1 (f=1): [r(1)][100.0%][r=413MiB/s][r=106k IOPS][eta 00m:00s] test: (groupid=0, jobs=1): err= 0: pid=109786: Wed Dec 12 17:25:56 2018 read: IOPS=106k, BW=414MiB/s (434MB/s)(4096MiB/9903msec) clat (nsec): min=8161, max=84768, avg=9092.68, stdev=1866.73 lat (nsec): min=8195, max=92651, avg=9127.03, stdev=1867.13 … ~# perf record /root/fio/fio --clocksource=cpu --name=test --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=1 test: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=pvsync2, iodepth=1 fio-3.9-dirty Starting 1 process Jobs: 1 (f=1): [r(1)][100.0%][r=413MiB/s][r=106k IOPS][eta 00m:00s] test: (groupid=0, jobs=1): err= 0: pid=109839: Wed Dec 12 17:27:50 2018 read: IOPS=106k, BW=413MiB/s (433MB/s)(4096MiB/9916msec) clat (nsec): min=8259, max=55066, avg=9102.88, stdev=1903.37 lat (nsec): min=8293, max=55096, avg=9135.43, stdev=1904.01</span></span></code> </pre> <br>  Perbedaannya tidak terlalu mencolok, hanya sekitar ~ 8 nanodetik. <br><br>  Mari kita lihat apa yang terjadi jika Anda menambah beban: <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /root/fio/fio --clocksource=cpu --name=test --numjobs=4 --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=1 test: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=pvsync2, iodepth=1 ... fio-3.9-dirty Starting 4 processes Jobs: 4 (f=4): [r(4)][100.0%][r=1608MiB/s][r=412k IOPS][eta 00m:00s] ~# perf record /root/fio/fio --clocksource=cpu --name=test --numjobs=4 --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=1 test: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=pvsync2, iodepth=1 ... fio-3.9-dirty Starting 4 processes Jobs: 4 (f=4): [r(4)][100.0%][r=1584MiB/s][r=405k IOPS][eta 00m:00s]</span></span></code> </pre> <br>  Di sini perbedaannya sudah menjadi nyata.  Dapat dikatakan bahwa sistem melambat kurang dari 1%, tetapi pada dasarnya kehilangan sekitar 7Kiops pada sistem yang sarat muatan dapat menyebabkan masalah. <br><br>  Jelas bahwa contoh ini adalah sintetis, namun sangat mengungkap. <br><br>  Mari kita coba menjalankan tes sintetik lain yang menghitung bilangan prima - <i>sysbench</i> : <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># sysbench --max-time=10 --test=cpu run --num-threads=10 --cpu-max-prime=100000 ... Test execution summary: total time: 10.0140s total number of events: 3540 total time taken by event execution: 100.1248 per-request statistics: min: 28.26ms avg: 28.28ms max: 28.53ms approx. 95 percentile: 28.31ms Threads fairness: events (avg/stddev): 354.0000/0.00 execution time (avg/stddev): 10.0125/0.00 ~# perf record sysbench --max-time=10 --test=cpu run --num-threads=10 --cpu-max-prime=100000 … Test execution summary: total time: 10.0284s total number of events: 3498 total time taken by event execution: 100.2164 per-request statistics: min: 28.53ms avg: 28.65ms max: 28.89ms approx. 95 percentile: 28.67ms Threads fairness: events (avg/stddev): 349.8000/0.40 execution time (avg/stddev): 10.0216/0.01</span></span></code> </pre> <br>  Di sini Anda dapat melihat bahwa bahkan waktu pemrosesan minimum pun meningkat 270 mikrodetik. <br><br><h3>  Alih-alih sebuah kesimpulan </h3><br>  <b>Perf</b> adalah alat yang sangat kuat untuk menganalisis kinerja sistem dan debugging.  Namun, seperti halnya alat lain, Anda perlu mengendalikan diri dan ingat bahwa sistem yang dimuat di bawah pengawasan ketat bekerja lebih buruk. <br><br>  Tautan terkait: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh baris tunggal dengan perf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perf wiki</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437808/">https://habr.com/ru/post/id437808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437796/index.html">Sudahkah AlphaStar menerapkan kecepatan manusia super sebagai tambalan untuk kesalahan pelatihan simulasi?</a></li>
<li><a href="../id437800/index.html">ScrumTapi di tim analisis: sebelum tinggal landas</a></li>
<li><a href="../id437802/index.html">Teknologi Cloud Inovasi: Catastrophic Cloud</a></li>
<li><a href="../id437804/index.html">Bisakah saya menggunakan Redux di server?</a></li>
<li><a href="../id437806/index.html">EcmaScript 10 - JavaScript Tahun Ini (ES2019)</a></li>
<li><a href="../id437810/index.html">Realitas perusahaan</a></li>
<li><a href="../id437812/index.html">Xcode 10.2, macOS Mojave 10.14.4, iOS 12.1 dan beta lainnya</a></li>
<li><a href="../id437814/index.html">Xcode 10.2, macOS Mojave 10.14.4, iOS 12.1 dan versi beta lainnya</a></li>
<li><a href="../id437816/index.html">MPLS ada di mana-mana. Bagaimana infrastruktur jaringan Yandex.Cloud</a></li>
<li><a href="../id437818/index.html">Kami mengajarkan komputer untuk membedakan suara: mengenal kontes DCASE dan merakit klasifikasi audio Anda dalam 30 menit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>