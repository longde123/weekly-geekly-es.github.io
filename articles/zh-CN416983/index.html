<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸 🤛🏾 🛀🏽 为网络创建卡通水着色器。 第二部分 🥢 👩🏽‍🎤 🏂🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在第一部分中，我们着眼于设置环境和水面。 在这一部分中，我们将为对象提供浮力，在表面上添加水线，并在与表面相交的对象边界周围创建深度缓冲的泡沫线。 

 为了使场景看起来更好一点，我对其进行了一些小的更改。 您可以按照自己的方式自定义场景，但是我做了以下工作： 



- 添加了灯塔和章鱼的模型。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>为网络创建卡通水着色器。 第二部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416983/"> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分中，</a>我们着眼于设置环境和水面。 在这一部分中，我们将为对象提供浮力，在表面上添加水线，并在与表面相交的对象边界周围创建深度缓冲的泡沫线。 <br><br> 为了使场景看起来更好一点，我对其进行了一些小的更改。 您可以按照自己的方式自定义场景，但是我做了以下工作： <br><br><ul><li> 添加了灯塔和章鱼的模型。 </li><li>添加了具有<code>#FFA457</code>颜色的地面模型。 </li><li>  <code>#6CC8FF</code>添加了<code>#6CC8FF</code>的天空色。 </li><li> 在场景中添加了<code>#FFC480</code>背光颜色（这些参数可以在场景设置中找到）。 </li></ul><br> 我的原始场景现在看起来像这样。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/2fa/0d5/bc22fa0d57b5120e75cced6f105bebd2.png"></div><a name="habracut"></a><br><h2> 浮力 </h2><br> 创建浮力的最简单方法是使用脚本上下推对象。 创建一个新的<strong>Buoyancy.js</strong>脚本，并在其初始化中设置以下内容： <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getPosition().clone(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialRotation = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getEulerAngles().clone(); <span class="hljs-comment"><span class="hljs-comment">//     ,  //        //     this.time = Math.random() * 2 * Math.PI; };</span></span></code> </pre> <br> 现在在更新中，我们运行时间增量并旋转对象： <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      var pos = this.entity.getPosition().clone(); pos.y = this.initialPosition.y + Math.cos(this.time) * 0.07; this.entity.setPosition(pos.x,pos.y,pos.z); //    var rot = this.entity.getEulerAngles().clone(); rot.x = this.initialRotation.x + Math.cos(this.time * 0.25) * 1; rot.z = this.initialRotation.z + Math.sin(this.time * 0.5) * 2; this.entity.setLocalEulerAngles(rot.x,rot.y,rot.z); };</span></span></code> </pre> <br> 将此脚本应用到船上，看看它是如何在水上跳跃的！ 您可以将此脚本应用于多个对象（包括相机-尝试一下）！ <br><br><h2> 表面质感 </h2><br> 当我们看到波浪时，我们看着水面的边缘。 添加纹理将使表面运动更加明显。 此外，这是一种模拟反射和焦散的低成本方法。 <br><br> 您可以尝试找到一些腐蚀性纹理或自己创建一个。 我在Gimp中绘制<a href="" rel="external">了</a>可以自由使用<a href="" rel="external">的纹理</a> 。 只要可以将其平铺而无明显缝隙，则任何纹理均适用。 <br><br> 选择所需的纹理后，将其拖动到项目的Assets窗口中。 我们需要从Water.js脚本中引用此纹理，因此让我们为其创建一个属性： <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'surfaceTexture'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'texture'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Surface Texture'</span></span> });</code> </pre> <br> 然后在编辑器中分配它： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/672/61e/32f/67261e32f145eda9dab99d1866181ced.png"></div><br> 现在我们需要将其传递给着色器。 进入<strong>Water.js</strong> ，并将<code>CreateWaterMaterial</code>函数<code>CreateWaterMaterial</code>新参数： <br><br><pre> <code class="javascript hljs">material.setParameter(<span class="hljs-string"><span class="hljs-string">'uSurfaceTexture'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.surfaceTexture.resource);</code> </pre> <br> 现在回到<strong>Water.frag</strong>并声明一个新的制服： <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture;</code> </pre> <br> 我们快完成了。 要在平面上渲染纹理，我们需要知道每个像素在网格中的位置。 也就是说，我们需要将数据从顶点着色器传输到片段1。 <br><br><h3> 变化的变量 </h3><br>  <em>各种</em>变量允许您将数据从顶点着色器传输到片段着色器。 这是可以在着色器中使用的第三种特殊变量（前两种是<em>Uniform</em>和<em>attribute</em> ）。 为每个顶点设置一个变量，每个像素都可以访问它。 由于像素多于顶点，因此会在顶点之间插值（因此，名称为“可变”-偏离传递给它的值）。 <br><br> 要在运行中对其进行测试，请在<strong>Water.vert中</strong>声明一个新变量， <strong>使其</strong>变化： <br><br><pre> <code class="javascript hljs">varying vec2 ScreenPosition;</code> </pre> <br> 然后在计算后为其分配值<code>gl_Position</code> ： <br><br><pre> <code class="javascript hljs">ScreenPosition = gl_Position.xyz;</code> </pre> <br> 现在回到<strong>Water.frag</strong>并声明相同的变量。 我们无法从着色器获取调试数据的输出，但可以使用颜色进行可视调试。 方法如下： <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec3 ScreenPosition; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    varying- color = vec4(vec3(ScreenPosition.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br> 现在，该平面应为黑色和白色，并且分色线将<code>ScreenPosition.x</code> = 0的位置。颜色值仅从0变为1，但是<code>ScreenPosition</code>的值可能不在此范围内。 它们是自动限制的，因此，当您看到黑色时，它可以是0或负数。 <br><br> 我们刚刚要做的是将每个顶点的屏幕位置传递给每个像素。 您会看到，将黑白两边分开的线将始终通过屏幕的中心，而不管表面实际在世界上的何处。 <br><br><blockquote>  <em>任务1：创建一个新的变化变量，以转移世界上的位置而不是屏幕位置。</em>  <em>以相同的方式可视化它。</em>  <em>如果颜色不随相机的移动而改变，则说明一切正确。</em> </blockquote><br><h3> 使用紫外线 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">UV</a>是网格中每个顶点的2D坐标，从0标准化为1。对于将纹理正确采样到平面，它们是必需的，我们已经在上一部分中对其进行了配置。 <br><br> 我们在<strong>Water.vert中</strong>声明一个新属性（此名称取自Water.js中的着色器定义）： <br><br><pre> <code class="javascript hljs">attribute vec2 aUv0;</code> </pre> <br> 现在我们只需要将其传递给片段着色器，因此只需创建variant并将属性值分配给它即可： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Water.vert //        varying vec2 vUv0; // .. //        //  varying,        vUv0 = aUv0;</span></span></code> </pre> <br> 现在，我们将在片段着色器中声明相同的变量。 为了确保一切正常，我们可以像以前一样可视化调试，然后Water.frag将如下所示： <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  UV color = vec4(vec3(vUv0.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br> 您应该看到一个渐变，确认我们一端的值为0，另一端的值为1。 现在要对纹理进行真实采样，我们需要做的是： <br><br><pre> <code class="javascript hljs">color = texture2D(uSurfaceTexture,vUv0);</code> </pre> <br> 之后，我们将在表面上看到纹理： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/9bf/ae2/f499bfae266b0aa16709bbea0280df6f.png"></div><br><h3> 纹理样式 </h3><br> 让我们将其与现有的蓝色结合起来，而不仅仅是将纹理设置为新的颜色： <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec4 WaterLines = texture2D(uSurfaceTexture,vUv0); color.rgba += WaterLines.r; gl_FragColor = color; }</code> </pre> <br> 这是可行的，因为除水线以外的所有地方纹理颜色均为黑色（0）。 加上它，我们不会更改初始的蓝色，除非带有线条的地方变浅。 <br><br> 但是，这不是组合颜色的唯一方法。 <br><br><blockquote>  <em>任务2：是否可以组合颜色以得到如下所示的较弱效果？</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/e18/22a/a3de1822a348656f47e5bd6cfa6cbed5.png"></div><br><h3> 移动纹理 </h3><br> 作为最后的效果，我们希望线条沿表面移动，并且看起来不是那么静态。 为此，我们将利用一个事实，即传递给<code>texture2D</code>函数的从0到1的间隔之外的任何值都将被传输（例如1.5和2.5都等于0.5）。 因此，我们可以通过已经设置的统一时间变量来增加位置，以增加或减少表面上线条的密度，这将使最终的片段着色器具有以下形式： <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; uniform float uTime; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0; <span class="hljs-comment"><span class="hljs-comment">//      1 //     pos *= 2.0; //   ,      pos.y += uTime * 0.02; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r; gl_FragColor = color; }</span></span></code> </pre> <br><h2> 泡沫线和深度缓冲 </h2><br> 在水中围绕对象绘制泡沫线使查看对象浸入的程度以及它们在表面的位置变得容易得多。 另外，这样我们的水变得更加可信。 为了实现泡沫线，我们需要以某种方式找出每个物体的边界在哪里，并有效地做到这一点。 <br><br><h3> 绝招 </h3><br> 我们需要学习确定水表面的像素是否靠近物体。 如果是这样，那么我们可以将其涂成泡沫的颜色。 据我所知，没有简单的方法可以解决此问题。 因此，为了解决这个问题，我使用了一种有用的技术来解决问题：我将以一个我们知道答案的示例为例，看看是否可以将其概括。 <br><br> 看一下下面的图片。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d0/0e7/eec/4d00e7eec8714a365c110aea67df9fab.png"></div><br> 泡沫应包含哪些像素？ 我们知道它应该看起来像这样： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a8/541/c4f/1a8541c4f8fdd65879966b909805c484.png"></div><br> 因此，让我们看两个特定的像素。 在下面，我用星号标记了它们。 黑色会出现在泡沫上，而红色不会出现在泡沫上。 我们如何在着色器中区分它们？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/d35/fb2/012d35fb25d42c19a86adaa081048237.png"></div><br> 我们知道，即使屏幕空间中的这两个像素彼此靠近（均在灯塔顶部渲染），但实际上它们在世界空间中相距甚远。 我们可以从不同的角度看同一场景来验证这一点。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd3/5a0/31b/cd35a031bbd18805128ebd44ed1c1279.png"></div><br> 请注意，在我们看来，红色的星星并不位于灯塔上，而实际上黑色的星星就在灯塔上。 我们可以通过使用到相机的距离（通常称为“深度”）来区分。 深度1表示该点非常靠近相机，深度0表示该点很远。 但这不仅是世界上绝对距离，深度或摄像机的问题。  <em>相对于其背后像素的</em>深度<em>很</em>重要。 <br><br> 再次查看第一个视图。 假设灯塔的船体的深度值为0.5。 黑星的深度将非常接近0.5。 也就是说，它和它下面的像素具有非常接近的深度值。 另一方面，红色星号的深度要大得多，因为它更靠近相机，例如0.7。 并且尽管其后面的像素仍在灯塔上，但其深度值为0.5，即差异更大。 <br><br> 这是诀窍。  <em>当水面上像素的深度足够接近其绘制像素的深度时，我们就非常接近某些对象的边界，</em>并且可以像泡沫一样渲染像素。 <br><br> 也就是说，我们需要比任何像素都更多的信息。 我们不知何故需要找出应在其上绘制像素的深度。 在这里，深度缓冲区对我们很有用。 <br><br><h3> 深度缓冲 </h3><br> 您可以将帧缓冲区或帧缓冲区视为屏幕外目标渲染或纹理。 当我们需要读取数据时，我们需要在屏幕外渲染。 此技术用于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">烟熏效果</a> 。 <br><br> 深度缓冲区是一种特殊的目标渲染，其中包含有关每个像素的深度值的信息。 不要忘记顶点着色器中<code>gl_Position</code>计算的值是屏幕空间值，但它还有第三个坐标-Z值，此Z值用于计算深度，并将其写入深度缓冲区。 <br><br> 深度缓冲区用于正确渲染场景，而无需从后到前对对象进行排序。 首先要绘制的每个像素都会检查深度缓冲区。 如果其深度值大于缓冲区中的值，则将其绘制，并且其自身的值将覆盖缓冲区的值。 否则，它将被丢弃（因为这意味着它前面有另一个对象）。 <br><br> 实际上，您可以禁用对深度缓冲区的写入，以查看没有该缓冲区的一切情况。 让我们尝试在Water.js中做到这一点： <br><br><pre> <code class="javascript hljs">material.depthTest = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br> 您会注意到，即使水在不透明的物体后面，现在也总是从上方抽水。 <br><br><h3> 深度缓冲区可视化 </h3><br> 让我们为渲染目的添加一种渲染深度缓冲区的方法。 创建一个新的<strong>DepthVisualize.js</strong>脚本。 将其安装到相机。 <br><br> 要访问PlayCanvas中的深度缓冲区，只需编写以下内容： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.camera.camera.requestDepthMap();</code> </pre> <br> 因此，我们将统一变量自动注入到所有着色器中，可以通过声明如下进行使用： <br><br><pre> <code class="javascript hljs">uniform sampler2D uDepthMap;</code> </pre> <br> 下面是一个示例脚本，该脚本请求深度图并将其渲染到场景的顶部。 他配置了热重启。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DepthVisualize = pc.createScript(<span class="hljs-string"><span class="hljs-string">'depthVisualize'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  initialize,       DepthVisualize.prototype.initialize = function() { this.entity.camera.camera.requestDepthMap(); this.antiCacheCount = 0; //    ,         this.SetupDepthViz(); }; DepthVisualize.prototype.SetupDepthViz = function(){ var device = this.app.graphicsDevice; var chunks = pc.shaderChunks; this.fs = ''; this.fs += 'varying vec2 vUv0;'; this.fs += 'uniform sampler2D uDepthMap;'; this.fs += ''; this.fs += 'float unpackFloat(vec4 rgbaDepth) {'; this.fs += ' const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);'; this.fs += ' float depth = dot(rgbaDepth, bitShift);'; this.fs += ' return depth;'; this.fs += '}'; this.fs += ''; this.fs += 'void main(void) {'; this.fs += ' float depth = unpackFloat(texture2D(uDepthMap, vUv0)) * 30.0; '; this.fs += ' gl_FragColor = vec4(vec3(depth),1.0);'; this.fs += '}'; this.shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, this.fs, "renderDepth" + this.antiCacheCount); this.antiCacheCount ++; //     ,        this.command = new pc.Command(pc.LAYER_FX, pc.BLEND_NONE, function () { pc.drawQuadWithShader(device, null, this.shader); }.bind(this)); this.command.isDepthViz = true; //    ,      this.app.scene.drawCalls.push(this.command); }; //  update,     DepthVisualize.prototype.update = function(dt) { }; //  swap,      //      DepthVisualize.prototype.swap = function(old) { this.antiCacheCount = old.antiCacheCount; //      for(var i=0;i&lt;this.app.scene.drawCalls.length;i++){ if(this.app.scene.drawCalls[i].isDepthViz){ this.app.scene.drawCalls.splice(i,1); break; } } //    this.SetupDepthViz(); }; //      ,  : // http://developer.playcanvas.com/en/user-manual/scripting/</span></span></code> </pre> <br> 尝试复制代码并注释掉该行<code>this.app.scene.drawCalls.push(this.command);</code> 启用/禁用深度渲染。 这看起来应如下图所示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c09/93a/c4f/c0993ac4f8ed7a4c739658bbff69e455.png"></div><br><blockquote>  <em>任务3：未将水表面吸入深度缓冲区。</em>  <em>PlayCanvas引擎是故意这样做的。</em>  <em>你能弄清楚为什么吗？</em>  <em>水材料有什么特别之处？</em>  <em>换句话说，给定我们检查深度的规则，如果将水像素写入深度缓冲区会发生什么情况？</em> </blockquote><br>  <em>提示：您可以在Water.js中更改一行，从而可以将水写入深度缓冲区。</em> <br><br> 还应该注意的是，在初始化函数中，我将深度值乘以30。要清楚地看到它，这是必需的，因为否则值的范围将太小而无法显示色调。 <br><br><h3> 技巧实施 </h3><br>  PlayCanvas引擎中有几个用于处理深度值的辅助功能，但是在编写时，它们尚未在生产中发布，因此我们必须自己配置它们。 <br><br> 我们在<strong>Water.frag中定义</strong>以下统一变量： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   uniform-    PlayCanvas uniform sampler2D uDepthMap; uniform vec4 uScreenSize; uniform mat4 matrix_view; //      uniform vec4 camera_params;</span></span></code> </pre> <br> 我们在主要功能上定义了这些辅助功能： <br><br><pre> <code class="javascript hljs">#ifdef GL2 float linearizeDepth(float z) { z = z * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (camera_params.z * z + camera_params.w); } #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #ifndef UNPACKFLOAT #define UNPACKFLOAT float unpackFloat(vec4 rgbaDepth) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec4 bitShift = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">256.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot(rgbaDepth, bitShift); } #endif #endif float getLinearScreenDepth(vec2 uv) { #ifdef GL2 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y; #endif } float getLinearDepth(vec3 pos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -(matrix_view * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)).z; } float getLinearScreenDepth() { vec2 uv = gl_FragCoord.xy * uScreenSize.zw; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getLinearScreenDepth(uv); }</code> </pre> <br> 我们将在<strong>Water.js中</strong>传递有关相机的着色器信息。 将其粘贴到传递其他统一变量（如uTime）的位置： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">"Camera"</span></span>).camera; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = camera.nearClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = camera.farClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera_params = [ <span class="hljs-number"><span class="hljs-number">1</span></span>/f, f, (<span class="hljs-number"><span class="hljs-number">1</span></span>-f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-number"><span class="hljs-number">1</span></span> + f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span> ]; material.setParameter(<span class="hljs-string"><span class="hljs-string">'camera_params'</span></span>, camera_params);</code> </pre> <br> 最后，我们需要为片段着色器在每个像素的世界中放置一个位置。 我们必须从顶点着色器获取它。 因此，我们将在<strong>Water.frag中</strong>定义一个变化的变量： <br><br><pre> <code class="javascript hljs">varying vec3 WorldPosition;</code> </pre> <br> 在<strong>Water.vert中</strong>定义相同的变化变量。 然后，从顶点着色器为它分配一个变形的位置，以便完整的代码如下所示： <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; attribute vec2 aUv0; varying vec2 vUv0; varying vec3 WorldPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; uniform float uTime; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vUv0 = aUv0; vec3 pos = aPosition; pos.y += cos(pos.z*<span class="hljs-number"><span class="hljs-number">5.0</span></span>+uTime) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> * sin(pos.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span> + uTime); gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); WorldPosition = pos; }</code> </pre> <br><h3> 我们意识到真正的窍门 </h3><br> 现在，我们终于准备好实施本节开头介绍的技术。 我们想将我们所在的像素的深度与它下方的像素的深度进行比较。 我们所在的像素是从世界上某个位置获取的，而其下方的像素是从屏幕位置获取的。 因此，我们采取以下两个深度： <br><br><pre> <code class="javascript hljs">float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth();</code> </pre> <br><blockquote>  <em>任务4：这些值之一将永远不会大于另一个（假设depthTest = true）。</em>  <em>你能确定哪一个吗？</em> </blockquote><br> 我们知道，泡沫将是两个值之间的距离较小的地方。 因此，让我们为每个像素渲染此差异。 将其粘贴到着色器的末尾（并关闭上一部分中的深度可视化脚本）： <br><br><pre> <code class="javascript hljs">color = vec4(vec3(screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">1.0</span></span>); gl_FragColor = color;</code> </pre> <br> 它看起来应该像这样： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/173/883/ad2173883ebe214bbec6c97921810755.png"></div><br> 也就是说，我们正确地实时选择了浸入水中的任何物体的边界！ 当然，您可以缩放差异以使泡沫更厚或更不常见。 <br><br> 现在，我们有很多选择，可以将此输出与水面结合起来以创建漂亮的泡沫线。 您可以为它们保留渐变色，用于从其他纹理进行采样，或者在差异小于或等于某个极限值时为它们指定特定的颜色。 <br><br> 我最喜欢的是分配与静态水线相似的颜色，所以我完成的主要功能如下所示： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0 * <span class="hljs-number"><span class="hljs-number">2.0</span></span>; pos.y += uTime * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r * <span class="hljs-number"><span class="hljs-number">0.1</span></span>; float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth(); float foamLine = clamp((screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(foamLine &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>){ color.rgba += <span class="hljs-number"><span class="hljs-number">0.2</span></span>; } gl_FragColor = color; }</code> </pre> <br><h2> 总结一下 </h2><br> 我们创建了浸入水中的物体的浮力，在表面上应用了移动的纹理以模拟焦散，并学习了如何使用深度缓冲区创建动态泡沫条纹。 <br><br> 在第三部分和最后一部分中，我们将添加后处理的效果，并学习如何使用它们来创建水下失真的效果。 <br><br><h2> 源代码 </h2><br> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">这里</a>找到完成的PlayCanvas项目。 我们的存储库还在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">Three.js下</a>有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">项目端口</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN416983/">https://habr.com/ru/post/zh-CN416983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN416967/index.html">正如我们做的BelAZ。 第3部分-分段调试</a></li>
<li><a href="../zh-CN416969/index.html">毕达哥拉斯乐谱的数学证明</a></li>
<li><a href="../zh-CN416977/index.html">智能家居软件＃2</a></li>
<li><a href="../zh-CN416979/index.html">对大型团队的关注：LeSS Day 2018</a></li>
<li><a href="../zh-CN416981/index.html">八个人如何扩展高负荷项目。 不飞溅的经验</a></li>
<li><a href="../zh-CN416985/index.html">精确到接近百分之一：SmartData 2017十大报告</a></li>
<li><a href="../zh-CN416987/index.html">Gartner：2018年IaaS市场的主要内容</a></li>
<li><a href="../zh-CN416989/index.html">Festo仿生机器人：未来工厂中的蜘蛛和章鱼？</a></li>
<li><a href="../zh-CN416991/index.html">从屏幕上录制视频并不是那么秘密。 King Burger版本和Appsee</a></li>
<li><a href="../zh-CN416993/index.html">与索非亚见面：几乎与人类没有区别的机器人</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>