<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçü§ù‚Äçüë®üèæ üóΩ üì∑ WebSockets in Angular: Erstellen Sie einen Angular-Service f√ºr die Arbeit mit Web-Sockets üìÑ üë©üèº‚Äçüíª üò†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich versuchen, den engen Umfang der Technologie im Rahmen des Angular-Frameworks und seines bereits integrierten Assistenten -...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebSockets in Angular: Erstellen Sie einen Angular-Service f√ºr die Arbeit mit Web-Sockets</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416155/"><img src="https://habrastorage.org/webt/dz/-h/c_/dz-hc_la-a4emvhkqbd4ihr5zfe.jpeg" alt="Bild"><br>  In diesem Artikel werde ich versuchen, den engen Umfang der Technologie im Rahmen des Angular-Frameworks und seines bereits integrierten Assistenten - RxJs - detailliert zu behandeln, w√§hrend wir bewusst nicht auf Server-Implementierungen eingehen, wie z  Dies ist ein vollwertiges Thema f√ºr einen separaten Artikel. <br><br>  Dieser Text ist n√ºtzlich f√ºr diejenigen, die bereits mit Angular vertraut sind, aber ihr Wissen direkt √ºber das Thema vertiefen m√∂chten. <br><a name="habracut"></a><br>  Zun√§chst einige grundlegende Informationen. <br><br><h2>  Was ist WebSocket und warum brauchen Sie es? </h2><br><blockquote>  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> ist WebSocket ein ‚ÄûDuplex-Kommunikationsprotokoll (es kann gleichzeitig senden und empfangen) √ºber eine TCP-Verbindung, das f√ºr Echtzeitnachrichten zwischen einem Browser und einem Webserver entwickelt wurde. <br>  WebSocket ist f√ºr die Implementierung in Webbrowsern und Webservern konzipiert, kann jedoch f√ºr jeden Client oder jede Serveranwendung verwendet werden.  Das WebSocket-Protokoll ist ein unabh√§ngiges Protokoll, das auf dem TCP-Protokoll basiert.  Es erm√∂glicht eine engere Interaktion zwischen dem Browser und der Website und erleichtert die Verteilung interaktiver Inhalte und die Erstellung von Echtzeitanwendungen. ‚Äú <br></blockquote><br>  Mit anderen Worten, WebSocket erm√∂glicht es dem Server, jederzeit Anforderungen vom Client zu empfangen und Anforderungen an den Client zu senden. Somit erhalten Browser (Client) und Server gleiche Rechte und die M√∂glichkeit, Nachrichten auszutauschen, wenn eine Verbindung besteht.  Eine regul√§re AJAX-Anforderung erfordert die √úbertragung vollst√§ndiger HTTP-Header, was einen erh√∂hten Datenverkehr in beide Richtungen bedeutet, w√§hrend der Overhead von Web-Sockets nach dem Herstellen einer Verbindung nur zwei Byte betr√§gt.  Web Socket reduziert die Menge an Informationen, die in HTTP-Headern √ºbertragen werden, um das Hunderttausende und reduziert die Wartezeit erheblich.  Web-Socket-Verbindungen unterst√ºtzen dom√§nen√ºbergreifende Funktionen wie CORS. <br><br>  Auf der Serverseite gibt es Pakete zur Unterst√ºtzung des Web-Sockets, auf dem Client die HTML5-WebSocket-API mit einer Schnittstelle von drei Methoden: <br><br>  <b><i>WebSocket</i></b> - die Hauptschnittstelle zum Herstellen einer Verbindung zu einem WebSocket-Server und zum Senden und Empfangen von Daten √ºber die Verbindung; <br>  <b><i>CloseEvent</i></b> - ein Ereignis, das vom WebSocket-Objekt <b><i>ausgel√∂st wurde,</i></b> als die Verbindung geschlossen wurde; <br>  <b><i>MessageEvent</i></b> - Ein Ereignis, das von einem WebSocket <b><i>ausgel√∂st wird,</i></b> wenn eine Nachricht vom Server empfangen wird. <br><br>  So sieht es auf der JavaSript-Implementierungsebene aus: <br><br><pre><code class="plaintext hljs">const ws = new WebSocket("ws://www.example.com/socketserver", "protocolOne"); ws.onopen = () =&gt; { ws.onmessage = (event) =&gt; { console.log(event); } ws.send("Here's some text that the server is urgently awaiting!"); };</code> </pre> <br>  <b><i>onmessage</i></b> - Abh√∂ren von Nachrichten vom Server <br>  <b><i>Senden</i></b> - Senden Sie Ihre Nachrichten an den Server <br><br>  Das hei√üt, in seiner Grundform ist alles sehr einfach. Wenn Sie sich jedoch mit dem Thema befassen m√∂chten, k√∂nnen Sie sich an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MDN-Webdokumente</a> wenden und gleichzeitig Bibliotheken studieren, die ihre eigenen Ebenen √ºber dieser API implementieren. <br><br><h2>  Warum haben Sie keine Angst, WebSocket zu verwenden? </h2><br>  Der erste Punkt, der abschrecken kann, ist die <b>Browserunterst√ºtzung</b> .  Heute gibt es kein solches Problem - WebSocket wird sowohl im Web als auch im mobilen Segment fast vollst√§ndig unterst√ºtzt. <br><br><img src="https://habrastorage.org/webt/6q/kt/br/6qktbrrlnloyi0ec862v8qzclts.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/bn/pk/k5/bnpkk58xzozo2c9plnkgszfjnk4.png" alt="Bild"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://caniuse.com/#feat=websockets</a> <br><br>  Der zweite Punkt ist die <b>einfache Implementierung</b> .  Ja, das ist zun√§chst entmutigend. <br><br>  Die API ist so einfach, dass es auf den ersten Blick schwierig sein kann, zu verstehen, wie man mit einer so bescheidenen Anzahl von Methoden arbeitet, da alle au√üer einer entweder Fehler oder Verbindungen melden und nur eine von ihnen - <b><i>onmessage</i></b> - tr√§gt f√ºr welche Web-Sockets verwendet werden, d.h.  um Daten vom Server zu empfangen. <br><br>  Gleichzeitig ist der Haken, dass der Server normalerweise unterschiedliche Daten sendet, daher ben√∂tigen wir mehrere unterschiedliche Nachrichten?  Oder m√ºssen Sie f√ºr jedes Datenmodell eine eigene Verbindung erstellen? <br><br>  Also die Aufgabe: Sie m√ºssen das Benutzermodell und das neueste Nachrichtenmodell vom Server akzeptieren, und vielleicht sogar etwas anderes. <br><br>  Ich bin auf eine so "elegante" Implementierung gesto√üen: <br><br><pre> <code class="plaintext hljs">const wsUser = new WebSocket("ws://www.example.com/user"); wsUser.onmessage = (event) =&gt; { // ... }; const wsNews = new WebSocket("ws://www.example.com/news"); wsNews.onmessage = (event) =&gt; { // ... }; const wsTime = new WebSocket("ws://www.example.com/time"); wsTime.onmessage = (event) =&gt; { // ... }; const wsDinner = new WebSocket("ws://www.example.com/dinner"); wsDinner.onmessage = (event) =&gt; { // ... }; const wsCurrency = new WebSocket("ws://www.example.com/currency"); wsCurrency.onmessage = (event) =&gt; { // ... }; const wsOnline = new WebSocket("ws://www.example.com/online"); wsOnline.onmessage = (event) =&gt; { // ... }; const wsLogin = new WebSocket("ws://www.example.com/login"); wsLogin.onmessage = (event) =&gt; { // ... }; const wsLogout = new WebSocket("ws://www.example.com/logout"); wsLogout.onmessage = (event) =&gt; { // ... };</code> </pre> <br>  Auf den ersten Blick ist alles logisch.  Aber stellen Sie sich jetzt vor, wie es aussehen wird, wenn es Dutzende oder Hunderte von ihnen gibt.  Bei einem der Projekte, an denen ich gerade gearbeitet habe, gab es ungef√§hr dreihundert Veranstaltungen. <br><br><img src="https://habrastorage.org/webt/d3/rg/dl/d3rgdlp8eggnms2ot2ely5zktz8.jpeg" alt="Bild"><br><br>  Wir l√∂sen das Problem. <br><br>  In allen Bibliotheken von Drittanbietern f√ºr die Arbeit mit Web-Sockets k√∂nnen Sie Nachrichten vom Typ addEventListener abonnieren.  Es sieht so aus: <br><br><pre> <code class="plaintext hljs">ws.on("user", (userData) =&gt; { / .. })</code> </pre> <br>  Wie wir wissen, k√∂nnen wir mit einer einzigen Methode arbeiten - <b><i>onmessage</i></b> , die alle Daten als Teil ihrer Verbindung empf√§ngt, sodass dieser Code etwas ungew√∂hnlich aussieht.  Dies wird wie folgt implementiert: <b><i>onmessage</i></b> gibt ein <b><i>MessageEvent zur√ºck</i></b> , das das <b><i>Datenfeld</i></b> enth√§lt.  Es sind <b><i>Daten,</i></b> die die Informationen enthalten, die der Server an uns sendet.  Dieses Objekt sieht folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">{ "event": "user", "data": { "name": "John Doe", ... } }</code> </pre> <br>  Dabei ist <b><i>Ereignis</i></b> der Schl√ºssel, mit dem bestimmt werden kann, welche Informationen der Server gesendet hat.  Als n√§chstes wird auf der Front-End-Seite ein Bus erstellt, der Informationen nach Ereignis filtert und an die gew√ºnschte Adresse sendet: <br><br><pre> <code class="plaintext hljs">const ws = new WebSocket("ws://www.example.com"); ws.onmessage = (event) =&gt; { const data = JSON.parse(event.data); if (data.event === 'user') { // ... } if (data.event === 'news') { // ... } };</code> </pre> <br><br>  Auf diese Weise k√∂nnen verschiedene Daten innerhalb derselben Verbindung empfangen und √ºber eine Syntax abonniert werden, die der f√ºr JS-Ereignisse √ºblichen √§hnelt. <br><br><h2>  WebSockets in Angular </h2><br>  Schlie√ülich kamen wir zum Wichtigsten - der Verwendung von WebSockets direkt in Angular. <br><br>  Trotz der Einfachheit der Arbeit mit der nativen WebSocket-API werden wir in diesem Artikel RxJs verwenden, was nat√ºrlich darauf zur√ºckzuf√ºhren ist, dass es sich um Angular handelt. <br><br>  Die native WebSocket-API kann in Anwendungen auf Angular verwendet werden, eine benutzerfreundliche Oberfl√§che auf der Basis von RxJs Observable erstellen, die erforderlichen Nachrichten abonnieren usw., aber RxJs hat bereits die Hauptarbeit f√ºr Sie erledigt: WebSocketSubject ist ein reaktiver Wrapper √ºber das Standard-WebSocket API  Es wird kein Ereignisbus erstellt oder die Verbindung erneut hergestellt.  Dies ist ein regul√§res Thema, mit dem Sie mit reaktiven Web-Sockets arbeiten k√∂nnen. <br><br><h2>  RxJs WebSocketSubject </h2><br>  Daher erwartet <a href="">WebSocketSubject WebSocketSubjectConfig</a> und ein optionales Ziel, in dem Sie einen Link zu Ihrem beobachteten Betreff √ºbergeben k√∂nnen, erstellt ein Observable, √ºber das Sie Nachrichten f√ºr Web-Sockets abh√∂ren und senden k√∂nnen. <br><br>  Einfach ausgedr√ºckt, Sie √ºbergeben die Verbindungs-URL als WebSocketSubject-Argument und abonnieren alle Aktivit√§ten des Web-Sockets auf die f√ºr RxJs √ºbliche Weise.  Wenn Sie eine Nachricht an den Server senden m√ºssen, verwenden Sie dieselbe √ºbliche Methode webSocketSubject.next (data). <br><br><h2>  Wir bieten einen Service f√ºr die Arbeit mit WebSocket Angular </h2><br>  Beschreiben Sie kurz, was wir vom Service erwarten: <br><br><ul><li>  Einheitliche und √ºbersichtliche Oberfl√§che; </li><li>  M√∂glichkeit der Konfiguration auf Verbindungsebene von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DI-</a> Abh√§ngigkeiten; </li><li>  Die M√∂glichkeit der Wiederverwendung; </li><li>  Tippen; </li><li>  Die M√∂glichkeit, sich anzumelden, um Informationen per Schl√ºssel zu erhalten; </li><li>  M√∂glichkeit, ein Abonnement zu k√ºndigen; </li><li>  Senden von Nachrichten an den Server; </li><li>  Schlie√üen Sie die Verbindung wieder an. </li></ul><br>  Der letzte Punkt ist besonders zu beachten.  Die erneute Verbindung oder die Organisation der erneuten Verbindung zum Server ist ein wichtiger Faktor bei der Arbeit mit Web-Sockets  Netzwerkbr√ºche, Serverabst√ºrze oder andere Fehler, die einen Verbindungsbruch verursachen, k√∂nnen zum Absturz der Anwendung f√ºhren. <br><br>  Es ist wichtig zu beachten, dass Wiederverbindungsversuche <b>nicht zu h√§ufig sein</b> und nicht auf unbestimmte Zeit fortgesetzt werden sollten  Dieses Verhalten kann den Client anhalten. <br><br>  Fangen wir an. <br><br>  Zun√§chst erstellen wir eine Service-Konfigurationsschnittstelle und ein Modul, das die Konfiguration bei Verbindung erm√∂glicht. <br><br>  Wenn m√∂glich, werde ich den Code verk√ºrzen, die Vollversion, die Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der russischsprachigen Angular-Community auf GitHub sehen k√∂nnen</a> . <br><br><pre> <code class="plaintext hljs">export interface WebSocketConfig { url: string; reconnectInterval?: number; reconnectAttempts?: number; } export class WebsocketModule { public static config(wsConfig: WebSocketConfig): ModuleWithProviders { return { ngModule: WebsocketModule, providers: [{ provide: config, useValue: wsConfig }] }; } }</code> </pre> <br>  Als n√§chstes m√ºssen wir die Schnittstelle der Web-Socket-Nachricht beschreiben: <br><br><pre> <code class="plaintext hljs">export interface IWsMessage&lt;T&gt; { event: string; data: T; }</code> </pre> <br>  Dabei ist <b><i>Ereignis</i></b> der Schl√ºssel, und die vom Schl√ºssel erhaltenen <b><i>Daten</i></b> sind ein typisiertes Modell. <br><br>  Die √∂ffentliche Schnittstelle des Dienstes sieht folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">export interface IWebsocketService { on&lt;T&gt;(event: string): Observable&lt;T&gt;; send(event: string, data: any): void; status: Observable&lt;boolean&gt;; }</code> </pre> <br>  Service hat Felder: <br><br><pre> <code class="plaintext hljs">//   WebSocketSubject private config: WebSocketSubjectConfig&lt;IWsMessage&lt;any&gt;&gt;; private websocketSub: SubscriptionLike; private statusSub: SubscriptionLike; // Observable    interval private reconnection$: Observable&lt;number&gt;; private websocket$: WebSocketSubject&lt;IWsMessage&lt;any&gt;&gt;; // ,      private connection$: Observer&lt;boolean&gt;; //  Observable       private wsMessages$: Subject&lt;IWsMessage&lt;any&gt;&gt;; //       private reconnectInterval: number; //    private reconnectAttempts: number; //      private isConnected: boolean; //   public status: Observable&lt;boolean&gt;;</code> </pre> <br>  Im Konstruktor der Serviceklasse erhalten wir das WebSocketConfig-Objekt, das angegeben wurde, als das Modul verbunden wurde: <br><br><pre> <code class="plaintext hljs">constructor(@Inject(config) private wsConfig: WebSocketConfig) { this.wsMessages$ = new Subject&lt;IWsMessage&lt;any&gt;&gt;(); //  ,  ,     this.reconnectInterval = wsConfig.reconnectInterval || 5000; this.reconnectAttempts = wsConfig.reconnectAttempts || 10; //      connection$   websocket$ this.config = { url: wsConfig.url, closeObserver: { next: (event: CloseEvent) =&gt; { this.websocket$ = null; this.connection$.next(false); } }, //     connection$ openObserver: { next: (event: Event) =&gt; { console.log('WebSocket connected!'); this.connection$.next(true); } } }; // connection status this.status = new Observable&lt;boolean&gt;((observer) =&gt; { this.connection$ = observer; }).pipe(share(), distinctUntilChanged()); //      this.statusSub = this.status .subscribe((isConnected) =&gt; { this.isConnected = isConnected; if (!this.reconnection$ &amp;&amp; typeof(isConnected) === 'boolean' &amp;&amp; !isConnected) { this.reconnect(); } }); // ,  -    this.websocketSub = this.wsMessages$.subscribe( null, (error: ErrorEvent) =&gt; console.error('WebSocket error!', error) ); //  this.connect(); }</code> </pre> <br>  Die Verbindungsmethode selbst ist einfach: <br><br><pre> <code class="plaintext hljs">private connect(): void { this.websocket$ = new WebSocketSubject(this.config); //  //   ,    , //  ,  // ,    this.websocket$.subscribe( (message) =&gt; this.wsMessages$.next(message), (error: Event) =&gt; { if (!this.websocket$) { // run reconnect if errors this.reconnect(); } }); }</code> </pre> <br>  Das erneute Verbinden ist etwas komplizierter: <br><br><pre> <code class="plaintext hljs">private reconnect(): void { //  interval    reconnectInterval this.reconnection$ = interval(this.reconnectInterval) .pipe(takeWhile((v, index) =&gt; index &lt; this.reconnectAttempts &amp;&amp; !this.websocket$)); //     ,        this.reconnection$.subscribe( () =&gt; this.connect(), null, () =&gt; { // Subject complete if reconnect attemts ending this.reconnection$ = null; if (!this.websocket$) { this.wsMessages$.complete(); this.connection$.complete(); } }); }</code> </pre> <br>  Die <b><i>on-</i></b> Methode ist auch sehr einfach, es gibt nichts zu kommentieren. <br><br><pre> <code class="plaintext hljs">public on&lt;T&gt;(event: string): Observable&lt;T&gt; { if (event) { return this.wsMessages$.pipe( filter((message: IWsMessage&lt;T&gt;) =&gt; message.event === event), map((message: IWsMessage&lt;T&gt;) =&gt; message.data) ); } }</code> </pre> <br>  Die <b><i>Sendemethode</i></b> ist noch einfacher: <br><br><pre> <code class="plaintext hljs">public send(event: string, data: any = {}): void { if (event &amp;&amp; this.isConnected) { //   any ,   ""   string //      :) this.websocket$.next(&lt;any&gt;JSON.stringify({ event, data })); } else { console.error('Send error!'); } }</code> </pre> <br>  Das ist der ganze Service.  Wie Sie sehen k√∂nnen, fiel der Gro√üteil des Codes auf die Organisation der erneuten Verbindung. <br><br>  Lassen Sie uns nun sehen, wie Sie es verwenden.  Schlie√üen Sie das WebsocketModule-Modul an: <br><br><pre> <code class="plaintext hljs">imports: [ WebsocketModule.config({ url: environment.ws //      'ws://www.example.com' }) ]</code> </pre> <br>  Im Komponentenkonstruktor injizieren wir den Dienst und abonnieren Nachrichten von ' <b><i>Nachrichten</i></b> '. Senden Sie den Text zur√ºck an den Server: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private wsService: WebsocketService) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsService.on&lt;IMessage[]&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'messages'</span></span></span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(messages: IMessage[]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(messages); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsService.send(<span class="hljs-string"><span class="hljs-string">'text'</span></span>, <span class="hljs-string"><span class="hljs-string">'Test Text!'</span></span>); }); }</code> </pre> <br>  Der Name der Ereignisse ist bequemer, um Konstanten oder eine Aufz√§hlung einzugeben.  Wir erstellen irgendwo die Datei websocket.events.ts und schreiben sie hinein: <br><br><pre> <code class="plaintext hljs">export const WS = { ON: { MESSAGES: 'messages' }, SEND: { TEXT: 'text' } };</code> </pre> <br>  Schreiben Sie Abonnements mit dem erstellten WS-Objekt neu: <br><br><pre> <code class="plaintext hljs">this.wsService.on&lt;IMessage[]&gt;(WS.ON.MESSAGES) .subscribe((messages: IMessage[]) =&gt; { console.log(messages); this.wsService.send(WS.SEND.TEXT, 'Test Text!'); });</code> </pre> <br><img src="https://habrastorage.org/webt/zn/jz/k7/znjzk75iy2uudtgep2wr4u8djmk.jpeg" alt="Bild"><br><br><h2>  Abschlie√üend </h2><br>  Das ist in der Tat alles.  Dies ist ein notwendiges Minimum, das ein Angular-Entwickler √ºber WebSockets wissen muss.  Ich hoffe, dass ich dieses Thema ganz klar behandelt habe.  Die Vollversion des Dienstes finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> . <br><br>  Bei allen Fragen k√∂nnen Sie sich in den Kommentaren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">an mich</a> per Telegramm oder auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den dortigen Angular-Kanal</a> wenden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416155/">https://habr.com/ru/post/de416155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416143/index.html">Das Buch "Eine Autopsie wird zeigen!" Praktische Malware-Analyse ¬ª</a></li>
<li><a href="../de416147/index.html">Organisation der Navigation in iOS-Anwendungen mit dem Root Controller</a></li>
<li><a href="../de416149/index.html">Fragen und Antworten zu erneuerbaren Energien, Teil 1</a></li>
<li><a href="../de416151/index.html">Dimensionsloser Ballon. Utilitaristische Dimensionsanalyse Magie</a></li>
<li><a href="../de416153/index.html">Werden Flugzeuge zuverl√§ssiger? Flugzeughersteller f√ºhren Roboter in Unternehmen ein</a></li>
<li><a href="../de416157/index.html">In den Armen von Python (nur f√ºr Frauen)</a></li>
<li><a href="../de416159/index.html">Wie wir beauftragt wurden, einen Igel mit einer Schlange zu vergleichen</a></li>
<li><a href="../de416161/index.html">10 Gr√ºnde, k8s nicht zu verwenden</a></li>
<li><a href="../de416163/index.html">Lerne OpenGL. Lektion 5.6 - Parallaxenzuordnung</a></li>
<li><a href="../de416167/index.html">Peter Norwig: Programmieren lernen in ... 10 Jahren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>