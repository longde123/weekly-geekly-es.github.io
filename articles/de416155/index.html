<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🤝‍👨🏾 🗽 📷 WebSockets in Angular: Erstellen Sie einen Angular-Service für die Arbeit mit Web-Sockets 📄 👩🏼‍💻 😠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich versuchen, den engen Umfang der Technologie im Rahmen des Angular-Frameworks und seines bereits integrierten Assistenten -...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebSockets in Angular: Erstellen Sie einen Angular-Service für die Arbeit mit Web-Sockets</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416155/"><img src="https://habrastorage.org/webt/dz/-h/c_/dz-hc_la-a4emvhkqbd4ihr5zfe.jpeg" alt="Bild"><br>  In diesem Artikel werde ich versuchen, den engen Umfang der Technologie im Rahmen des Angular-Frameworks und seines bereits integrierten Assistenten - RxJs - detailliert zu behandeln, während wir bewusst nicht auf Server-Implementierungen eingehen, wie z  Dies ist ein vollwertiges Thema für einen separaten Artikel. <br><br>  Dieser Text ist nützlich für diejenigen, die bereits mit Angular vertraut sind, aber ihr Wissen direkt über das Thema vertiefen möchten. <br><a name="habracut"></a><br>  Zunächst einige grundlegende Informationen. <br><br><h2>  Was ist WebSocket und warum brauchen Sie es? </h2><br><blockquote>  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> ist WebSocket ein „Duplex-Kommunikationsprotokoll (es kann gleichzeitig senden und empfangen) über eine TCP-Verbindung, das für Echtzeitnachrichten zwischen einem Browser und einem Webserver entwickelt wurde. <br>  WebSocket ist für die Implementierung in Webbrowsern und Webservern konzipiert, kann jedoch für jeden Client oder jede Serveranwendung verwendet werden.  Das WebSocket-Protokoll ist ein unabhängiges Protokoll, das auf dem TCP-Protokoll basiert.  Es ermöglicht eine engere Interaktion zwischen dem Browser und der Website und erleichtert die Verteilung interaktiver Inhalte und die Erstellung von Echtzeitanwendungen. “ <br></blockquote><br>  Mit anderen Worten, WebSocket ermöglicht es dem Server, jederzeit Anforderungen vom Client zu empfangen und Anforderungen an den Client zu senden. Somit erhalten Browser (Client) und Server gleiche Rechte und die Möglichkeit, Nachrichten auszutauschen, wenn eine Verbindung besteht.  Eine reguläre AJAX-Anforderung erfordert die Übertragung vollständiger HTTP-Header, was einen erhöhten Datenverkehr in beide Richtungen bedeutet, während der Overhead von Web-Sockets nach dem Herstellen einer Verbindung nur zwei Byte beträgt.  Web Socket reduziert die Menge an Informationen, die in HTTP-Headern übertragen werden, um das Hunderttausende und reduziert die Wartezeit erheblich.  Web-Socket-Verbindungen unterstützen domänenübergreifende Funktionen wie CORS. <br><br>  Auf der Serverseite gibt es Pakete zur Unterstützung des Web-Sockets, auf dem Client die HTML5-WebSocket-API mit einer Schnittstelle von drei Methoden: <br><br>  <b><i>WebSocket</i></b> - die Hauptschnittstelle zum Herstellen einer Verbindung zu einem WebSocket-Server und zum Senden und Empfangen von Daten über die Verbindung; <br>  <b><i>CloseEvent</i></b> - ein Ereignis, das vom WebSocket-Objekt <b><i>ausgelöst wurde,</i></b> als die Verbindung geschlossen wurde; <br>  <b><i>MessageEvent</i></b> - Ein Ereignis, das von einem WebSocket <b><i>ausgelöst wird,</i></b> wenn eine Nachricht vom Server empfangen wird. <br><br>  So sieht es auf der JavaSript-Implementierungsebene aus: <br><br><pre><code class="plaintext hljs">const ws = new WebSocket("ws://www.example.com/socketserver", "protocolOne"); ws.onopen = () =&gt; { ws.onmessage = (event) =&gt; { console.log(event); } ws.send("Here's some text that the server is urgently awaiting!"); };</code> </pre> <br>  <b><i>onmessage</i></b> - Abhören von Nachrichten vom Server <br>  <b><i>Senden</i></b> - Senden Sie Ihre Nachrichten an den Server <br><br>  Das heißt, in seiner Grundform ist alles sehr einfach. Wenn Sie sich jedoch mit dem Thema befassen möchten, können Sie sich an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MDN-Webdokumente</a> wenden und gleichzeitig Bibliotheken studieren, die ihre eigenen Ebenen über dieser API implementieren. <br><br><h2>  Warum haben Sie keine Angst, WebSocket zu verwenden? </h2><br>  Der erste Punkt, der abschrecken kann, ist die <b>Browserunterstützung</b> .  Heute gibt es kein solches Problem - WebSocket wird sowohl im Web als auch im mobilen Segment fast vollständig unterstützt. <br><br><img src="https://habrastorage.org/webt/6q/kt/br/6qktbrrlnloyi0ec862v8qzclts.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/bn/pk/k5/bnpkk58xzozo2c9plnkgszfjnk4.png" alt="Bild"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://caniuse.com/#feat=websockets</a> <br><br>  Der zweite Punkt ist die <b>einfache Implementierung</b> .  Ja, das ist zunächst entmutigend. <br><br>  Die API ist so einfach, dass es auf den ersten Blick schwierig sein kann, zu verstehen, wie man mit einer so bescheidenen Anzahl von Methoden arbeitet, da alle außer einer entweder Fehler oder Verbindungen melden und nur eine von ihnen - <b><i>onmessage</i></b> - trägt für welche Web-Sockets verwendet werden, d.h.  um Daten vom Server zu empfangen. <br><br>  Gleichzeitig ist der Haken, dass der Server normalerweise unterschiedliche Daten sendet, daher benötigen wir mehrere unterschiedliche Nachrichten?  Oder müssen Sie für jedes Datenmodell eine eigene Verbindung erstellen? <br><br>  Also die Aufgabe: Sie müssen das Benutzermodell und das neueste Nachrichtenmodell vom Server akzeptieren, und vielleicht sogar etwas anderes. <br><br>  Ich bin auf eine so "elegante" Implementierung gestoßen: <br><br><pre> <code class="plaintext hljs">const wsUser = new WebSocket("ws://www.example.com/user"); wsUser.onmessage = (event) =&gt; { // ... }; const wsNews = new WebSocket("ws://www.example.com/news"); wsNews.onmessage = (event) =&gt; { // ... }; const wsTime = new WebSocket("ws://www.example.com/time"); wsTime.onmessage = (event) =&gt; { // ... }; const wsDinner = new WebSocket("ws://www.example.com/dinner"); wsDinner.onmessage = (event) =&gt; { // ... }; const wsCurrency = new WebSocket("ws://www.example.com/currency"); wsCurrency.onmessage = (event) =&gt; { // ... }; const wsOnline = new WebSocket("ws://www.example.com/online"); wsOnline.onmessage = (event) =&gt; { // ... }; const wsLogin = new WebSocket("ws://www.example.com/login"); wsLogin.onmessage = (event) =&gt; { // ... }; const wsLogout = new WebSocket("ws://www.example.com/logout"); wsLogout.onmessage = (event) =&gt; { // ... };</code> </pre> <br>  Auf den ersten Blick ist alles logisch.  Aber stellen Sie sich jetzt vor, wie es aussehen wird, wenn es Dutzende oder Hunderte von ihnen gibt.  Bei einem der Projekte, an denen ich gerade gearbeitet habe, gab es ungefähr dreihundert Veranstaltungen. <br><br><img src="https://habrastorage.org/webt/d3/rg/dl/d3rgdlp8eggnms2ot2ely5zktz8.jpeg" alt="Bild"><br><br>  Wir lösen das Problem. <br><br>  In allen Bibliotheken von Drittanbietern für die Arbeit mit Web-Sockets können Sie Nachrichten vom Typ addEventListener abonnieren.  Es sieht so aus: <br><br><pre> <code class="plaintext hljs">ws.on("user", (userData) =&gt; { / .. })</code> </pre> <br>  Wie wir wissen, können wir mit einer einzigen Methode arbeiten - <b><i>onmessage</i></b> , die alle Daten als Teil ihrer Verbindung empfängt, sodass dieser Code etwas ungewöhnlich aussieht.  Dies wird wie folgt implementiert: <b><i>onmessage</i></b> gibt ein <b><i>MessageEvent zurück</i></b> , das das <b><i>Datenfeld</i></b> enthält.  Es sind <b><i>Daten,</i></b> die die Informationen enthalten, die der Server an uns sendet.  Dieses Objekt sieht folgendermaßen aus: <br><br><pre> <code class="plaintext hljs">{ "event": "user", "data": { "name": "John Doe", ... } }</code> </pre> <br>  Dabei ist <b><i>Ereignis</i></b> der Schlüssel, mit dem bestimmt werden kann, welche Informationen der Server gesendet hat.  Als nächstes wird auf der Front-End-Seite ein Bus erstellt, der Informationen nach Ereignis filtert und an die gewünschte Adresse sendet: <br><br><pre> <code class="plaintext hljs">const ws = new WebSocket("ws://www.example.com"); ws.onmessage = (event) =&gt; { const data = JSON.parse(event.data); if (data.event === 'user') { // ... } if (data.event === 'news') { // ... } };</code> </pre> <br><br>  Auf diese Weise können verschiedene Daten innerhalb derselben Verbindung empfangen und über eine Syntax abonniert werden, die der für JS-Ereignisse üblichen ähnelt. <br><br><h2>  WebSockets in Angular </h2><br>  Schließlich kamen wir zum Wichtigsten - der Verwendung von WebSockets direkt in Angular. <br><br>  Trotz der Einfachheit der Arbeit mit der nativen WebSocket-API werden wir in diesem Artikel RxJs verwenden, was natürlich darauf zurückzuführen ist, dass es sich um Angular handelt. <br><br>  Die native WebSocket-API kann in Anwendungen auf Angular verwendet werden, eine benutzerfreundliche Oberfläche auf der Basis von RxJs Observable erstellen, die erforderlichen Nachrichten abonnieren usw., aber RxJs hat bereits die Hauptarbeit für Sie erledigt: WebSocketSubject ist ein reaktiver Wrapper über das Standard-WebSocket API  Es wird kein Ereignisbus erstellt oder die Verbindung erneut hergestellt.  Dies ist ein reguläres Thema, mit dem Sie mit reaktiven Web-Sockets arbeiten können. <br><br><h2>  RxJs WebSocketSubject </h2><br>  Daher erwartet <a href="">WebSocketSubject WebSocketSubjectConfig</a> und ein optionales Ziel, in dem Sie einen Link zu Ihrem beobachteten Betreff übergeben können, erstellt ein Observable, über das Sie Nachrichten für Web-Sockets abhören und senden können. <br><br>  Einfach ausgedrückt, Sie übergeben die Verbindungs-URL als WebSocketSubject-Argument und abonnieren alle Aktivitäten des Web-Sockets auf die für RxJs übliche Weise.  Wenn Sie eine Nachricht an den Server senden müssen, verwenden Sie dieselbe übliche Methode webSocketSubject.next (data). <br><br><h2>  Wir bieten einen Service für die Arbeit mit WebSocket Angular </h2><br>  Beschreiben Sie kurz, was wir vom Service erwarten: <br><br><ul><li>  Einheitliche und übersichtliche Oberfläche; </li><li>  Möglichkeit der Konfiguration auf Verbindungsebene von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DI-</a> Abhängigkeiten; </li><li>  Die Möglichkeit der Wiederverwendung; </li><li>  Tippen; </li><li>  Die Möglichkeit, sich anzumelden, um Informationen per Schlüssel zu erhalten; </li><li>  Möglichkeit, ein Abonnement zu kündigen; </li><li>  Senden von Nachrichten an den Server; </li><li>  Schließen Sie die Verbindung wieder an. </li></ul><br>  Der letzte Punkt ist besonders zu beachten.  Die erneute Verbindung oder die Organisation der erneuten Verbindung zum Server ist ein wichtiger Faktor bei der Arbeit mit Web-Sockets  Netzwerkbrüche, Serverabstürze oder andere Fehler, die einen Verbindungsbruch verursachen, können zum Absturz der Anwendung führen. <br><br>  Es ist wichtig zu beachten, dass Wiederverbindungsversuche <b>nicht zu häufig sein</b> und nicht auf unbestimmte Zeit fortgesetzt werden sollten  Dieses Verhalten kann den Client anhalten. <br><br>  Fangen wir an. <br><br>  Zunächst erstellen wir eine Service-Konfigurationsschnittstelle und ein Modul, das die Konfiguration bei Verbindung ermöglicht. <br><br>  Wenn möglich, werde ich den Code verkürzen, die Vollversion, die Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der russischsprachigen Angular-Community auf GitHub sehen können</a> . <br><br><pre> <code class="plaintext hljs">export interface WebSocketConfig { url: string; reconnectInterval?: number; reconnectAttempts?: number; } export class WebsocketModule { public static config(wsConfig: WebSocketConfig): ModuleWithProviders { return { ngModule: WebsocketModule, providers: [{ provide: config, useValue: wsConfig }] }; } }</code> </pre> <br>  Als nächstes müssen wir die Schnittstelle der Web-Socket-Nachricht beschreiben: <br><br><pre> <code class="plaintext hljs">export interface IWsMessage&lt;T&gt; { event: string; data: T; }</code> </pre> <br>  Dabei ist <b><i>Ereignis</i></b> der Schlüssel, und die vom Schlüssel erhaltenen <b><i>Daten</i></b> sind ein typisiertes Modell. <br><br>  Die öffentliche Schnittstelle des Dienstes sieht folgendermaßen aus: <br><br><pre> <code class="plaintext hljs">export interface IWebsocketService { on&lt;T&gt;(event: string): Observable&lt;T&gt;; send(event: string, data: any): void; status: Observable&lt;boolean&gt;; }</code> </pre> <br>  Service hat Felder: <br><br><pre> <code class="plaintext hljs">//   WebSocketSubject private config: WebSocketSubjectConfig&lt;IWsMessage&lt;any&gt;&gt;; private websocketSub: SubscriptionLike; private statusSub: SubscriptionLike; // Observable    interval private reconnection$: Observable&lt;number&gt;; private websocket$: WebSocketSubject&lt;IWsMessage&lt;any&gt;&gt;; // ,      private connection$: Observer&lt;boolean&gt;; //  Observable       private wsMessages$: Subject&lt;IWsMessage&lt;any&gt;&gt;; //       private reconnectInterval: number; //    private reconnectAttempts: number; //      private isConnected: boolean; //   public status: Observable&lt;boolean&gt;;</code> </pre> <br>  Im Konstruktor der Serviceklasse erhalten wir das WebSocketConfig-Objekt, das angegeben wurde, als das Modul verbunden wurde: <br><br><pre> <code class="plaintext hljs">constructor(@Inject(config) private wsConfig: WebSocketConfig) { this.wsMessages$ = new Subject&lt;IWsMessage&lt;any&gt;&gt;(); //  ,  ,     this.reconnectInterval = wsConfig.reconnectInterval || 5000; this.reconnectAttempts = wsConfig.reconnectAttempts || 10; //      connection$   websocket$ this.config = { url: wsConfig.url, closeObserver: { next: (event: CloseEvent) =&gt; { this.websocket$ = null; this.connection$.next(false); } }, //     connection$ openObserver: { next: (event: Event) =&gt; { console.log('WebSocket connected!'); this.connection$.next(true); } } }; // connection status this.status = new Observable&lt;boolean&gt;((observer) =&gt; { this.connection$ = observer; }).pipe(share(), distinctUntilChanged()); //      this.statusSub = this.status .subscribe((isConnected) =&gt; { this.isConnected = isConnected; if (!this.reconnection$ &amp;&amp; typeof(isConnected) === 'boolean' &amp;&amp; !isConnected) { this.reconnect(); } }); // ,  -    this.websocketSub = this.wsMessages$.subscribe( null, (error: ErrorEvent) =&gt; console.error('WebSocket error!', error) ); //  this.connect(); }</code> </pre> <br>  Die Verbindungsmethode selbst ist einfach: <br><br><pre> <code class="plaintext hljs">private connect(): void { this.websocket$ = new WebSocketSubject(this.config); //  //   ,    , //  ,  // ,    this.websocket$.subscribe( (message) =&gt; this.wsMessages$.next(message), (error: Event) =&gt; { if (!this.websocket$) { // run reconnect if errors this.reconnect(); } }); }</code> </pre> <br>  Das erneute Verbinden ist etwas komplizierter: <br><br><pre> <code class="plaintext hljs">private reconnect(): void { //  interval    reconnectInterval this.reconnection$ = interval(this.reconnectInterval) .pipe(takeWhile((v, index) =&gt; index &lt; this.reconnectAttempts &amp;&amp; !this.websocket$)); //     ,        this.reconnection$.subscribe( () =&gt; this.connect(), null, () =&gt; { // Subject complete if reconnect attemts ending this.reconnection$ = null; if (!this.websocket$) { this.wsMessages$.complete(); this.connection$.complete(); } }); }</code> </pre> <br>  Die <b><i>on-</i></b> Methode ist auch sehr einfach, es gibt nichts zu kommentieren. <br><br><pre> <code class="plaintext hljs">public on&lt;T&gt;(event: string): Observable&lt;T&gt; { if (event) { return this.wsMessages$.pipe( filter((message: IWsMessage&lt;T&gt;) =&gt; message.event === event), map((message: IWsMessage&lt;T&gt;) =&gt; message.data) ); } }</code> </pre> <br>  Die <b><i>Sendemethode</i></b> ist noch einfacher: <br><br><pre> <code class="plaintext hljs">public send(event: string, data: any = {}): void { if (event &amp;&amp; this.isConnected) { //   any ,   ""   string //      :) this.websocket$.next(&lt;any&gt;JSON.stringify({ event, data })); } else { console.error('Send error!'); } }</code> </pre> <br>  Das ist der ganze Service.  Wie Sie sehen können, fiel der Großteil des Codes auf die Organisation der erneuten Verbindung. <br><br>  Lassen Sie uns nun sehen, wie Sie es verwenden.  Schließen Sie das WebsocketModule-Modul an: <br><br><pre> <code class="plaintext hljs">imports: [ WebsocketModule.config({ url: environment.ws //      'ws://www.example.com' }) ]</code> </pre> <br>  Im Komponentenkonstruktor injizieren wir den Dienst und abonnieren Nachrichten von ' <b><i>Nachrichten</i></b> '. Senden Sie den Text zurück an den Server: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private wsService: WebsocketService) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsService.on&lt;IMessage[]&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'messages'</span></span></span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(messages: IMessage[]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(messages); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsService.send(<span class="hljs-string"><span class="hljs-string">'text'</span></span>, <span class="hljs-string"><span class="hljs-string">'Test Text!'</span></span>); }); }</code> </pre> <br>  Der Name der Ereignisse ist bequemer, um Konstanten oder eine Aufzählung einzugeben.  Wir erstellen irgendwo die Datei websocket.events.ts und schreiben sie hinein: <br><br><pre> <code class="plaintext hljs">export const WS = { ON: { MESSAGES: 'messages' }, SEND: { TEXT: 'text' } };</code> </pre> <br>  Schreiben Sie Abonnements mit dem erstellten WS-Objekt neu: <br><br><pre> <code class="plaintext hljs">this.wsService.on&lt;IMessage[]&gt;(WS.ON.MESSAGES) .subscribe((messages: IMessage[]) =&gt; { console.log(messages); this.wsService.send(WS.SEND.TEXT, 'Test Text!'); });</code> </pre> <br><img src="https://habrastorage.org/webt/zn/jz/k7/znjzk75iy2uudtgep2wr4u8djmk.jpeg" alt="Bild"><br><br><h2>  Abschließend </h2><br>  Das ist in der Tat alles.  Dies ist ein notwendiges Minimum, das ein Angular-Entwickler über WebSockets wissen muss.  Ich hoffe, dass ich dieses Thema ganz klar behandelt habe.  Die Vollversion des Dienstes finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> . <br><br>  Bei allen Fragen können Sie sich in den Kommentaren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">an mich</a> per Telegramm oder auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den dortigen Angular-Kanal</a> wenden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416155/">https://habr.com/ru/post/de416155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416143/index.html">Das Buch "Eine Autopsie wird zeigen!" Praktische Malware-Analyse »</a></li>
<li><a href="../de416147/index.html">Organisation der Navigation in iOS-Anwendungen mit dem Root Controller</a></li>
<li><a href="../de416149/index.html">Fragen und Antworten zu erneuerbaren Energien, Teil 1</a></li>
<li><a href="../de416151/index.html">Dimensionsloser Ballon. Utilitaristische Dimensionsanalyse Magie</a></li>
<li><a href="../de416153/index.html">Werden Flugzeuge zuverlässiger? Flugzeughersteller führen Roboter in Unternehmen ein</a></li>
<li><a href="../de416157/index.html">In den Armen von Python (nur für Frauen)</a></li>
<li><a href="../de416159/index.html">Wie wir beauftragt wurden, einen Igel mit einer Schlange zu vergleichen</a></li>
<li><a href="../de416161/index.html">10 Gründe, k8s nicht zu verwenden</a></li>
<li><a href="../de416163/index.html">Lerne OpenGL. Lektion 5.6 - Parallaxenzuordnung</a></li>
<li><a href="../de416167/index.html">Peter Norwig: Programmieren lernen in ... 10 Jahren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>