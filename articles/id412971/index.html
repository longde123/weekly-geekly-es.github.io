<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥐 👂🏽 🥜 Membuat aplikasi pewarnaan di Unity3D ☄️ 🏇 👃🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cerita ini dimulai pada malam musim semi yang sangat dingin, ketika pertanyaan muncul di benak: apakah ada cara untuk menentukan tingkat pengisian ben...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat aplikasi pewarnaan di Unity3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412971/"><img src="https://habrastorage.org/webt/1n/wt/6k/1nwt6kpf53h7tdyd_ez0-j3f5ds.jpeg" alt="gambar"><br><br>  Cerita ini dimulai pada malam musim semi yang sangat dingin, ketika pertanyaan muncul di benak: apakah ada cara untuk menentukan <b>tingkat pengisian bentuk geometris yang sewenang-wenang dengan cat</b> (yaitu, berapa persen yang saat ini dilukis)?  Ya, sehingga tidak hanya melambat, tetapi <i>terbang dengan kecepatan 60 fps</i> pada perangkat seluler terlemah. <br><br>  Bagi mereka yang tidak segera mengerti apa yang saya bicarakan, saya akan menjelaskan: pendekatan raster dimungkinkan untuk masalah, dan juga ... bukan pendekatan raster. <br><a name="habracut"></a><br>  Dalam kasus pertama, semuanya sederhana, topik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">isi banjir</a> dan algoritma terkait telah berhasil dipelajari dan diterapkan di <abbr title="Bahasa Pemrograman">YP</abbr> untuk setiap selera.  Ada array piksel yang harus diisi, ada perbatasannya.  Kami menghitung jumlah titik banjir, dibagi dengan jumlah total, dan voila - kami memiliki persentase yang dihargai di pintu keluar.  Tetapi - dengan sejumlah besar piksel (dan ppi pada perangkat modern Anda sendiri tahu yang mana), plus - jika ada banyak angka seperti itu, kami mengalami banyak perhitungan di setiap bingkai yang menyenangkan menghangatkan perangkat, tetapi bukan jiwa. <br><br>  Lagi pula, bekerja dengan raster sepertinya tidak sportif.  Tatapan itu berbalik ke tempat pembuangan sampah yang mahakuasa.  Beberapa jam yang menyenangkan dari pengkodean santai-persisten membuktikan hipotesis: Anda dapat menggunakan hal seperti " <i>warna titik</i> " - warna titik. <br><br><div class="spoiler">  <b class="spoiler_title">Sedikit tentang warna titik</b> <div class="spoiler_text">  Saluran informasi tambahan asli yang tersedia dalam struktur data segitiga adalah <i>mesh.colors yang</i> sama.  Secara teoritis, ini dapat digunakan untuk tujuan apa pun, tergantung pada apa yang tertulis dalam shader, tetapi dalam kasus ini, byte yang berharga akan menyimpan dengan tepat nilai pengisian warna saat ini untuk setiap titik.  Shadernya menggunakannya saat melakukan render, dan kemudian dengan Unity one material, Anda dapat membuat jerat multi-warna dalam jumlah tak terbatas dengan satu bahan untuk semua.  Hal yang paling menarik adalah bahwa nilai warna vertex diinterpolasi oleh perangkat keras di antara mereka sendiri, yang memungkinkan Anda membuat gradien cahaya. <br></div></div><br>  Saya pikir pantas menyebutkan mengapa persentase bayangan yang buruk, yang menjadi dasar artikel ini, dibutuhkan.  Gagasan utama aplikasi pewarnaan adalah sebagai berikut: gambar akhir terdiri dari satu set poligon.  Aplikasi akan <b>secara berurutan dan secara otomatis menghilangkan elemen pengguna dengan elemen</b> .  Dengan demikian, sampai Anda selesai mengecat satu bagian sampai akhir, Anda tidak akan melanjutkan ke yang berikutnya.  Keputusan semacam itu bagi saya tampak sangat elegan, menarik, dan mengingat dominasi global pewarnaan "piksel" dalam cerita-cerita itu, juga segar. <br><br><h1>  Langkah pertama </h1><br>  Tentu saja, untuk membuat pewarnaan yang lengkap, perlu menciptakan banyak solusi menarik.  Pertama-tama, saya ingin, untuk semua sifat poligonal dari aplikasi, pewarnaan dianggap sebagai yang paling raster, yaitu <b>cat harus menyebar di bawah jari</b> , dan memiliki tampilan yang kurang lebih realistis.  Persyaratan awal untuk kinerja maksimum tidak hilang di mana pun dan terus menggantung awan kumulus yang tangguh di seluruh proses. <br><br>  Langkah pertama adalah membuat <b>tessellation</b> manusia (memecah poligon besar yang terdiri dari seperangkat segitiga menjadi sekelompok stokastik segitiga kecil).  Lagipula, jika kita mendapatkan larik simpul dan menulis warna simpul di sana saat kita isi, kita dapat menentukan dengan bagian normal melalui larik apakah gambar itu benar-benar terisi dan potongan apa yang tetap tidak dicat - <i>mirip dengan algoritma piksel, tetapi dengan lebih banyak kebebasan</i> . <br><br><img src="https://habrastorage.org/webt/hd/ki/0c/hdki0cypjlbrmfhokpfho7y0qv4.jpeg" alt="gambar"><br><br>  Kemudian mulailah perjalanan yang mengasyikkan ke dunia shader.  Seperti yang Anda pahami, saya tidak dapat sepenuhnya menemukan semua penemuan dan rahasia, tetapi saya akan mengatakan bahwa dengan berinteraksi dengan peta kebisingan dan sinar sekolah lama memancarkan sinar Persatuan dari jari-jari saya, efek kuas tercapai, dan bahkan dengan beberapa penyebaran cat di sepanjang segitiga yang berdekatan dengan jari.  Menggunakan warna titik memungkinkan untuk mengeluarkan dengan <b>satu bahan Unity</b> pada semua bagian komponen dari gambar dan karenanya menarik panggilan dalam program jadi tidak melebihi 5-7 (tergantung pada keberadaan menu dan partikel). <br><br>  Pukulan itu dibuat oleh Unity Line Renderer yang biasa, yang dengan curang merusak beberapa figur, bergerak keluar dan menunjukkan kelemahan pada sendi.  Ini tidak dapat dikalahkan, oleh karena itu, tugas prioritas adalah menulis ulang komponen dari awal.  Sidik jari juga merupakan Trail Renderer standar, tetapi shadernya menggunakan z-check sehingga elemen jejak tidak tumpang tindih, menciptakan artefak yang jelek.  Tekstur "kotak-kotak" latar belakang membantu, antara lain, <b>untuk mengevaluasi ukuran elemen yang dicat</b> : semakin besar, semakin kecil ukuran selnya. <br><br><img src="https://habrastorage.org/webt/tq/oa/-3/tqoa-3wwdoc-fg23wqk_mcgnpqc.gif" alt="gambar"><br><br><h1>  Fungsi tidak diharapkan </h1><br>  Selama pengujian, ternyata seringkali di suatu tempat di sudut-sudut gambar terdapat puncak kosong, yang sulit ditentukan secara visual.  Terlepas dari kenyataan bahwa pemicu untuk beralih ke elemen berikutnya bekerja ketika level pengisian 97%, situasinya adalah “ <i>apa yang harus dilakukan selanjutnya?</i>  »- dengan tingkat hunian dari 90% hingga 97% - mereka cukup sering muncul dan membingungkan pengguna (yang pada dasarnya berusia tidak lebih dari 12 tahun).  Saya tidak ingin menetapkan pemicu kurang dari 97%, karena saat itu efek " <i>Saya belum menyelesaikannya, tetapi sudah melompat</i> " muncul. <br><br>  Jadi saya dengan enggan bertemu <b>Madame Clusterization</b> .  Bayangkan: poligon, sekelompok titik di dalam, ada beberapa yang "istimewa", kadang-kadang secara terpisah, kadang-kadang dalam kelompok.  Penting untuk menemukan dan menunjuk “kelompok” terbesar.  Ini adalah masalah matematika yang umum.  Tidak ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma tradisional yang</a> saya temukan muncul karena berbagai alasan, saya harus melakukannya sendiri.  Retas pada retasan, tetapi berhasil - dan area yang tidak dicat mulai menonjol dalam lingkaran dinamis yang indah.  Untuk mengoptimalkan, algoritme ini berfungsi setiap 3 detik, dan hanya setelah pengguna bingung mengangkat jari dari layar dengan gaya "apa yang harus dilakukan selanjutnya".  Terlihat sangat organik. <br><br><img src="https://habrastorage.org/webt/h_/qc/-d/h_qc-dlrdx_2aqol8nbqioqivzq.gif" alt="gambar"><br><br>  Setelah brainstorming seperti itu, untuk membuat <b>"garis pewarnaan" yang</b> bervariasi sesuai dengan persyaratan para penguji - yaitu, untuk memberi pengguna kesempatan untuk memilih dalam urutan apa ia ingin mewarnai elemen - adalah masalah satu malam.  Yang Anda butuhkan adalah menentukan pusat geometri dari setiap mesh dan membangunnya sesuai kebutuhan: dari kiri ke kanan, dari atas ke bawah, dll. Untuk kejelasan yang lebih besar, partikel diimplementasikan pada latar belakang, yang menunjukkan arah antrian. <br><br><div class="spoiler">  <b class="spoiler_title">Ilustrasi antrian</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vg/kt/ij/vgktijp2haaqb6ij0gi6jemuqjo.gif" alt="gambar"><br><br>  Antrian default ditampilkan di sini (sesuai keinginan artis).  Jika Anda mengaktifkan mode " <i>belokan demi belokan</i> " dengan mengklik salah satu tombol di bawah ini, antrian pewarnaan akan berubah, dan partikel-partikel akan bergerak ke arah yang ditunjukkan. <br></div></div><br><h1>  UX &amp; UI </h1><br>  Saya umumnya menyukai gagasan otomatisme terkontrol dalam aplikasi, dan oleh karena itu setiap elemen dipusatkan dan diskalakan sehingga dapat dicat dengan jari Anda <b>tanpa harus menggulir layar</b> .  Kerugian dari pendekatan ini adalah bahwa tidak selalu jelas bagian mana dari sosok itu sekarang di layar.  Ternyata, pengguna bahkan menyukai tantangan sekecil itu, karena melatih memori jangka pendek dan korelasi informasi - Anda perlu mengingat gambaran besarnya.  Nah, ada dua cara untuk sampai ke "pandangan sekilas sosok" - dengan gerakan mencubit atau dengan menekan tombol zoom. <br><br><img src="https://habrastorage.org/webt/9_/ej/ic/9_ejic4dyydfoljrxzxdqjl9xos.gif" alt="gambar"><br><br>  Mengikuti aturan-aturan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Antarmuka Apple</a> , diputuskan untuk mengurangi jumlah tombol di layar seminimal mungkin.  Selain tombol <b>zoom masuk / keluar</b> dan tombol keluar yang jelas di menu, ada juga panggilan palet - Anda dapat melukis sebagai warna "default" yang ditetapkan oleh artis, atau pilihan Anda. <br><br>  Selain itu, dalam mode "mata burung", Anda dapat mengubah gradien latar belakang (setiap klik dihasilkan secara acak) atau masuk ke mode "mengecat", yang memungkinkan Anda untuk memperbaiki elemen yang sudah dicat.  Ya, saya harus menyembunyikan fungsi ini, tetapi ini dibenarkan - untuk semua pengujian, tidak ada yang pernah bertanya bagaimana melakukannya. <br><br><h4>  Tentang palet </h4><br>  Palet itu sendiri diulang dua kali.  Pada awalnya, saya hanya menempatkan sejumlah kotak dengan warna di layar, tetapi pengguna meminta lebih banyak warna.  Saya tidak ingin menggulir di antarmuka, dan skema <b>"warna-warna"</b> muncul, yaitu, pertama pengguna memilih warna dasar dengan menekan, dan kemudian salah satu warnanya.  Palet dihapus dengan tombol atau memaksakan ke bawah.  Selain itu, ketika muncul di layar, ruang kerja artis berkurang 1/3, yang mengharuskan "penskalaan" gambar saat ini ke ukuran viewport yang diubah. <br><br><img src="https://habrastorage.org/webt/-b/7l/mc/-b7lmcif2fozsmqquhrifrisyqo.gif" alt="gambar"><br><br><h1>  Untuk manis </h1><br>  Tautan yang kurang penting dalam keseluruhan gambar adalah <b>hadiah</b> - semacam hadiah psikologis visual yang diterima pengguna setelah menyelesaikan proses pewarnaan.  Idenya <s>dimata-matai</s> di permukaan: sosok itu dilukis secara otomatis dan baru, dalam mode dipercepat, dan persis seperti yang dilakukan pengguna - dengan kata lain, <b>timelapse selama 15-20 detik</b> .  Ini diimplementasikan dengan merekam urutan di mana pengguna menyentuh simpul angka-angka, dan kemudian memainkan data ini dalam bentuk "memberi makan" mesin gambar dengan penundaan (melalui coroutine).  Setiap mesh digandakan beberapa kali untuk mencapai efek "manifestasi" dan "redaman". <br><br><img src="https://habrastorage.org/webt/1m/q7/dg/1mq7dg-rgkjl0r5hamxlci7vq94.gif" alt="gambar"><br><br>  Tentu saja, timelapse selama pemutaran <b>direkam dalam file video</b> , dan setelah ekstravaganza visual, pengguna diminta untuk menyimpan / berbagi karya yang baru dibuat.  Untungnya, tepat di musim semi, sebuah plugin muncul di Asset Store yang memungkinkan Anda untuk mengambil video multi-platform sepenuhnya dari layar (setelah beberapa konfigurasi), karena menulis alat seperti itu dari awal jauh melampaui kemampuan pemrograman saya, <s>tetapi secara umum saya seorang desainer</s> . <br><br><div class="spoiler">  <b class="spoiler_title">Alih-alih sebuah kesimpulan</b> <div class="spoiler_text">  Tentang ini seribu kata yang saya bagikan untuk tujuan pertama.  Pada bagian berikut, direncanakan untuk menceritakan tentang pertempuran heroik dengan Unity UI ketika mengembangkan bagian kedua dari aplikasi - menu untuk memilih gambar, serta untuk menghitung gundukan ramai dalam bisnis keras ASO. <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412971/">https://habr.com/ru/post/id412971/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412959/index.html">Untuk pertanyaan tentang AVR dan rekor dunia</a></li>
<li><a href="../id412961/index.html">Berbagi ekonomi dalam telekomunikasi</a></li>
<li><a href="../id412963/index.html">Fallout Baru: Apa yang diketahui tentang Vault 76?</a></li>
<li><a href="../id412967/index.html">Membuat widget penyesuaian kecerahan yang bagus</a></li>
<li><a href="../id412969/index.html">Sistem pengenalan wajah muncul di sekolah-sekolah AS, tetapi efektivitasnya dipertanyakan</a></li>
<li><a href="../id412975/index.html">Tombol smartphone pada 2018</a></li>
<li><a href="../id412977/index.html">Ketidakpuasan membatalkan tingkat kebahagiaan: mengapa tidak mungkin untuk bahagia sepanjang waktu</a></li>
<li><a href="../id412979/index.html">Tanya Ethan: jika dark matter ada di mana-mana, mengapa kita tidak menemukannya di tata surya?</a></li>
<li><a href="../id412983/index.html">Tur Insider Dev: siaran langsung</a></li>
<li><a href="../id412985/index.html">Revolusi pesan instan? UE mengusulkan untuk memperkenalkan undang-undang tentang standar perpesanan terpadu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>