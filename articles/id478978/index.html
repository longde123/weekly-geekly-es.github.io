<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏻 💅🏽 🏚️ Azure SDK untuk .NET: Kisah tentang Pencarian Kesalahan yang Sulit 👋🏾 🦉 ⏸️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika kami memutuskan untuk mencari kesalahan di Azure SDK untuk proyek .NET, kami sangat terkejut dengan ukurannya. "Tiga setengah juta baris kode,"...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Azure SDK untuk .NET: Kisah tentang Pencarian Kesalahan yang Sulit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/478978/"><p><img src="https://habrastorage.org/getpro/habr/post_images/1d1/893/6e4/1d18936e4455beb69c69b410bbfd10f6.png" alt="Gambar 2" align="left"></p><br>  Ketika kami memutuskan untuk mencari kesalahan di Azure SDK untuk proyek .NET, kami sangat terkejut dengan ukurannya.  "Tiga setengah juta baris kode," kami terus berkata, mempelajari statistik proyek.  Mungkin ada begitu banyak temuan.  Aduh dan mundur!  Proyek itu ternyata licik.  Jadi apa semangat proyek dan bagaimana diperiksa - baca di artikel ini. <br><a name="habracut"></a><br><h2>  Tentang proyek </h2><br>  Saya menulis artikel ini menindaklanjuti yang sebelumnya, yang juga tentang proyek yang berkaitan dengan Microsoft Azure: <a href="https://www.viva64.com/en/b/0678/">Azure PowerShell: Kebanyakan Tidak Berbahaya</a> .  Jadi, kali ini saya bertaruh pada sejumlah kesalahan yang beragam dan menarik.  Bagaimanapun, ukuran proyek adalah faktor yang sangat penting dalam hal analisis statis, khususnya ketika memeriksa proyek untuk pertama kalinya.  Bahkan, dalam praktiknya, aplikasi pemeriksaan satu kali bukan pendekatan yang tepat.  Namun demikian, jika pengembang mendukungnya, itu hanya terjadi pada tahap pengantar analisa.  Pada saat yang sama, tidak ada seorang pun yang berhasil memilah-milah sejumlah besar peringatan dan hanya menghapusnya sebagai hutang teknis menggunakan mekanisme penekan peringatan massal dan menyimpannya di pangkalan-pangkalan khusus.  Omong-omong, memiliki sejumlah besar peringatan baik-baik saja ketika menjalankan analisa untuk pertama kalinya.  Adapun kami, kami pergi untuk pemeriksaan satu kali untuk tujuan penelitian.  Untuk alasan ini, proyek besar selalu lebih disukai untuk analisis berikut dibandingkan dengan yang kecil. <br><br>  Namun, Azure SDK untuk proyek .NET segera terbukti menjadi test bed yang tidak dapat dijalankan.  Bahkan ukurannya yang mengesankan tidak membantu, tetapi agak rumit mengerjakannya.  Alasannya diberikan dalam statistik proyek berikut: <br><br><ul><li>  File sumber .cs (tidak termasuk tes): 16.500 </li><li>  Solusi Visual Studio (.sln): 163 </li><li>  Baris kode yang tidak kosong: 3 462 000 </li><li>  Dari yang dihasilkan secara otomatis ini: sekitar 3.300.000 </li><li>  Repositori proyek tersedia di <a href="https://github.com/Azure/azure-sdk-for-net">GitHub</a> . </li></ul><br>  Sekitar 95% kode dihasilkan secara otomatis, dan banyak dari kode itu diulang berkali-kali.  Memeriksa proyek-proyek seperti itu dengan analisa statis biasanya memakan waktu dan tidak berguna, karena ada banyak yang bisa diterapkan, tetapi tidak logis (setidaknya pada pandangan pertama) dan kode berlebihan.  Ini mengarah pada sejumlah besar kesalahan positif. <br><br>  Semua jumlah kode yang tersebar di 163 solusi Visual Studio menjadi "cherry on top".  Butuh beberapa upaya untuk memeriksa kode yang tersisa (tidak dihasilkan secara otomatis).  Apa yang benar-benar membantu adalah kenyataan bahwa semua kode yang dibuat secara otomatis disimpan dalam subdirektori solusi oleh jalur relatif "&lt;Direktori solusi&gt; \ src \ Generated".  Juga setiap file .cs dari jenis tersebut berisi komentar khusus dalam tag <i>&lt;auto-generated&gt;</i> : <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// &lt;auto-generated&gt; // Copyright (c) Microsoft Corporation. All rights reserved. // Licensed under the MIT License. See License.txt in the project root for // license information. // // Code generated by Microsoft (R) AutoRest Code Generator. // Changes may cause incorrect behavior and will be lost if the code is // regenerated. // &lt;/auto-generated&gt;</span></span></code> </pre> <br>  Untuk kemurnian percobaan, saya memeriksa sekitar sepuluh solusi yang dibuat secara acak secara acak.  Saya akan ceritakan hasilnya nanti. <br><br>  Jadi, meskipun jumlah kode “jujur” yang tersisa sedikit, saya masih berhasil menemukan sejumlah kesalahan dari yang tersisa.  Kali ini saya tidak akan mengutip peringatan dalam urutan kode diagnostik PVS-Studio.  Sebagai gantinya, saya akan mengelompokkan pesan pada solusi yang mereka temukan. <br><br>  Baiklah, mari kita lihat apa yang berhasil saya temukan di Azure SDK untuk kode .NET. <br><br><h2>  Microsoft.Azure.Management.Advisor </h2><br>  Ini adalah salah satu dari banyak solusi yang berisi kode yang dibuat secara otomatis.  Seperti yang saya katakan sebelumnya, saya secara acak memeriksa sekitar selusin solusi semacam itu.  Dalam setiap kasus, peringatan sama, dan, seperti yang diharapkan, tidak berguna.  Berikut ini beberapa contohnya. <br><br>  Ekspresi <a href="https://www.viva64.com/en/w/v3022/">V3022</a> 'Kredensial! = Null' selalu benar.  AdvisorManagementClient.cs 204 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Code generated by Microsoft (R) AutoRest Code Generator. .... public ServiceClientCredentials Credentials { get; private set; } .... public AdvisorManagementClient(ServiceClientCredentials credentials, params DelegatingHandler[] handlers) : this(handlers) { if (credentials == null) { throw new System.ArgumentNullException("credentials"); } Credentials = credentials; if (Credentials != null) // &lt;= { Credentials.InitializeServiceClient(this); } }</span></span></code> </pre> <br>  Jelas, kode ini berlebihan dan <i>Kredensial! =</i> Pemeriksaan <i>kosong</i> tidak ada gunanya.  Namun demikian, kodenya berfungsi.  Dan dihasilkan secara otomatis.  Untuk alasan ini, tidak ada keluhan di sini. <br><br>  Ekspresi <a href="https://www.viva64.com/en/w/v3022/">V3022</a> '_queryParameters.Count&gt; 0' selalu salah.  ConfigurationsOperations.cs 871 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Code generated by Microsoft (R) AutoRest Code Generator. .... public async Task&lt;AzureOperationResponse&lt;IPage&lt;ConfigData&gt;&gt;&gt; ListBySubscriptionNextWithHttpMessagesAsync(....) { .... List&lt;string&gt; _queryParameters = new List&lt;string&gt;(); if (_queryParameters.Count &gt; 0) { .... } .... }</span></span></code> </pre> <br>  Sekali lagi, ini tampak seperti konstruksi yang tidak logis.  Untuk beberapa alasan, pembuat kode memeriksa ukuran daftar <i>kosong yang</i> baru dibuat.  Padahal, itu semua benar.  Pada titik ini, cek tidak masuk akal, tetapi jika pengembang menambahkan daftar generasi, misalnya, berdasarkan koleksi lain, cek pasti akan bernilai sementara.  Lagi - tidak ada klaim kode, tentu saja, berkaitan dengan asalnya. <br><br>  Ratusan peringatan serupa telah dikeluarkan untuk setiap solusi yang dibuat secara otomatis.  Mengingat kesia-siaan mereka, saya pikir tidak ada gunanya membahas lebih lanjut kasus-kasus seperti itu.  Selanjutnya, hanya kesalahan nyata dalam kode "normal" yang akan dipertimbangkan. <br><br><h2>  Azure. Skor </h2><br>  <a href="https://www.viva64.com/en/w/v3001/">V3001</a> Ada sub-ekspresi identik 'buffer.Length' ke kiri dan ke kanan operator '&lt;'.  AzureBaseBuffersExtensions.cs 30 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...., ReadOnlyMemory&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; buffer, ....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]? array = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || buffer.Length &lt; buffer.Length) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if (array != null) ArrayPool&lt;byte&gt;.Shared.Return(array); array = ArrayPool&lt;byte&gt;.Shared.Rent(buffer.Length); } if (!buffer.TryCopyTo(array)) throw new Exception("could not rent large enough buffer."); .... }</span></span></code> </pre> <br>  Kesalahan dalam kondisi itu mungkin hasil dari copy-paste.  Menurut fakta bahwa <i>buffer</i> disalin dalam <i>array</i> , cek akan terlihat seperti: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || array.Length &lt; buffer.Length)</code> </pre> <br>  Lagi pula, seperti yang selalu saya katakan, pembuat kode harus berurusan dengan memperbaiki kesalahan tersebut. <br><br>  <a href="https://www.viva64.com/en/w/v3083/">V3083</a> Doa yang tidak aman dari acara '_onChange', NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  ClientOptionsMonitor.cs 44 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;TOptions, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; _onChange; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_onChange != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _onChange.Invoke(options, name); } }</code> </pre> <br>  Tidak kritis, tetapi ada kesalahan di sini.  Konsumen mungkin berhenti berlangganan dari acara antara memeriksa acara untuk <i>nol</i> dan permintaannya.  Kemudian variabel <i>_onChange</i> akan menjadi <i>nol</i> dan pengecualian akan dibuang.  Kode ini harus ditulis ulang dengan cara yang lebih aman.  Misalnya, sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... _onChange?.Invoke(options, name); }</code> </pre> <br><h2>  Azure.Messaging.EventHubs </h2><br>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'eventPropertyValue'.  AmqpMessageConverter.cs 650 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryCreateEventPropertyForAmqpProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amqpPropertyValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventPropertyValue</span></span></span><span class="hljs-function">)</span></span> { eventPropertyValue = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GetTypeIdentifier(amqpPropertyValue)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AmqpProperty.Type.Byte: .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AmqpProperty.Type.String: eventPropertyValue = amqpPropertyValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... } .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (amqpPropertyValue) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AmqpSymbol symbol: eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] array: eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ArraySegment&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; segment when segment.Count == segment.Array.Length: eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ArraySegment&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; segment: .... eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> DescribedType described </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">when</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">described.Descriptor </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AmqpSymbol</span></span></span><span class="hljs-function">): eventPropertyValue</span></span> = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exception = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationException( <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(...., eventPropertyValue.GetType().FullName)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return (eventPropertyValue != null); }</span></span></code> </pre> <br>  Mari kita lihat apa yang terjadi dengan nilai variabel <i>eventPropertyValue</i> dalam fragmen kode yang diberikan.  Variabel diberikan <i>nol</i> pada awal metode.  Selanjutnya, dalam salah satu kondisi <i>sakelar</i> pertama, variabel diinisialisasi, setelah itu metode keluar.  Blok <i>switch</i> kedua berisi banyak kondisi, di mana masing-masing variabel juga menerima nilai baru.  Sedangkan di blok <i>default</i> , variabel <i>eventPropertyValue</i> digunakan tanpa centang, yang merupakan kesalahan, karena variabelnya <i>nol</i> pada saat ini. <br><br>  <a href="https://www.viva64.com/en/w/v3066/">V3066</a> Kemungkinan urutan argumen yang salah diteruskan ke konstruktor 'EventHubConsumer': 'partisiId' dan 'consumerGroup'.  TrackOneEventHubClient.cs 394 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> EventHubConsumer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateConsumer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHubConsumer ( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TrackOneEventHubConsumer(....), TrackOneClient.EventHubName, partitionId, <span class="hljs-comment"><span class="hljs-comment">// &lt;= 3 consumerGroup, // &lt;= 4 eventPosition, consumerOptions, initialRetryPolicy ); }</span></span></code> </pre> <br>  Penganalisa curiga urutan argumen ketiga dan keempat saat memanggil konstruktor kelas <i>EventHubConsumer</i> .  Jadi mari kita periksa deklarasi konstruktor ini: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventHubConsumer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TransportEventHubConsumer transportConsumer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventHubName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> consumerGroup, // &lt;= </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> partitionId, // &lt;= </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EventPosition eventPosition, EventHubConsumerOptions consumerOptions, EventHubRetryPolicy retryPolicy</span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre> <br>  Memang, argumen tercampur aduk.  Saya berani menyarankan bagaimana kesalahan itu dibuat.  Mungkin, salah memformat kode adalah kesalahan di sini.  Lihat lagi deklarasi konstruktor <i>EventHubConsumer</i> .  Karena fakta bahwa parameter <i>transportConsumer</i> pertama berada di baris yang sama dengan nama kelas, mungkin tampak bahwa parameter partisiId berada di tempat ketiga, bukan yang keempat (komentar saya dengan nomor parameter tidak tersedia dalam kode asli) .  Itu hanya dugaan, tetapi saya akan mengubah pemformatan kode konstruktor sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventHubConsumer</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> TransportEventHubConsumer transportConsumer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventHubName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> consumerGroup, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> partitionId, EventPosition eventPosition, EventHubConsumerOptions consumerOptions, EventHubRetryPolicy retryPolicy</span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre> <br><h2>  Azure. Penyimpanan </h2><br>  <a href="https://www.viva64.com/en/w/v3112/">V3112</a> Kelainan dalam perbandingan serupa.  Mungkin salah ketik ada di dalam ekspresi 'ContentLanguage == other.ContentEncoding'.  BlobSasBuilder.cs 410 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BlobSasBuilder : IEquatable&lt;BlobSasBuilder&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BlobSasBuilder other</span></span></span><span class="hljs-function">)</span></span> =&gt; BlobName == other.BlobName &amp;&amp; CacheControl == other.CacheControl &amp;&amp; BlobContainerName == other.BlobContainerName &amp;&amp; ContentDisposition == other.ContentDisposition &amp;&amp; ContentEncoding == other.ContentEncoding &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// &lt;= ContentLanguage == other.ContentEncoding &amp;&amp; // &lt;= ContentType == other.ContentType &amp;&amp; ExpiryTime == other.ExpiryTime &amp;&amp; Identifier == other.Identifier &amp;&amp; IPRange == other.IPRange &amp;&amp; Permissions == other.Permissions &amp;&amp; Protocol == other.Protocol &amp;&amp; StartTime == other.StartTime &amp;&amp; Version == other.Version; }</span></span></code> </pre> <br>  Sebuah kesalahan yang dilakukan karena kurangnya perhatian.  Menemukan kesalahan dengan ulasan kode cukup sulit.  Ini versi kode yang benar: <br><br><pre> <code class="cs hljs"> .... ContentEncoding == other.ContentEncoding &amp;&amp; ContentLanguage == other.ContentLanguage &amp;&amp; ....</code> </pre> <br>  <a href="https://www.viva64.com/en/w/v3112/">V3112</a> Kelainan dalam perbandingan serupa.  Mungkin salah ketik ada di dalam ekspresi 'ContentLanguage == other.ContentEncoding'.  FileSasBuilder.cs 265 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> FileSasBuilder : IEquatable&lt;FileSasBuilder&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FileSasBuilder other</span></span></span><span class="hljs-function">)</span></span> =&gt; CacheControl == other.CacheControl &amp;&amp; ContentDisposition == other.ContentDisposition &amp;&amp; ContentEncoding == other.ContentEncoding <span class="hljs-comment"><span class="hljs-comment">// &lt;= &amp;&amp; ContentLanguage == other.ContentEncoding // &lt;= &amp;&amp; ContentType == other.ContentType &amp;&amp; ExpiryTime == other.ExpiryTime &amp;&amp; FilePath == other.FilePath &amp;&amp; Identifier == other.Identifier &amp;&amp; IPRange == other.IPRange &amp;&amp; Permissions == other.Permissions &amp;&amp; Protocol == other.Protocol &amp;&amp; ShareName == other.ShareName &amp;&amp; StartTime == other.StartTime &amp;&amp; Version == other.Version ;</span></span></code> </pre> <br>  Ada kesalahan yang persis sama dalam bagian kode yang sangat mirip.  Kode mungkin telah disalin dan sebagian diubah.  Namun kesalahan tetap ada. <br><br><h2>  Microsoft.Azure.Batch </h2><br>  <a href="https://www.viva64.com/en/w/v3053/">V3053</a> Ekspresi yang berlebihan.  Periksa substring 'IList' dan 'List'.  PropertyData.cs 157 <br><br>  <a href="https://www.viva64.com/en/w/v3053/">V3053</a> Ekspresi yang berlebihan.  Periksa substring 'Daftar' dan 'IReadOnlyList'.  PropertyData.cs 158 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PropertyData</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsTypeCollection =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"IList"</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"IEnumerable"</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"List"</span></span>) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= this.Type.Contains("IReadOnlyList"); // &lt;= }</span></span></code> </pre> <br>  Penganalisa mengeluarkan dua peringatan tentang cek tidak berguna atau salah.  Dalam kasus pertama, mencari substring "Daftar" setelah mencari "IList" tampak berlebihan.  Memang benar, kondisi ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"IList"</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"List"</span></span>)</code> </pre> <br>  dapat diubah dengan baik untuk yang berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"List"</span></span>)</code> </pre> <br>  Dalam kasus kedua, pencarian untuk substring "IReadOnlyList" tidak ada gunanya, karena sebelumnya substring yang lebih pendek "List" dicari. <br><br>  Ada juga kemungkinan bahwa substring pencarian sendiri memiliki kesalahan dan harus ada sesuatu yang lain.  Bagaimanapun, hanya pembuat kode yang menyarankan versi kode yang benar dengan mempertimbangkan kedua komentar. <br><br>  <a href="https://www.viva64.com/en/w/v3095/">V3095 Objek</a> 'httpRequest.Content.Headers' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 76, 79. BatchSharedKeyCredential.cs 76 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessHttpRequestAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HttpRequestMessage httpRequest, ....</span></span></span><span class="hljs-function">)</span></span> { .... signature.Append(httpRequest.Content != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; httpRequest.Content.Headers.Contains(<span class="hljs-string"><span class="hljs-string">"Content-Language"</span></span>) ? .... : ....; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>? contentLength = httpRequest.Content?.Headers?.ContentLength; .... }</code> </pre> <br>  Variabel <i>httpRequest.Content.Headers</i> pertama kali digunakan tanpa pemeriksaan, tetapi kemudian diatasi menggunakan operator akses bersyarat. <br><br>  <a href="https://www.viva64.com/en/w/v3125/">V3125 Objek</a> 'omPropertyData' digunakan setelah diverifikasi terhadap null.  Periksa baris: 156, 148. CodeGenerationUtilities.cs 156 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProtocolCollectionToObjectModelCollectionString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ...., PropertyData omPropertyData, ....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsMappedEnumPair(omPropertyData?.GenericTypeParameter, ....)) { .... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsTypeComplex(omPropertyData.GenericTypeParameter)) .... }</code> </pre> <br>  Dan ini adalah situasi sebaliknya.  Satu blok kode berisi varian akses aman ke <i>omPropertyData yang</i> berpotensi menjadi referensi nol.  Lebih lanjut dalam kode, referensi ini ditangani tanpa pemeriksaan. <br><br>  <a href="https://www.viva64.com/en/w/v3146/">V3146</a> Kemungkinan nol dereferensi 'nilai'.  'FirstOrDefault' dapat mengembalikan nilai nol default.  BatchSharedKeyCredential.cs 127 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessHttpRequestAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpRequestMessage httpRequest, ....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> canonicalHeader <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> customHeaders) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = httpRequest.Headers. GetValues(canonicalHeader).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Replace(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).Replace(<span class="hljs-string"><span class="hljs-string">'\r'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).TrimStart(); .... } .... }</code> </pre> <br>  Karena metode <i>FirstOrDefault</i> , jika pencarian gagal, nilai default akan dikembalikan, yang merupakan <i>nol</i> untuk tipe <i>string</i> .  Nilai akan ditetapkan ke variabel <i>nilai</i> , yang kemudian digunakan dalam kode dengan metode <i>Ganti</i> tanpa pemeriksaan apa pun.  Kode harus dibuat lebih aman.  Misalnya, sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> canonicalHeader <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> customHeaders) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = httpRequest.Headers. GetValues(canonicalHeader).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>?.Replace(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).Replace(<span class="hljs-string"><span class="hljs-string">'\r'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).TrimStart(); .... }</code> </pre> <br><h2>  Microsoft.Azure.ServiceBus </h2><br>  <a href="https://www.viva64.com/en/w/v3121/">V3121 Enumerasi</a> 'BlocksUsing' dideklarasikan dengan atribut 'Flags', tetapi tidak mengatur inisialisasi apa pun untuk mengesampingkan nilai default.  Fx.cs 69 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Fx</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tag</span></span> { .... [Flags] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BlocksUsing { MonitorEnter, MonitorWait, ManualResetEvent, AutoResetEvent, AsyncResult, IAsyncResult, PInvoke, InputQueue, ThreadNeutralSemaphore, PrivatePrimitive, OtherInternalPrimitive, OtherFrameworkPrimitive, OtherInterop, Other, NonBlocking, } .... } .... }</code> </pre> <br>  Enumerasi dideklarasikan dengan atribut <i>Flags</i> .  Pada saat yang sama, nilai-nilai konstan dibiarkan secara default ( <i>MonitorEnter = 0</i> , <i>MonitorWait = 1</i> , <i>ManualResetEvent = 2</i> dan seterusnya).  Ini dapat menghasilkan kasus berikut: ketika mencoba menggunakan kombinasi bendera, misalnya, konstanta kedua dan ketiga <i>MonitorWait (= 1)</i> |  <i>ManualResetEvent (= 2)</i> , bukan nilai unik yang akan diterima, tetapi konstan dengan nilai 3 secara default <i>(AutoResetEvent</i> ).  Ini mungkin mengejutkan bagi kode penelepon.  Jika enumerasi <i>BlocksUsing</i> benar-benar digunakan untuk mengatur kombinasi flags (bidang bit), konstanta harus diberi nilai, sama dengan angka yang merupakan kekuatan dua. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Flags</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BlocksUsing { MonitorEnter = <span class="hljs-number"><span class="hljs-number">1</span></span>, MonitorWait = <span class="hljs-number"><span class="hljs-number">2</span></span>, ManualResetEvent = <span class="hljs-number"><span class="hljs-number">4</span></span>, AutoResetEvent = <span class="hljs-number"><span class="hljs-number">8</span></span>, AsyncResult = <span class="hljs-number"><span class="hljs-number">16</span></span>, IAsyncResult = <span class="hljs-number"><span class="hljs-number">32</span></span>, PInvoke = <span class="hljs-number"><span class="hljs-number">64</span></span>, InputQueue = <span class="hljs-number"><span class="hljs-number">128</span></span>, ThreadNeutralSemaphore = <span class="hljs-number"><span class="hljs-number">256</span></span>, PrivatePrimitive = <span class="hljs-number"><span class="hljs-number">512</span></span>, OtherInternalPrimitive = <span class="hljs-number"><span class="hljs-number">1024</span></span>, OtherFrameworkPrimitive = <span class="hljs-number"><span class="hljs-number">2048</span></span>, OtherInterop = <span class="hljs-number"><span class="hljs-number">4096</span></span>, Other = <span class="hljs-number"><span class="hljs-number">8192</span></span>, NonBlocking = <span class="hljs-number"><span class="hljs-number">16384</span></span>, }</code> </pre> <br>  <a href="https://www.viva64.com/en/w/v3125/">V3125 Objek</a> 'sesi' digunakan setelah diverifikasi terhadap nol.  Periksa baris: 69, 68. AmqpLinkCreator.cs 69 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;Tuple&lt;AmqpObject, DateTime&gt;&gt; CreateAndOpenAmqpLinkAsync() { .... AmqpSession session = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Create Session .... } catch (Exception exception) { .... session?.Abort(); throw AmqpExceptionHelper.GetClientException(exception, null, session.GetInnerException(), amqpConnection.IsClosing()); } .... }</span></span></code> </pre> <br>  Perhatikan penanganan variabel <i>sesi</i> di blok <i>tangkap</i> .  Metode <i>Abort</i> dipanggil dengan aman oleh operator akses bersyarat.  Tetapi setelah metode <i>GetInnerException</i> disebut tidak aman.  Dengan melakukan hal itu, <i>NullReferenceException</i> mungkin dilemparkan bukan pengecualian dari tipe yang diharapkan.  Kode ini harus diperbaiki.  Metode <i>AmqpExceptionHelper.GetClientException</i> mendukung melewati nilai <i>nol</i> untuk parameter <i>innerException</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Exception </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetClientException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Exception exception, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> referenceId = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Exception innerException = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionError = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre> <br>  Oleh karena itu, seseorang hanya dapat menggunakan operator akses bersyarat saat memanggil <i>sesi. DapatkanInnerException ()</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;Tuple&lt;AmqpObject, DateTime&gt;&gt; CreateAndOpenAmqpLinkAsync() { .... AmqpSession session = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Create Session .... } catch (Exception exception) { .... session?.Abort(); throw AmqpExceptionHelper.GetClientException(exception, null, session?.GetInnerException(), amqpConnection.IsClosing()); } .... }</span></span></code> </pre> <br><h2>  Kesimpulan </h2><br>  Seperti yang Anda lihat, ukuran proyek besar tidak selalu menjamin banyak kesalahan.  Namun, kami tetap waspada karena kami selalu dapat menemukan sesuatu.  Bahkan dalam proyek yang kompleks secara struktural seperti Azure SDK untuk .NET.  Menemukan beberapa cacat krusial membutuhkan upaya tambahan.  Tetapi semakin banyak kesulitan semakin menyenangkan hasilnya.  Di sisi lain, untuk menghindari upaya yang tidak semestinya, kami sarankan menggunakan analisis statis langsung di komputer pengembang saat menulis kode baru.  Ini adalah pendekatan yang paling efektif.  <a href="https://www.viva64.com/en/pvs-studio-download/">Unduh dan coba PVS-Studio</a> dalam aksi.  Semoga berhasil dalam memerangi serangga! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478978/">https://habr.com/ru/post/id478978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478962/index.html">Ilya Yakyamsev: Efisiensi tidak bekerja</a></li>
<li><a href="../id478966/index.html">Bagaimana cara bertahan dan menjadi pengembang frontend di dunia modern?</a></li>
<li><a href="../id478968/index.html">Nanoracks dengan SpaceX akan meluncurkan demonstran untuk membuat stasiun orbit puing ruang</a></li>
<li><a href="../id478972/index.html">Pemenang Kontes Platform Miro</a></li>
<li><a href="../id478974/index.html">Modul memuat otomatis menggunakan impor dinamis</a></li>
<li><a href="../id478980/index.html">Azure SDK untuk .NET: Kisah Pencari Bug yang Sulit</a></li>
<li><a href="../id478982/index.html">Seperti yang saya yakini Topeng Ilona. Dan ketika kita akan berada di bulan lagi</a></li>
<li><a href="../id478984/index.html">TimTam - pijat perkusi generasi baru dengan fungsi pemanasan tip yang unik</a></li>
<li><a href="../id478986/index.html">Yandex meluncurkan suara populer untuk game retro. Finalis Pertempuran Game Retro 2019</a></li>
<li><a href="../id478988/index.html">Venesia: untung liar di atas batu yang telanjang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>