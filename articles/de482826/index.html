<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèΩ üëäüèø üë©üèΩ‚Äçüè´ Analysieren einer 128-Byte-Demo aus dem Archiv von 1997 üëºüèº üßóüèª ‚ùì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist sehr angenehm, meine W√ºnsche zu erf√ºllen, besonders aus der fernen Vergangenheit, so fern, dass ich schon vergessen habe, dass ich es einmal wo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analysieren einer 128-Byte-Demo aus dem Archiv von 1997</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482826/"> Es ist sehr angenehm, meine W√ºnsche zu erf√ºllen, besonders aus der fernen Vergangenheit, so fern, dass ich schon vergessen habe, dass ich es einmal wollte.  Ich wei√ü wenig √ºber die Demoszene und bin den Autoren oder ihrer Arbeit auf keinen Fall gefolgt. Ich habe nur gern zugesehen, was passiert ist.  Manchmal wollte ich es herausfinden, aber dann fehlte mir das Wissen und die Erfahrung, sp√§ter die Ausdauer, und dann verlor ich das Interesse daran vollst√§ndig.  Aber k√ºrzlich besuchte mein Freund, mit dem wir zu dieser Zeit studierten und der uns alle neuen Produkte, einschlie√ülich Demos, mit BBS und Fidonet versorgte, weil er fast alle gleichzeitig ein Telefon und ein Modem und einen Computer besa√ü, <a href="https://cafeparty.org.ru/2019/" rel="nofollow">CAFePARTY</a> mit seinen Arbeiten Das hat mich dazu gebracht, das Archiv meines ersten Computers zu √∂ffnen, eine Demo auszuw√§hlen und es herauszufinden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/yt/35/noyt35q-swsum-xmzb10a5px1rk.gif" alt="pentagra.com"></div><br>  Um meine St√§rken objektiv beurteilen zu k√∂nnen, habe ich ein 128-Byte-Intro aufgenommen, das mir visuell gefallen hat.  Die <code>pentagra.com</code> Datei ist von <b>Mcm</b> signiert, 128 Bytes, zuletzt ge√§ndert am 24.09.1996 18:10:14, Hex-Dump: <br><br> <code>000000: b0 13 cd 10 68 00 a0 07 06 1f ac ba c8 03 ee 42 <br> 000010: b1 40 ee 40 6e 6e e2 fa b8 3f 3f bb 40 01 bf 40 <br> 000020: 05 57 b1 78 ab 03 fb e2 fb 5f b1 60 88 01 aa 03 <br> 000030: fb 03 fb e2 f7 b1 61 88 01 aa 2b fb 2b fb e2 f7 <br> 000040: bf d1 99 57 b1 78 ab 2b fb e2 fb 5f b1 8f f3 ab <br> 000050: 81 fe 00 fa 73 12 ac 0a c0 74 0d 48 88 44 fe 88 <br> 000060: 04 88 40 ff 88 84 bf fe 03 f2 42 75 e3 e4 60 3c <br> 000070: 01 75 a5 b8 03 00 cd 10 c3 00 00 00 00 4d 63 6d <br></code> <a name="habracut"></a><br>  Aus demselben Archiv, das ich herausgezogen habe: <br><br><ul><li>  <b>Hiew 6.11</b> ( <a href="http://www.hiew.ru/" rel="nofollow">6.50</a> ist auf der Site zu finden) - Ich habe es als Disassembler verwendet </li><li>  <b>TASM-</b> Paket - mit dem ich den erhaltenen Code zur√ºckerhob, um sicherzustellen, dass ich nichts vermasselt habe </li><li>  <b>Die TECH-Hilfe von Flambeaux Software!</b>  <b>6.0</b> - M√§√üig detaillierte und umfassende Online-Referenz f√ºr DOS-API, BIOS-Funktionen, Hardware und Assembler </li><li>  <b>Mayko G.V.</b>  <b>Assembler f√ºr IBM PC</b> - eine fast taschengro√üe Formatreferenz f√ºr alle grundlegenden Intel 8086-Befehle und Programmtextformatierungsregeln.  Ohne architektonische Details und mit elementaren Beispielen nur die grundlegendsten Dinge.  Hier gibt es fast alles, was Sie brauchen, aber Sie k√∂nnen in Assembler nur in der Umgebung schreiben. </li><li>  Daher ist das zweite Buch <b>Zubkov S.V.</b>  <b>Assembler.</b>  <b>F√ºr DOS, Windows und Unix</b> - Eine Anleitung zu Hardware-Nooks und DOS </li></ul><br>  Von der extrem minimalen Implementierung sollte man die Verwendung von Tricks und nicht-standardm√§√üigen Ans√§tzen erwarten, aber abgesehen von einigen Annahmen in den Anfangsbedingungen sah ich keine technischen Tricks, aber ich sah einen algorithmischen Trick.  Und hier sollten ein paar Worte √ºber die Erfahrung gesagt werden.  Was k√∂nnte die Schwierigkeit sein?  Entweder in der Implementierung oder im Algorithmus.  Im Befehl <code>mov di, 099d1h</code> , haben Sie m√∂glicherweise Angst vor einer magischen Konstante.  Wenn Sie sich jedoch im Nutzungskontext befinden, wird deutlich, dass dies die Adresse f√ºr den Zugriff auf die Bildschirmkoordinaten X und Y ist, wobei X = 17, Y = 123, 320 die horizontale Aufl√∂sung des Bildschirms in Pixel ist.  Zusammen ergibt dies 17 + 123 * 320, die Umwandlung zweidimensionaler Koordinaten in eindimensionale. <br><br>  Wenn ich mir jetzt anschaue, was auf dem Bildschirm passiert, kann ich mir leicht vorstellen, wie ich dies implementieren k√∂nnte, wenn auch nicht mit 128 Bytes, auch wenn es nicht 100% √§hnlich ist, aber ich k√∂nnte.  Und vor 20 Jahren konnte ich es nicht, obwohl ich alle Werkzeuge, die ich verwendete, aus staubigen Regalen holte und nicht im Internet surfen musste, um zu verstehen, wie es funktioniert.  Daher ist dies zuallererst ein Kontext, ein Verst√§ndnis dessen, was geschieht, und daher steht die Frage nach Tricks und WIE dies zu tun ist an zweiter Stelle. <br><br>  Was sehen wir: <br><br><ol><li>  5 Zeilen des Pentagramms.  Dies sind nicht unbedingt direkte, untrennbare Linien nach allen Kanonen.  Wir sehen nur die allgemeine Figur ohne Details </li><li>  Der Flammeneffekt, der aus zwei wichtigen Teilen besteht: einer korrekt ausgew√§hlten Palette und einem Algorithmus zum st√§ndigen √Ñndern der Farbe von Punkten auf dem Bildschirm mit Unsicherheitselementen, wobei jedoch eine kontinuierliche Palettensequenz f√ºr benachbarte Punkte beibehalten wird.  Sie k√∂nnen beispielsweise den gesamten aktuellen Bildschirm berechnen, indem Sie den Durchschnitt der Werte benachbarter Pixel des vorherigen Bildschirms berechnen und an zuf√§lligen oder nicht zuf√§lligen Stellen, aber zuf√§lligen oder nicht zuf√§lligen Werten weitere ‚Äûhelle‚Äú Punkte hinzuf√ºgen. Entfernen Sie sich einfach von der linearen Reihenfolge.  Eine M√∂glichkeit ist, <a href="https://habr.com/ru/post/435122/">wie es in DOOM gemacht wird</a> .  Das Ergebnis sollte in Form von ineinander flie√üenden Farben sein, von st√§ndig auftauchenden hellen Bereichen bis hin zum Ausbleichen </li></ol><br>  Es bleibt zu verstehen, wie dies getan wurde.  Eine weitere Beschreibung ersetzt nicht das Wissen √ºber Computerarchitektur und DOS- oder Assembler-Funktionen. Mit diesem Wissen k√∂nnen Sie jedoch das Wesentliche des Geschehens verstehen und sich darauf konzentrieren.  Nachdem ich mit dem Schreiben angefangen hatte, wurde mir klar, dass es sich immer noch als ausreichend detailliert herausstellte, aber ich konnte es nicht ablehnen, um nicht im Sinne der Geschichte zu verlieren. <br><br><h3>  DOS und Laden von .COM-Programmen </h3><br>  Das Programm in der <code>.com</code> Datei ist sauberer Code, keine √úberschriften, Sie m√ºssen es nur an der richtigen Stelle platzieren.  Das macht DOS, oder besser gesagt der 4Bh-Systemaufruf.  Viele Aktionen finden statt, lassen Sie uns das Ergebnis n√§her betrachten: <br><br><ul><li>  Alle Segmentregister CS, DS, ES, SS werden mit einem einzigen Wert geladen </li><li>  65536 Bytes sind f√ºr das gesamte Programm reserviert, genau ein Segment, auf das sich alle Segmentregister beziehen.  Die ersten 256 Bytes werden vom Systemheader PSP (Program Segment Prefix) belegt.  Bei CS: 0, dem ersten Feld der PSP, befindet sich der Befehl INT 20h, um das aktuelle Programm zu beenden und die Steuerung an den √ºbergeordneten Prozess zu √ºbertragen.  Das Programm selbst startet mit der Adresse CS: 100h und belegt die folgenden 128 Bytes </li><li>  Das Wort 0000h wird auf den Stapel geschoben, das SP-Register ist FFFEh.  Dies bedeutet, dass die letzten zwei Bytes in diesem Segment an der Adresse SS: FFFEh zur√ºckgesetzt werden.  Tats√§chlich ist dies die n√§chste R√ºcksprungadresse aus der Prozedur, die uns zum Beendigungsbefehl bei CS: 0 f√ºhrt </li><li>  Die Register AL und AH enthalten ein Fehlerflag zum Bestimmen der Laufwerksbuchstaben aus dem ersten und zweiten Argument, wenn das Programm aufgerufen wird.  Wenn es keine Fehler gibt, sind sie 0, wenn es dann FFh gibt </li></ul><br>  Ich bin fest davon √ºberzeugt, dass der Status der Register im Allgemeinen nicht definiert ist.  Aber in dem analysierten Code wird meiner Meinung nach eine sehr k√ºhne Annahme √ºber ihren Anfangszustand getroffen, insbesondere √ºber die CX-, SI-Register und das DF-Richtungsflag.  Ich habe keine Best√§tigung daf√ºr in der Liste der Quellen gefunden, die sich oben ergeben haben, also habe ich die <a href="" rel="nofollow">MS-DOS 2.0-</a> Quellen durchgesehen: <br><br><ul><li>  Bei DF k√∂nnen wir davon ausgehen, dass es durch den Befehl <code>cld</code> , da dieser die Vorw√§rtsrichtung verwendet, bevor die Steuerung auf <code>cld</code> √ºbertragen wird. Daher wird DF zur√ºckgesetzt.  Obwohl <code>cld</code> an dieser Stelle nicht explizit verwendet wird, wird der Befehl zum L√∂schen des Richtungsflags h√§ufig vor vielen anderen √úbertragungen ausgef√ºhrt </li><li>  SI enth√§lt 100h, da es verwendet wird, um den Offset zu bestimmen, der vom IP-Befehlsz√§hler in das Register geladen wird </li><li>  CX ist gleich FFh, weil es als Z√§hler mit einem Anfangswert von 80h zum √úbertragen des Inhalts der gesamten Befehlszeile verwendet wird und dementsprechend nach dem √úbertragen 0 ist. Danach l√§dt CL als tempor√§re Variable FFh und setzt das Fehlerflag des Laufwerksbuchstabens in AL und AH </li></ul><br>  Es gibt keine Quellen f√ºr neuere Versionen, aber <a href="https://sourceforge.net/projects/dosbox/files/dosbox/" rel="nofollow">DOSBox-Quellen</a> : <br><br><pre> <code class="cpp hljs">reg_ax=reg_bx=<span class="hljs-number"><span class="hljs-number">0</span></span>;reg_cx=<span class="hljs-number"><span class="hljs-number">0xff</span></span>; reg_dx=pspseg; reg_si=RealOff(csip); reg_di=RealOff(sssp);</code> </pre><br>  Das hei√üt, es stimmt mit dem √ºberein, was ich im MS-DOS-Quellcode (2. Version!) Gesehen habe. Sie k√∂nnen die Anfangswerte anderer Register sehen, hier handelt es sich um eine explizite, spezielle Initialisierung.  F√ºr MS-DOS sind die Werte anderer Register als AX, Segment und Stack Ans√§tze f√ºr ihre Verwendung f√ºr andere Zwecke, dies ist kein Dogma oder Standard, daher werden sie nirgendwo erw√§hnt.  Andererseits wird das √ñkosystem, das sich gebildet hat, und der ganze Schmerz von Microsoft, die Kompatibilit√§t mit alten Versionen zu unterst√ºtzen und alle zuf√§llig generierten Werte mitzurei√üen, ein wenig verst√§ndlich, weil Programmierer so an sie gew√∂hnt sind. <br><br>  Schlie√ülich reicht uns dieses Wissen, und wir beginnen, das Programm aus den Headern wiederherzustellen: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup</code> </pre><br>  Wir bestimmen den Prozessortyp 80186, da wir den Befehl <code>outsb</code> , der nur in diesem Modell vorkommt.  Ein Codesegment und ein Einstiegspunkt in das Programm erm√∂glichen es dem Compiler zusammen mit der Definition des <code>tiny</code> Speichermodells, alle Offsets von Variablen und √úberg√§ngen korrekt zu berechnen.  Beim <code>tlink</code> wird der <code>tlink</code> <code>/t</code> verwendet, der bei der Ausgabe eine <code>.com</code> Datei ergibt. <br><br><h3>  Grafik und Palette </h3><br>  Um in den Grafikmodus zu wechseln, m√ºssen Sie sich an die BIOS-Funktion wenden, f√ºr die eine Unterbrechung von 10h, AH = 0, aufgerufen wird. In AL geben wir die Kennung des gew√ºnschten Modus ein - 13h: <br><br><pre> <code class="cpp hljs">mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h ;b0 <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Bitte beachten Sie, dass wir AH nicht ber√ºhren, wenn wir davon ausgehen, dass es gem√§√ü den Programmladebedingungen Null gibt.  Der ausgew√§hlte Modus entspricht einer Grafikaufl√∂sung von 320 x 200 Pixel mit einer 256-Farben-Palette.  Um einen Punkt auf dem Bildschirm anzuzeigen, m√ºssen Sie in den Speicherbereich schreiben, der mit der Adresse A000h: 0 beginnt, wobei das Byte der Farbe entspricht.  Segmentdatenregister mit diesem Wert f√ºllen: <br><br><pre> <code class="cpp hljs">push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h ;<span class="hljs-number"><span class="hljs-number">68</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> a0 pop es ;<span class="hljs-number"><span class="hljs-number">07</span></span> push es ;<span class="hljs-number"><span class="hljs-number">06</span></span> pop ds ;<span class="hljs-number"><span class="hljs-number">1f</span></span></code> </pre><br>  Logischerweise ist der Speicher als zweidimensionales Array organisiert, in dem Bildschirmkoordinaten angezeigt werden. 0: 0 entspricht der oberen linken Ecke.  Nach dem Umschalten des Modus wird er in der Standardpalette mit Nullen gef√ºllt - schwarz.  Die Formel f√ºr die √úbersetzung in eine lineare Verschiebung lautet <b>X + Y * L</b> , wobei L die horizontale Aufl√∂sung ist, in unserem Fall 320. In dieser Form schreibe ich an den Stellen, an denen die Konstanten verwendet werden, wenn der Programmtext √ºbersetzt wird, werden sie automatisch berechnet. <br><br>  Um die Palette zu √§ndern, greifen wir √ºber die Eingabe- / Ausgabeports direkt auf das Ger√§t zu: <br><br><pre> <code class="cpp hljs">lodsb ;ac mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h ;ba c8 <span class="hljs-number"><span class="hljs-number">03</span></span> out dx, al ;ee</code> </pre><br>  Der erste Befehl l√§dt das bei DS: SI befindliche Datenbyte in AL.  In DS haben wir die Segmentadresse des Videospeichers geladen und wissen, dass sie mit Nullen gef√ºllt ist, in SI - im Allgemeinen ist mindestens 0 nicht bekannt. Es spielt f√ºr uns keine Rolle, wo immer SI angibt, dass wir mit ziemlicher Sicherheit in den Videospeicher gelangen, der belegt mit dieser aufl√∂sung 320 * 200 = 64000 bytes fast das gesamte segment.  Daher erwarten wir, dass nach diesem Befehl AL = 0 ist.  Eine Einheit wird zu SI addiert oder subtrahiert. Dies h√§ngt von der Einstellung des DF-Richtungsflags ab.  Auch wenn dies f√ºr uns nicht besonders wichtig ist, bleiben wir in dem mit Nullen gef√ºllten Videospeicherbereich, egal wo sich der SI bewegt. <br><br>  Laden Sie als n√§chstes den DX mit der Portnummer 03C8h, deren Ausgang bestimmt, welche der 256 Farben √ºberschrieben werden soll.  In unserem Fall ist es 0 von AL. <br><br>  Die Farbe wird in der RGB-Palette codiert. Dazu m√ºssen Sie dreimal hintereinander einmal f√ºr jede der Komponenten auf Port 03C9h schreiben (einer mehr als 3C8h).  Die maximale Helligkeit der Komponente betr√§gt 63, die minimale 0. <br><br><pre> <code class="cpp hljs">inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">64</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">40</span></span> PALETTE: out dx, al ;ee inc ax ;<span class="hljs-number"><span class="hljs-number">40</span></span> outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e loop PALETTE ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-6</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">,    6  </span></span></code> </pre><br>  Erh√∂hen Sie DX um eins, damit es die gew√ºnschte Portnummer hat.  CL ist unser Zyklusz√§hler von 64, und wir gehen davon aus, dass CH = 0 ist, wie zuvor beschrieben, basierend auf den anf√§nglichen Ladebedingungen.  Als n√§chstes geben wir die erste Komponente an den Port aus - die rote, deren Helligkeit in AL gespeichert wird. In Schritt 0 √§ndern wir sie. Danach erh√∂hen wir ihre Helligkeit um eins, um sie in der n√§chsten Iteration anzuzeigen.  Als n√§chstes f√ºhren wir zwei <code>outsb</code> Befehle aus <code>outsb</code> die auf den Port schreiben, dessen Nummer in DX, dem Byte aus dem DS-Speicherbereich, enthalten ist: SI, denken Sie daran, dass wir dort Nullen haben.  SI √§ndert sich jedes Mal um eins. <br><br>  Sobald wir die drei Komponenten abgeleitet haben, wird der Farbnummer automatisch eine Einheit hinzugef√ºgt.  Daher ist es nicht erforderlich, die Farbe durch Ausgabe an den 3C8h-Port neu zu definieren, wenn die Farben nach Bedarf in einer Reihe liegen.  Der <code>loop</code> reduziert CX um eins. Wenn ein Wert ungleich Null erhalten wird, springt er zum Beginn des Zyklus, bei 0 zum n√§chsten Befehl nach dem Zyklus. <br><br>  Insgesamt 64 Wiederholungen.  Bei jeder Wiederholung bestimmen wir f√ºr die Farbe, beginnend von 0 bis 63, die Rotkomponente mit der Helligkeit, die mit der aktuellen Farbnummer √ºbereinstimmt.  Wir setzen die gr√ºnen und blauen Komponenten zur√ºck, um eine solche Palette von minimaler zu maximaler roter Helligkeit zu erhalten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/py/jq/lzpyjqjyav0-x3qdl5easmdesvs.png" alt="Palette"></div><br><br><h3>  Linien </h3><br>  Richten Sie die anf√§nglichen Farb- und Koordinatenwerte ein: <br><br><pre> <code class="cpp hljs">LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh ;b8 <span class="hljs-number"><span class="hljs-number">3f</span></span> <span class="hljs-number"><span class="hljs-number">3f</span></span> mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bb <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span></code> </pre><br>  In AL und AH laden wir die maximal m√∂gliche (hellste) Farbe 63 (3Fh), AX definiert zwei Punkte gleichzeitig.  BX - maximale horizontale Aufl√∂sung.  In Zukunft wird dies verwendet, um eine Zeile zu den aktuellen Koordinaten zu addieren oder von diesen zu subtrahieren.  DI - Koordinaten 64: 4, speichern Sie sie auf dem Stapel. <br><br>  <b>Zeichne die erste Linie von der oberen linken Ecke bis zum rechten Ende</b> : <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE1: stosw ;ab add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE1 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  Konfigurieren Sie den Z√§hler - dies ist die Anzahl der Zeilen.  Speichern Sie als n√§chstes das Wort (zwei Bytes) von AX unter der Adresse ES: DI.  Diese Aktion zeigt zwei Punkte auf dem Bildschirm mit der maximalen Farbe aus unserer Palette an, da der ES f√ºr den Videospeicher konfiguriert ist und bestimmte Koordinaten in DI festgelegt werden.  Nach dieser Aktion wird 2 zum DI hinzugef√ºgt, da zwei Bytes geschrieben wurden.  Wir setzen das DF-Richtungs-Flag offensichtlich nicht und verlassen uns auf die Tatsache, dass es zur√ºckgesetzt wird. Wir erinnern uns erneut an unsere urspr√ºnglichen Bedingungen f√ºr das Laden des Programms.  Andernfalls w√ºrden die beiden weggenommen, was nicht erlauben w√ºrde, die gew√ºnschte Linie zu zeichnen. <br><br>  Als n√§chstes ist DI = DI + BX, was einer Erh√∂hung der Y-Koordinate um eins entspricht.  Im Hauptteil des Zyklus werden also zwei Punkte in einer Linie gezeichnet, die X-Koordinate wird um 2 und die Y-Koordinate um 1 erh√∂ht, und diese Aktion wird 120 Mal wiederholt. Das Bild mit dem Ergebnis ist geringf√ºgig niedriger. <br><br>  <b>Die zweite Zeile verl√§uft von links oben nach oben</b> : <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">60</span></span> LINE2: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE2 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  Wir stellen die Anfangskoordinaten 64: 4 wieder her und setzen den Z√§hler auf 96 Wiederholungen.  Wir drucken einen Punkt, aber eine Linie unter den aktuellen Koordinaten.  Dies wird nach wie vor durch Hinzuf√ºgen eines Wertes aus BX erreicht, nur ohne die neuen Koordinaten zu speichern.  Die Konstruktion <code>[bx+di]</code> oder <code>[bx][di]</code> wird Basisadressierung mit Indexierung genannt und arbeitet auf Prozessorebene, nicht auf √úbersetzerebene.  Das Standardsegmentregister bei BX ist DS.  Danach zeigen wir den zweiten Punkt an, jedoch bereits in den aktuellen Koordinaten.  DI und damit X um eins, da nur ein Byte-√úbertragungsbefehl <code>stosb</code> - <code>stosb</code> .  Die letzten beiden Befehle des Zyklusk√∂rpers sind eine Erh√∂hung von Y um 2, f√ºr die wir wieder BX verwenden. <br><br>  Nach dem Zeichnen von zwei Linien wird das folgende Bild in der N√§he der oberen linken Ecke erhalten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/nu/fk/xvnufkuhyvi0gwqomrquixlvti8.png" alt="Zeile 1.2"></div><br><br>  Linke und obere Koordinaten, rechts von der Zeilenversatzadresse im Videospeicher.  Punkt 64: 4 wird zweimal gezogen. <br><br>  <b>Die dritte Zeile verl√§uft von oben nach rechts oben</b> : <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">61</span></span> LINE3: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb loop LINE3 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  DI enth√§lt bereits den gew√ºnschten Koordinatenwert 160: 196. Wir m√ºssen eine Linie von oben an der Stelle zeichnen, an der die vorherige Linie geendet hat. Dabei m√ºssen wir den Bildschirm nach oben bewegen und den gleichen Winkel beibehalten.  Dementsprechend ist der Zyklus nahezu identisch.  CX wird um 1 erh√∂ht, da die aktuelle Y-Koordinate 2 mehr (niedriger) ist als am Ende der vorherigen Zeile. Sie wurde bereits f√ºr die n√§chste Iteration berechnet.  Um in die obere Ecke zu gelangen, m√ºssen Sie daher einen zus√§tzlichen Schritt machen.  Die Bewegung entlang X setzt sich in derselben Richtung fort - plus eins nach jeder Iteration, und entlang Y subtrahieren wir die beiden, anstatt sie zu addieren.  Die Punkte werden in derselben Reihenfolge angezeigt, zuerst unten, dann oben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d8/bw/3f/d8bw3fucavqttjhld9wqrlqsi_s.png" alt="Zeile 3"></div><br><br>  <b>Die vierte Zeile befindet sich ganz links in der oberen rechten Ecke:</b> <br><br><pre> <code class="cpp hljs">mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf d1 <span class="hljs-number"><span class="hljs-number">99</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE4: stosw ;ab sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb(<span class="hljs-number"><span class="hljs-number">-5</span></span>) loop LINE4</code> </pre><br>  Wir sind wieder in den n√∂tigen Koordinaten, aber dies wird anscheinend nicht verwendet, um das DF-Richtungs-Flag nicht zu √§ndern.  Daher werden neue Koordinaten in das DI gestellt und auf dem Stapel gespeichert. <br><br>  Weiterhin ist alles identisch mit der ersten Zeile, nur die Y-Koordinate w√§chst nicht, sondern nimmt ab, wir steigen auf. <br><br>  <b>Die f√ºnfte Zeile ist horizontal:</b> <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">8f</span></span> rep stosw ;f3 ab</code> </pre><br>  Hier ist alles einfach, es wird der Mikroprozessor-Neu√ºbertragungsmechanismus verwendet, da die horizontale Linie einer einfachen Erh√∂hung der Adresse jedes n√§chsten Punktes entspricht.  In DI wird die Adresse wiederhergestellt, die der im vorherigen Schritt gespeicherten Koordinate der linken √§u√üersten Ecke entspricht.  Die Anzahl der Wiederholungen in CX wird festgelegt und das Wiederholungspr√§fix wird mit dem Wort√ºbertragungsbefehl angewendet. <br><br>  Nach dieser Aktion haben wir ein vollst√§ndig gezeichnetes Pentagramm in der hellsten Farbe.  80 Bytes verwendet und 48 in Reserve. <br><br><h3>  Feuermagie </h3><br>  <b>Wir setzen die Randbedingungen f√ºr die Berechnungen:</b> <br><br><pre> <code class="cpp hljs">FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> ;<span class="hljs-number"><span class="hljs-number">81</span></span> fe <span class="hljs-number"><span class="hljs-number">00</span></span> fa jae NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> lodsb ;ac <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al ;<span class="hljs-number"><span class="hljs-number">0</span></span>a c0 jz NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>d</code> </pre><br>  In SI gibt es die Koordinate des aktuellen Punktes f√ºr Berechnungen. Wenn wir √ºber die Grenzen des Bildschirms hinausgehen, f√ºhren wir keine Berechnungen mit diesem Punkt durch und fahren mit der Berechnung des n√§chsten Punktes fort. <br><br>  <code>lodsb</code> l√§dt ein Byte aus dem DS: SI-Bereich in AL, <code>lodsb</code> die Farbe des Punkts in den aktuellen Koordinaten.  Wenn es 0 ist, dann tun wir auch nichts und fahren mit dem n√§chsten Punkt fort. <br><br>  <b>Neue Farbberechnung</b> <br><br>  Dies ist der Hauptalgorithmus zum √Ñndern der Farbwerte auf dem Bildschirm, dies ist keine Flamme, dies ist die Basis daf√ºr.  Wir berechnen Nachbarpunkte und erzielen Farbkontinuit√§t: <br><br><pre> <code class="cpp hljs">dec ax ;<span class="hljs-number"><span class="hljs-number">48</span></span> mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">44</span></span> fe mov [si], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> ff mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">84</span></span> bf fe</code> </pre><br>  Subtrahieren Sie von AX, tats√§chlich von AL, eine Einheit, die einen von Null verschiedenen Farbwert enth√§lt, der aus den aktuellen Koordinaten erhalten wird.  Als n√§chstes schreiben wir den erhaltenen Wert auf alle benachbarten Punkte, relativ zur aktuellen Koordinate, das hei√üt ein bisschen von ihnen, basierend auf unserer Palette. <br><br>  Da nach <code>lodsb</code> der SI-Wert um eins ansteigt und nicht mehr dem Punkt entspricht, dessen Farbe wir in AL lesen, muss dieser angepasst werden.  Beachten Sie, dass <code>stosb</code> Byte-√úbertragungsbefehle mehr verwendet werden, sondern <code>mov</code> , um die Adresse zu bestimmen, an der der Wert platziert wird.  Wenn wir akzeptieren, dass die aktuellen Koordinaten X: Y sind, f√ºr sie SI-1, dann: <br><br><ul><li>  <code>mov [si-2], al</code> - <code>mov [si-2], al</code> eine neue Farbe am Punkt X-1: Y links von der aktuellen auf.  2 wird aus dem oben beschriebenen Grund von SI subtrahiert, da bereits eine zus√§tzliche Einheit hinzugef√ºgt wurde </li><li>  <code>mov [si], al</code> eine neue Farbe am Punkt X + 1: Y rechts von der aktuellen auf.  SI hat bereits X + 1 </li><li>  <code>mov [bx+si-1], al</code> - Schreiben einer neuen Farbe an den Punkt X: Y + 1 unter der aktuellen.  Verwenden Sie wieder BX f√ºr Y + 1 </li><li>  <code>mov [si-1-1*320], al</code> - Schreiben einer neuen Farbe an den Punkt X: Y-1 √ºber der aktuellen.  Wir k√∂nnen BX nicht verwenden, da wir die Koordinate entfernen m√ºssen. Aufgrund der Prozessorarchitektur ist dies in dieser Form nicht m√∂glich. Daher wird eine Konstante gem√§√ü der Koordinatenreduktionsformel verwendet </li></ul><br>  Das Segmentregister ist DS, das standardm√§√üig mit SI und BX verwendet wird. <br><br>  Nirgendwo wird die Situation √ºberpr√ºft, wenn der Punkt den Rand des Bildschirms ber√ºhrt.  Dies kann nicht zu einem Ausfall f√ºhren, da wir uns immer innerhalb der Grenzen des Videosegments befinden.  Ein benachbarter Punkt kann entweder in einen nicht gemeldeten Bereich mit Adressen √ºber 64.000 fallen oder auf eine benachbarte Linie, die uns nicht schadet und sogar ein wenig hilft, wie aus der weiteren Beschreibung hervorgeht. <br><br>  <b>Dieselbe Magie, die Berechnung der Koordinaten des n√§chsten Punktes</b> <br><br><pre> <code class="cpp hljs">NEXT_PIXEL: add si, dx ;<span class="hljs-number"><span class="hljs-number">03</span></span> f2 inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> jnz FLAME ;<span class="hljs-number"><span class="hljs-number">75</span></span> e3(<span class="hljs-number"><span class="hljs-number">-29</span></span>)</code> </pre><br>  Gehen wir noch ein bisschen zur√ºck, wir haben den anf√§nglichen SI-Wert nirgendwo speziell festgelegt und in DX haben wir immer noch die Nummer des Ausgabe-Eingangsports, den wir f√ºr die Palette verwendet haben.  Wir f√ºhren nur drei einfache Aktionen durch: SI = SI + DX. Dies setzt nat√ºrlich neue Koordinaten. Welche?  DX = DX + 1 und wenn DX nicht gleich 0 ist, dann zur√ºck zum Basisalgorithmus zum Erhalten und Berechnen benachbarter Punkte, das hei√üt, ist DX eine Art Z√§hler? <br><br>  Wir wissen, dass wir alle Punkte umgehen und die Helligkeits√§nderungen ihrer Nachbarn berechnen m√ºssen.  Wenn Sie dies in einer Reihe tun, erhalten Sie wahrscheinlich einen statischen Gradienten, vielleicht nicht ganz gleichm√§√üig, aber unver√§ndert um unsere Linien.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir kennen die Gr√∂√üe unseres Bildschirms und wissen, wie viele Punkte wir ben√∂tigen, aber hier vernachl√§ssigen wir sie fast, genauer gesagt, w√§hlen Sie den Schlusswert 65536 anstelle des exakten 64000. DX ist wirklich ein Z√§hler, nur 65536. Aber warum ist sein Anfangswert nicht wichtig und warum nehmen wir Ist der Endwert gr√∂√üer als die Gesamtpunktzahl auf dem Bildschirm? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weil wir Punkte nicht hintereinander und nicht alle umgehen. Jede nachfolgende lineare Koordinate ist um den Wert von DX gr√∂√üer als die vorherige. Das hei√üt, in SI die Summe der DX-Elemente einer einfachen arithmetischen Folge: 0,1,2,3,4,5,6, ..., 362,363, ..., 65535. Dies gibt uns bereits Nichtlinearit√§t, wenn Sie mit SI = 0 und DX = 0 beginnen, dann erhalten wir in SI: 0,1,3,4,6,10,15,21, ..., 65341,65703, ..., 2147450880.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist aber noch nicht alles, da die SI-Dimension 16 Bit betr√§gt, wir keinen Wert gr√∂√üer als 65535 erhalten k√∂nnen, ein √úberlauf auftritt und der Rest in SI modulo 65536 bleibt. Die lineare Koordinatenberechnungsformel hat die Form SI = (SI + DX) MOD 65536, Dies unterbricht die kontinuierliche Reihenfolge vollst√§ndig: 0,1,3,4,6,10,15,21, ..., 65341,167,530,894, ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun erinnern wir uns, dass SI in keiner Weise initialisiert wird, das hei√üt, wenn wir das n√§chste Mal zu diesem Zyklus zur√ºckkehren dann fangen wir bei der Koordinate an, bei der wir aufgeh√∂rt haben, und nicht bei 0 oder einer bestimmten. Dies wird unsere Sequenz chaotisch machen - die Anzahl der sich nicht wiederholenden Elemente erh√∂hen. Andernfalls w√§re die Durchquerung der Punkte immer gleich, wenn auch nicht linear. Ein Flammeneffekt w√§re vorhanden, aber nicht so deutlich. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir √ºber den Trick sprechen, dann ist dies genau das Richtige.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DX beginnt mit Ausnahme der ersten Verwendung immer implizit bei 0 als Ergebnis eines √úberlaufs </font></font><code>inc dx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein wenig mehr Chaos bringen unsere Grenzwerte, da f√ºr SI&gt; = 64000 keine Punkte gezogen werden und die Ausgabereihenfolge leicht verwirrt ist. Und das √úberspringen aller Punkte mit einem Nullwert f√ºhrt in den ersten Sekunden des Programms zum Z√ºndeffekt. Dies liegt daran, dass der vollst√§ndige Zyklus schneller endet, da die meisten Punkte nicht verarbeitet werden. Da die Helligkeit f√ºr die meisten Punkte jedoch nur zunimmt, k√∂nnen sie nicht durch benachbarte Dimmerabschnitte verdeckt werden. Sie sind einfach noch nicht vorhanden und es werden keine Nullwerte berechnet. Nachdem die vollst√§ndig schwarzen Bereiche verschwunden sind, wird das Gleichgewicht hergestellt, einige Bereiche erh√∂hen die Helligkeit und einige verringern sich.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infolgedessen k√∂nnen wir nicht mehr √ºber eine Reihenfolge oder einen Gradienten sprechen. Die Punkte werden jedes Mal in einer neuen Reihenfolge umgangen, einschlie√ülich mehrmaliger Wiederholung oder √úberspringen. </font><font style="vertical-align: inherit;">Dies f√ºhrt zur Bildung von Regionen unterschiedlicher Helligkeit, die miteinander vermischt sind und sich bei jeder neuen Iteration √§ndern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber das ist noch nicht alles, wenn Sie keine neuen hellen Punkte hinzuf√ºgen, werden sie am Ende alle zur√ºckgezahlt. </font><font style="vertical-align: inherit;">Nachdem der DX seinen Maximalwert erreicht hat, zeichnen wir erneut f√ºnf helle Linien und z√§hlen erneut alle Punkte auf dem Bildschirm:</font></font><br><br><pre> <code class="cpp hljs">in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h ;e4 <span class="hljs-number"><span class="hljs-number">60</span></span> cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h ;<span class="hljs-number"><span class="hljs-number">3</span></span>c <span class="hljs-number"><span class="hljs-number">01</span></span> jne LINES ;<span class="hljs-number"><span class="hljs-number">75</span></span> a5(<span class="hljs-number"><span class="hljs-number">-91</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber vorher haben wir von Port 60h gelesen, das ist die Tastatur, der Scan-Code der zuletzt gedr√ºckten Taste. </font><font style="vertical-align: inherit;">F√ºr ESC ist es gleich 1. Wenn die ESC-Taste gedr√ºckt wurde, bewegen wir uns in Richtung Ausgang.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertigstellung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist zu beachten, dass Sie w√§hrend der Aktualisierung des aktuellen Bildschirms, die einige Zeit in Anspruch nimmt, das Programm nicht beenden k√∂nnen, dh die Reaktion auf ESC verz√∂gert sich. Wenn wir w√§hrend des Wartens und nach dem Dr√ºcken einer Taste im Programm bleiben, kann nur der letzte Scan-Code vom Port gelesen werden. Eine weitere Sache ist, dass wir die DOS- und BIOS-Systemfunktionen daf√ºr nicht ersetzen oder verwenden, unabh√§ngig davon, was wir vom Port lesen. Die gedr√ºckte Taste befindet sich in einem Umlaufpuffer und wird wahrscheinlich vom n√§chsten Programm gelesen, nachdem unser Intro abgeschlossen ist, h√∂chstwahrscheinlich die Datei Manager oder </font></font><code>command.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies wird zu seiner Verarbeitung f√ºhren, zum Beispiel wird Volkov Commander auf ESC seine Panels verstecken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bleibt zu Textmodus 3 zur√ºckzukehren:</font></font><br><br><pre> <code class="cpp hljs">mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h ;b8 <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird davon ausgegangen, dass wir uns vor dem Start des Programms in diesem Modus befanden, aber im Allgemeinen ist dies m√∂glicherweise nicht der Fall. </font><font style="vertical-align: inherit;">Hier aktualisieren wir die gesamte AXT, da wir sicher sind, dass AH keine 0 enth√§lt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen Sie beenden:</font></font><br><br><pre> <code class="cpp hljs">retn ;c3</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein Near-Exit-Befehl aus einer Prozedur, die den Wert des dort platzierten Wortes (zwei Bytes) vom Stapel nimmt und in den IP-Befehlsz√§hler l√§dt. </font><font style="vertical-align: inherit;">Unter den Anfangsbedingungen haben wir Nullen im Stapel, dies f√ºhrt uns zur Adresse CS: 0, wo wir den Befehlscode kennen </font></font><code>int 20h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Herunterfahren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und 7 Bytes f√ºr das Urheberrecht:</font></font><br><br><pre> <code class="cpp hljs">dd <span class="hljs-number"><span class="hljs-number">0</span></span>h ;<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> ;<span class="hljs-number"><span class="hljs-number">4</span></span>d <span class="hljs-number"><span class="hljs-number">63</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>d end</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen sagen, dass es noch einen Platz gibt, den ich f√ºr eine strengere Initialisierung ausgeben w√ºrde, aber da alles in der modernen DOSBox funktioniert, hat der Autor wahrscheinlich alles richtig gemacht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen wir noch einmal durch:</font></font><br><br><ol><li>    ,        </li><li>  4    ,           :  X+1  Y+2,  X+2  Y+1.         ,       .    ,          </li><li>       SI=(SI+DX) MOD 65536,     DX ,     ,      ,     SI.         1.   65536 ,    ,     .     ,         ‚Äî <code>add si, dx</code>  <code>inc dx</code> ,            ,       </li><li>     ESC  ,           </li></ol><br><div class="spoiler"> <b class="spoiler_title">  .</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h pop es push es pop ds lodsb mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h out dx, al inc dx mov cl, <span class="hljs-number"><span class="hljs-number">040</span></span>h PALETTE: out dx, al inc ax outsb outsb loop PALETTE LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE1: stosw add di, bx loop LINE1 pop di mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> LINE2: mov [bx+di], al stosb add di, bx add di, bx loop LINE2 mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> LINE3: mov [bx+di], al stosb sub di, bx sub di, bx loop LINE3 mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE4: stosw sub di, bx loop LINE4 pop di mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> rep stosw FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> jae NEXT_PIXEL lodsb <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al jz NEXT_PIXEL dec ax mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al mov [si], al mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al NEXT_PIXEL: add si, dx inc dx jnz FLAME in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h jne LINES mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h retn dd <span class="hljs-number"><span class="hljs-number">0</span></span>h db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> end</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Kompilieren m√ºssen Sie Folgendes ausf√ºhren: </font></font><code>tasm pentagra.asm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>tlink /t pentagra.obj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wei√ü nicht, ob WAS und WIE es f√ºr Sie realisiert wurde, aber es scheint mir, dass ein sch√∂ner und ungew√∂hnlicher Ansatz verwendet wurde, um den Flammeneffekt zu erzeugen. </font><font style="vertical-align: inherit;">Obwohl ich nichts zu vergleichen habe, haben es vielleicht alle getan, und jetzt k√∂nnen Sie dasselbe tun.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482826/">https://habr.com/ru/post/de482826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482814/index.html">Gesamtansicht des Baumes, Implementierung und nicht nur</a></li>
<li><a href="../de482816/index.html">Arthur Khachuyan: K√ºnstliche Intelligenz im Marketing</a></li>
<li><a href="../de482818/index.html">Kurze Ergebnisse der Lekt√ºre des Berichts √ºber 1C DSS f√ºr Infostart 2019</a></li>
<li><a href="../de482820/index.html">Bild-Upload-Optimierung</a></li>
<li><a href="../de482822/index.html">Wie werden Kunsttests f√ºr Spiele durchgef√ºhrt?</a></li>
<li><a href="../de482832/index.html">Zukunfts√∂konomie f√ºr Physiker</a></li>
<li><a href="../de482834/index.html">Die statische Eingabe erfordert nicht unbedingt Zeremonien</a></li>
<li><a href="../de482838/index.html">ONYX BOOX Note 2 Test - ein Gro√übildleser mit maximaler Leistungsf√§higkeit</a></li>
<li><a href="../de482840/index.html">UTorrent sequentieller Download in 2 Klicks</a></li>
<li><a href="../de482842/index.html">Mash ist eine Programmiersprache, die sich selbst kompiliert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>