<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏽 👊🏿 👩🏽‍🏫 Analysieren einer 128-Byte-Demo aus dem Archiv von 1997 👼🏼 🧗🏻 ❓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist sehr angenehm, meine Wünsche zu erfüllen, besonders aus der fernen Vergangenheit, so fern, dass ich schon vergessen habe, dass ich es einmal wo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analysieren einer 128-Byte-Demo aus dem Archiv von 1997</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482826/"> Es ist sehr angenehm, meine Wünsche zu erfüllen, besonders aus der fernen Vergangenheit, so fern, dass ich schon vergessen habe, dass ich es einmal wollte.  Ich weiß wenig über die Demoszene und bin den Autoren oder ihrer Arbeit auf keinen Fall gefolgt. Ich habe nur gern zugesehen, was passiert ist.  Manchmal wollte ich es herausfinden, aber dann fehlte mir das Wissen und die Erfahrung, später die Ausdauer, und dann verlor ich das Interesse daran vollständig.  Aber kürzlich besuchte mein Freund, mit dem wir zu dieser Zeit studierten und der uns alle neuen Produkte, einschließlich Demos, mit BBS und Fidonet versorgte, weil er fast alle gleichzeitig ein Telefon und ein Modem und einen Computer besaß, <a href="https://cafeparty.org.ru/2019/" rel="nofollow">CAFePARTY</a> mit seinen Arbeiten Das hat mich dazu gebracht, das Archiv meines ersten Computers zu öffnen, eine Demo auszuwählen und es herauszufinden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/yt/35/noyt35q-swsum-xmzb10a5px1rk.gif" alt="pentagra.com"></div><br>  Um meine Stärken objektiv beurteilen zu können, habe ich ein 128-Byte-Intro aufgenommen, das mir visuell gefallen hat.  Die <code>pentagra.com</code> Datei ist von <b>Mcm</b> signiert, 128 Bytes, zuletzt geändert am 24.09.1996 18:10:14, Hex-Dump: <br><br> <code>000000: b0 13 cd 10 68 00 a0 07 06 1f ac ba c8 03 ee 42 <br> 000010: b1 40 ee 40 6e 6e e2 fa b8 3f 3f bb 40 01 bf 40 <br> 000020: 05 57 b1 78 ab 03 fb e2 fb 5f b1 60 88 01 aa 03 <br> 000030: fb 03 fb e2 f7 b1 61 88 01 aa 2b fb 2b fb e2 f7 <br> 000040: bf d1 99 57 b1 78 ab 2b fb e2 fb 5f b1 8f f3 ab <br> 000050: 81 fe 00 fa 73 12 ac 0a c0 74 0d 48 88 44 fe 88 <br> 000060: 04 88 40 ff 88 84 bf fe 03 f2 42 75 e3 e4 60 3c <br> 000070: 01 75 a5 b8 03 00 cd 10 c3 00 00 00 00 4d 63 6d <br></code> <a name="habracut"></a><br>  Aus demselben Archiv, das ich herausgezogen habe: <br><br><ul><li>  <b>Hiew 6.11</b> ( <a href="http://www.hiew.ru/" rel="nofollow">6.50</a> ist auf der Site zu finden) - Ich habe es als Disassembler verwendet </li><li>  <b>TASM-</b> Paket - mit dem ich den erhaltenen Code zurückerhob, um sicherzustellen, dass ich nichts vermasselt habe </li><li>  <b>Die TECH-Hilfe von Flambeaux Software!</b>  <b>6.0</b> - Mäßig detaillierte und umfassende Online-Referenz für DOS-API, BIOS-Funktionen, Hardware und Assembler </li><li>  <b>Mayko G.V.</b>  <b>Assembler für IBM PC</b> - eine fast taschengroße Formatreferenz für alle grundlegenden Intel 8086-Befehle und Programmtextformatierungsregeln.  Ohne architektonische Details und mit elementaren Beispielen nur die grundlegendsten Dinge.  Hier gibt es fast alles, was Sie brauchen, aber Sie können in Assembler nur in der Umgebung schreiben. </li><li>  Daher ist das zweite Buch <b>Zubkov S.V.</b>  <b>Assembler.</b>  <b>Für DOS, Windows und Unix</b> - Eine Anleitung zu Hardware-Nooks und DOS </li></ul><br>  Von der extrem minimalen Implementierung sollte man die Verwendung von Tricks und nicht-standardmäßigen Ansätzen erwarten, aber abgesehen von einigen Annahmen in den Anfangsbedingungen sah ich keine technischen Tricks, aber ich sah einen algorithmischen Trick.  Und hier sollten ein paar Worte über die Erfahrung gesagt werden.  Was könnte die Schwierigkeit sein?  Entweder in der Implementierung oder im Algorithmus.  Im Befehl <code>mov di, 099d1h</code> , haben Sie möglicherweise Angst vor einer magischen Konstante.  Wenn Sie sich jedoch im Nutzungskontext befinden, wird deutlich, dass dies die Adresse für den Zugriff auf die Bildschirmkoordinaten X und Y ist, wobei X = 17, Y = 123, 320 die horizontale Auflösung des Bildschirms in Pixel ist.  Zusammen ergibt dies 17 + 123 * 320, die Umwandlung zweidimensionaler Koordinaten in eindimensionale. <br><br>  Wenn ich mir jetzt anschaue, was auf dem Bildschirm passiert, kann ich mir leicht vorstellen, wie ich dies implementieren könnte, wenn auch nicht mit 128 Bytes, auch wenn es nicht 100% ähnlich ist, aber ich könnte.  Und vor 20 Jahren konnte ich es nicht, obwohl ich alle Werkzeuge, die ich verwendete, aus staubigen Regalen holte und nicht im Internet surfen musste, um zu verstehen, wie es funktioniert.  Daher ist dies zuallererst ein Kontext, ein Verständnis dessen, was geschieht, und daher steht die Frage nach Tricks und WIE dies zu tun ist an zweiter Stelle. <br><br>  Was sehen wir: <br><br><ol><li>  5 Zeilen des Pentagramms.  Dies sind nicht unbedingt direkte, untrennbare Linien nach allen Kanonen.  Wir sehen nur die allgemeine Figur ohne Details </li><li>  Der Flammeneffekt, der aus zwei wichtigen Teilen besteht: einer korrekt ausgewählten Palette und einem Algorithmus zum ständigen Ändern der Farbe von Punkten auf dem Bildschirm mit Unsicherheitselementen, wobei jedoch eine kontinuierliche Palettensequenz für benachbarte Punkte beibehalten wird.  Sie können beispielsweise den gesamten aktuellen Bildschirm berechnen, indem Sie den Durchschnitt der Werte benachbarter Pixel des vorherigen Bildschirms berechnen und an zufälligen oder nicht zufälligen Stellen, aber zufälligen oder nicht zufälligen Werten weitere „helle“ Punkte hinzufügen. Entfernen Sie sich einfach von der linearen Reihenfolge.  Eine Möglichkeit ist, <a href="https://habr.com/ru/post/435122/">wie es in DOOM gemacht wird</a> .  Das Ergebnis sollte in Form von ineinander fließenden Farben sein, von ständig auftauchenden hellen Bereichen bis hin zum Ausbleichen </li></ol><br>  Es bleibt zu verstehen, wie dies getan wurde.  Eine weitere Beschreibung ersetzt nicht das Wissen über Computerarchitektur und DOS- oder Assembler-Funktionen. Mit diesem Wissen können Sie jedoch das Wesentliche des Geschehens verstehen und sich darauf konzentrieren.  Nachdem ich mit dem Schreiben angefangen hatte, wurde mir klar, dass es sich immer noch als ausreichend detailliert herausstellte, aber ich konnte es nicht ablehnen, um nicht im Sinne der Geschichte zu verlieren. <br><br><h3>  DOS und Laden von .COM-Programmen </h3><br>  Das Programm in der <code>.com</code> Datei ist sauberer Code, keine Überschriften, Sie müssen es nur an der richtigen Stelle platzieren.  Das macht DOS, oder besser gesagt der 4Bh-Systemaufruf.  Viele Aktionen finden statt, lassen Sie uns das Ergebnis näher betrachten: <br><br><ul><li>  Alle Segmentregister CS, DS, ES, SS werden mit einem einzigen Wert geladen </li><li>  65536 Bytes sind für das gesamte Programm reserviert, genau ein Segment, auf das sich alle Segmentregister beziehen.  Die ersten 256 Bytes werden vom Systemheader PSP (Program Segment Prefix) belegt.  Bei CS: 0, dem ersten Feld der PSP, befindet sich der Befehl INT 20h, um das aktuelle Programm zu beenden und die Steuerung an den übergeordneten Prozess zu übertragen.  Das Programm selbst startet mit der Adresse CS: 100h und belegt die folgenden 128 Bytes </li><li>  Das Wort 0000h wird auf den Stapel geschoben, das SP-Register ist FFFEh.  Dies bedeutet, dass die letzten zwei Bytes in diesem Segment an der Adresse SS: FFFEh zurückgesetzt werden.  Tatsächlich ist dies die nächste Rücksprungadresse aus der Prozedur, die uns zum Beendigungsbefehl bei CS: 0 führt </li><li>  Die Register AL und AH enthalten ein Fehlerflag zum Bestimmen der Laufwerksbuchstaben aus dem ersten und zweiten Argument, wenn das Programm aufgerufen wird.  Wenn es keine Fehler gibt, sind sie 0, wenn es dann FFh gibt </li></ul><br>  Ich bin fest davon überzeugt, dass der Status der Register im Allgemeinen nicht definiert ist.  Aber in dem analysierten Code wird meiner Meinung nach eine sehr kühne Annahme über ihren Anfangszustand getroffen, insbesondere über die CX-, SI-Register und das DF-Richtungsflag.  Ich habe keine Bestätigung dafür in der Liste der Quellen gefunden, die sich oben ergeben haben, also habe ich die <a href="" rel="nofollow">MS-DOS 2.0-</a> Quellen durchgesehen: <br><br><ul><li>  Bei DF können wir davon ausgehen, dass es durch den Befehl <code>cld</code> , da dieser die Vorwärtsrichtung verwendet, bevor die Steuerung auf <code>cld</code> übertragen wird. Daher wird DF zurückgesetzt.  Obwohl <code>cld</code> an dieser Stelle nicht explizit verwendet wird, wird der Befehl zum Löschen des Richtungsflags häufig vor vielen anderen Übertragungen ausgeführt </li><li>  SI enthält 100h, da es verwendet wird, um den Offset zu bestimmen, der vom IP-Befehlszähler in das Register geladen wird </li><li>  CX ist gleich FFh, weil es als Zähler mit einem Anfangswert von 80h zum Übertragen des Inhalts der gesamten Befehlszeile verwendet wird und dementsprechend nach dem Übertragen 0 ist. Danach lädt CL als temporäre Variable FFh und setzt das Fehlerflag des Laufwerksbuchstabens in AL und AH </li></ul><br>  Es gibt keine Quellen für neuere Versionen, aber <a href="https://sourceforge.net/projects/dosbox/files/dosbox/" rel="nofollow">DOSBox-Quellen</a> : <br><br><pre> <code class="cpp hljs">reg_ax=reg_bx=<span class="hljs-number"><span class="hljs-number">0</span></span>;reg_cx=<span class="hljs-number"><span class="hljs-number">0xff</span></span>; reg_dx=pspseg; reg_si=RealOff(csip); reg_di=RealOff(sssp);</code> </pre><br>  Das heißt, es stimmt mit dem überein, was ich im MS-DOS-Quellcode (2. Version!) Gesehen habe. Sie können die Anfangswerte anderer Register sehen, hier handelt es sich um eine explizite, spezielle Initialisierung.  Für MS-DOS sind die Werte anderer Register als AX, Segment und Stack Ansätze für ihre Verwendung für andere Zwecke, dies ist kein Dogma oder Standard, daher werden sie nirgendwo erwähnt.  Andererseits wird das Ökosystem, das sich gebildet hat, und der ganze Schmerz von Microsoft, die Kompatibilität mit alten Versionen zu unterstützen und alle zufällig generierten Werte mitzureißen, ein wenig verständlich, weil Programmierer so an sie gewöhnt sind. <br><br>  Schließlich reicht uns dieses Wissen, und wir beginnen, das Programm aus den Headern wiederherzustellen: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup</code> </pre><br>  Wir bestimmen den Prozessortyp 80186, da wir den Befehl <code>outsb</code> , der nur in diesem Modell vorkommt.  Ein Codesegment und ein Einstiegspunkt in das Programm ermöglichen es dem Compiler zusammen mit der Definition des <code>tiny</code> Speichermodells, alle Offsets von Variablen und Übergängen korrekt zu berechnen.  Beim <code>tlink</code> wird der <code>tlink</code> <code>/t</code> verwendet, der bei der Ausgabe eine <code>.com</code> Datei ergibt. <br><br><h3>  Grafik und Palette </h3><br>  Um in den Grafikmodus zu wechseln, müssen Sie sich an die BIOS-Funktion wenden, für die eine Unterbrechung von 10h, AH = 0, aufgerufen wird. In AL geben wir die Kennung des gewünschten Modus ein - 13h: <br><br><pre> <code class="cpp hljs">mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h ;b0 <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Bitte beachten Sie, dass wir AH nicht berühren, wenn wir davon ausgehen, dass es gemäß den Programmladebedingungen Null gibt.  Der ausgewählte Modus entspricht einer Grafikauflösung von 320 x 200 Pixel mit einer 256-Farben-Palette.  Um einen Punkt auf dem Bildschirm anzuzeigen, müssen Sie in den Speicherbereich schreiben, der mit der Adresse A000h: 0 beginnt, wobei das Byte der Farbe entspricht.  Segmentdatenregister mit diesem Wert füllen: <br><br><pre> <code class="cpp hljs">push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h ;<span class="hljs-number"><span class="hljs-number">68</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> a0 pop es ;<span class="hljs-number"><span class="hljs-number">07</span></span> push es ;<span class="hljs-number"><span class="hljs-number">06</span></span> pop ds ;<span class="hljs-number"><span class="hljs-number">1f</span></span></code> </pre><br>  Logischerweise ist der Speicher als zweidimensionales Array organisiert, in dem Bildschirmkoordinaten angezeigt werden. 0: 0 entspricht der oberen linken Ecke.  Nach dem Umschalten des Modus wird er in der Standardpalette mit Nullen gefüllt - schwarz.  Die Formel für die Übersetzung in eine lineare Verschiebung lautet <b>X + Y * L</b> , wobei L die horizontale Auflösung ist, in unserem Fall 320. In dieser Form schreibe ich an den Stellen, an denen die Konstanten verwendet werden, wenn der Programmtext übersetzt wird, werden sie automatisch berechnet. <br><br>  Um die Palette zu ändern, greifen wir über die Eingabe- / Ausgabeports direkt auf das Gerät zu: <br><br><pre> <code class="cpp hljs">lodsb ;ac mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h ;ba c8 <span class="hljs-number"><span class="hljs-number">03</span></span> out dx, al ;ee</code> </pre><br>  Der erste Befehl lädt das bei DS: SI befindliche Datenbyte in AL.  In DS haben wir die Segmentadresse des Videospeichers geladen und wissen, dass sie mit Nullen gefüllt ist, in SI - im Allgemeinen ist mindestens 0 nicht bekannt. Es spielt für uns keine Rolle, wo immer SI angibt, dass wir mit ziemlicher Sicherheit in den Videospeicher gelangen, der belegt mit dieser auflösung 320 * 200 = 64000 bytes fast das gesamte segment.  Daher erwarten wir, dass nach diesem Befehl AL = 0 ist.  Eine Einheit wird zu SI addiert oder subtrahiert. Dies hängt von der Einstellung des DF-Richtungsflags ab.  Auch wenn dies für uns nicht besonders wichtig ist, bleiben wir in dem mit Nullen gefüllten Videospeicherbereich, egal wo sich der SI bewegt. <br><br>  Laden Sie als nächstes den DX mit der Portnummer 03C8h, deren Ausgang bestimmt, welche der 256 Farben überschrieben werden soll.  In unserem Fall ist es 0 von AL. <br><br>  Die Farbe wird in der RGB-Palette codiert. Dazu müssen Sie dreimal hintereinander einmal für jede der Komponenten auf Port 03C9h schreiben (einer mehr als 3C8h).  Die maximale Helligkeit der Komponente beträgt 63, die minimale 0. <br><br><pre> <code class="cpp hljs">inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">64</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">40</span></span> PALETTE: out dx, al ;ee inc ax ;<span class="hljs-number"><span class="hljs-number">40</span></span> outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e loop PALETTE ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-6</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">,    6  </span></span></code> </pre><br>  Erhöhen Sie DX um eins, damit es die gewünschte Portnummer hat.  CL ist unser Zykluszähler von 64, und wir gehen davon aus, dass CH = 0 ist, wie zuvor beschrieben, basierend auf den anfänglichen Ladebedingungen.  Als nächstes geben wir die erste Komponente an den Port aus - die rote, deren Helligkeit in AL gespeichert wird. In Schritt 0 ändern wir sie. Danach erhöhen wir ihre Helligkeit um eins, um sie in der nächsten Iteration anzuzeigen.  Als nächstes führen wir zwei <code>outsb</code> Befehle aus <code>outsb</code> die auf den Port schreiben, dessen Nummer in DX, dem Byte aus dem DS-Speicherbereich, enthalten ist: SI, denken Sie daran, dass wir dort Nullen haben.  SI ändert sich jedes Mal um eins. <br><br>  Sobald wir die drei Komponenten abgeleitet haben, wird der Farbnummer automatisch eine Einheit hinzugefügt.  Daher ist es nicht erforderlich, die Farbe durch Ausgabe an den 3C8h-Port neu zu definieren, wenn die Farben nach Bedarf in einer Reihe liegen.  Der <code>loop</code> reduziert CX um eins. Wenn ein Wert ungleich Null erhalten wird, springt er zum Beginn des Zyklus, bei 0 zum nächsten Befehl nach dem Zyklus. <br><br>  Insgesamt 64 Wiederholungen.  Bei jeder Wiederholung bestimmen wir für die Farbe, beginnend von 0 bis 63, die Rotkomponente mit der Helligkeit, die mit der aktuellen Farbnummer übereinstimmt.  Wir setzen die grünen und blauen Komponenten zurück, um eine solche Palette von minimaler zu maximaler roter Helligkeit zu erhalten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/py/jq/lzpyjqjyav0-x3qdl5easmdesvs.png" alt="Palette"></div><br><br><h3>  Linien </h3><br>  Richten Sie die anfänglichen Farb- und Koordinatenwerte ein: <br><br><pre> <code class="cpp hljs">LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh ;b8 <span class="hljs-number"><span class="hljs-number">3f</span></span> <span class="hljs-number"><span class="hljs-number">3f</span></span> mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bb <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span></code> </pre><br>  In AL und AH laden wir die maximal mögliche (hellste) Farbe 63 (3Fh), AX definiert zwei Punkte gleichzeitig.  BX - maximale horizontale Auflösung.  In Zukunft wird dies verwendet, um eine Zeile zu den aktuellen Koordinaten zu addieren oder von diesen zu subtrahieren.  DI - Koordinaten 64: 4, speichern Sie sie auf dem Stapel. <br><br>  <b>Zeichne die erste Linie von der oberen linken Ecke bis zum rechten Ende</b> : <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE1: stosw ;ab add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE1 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  Konfigurieren Sie den Zähler - dies ist die Anzahl der Zeilen.  Speichern Sie als nächstes das Wort (zwei Bytes) von AX unter der Adresse ES: DI.  Diese Aktion zeigt zwei Punkte auf dem Bildschirm mit der maximalen Farbe aus unserer Palette an, da der ES für den Videospeicher konfiguriert ist und bestimmte Koordinaten in DI festgelegt werden.  Nach dieser Aktion wird 2 zum DI hinzugefügt, da zwei Bytes geschrieben wurden.  Wir setzen das DF-Richtungs-Flag offensichtlich nicht und verlassen uns auf die Tatsache, dass es zurückgesetzt wird. Wir erinnern uns erneut an unsere ursprünglichen Bedingungen für das Laden des Programms.  Andernfalls würden die beiden weggenommen, was nicht erlauben würde, die gewünschte Linie zu zeichnen. <br><br>  Als nächstes ist DI = DI + BX, was einer Erhöhung der Y-Koordinate um eins entspricht.  Im Hauptteil des Zyklus werden also zwei Punkte in einer Linie gezeichnet, die X-Koordinate wird um 2 und die Y-Koordinate um 1 erhöht, und diese Aktion wird 120 Mal wiederholt. Das Bild mit dem Ergebnis ist geringfügig niedriger. <br><br>  <b>Die zweite Zeile verläuft von links oben nach oben</b> : <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">60</span></span> LINE2: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE2 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  Wir stellen die Anfangskoordinaten 64: 4 wieder her und setzen den Zähler auf 96 Wiederholungen.  Wir drucken einen Punkt, aber eine Linie unter den aktuellen Koordinaten.  Dies wird nach wie vor durch Hinzufügen eines Wertes aus BX erreicht, nur ohne die neuen Koordinaten zu speichern.  Die Konstruktion <code>[bx+di]</code> oder <code>[bx][di]</code> wird Basisadressierung mit Indexierung genannt und arbeitet auf Prozessorebene, nicht auf Übersetzerebene.  Das Standardsegmentregister bei BX ist DS.  Danach zeigen wir den zweiten Punkt an, jedoch bereits in den aktuellen Koordinaten.  DI und damit X um eins, da nur ein Byte-Übertragungsbefehl <code>stosb</code> - <code>stosb</code> .  Die letzten beiden Befehle des Zykluskörpers sind eine Erhöhung von Y um 2, für die wir wieder BX verwenden. <br><br>  Nach dem Zeichnen von zwei Linien wird das folgende Bild in der Nähe der oberen linken Ecke erhalten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/nu/fk/xvnufkuhyvi0gwqomrquixlvti8.png" alt="Zeile 1.2"></div><br><br>  Linke und obere Koordinaten, rechts von der Zeilenversatzadresse im Videospeicher.  Punkt 64: 4 wird zweimal gezogen. <br><br>  <b>Die dritte Zeile verläuft von oben nach rechts oben</b> : <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">61</span></span> LINE3: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb loop LINE3 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  DI enthält bereits den gewünschten Koordinatenwert 160: 196. Wir müssen eine Linie von oben an der Stelle zeichnen, an der die vorherige Linie geendet hat. Dabei müssen wir den Bildschirm nach oben bewegen und den gleichen Winkel beibehalten.  Dementsprechend ist der Zyklus nahezu identisch.  CX wird um 1 erhöht, da die aktuelle Y-Koordinate 2 mehr (niedriger) ist als am Ende der vorherigen Zeile. Sie wurde bereits für die nächste Iteration berechnet.  Um in die obere Ecke zu gelangen, müssen Sie daher einen zusätzlichen Schritt machen.  Die Bewegung entlang X setzt sich in derselben Richtung fort - plus eins nach jeder Iteration, und entlang Y subtrahieren wir die beiden, anstatt sie zu addieren.  Die Punkte werden in derselben Reihenfolge angezeigt, zuerst unten, dann oben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d8/bw/3f/d8bw3fucavqttjhld9wqrlqsi_s.png" alt="Zeile 3"></div><br><br>  <b>Die vierte Zeile befindet sich ganz links in der oberen rechten Ecke:</b> <br><br><pre> <code class="cpp hljs">mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf d1 <span class="hljs-number"><span class="hljs-number">99</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE4: stosw ;ab sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb(<span class="hljs-number"><span class="hljs-number">-5</span></span>) loop LINE4</code> </pre><br>  Wir sind wieder in den nötigen Koordinaten, aber dies wird anscheinend nicht verwendet, um das DF-Richtungs-Flag nicht zu ändern.  Daher werden neue Koordinaten in das DI gestellt und auf dem Stapel gespeichert. <br><br>  Weiterhin ist alles identisch mit der ersten Zeile, nur die Y-Koordinate wächst nicht, sondern nimmt ab, wir steigen auf. <br><br>  <b>Die fünfte Zeile ist horizontal:</b> <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">8f</span></span> rep stosw ;f3 ab</code> </pre><br>  Hier ist alles einfach, es wird der Mikroprozessor-Neuübertragungsmechanismus verwendet, da die horizontale Linie einer einfachen Erhöhung der Adresse jedes nächsten Punktes entspricht.  In DI wird die Adresse wiederhergestellt, die der im vorherigen Schritt gespeicherten Koordinate der linken äußersten Ecke entspricht.  Die Anzahl der Wiederholungen in CX wird festgelegt und das Wiederholungspräfix wird mit dem Wortübertragungsbefehl angewendet. <br><br>  Nach dieser Aktion haben wir ein vollständig gezeichnetes Pentagramm in der hellsten Farbe.  80 Bytes verwendet und 48 in Reserve. <br><br><h3>  Feuermagie </h3><br>  <b>Wir setzen die Randbedingungen für die Berechnungen:</b> <br><br><pre> <code class="cpp hljs">FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> ;<span class="hljs-number"><span class="hljs-number">81</span></span> fe <span class="hljs-number"><span class="hljs-number">00</span></span> fa jae NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> lodsb ;ac <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al ;<span class="hljs-number"><span class="hljs-number">0</span></span>a c0 jz NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>d</code> </pre><br>  In SI gibt es die Koordinate des aktuellen Punktes für Berechnungen. Wenn wir über die Grenzen des Bildschirms hinausgehen, führen wir keine Berechnungen mit diesem Punkt durch und fahren mit der Berechnung des nächsten Punktes fort. <br><br>  <code>lodsb</code> lädt ein Byte aus dem DS: SI-Bereich in AL, <code>lodsb</code> die Farbe des Punkts in den aktuellen Koordinaten.  Wenn es 0 ist, dann tun wir auch nichts und fahren mit dem nächsten Punkt fort. <br><br>  <b>Neue Farbberechnung</b> <br><br>  Dies ist der Hauptalgorithmus zum Ändern der Farbwerte auf dem Bildschirm, dies ist keine Flamme, dies ist die Basis dafür.  Wir berechnen Nachbarpunkte und erzielen Farbkontinuität: <br><br><pre> <code class="cpp hljs">dec ax ;<span class="hljs-number"><span class="hljs-number">48</span></span> mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">44</span></span> fe mov [si], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> ff mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">84</span></span> bf fe</code> </pre><br>  Subtrahieren Sie von AX, tatsächlich von AL, eine Einheit, die einen von Null verschiedenen Farbwert enthält, der aus den aktuellen Koordinaten erhalten wird.  Als nächstes schreiben wir den erhaltenen Wert auf alle benachbarten Punkte, relativ zur aktuellen Koordinate, das heißt ein bisschen von ihnen, basierend auf unserer Palette. <br><br>  Da nach <code>lodsb</code> der SI-Wert um eins ansteigt und nicht mehr dem Punkt entspricht, dessen Farbe wir in AL lesen, muss dieser angepasst werden.  Beachten Sie, dass <code>stosb</code> Byte-Übertragungsbefehle mehr verwendet werden, sondern <code>mov</code> , um die Adresse zu bestimmen, an der der Wert platziert wird.  Wenn wir akzeptieren, dass die aktuellen Koordinaten X: Y sind, für sie SI-1, dann: <br><br><ul><li>  <code>mov [si-2], al</code> - <code>mov [si-2], al</code> eine neue Farbe am Punkt X-1: Y links von der aktuellen auf.  2 wird aus dem oben beschriebenen Grund von SI subtrahiert, da bereits eine zusätzliche Einheit hinzugefügt wurde </li><li>  <code>mov [si], al</code> eine neue Farbe am Punkt X + 1: Y rechts von der aktuellen auf.  SI hat bereits X + 1 </li><li>  <code>mov [bx+si-1], al</code> - Schreiben einer neuen Farbe an den Punkt X: Y + 1 unter der aktuellen.  Verwenden Sie wieder BX für Y + 1 </li><li>  <code>mov [si-1-1*320], al</code> - Schreiben einer neuen Farbe an den Punkt X: Y-1 über der aktuellen.  Wir können BX nicht verwenden, da wir die Koordinate entfernen müssen. Aufgrund der Prozessorarchitektur ist dies in dieser Form nicht möglich. Daher wird eine Konstante gemäß der Koordinatenreduktionsformel verwendet </li></ul><br>  Das Segmentregister ist DS, das standardmäßig mit SI und BX verwendet wird. <br><br>  Nirgendwo wird die Situation überprüft, wenn der Punkt den Rand des Bildschirms berührt.  Dies kann nicht zu einem Ausfall führen, da wir uns immer innerhalb der Grenzen des Videosegments befinden.  Ein benachbarter Punkt kann entweder in einen nicht gemeldeten Bereich mit Adressen über 64.000 fallen oder auf eine benachbarte Linie, die uns nicht schadet und sogar ein wenig hilft, wie aus der weiteren Beschreibung hervorgeht. <br><br>  <b>Dieselbe Magie, die Berechnung der Koordinaten des nächsten Punktes</b> <br><br><pre> <code class="cpp hljs">NEXT_PIXEL: add si, dx ;<span class="hljs-number"><span class="hljs-number">03</span></span> f2 inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> jnz FLAME ;<span class="hljs-number"><span class="hljs-number">75</span></span> e3(<span class="hljs-number"><span class="hljs-number">-29</span></span>)</code> </pre><br>  Gehen wir noch ein bisschen zurück, wir haben den anfänglichen SI-Wert nirgendwo speziell festgelegt und in DX haben wir immer noch die Nummer des Ausgabe-Eingangsports, den wir für die Palette verwendet haben.  Wir führen nur drei einfache Aktionen durch: SI = SI + DX. Dies setzt natürlich neue Koordinaten. Welche?  DX = DX + 1 und wenn DX nicht gleich 0 ist, dann zurück zum Basisalgorithmus zum Erhalten und Berechnen benachbarter Punkte, das heißt, ist DX eine Art Zähler? <br><br>  Wir wissen, dass wir alle Punkte umgehen und die Helligkeitsänderungen ihrer Nachbarn berechnen müssen.  Wenn Sie dies in einer Reihe tun, erhalten Sie wahrscheinlich einen statischen Gradienten, vielleicht nicht ganz gleichmäßig, aber unverändert um unsere Linien.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir kennen die Größe unseres Bildschirms und wissen, wie viele Punkte wir benötigen, aber hier vernachlässigen wir sie fast, genauer gesagt, wählen Sie den Schlusswert 65536 anstelle des exakten 64000. DX ist wirklich ein Zähler, nur 65536. Aber warum ist sein Anfangswert nicht wichtig und warum nehmen wir Ist der Endwert größer als die Gesamtpunktzahl auf dem Bildschirm? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weil wir Punkte nicht hintereinander und nicht alle umgehen. Jede nachfolgende lineare Koordinate ist um den Wert von DX größer als die vorherige. Das heißt, in SI die Summe der DX-Elemente einer einfachen arithmetischen Folge: 0,1,2,3,4,5,6, ..., 362,363, ..., 65535. Dies gibt uns bereits Nichtlinearität, wenn Sie mit SI = 0 und DX = 0 beginnen, dann erhalten wir in SI: 0,1,3,4,6,10,15,21, ..., 65341,65703, ..., 2147450880.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist aber noch nicht alles, da die SI-Dimension 16 Bit beträgt, wir keinen Wert größer als 65535 erhalten können, ein Überlauf auftritt und der Rest in SI modulo 65536 bleibt. Die lineare Koordinatenberechnungsformel hat die Form SI = (SI + DX) MOD 65536, Dies unterbricht die kontinuierliche Reihenfolge vollständig: 0,1,3,4,6,10,15,21, ..., 65341,167,530,894, ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun erinnern wir uns, dass SI in keiner Weise initialisiert wird, das heißt, wenn wir das nächste Mal zu diesem Zyklus zurückkehren dann fangen wir bei der Koordinate an, bei der wir aufgehört haben, und nicht bei 0 oder einer bestimmten. Dies wird unsere Sequenz chaotisch machen - die Anzahl der sich nicht wiederholenden Elemente erhöhen. Andernfalls wäre die Durchquerung der Punkte immer gleich, wenn auch nicht linear. Ein Flammeneffekt wäre vorhanden, aber nicht so deutlich. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir über den Trick sprechen, dann ist dies genau das Richtige.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DX beginnt mit Ausnahme der ersten Verwendung immer implizit bei 0 als Ergebnis eines Überlaufs </font></font><code>inc dx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein wenig mehr Chaos bringen unsere Grenzwerte, da für SI&gt; = 64000 keine Punkte gezogen werden und die Ausgabereihenfolge leicht verwirrt ist. Und das Überspringen aller Punkte mit einem Nullwert führt in den ersten Sekunden des Programms zum Zündeffekt. Dies liegt daran, dass der vollständige Zyklus schneller endet, da die meisten Punkte nicht verarbeitet werden. Da die Helligkeit für die meisten Punkte jedoch nur zunimmt, können sie nicht durch benachbarte Dimmerabschnitte verdeckt werden. Sie sind einfach noch nicht vorhanden und es werden keine Nullwerte berechnet. Nachdem die vollständig schwarzen Bereiche verschwunden sind, wird das Gleichgewicht hergestellt, einige Bereiche erhöhen die Helligkeit und einige verringern sich.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infolgedessen können wir nicht mehr über eine Reihenfolge oder einen Gradienten sprechen. Die Punkte werden jedes Mal in einer neuen Reihenfolge umgangen, einschließlich mehrmaliger Wiederholung oder Überspringen. </font><font style="vertical-align: inherit;">Dies führt zur Bildung von Regionen unterschiedlicher Helligkeit, die miteinander vermischt sind und sich bei jeder neuen Iteration ändern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber das ist noch nicht alles, wenn Sie keine neuen hellen Punkte hinzufügen, werden sie am Ende alle zurückgezahlt. </font><font style="vertical-align: inherit;">Nachdem der DX seinen Maximalwert erreicht hat, zeichnen wir erneut fünf helle Linien und zählen erneut alle Punkte auf dem Bildschirm:</font></font><br><br><pre> <code class="cpp hljs">in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h ;e4 <span class="hljs-number"><span class="hljs-number">60</span></span> cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h ;<span class="hljs-number"><span class="hljs-number">3</span></span>c <span class="hljs-number"><span class="hljs-number">01</span></span> jne LINES ;<span class="hljs-number"><span class="hljs-number">75</span></span> a5(<span class="hljs-number"><span class="hljs-number">-91</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber vorher haben wir von Port 60h gelesen, das ist die Tastatur, der Scan-Code der zuletzt gedrückten Taste. </font><font style="vertical-align: inherit;">Für ESC ist es gleich 1. Wenn die ESC-Taste gedrückt wurde, bewegen wir uns in Richtung Ausgang.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertigstellung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist zu beachten, dass Sie während der Aktualisierung des aktuellen Bildschirms, die einige Zeit in Anspruch nimmt, das Programm nicht beenden können, dh die Reaktion auf ESC verzögert sich. Wenn wir während des Wartens und nach dem Drücken einer Taste im Programm bleiben, kann nur der letzte Scan-Code vom Port gelesen werden. Eine weitere Sache ist, dass wir die DOS- und BIOS-Systemfunktionen dafür nicht ersetzen oder verwenden, unabhängig davon, was wir vom Port lesen. Die gedrückte Taste befindet sich in einem Umlaufpuffer und wird wahrscheinlich vom nächsten Programm gelesen, nachdem unser Intro abgeschlossen ist, höchstwahrscheinlich die Datei Manager oder </font></font><code>command.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies wird zu seiner Verarbeitung führen, zum Beispiel wird Volkov Commander auf ESC seine Panels verstecken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bleibt zu Textmodus 3 zurückzukehren:</font></font><br><br><pre> <code class="cpp hljs">mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h ;b8 <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird davon ausgegangen, dass wir uns vor dem Start des Programms in diesem Modus befanden, aber im Allgemeinen ist dies möglicherweise nicht der Fall. </font><font style="vertical-align: inherit;">Hier aktualisieren wir die gesamte AXT, da wir sicher sind, dass AH keine 0 enthält. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können Sie beenden:</font></font><br><br><pre> <code class="cpp hljs">retn ;c3</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein Near-Exit-Befehl aus einer Prozedur, die den Wert des dort platzierten Wortes (zwei Bytes) vom Stapel nimmt und in den IP-Befehlszähler lädt. </font><font style="vertical-align: inherit;">Unter den Anfangsbedingungen haben wir Nullen im Stapel, dies führt uns zur Adresse CS: 0, wo wir den Befehlscode kennen </font></font><code>int 20h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Herunterfahren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und 7 Bytes für das Urheberrecht:</font></font><br><br><pre> <code class="cpp hljs">dd <span class="hljs-number"><span class="hljs-number">0</span></span>h ;<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> ;<span class="hljs-number"><span class="hljs-number">4</span></span>d <span class="hljs-number"><span class="hljs-number">63</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>d end</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können sagen, dass es noch einen Platz gibt, den ich für eine strengere Initialisierung ausgeben würde, aber da alles in der modernen DOSBox funktioniert, hat der Autor wahrscheinlich alles richtig gemacht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen wir noch einmal durch:</font></font><br><br><ol><li>    ,        </li><li>  4    ,           :  X+1  Y+2,  X+2  Y+1.         ,       .    ,          </li><li>       SI=(SI+DX) MOD 65536,     DX ,     ,      ,     SI.         1.   65536 ,    ,     .     ,         — <code>add si, dx</code>  <code>inc dx</code> ,            ,       </li><li>     ESC  ,           </li></ol><br><div class="spoiler"> <b class="spoiler_title">  .</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h pop es push es pop ds lodsb mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h out dx, al inc dx mov cl, <span class="hljs-number"><span class="hljs-number">040</span></span>h PALETTE: out dx, al inc ax outsb outsb loop PALETTE LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE1: stosw add di, bx loop LINE1 pop di mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> LINE2: mov [bx+di], al stosb add di, bx add di, bx loop LINE2 mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> LINE3: mov [bx+di], al stosb sub di, bx sub di, bx loop LINE3 mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE4: stosw sub di, bx loop LINE4 pop di mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> rep stosw FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> jae NEXT_PIXEL lodsb <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al jz NEXT_PIXEL dec ax mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al mov [si], al mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al NEXT_PIXEL: add si, dx inc dx jnz FLAME in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h jne LINES mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h retn dd <span class="hljs-number"><span class="hljs-number">0</span></span>h db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> end</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Kompilieren müssen Sie Folgendes ausführen: </font></font><code>tasm pentagra.asm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>tlink /t pentagra.obj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich weiß nicht, ob WAS und WIE es für Sie realisiert wurde, aber es scheint mir, dass ein schöner und ungewöhnlicher Ansatz verwendet wurde, um den Flammeneffekt zu erzeugen. </font><font style="vertical-align: inherit;">Obwohl ich nichts zu vergleichen habe, haben es vielleicht alle getan, und jetzt können Sie dasselbe tun.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482826/">https://habr.com/ru/post/de482826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482814/index.html">Gesamtansicht des Baumes, Implementierung und nicht nur</a></li>
<li><a href="../de482816/index.html">Arthur Khachuyan: Künstliche Intelligenz im Marketing</a></li>
<li><a href="../de482818/index.html">Kurze Ergebnisse der Lektüre des Berichts über 1C DSS für Infostart 2019</a></li>
<li><a href="../de482820/index.html">Bild-Upload-Optimierung</a></li>
<li><a href="../de482822/index.html">Wie werden Kunsttests für Spiele durchgeführt?</a></li>
<li><a href="../de482832/index.html">Zukunftsökonomie für Physiker</a></li>
<li><a href="../de482834/index.html">Die statische Eingabe erfordert nicht unbedingt Zeremonien</a></li>
<li><a href="../de482838/index.html">ONYX BOOX Note 2 Test - ein Großbildleser mit maximaler Leistungsfähigkeit</a></li>
<li><a href="../de482840/index.html">UTorrent sequentieller Download in 2 Klicks</a></li>
<li><a href="../de482842/index.html">Mash ist eine Programmiersprache, die sich selbst kompiliert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>