<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ€ ğŸ ğŸ§¤ Menggergaji data dengan nyaman ğŸ¤œ ğŸŒ» ğŸ¦ƒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari yang baik 

 Dalam praktik nyata, Anda sering menghadapi tugas yang jauh dari algoritma ML kompleks, tetapi pada saat yang sama tidak kalah penti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggergaji data dengan nyaman</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438556/"><img src="https://habrastorage.org/webt/im/nm/mx/imnmmxqmywsjq2wirence45dz4g.jpeg" alt="gambar"><br><br>  Hari yang baik <br><br>  Dalam praktik nyata, Anda sering menghadapi tugas yang jauh dari algoritma ML kompleks, tetapi pada saat yang sama tidak kalah penting dan mendesak untuk bisnis. <br>  Mari kita bicara tentang salah satunya. <br><br>  Tugas bermuara pada mendistribusikan (menggergaji, rasplitovat - jargon bisnis tidak habis-habisnya) data dari beberapa tabel target dengan agregat (nilai agregat) pada tabel rincian lebih rinci. <br><br>  Misalnya, departemen komersial perlu memecah rencana tahunan yang disepakati di tingkat merek - secara rinci, ke produk, bagi pemasar untuk memecah anggaran pemasaran tahunan menurut negara, departemen perencanaan dan ekonomi untuk memecah biaya bisnis umum oleh pusat pertanggungjawaban keuangan, dll.  dll. <br><br>  Jika Anda merasa bahwa tugas-tugas seperti ini sudah menjulang di depan Anda di cakrawala atau sudah merawat mereka yang terkena tugas-tugas tersebut, maka saya meminta kucing. <br><a name="habracut"></a><br>  Pertimbangkan contoh nyata: <br><br>  Mereka menurunkan rencana penjualan sebagai tugas seperti pada gambar di bawah ini (saya sengaja membuat contoh disederhanakan, pada kenyataannya - spanduk excel 100-200 mb). <br><br>  Penjelasan judul: <br><br><ul><li>  pos_terr-wilayah (wilayah) outlet </li><li>  pos_fo - distrik federal dari outlet (misalnya, Central Federal District-Central Federal District) </li><li>  product_brend - merek produk </li><li>  product_class - kelas produk </li><li>  plan.sales adalah rencana penjualan untuk apa pun. </li></ul><br><img src="https://habrastorage.org/webt/wc/2t/n5/wc2tn5wplux5kjawucs4gpl5ey8.png" alt="gambar"><br><br>  Dan mereka meminta, misalnya, untuk memecahkan tabel besar mereka (dalam kerangka contoh anak-anak kita, tentu saja lebih sederhana) - ke saluran penjualan.  Untuk pertanyaan - sesuai dengan logika apa yang harus dipecah, saya mendapatkan jawabannya: "tetapi ambil statistik penjualan aktual untuk kuartal ke-4 tahun ini dan itu, dapatkan bagian aktual dari saluran dalam% untuk setiap baris rencana dan uraikan bagian-bagian dari garis rencana". <br>  Sebenarnya, ini adalah jawaban paling sering dalam tugas-tugas seperti itu ... <br><br>  Sejauh ini, semuanya tampak cukup sederhana. <br><br>  Saya mendapatkan fakta ini (lihat gambar di bawah): <br><br><ul><li>  pos_channell - saluran penjualan (atribut target untuk paket tersebut) </li><li>  fact.sales - penjualan aktual sesuatu. </li></ul><br><img src="https://habrastorage.org/webt/8t/uo/pn/8tuopnzhdexvdz9cq2c6sqftgxc.png" alt="gambar"><br><br>  Berdasarkan pendekatan yang diperoleh untuk "menggergaji" pada contoh baris pertama dari rencana, kami akan memecahnya berdasarkan fakta seperti ini: <br><br><img src="https://habrastorage.org/webt/b9/ib/q0/b9ibq06zbezjvfhsf5gxkeoba4s.png" alt="gambar"><br><br>  Namun, jika kita membandingkan fakta dengan rencana untuk seluruh pelat untuk memahami apakah semua garis rencana dapat â€œdipotongâ€ secara memadai, kita mendapatkan gambar berikut: (hijau - semua atribut dari garis rencana bertepatan dengan fakta, sel kuning tidak cocok). <br><br><img src="https://habrastorage.org/webt/tp/vm/ta/tpvmtayhezx1cou7359wqzmds3c.png" alt="gambar"><br><br><ul><li>  Pada baris pertama rencana, semua bidang ditemukan sepenuhnya dalam fakta. </li><li>  Pada baris kedua dari rencana, wilayah yang sesuai tidak ditemukan dalam kenyataan </li><li>  Garis ke-3 dari rencana itu tidak cukup dalam fakta merek </li><li>  Baris ke-4 dari rencana itu tidak cukup dalam kenyataan wilayah dan distrik federal </li><li>  Garis kelima dari rencana tersebut sebenarnya tidak memiliki merek dan kelas. </li></ul><br>  Seperti Panikovsky berkata: "Melihat Syura, melihat - mereka adalah emas ..." <br><br><img src="https://habrastorage.org/webt/m3/v0/ig/m3v0ig5ao9agopnt9-7tthegaiu.jpeg" alt="gambar"><br><br>  Saya pergi ke pelanggan bisnis dan mengklarifikasi contoh baris ke-2, pendekatan apa yang dia lihat untuk situasi seperti itu? <br><br>  Saya mendapatkan jawabannya: "untuk kasus-kasus ketika tidak mungkin untuk menghitung pangsa saluran untuk merek No. 2 di wilayah Smolensk (dengan mempertimbangkan fakta bahwa kami memiliki wilayah Smolensk di Distrik Federal Tengah - Distrik Federal Tengah) - kemudian pecahkan garis ini sesuai dengan struktur saluran di seluruh Distrik Federal Pusat!" <br><br>  Yaitu, untuk {wilayah Smolensk + brand_2} kami mengumpulkan fakta di tingkat Distrik Federal Pusat dan memecah sesuatu di wilayah Smolensk seperti ini: <br><br><img src="https://habrastorage.org/webt/2t/pf/i1/2tpfi18n14-qytt76pydyjjwnfs.png" alt="gambar"><br><br>  Kembali dan mencerna apa yang saya dengar, saya mencoba untuk menggeneralisasi ke heuristik yang lebih universal: <br>  Jika tidak ada data di tingkat detail tabel fakta saat ini, maka sebelum menghitung saham untuk bidang target (saluran penjualan), kami menggabungkan tabel fakta hingga atribut hierarki di atas. <br><br>  Artinya, jika bukan untuk wilayah tersebut, maka kami mengumpulkan fakta ke tingkat hierarki yang lebih tinggi - berbagi untuk Distrik Federal Pusat yang sama seperti dalam rencana.  Jika tidak untuk merek, maka dalam hierarki di atas ada kelas produk - sesuai dengan itu kami menceritakan kembali saham untuk kelas yang sama dan seterusnya. <br><br>  Yaitu  kami menggabungkan rencana dan fakta pada bidang kopling yang kami pertimbangkan bagiannya dalam fakta dan pada setiap iterasi sesuai dengan rencana yang tidak didistribusikan yang tersisa, kami berturut-turut mengurangi komposisi bidang kopling. <br><br>  Pola distribusi data tertentu sudah muncul di sini: <br><br><ol><li>  Kami mendistribusikan rencana sebenarnya berdasarkan pada kebetulan yang lengkap dari bidang yang sesuai </li><li>  Kami mendapatkan paket yang rusak (kami mengakumulasikannya di hasil antara) dan rencana yang tidak terputus (tidak semua lini cocok) </li><li>  Kami mengambil rencana yang tidak terputus dan membaginya sebenarnya ke tingkat hierarki yang lebih tinggi (mis., Kami mengabaikan bidang penggandaan 2 tabel ini dan menggabungkan fakta tanpa bidang ini untuk menghitung bagian) </li><li>  Kami mendapatkan paket yang rusak (kami menambahkannya ke hasil antara) dan paket yang tidak terputus (tidak semua baris cocok) </li><li>  Dan kami mengulangi langkah yang sama sampai tidak ada rencana yang "tidak terpecahkan". </li></ol><br>  Secara umum, tidak ada yang mewajibkan kami untuk secara konsisten menghapus bidang halangan hanya dalam hierarki.  Misalnya, kami telah menghapus merek dan wilayah dari bidang halangan dan mendistribusikan rencana yang tersisa dengan: product_class (hierarki di atas merek) + Fed.krug (hierarki di atas wilayah).  Dan masih punya keseimbangan rencana yang belum teralokasi. <br><br>  Selanjutnya, kami dapat menghapus dari bidang kopling baik kelas produk atau distrik federal, seperti  mereka tidak lagi tertanam dalam hierarki masing-masing. <br><br>  Mempertimbangkan bahwa ada lusinan bidang dalam tabel tersebut - hingga satu juta melakukan manipulasi dengan tangan Anda - tugasnya bukanlah yang paling menyenangkan. <br><br>  Dan mengingat bahwa tugas-tugas semacam ini datang kepada saya secara teratur pada akhir setiap tahun (menyetujui anggaran untuk tahun berikutnya di dewan direksi), Anda harus menerjemahkan proses ini ke dalam beberapa jenis templat universal yang fleksibel. <br><br>  Dan karena sebagian besar waktu saya bekerja dengan data melalui R - implementasinya juga sama. <br><br>  Pertama, kita perlu menulis fungsi sulap universal yang akan mengambil tabel dasar (basetab) dengan data untuk perincian (dalam contoh kita, rencana) dan tabel untuk menghitung pembagian (sharetab) berdasarkan di mana kita akan "melihat" data (dalam contoh kita, fakta).  Tetapi fungsi tersebut juga harus memahami apa yang perlu dilakukan dengan objek-objek ini, sehingga fungsi tersebut masih akan menerima vektor nama bidang dari kopling (merge.vrs) - yaitu.  bidang-bidang yang secara identik diberi nama di kedua tabel dan akan memungkinkan kami untuk menghubungkan satu tabel dengan yang lain dengan bidang-bidang ini tempat kerjanya (mis., gabung dengan benar).  Juga, fungsi tersebut harus memahami kolom tabel dasar mana yang harus dimasukkan ke dalam distribusi (basetab.value) dan berdasarkan pada bidang mana untuk menghitung share (sharetab.value).  Nah, dan yang paling penting - apa yang harus diambil untuk bidang yang dihasilkan (sharetab.targetvars), dalam kasus kami, kami ingin merinci rencana melalui saluran penjualan dari fakta. <br><br>  Omong-omong, variabel sharetab.targetvars ini tidak acak dalam jamak saya - ini mungkin bukan satu bidang tetapi vektor nama bidang, untuk kasus-kasus ketika Anda perlu menambahkan bukan satu bidang ke tabel dasar dari tabel bagikan tetapi beberapa sekaligus (misalnya, berdasarkan fakta, Anda tidak dapat membagi rencana hanya melalui saluran penjualan tetapi juga dengan nama produk yang termasuk dalam merek). <br><br>  Ya, dan satu lagi syarat :) fungsi saya harus sebagai lokalistis dan mudah dibaca, tanpa bangunan bertingkat di 2 layar (saya benar-benar tidak suka fungsi besar). <br><br>  Dalam kondisi terakhir, paket dplyr populer cocok senyaman mungkin, dan mempertimbangkan bahwa operator pipeline harus memahami nama tekstual dari bidang yang telah diturunkan ke fungsi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">evaluasi Standart</a> bukan tanpa. <br><br>  Ini bayi ini (tidak termasuk komentar internal): <br><br><pre><code class="plaintext hljs">fn_distr &lt;- function(sharetab, sharetab.value, sharetab.targetvars, basetab, basetab.value, merge.vrs,level.txt=NA) { # sharetab - =   # sharetab.value -            - # sharetab.targetvars -      -          # basetab - =      # basetab.value -         # merge.vrs -    2-  # level.txt -    .       (     merge.vrs) require(dplyr) sharetab.value &lt;- as.name(sharetab.value) basetab.value &lt;- as.name(basetab.value) if(is.na(level.txt )){level.txt &lt;- paste0(merge.vrs,collapse = ",")} result &lt;- sharetab %&gt;% group_by(.dots = c(merge.vrs, sharetab.targetvars)) %&gt;% summarise(sharetab.sum = sum(!!sharetab.value)) %&gt;% ungroup %&gt;% group_by(.dots = merge.vrs) %&gt;% mutate(sharetab.share = sharetab.sum / sum(sharetab.sum)) %&gt;% ungroup %&gt;% right_join(y = basetab, by = merge.vrs) %&gt;% mutate(distributed.result = !!basetab.value * sharetab.share, level = level.txt) %&gt;% select(-sharetab.sum,-sharetab.share) return(result) }</code> </pre> <br>  Pada output, fungsi harus mengembalikan data.rangka penyatuan dua tabel dengan garis-garis rencana + fakta di mana dimungkinkan untuk membagi rencana pada versi saat ini dari bidang kopling, dan dengan garis asli rencana (dan fakta kosong) di garis di mana rencana tidak dapat dibagi pada iterasi saat ini. <br><br>  Artinya, hasil yang dikembalikan oleh fungsi setelah iterasi pertama (melanggar garis pertama rencana untuk wilayah Yaroslavl) akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/zr/jy/nz/zrjynzehck-sb3mv1bysenaixde.png" alt="gambar"><br><br>  Selanjutnya, hasil ini dapat diambil dengan didistribusikan non-kosong. Hasil ke dalam hasil kumulatif dan dengan kosong (NA) didistribusikan. Hasil - kirim ke iterasi khas berikutnya, tetapi dipecah oleh saham pada tingkat hierarki yang lebih tinggi. <br><br>  Semua pesona dan semua kemudahan adalah bahwa pekerjaan berjalan dengan jenis blok yang sama dan satu fungsi universal, semua yang diperlukan pada setiap langkah (iterasi) adalah untuk memperbaiki penggabungan vektor. <br><br><img src="https://habrastorage.org/webt/rb/7x/hb/rb7xhby_9ztkha0hwfjfysslxaq.jpeg" alt="gambar"><br><br>  Ya, saya hampir lupa nuansa kecil: jika terjadi kesalahan dan pada akhirnya kami mendapatkan rencana yang rusak yang secara total tidak akan sama dengan rencana sebelum kerusakan - akan sulit untuk melacak di mana iterasi semuanya berjalan salah. <br><br>  Oleh karena itu, kami menyediakan setiap iterasi dengan checksum: <br><br><pre> <code class="plaintext hljs">(_)-(___ )-(___.)=0</code> </pre> <br>  Sekarang mari kita coba jalankan contoh kita melalui template distribusi dan lihat apa yang kita dapatkan di output. <br><br>  Pertama, dapatkan data sumber: <br><br><pre> <code class="plaintext hljs">library(dplyr) plan &lt;- data_frame(pos_terr = c(" ", " ", " ", " ", " "), pos_fo = c("", "", "", "", ""), product_brend = c("brend_1", "brend_2", "brend_3", "brend_4", "brend_5"), product_class = c("class_1", "class_1", "class_2", "class_2", "class_3"), plan.sales = c(100, 200, 300, 400, 500)) fact &lt;- data_frame(pos_terr = c(" ", " ", " ", " ", " "," ", " ", " ", " ", " "), pos_fo = c("", "","","", "", "", "", "", "", ""), product_brend = c("brend_1", "brend_1", "brend_2", "brend_2","brend_2", "brend_4", "brend_4", "brend_1", "brend_2", "brend_4"), product_class = c("class_1", "class_1", "class_1","class_1","class_1", "class_2", "class_2", "class_1", "class_1", "class_2"), pos_channell = c("", "", "","", "", "", "", "", "", ""), fact.sales = c(16.38, 11.64, 30.73,60, 20, 6.40, 26.49, 46.63, 65.96, 98.81)) &lt;/soure&gt;      (   )     . &lt;source&gt; plan.remain &lt;- plan result.total &lt;- data_frame()</code> </pre><br>  <b>1. Kami mendistribusikan oleh Terr, FD (distrik federal), merek, kelas</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_terr","pos_fo","product_brend", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) #     -      plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) #            =    cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre> <br><img src="https://habrastorage.org/webt/84/zv/zq/84zvzqtilnk4mbdvkntjpf43lls.png" alt="gambar"><br><br>  <b>2. Kami mendistribusikan berdasarkan pho, merek, kelas (yaitu, kami meninggalkan wilayah sebenarnya)</b> <br><br>  Satu-satunya perbedaan dari blok pertama adalah mereka sedikit menyingkat merge.fields dengan menghapus pos_terr di dalamnya <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_fo","product_brend", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  <b>3. Bagikan berdasarkan pho, kelas</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_fo", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  <b>4. Bagikan berdasarkan kelas</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c( "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre> <br><img src="https://habrastorage.org/webt/fe/-q/nd/fe-qnd2szmr7giomwxnliujddha.png" alt="gambar"><br><br>  <b>5. Mendistribusikan oleh FD</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c( "pos_fo") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  Seperti yang Anda lihat, tidak ada rencana "tidak-gergajian" yang tersisa dan aritmatika dari rencana yang didistribusikan sama dengan yang asli. <br><br><img src="https://habrastorage.org/webt/bb/cz/-e/bbcz-enxlpsnwnji6atftwle1tg.png" alt="gambar"><br><br>  Dan inilah hasilnya dengan saluran penjualan (di kolom kanan, fungsinya menampilkan bidang untuk penggandaan / agregasi apa, sehingga nantinya kita bisa memahami dari mana asal distribusi ini): <br><br><img src="https://habrastorage.org/webt/l_/3t/fg/l_3tfgj9v2hvsflh_q18o8l2cbo.png" alt="gambar"><br><br>  Itu saja.  Artikel itu tidak terlalu kecil, tetapi ada lebih banyak teks penjelasan daripada kode itu sendiri. <br><br>  Saya harap pendekatan yang fleksibel ini akan menghemat waktu dan saraf bukan hanya untuk saya :-) <br><br>  Terima kasih atas perhatian anda </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438556/">https://habr.com/ru/post/id438556/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438544/index.html">Kami menonton film di rumah: 10 materi tentang membangun teater rumah dan memilih peralatan</a></li>
<li><a href="../id438546/index.html">Analisis pendekatan pengikatan modul di Node.js</a></li>
<li><a href="../id438548/index.html">Lombok, sources.jar dan debug nyaman</a></li>
<li><a href="../id438550/index.html">Manifes lain</a></li>
<li><a href="../id438554/index.html">Mengelola keadaan dan acara antar komponen di GameObject</a></li>
<li><a href="../id438560/index.html">Menulis XGBoost dari awal - bagian 1: pohon keputusan</a></li>
<li><a href="../id438562/index.html">Menulis XGBoost dari awal - bagian 2: meningkatkan gradien</a></li>
<li><a href="../id438566/index.html">Kasus Mikroprosesor Apple Strange A12X</a></li>
<li><a href="../id438568/index.html">Tentang komputer kuantum: bagaimana berbagai negara mengembangkan teknologi ini</a></li>
<li><a href="../id438570/index.html">CS Center Kompetisi Malam Tahun Baru 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>