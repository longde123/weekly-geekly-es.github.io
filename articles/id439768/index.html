<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¼â€âœˆï¸ ğŸ‘³ âœ‹ğŸ¼ Bagaimana cara kerja barcode? ğŸ¤¦ğŸ» ã€½ï¸ â˜ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai semuanya! 

 Setiap orang menggunakan barcode saat ini, kebanyakan tanpa memperhatikan hal ini. Ketika kami membeli bahan makanan di toko, pengena...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara kerja barcode?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439768/">  Hai semuanya! <br><br>  Setiap orang menggunakan barcode saat ini, kebanyakan tanpa memperhatikan hal ini.  Ketika kami membeli bahan makanan di toko, pengenal mereka dapatkan dari barcode.  Ini juga sama dengan barang di gudang, parsel pos dan sebagainya.  Tetapi tidak banyak orang yang tahu, bagaimana cara kerjanya. <br><br>  Apa yang 'di dalam' barcode, dan apa yang dikodekan pada gambar ini? <br><br><img src="https://habrastorage.org/webt/zg/gi/wt/zggiwtxnuelznl9cq6u9jzcio5m.jpeg"><br><br>  Mari kita mencari tahu, dan juga mari kita menulis bar decoder kita sendiri. <a name="habracut"></a><br><br><h2>  Pendahuluan </h2><br>  Menggunakan barcode memiliki sejarah panjang.  Upaya pertama untuk membuat otomatisasi dilakukan pada tahun 50-an, paten untuk sistem pembacaan kode diberikan.  David Collins, yang bekerja di Pennsylvania Railroad, memutuskan untuk mempermudah proses penyortiran mobil.  Idenya jelas - untuk menyandikan pengidentifikasi mobil dengan garis warna yang berbeda, dan membacanya menggunakan sel foto.  Pada tahun 1962 kode semacam itu menjadi standar oleh Association of American Railroads.  (sistem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KarTrak</a> ).  Pada tahun 1968 lampu diganti oleh laser, itu memungkinkan untuk meningkatkan akurasi dan mengurangi ukuran pembaca.  Pada tahun 1973, Kode Produk Universal dikembangkan, dan pada tahun 1974 produk bahan makanan pertama (permen karet Wrigley - jelas di Amerika Serikat;) dijual.  Pada tahun 1984, bagian ketiga dari semua toko telah menggunakan barcode, di negara lain kemudian menjadi populer. <br><br>  Ada banyak jenis barcode yang berbeda untuk aplikasi yang berbeda, misalnya, string "12345678" dapat dikodekan dengan cara ini (dan tidak semuanya): <br><br><img src="https://habrastorage.org/webt/gf/uo/ef/gfuoefu3nglocmhctpw_z8ivbpe.png"><br><br>  Mari kita mulai analisis.  Semua informasi di bawah ini adalah tentang tipe "Code-128" - hanya karena prinsipnya mudah dipahami.  Mereka yang ingin menguji mode lain, dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">generator barcode online</a> dan menguji jenis lain sendiri. <br><br>  Pada pandangan pertama, sebuah barcode terlihat seperti kumpulan angka acak, tetapi sebenarnya strukturnya terorganisasi dengan baik: <br><br><img src="https://habrastorage.org/webt/rx/ag/qf/rxagqfppyrtszrl7ldjku2lekg8.jpeg"><br><br>  1 - Ruang kosong, diperlukan untuk menentukan posisi kode mulai. <br>  2 - Mulai simbol.  Tiga jenis Code-128 tersedia (disebut A, B dan C), dan simbol awal masing-masing dapat berupa 11010000100, 11010010000 atau 11010011100.  Untuk jenis ini, tabel penyandian berbeda (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi Code_128 untuk lebih jelasnya</a> ). <br>  3 - Kode itu sendiri, berisi data pengguna. <br>  4 - Periksa jumlah. <br>  5 - Stop simbol, untuk Code-128-nya 1100011101011. <br>  6 (1) - Ruang kosong. <br><br>  Sekarang mari kita lihat, bagaimana bit-bit tersebut dikodekan.  Sangat mudah - jika kita akan mengambil lebar garis paling tipis ke "1", maka garis lebar ganda adalah "11", garis lebar tiga kali lipat adalah "111", dan seterusnya.  Ruang kosong masing-masing akan "0", "00" atau "000", sesuai dengan prinsip yang sama.  Mereka yang tertarik, dapat membandingkan urutan mulai pada gambar di atas, untuk melihat bahwa aturannya dihormati. <br><br>  Sekarang kita bisa mulai coding. <br><br><h2>  Mendapatkan urutan bit </h2><br>  Secara umum, ini adalah bagian yang paling rumit, dan dapat dilakukan dengan cara yang berbeda.  Saya tidak yakin bahwa pendekatan saya optimal, tetapi untuk tugas kami cukup jelas. <br><br>  Pertama, mari memuat gambar, merentangkan lebar, memotong garis horizontal dari tengah, mengubahnya menjadi warna b / w dan menyimpannya sebagai array. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image_path = <span class="hljs-string"><span class="hljs-string">"barcode.jpg"</span></span> img = Image.open(image_path) width, height = img.size basewidth = <span class="hljs-number"><span class="hljs-number">4</span></span>*width img = img.resize((basewidth, height), Image.ANTIALIAS) hor_line_bw = img.crop((<span class="hljs-number"><span class="hljs-number">0</span></span>, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>), basewidth, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)).convert(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) hor_data = np.asarray(hor_line_bw, dtype=<span class="hljs-string"><span class="hljs-string">"int32"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  Pada barcode, garis hitam berkorespondensi dengan â€œ1â€, tetapi dalam RGB hitamnya bertolak belakang, 0, sehingga array harus dibalik.  Kami juga akan menghitung nilai rata-rata. <br><br><pre> <code class="python hljs">hor_data = <span class="hljs-number"><span class="hljs-number">255</span></span> - hor_data avg = np.average(hor_data) plt.plot(hor_data) plt.show()</code> </pre><br>  Mari kita jalankan program untuk memverifikasi bahwa barcode telah dimuat dengan benar: <br><br><img src="https://habrastorage.org/webt/8z/jp/po/8zjppozs3lgketrraqtqeuzgj8g.jpeg"><br><br>  Sekarang kita perlu menentukan lebar satu 'bit'.  Untuk melakukan ini, kami akan mengekstrak urutan, menyimpan posisi persimpangan garis rata-rata. <br><br><pre> <code class="python hljs">pos1, pos2 = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos1 == <span class="hljs-number"><span class="hljs-number">-1</span></span>: pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits == <span class="hljs-string"><span class="hljs-string">"101"</span></span>: pos2 = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span> bit_width = int((pos2 - pos1)/<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Kami hanya menyimpan garis silang rata-rata, sehingga kode "1101" akan disimpan sebagai "101", cukup bit untuk mendapatkan lebar pikselnya. <br><br>  Sekarang mari kita buat decoding itu sendiri.  Kita perlu menemukan setiap garis rata-rata yang bersilangan, dan menemukan jumlah bit dalam interval terakhir, yang ditemukan.  Angka tidak akan cocok dengan sempurna (kode dapat diregangkan atau ditekuk sedikit), jadi, kita perlu membulatkan nilainya menjadi bilangan bulat. <br><br><pre> <code class="python hljs">bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span>*int(round(cnt)) pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span>*int(round(cnt)) pos1 = p</code> </pre><br>  Mungkin ada cara yang lebih baik untuk melakukan ini, pembaca dapat menulis dalam komentar. <br><br>  Jika semua dilakukan dengan sempurna, kita akan mendapatkan urutan seperti ini: <br><br> <code>11010010000110001010001000110100010001101110100011011101000111011011 <br> 01100110011000101000101000110001000101100011000101110110011011001111 <br> 00010101100011101011</code> <br> <br><h2>  Decoding </h2><br>  Secara umum, ini cukup mudah.  Simbol dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode-128</a> dikodekan dengan kode 11-bit, yang dapat memiliki pengkodean yang berbeda (menurut pengkodean ini - A, B atau C, dapat berupa huruf atau angka dari 00 hingga 99). <br><br>  Dalam kasus kami, awal urutannya adalah 11010010000, yang sesuai dengan "Kode B".  Saya terlalu malas untuk memasukkan semua kode secara manual, jadi saya hanya menyalinnya dari halaman Wikipedia.  Parsing dari baris ini juga dibuat dengan Python (petunjuk - jangan lakukan hal-hal seperti ini pada produksi). <br><br><pre> <code class="python hljs"> CODE128_CHART = <span class="hljs-string"><span class="hljs-string">""" 0 _ _ 00 32 S 11011001100 212222 1 ! ! 01 33 ! 11001101100 222122 2 " " 02 34 " 11001100110 222221 3 # # 03 35 # 10010011000 121223 ... 93 GS } 93 125 } 10100011110 111341 94 RS ~ 94 126 ~ 10001011110 131141 103 Start Start A 208 SCA 11010000100 211412 104 Start Start B 209 SCB 11010010000 211214 105 Start Start C 210 SCC 11010011100 211232 106 Stop Stop - - - 11000111010 233111"""</span></span>.split() SYMBOLS = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">6</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] VALUESB = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">2</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] CODE128B = dict(zip(SYMBOLS, VALUESB))</code> </pre><br>  Bagian terakhir mudah.  Pertama, mari kita pisahkan urutan menjadi blok 11-bit: <br><br><pre> <code class="python hljs">sym_len = <span class="hljs-number"><span class="hljs-number">11</span></span> symbols = [bits[i:i+sym_len] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(bits), sym_len)]</code> </pre><br>  Akhirnya, mari hasilkan string output dan tampilkan: <br><br><pre> <code class="python hljs">str_out = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Start'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Stop'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> str_out += CODE128A[sym] print(<span class="hljs-string"><span class="hljs-string">" "</span></span>, sym, CODE128A[sym]) print(<span class="hljs-string"><span class="hljs-string">"Str:"</span></span>, str_out)</code> </pre><br>  Saya tidak akan menunjukkan di sini hasil dekode dari gambar atas, biarkan itu menjadi pekerjaan rumah bagi pembaca (menggunakan aplikasi yang diunduh untuk smartphone akan dianggap curang :). <br><br>  Pemeriksaan CRC tidak diterapkan dalam kode ini, mereka yang ingin, dapat melakukannya sendiri. <br><br>  Yang pasti, algoritma ini tidak sempurna, itu dilakukan dalam waktu setengah jam.  Untuk tugas profesional ada pustaka yang siap digunakan, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pyzbar</a> .  Untuk mendekode gambar, 4 baris kode sudah cukup: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyzbar.pyzbar <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decode img = Image.open(image_path) decode = decode(img) print(decode)</code> </pre><br>  (pertama perpustakaan harus diinstal menggunakan perintah "pip install pyzbar") <br><br>  <b>Tambahan</b> : pengguna situs <i>vinograd19</i> mengirim komentar menarik tentang riwayat perhitungan jumlah cek barcode. <br><br>  <i>Perhitungan angka cek itu menarik, itu berasal dari evolusi.</i> <i><br></i>  <i>Jumlah cek jelas diperlukan untuk menghindari kesalahan penguraian kode.</i>  <i>Jika barcode 1234, dan diterjemahkan sebagai 7234, kita perlu metode untuk menolak penggantian 1 hingga 7. Validasi bisa tidak sempurna, tetapi setidaknya 90% kode harus diverifikasi dengan benar.</i> <i><br><br></i>  <i>Pendekatan 1: Mari kita ambil saja jumlah, untuk memiliki 0 sebagai sisa dari divisi.</i>  <i>Simbol pertama berisi data, dan digit terakhir adalah demikian, sehingga jumlah semua angka dibagi dengan 10. Setelah decoding, jika jumlahnya tidak habis dibagi 10 - decoding salah, dan perlu diulang.</i>  <i>Misalnya, kode 1234 valid - 1 + 2 + 3 + 4 = 10. Kode 1216 - juga valid, tetapi 1218 tidak.</i> <i><br><br></i>  <i>Ini membantu untuk menghindari masalah decoding.</i>  <i>Tetapi kode juga dapat dimasukkan secara manual, menggunakan keyboard perangkat keras.</i>  <i>Menggunakan ini, kasus buruk lain ditemukan - jika urutan dua digit akan diubah, jumlah cek akan tetap benar, itu pasti buruk.</i>  <i>Misalnya, jika barcode 1234 dimasukkan sebagai 2134, jumlah cek akan sama.</i>  <i>Ditemukan, bahwa urutan angka yang salah adalah kasus umum, jika seseorang mencoba memasukkan angka dengan cepat.</i> <i><br><br></i>  <i>Pendekatan 2.</i>  <i>Mari kita tingkatkan algoritma checksum - mari kita hitung angka ganjil dua kali.</i>  <i>Kemudian, jika pesanan akan diubah, jumlahnya akan salah.</i>  <i>Misalnya, kode 2364 valid (2 + 3 * 2 + 6 + 4 * 2 = 20), tetapi kode 3264 tidak (3 + 2 * 2 + 6 + 4 * 2 = 19).</i>  <i>Lebih baik, tetapi ada kasus lain yang muncul.</i>  <i>Ada beberapa keyboard, memiliki 10 kunci dalam dua baris, baris pertama adalah 12345 dan yang kedua adalah 67890. Jika alih-alih "1" pengguna akan mengetik "2", cek checksum akan gagal.</i>  <i>Tetapi jika pengguna akan memasukkan "6" dan bukannya "1" - jumlah cek mungkin terkadang benar.</i>  <i>Itu karena 6 = 1 + 5, dan jika digit memiliki tempat ganjil, kita mendapatkan 2 * 6 = 2 * 1 + 2 * 5 - jumlahnya meningkat 10. Kesalahan yang sama akan terjadi, jika pengguna memasukkan "7 "Alih-alih" 2 "," 8 "bukannya" 3 ", dan seterusnya.</i> <i><br><br></i>  <i>Pendekatan ke-3.</i>  <i>Mari kita ambil jumlahnya lagi, tapi mari kita dapatkan angka ganjil ... 3 kali.</i>  <i>Misalnya, kode 1234565 - valid, karena 1 + 2 * 3 + 3 + 4 * 3 + 5 + 6 * 3 +5 = 50.</i> <i><br><br></i>  <i>Metode ini menjadi standar untuk kode EAN13, dengan beberapa perubahan: jumlah digit adalah tetap dan sama dengan 13, di mana 13 digit - adalah jumlah cek.</i>  <i>Angka di tempat ganjil dihitung tiga kali, di tempat genap sekali.</i> <br><br>  Ngomong-ngomong, kode EAN-13 adalah yang paling banyak digunakan dalam perdagangan dan pusat perbelanjaan, sehingga orang melihatnya lebih sering daripada jenis kode lainnya.  Pengkodean bitnya sama seperti pada Code-128, struktur datanya dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel Wikipedia</a> . <br><br><h2>  Kesimpulan </h2><br>  Seperti yang bisa kita lihat, bahkan hal yang mudah seperti barcode, bisa berisi beberapa hal keren.  By the way, lifehack kecil lain untuk pembaca, yang cukup sabar untuk membaca sampai tempat ini - teks di bawah barcode sepenuhnya identik dengan data barcode.  Itu dibuat untuk operator, yang dapat secara manual memasukkan kode, jika tidak dapat dibaca oleh pemindai.  Jadi mudah untuk mengetahui konten barcode - cukup baca teks di bawah ini. <br><br>  Terima kasih sudah membaca. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439768/">https://habr.com/ru/post/id439768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439758/index.html">Setengah jalan "Juno"</a></li>
<li><a href="../id439760/index.html">Para insinyur "memelintir" cahaya pada serat - sebuah teknologi baru akan mempercepat transfer data hingga seratus</a></li>
<li><a href="../id439762/index.html">Tentang pendidikan tinggi, programmer dan pekerjaan kerah biru</a></li>
<li><a href="../id439764/index.html">Buah Perusahaan</a></li>
<li><a href="../id439766/index.html">Tingkatkan itu! Peningkatan resolusi modern</a></li>
<li><a href="../id439772/index.html">Unit Tes menulis di Swift untuk menguji tugas yang tidak sinkron</a></li>
<li><a href="../id439774/index.html">Mengotomatiskan pengujian penyeleksi redux dalam aplikasi</a></li>
<li><a href="../id439776/index.html">Frontend Weekly Digest (4 - 10 Feb 2019)</a></li>
<li><a href="../id439778/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 351 (4 - 10 Februari 2019)</a></li>
<li><a href="../id439780/index.html">PHP Digest No. 149 (28 Januari - 11 Februari 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>