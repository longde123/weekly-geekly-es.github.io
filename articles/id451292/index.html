<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèΩ üë©üèæ‚Äçü§ù‚Äçüë®üèΩ üë©üèº‚Äçüéì RxDart: transformasi ajaib arus ü§æ üôÇ ü§Æ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat datang - Ini adalah bagian ketiga dari seri artikel Flutter Architecture saya. 


- Pendahuluan 
- Dasar-Dasar Aliran Dart 
- RxDart: transfor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RxDart: transformasi ajaib arus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451292/"><p>  Selamat datang - Ini adalah bagian ketiga dari seri artikel Flutter Architecture saya. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dasar-Dasar Aliran Dart</a> </li><li>  <strong>RxDart: transformasi aliran ajaib (posting ini)</strong> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dasar-Dasar RxVMS: RxCommand dan GetIt</a> </li><li>  RxVMS: Layanan dan Manajer </li><li>  RxVMS: widget mandiri </li><li>  Otentikasi Pengguna dengan RxVMS </li></ul><br><p> Kali ini kita akan terjun kecil ke dunia magis ekstensi reaktif (Rx).  Saya akan fokus pada fungsi Rx yang paling sering digunakan dan menjelaskan aplikasi mereka.  Jika Anda belum membaca posting sebelumnya, sekarang adalah waktunya untuk ini sebelum melanjutkan. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxDart</a> adalah implementasi konsep Rx untuk bahasa Dart, terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frank Pepermans</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Brian Egan untuk itu</a> .  Jika sebelumnya Anda menggunakan Rx dalam bahasa lain, Anda mungkin akan melihat perbedaan dalam penamaan sejumlah fungsi, tetapi ini tidak akan menyebabkan Anda kesulitan. </p><br><p>  Kode untuk pengujian ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Sejauh ini, kami telah menggunakan stream sebagai cara untuk mentransfer data dari satu tempat ke tempat lain dalam aplikasi kami, tetapi mereka dapat melakukan lebih banyak lagi.  Mari kita lihat beberapa fitur yang ditambahkan Rx ke Streams. </p><a name="habracut"></a><br><h2 id="sozdanie-observables">  Membuat Observable </h2><br><p>  Seperti yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dinyatakan sebelumnya</a> , Observables adalah versi Rx stream dengan fitur hebat.  Ada beberapa cara menarik untuk membuatnya: </p><br><h3 id="iz-potoka">  Di luar arus </h3><br><p>  Aliran apa pun dapat dikonversi ke Observable dengan meneruskannya ke konstruktor: </p><br><pre><code class="cpp hljs">var controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController&lt;String&gt;(); var streamObservable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(controller.stream); streamObservable.listen(print);</code> </pre> <br><h3 id="povtoryayuschiesya-sobytiya">  Peristiwa berulang </h3><br><pre> <code class="cpp hljs">var timerObservable = Observable.periodic(Duration(seconds: <span class="hljs-number"><span class="hljs-number">1</span></span>), (x) =&gt; x.toString() ); timerObservable.listen(print);</code> </pre> <br><p>  Dengan cara ini, Observable akan dibangun yang menampilkan nilai dengan periode tertentu.  Jadi Anda bisa mengganti timer. </p><br><h3 id="iz-odinochnogo-znacheniya">  Dari satu nilai </h3><br><p>  Terkadang API mengharapkan Stream / Diobservasi di mana Anda hanya memiliki nilai.  Untuk kasus seperti itu, Observable memiliki pabrik. </p><br><pre> <code class="cpp hljs">var justObservable = Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.just(<span class="hljs-number"><span class="hljs-number">42</span></span>); justObservable.listen(print); <span class="hljs-comment"><span class="hljs-comment">//   : 42</span></span></code> </pre> <br><h3 id="iz-future">  Dari Masa Depan </h3><br><pre> <code class="cpp hljs"> Future&lt;String&gt; asyncFunction() async { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Future.delayed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Duration(seconds: <span class="hljs-number"><span class="hljs-number">1</span></span>), () =&gt; <span class="hljs-string"><span class="hljs-string">"AsyncRsult"</span></span>); } test(<span class="hljs-string"><span class="hljs-string">'Create Observable from Future'</span></span>, () async { print(<span class="hljs-string"><span class="hljs-string">'start'</span></span>); var fromFutureObservable = Observable.fromFuture(asyncFunction()); fromFutureObservable.listen(print);</code> </pre> <br><p>  Membuat <code>Observable</code> from <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Future</a> akan menunggu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Future</a> untuk menyelesaikan dan mengembalikan nilai untuk hasilnya atau <code>null</code> jika nilainya tidak dikembalikan.  Cara lain untuk membuat aliran dari Masa Depan adalah memanggil <code>toStream()</code> untuk Masa Depan apa pun. </p><br><p>  Anda mungkin bertanya-tanya apa gunanya mengubah Future menjadi Observable / Stream alih-alih hanya menunggu saja.  Yakinlah, ini akan menjadi jelas ketika kita memeriksa fungsi yang tersedia untuk memanipulasi data saat mereka berada di aliran. </p><br><h3 id="subjects">  Subjek </h3><br><p>  <code>Subjects</code> adalah pengganti <code>StreamController</code> di RxDart, dan itulah bagaimana mereka diimplementasikan di suatu tempat di perut perpustakaan. </p><br><p>  Tetapi perilaku mereka sedikit berbeda dari StreamControllers dasar: </p><br><ul><li>  Anda dapat menerapkan <code>listen()</code> langsung ke Subjek, tanpa mengakses properti Stream </li><li>  sejumlah langganan tersedia, dan semua pendengar menerima data yang sama pada saat yang sama </li><li>  Ada tiga jenis Subjek, yang dijelaskan di bawah ini dengan contoh: </li></ul><br><h4 id="publishsubjects">  Publikasikan Subjek </h4><br><p>  <code>PublishSubjects</code> berperilaku seperti <code>StreamControllers</code> , kecuali untuk kemungkinan banyak pendengar: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.listen((item) =&gt; print(item)); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    subject.listen((item) =&gt; print(item.toUpperCase())); subject.add("Item2"); subject.add("Item3"); //        await Future.delayed(Duration(seconds: 5)); //    subject.close;</span></span></code> </pre> <br><p>  Jalankan kode ini dan Anda akan mendapatkan: </p><br><pre> <code class="cpp hljs">Item1 ITEM2 Item2 ITEM3 Item3</code> </pre> <br><p>  Jelas bahwa pendengar kedua yang terlambat menghadiri pesta (kami akan menyebutnya pelanggan terlambat) melewatkan poin pertama.  Untuk menghindari ini, Anda dapat menggunakan <code>BehaviourSubject</code> </p><br><h4 id="behavioursubject">  Subjek perilaku </h4><br><p>  Dengan <code>BehaviourSubject</code> setiap pelanggan baru akan menerima nilai yang terakhir diterima: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject&lt;String&gt;(); subject.listen((item) =&gt; print(item)); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item2"</span></span>); subject.listen((item) =&gt; print(item.toUpperCase())); subject.add(<span class="hljs-string"><span class="hljs-string">"Item3"</span></span>);</code> </pre> <br><p>  Di pintu keluar </p><br><pre> <code class="cpp hljs">Item1 ITEM2 ITEM3 Item2 Item3</code> </pre> <br><p>  Anda dapat melihat bahwa <code>Item1</code> hilang untuk pelanggan kedua, tetapi menerima <code>Item2</code> .  Anda mungkin terkejut bahwa pelanggan kedua menerima <code>Item3</code> sebelum pelanggan pertama menerima <code>Item2</code> .  Ini karena urutan layanan pelanggan tidak dijamin, meskipun semua pelanggan menerima data dalam urutan yang benar.  <code>BehaviourSubject</code> hanya menyimpan cache item terakhir yang diterima untuk pelanggan yang terlambat.  Jika Anda perlu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">men-</a> cache lebih banyak elemen, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReplaySubject</a> .  Dalam kebanyakan kasus ini tidak perlu. </p><br><h2 id="manipulirovanie-dannymi-na-letu">  Memanipulasi data dengan cepat </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ea5/dfe/1c6/ea5dfe1c65f93367e3207e2a0fe68908.gif"></p><br><p>  Kekuatan sebenarnya dari Rx terletak pada kenyataan bahwa Rx memungkinkan Anda untuk memproses data selama transmisi melalui aliran.  Setiap metode Rx mengembalikan aliran baru dengan data yang dihasilkan (seperti dalam ilustrasi), yang berarti Anda dapat mengikat mereka bersama dalam satu pipa pemrosesan, dan ini membuat Rx alat yang sangat kuat. </p><br><h3 id="map">  Peta </h3><br><p>  Jika ada operasi Stream yang tidak ingin saya lewatkan, maka ini adalah <code>map()</code> .  Apa yang dilakukan <code>map()</code> adalah bahwa setiap item data harus ditransfer dan menerapkan fungsi tertentu padanya, setelah itu menempatkan hasilnya dalam aliran yang dihasilkan.  Contoh sederhana: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8e0/05a/ecc/8e005aecc11e119b7c856a4cadec9b11.gif"></p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((item) =&gt; item.toUpperCase()).listen(print); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item2"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item3"</span></span>);</code> </pre> <br><p>  Hasil: </p><br><pre> <code class="cpp hljs">ITEM1 ITEM2 ITEM3</code> </pre> <br><p>  Tetapi <code>map</code> tidak diperlukan untuk mengembalikan tipe data yang sama dengan yang diterimanya sebagai input.  Contoh berikut akan mengambil bilangan bulat sebagai ganti string.  Selain itu, kami akan menautkan dua transformasi: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((intValue) =&gt; intValue.toString()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((item) =&gt; item.toUpperCase()) .listen(print); subject.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  atau sesuatu seperti ini: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0bb/73f/2a2/0bb73f2a2ccb82e6a920efbf2c395b0d.gif"></p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataClass</span></span></span><span class="hljs-class">{</span></span>} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WrapperClass</span></span></span><span class="hljs-class"> {</span></span> final DataClass wrapped; WrapperClass(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapped); } var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;WrapperClass&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;WrapperClass&gt;((a) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WrapperClass(a));</code> </pre> <br><p>  Salah satu penggunaan <code>.map</code> paling berguna adalah ketika Anda mendapatkan data dalam format dari beberapa REST API atau dari database dan ingin data tersebut dikonversi ke objek Anda sendiri: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> {</span></span> final String name; final String adress; final String phoneNumber; final <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; <span class="hljs-comment"><span class="hljs-comment">//       - //   factory User.fromJson(String jsonString) { var jsonMap = json.decode(jsonString); return User( jsonMap['name'], jsonMap['adress'], jsonMap['phoneNumber'], jsonMap['age'], ); } User(this.name, this.adress, this.phoneNumber, this.age); @override String toString() { return '$name - $adress - $phoneNumber - $age'; } } void main() { test('Map', () { // -  var jsonStrings = [ '{"name": "Jon Doe", "adress": "New York", "phoneNumber":"424242","age": 42 }', '{"name": "Stephen King", "adress": "Castle Rock", "phoneNumber":"123456","age": 71 }', '{"name": "Jon F. Kennedy", "adress": "Washington", "phoneNumber":"111111","age": 66 }', ]; //   json-,    API/DB. var dataStreamFromAPI = new PublishSubject&lt;String&gt;(); dataStreamFromAPI .map&lt;User&gt;((jsonString) =&gt; User.fromJson(jsonString)) // json -&gt; User .listen((user) =&gt; print(user.toString())); //    dataStreamFromAPI.add(jsonStrings[0]); dataStreamFromAPI.add(jsonStrings[1]); dataStreamFromAPI.add(jsonStrings[2]); });</span></span></code> </pre> <br><p>  <em>Saya perhatikan bahwa tidak hanya Streams, tetapi juga setiap Iterable menawarkan fungsi <code>map</code> yang dapat Anda gunakan untuk transformasi dalam daftar.</em> </p><br><h3 id="where">  Dimana </h3><br><p>  Jika Anda hanya tertarik pada nilai-nilai tertentu yang terjadi dalam aliran, Anda dapat menggunakan fungsi <code>.where()</code> alih-alih menggunakan <code>if</code> di pendengar Anda, ini lebih ekspresif dan lebih mudah dibaca: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); subject.where((val) =&gt; val.isOdd) .listen( (val) =&gt; print(<span class="hljs-string"><span class="hljs-string">'This only prints odd numbers: $val'</span></span>)); subject.where((val) =&gt; val.isEven) .listen( (val) =&gt; print(<span class="hljs-string"><span class="hljs-string">'This only prints even numbers: $val'</span></span>)); subject.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">//: This only prints odd numbers: 1 This only prints even numbers: 2 This only prints odd numbers: 3</span></span></code> </pre> <br><h3 id="debounce">  Debounce </h3><br><p>  Ini adalah salah satu mutiara kecil Rx!  Bayangkan Anda memiliki bidang pencarian yang memanggil REST API jika teksnya diubah.  Membuat panggilan API untuk setiap penekanan tombol itu mahal.  Dengan demikian, Anda hanya ingin melakukan panggilan jika pengguna berhenti sejenak.  Untuk ini, fungsi <code>debounce()</code> digunakan, yang menelan semua peristiwa yang masuk jika tidak diikuti oleh jeda. </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.debounce(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Duration(milliseconds: <span class="hljs-number"><span class="hljs-number">500</span></span>)).listen((s) =&gt; print(s)); subject.add(<span class="hljs-string"><span class="hljs-string">'A'</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">'AB'</span></span>); await Future.delayed(Duration(milliseconds: <span class="hljs-number"><span class="hljs-number">200</span></span>)); subject.add(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    await Future.delayed(Duration(milliseconds: 700)); //       : 'ABC'</span></span></code> </pre> <br><p>  Karena itu, jika Anda mengonversi penangan <code>TextField.onChanged</code> ke <code>Observable</code> , Anda akan mendapatkan solusi yang elegan. </p><br><h3 id="expand">  Perluas </h3><br><p>  Jika Stream sumber Anda memancarkan array objek, dan Anda ingin memproses masing-masing objek sendiri, Anda dapat menggunakan. <code>.expand</code> , yang akan melakukan hal itu: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e8e/8d7/2b3/e8e8d72b36dddd0d3469107c6cdae2b1.gif" alt="gambar"></p><br><p>  Anda akan melihat penerapan metode ini di bawah dalam contoh FireStore. </p><br><h3 id="merge">  Gabungkan </h3><br><p>  Jika Anda memiliki beberapa utas berbeda, tetapi Anda ingin memproses objek mereka bersama-sama, Anda dapat menggunakan <code>.mergeWith</code> (dalam implementasi Rx lainnya hanya <code>merge</code> ), yang mengambil larik utas dan mengembalikan satu utas yang digabungkan. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a2f/9ba/82b/a2f9ba82b88b555841c21dc623c3d298.gif" alt="gambar"></p><br><p>  <code>.mergeWith</code> tidak menjamin bahwa pesanan apa pun dalam aliran digabungkan.  Data dipancarkan dalam urutan input. </p><br><p>  Misalnya, jika Anda memiliki dua komponen yang melaporkan kesalahan melalui aliran, dan Anda ingin mereka ditampilkan bersama dalam dialog, Anda bisa melakukan ini sebagai berikut (pseudo-code): </p><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">override </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ super.initState(); component1.errors.mergeWith([component2.errors]) .listen( (error) async =&gt; await showDialog(error.message)); }</code> </pre> <br><p>  atau jika Anda ingin tampilan pesan gabungan dari beberapa jejaring sosial, mungkin akan terlihat seperti ini (pseudo-code): </p><br><pre> <code class="cpp hljs">final observableTwitter = getTwitterStream().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((data) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAppPost.fromTwitter(data)); final observableFacebook = getFacebookStream().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((data) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAppPost.fromFaceBook(data)); final postStream = observableTwitter.mergeWith([observableFacebook]);</code> </pre> <br><h3 id="zipwith">  Zipwith </h3><br><p>  <code>zipWith</code> juga menggabungkan satu aliran dengan yang lain.  Tapi, tidak seperti <code>.mergeWith</code> , ia tidak mengirim data segera setelah menerima elemen dari salah satu stream sumbernya.  Dia menunggu sampai elemen dari kedua aliran sumber tiba, dan kemudian menggabungkannya menggunakan fungsi <code>zipper</code> disediakan: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5ef/611/847/5ef611847db6bfa40237fb3622d93822.gif" alt="gambar"></p><br><p>  <code>zipWith</code> tangan <code>zipWith</code> tampak menakutkan, tetapi sekarang kita melihatnya: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// R :   Stream/Observable // S :   Stream/Observable // zipper: - Observable&lt;R&gt; zipWith&lt;S, R&gt;(Stream&lt;S&gt; other, R zipper(T t, S s))</span></span></code> </pre> <br><p>  Contoh yang sangat sederhana: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable.just(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// .just()  Observable,    .zipWith(new Observable.just(2), (one, two) =&gt; one + two) .listen(print); //  3</span></span></code> </pre> <br><p>  Aplikasi yang lebih praktis adalah jika Anda harus menunggu dua fungsi tidak sinkron yang mengembalikan <code>Future</code> , dan Anda ingin memproses data segera setelah kedua hasil dikembalikan.  Dalam contoh yang sedikit dibuat-buat ini, kami menyajikan dua API REST: satu mengembalikan <code>User</code> , yang lainnya mengembalikan <code>Product</code> sebagai string JSON, dan kami ingin menunggu kedua panggilan sebelum mengembalikan objek <code>Invoice</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invoice</span></span></span><span class="hljs-class"> {</span></span> final User user; final Product product; Invoice(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.product); printInvoice() { print(user.toString()); print(product.toString()); } } <span class="hljs-comment"><span class="hljs-comment">//  HTTP ,  Product,  JSON Future&lt;String&gt; getProduct() async { print("Started getting product"); await Future.delayed(Duration(seconds: 2)); print("Finished getting product"); return '{"name": "Flux compensator", "price": 99999.99}'; } //  HTTP ,  User,  JSON Future&lt;String&gt; getUser() async { print("Started getting User"); await Future.delayed(Duration(seconds: 4)); print("Finished getting User"); return '{"name": "Jon Doe", "adress": "New York", "phoneNumber":"424242","age": 42 }'; } void main() { test('zipWith', () async { var userObservable = Observable.fromFuture(getUser()).map&lt;User&gt;((jsonString) =&gt; User.fromJson(jsonString)); var productObservable = Observable.fromFuture(getProduct()) .map&lt;Product&gt;((jsonString) =&gt; Product.fromJson(jsonString)); Observable&lt;Invoice&gt; invoiceObservable = userObservable.zipWith&lt;Product, Invoice&gt;( productObservable, (user, product) =&gt; Invoice(user, product)); print("Start listening for invoices"); invoiceObservable.listen((invoice) =&gt; invoice.printInvoice()); //        await Future.delayed(Duration(seconds: 5)); }); }</span></span></code> </pre> <br><p>  Melihat output, Anda dapat melihat bagaimana hal ini dilakukan secara serempak </p><br><pre> <code class="cpp hljs">Started getting User Started getting product Start listening <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> invoices Finished getting product Finished getting User Jon Doe - New York - <span class="hljs-number"><span class="hljs-number">424242</span></span> - <span class="hljs-number"><span class="hljs-number">42</span></span> Flux compensator - <span class="hljs-number"><span class="hljs-number">99999.99</span></span></code> </pre> <br><h3 id="combinelatest">  Combinelatest </h3><br><p>  <code>combineLatest</code> juga menggabungkan nilai aliran, tetapi dengan cara yang sedikit berbeda dari <code>merge</code> dan <code>zip</code> .  Ini mendengarkan lebih banyak utas dan mengeluarkan nilai gabungan setiap kali nilai baru datang dari salah satu utas.  Sangat menarik bahwa ia menghasilkan tidak hanya nilai yang diubah, tetapi juga nilai yang diperoleh terakhir dari semua aliran sumber lainnya.  Perhatikan baik-baik animasi ini: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/633/acb/bee/633acbbee01158bb7a6ad0450d39f712.gif" alt="gambar"></p><br><p>  Sebelum <code>combineLates</code> nilai pertama, semua utas sumber harus menerima setidaknya satu entri. </p><br><p>  Berbeda dengan metode yang digunakan sebelumnya, <code>combineLatest</code> adalah statis.  Selain itu, karena Dart tidak memungkinkan overloading operator, ada versi <code>combLastest</code> tergantung pada jumlah stream sumber: <strong>kombinasikanLatest2 ... kombinasikanLatest9</strong> </p><br><p>  <code>combineLatest</code> penggunaan yang baik, misalnya, jika Anda memiliki dua <code>Observable&lt;bool&gt;</code> yang menandakan bahwa beberapa bagian dari aplikasi Anda sedang sibuk, dan Anda ingin menampilkan pemintal Sibuk jika salah satunya sibuk.  Mungkin terlihat seperti ini (pseudo-code): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; get isBusy =&gt; Observable.combineLatest2(isBusyOne,isBusyTwo, (b1, b2) =&gt; b1 || b2); PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusyOne; PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusyTwo; }</code> </pre> <br><p>  Di UI Anda, Anda bisa menggunakan <code>isBusy</code> dengan <code>StreamBuilder</code> untuk menampilkan <code>Spinner</code> jika nilai yang dihasilkan benar. </p><br><p>  <code>combineLatest</code> sangat cocok dikombinasikan dengan stream <strong>snapshots FireStore</strong> . </p><br><p>  Bayangkan Anda ingin membuat aplikasi yang menampilkan feed berita beserta ramalan cuaca.  Pesan ticker dan data cuaca disimpan dalam dua koleksi FireStore yang berbeda.  Keduanya diperbarui secara independen.  Anda ingin menampilkan pembaruan data menggunakan StreamBuilder.  Dengan <code>combineLatest</code> mudah: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherForecast</span></span></span><span class="hljs-class"> {</span></span> final String forecastText; final GeoPoint location; factory WeatherForecast.fromMap(Map&lt;String, dynamic&gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WeatherForecast(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'forecastText'</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'location'</span></span>]); } WeatherForecast(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forecastText, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewsMessage</span></span></span><span class="hljs-class"> {</span></span> final String newsText; final GeoPoint location; factory NewsMessage.fromMap(Map&lt;String, dynamic&gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'newsText'</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'location'</span></span>]); } NewsMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newsText, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CombinedMessage</span></span></span><span class="hljs-class"> {</span></span> final WeatherForecast forecast; final NewsMessage newsMessage; CombinedMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forecast, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newsMessage); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> CollectionReference weatherCollection; CollectionReference newsCollection; Model() { weatherCollection = Firestore.instance.collection(<span class="hljs-string"><span class="hljs-string">'weather'</span></span>); newsCollection = Firestore.instance.collection(<span class="hljs-string"><span class="hljs-string">'news'</span></span>); } Observable&lt;CombinedMessage&gt; getCombinedMessages() { Observable&lt;WeatherForecast&gt; weatherForecasts = weatherCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;WeatherForecast&gt;((document) =&gt; WeatherForecast.fromMap(document.data)); Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) =&gt; NewsMessage.fromMap(document.data)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.combineLatest2( weatherForecasts, news, (weather, news) =&gt; CombinedMessage(weather, news)); } }</code> </pre> <br><p>  Di UI Anda, akan terlihat seperti ini: <code>StreamBuilder&lt;CombinedMessage&gt;(stream: model.getCombinedMessages(),...).</code> </p><br><h3 id="distinct">  Berbeda </h3><br><p>  Dalam skenario yang dijelaskan di atas, mungkin saja <strong>isBusyOne</strong> dan <strong>isBusyTwo</strong> memberikan nilai yang sama, yang akan mengarah pada pembaruan antarmuka pengguna dengan data yang sama.  Untuk mencegah ini, kita bisa menggunakan <code>.distinct()</code> .  Ini memastikan bahwa data hanya dialirkan jika nilai elemen baru berbeda dari yang terakhir.  Dengan demikian, kami akan mengubah kode menjadi: </p><br><pre> <code class="cpp hljs"> Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusy =&gt; isBusyOne.mergeWith([isBusyTwo]).distinct();</code> </pre> <br><p>  dan itu juga menunjukkan bahwa kita dapat menggabungkan fungsi kita dalam rantai yang berbeda sesuka hati. </p><br><h3 id="asyncmap">  Asyncmap </h3><br><p>  Selain <code>map()</code> ada juga fungsi <code>asyncMap</code> , yang memungkinkan Anda untuk menggunakan fungsi asinkron sebagai fungsi peta.  Mari kita perkenalkan pengaturan yang sedikit berbeda untuk contoh FireStore kami.  Sekarang, <strong>WeatherForecast yang</strong> diperlukan tergantung pada lokasi <strong>NewsMessage</strong> dan hanya akan diperbarui ketika <strong>NewsMessage</strong> baru <strong>diterima</strong> : </p><br><pre> <code class="cpp hljs">Observable&lt;CombinedMessage&gt; getDependendMessages() { Observable&lt;NewsMessage&gt; news = newsCollection.snapshots().expand((snapShot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> snapShot.documents; }).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage.fromMap(document.data); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> news.asyncMap((newsEntry) async { var weatherDocuments = await weatherCollection.where(<span class="hljs-string"><span class="hljs-string">'location'</span></span>, isEqualTo: newsEntry.location).getDocuments(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CombinedMessage( WeatherForecast.fromMap(weatherDocuments.documents.first.data), newsEntry); }); }</code> </pre> <br><p>  Observable yang dikembalikan oleh getDependendMessages akan menghasilkan CombinedMessage baru setiap kali newsCollection berubah. </p><br><h2 id="otladka-observables">  Debug Dapat Diobservasi </h2><br><p>  Melihat rantai panggilan Rx yang elegan, tampaknya hampir mustahil untuk men-debug ekspresi seperti ini: </p><br><pre> <code class="cpp hljs">Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) =&gt; NewsMessage.fromMap(document.data));</code> </pre> <br><p>  Tetapi perlu diingat bahwa <code>=&gt;</code> hanyalah bentuk singkat untuk fungsi anonim.  Menggunakan <strong>Konversi untuk memblokir tubuh</strong> , Anda akan mendapatkan: </p><br><pre> <code class="cpp hljs">Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> snapShot.documents; }) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage.fromMap(document.data); });</code> </pre> <br><p>  Dan sekarang kita dapat mengatur breakpoint atau menambahkan pernyataan cetak pada setiap langkah dari pipeline kita. </p><br><h2 id="osteregaytes-pobochnyh-effektov">  Waspadai efek samping </h2><br><p>  <strong>Jika Anda ingin memanfaatkan Rx untuk membuat kode Anda lebih kuat, selalu ingat bahwa Rx adalah konversi data saat memindahkannya "di sepanjang sabuk konveyor".</strong>  <strong>Oleh karena itu, jangan pernah panggil fungsi yang mengubah variabel / status di luar pipa pemrosesan hingga Anda mencapai fungsi .listen.</strong> <br>  Alih-alih melakukannya: </p><br><pre> <code class="cpp hljs">Observable.fromFuture(getProduct()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Product&gt;((jsonString) { var product = Product.fromJson(jsonString); database.save(product); setState((){ _product = product }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> product; }).listen();</code> </pre> <br><p>  lakukan ini: </p><br><pre> <code class="cpp hljs">Observable.fromFuture(getProduct()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Product&gt;((jsonString) =&gt; Product.fromJson(jsonString)) .listen( (product) { database.save(product); setState((){ _product = product }); });</code> </pre> <br><p>  Tugas <code>map()</code> adalah untuk mengubah data dalam aliran, DAN TIDAK ADA LEBIH BANYAK!  Jika fungsi tampilan yang disahkan melakukan sesuatu yang lain, itu akan dianggap sebagai efek samping, menghasilkan potensi kesalahan yang sulit dideteksi ketika membaca kode. </p><br><h2 id="nekotorye-mysli-ob-osvobozhdenii-resursov">  Beberapa pemikiran tentang pembebasan sumber daya </h2><br><p>  Untuk menghindari kebocoran memori, selalu panggil <code>cancel()</code> untuk langganan, <code>dispose()</code> untuk StreamControllers, <code>close()</code> untuk Subjek, segera setelah Anda tidak lagi membutuhkannya. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Selamat jika kamu tetap bersamaku sampai saat ini.  Sekarang Anda tidak hanya dapat menggunakan Rx untuk membuat hidup Anda lebih mudah, tetapi juga mempersiapkan posting berikutnya di mana kita akan mempelajari rincian <strong>RxVMS</strong> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451292/">https://habr.com/ru/post/id451292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451276/index.html">Bagaimana cara membangun merek?</a></li>
<li><a href="../id451278/index.html">Analisis wavelet Bagian 1</a></li>
<li><a href="../id451280/index.html">Logam yang paling menarik</a></li>
<li><a href="../id451282/index.html">Black hole analytics web: berapa banyak data yang hilang di GA dan mengapa</a></li>
<li><a href="../id451286/index.html">Roskomnadzor, yang pantas kita dapatkan</a></li>
<li><a href="../id451294/index.html">Ketika saya menambahkan fungsi ke mobil melalui CAN, tidak dapat memprogram</a></li>
<li><a href="../id451296/index.html">Diumumkan oleh ML.NET 1.0</a></li>
<li><a href="../id451298/index.html">Cara membuat konsol game dengan kasing dengan memesan satu papan sirkuit tercetak</a></li>
<li><a href="../id451302/index.html">Perusahaan alih daya TI teratas</a></li>
<li><a href="../id451304/index.html">"Tip" Yandex: bagaimana memaksimalkan keuntungan pada langganan berbayar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>