<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎆 👩🏽 😆 C＃中的不安全通用数学 📕 📈 👊🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="不幸的是，要把我刚开始的丑陋的名字适当地翻译成俄语并不容易。 令我惊讶的是，官方MSDN文档将其称为“泛型”“模板”（我想类似于C++模板）。 在引起我注意的第4版"CLR通过C# "CLR ”中， 彼得翻译的杰弗里·里希特 （ Jeffrey Richter ）将泛型称为“泛化”，它更好地反映了这...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C＃中的不安全通用数学</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480416/"><p><img src="https://habrastorage.org/webt/mj/zg/yw/mjzgywquj0lud4_vs9bjh8xdacu.png"></p><br><p>不幸的是，要把我刚开始的丑陋的名字适当地翻译成俄语并不容易。 令我惊讶的是，官方<a href="https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/generics/" rel="nofollow">MSDN</a>文档将其称为“泛型”“模板”（我想类似于<code>C++</code>模板）。 在引起我<a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow">注意</a>的第4版<a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow"><code>"CLR</code>通过<code>C#</code> <code>"CLR</code> ”中，</a> <a href="https://habr.com/en/company/piter/">彼得</a>翻译的<a href="https://twitter.com/jeffrichter" rel="nofollow">杰弗里·里希特</a> （ <a href="https://twitter.com/jeffrichter" rel="nofollow">Jeffrey Richter</a> ）将泛型称为“泛化”，它更好地反映了这一概念。 本文将讨论<em><code>C#</code>不安全的广义数学运算</em> 。 考虑到<code>C#</code>并非旨在用于高性能计算（尽管当然可以，但它不能与相同的<code>C/C++</code>竞争），因此<code>BCL</code>数学运算并未引起太多关注。 让我们尝试使用<code>C#</code>和<code>CLR</code>简化基本算术类型的工作。 </p><a name="habracut"></a><br><h2 id="postanovka-zadachi"> 问题陈述 </h2><br><p>  <strong>免责声明</strong> ：本文将包含许多代码片段，其中一些我将通过与<a href="https://twitter.com/ashmind" rel="nofollow">Andrey Shchekin</a>的精彩资源<a href="https://sharplab.io/" rel="nofollow">SharpLab</a> （ <a href="https://github.com/ashmind/SharpLab" rel="nofollow">Gi <s>r</s> tHub</a> ）的链接进行说明。 </p><br><p> 大多数计算以一种或另一种方式归结为基本操作。 加法，减法（求反，求反），乘法和除法可以通过比较和检查相等性的操作来补充。 当然，所有这些动作都可以轻松，简单地在<code>C#</code>的任何基本算术类型的变量上执行。 唯一的问题是<code>C#</code>应该在编译时就<em>知道</em>对特定类型执行了操作，而且似乎不可能写出一种有效地（透明地）相加两个整数和两个浮点数的方法。 </p><br><p> 让我们指定对执行一些简单数学运算的假设通用方法的期望： </p><br><ol><li> 方法必须具有通用的类型限制，以防止我们尝试添加（或乘，除）两个任意类型。 我们需要一些通用类型约束。 </li><li> 为了保证实验的纯度，接受和返回的类型必须相同。 例如，二进制运算符必须具有<code>(T, T) =&gt; T</code>形式的签名<code>(T, T) =&gt; T</code> </li><li> 该方法应至少部分优化。 例如，无处不在的拳击是不可接受的。 </li></ol><br><h2 id="a-chto-tam-u-sosedey"> 那邻居呢？ </h2><br><p> 让我们看一下<code>F#</code> 。 我不擅长<code>F#</code> ，但是大多数<code>C#</code>限制是由<code>CLR</code>限制决定的，这意味着<code>F#</code>会遇到相同的问题。 您可以尝试声明一个显式的广义加法和通常的加法，并查看<code>F#</code>类型推断系统的含义： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x + y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> xy = x + y add_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore</code> </pre> <br><p> 在<a href="https://sharplab.io/" rel="nofollow">这种情况下，</a>两种方法都将变成非通用的，并且生成的代码将是相同的。 给定<code>F#</code>类型系统的刚性，其中不存在<code>int -&gt; double</code>形式的隐式转换，在首次使用<code>double</code>类型的参数（用<code>C#</code>术语）调用这些方法之后，使用其他类型的参数调用方法（即使由于类型转换而可能导致精度损失）更多会失败。 </p><br><p> 值得注意的是，如果用相等运算符<code>=</code>替换<code>+</code>运算符， <a href="https://sharplab.io/" rel="nofollow">图片会略有不同</a> ：两种方法都变成了通用的（从<code>C#</code>的角度来看），并且调用了<code>F#</code>可用的特殊辅助方法来执行比较。 </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x = y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eq xy = x = y eq_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq_gen <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore</code> </pre> <br><h3 id="chto-naschet-java">  <code>Java</code>呢？ </h3><br><p> 我很难谈论<code>Java</code> ，但是据我所知，重要类型<a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">不是</a>我们惯用的形式，但仍然有<em>原始</em>类型。 为了在<code>Java</code>使用基元<code>Java</code>有一些<a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">包装器</a> （例如，基元按值<code>long</code>的引用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" rel="nofollow"><code>Long</code></a> ），它们具有一个通用的基类<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html" rel="nofollow"><code>Number</code></a> 。 因此，您可以使用<code>Number</code>来部分概括操作，但这是一种引用类型，不太可能对性能产生积极影响。 </p><br><p>  <em>如果我错了，请纠正我。</em> </p><br><h3 id="c">  <code>C++</code> ？ </h3><br><p>  <code>C++</code>是作弊者的一种语言。 <br>  <code>C++</code>为某些人认为... <a href="https://ru.wikiquote.org/wiki/%25D0%2597%25D0%25B2%25D1%2591%25D0%25B7%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D0%25BE%25D0%25B9%25D0%25BD%25D1%258B._%25D0%25AD%25D0%25BF%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B4_III:_%25D0%259C%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D1%2581%25D0%25B8%25D1%2582%25D1%2585%25D0%25BE%25D0%25B2" rel="nofollow">不自然的</a>功能铺平了道路。 <br> 从广义上讲， <em>模板</em> （aka模板）与概括（泛型）相反，是<em>template</em> 。 声明模板时，可以显式限制此模板可用的类型。 因此，例如在<code>C++</code> ，以下代码有效： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T, std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value&gt;* = nullptr&gt; T Add (T left, T right) { return left + right; } int main() { std::cout &lt;&lt; Add(5, 6) &lt;&lt; std::endl; std::cout &lt;&lt; Add(5.0, 6.0) &lt;&lt; std::endl; // std::cout &lt;&lt; Add("a", "b") &lt;&lt; std::endl; Does not compile }</span></span></span></span></code> </pre> <br><p> 不幸的是， <code>is_arithmetic</code>允许使用<code>char</code>和<code>bool</code>作为参数。 另一方面，尽管整数类型的实际大小取决于平台/编译器/月相，但是<code>char</code>在<code>C#</code>术语中可以等同于<code>sbyte</code> 。 </p><br><h3 id="yazyki-s-dinamicheskoy-tipizaciey"> 动态打字语言 </h3><br><p> 最后，考虑几种动态类型化（和<em>解释性</em> ）的语言，这些语言通过计算得到了增强。 在这种语言中，计算的一般化通常不会引起问题：如果参数类型适合于有条件地执行加法运算，则将执行该操作，否则将失败并显示错误。 </p><br><p> 在<code>Python</code> （3.7.3 x64）中： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y type(add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># &lt;class 'int'&gt; type(add(5.0, 6.0)) # &lt;class 'float'&gt; type(add('a', 'b') # &lt;class 'str'&gt;</span></span></code> </pre> <br><p> 在<code>R</code> （3.6.1 x64）中 </p><br><pre> <code class="cpp hljs">add &lt;- function(x, y) x + y # <span class="hljs-function"><span class="hljs-function">Or </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeof</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5L</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6L</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: integer vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"5"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"6"</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Error in x + y : non-numeric argument to binary </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span></span></code> </pre> <br><h2 id="obratno-v-mir-c-ogranichivaem-obobschennyy-tip-matematicheskoy-funkcii"> 相反，在C＃世界中：我们限制数学函数的广义类型 </h2><br><p> 不幸的是，我们不能这样做。 在<code>C#</code>基本类型是按值类型，即 尽管从<code>System.Object</code> （和<a href="https://docs.microsoft.com/en-us/dotnet/api/system.valuetype%3Fview%3Dnetcore-3.0" rel="nofollow"><code>System.ValueType</code></a> ）继承的结构却没有太多共同点。 一个自然而合理的限制是<code>where T : struct</code> 。 从<code>C# 7.3</code>我们具有<code>where T : unmanaged</code>约束，这意味着<code>T</code>是非<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow"><code> ,        null</code></a> 。 除了我们需要的原始算术类型之外， <code>char</code> ， <code>bool</code> ， <code>decimal</code> ， <em>任何</em> <code>Enum</code>以及所有字段都具有相同<code>unmanaged</code>类型的<em>任何</em>结构都可以满足这些要求。 即  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow">此类型</a>将通过测试： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Coords&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TX; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TY; }</code> </pre> <br><p> 因此，我们不能编写仅接受所需算术类型的通用函数。 因此，本文标题中的<code>Unsafe</code> -我们将不得不依靠程序员使用我们的代码。 如果程序员将不兼容类型的对象作为参数传递，则尝试调用假设的通用方法<code>T Add&lt;T&gt;(T left, T right) where T : unmanaged</code>将导致无法预测的结果。 </p><br><h2 id="eksperiment-pervyy-naivnyy-dynamic"> 第一次实验，天真： <code>dynamic</code> </h2><br><p>  <code>dynamic</code>是可以帮助我们解决问题的第一个显而易见的工具。 当然，将<code>dynamic</code>用于计算绝对是没有用的- <code>dynamic</code>等效于<code>object</code> ，并且带有<code>dynamic</code>变量的被调用方法被编译器转换为可怕的反射。 作为奖励-包装/拆装我们的按值类型。 这是<a href="https://sharplab.io/" rel="nofollow">一个例子</a> ： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = Add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = Add(<span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">dynamic</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right</span></span></span><span class="hljs-function">)</span></span> =&gt; left + right; }</code> </pre> <br><p> 只需查看<code>Method</code>方法的<code>IL</code> ： </p><br><pre> <code class="cs hljs">.<span class="hljs-function"><span class="hljs-function">method </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> hidebysig </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) cil managed</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Method begins at RVA 0x2050 // Code size 53 (0x35) .maxstack 8 IL_0000: ldc.i4.5 IL_0001: box [System.Private.CoreLib]System.Int32 IL_0006: ldc.i4.6 IL_0007: box [System.Private.CoreLib]System.Int32 IL_000c: call object Class::Add(object, object) IL_0011: pop IL_0012: ldc.r8 5 IL_001b: box [System.Private.CoreLib]System.Double IL_0020: ldc.r8 6 IL_0029: box [System.Private.CoreLib]System.Double IL_002e: call object Class::Add(object, object) IL_0033: pop IL_0034: ret } // end of method Class::Method</span></span></code> </pre> <br><p> 加载<code>5</code> ， <em>打包</em> ，加载<code>6</code> ，打包，称为<code>object Add(object, object)</code> 。 <br> 选择显然不适合我们。 </p><br><h2 id="eksperiment-vtoroy-v-lob"> 第二个实验，“在额头上” </h2><br><p> 好吧， <code>dynamic</code>不是适合我们的，但是我们类型的数量是有限的，并且它们是预先知道的。 让我们用分支<s>撬棍</s>武装自己并将其写下来：如果<em>我们的</em>类型<em>是</em> ，让我们计算一下，否则-这是例外。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Left &amp;&amp; right <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Right) { <span class="hljs-comment"><span class="hljs-comment">// ??? } // ... throw new NotSupportedException(); }</span></span></code> </pre> <br><p>  III，这里我们遇到一个问题。 如果您了解我们正在使用的类型，则仍然可以对它们应用操作，那么需要将结果条件<code>int</code>转换为未知类型<code>T</code> ，这不是很简单。  <code>return (T)(i32Left + i32Right)</code>不会编译-无法保证<code>T</code>为<code>int</code> （即使我们知道它是<code>int</code> ）。 您可以尝试两次转换<code>return (T)(object)(i32Left + i32Right)</code> 。 首先，打包数量，然后在<code>T</code>解包<code>T</code>  <strong>仅</strong>当类型在包装之前和包装之后<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing" rel="nofollow">匹配时</a> ，此方法<strong>才</strong>起作用。 您不能打包<code>int</code> ，但可以将其解压缩为<code>double</code> ，即使存在隐式转换<code>int -&gt; double</code> 。  <a href="https://sharplab.io/" rel="nofollow">此</a>代码的问题是即使在<code>if</code>情况下，巨大的分支和大量的拆包程序也是<code>if</code> 。 这个选项也不好。 </p><br><h2 id="refleksiya-i-metadannye"> 反射和元数据 </h2><br><p> 好吧，玩就够了。 每个人都知道<code>C#</code>存在可以被覆盖的运算符。 那里有<code>+</code> ， <code>-</code> ， <code>==</code> <code>!=</code>等。 我们要做的就是提取与运算符相对应的<code>T</code>型静态方法，例如，加法-仅此而已。 好吧，是的，还是几个包，但是没有分支，也没有问题。 可以使用<code>T</code>类型缓存整个对象，并且通常可以以各种方式加速该过程，从而将一种数学运算减少为调用单个反射方法。 好吧，像这样： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-comment"><span class="hljs-comment">// Simple example without cache. var method = typeof(T) .GetMethod(@"op_Addition", new [] {typeof(T), typeof(T)}) ?.CreateDelegate(typeof(Func&lt;T, T, T&gt;)) as Func&lt;T, T, T&gt;; return method?.Invoke(left, right) ?? throw new InvalidOperationException(); }</span></span></code> </pre> <br><p> 不幸的是，这<a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">不起作用</a> 。 事实是算术类型（但不是<code>decimal</code> ） <em>没有</em>这种静态方法。 所有操作都是通过<code>IL</code>操作（例如<a href="" rel="nofollow"><code>add</code></a> 。 正反射不能解决我们的问题。 </p><br><h2 id="systemlinqexpressions">  System.Linq.Expressions </h2><br><p>  <a href="https://twitter.com/jonskeet" rel="nofollow">John Skeet</a>的博客（由Marc Gravell撰写）中介绍了基于<code>Expressions</code>的解决方案。 <br> 这个想法很简单。 假设我们有一个支持操作<code>+</code>的类型<code>T</code> 让我们创建一个这样的表达式： </p><br><pre> <code class="cs hljs">(x, y) =&gt; x + y;</code> </pre> <br><p> 之后，缓存后，我们将使用它。 构建这样的表达式非常容易。 我们需要两个参数和一个操作。 因此，让我们写下来。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt; Cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T); <span class="hljs-comment"><span class="hljs-comment">// If op is cached by type and function name, use cached version if (Cache.TryGetValue((t, nameof(Add)), out var del)) return del is Func&lt;T, T, T&gt; specificFunc ? specificFunc(left, right) : throw new InvalidOperationException(nameof(Add)); var leftPar = Expression.Parameter(t, nameof(left)); var rightPar = Expression.Parameter(t, nameof(right)); var body = Expression.Add(leftPar, rightPar); var func = Expression.Lambda&lt;Func&lt;T, T, T&gt;&gt;(body, leftPar, rightPar).Compile(); Cache[(t, nameof(Add))] = func; return func(left, right); }</span></span></code> </pre> <br><p> 有关表达式树和委托的有用信息已发布在中心上 </p><br><p> 从技术上讲，表达式使我们能够解决所有问题-任何基本操作都可以简化为调用通用方法。 可以使用更复杂的表达式以相同的方式编写任何更复杂的操作。 这<em>几乎</em>足够了。 </p><br><h2 id="narushaem-vse-pravila"> 我们违反了所有规则 </h2><br><p> 是否可以使用<code>CLR/C#</code>的功能实现其他目标？ 让我们看看通过<a href="https://sharplab.io/" rel="nofollow">不同类型的</a>加法生成代码的<s>年份</s> ： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-comment"><span class="hljs-comment">// Decimal only to show difference public static decimal Add(decimal x, decimal y) =&gt; x + y; }</span></span></code> </pre> <br><p> 相应的<code>IL</code>代码包含相同的指令集： </p><br><pre> <code class="cs hljs">ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret</code> </pre> <br><p> 这是用于<a href="" rel="nofollow"><code>add</code></a>算术基本类型的附加操作码。 在此位置的<code>static decimal decimal.op_Addition(decimal, decimal)</code>调用<code>static decimal decimal.op_Addition(decimal, decimal)</code> 。 但是，如果我们编写一个将被概括但完全包含此<code>IL</code>代码的方法怎么办？ 好吧，约翰·斯基特警告说，这<a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">不值得</a> 。 就他而言，他考虑了所有类型（包括<code>decimal</code> ），以及它们的<code>nullable</code>为<code>nullable</code>类似物。 这将需要非常不平凡的<code>IL</code>操作，并且必然会导致错误。 但是我们仍然可以尝试执行基本操作。 </p><br><p> 令我惊讶的是， <code>Visual Studio</code>不包含<code>IL</code>项目和<code>IL</code>文件的模板。 您不仅可以在<code>IL</code>采用和描述部分代码，还可以将其包含在程序集中。 自然，开源会为我们提供帮助。  <a href="https://github.com/ins0mniaque/ILSupport" rel="nofollow"><code>ILSupport</code></a>项目包含<code>IL</code>项目的模板，以及可以添加到<code>*.csproj</code>以在项目中包含<code>IL</code>代码的一组指令。 当然，要在<code>IL</code>描述所有内容非常困难，因此该项目的作者使用了带有<a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimploptions%3Fredirectedfrom%3DMSDN%26view%3Dnetcore-3.0" rel="nofollow"><code>ForwardRef</code></a>标志的内置<a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimplattribute%3Fview%3Dnetcore-3.0" rel="nofollow"><code>MethodImpl</code></a>属性。 此属性使您可以将方法声明为<code>extern</code> ，而不描述方法的主体。 看起来像这样： </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">MethodImpl(MethodImplOptions.ForwardRef)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p> 下一步是使用<code>IL</code>代码在<code>*.il</code>文件中编写该方法的实现： </p><br><pre> <code class="cs hljs">.method <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> hidebysig !!T Add&lt;valuetype .ctor (<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> [<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">ValueType</span></span> <span class="hljs-title"><span class="hljs-title">modreq</span></span> ([<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Runtime</span></span>.<span class="hljs-title"><span class="hljs-title">InteropServices</span></span>.<span class="hljs-title"><span class="hljs-title">UnmanagedType</span></span>)) <span class="hljs-title"><span class="hljs-title">T</span></span>&gt;(!!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">left</span></span>, !!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">right</span></span>) <span class="hljs-title"><span class="hljs-title">cil</span></span> <span class="hljs-title"><span class="hljs-title">managed</span></span> { .param type [<span class="hljs-number"><span class="hljs-number">1</span></span>] .custom instance <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> System.Runtime.CompilerServices.IsUnmanagedAttribute::.ctor() = (<span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ) ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret }</code> </pre> <br><p> 没有地方明确引用类型<code>!!T</code> ，我们建议<code>CLR</code>添加两个参数并返回结果。  <strong>没有</strong>类型检查，一切都取决于开发人员的良心。 出人意料的是，它可以工作并且<em>相对</em>较快。 </p><br><h2 id="nemnogo-benchmarka"> 有点基准 </h2><br><p> 诚实的基准可能建立在一些相当复杂的表达式上，将其“正面”计算与这些危险的<code>IL</code>方法进行比较。 我写了一个简单的算法，将先前计算并存储在<code>double</code>精度数组中的数字平方求和，然后将最终数量除以数字数。 为了执行该操作，我像正常人一样使用<code>C#</code>运算符<code>+</code> ， <code>*</code>和<code>/</code> ，使用<code>Expressions</code>构建的函数以及<code>IL</code>函数。 </p><br><div class="spoiler">  <b class="spoiler_title">结果大致如下：</b> <div class="spoiler_text"><ul><li>  <code>DirectSum</code>是使用标准运算符<code>+</code> ， <code>*</code>和<code>/</code>和。 </li><li>  <code>BranchSum</code>使用类型进行分支并通过<code>object</code>转换； </li><li>  <code>UnsafeBranchSum</code>使用按类型的分支，并通过<code>Unsafe.As&lt;,&gt;()</code> ； </li><li>  <code>ExpressionSum</code>对每个操作使用缓存的表达式（ <code>Expression</code> ）； </li><li>  <code>UnsafeSum</code>使用本文中介绍的<code>IL</code>不安全代码 </li></ul><br><p> 有效载荷基准-将类型为<code>double</code>和大小为<code>N</code>的随机预填充数组的元素平方求和，然后将和除以<code>N</code>并存储； 包括优化。 </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.12.0, OS=Windows 10.0.18362 Intel Core i7-2700K CPU 3.50GHz (Sandy Bridge), 1 CPU, 8 logical and 4 physical cores .NET Core SDK=3.1.100 [Host] : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Job-POXTAH : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Runtime=.NET Core 3.1</code> </pre><br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th>  ñ </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th><th> 比例 </th><th> 比率SD </th></tr></thead><tbody><tr><td>  <strong>直接和</strong> </td><td>  <strong>1000</strong> </td><td>  <strong>2.128我们</strong> </td><td>  <strong>0.0341美元</strong> </td><td>  <strong>0.0303我们</strong> </td><td>  <strong>1.00</strong> </td><td>  <strong>0.00</strong> </td></tr><tr><td> 分支 </td><td>  1000 </td><td>  57.468我们 </td><td>  0.4478我们 </td><td>  0.3496我们 </td><td>  26.97 </td><td>  0.46 </td></tr><tr><td> 不安全分支总和 </td><td>  1000 </td><td>  72.924我们 </td><td>  0.4131我们 </td><td>  0.3864我们 </td><td>  34.28 </td><td>  0.50 </td></tr><tr><td> 表达式总和 </td><td>  1000 </td><td>  144.555我们 </td><td>  2.5182我们 </td><td>  2.2323我们 </td><td>  67.94 </td><td>  1.29 </td></tr><tr><td> 不安全总和 </td><td>  1000 </td><td>  5.054我们 </td><td>  0.0324我们 </td><td>  0.0303我们 </td><td>  2.37 </td><td>  0.03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>直接和</strong> </td><td>  <strong>10,000</strong> </td><td>  <strong>21.174我们</strong> </td><td>  <strong>0.3092我们</strong> </td><td>  <strong>0.2741我们</strong> </td><td>  <strong>1.00</strong> </td><td>  <strong>0.00</strong> </td></tr><tr><td> 分支 </td><td>  10,000 </td><td>  573.972我们 </td><td>  2.9274我们 </td><td>  2.5951我们 </td><td>  11/27 </td><td>  0.40 </td></tr><tr><td> 不安全分支总和 </td><td>  10,000 </td><td>  735.031美元 </td><td>  9.1016我们 </td><td>  8.0683我们 </td><td>  34.72 </td><td>  0.53 </td></tr><tr><td> 表达式总和 </td><td>  10,000 </td><td>  1,462.593美元 </td><td>  9.0932我们 </td><td>  8.0609我们 </td><td>  69.09 </td><td>  1.02 </td></tr><tr><td> 不安全总和 </td><td>  10,000 </td><td>  50.388我们 </td><td>  0.3956我们 </td><td>  0.3701我们 </td><td>  2.38 </td><td>  0.03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>直接和</strong> </td><td>  <strong>100,000</strong> </td><td>  <strong>210.021我们</strong> </td><td>  <strong>1.9832我们</strong> </td><td>  <strong>1.7581我们</strong> </td><td>  <strong>1.00</strong> </td><td>  <strong>0.00</strong> </td></tr><tr><td> 分支 </td><td>  100,000 </td><td>  6,046.340我们 </td><td>  86.9740我们 </td><td>  77.1002我们 </td><td>  28.79 </td><td>  0.42 </td></tr><tr><td> 不安全分支总和 </td><td>  100,000 </td><td>  7,406.489美元 </td><td>  65.7415我们 </td><td>  58.2782我们 </td><td>  35.27 </td><td>  0.27 </td></tr><tr><td> 表达式总和 </td><td>  100,000 </td><td>  14,021.642美元 </td><td>  189.2625我们 </td><td>  167.7763我们 </td><td>  66.77 </td><td>  0.88 </td></tr><tr><td> 不安全总和 </td><td>  100,000 </td><td>  505.551我们 </td><td>  2.3662我们 </td><td>  2.2133我们 </td><td>  2.41 </td><td>  0.03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>直接和</strong> </td><td>  <strong>1,024,000</strong> </td><td>  <strong>2,306.751美元</strong> </td><td>  <strong>22.4173我们</strong> </td><td>  <strong>20.9692我们</strong> </td><td>  <strong>1.00</strong> </td><td>  <strong>0.00</strong> </td></tr><tr><td> 分支 </td><td>  1,024,000 </td><td>  61,643.224美元 </td><td>  610.3048我们 </td><td>  570.8795我们 </td><td>  26.72 </td><td>  0.28 </td></tr><tr><td> 不安全分支总和 </td><td>  1,024,000 </td><td>  75,644.639美元 </td><td>  494.4096美元 </td><td>  462.4711我们 </td><td>  32.80 </td><td>  0.39 </td></tr><tr><td> 表达式总和 </td><td>  1,024,000 </td><td>  154,327.137美元 </td><td>  1,267.2469我们 </td><td>  1,185.3835我们 </td><td>  66.91 </td><td>  0.55 </td></tr><tr><td> 不安全总和 </td><td>  1,024,000 </td><td>  5,295.990美元 </td><td>  14.9537我们 </td><td>  12.4871我们 </td><td>  2.29 </td><td>  0.02 </td></tr></tbody></table></div></div></div><br><p> 我们的不安全代码慢了大约<code>2.5</code>倍（就一次操作而言）。 这可以归因于以下事实：在“前额”计算的情况下，编译器将<code>a + b</code>编译为<code>add</code> op代码，在不安全的方法的情况下，将调用静态函数，该函数自然较慢。 </p><br><h2 id="vmesto-zaklyucheniya-kogda-true--true"> 而不是结论：when <code>true != true</code> </h2><br><p> 几天前，我<a href="https://twitter.com/jaredpar/status/1205540750764625920" rel="nofollow">从</a> Jared Parsons看到了这样一条<a href="https://twitter.com/jaredpar/status/1205540750764625920" rel="nofollow">推文</a> ： </p><br><blockquote> 在某些情况下，以下内容将显示“ false” <br> 布尔b = ... <br> 如果（b）Console.WriteLine（b.IsTrue（））; </blockquote><p> 这是<a href="https://twitter.com/vreshetnikov/status/1204929378368417792" rel="nofollow">该条目的</a>答案，它显示了<code>bool</code>验证代码<code>true</code> ，看起来像这样： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsTrue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; !<span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p> 检查似乎多余，对不对？  Jared提出了一个反例，演示<a href="https://gist.github.com/jaredpar/a0835afc71139284c09bfda203d8c011" rel="nofollow">了</a> <code>bool</code>行为的<a href="https://gist.github.com/jaredpar/a0835afc71139284c09bfda203d8c011" rel="nofollow">一些特征</a> 。 这个想法是<code>bool</code>是<code>byte</code> （ <code>sizeof(bool) == 1</code> ），而<code>false</code>匹配<code>0</code> ， <code>true</code>匹配<code>1</code> 。 只要您不摆动指针， <code>bool</code>表现就可以明确且可预测。 但是，正如Jared所示，您可以使用<code>2</code>作为初始值来创建<code>bool</code>值，并且部分检查将正确失败： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptr = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;b; *ptr = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><p> 我们可以使用不安全的数学运算来达到类似的效果（这不适用于<code>Expressions</code> ）： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fakeTrue = Subtract&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;fakeTrue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fakeTrue) Assert.AreNotEqual(fakeTrue, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Assert.Fail(<span class="hljs-string"><span class="hljs-string">"Clause not entered."</span></span>);</code> </pre> <br><p> 是的，是的，我们在<code>true</code>分支内检查条件是否为<code>true</code> ，并且我们期望实际上<em>不是<code>true</code></em> 。 为什么会这样呢？ 如果不检查就从<code>0</code> （ <code>=false</code> ） <code>1</code> （ <code>=true</code> ）减去，那么对于<code>byte</code>这将等于<code>255</code> 。 当然， <code>255</code> （我们的<code>fakeTrue</code> ）不是<code>1</code> （真正的<code>true</code> ），因此将执行assert。 分支的工作方式不同。 </p><br><p>  <code>if</code>发生反转：插入条件分支； 如果条件为<em>false</em> ，则在<code>if</code>块结束之后发生到该点的转换。 验证由<code>brfalse</code> / <code>brfalse_S</code> 。 它将堆栈上的最后一个值与<em>零</em>进行比较。 如果值为零，则为<code>false</code> ，我们跳过<code>if</code>块。 在我们的例子中， <code>fakeTrue</code>不等于零，因此检查通过，并且执行继续在<code>if</code>块内进行，在该块中，我们将<code>fakeBool</code>与真实值进行比较，得到否定的结果。 </p><br><p>  UPD01： <br> 在使用<a href="https://habr.com/en/users/shai_hulud/" class="user_link">shai_hulud</a>和<a href="https://habr.com/en/users/shai_hulud/" class="user_link">blowin</a>在评论中讨论之后，我在基准测试中添加了另一种方法来实现一个分支，例如<code>if(typeof(T) == typeof(int)) return (T)(object)((int)(object)left + (int)(object)right);</code>  。 尽管事实上<code>JIT</code>应该优化检查，至少在<code>T</code>是一个<code>struct</code> ，这种方法的运行速度仍然慢一个数量级。 优化转换<code>T</code> &gt; <code>int</code> &gt; <code>T</code>或是否使用装箱/拆箱并不明显。 基准测试的结果不受<code>MethodImpl</code>标志的明显影响。 </p><br><p>  UPD02： <br>  <a href="https://habr.com/en/users/xxxvano/" class="user_link">注释</a>中的<a href="https://habr.com/en/users/xxxvano/" class="user_link">xXxVano</a>显示了一个按类型使用分支的示例，并使用<code>Unsafe.As&lt;TFrom, TTo&gt;()</code>将<code>T</code> &lt;-&gt;转换为特定类型。 与通常的分支和通过<code>object</code>自定义类似，我为所有算术类型编写了三个带有分支的操作​​（加，乘和除），之后添加了另一个基准（ <code>UnsafeBranchSum</code> ）。 尽管事实上所有方法（表达式除外）都会生成几乎相同的asm代码（据我对汇编器的有限了解，我可以判断），但出于某种未知的原因，与直接求和（ <code>DirectSum</code> ）和使用泛型和<code>IL</code>代码。 对于这种影响，我没有任何解释，因为花费的时间与<code>N</code>成正比增长，这表明尽管有<code>JIT</code>的魔力，但<em>每个</em>操作都有某种恒定的开销。 方法的<code>IL</code>版本缺少此开销。   ,   <code>IL</code> -    ,    /    /  ,          100%  (  ,   ). <br>   ,      , -       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN480416/">https://habr.com/ru/post/zh-CN480416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN480402/index.html">T̶off的第二个Android mitap是如何实现的</a></li>
<li><a href="../zh-CN480404/index.html">Mikrotik和Linux。 例行与自动化</a></li>
<li><a href="../zh-CN480408/index.html">52个培训项目数据集</a></li>
<li><a href="../zh-CN480412/index.html">Alexei Ragozin在jug.msk.ru会议上讨论OpenJDK 11中Java Flight Recorder的新功能和旧功能</a></li>
<li><a href="../zh-CN480414/index.html">上周第393期（2019年12月9日至15日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN480420/index.html">Matthew“ Oki” O'Connor的动脉粥样硬化及其治疗访谈</a></li>
<li><a href="../zh-CN480422/index.html">C ++中的Google样式指南。 第一部分</a></li>
<li><a href="../zh-CN480424/index.html">C ++中的Google样式指南。 第9部分</a></li>
<li><a href="../zh-CN480428/index.html">最简单的速记方法。 她的字母和字体。</a></li>
<li><a href="../zh-CN480430/index.html">视频编解码器的工作方式。 第2部分。什么，为什么，如何</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>