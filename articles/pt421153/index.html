<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§§ üèöÔ∏è üê∂ CPU de 24 n√∫cleos, mas n√£o consigo digitar um email (parte 2) ‚úäüèª üç∏ üôéüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em um artigo anterior, prometi revelar com mais detalhes alguns detalhes que omiti durante a investiga√ß√£o [o Gmail trava no Chrome no Windows - aprox....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CPU de 24 n√∫cleos, mas n√£o consigo digitar um email (parte 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421153/"> Em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior,</a> prometi revelar com mais detalhes alguns detalhes que omiti durante a investiga√ß√£o [o Gmail trava no Chrome no Windows - aprox.  Por.], Incluindo tabelas de p√°ginas, bloqueios, WMI e o erro vmmap.  Agora preencho essas lacunas junto com exemplos de c√≥digo atualizados.  Mas primeiro, esboce brevemente a ess√™ncia. <br><br>  O ponto foi que um processo que oferece suporte ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Control Flow Guard</a> (CFG) aloca mem√≥ria execut√°vel, al√©m de alocar mem√≥ria CFG que o Windows nunca libera.  Portanto, se voc√™ continuar alocando e liberando mem√≥ria execut√°vel <i>em endere√ßos diferentes</i> , o processo acumular√° uma quantidade arbitr√°ria de mem√≥ria CFG.  O navegador Chrome faz isso, o que leva a um vazamento de mem√≥ria quase ilimitado e congela em algumas m√°quinas. <br><br>  Deve-se observar que √© dif√≠cil evitar congelamentos se o VirtualAlloc come√ßar a executar mais de um milh√£o de vezes mais devagar que o normal. <br><a name="habracut"></a><br>  Al√©m do CFG, h√° outra mem√≥ria desperdi√ßada, embora n√£o seja tanto quanto o vmmap afirma. <br><br><h1>  CFG e p√°ginas </h1><br>  A mem√≥ria do programa e a mem√≥ria CFG s√£o finalmente alocadas com p√°ginas de 4 kilobytes (mais sobre isso posteriormente).  Como 4 KB de mem√≥ria CFG podem descrever 256 KB de mem√≥ria de programa (mais sobre isso mais tarde), isso significa que, se voc√™ selecionar um bloco de mem√≥ria de 256 KB alinhado com 256 KB, receber√° uma p√°gina CFG de 4 KB.  E se voc√™ alocar um bloco execut√°vel de 4 KB, ainda receber√° uma p√°gina CFG de 4 KB, mas a maior parte n√£o ser√° usada. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f10/0c2/e19/f100c2e19331ea5b1e313961be362c80.png" align="right">  Tudo fica mais complicado se a mem√≥ria execut√°vel for liberada.  Se voc√™ usar a fun√ß√£o VirtualFree em um bloco de mem√≥ria execut√°vel que n√£o seja m√∫ltiplo de 256 KB ou n√£o esteja alinhado em 256 KB, o sistema operacional dever√° realizar algumas an√°lises e verificar se alguma outra mem√≥ria execut√°vel n√£o usa uma p√°gina CFG.  Os autores do CFG decidiram n√£o se incomodar - e simplesmente deixaram para sempre a mem√≥ria CFG alocada.  √â muito lament√°vel.  Isso significa que, quando meu programa de teste aloca e libera 1 gigabyte de mem√≥ria execut√°vel alinhada, ele deixa 16 MB de mem√≥ria CFG. <br><br>  Na pr√°tica, verifica-se que, quando o mecanismo JavaScript do Chrome aloca e libera 128 MB de mem√≥ria execut√°vel alinhada (nem toda ela foi usada, mas todo o intervalo foi alocado e liberado imediatamente), at√© 2 MB de mem√≥ria CFG permanecer√£o alocados, embora seja trivial liber√°-lo completamente .  Como o Chrome aloca e libera repetidamente a mem√≥ria em endere√ßos aleat√≥rios, isso leva ao problema descrito acima. <br><br><h1>  Mem√≥ria perdida adicional </h1><br>  Em qualquer sistema operacional moderno, cada processo obt√©m seu pr√≥prio espa√ßo de endere√ßo de mem√≥ria virtual, para que o sistema operacional isole processos e proteja a mem√≥ria.  Isso √© feito usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma unidade de gerenciamento de mem√≥ria</a> (MMU) e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tabelas de p√°ginas</a> .  A mem√≥ria √© dividida em p√°ginas de 4 KB.  Essa √© a quantidade m√≠nima de mem√≥ria que o sistema operacional fornece.  Cada p√°gina √© indicada por um registro de oito bytes na tabela de p√°ginas e os pr√≥prios registros s√£o armazenados em p√°ginas de 4 KB.  Cada um deles aponta para um m√°ximo de 512 p√°ginas diferentes de mem√≥ria, portanto, precisamos de uma hierarquia de tabelas de p√°ginas.  Para um espa√ßo de endere√ßo de 48 bits em um sistema operacional de 64 bits, o sistema √© o seguinte: <br><br><ul><li>  Uma tabela de n√≠vel 1 cobre 256 TB (48 bits), apontando para 512 tabelas diferentes de n√≠vel 2 de p√°gina </li><li>  Cada tabela de n√≠vel 2 abrange 512 GB, apontando para 512 tabelas de n√≠vel 3 </li><li>  Cada tabela do n√≠vel 3 abrange 1 GB, apontando para 512 tabelas do n√≠vel 4 </li><li>  Cada tabela do n√≠vel 4 abrange 2 MB, apontando para 512 p√°ginas f√≠sicas </li></ul><br>  A MMU indexa a tabela do 1¬∫ n√≠vel nos primeiros 9 (de 48) bits do endere√ßo, as tabelas do 2¬∫ n√≠vel nos pr√≥ximos 9 bits e os demais n√≠veis recebem 9 bits, ou seja, apenas 36 bits.  Os 12 bits restantes s√£o usados ‚Äã‚Äãpara indexar p√°ginas de 4 kilobytes de uma tabela de 4¬∫ n√≠vel.  Bem, bem. <br><br>  Se voc√™ preencher imediatamente todos os n√≠veis das tabelas, precisar√° de mais de 512 GB de RAM, para que eles sejam preenchidos conforme necess√°rio.  Isso significa que, ao alocar uma p√°gina de mem√≥ria, o sistema operacional seleciona algumas tabelas de p√°ginas - de zero a tr√™s, dependendo se os endere√ßos alocados est√£o em uma √°rea n√£o utilizada anteriormente de 2 MB, uma √°rea n√£o utilizada anteriormente de 1 GB ou uma √°rea n√£o utilizada anteriormente de 512 GB (tabela de p√°ginas de n√≠vel 1 sempre se destaca). <br><br>  Em resumo, alocar para endere√ßos aleat√≥rios √© muito mais caro do que alocar para endere√ßos pr√≥ximos, pois, no primeiro caso, as tabelas de p√°ginas n√£o podem ser compartilhadas.  Os vazamentos de CFG s√£o raros; portanto, quando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vmmap</a> mostrou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">412.480</a> KB de tabelas de p√°ginas usadas no Chrome, presumi que os n√∫meros estavam corretos.  Aqui est√° uma captura de tela do vmmap com o layout de mem√≥ria chrome.exe do artigo anterior, mas com a linha Tabela da p√°gina: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08b/7b7/b4d/08b7b7b4dda4d0b54b3017b5eb80c7ab.png"><br><br>  Mas algo parecia errado.  Decidi adicionar um simulador de tabela de p√°ginas √† minha ferramenta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VirtualScan</a> .  Ele calcula quantas p√°ginas de tabelas de p√°ginas s√£o necess√°rias para toda a mem√≥ria alocada durante o processo de digitaliza√ß√£o.  Voc√™ s√≥ precisa digitalizar a mem√≥ria alocada, adicionando ao contador um n√∫mero m√∫ltiplo de 2 MB, 1 GB ou 512 GB. <br><br>  Foi rapidamente descoberto que os resultados do simulador correspondem ao vmmap em processos normais, mas n√£o em processos com uma grande quantidade de mem√≥ria CFG.  A diferen√ßa corresponde aproximadamente √† mem√≥ria CFG alocada.  Para o processo acima, em que o vmmap fala sobre 402,8 MB (412.480 KB) de tabelas de p√°ginas, minha ferramenta mostra 67,7 MB. <br><br><pre>  Tempo de verifica√ß√£o, confirmado, tabelas de p√°ginas, blocos confirmados
 Total: 41.763s, 1457,7 MiB, 67,7 MiB, 32112, 98 blocos de c√≥digo
 CFG: 41.759s, 353,3 MiB, 59,2 MiB, 24866 </pre><br><br>  Verifiquei o erro do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vmmap</a> executando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VAllocStress</a> , que nas configura√ß√µes padr√£o faz com que o Windows aloque 2 gigabytes de mem√≥ria CFG.  O vmmap alegou ter alocado 2 gigabytes de tabelas de p√°ginas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89c/e6e/33f/89ce6e33f668a6de32abc6a0231bd3e1.png"><br><br>  E quando conclu√≠ o processo por meio do Gerenciador de tarefas, o vmmap mostrou que a quantidade de mem√≥ria alocada diminu√≠a em apenas 2 gigabytes.  Portanto, o vmmap est√° errado, meus c√°lculos com tabelas de p√°ginas est√£o corretos e, ap√≥s uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">discuss√£o</a> proveitosa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no Twitter,</a> enviei um relat√≥rio sobre o erro do vmmap, que deve ser corrigido.  A mem√≥ria CFG ainda consome muitas entradas da tabela de p√°ginas (59,2 MB no exemplo acima), mas n√£o tanto quanto o vmmap diz, e depois de corrigi-la n√£o consumir√° nada. <br><br><h1>  O que s√£o CFG e CFG? </h1><br>  Eu quero voltar um pouco e dizer com mais detalhes o que √© CFG. <br><br>  CFG significa Control Flow Guard.  Este √© um m√©todo de prote√ß√£o contra explora√ß√µes, reescrevendo ponteiros de fun√ß√£o.  Com o CFG ativado, o compilador e o SO juntos verificam a validade do destino da ramifica√ß√£o.  Primeiro, o byte de controle CFG correspondente √© carregado a partir da √°rea CFG reservada de 2 TB.  O processo de 64 bits no Windows gerencia o espa√ßo de endere√ßo de 128 TB, portanto, dividir o endere√ßo por 64 permite encontrar o byte CFG correspondente para esse objeto. <br><br> <code>uint8_t cfg_byte = cfg_base[size_t(target_addr) / 64];</code> <br> <br>  Agora, temos um byte que deve descrever quais endere√ßos no intervalo de 64 bytes s√£o destinos de ramifica√ß√£o v√°lidos.  Para fazer isso, o CFG trata o byte como quatro valores de dois bits, cada um dos quais corresponde a um intervalo de 16 bytes.  Esse n√∫mero de dois bits (cujo valor √© de zero a tr√™s) √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interpretado da seguinte maneira</a> : <br><br><ul><li>  0 - todos os destinos neste bloco de 16 bytes s√£o destinos inv√°lidos de ramifica√ß√µes indiretas </li><li>  1 - o endere√ßo inicial neste bloco de 16 bytes √© o destino v√°lido da ramifica√ß√£o indireta </li><li>  2 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">associado a chamadas CFG "suprimidas"</a> ;  endere√ßo potencialmente inv√°lido </li><li>  3 - endere√ßos n√£o alinhados neste bloco de 16 bytes s√£o destinos v√°lidos de uma ramifica√ß√£o indireta, no entanto, um endere√ßo alinhado de 16 bytes √© potencialmente inv√°lido </li></ul><br>  Se o destino da ramifica√ß√£o indireta for inv√°lido, o processo ser√° encerrado e a explora√ß√£o ser√° impedida.  Viva! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/1af/827/a081af827b3df7b40e8b8530b7cbd1a4.png"><br><br>  A partir disso, podemos concluir que, para seguran√ßa m√°xima, os objetivos indiretos da ramifica√ß√£o devem ser alinhados por 16 bytes e podemos entender por que a mem√≥ria CFG do processo √© aproximadamente 1/64 da mem√≥ria do programa. <br><br><blockquote>  Na verdade, o CFG carrega 32 bits por vez, mas esses s√£o detalhes de implementa√ß√£o.  Muitas fontes descrevem a mem√≥ria CFG como um bit de 8 bytes em vez de um bit de 16 bytes.  Minha explica√ß√£o √© melhor. </blockquote><br><h1>  √â por isso que tudo est√° ruim </h1><br>  O Gmail trava por dois motivos.  Primeiro, a digitaliza√ß√£o da mem√≥ria CFG no Windows 10 16299 ou anterior √© muito lenta.  Vi como a varredura do espa√ßo de endere√ßamento de um processo leva 40 segundos ou mais e, literalmente, 99,99% desse tempo, a mem√≥ria reservada do CFG √© varrida, embora represente apenas 75% dos blocos de mem√≥ria fixos.  N√£o sei por que a verifica√ß√£o foi t√£o lenta, mas eles a corrigiram no Windows 10 17134, por isso n√£o faz sentido estudar o problema com mais detalhes. <br><br>  A verifica√ß√£o lenta causou uma desacelera√ß√£o porque o Gmail queria redund√¢ncia de CFG e o WMI reteve o bloqueio durante a verifica√ß√£o.  Mas o bloqueio de reserva de mem√≥ria n√£o foi mantido durante a verifica√ß√£o.  No meu exemplo, existem aproximadamente 49.000 blocos na √°rea CFG, e a fun√ß√£o <i>NtQueryVirtualMemory</i> , que recebe e libera o bloqueio, foi chamada uma vez para cada um deles.  Portanto, o bloqueio foi obtido e liberado ~ 49.000 vezes e cada vez foi mantido por menos de 1 milissegundo. <br><br>  Mas, embora o bloqueio tenha sido liberado 49.000 vezes, o processo do Chrome, por algum motivo, n√£o foi poss√≠vel.  Isso √© injusto! <br><br>  Essa √© a ess√™ncia do problema.  Como escrevi da √∫ltima vez: <br><br><blockquote>  Isso ocorre porque os bloqueios do Windows s√£o inerentemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">injustos</a> - e se o thread libera o bloqueio e o solicita imediatamente novamente, ele pode ser recuperado para sempre. </blockquote><br>  Bloqueio justo significa que dois segmentos concorrentes o receber√£o por sua vez.  Mas isso significa muitas op√ß√µes de contexto caras, portanto, por um longo tempo, o bloqueio n√£o ser√° usado. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/713/348/9de/7133489de2c1eca7dc2b2c91b08e1871.png"><br><br>  Bloqueios injustos s√£o mais baratos e n√£o fazem com que os threads fiquem na fila.  Eles apenas capturam a fechadura, como mencionado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo de Joe Duffy</a> .  Ele tamb√©m escreve: <br><br><blockquote>  A introdu√ß√£o de fechaduras injustas pode indubitavelmente levar √† fome.  Mas, estatisticamente, o tempo em sistemas paralelos tende a ser t√£o vari√°vel que cada thread recebe uma virada para execu√ß√£o, do ponto de vista probabil√≠stico. </blockquote><br>  Como correlacionar a afirma√ß√£o de Joe de 2006 sobre a raridade da fome com a minha experi√™ncia em um problema 100% repetido e de longo prazo?  Eu acho que o principal motivo foi o que aconteceu em 2006.  A Intel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lan√ßou o Core Duo</a> , e os computadores com v√°rios n√∫cleos s√£o onipresentes. <br><br>  Afinal, acontece que esse problema de fome ocorre apenas em um sistema multin√∫cleo!  Nesse sistema, o thread WMI libera a trava, sinaliza o thread do Chrome para ativar e continua.  Como o fluxo WMI j√° est√° em execu√ß√£o, ele possui um ‚Äúhandicap‚Äù na frente do fluxo do Chrome, para que possa chamar facilmente o <i>NtQueryVirtualMemory</i> novamente e recuperar o bloqueio antes que o Chrome possa fazer isso. <br><br>  Obviamente, em um sistema de n√∫cleo √∫nico, apenas um encadeamento pode funcionar por vez.  Como regra, o Windows aumenta a prioridade de um novo encadeamento, e aumentar a prioridade significa que, quando o bloqueio for liberado, o novo encadeamento do Chrome estar√° pronto e imediatamente avan√ßar√° no encadeamento WMI.  Isso d√° ao thread do Chrome muito tempo para acordar e bloquear, e a fome nunca chega. <br><br>  Voc√™ entende?  Em um sistema com v√°rios n√∫cleos, na maioria dos casos, um aumento de prioridade n√£o afeta o fluxo WMI, pois ser√° executado em um kernel diferente! <br><br>  Isso significa que um sistema com n√∫cleos adicionais pode <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">responder mais lentamente do</a></i> que um sistema com a mesma carga de trabalho e menos n√∫cleos.  Outra conclus√£o √© curiosa: se meu computador tiver uma carga pesada - threads com a prioridade correspondente, trabalhando em todos os n√∫cleos do processador -, travamentos poder√£o ser evitados (n√£o tente repetir isso em casa). <br><br>  Assim, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bloqueios injustos</a> aumentam a produtividade, mas podem levar √† fome.  Suspeito que a solu√ß√£o possa ser o que chamo de bloqueios "√†s vezes justos".  Digamos, 99% das vezes elas ser√£o injustas, mas em 1% a trava para outro processo.  Isso preservar√° os benef√≠cios da produtividade com mais, evitando o problema da fome.  Anteriormente, os bloqueios do Windows eram distribu√≠dos de maneira justa e voc√™ provavelmente pode retornar parcialmente a esse problema, encontrando o equil√≠brio perfeito.  Isen√ß√£o de responsabilidade: eu n√£o sou especialista em bloqueios ou engenheiro de SO, mas estou interessado em ouvir pensamentos sobre isso e, pelo menos, n√£o sou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o primeiro a oferecer algo assim</a> . <br><br>  Linus Torvalds recentemente apreciou a import√¢ncia das fechaduras justas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Talvez seja hora de mudar tamb√©m no Windows. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para resumir</a> : O bloqueio por alguns segundos n√£o √© bom, limita a simultaneidade.  Por√©m, em sistemas com v√°rios n√∫cleos com bloqueios injustos, a remo√ß√£o e o recebimento imediato do bloqueio se comportam <i>exatamente dessa maneira</i> - outros threads n√£o t√™m como funcionar. <br><br><h1>  Quase uma falha no ETW </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/d69/a68/740/d69a68740eb8df0f6962d53db91190b7.png" align="right">  Para toda essa pesquisa, contei com o rastreamento ETW, por isso fiquei um pouco assustado ao descobrir, no in√≠cio da investiga√ß√£o, que o Windows Performance Analyzer (WPA) n√£o podia carregar caracteres do Chrome.  Estou certo de que, literalmente, na semana passada tudo deu certo.  O que aconteceu ... <br><br>  Aconteceu que o Chrome M68 saiu e foi vinculado usando o lld-link em vez do vinculador VC ++.  Se voc√™ executar o <i>dumpbin</i> e examinar as informa√ß√µes de depura√ß√£o, ver√°: <br><br> <code>C:\b\c\b\win64_clang\src\out\Release_x64\./initialexe/chrome.exe.pdb</code> <br> <br>  Bem, provavelmente o WPA n√£o gosta dessas barras.  Mas ainda n√£o faz sentido, porque mudei o vinculador para lld-link e lembro que testei o WPA antes disso, ent√£o o que aconteceu ... <br><br>  Aconteceu que o motivo estava na nova vers√£o WPA 17134. Testei o layout lld-Link - e funcionou bem no WPA 16299. Que coincid√™ncia!  O novo vinculador e o novo WPA n√£o eram compat√≠veis. <br><br>  Instalei a vers√£o antiga do WPA para continuar a investiga√ß√£o (xcopy de uma m√°quina com a vers√£o antiga) e relatei um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bug do lld-link</a> , que os desenvolvedores rapidamente corrigiram.  Agora voc√™ pode retornar ao WPA 17134 quando o M69 √© montado com um vinculador fixo. <br><br><h1>  Wmi </h1><br>  O gatilho de congelamento da WMI √© um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">snap-in da Instrumenta√ß√£o de Gerenciamento do Windows</a> e eu n√£o sou bom nisso.  Descobri que em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2014 ou mais cedo,</a> algu√©m enfrentou o problema do uso significativo da CPU no <i>WmiPrvSE.exe</i> no <i>perfproc! GetProcessVaData</i> , mas n√£o forneceu informa√ß√µes suficientes para entender as causas do bug.  Em algum momento, cometi um erro e tentei descobrir que solicita√ß√£o WMI maluca poderia travar o Gmail por alguns segundos.  Conectei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alguns</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especialistas</a> √† investiga√ß√£o e passei muito tempo tentando encontrar essa consulta m√°gica.  <i>Registrei a atividade Microsoft-Windows-WMI-Activity</i> em rastreamentos ETW, experimentei o PowerShell para encontrar todas as solicita√ß√µes de Win32_Perf e me perdi em mais algumas maneiras indiretas que s√£o muito chatas para discutir.  No final, descobri que um travamento do Gmail causou esse contador, <i>Win32_PerfRawData_PerfProc_ProcessAddressSpace_Costly</i> , acionado por um PowerShell de linha √∫nica: <br><br><pre> <code class="hljs pgsql">measure-command {<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>-WmiObject -Query ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Win32_PerfFormattedData_PerfProc_ProcessAddressSpace_Costly‚Äù}</code> </pre> <br>  Fiquei <i>ainda mais</i> confuso por causa do nome do balc√£o ("querido"? S√©rio?) E porque esse contador aparece e desaparece com base em fatores que eu n√£o entendo. <br><br>  Mas os detalhes do WMI n√£o importam.  O WMI n√£o fez nada de errado - na verdade - apenas examinou a mem√≥ria.  Escrever seu pr√≥prio c√≥digo de verifica√ß√£o acabou sendo muito mais √∫til na investiga√ß√£o do problema. <br><br><h1>  Hassle for Microsoft </h1><br>  Chrome lan√ßou um patch, o resto √© para a Microsoft. <br><br><ol><li>  <s>Acelere a digitaliza√ß√£o da regi√£o CFG</s> - OK, est√° pronto </li><li>  Libere mem√≥ria CFG quando a mem√≥ria execut√°vel √© liberada - pelo menos no caso do alinhamento de 256K, √© <i>f√°cil</i> </li><li>  Considere um sinalizador que permita alocar mem√≥ria execut√°vel sem mem√≥ria CFG ou use PAGE_TARGETS_INVALID para esse fim.  Observe que o manual <i>Windows Internals Part 1 7th Edition</i> diz que ‚Äúvoc√™ deve selecionar p√°ginas [CFG] com pelo menos um conjunto de bits {1, X}‚Äù - se o Windows 10 implementar isso, o sinalizador PAGE_TARGETS_INVALID ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">atualmente usado pelo mecanismo v8</a> ) evitar√° aloca√ß√£o de mem√≥ria </li><li>  Corrija o c√°lculo das tabelas de p√°ginas no vmmap para processos com um grande n√∫mero de aloca√ß√µes de CFG </li></ol><br><h1>  Atualiza√ß√µes de c√≥digo </h1><br>  Atualizei os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplos de c√≥digo</a> , especialmente o VAllocStress.  Existem 20 linhas inclu√≠das para demonstrar como encontrar uma reserva CFG para um processo.  Tamb√©m adicionei c√≥digo de teste que usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>SetProcessValidCallTargets</i></a> para verificar o valor dos bits CFG e demonstrar os truques necess√°rios para cham√°-los com √™xito (dica: chamar via GetProcAddress provavelmente levar√° √† viola√ß√£o do CFG!) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt421153/">https://habr.com/ru/post/pt421153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt421139/index.html">Frontend Conf - cuidando do usu√°rio</a></li>
<li><a href="../pt421141/index.html">An√°lise de muta√ß√£o ou como testar testes</a></li>
<li><a href="../pt421143/index.html">Aurora Labs Impressora 3D mini-metal S-Titanium Pro</a></li>
<li><a href="../pt421147/index.html">Monstros ap√≥s as f√©rias: AMD Threadripper 2990WX 32-Core e 2950X 16-Core</a></li>
<li><a href="../pt421149/index.html">Algumas palavras sobre gradientes</a></li>
<li><a href="../pt421155/index.html">Impress√£o 3D em 2018: a coisa mais interessante da ind√∫stria</a></li>
<li><a href="../pt421157/index.html">O Facebook far√° pesquisas sobre resson√¢ncia magn√©tica usando IA</a></li>
<li><a href="../pt421159/index.html">Como encontrar um mentor / mentor de neg√≥cios?</a></li>
<li><a href="../pt421161/index.html">Seguran√ßa da informa√ß√£o de pagamentos banc√°rios sem dinheiro. Parte 7 - Modelo B√°sico de Amea√ßas</a></li>
<li><a href="../pt421163/index.html">Existe uma alternativa do Excel ao or√ßamento e intelig√™ncia de neg√≥cios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>