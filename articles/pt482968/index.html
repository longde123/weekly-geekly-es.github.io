<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😽 🧘🏾 ☹️ Quarkus - Um novo olhar sobre o Java nativo da nuvem 🐙 🔯 🎟️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! 

 No próximo ano, planejamos desenvolver seriamente temas de contêiner, Java nativo da nuvem e Kubernetes . Uma continuação lógica desses t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quarkus - Um novo olhar sobre o Java nativo da nuvem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/482968/">  Olá Habr! <br><br>  No próximo ano, planejamos desenvolver seriamente temas de contêiner, <a href="https://www.piter.com/product_by_id/112863337">Java nativo da nuvem</a> e <a href="https://www.piter.com/product_by_id/125705747">Kubernetes</a> .  Uma continuação lógica desses tópicos em russo será a história sobre a estrutura do <a href="https://quarkus.io/">Quarkus</a> , já considerada em um bom artigo sobre Habré.  O artigo de hoje não se concentra tanto no “dispositivo <a href="https://habr.com/ru/company/haulmont/blog/443242/">Java ultra-</a> rápido <a href="https://habr.com/ru/company/haulmont/blog/443242/">subatômico</a> ” como nas perspectivas que o Quarkus traz para a Enterprise. <br><a name="habracut"></a><br>  Java e a JVM ainda são extremamente populares, mas, ao trabalhar com tecnologias sem servidor e microsserviços orientados à nuvem, Java e outras linguagens para a JVM são usadas cada vez menos, pois ocupam muito espaço na memória e carregam muito lentamente, o que as torna inadequadas para use com recipientes de vida curta.  Felizmente, esta situação está começando a mudar graças ao Quarkus. <br><br><h3>  1. Introdução </h3><br>  Quanto mais eu desenvolvo DevOps, contêineres e tecnologias sem servidor, mais descobri que estou escrevendo <b>meu código</b> em contêiner em contêineres leves ou <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%25BA%25D0%25B0%25D0%25BA_%25D1%2583%25D1%2581%25D0%25BB%25D1%2583%25D0%25B3%25D0%25B0">FaaS</a> <b>em Python ou JavaScript.</b>  <b>Java é simplesmente muito pesado para inicializar</b> para usar em uma estrutura sem servidor.  Em relação aos microsserviços, JavaScript ou Python fornecem carregamento mais rápido e contêineres mais compactos, tornando o Java mais eficiente. <br><br><img src="https://habrastorage.org/webt/bk/tu/uc/bktuuc-fn00w6i94twxguuygnx4.jpeg"><br><br>  <i>Python e JavaScript são os melhores idiomas para criar microsserviços baseados em nuvem</i> <br><br>  Java tem <b>mais de 20 anos</b> e, no momento de sua criação, o mundo era completamente diferente do que é agora.  Com o advento da JVM, grandes problemas foram resolvidos - conseguimos escrever o código uma vez e executá-lo em várias plataformas e sistemas operacionais.  Os contêineres permitem empacotar aplicativos, bibliotecas e recursos do sistema operacional em contêineres separados, e cada um desses contêineres pode funcionar em qualquer lugar.  <b>A portabilidade que a JVM fornece agora é menos relevante</b> .  Ao mesmo tempo, estávamos prontos para incorrer em custos adicionais para garantir a portabilidade, mas agora esses tempos já passaram.  <b>Agora você precisa de um trabalho rápido, com atrasos mínimos e aplicativos reativos que sempre estarão disponíveis</b> .  Contêineres e ferramentas de orquestração de contêineres, como o <a href="https://kubernetes.io/">Kubernetes,</a> fornecem esses recursos, independentemente da linguagem de programação. <br><br>  As empresas que mudam para arquiteturas de microsserviço pegam seus serviços baseados em <a href="https://spring.io/">Spring</a> escritos em Java, os vinculam a arquivos jar pesados, adicionam <b>JDKs</b> e os executam em um contêiner baseado em Linux.  Essa solução funciona, mas você precisa lidar com contêineres pesados ​​de 500 MB de tamanho, que são colocados em um estado de acessibilidade por 10 a 30 segundos cada;  Este é um problema sério.  Após a migração, muitas empresas estão migrando lentamente para o Python, deixando os serviços do lado do servidor em Java e, no final, parando no FaaS. <br><br>  Hoje, as tecnologias sem servidor e o FaaS são muito populares porque permitem que você se concentre nas funções de escrita sem se preocupar com a infraestrutura.  Seja como for, todos eles funcionam em contêineres, mas o provedor de nuvem gerencia seu ciclo de vida.  A melhor parte é que, depois de um certo tempo, o provedor para completamente o contêiner e retoma seu trabalho somente após a próxima chamada, ou seja, você paga apenas pelo tempo de trabalho real.  A primeira chamada de função pode durar um pouco mais que o normal, este é o famoso <b>início a frio</b> .  O fato é que o contêiner precisa de carregamento primário.  Usar Python ou JavaScript não é um problema tão grande, mas no caso de Java, o carregamento inicial pode levar de 10 a 15 segundos, e essa é uma frase e uma das razões para o declínio na popularidade do Java.  Agora precisamos de um <b>código que possa iniciar, concluir a tarefa e depois parar</b> .  Não queremos lidar com muitos threads ou processos de execução demorada, precisamos <b>de processos de vida curta que possam carregar muito rapidamente</b> . <br><br><h3>  Apresentando o Quarkus </h3><br>  Se você lê blogs técnicos ou acompanha as notícias, provavelmente pensa que o <a href="https://aws.amazon.com/ru/serverless/">paradigma sem servidor está</a> dominando o mundo, e todos o encaram com extremo entusiasmo.  Agora, uma startup pode escrever funções e fornecê-las na nuvem como um serviço - graças ao uso de JavaScript - e também escalá-las para oferecer suporte a milhões de usuários, sem precisar gerenciar a infraestrutura.  É verdade que também existe um mundo real fora do Vale do Silício: instituições financeiras, governo, varejo e muitas outras indústrias atendidas com milhões de linhas Java, caras demais para serem reescritas.  Portanto, devemos tomar como certo o fato de que nessas indústrias resta continuar a usar contêineres pesados. <br><br><img src="https://habrastorage.org/webt/if/hp/pd/ifhppdap0n0wb-8mfbwxmh9_a94.png"><br><br>  <a href="https://graalvm.org/">Hoje</a> , o <a href="https://graalvm.org/">GraalVM</a> e, em particular, o Substrate VM, abrem as portas para o futuro glorioso e de longo prazo da linguagem Java.  GraalVM é uma <b>máquina virtual universal</b> para executar aplicativos escritos em JavaScript, Python, Ruby, R e linguagens para a JVM, em particular Java, Scala ou Kotlin.  O <b>mais</b> interessante é que o <b>GraalVM permite pré-compilar (no modo AOT) os programas em um arquivo executável nativo</b> .  Isso significa que você pode compilar seu código Java diretamente no código específico da máquina.  O programa resultante não funciona na Java HotSpot VM, mas usa todos os componentes necessários, em particular gerenciamento de memória, agendamento de encadeamentos de outra implementação de uma máquina virtual chamada Substrate VM.  A VM do substrato é gravada em Java e seu código é compilado em um executável nativo.  O programa resultante é iniciado mais rapidamente e, consequentemente, fornece menor sobrecarga no uso de memória em comparação com o Java VM.  Isso é ótimo, mas você provavelmente pensa: compilação antecipada?  Isso contradiz a idéia básica para a qual a JVM foi criada, ou seja, o uso de código escrito uma vez em todos os lugares!  Isso é loucura !!!  No entanto, pense por si mesmo: agora temos contêineres e eles não precisam de uma JVM.  Os <b>aplicativos de contêiner</b> convencionais <b>criados usando a inicialização Spring têm um nível extra de abstração, o que é absolutamente desnecessário no mundo em que o Kubernetes está</b> .  Você tem um aplicativo Java em execução na JVM dentro do contêiner, esse contêiner permanece inalterado, porque hoje o produto final é um contêiner, não um aplicativo.  Agora estamos empacotando contêineres, não arquivos WAR.  Portanto, <b>todos os custos associados ao uso do aplicativo JVM dentro do contêiner se tornam inúteis</b> , e o AOT se torna uma decisão muito lógica se você for empacotar seus aplicativos em contêineres. <br><br>  É verdade que a compilação AOT limita seriamente os recursos dinâmicos do Java (carregar classes em tempo de execução, reflexão, proxies etc.).  Na prática, isso significa que 90% do ecossistema Java não funcionará sem mudanças.  Consequentemente, <b>o ecossistema Java deve se adaptar</b> .  Há boas notícias: a maior parte disso pode ser feita durante a montagem! <br><br>  Este é o poder do Quarkus.  Ele usa o GraalVM e fornece um ecossistema que suporta a compilação AOT no momento da construção;  portanto, usando Java, você pode criar binários nativos.  Graças ao Quarkus, o GraalVM <b>é disponibilizado para desenvolvedores Java</b> . <br><br><h3>  Introdução ao Quarkus </h3><br>  Como explicado acima, o Quarkus fornece compilação antecipada para aplicativos Java, e isso produz um ecossistema de Java subatômico supersônico;  O Quarkus é caracterizado por carregamento ultra-rápido - e o Java retorna ao jogo no campo do desenvolvimento baseado em nuvem.  Durante anos, nenhuma nova tecnologia me inspirou - e <a href="https://dzone.com/articles/using-quarkus-to-run-java-apps-on-kubernetes-1">não estou sozinha nisso</a> . <br><br>  Leia <a href="https://quarkus.io/guides/getting-started">o guia para iniciantes</a> - e veja por si mesmo.  Ainda existem muitas empresas usando Java + JPA dentro do contêiner, mas nessa configuração, o carregamento pode levar 15 segundos e, <b>no caso do Quarkus, 0,005!</b> <br><br><img src="https://habrastorage.org/webt/rc/ke/zy/rckezyrivwarr2wcwze7md18cru.png"><br><br>  <i>Estatísticas do Quarkus</i> <br><br>  Você está usando o mesmo IDE e as mesmas ferramentas com as quais está acostumado no mundo do Spring Boot.  Para criar seu projeto, use Maven ou Gradle.  O projeto pode ser executado diretamente no IDE e, além disso, uma reinicialização em tempo real está disponível para você com todas as alterações e você não precisa reiniciar o aplicativo.  O Quarkus não é o Spring, portanto, se você usa o Spring Boot, precisará migrar o código específico do Spring.  Felizmente, o Quarkus fornece um <a href="https://quarkus.io/guides/spring-di">nível de compatibilidade para a implementação de dependências do Spring</a> , o que simplifica bastante o trabalho.  A estrutura do Quarkus é compatível com os padrões, o que significa facilidade de portabilidade e suporte para seu código. <br><br><h3>  Processo de Desenvolvimento Quarkus </h3><br>  O Quarkus pode ser usado no modo de desenvolvimento, lembrando o Spring Boot.  Com ele, você também pode embalar seu projeto em jarra grossa.  Isso é muito conveniente para testar e depurar seu código, pois a reinicialização ao vivo é suportada;  mas você precisa compilar com antecedência para entrar em produção.  Todo o processo é mostrado no diagrama a seguir: <br><br><img src="https://habrastorage.org/webt/hr/bg/ka/hrbgkaa4flnejnwq-qiutmznacu.png"><br><br><ul><li> Primeiro, crie o aplicativo no seu IDE favorito e, em seguida, execute-o no modo de desenvolvedor com: “ <code>mvnw compile quarkus:dev</code> ”, como faria com o aplicativo Spring Boot.  Você também pode embalá-lo em uma jarra grossa. </li><li>  Assim que você concluir a etapa anterior e o resultado lhe <code>mvnw package -Pnative</code> - você está pronto para criar o arquivo binário Java, basta executar: “ <code>mvnw package -Pnative</code> ”.  Isso levará algum tempo, pois o código nativo será gerado durante a compilação com antecedência!  Quando esta etapa estiver concluída, você terá à sua disposição um arquivo executável ultra-pequeno e ultra-rápido, mas ele só funcionará na sua plataforma / sistema operacional, ou seja, não será portado!  Mas isso é normal, pois podemos colocá-lo em um contêiner - e assim garantir a portabilidade.  Aqui está como fazer isso: <code>./mvnw package -Pnative -Dnative-image.docker-build=true</code> 4 - e removemos o executável do contêiner do Docker, ou seja, executamos a montagem nativa dentro do contêiner e criamos um arquivo binário.  Essa técnica pode não funcionar no seu laptop se o sistema operacional for diferente da plataforma de destino especificada no <code>DockerFile</code> gerado pelo Quarkus durante a criação do projeto. </li><li>  Depois de ter o binário, basta criar uma imagem com base no arquivo docker.  <code>docker build -f src/main/docker/Dockerfile.native -t quarkus-quickstart/quickstart</code> . </li><li>  Por fim, o aplicativo pode ser iniciado no Docker ou no Kubernetes: <code>docker run -i --rm -p 8080:8080 quarkus-quickstart/quickstart</code> </li></ul><br><h3>  Recursos do Quarkus </h3><br>  O Quarkus possui muito mais recursos do que o código Java nativo. <br><br><ul><li>  Unificação de recursos imperativos e reativos: permite combinar código imperativo familiar com código não-bloqueador, escrito em um estilo reativo. </li><li>  <a href="https://quarkus.io/vision/developer-joy">O desenvolvedor está satisfeito</a> : uma configuração unificada, configuração Zero, reinicialização em tempo real, código otimizado otimizado para 80% dos casos comuns e código flexível para os 20% restantes, geração de arquivos executáveis ​​nativos sem problemas, codificação ao vivo. </li><li>  Carregamento incrivelmente rápido, uma área de memória residente incrivelmente pequena (sim, não é apenas do tamanho de um monte!), Que fornece escala vertical quase instantânea e uso de memória muito denso ao orquestrar contêineres em plataformas como o Kubernetes.  <a href="https://quarkus.io/vision/container-first">Veja mais detalhes</a> . </li><li>  O Quarkus oferece uma estrutura holística e fácil de usar, com bibliotecas de primeira classe que você conhece e adora incorporadas nas estruturas de suporte.  <a href="https://quarkus.io/vision/standards">Mais detalhes</a> . </li><li>  As bibliotecas Hibernate, JPA, REST, JWT etc. são suportadas. </li><li>  Configurações suportadas implantadas no <a href="https://kubernetes.io/">Kubernetes</a> e <a href="https://www.openshift.com/">OpenShift</a> </li><li>  Rastreio aberto usando Jaeger </li><li>  Suporte <a href="https://quarkus.io/guides/kotlin">Kotlin</a> </li><li>  Mensagens com Kafka, Camel ... </li><li>  E muito mais, confira a <a href="https://quarkus.io/extensions/">lista de extensões</a> ! </li></ul><br><h3>  Ecossistema Quarkus </h3><br>  <b>Em resumo, agora você pode executar os serviços transacionais tradicionais JPA / JTA em contêineres super rápidos - tanto na nuvem quanto no local</b> . <br><br><h3>  Exemplo Quarkus </h3><br>  Nesta seção, vamos dar uma olhada simplificada no <a href="https://quarkus.io/guides/getting-started">guia do iniciante para</a> dar uma impressão do poder do Quarkus. <br><br><img src="https://habrastorage.org/webt/o6/ow/w8/o6oww8qnyoxtpobjavpm4drpz4o.png"><br><br>  A maneira mais fácil de criar um novo projeto do Quarkus é abrir uma janela do prompt de comando e executar o seguinte comando: <br><br><pre> <code class="plaintext hljs">mvn io.quarkus:quarkus-maven-plugin:0.12.0:create \ -DprojectGroupId=org.acme \ -DprojectArtifactId=getting-started \ -DclassName="org.acme.quickstart.GreetingResource" \ -Dpath="/hello"</code> </pre> <br>  Isso gera um projeto Maven com o GreetingResuce, fornecendo o endpoint / hello.  Também são geradas imagens de janela de encaixe Dockerfile para arquivos nativos e jvm (imagens tradicionais na forma de jar grosso).  O código é muito limpo e simples: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"/hello"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Produces</span></span>(MediaType.TEXT_PLAIN) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; } }</code> </pre><br>  Para executar o aplicativo, use: <code>./mvnw compile quarkus:dev</code> <br>  O aplicativo é empacotado usando o pacote ./mvnw.  O resultado são 2 arquivos jar: <br><br><ul><li>  Getting-Start-1.0-SNAPSHOT.jar - contém apenas classes e recursos do projeto.  Este é um artefato comum resultante da montagem do Maven; </li><li>  Getting-Start-1.0-SNAPSHOT-runner.jar é um jar executável.  Note que isto não é "uber-jar", existem dependências aqui, elas são copiadas para o diretório target / lib. </li></ul><br>  Você pode iniciar o aplicativo usando: java -jar target / Getting-Start-1.0-SNAPSHOT-runner.jar <br><br>  Então você precisa baixar e instalar o GraalVM e configurar a variável de ambiente <code>GRAALVM_HOME</code> . <br><br>  Agora você pode criar um executável nativo com: <code>./mvnw package -Pnative -Dnative-image.docker-build=true</code> . <br><br>  Veja como criar uma imagem do Docker: <code>docker build -f src/main/docker/Dockerfile.native -t quarkus-quickstart/quickstart</code> . <br><br>  Agora ele pode ser iniciado usando qualquer mecanismo de orquestração de contêiner, se você usar o <b>minishift</b> : <br><br><pre> <code class="plaintext hljs">kubectl run quarkus-quickstart --image=quarkus-quickstart/quickstart:latest --port=8080 --image-pull-policy=IfNotPresent</code> </pre> <br><pre> <code class="plaintext hljs">kubectl expose deployment quarkus-quickstart --type=NodePort</code> </pre> <br>  Isso é tudo!  Agora você tem um contêiner com um serviço Java REST que inicia em 0.004 segundos! <br><br><h3>  Conclusão </h3><br>  Agora entendo por que estou tão impressionado com a estrutura do Quarkus suportada pela Red Hat.  Eu realmente acredito que isso mudará o cenário tecnológico de Java e proporcionará às grandes empresas tradicionais uma oportunidade real de migrar para a nuvem. <br><br>  <b>O Kubernetes + Knative + Quarkus</b> altera as regras do jogo em um desenvolvimento orientado à nuvem e agradará qualquer desenvolvedor Java. <br><br>  Este <a href="https://github.com/quarkusio/quarkus-quickstarts">repositório tem</a> muitos exemplos interessantes! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt482968/">https://habr.com/ru/post/pt482968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt482948/index.html">“Um, dois, três - queime a árvore de Natal!” Ou meu primeiro olhar para o pequeno controlador CANNY 3</a></li>
<li><a href="../pt482950/index.html">Java: coisas que podem parecer curiosas para um desenvolvedor experiente</a></li>
<li><a href="../pt482956/index.html">Revisão do WCS 5.2 - Servidor WebRTC para desenvolvedores de Webcast e webcam</a></li>
<li><a href="../pt482958/index.html">"Regras de crescimento: do júnior ao CTO", resumo de um webinar de Fedor Borshchev</a></li>
<li><a href="../pt482960/index.html">Visão geral do WCS 5.2 - Servidor WebRTC para desenvolvedores da Web de transmissões on-line e bate-papo por vídeo</a></li>
<li><a href="../pt482970/index.html">Hack The Box - Artesanato passo a passo. Exploramos o Git, exploramos vulnerabilidades na API, lidamos com o Vault</a></li>
<li><a href="../pt482974/index.html">Apoio à Saúde Mental com Realidade Virtual</a></li>
<li><a href="../pt482976/index.html">Análise de transações anônimas na negociação de ações</a></li>
<li><a href="../pt482978/index.html">Analisador de Blockchain com 300 linhas em Python</a></li>
<li><a href="../pt482980/index.html">O próprio Oracle copiou a API do Amazon S3, e está perfeitamente bem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>