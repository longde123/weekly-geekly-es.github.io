<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•° üçí üì± Inseguro.AsSpan: Span <T> ¬øC√≥mo reemplazar los punteros? üöá ü¶â üë®üèΩ‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C# es un lenguaje incre√≠blemente flexible. En √©l puede escribir no solo el backend o las aplicaciones de escritorio. Utilizo C# para trabajar con dato...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inseguro.AsSpan: Span <T> ¬øC√≥mo reemplazar los punteros?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465077/"><p><img src="https://habrastorage.org/webt/3f/dh/ia/3fdhia5h25mpjbabeocnlygdd1c.png"></p><br><p> <code>C#</code> es un lenguaje incre√≠blemente flexible.  En √©l puede escribir no solo el backend o las aplicaciones de escritorio.  Utilizo <code>C#</code> para trabajar con datos cient√≠ficos, que imponen ciertos requisitos sobre las herramientas disponibles en el lenguaje.  Aunque <code>netcore</code> toma el orden del d√≠a (teniendo en cuenta que despu√©s de <code>netstandard2.0</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mayor√≠a de las</a> caracter√≠sticas de los dos idiomas y el tiempo de ejecuci√≥n no son <code>netframework</code> con <code>netframework</code> ), sigo trabajando con proyectos <code>netframework</code> . </p><br><p>  En este art√≠culo, considero una aplicaci√≥n no obvia (¬øpero probablemente deseada?) De <code>Span&lt;T&gt;</code> y la diferencia entre la implementaci√≥n de <code>Span&lt;T&gt;</code> en <code>netframework</code> y <code>netcore</code> debido a los detalles de <code>clr</code> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Descargo de responsabilidad 1</b> <div class="spoiler_text"><p>  Los fragmentos de c√≥digo de este art√≠culo de ninguna manera est√°n destinados a su uso en proyectos del mundo real. </p><br><p>  La soluci√≥n propuesta para el problema (¬øexagerado?) Es m√°s bien una prueba de concepto. <br>  En cualquier caso, al implementar esto en su proyecto, lo hace bajo su propio riesgo y riesgo. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Descargo de responsabilidad 2</b> <div class="spoiler_text"><p>  Estoy absolutamente seguro de que en alg√∫n lugar, en alg√∫n caso, esto <strong>definitivamente</strong> disparar√° a alguien en la rodilla. </p><br><p>  El bypass de seguridad de tipo en <code>C#</code> poco probable que conduzca a algo bueno. </p><br><p>  Por razones obvias, no prob√© este c√≥digo en todas las situaciones posibles, sin embargo, los resultados preliminares parecen prometedores. </p></div></div><br><h1 id="a-zachem-mne-voobsche-spant">  ¬øPor qu√© necesito <code>Span&lt;T&gt;</code> ? </h1><br><p>  Spen le permite trabajar con matrices de tipos <code>unmanaged</code> en una forma m√°s conveniente, reduciendo el n√∫mero de asignaciones necesarias.  A pesar de que el soporte de span en el <code>netframework</code> <code>BCL</code> <code>netframework</code> casi ausente, se pueden obtener varias herramientas usando <code>System.Memory</code> , <code>System.Buffers</code> y <code>System.Runtime.CompilerServices.Unsafe</code> . <br>  El uso de vanos en mi proyecto heredado es limitado, sin embargo, me pareci√≥ un uso no obvio, mientras escup√≠a en seguridad de tipo. <br>  ¬øQu√© es esta aplicaci√≥n?  En mi proyecto trabajo con datos obtenidos de una herramienta cient√≠fica.  Estas son im√°genes que, en general, son una matriz de <code>T[]</code> , donde <code>T</code> es uno de los tipos primitivos <code>unmanaged</code> , por ejemplo <code>Int32</code> (tambi√©n conocido como <code>int</code> ).  Para serializar correctamente estas im√°genes en el disco, necesito admitir el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">formato heredado</a> incre√≠blemente inconveniente, que se propuso en <a href="">1981</a> , y desde entonces ha cambiado poco.  El principal problema de este formato es que es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BigEndian</a> .  Por lo tanto, para escribir (o leer) una matriz sin comprimir de <code>T[]</code> , debe cambiar la endianess de cada elemento.  La tarea trivial. <br>  ¬øCu√°les son algunas soluciones obvias? </p><br><ol><li>  Repetimos la matriz <code>T[]</code> , llamamos a <code>BitConverter.GetBytes(T)</code> , expandimos estos pocos bytes, copiamos a la matriz de destino. </li><li>  Repetimos la matriz <code>T[]</code> , realizamos fraudes de la forma <code>new byte[] {(byte)((x &amp; 0xFF00) &gt;&gt; 8), (byte)(x &amp; 0x00FF)};</code>  (deber√≠a funcionar en tipos de doble byte), escriba en la matriz de destino. </li><li>  <sup>* ¬ø</sup> Pero es <code>T[]</code> una matriz?  Los elementos est√°n en una fila, ¬øverdad?  Entonces puede ir hasta el final, por ejemplo, <code>Buffer.BlockCopy(intArray, 0, byteArray, 0, intArray.Length * sizeof(int));</code>  .  El m√©todo copia la matriz a la matriz ignorando la comprobaci√≥n de tipo.  Solo es necesario no perderse los l√≠mites y la asignaci√≥n.  Mezclamos los bytes como resultado. </li><li>  <sup>*</sup> Dicen que <code>C#</code> es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>(C++)++</code></a> .  Por lo tanto, active <code>/unsafe</code> , <code>fixed(int* p = &amp;intArr[0]) byte* bPtr = (byte*)p;</code>  y ahora puede ejecutar la representaci√≥n de bytes de la matriz de origen, cambiar la endianess sobre la marcha y escribir bloques en el disco (agregando <code>stackalloc byte[]</code> o <code>ArrayPool&lt;byte&gt;.Shared</code> para el b√∫fer intermedio) sin asignar memoria para una matriz de bytes completamente nueva. </li></ol><br><p>  Parece que el punto <strong>4 le</strong> permite resolver todos los problemas, pero el uso expl√≠cito del contexto <code>unsafe</code> y el trabajo con punteros es de alguna manera completamente diferente.  Entonces <code>Span&lt;T&gt;</code> viene en nuestra ayuda. </p><br><h1 id="spant"> <code>Span&lt;T&gt;</code> </h1> <br><p>  <code>Span&lt;T&gt;</code> deber√≠a proporcionar t√©cnicamente herramientas para trabajar con gr√°ficos de memoria casi como trabajar con punteros, al tiempo que elimina la necesidad de "arreglar" la matriz en la memoria.  Tal puntero compatible con <code>GC</code> con l√≠mites de matriz.  Todo est√° bien y seguro. <br>  Una cosa, pero a pesar de la riqueza de <code>System.Runtime.CompilerServices.Unsafe</code> , <code>Span&lt;T&gt;</code> clavado en el tipo <code>T</code>  Dado que spen es esencialmente un puntero de longitud <sup>1</sup> +, ¬øqu√© sucede si saca su puntero, lo convierte a otro tipo, recalcula la longitud y crea un nuevo tramo?  Afortunadamente, tenemos <code>public Span&lt;T&gt;(void* pointer, int length)</code> . <br>  Escribamos una prueba simple: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*   endianess */</span></span>} Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {<span class="hljs-number"><span class="hljs-number">123</span></span>}; Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; y = DangerousCast&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(x); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">123</span></span>, x[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Flip(y); Assert.AreNotEqual(<span class="hljs-number"><span class="hljs-number">123</span></span>, x[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Flip(y); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">123</span></span>, x[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br><p>  Desarrolladores m√°s avanzados de los que deber√≠a darme cuenta inmediatamente de lo que est√° mal aqu√≠.  ¬øLa prueba fallar√°?  La respuesta, como suele suceder, <strong>depende</strong> . <br>  En este caso, depende principalmente del tiempo de ejecuci√≥n.  En <code>netcore</code> prueba <em>deber√≠a</em> funcionar, pero en <code>netframework</code> , c√≥mo funciona. <br>  Curiosamente, si elimina algunos de los ensayos, la prueba comienza a funcionar correctamente en el 100% de los casos. <br>  Vamos a hacerlo bien. </p><br><p>  <sup>1</sup> Estaba <em>equivocado</em> . </p><br><h1 id="pravilnyy-otvet-zavisit">  Respuesta correcta: depende </h1><br><p>  ¬øPor qu√© <em>depende</em> el resultado? <br>  Eliminemos todo lo innecesario y escriba aqu√≠ dicho c√≥digo: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Check(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Check</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">-100</span></span>}; Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; y = As&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">@"FRAMEWORK_NAME"</span></span>); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y); Console.WriteLine(); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x, <span class="hljs-string"><span class="hljs-string">"Span&lt;int&gt; [0]"</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y, <span class="hljs-string"><span class="hljs-string">"Span&lt;byte&gt;[0]"</span></span>); Console.WriteLine(); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Offset&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">"Span&lt;int&gt; [0] offset by size_t"</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Offset&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">"Span&lt;byte&gt;[0] offset by size_t"</span></span>); Console.WriteLine(); GC.Collect(<span class="hljs-number"><span class="hljs-number">0</span></span>, GCCollectionMode.Forced, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x, <span class="hljs-string"><span class="hljs-string">"Span&lt;int&gt; [0] after GC"</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y, <span class="hljs-string"><span class="hljs-string">"Span&lt;byte&gt;[0] after GC"</span></span>); Console.WriteLine(); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y); }</code> </pre> <br><p>  El m√©todo <code>Write&lt;T, U&gt;</code> acepta un intervalo de tipo <code>T</code> , lee la direcci√≥n del primer elemento y lee a trav√©s de este puntero un elemento de tipo <code>U</code>  En otras palabras, <code>Write&lt;int, int&gt;(ref x)</code> generar√° la direcci√≥n en la memoria + el n√∫mero 999. <br>  Normal <code>Write</code> imprime una matriz. <br>  Ahora sobre el m√©todo <code>As&lt;,&gt;</code> : </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> Span&lt;U&gt; As&lt;T, U&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Span&lt;T&gt; span) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> U : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span>(T* ptr = span) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Span&lt;U&gt;(ptr, span.Length * Unsafe.SizeOf&lt;T&gt;() / Unsafe.SizeOf&lt;U&gt;()); }</code> </pre> <br><p>  <code>C#</code> sintaxis de <code>C#</code> ahora admite este registro de estado <code>Span&lt;T&gt;.GetPinnableReference()</code> al llamar impl√≠citamente al m√©todo <code>Span&lt;T&gt;.GetPinnableReference()</code> . <br>  Ejecute este m√©todo en <code>netframework4.8</code> en modo <code>x64</code> .  Nos fijamos en lo que sucede: </p><br><pre> <code class="plaintext hljs">LEGACY [ 999, 123, 11, -100 ] [ 231, 3, 0, 0, 123, 0, 0, 0, 11, 0, 0, 0, 156, 255, 255, 255 ] 0x|00|00|02|8C|00|00|2F|B0 999 Span&lt;int&gt; [0] 0x|00|00|02|8C|00|00|2F|B0 999 Span&lt;byte&gt;[0] 0x|00|00|02|8C|00|00|2F|B8 11 Span&lt;int&gt; [0] offset by size_t 0x|00|00|02|8C|00|00|2F|B8 11 Span&lt;byte&gt;[0] offset by size_t 0x|00|00|02|8C|00|00|2B|18 999 Span&lt;int&gt; [0] after GC 0x|00|00|02|8C|00|00|2F|B0 6750318 Span&lt;byte&gt;[0] after GC [ 999, 123, 11, -100 ] [ 110, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]</code> </pre> <br><p>  Inicialmente, ambos tramos (a pesar de los diferentes tipos) se comportan de manera id√©ntica, y el <code>Span&lt;byte&gt;</code> , en esencia, representa una vista de bytes de la matriz original.  Lo que necesitas <br>  Bien, intentemos cambiar el comienzo del lapso al tama√±o de un <code>IntPtr</code> (o <code>2 X int</code> en <code>x64</code> ) y leer.  Obtenemos el tercer elemento de la matriz y la direcci√≥n correcta.  Y luego recogeremos la basura ... </p><br><pre> <code class="plaintext hljs">GC.Collect(0, GCCollectionMode.Forced, true, true);</code> </pre> <br><p>  El √∫ltimo indicador en este m√©todo le pide al <code>GC</code> compacte el mont√≥n.  Despu√©s de llamar a <code>GC.Collect</code> <code>GC</code> mueve la matriz local original.  <code>Span&lt;int&gt;</code> refleja estos cambios, pero nuestro <code>Span&lt;byte&gt;</code> contin√∫a apuntando a la direcci√≥n anterior, donde ahora no est√° claro qu√©.  ¬°Una excelente manera de dispararte todas las rodillas a la vez! </p><br><p>  Ahora veamos el resultado del mismo fragmento de c√≥digo llamado en <code>netcore3.0.100-preview8</code> . </p><br><pre> <code class="plaintext hljs">CORE [ 999, 123, 11, -100 ] [ 231, 3, 0, 0, 123, 0, 0, 0, 11, 0, 0, 0, 156, 255, 255, 255 ] 0x|00|00|01|F2|8F|BD|C6|90 999 Span&lt;int&gt; [0] 0x|00|00|01|F2|8F|BD|C6|90 999 Span&lt;byte&gt;[0] 0x|00|00|01|F2|8F|BD|C6|98 11 Span&lt;int&gt; [0] offset by size_t 0x|00|00|01|F2|8F|BD|C6|98 11 Span&lt;byte&gt;[0] offset by size_t 0x|00|00|01|F2|8F|BD|BF|38 999 Span&lt;int&gt; [0] after GC 0x|00|00|01|F2|8F|BD|BF|38 999 Span&lt;byte&gt;[0] after GC [ 999, 123, 11, -100 ] [ 231, 3, 0, 0, 123, 0, 0, 0, 11, 0, 0, 0, 156, 255, 255, 255 ]</code> </pre> <br><p>  Todo funciona, y funciona de <em>manera estable</em> , por lo que puedo ver.  Despu√©s de la compactaci√≥n, ambos spains cambian su puntero.  Genial  Pero, ¬øc√≥mo hacer que funcione en un proyecto heredado? </p><br><h1 id="jit-intrinsic">  Jit intr√≠nseco </h1><br><p>  Olvid√© por <code>netcore</code> que el soporte para los tramos se implementa en <code>netcore</code> trav√©s de <a href="">intrinsik</a> .  En otras palabras, <code>netcore</code> puede crear punteros internos incluso para un fragmento de matriz y actualizar correctamente los enlaces cuando el <code>GC</code> mueve.  En <code>netframework</code> , la implementaci√≥n <code>nuget</code> de un span es una muleta.  De hecho, tenemos dos spen diferentes: uno se crea a partir de la matriz y rastrea sus enlaces, el segundo desde el puntero y no tiene idea de a qu√© apunta.  Despu√©s de mover la matriz original, el puntero span contin√∫a apuntando hacia donde el puntero pas√≥ a su constructor apuntado.  A modo de comparaci√≥n, este es un <em>ejemplo de</em> implementaci√≥n de span en <code>netcore</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Span&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ByReference&lt;T&gt; _pointer; <span class="hljs-comment"><span class="hljs-comment">//  -   private readonly int _length; }</span></span></code> </pre> <br><p>  y en <code>netframework</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Span&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pinnable&lt;T&gt; _pinnable; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IntPtr _byteOffset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _length; }</code> </pre> <br><p>  <code>_pinnable</code> contiene una referencia a la matriz, si una se pas√≥ al constructor, <code>_byteOffset</code> contiene un cambio (incluso el intervalo en toda la matriz tiene alg√∫n cambio distinto de cero relacionado con la forma en que la matriz se representa en la memoria, <em>probablemente</em> ).  Si pasa el puntero <code>void*</code> al constructor, simplemente se convierte en un <code>_byteOffset</code> absoluto.  Span se enclavar√° estrechamente al √°rea de memoria, y todos los m√©todos de instancia abundan en condiciones como <code>if(_pinnable is null) {/*    */} else {/*    _pinnable */}</code> .  ¬øQu√© hacer en tal situaci√≥n? </p><br><h1 id="kak-delat-ne-stoit-no-ya-vse-zhe-sdelal">  C√≥mo hacerlo no vale la pena, pero todav√≠a lo hice </h1><br><p>  Esta secci√≥n est√° dedicada a varias implementaciones compatibles con <code>netframework</code> , que permiten <code>netframework</code> <code>Span&lt;T&gt; -&gt; Span&lt;U&gt;</code> , manteniendo todos los enlaces necesarios. <br>  <strong>Te advierto: esta es una zona de programaci√≥n anormal con posibles errores fundamentales y un comportamiento indefinido al final</strong> </p><br><h2 id="metod-1-naivnyy">  M√©todo 1: ingenuo </h2><br><p>  Como muestra el ejemplo, la conversi√≥n de punteros no dar√° el resultado deseado en <code>netframework</code> .  Necesitamos el valor <code>_pinnable</code> .  Bien, descubriremos el reflejo sacando los campos privados (muy mal y no siempre es posible), lo escribiremos en una nueva inversi√≥n, estaremos felices.  Solo hay un <em>peque√±o</em> problema: spen es una <code>ref struct</code> , no puede ser un argumento gen√©rico, ni puede empaquetarse en un <code>object</code> .  Los m√©todos est√°ndar de reflexi√≥n requerir√°n, de una forma u otra, empujar la luz al tipo de referencia.  No encontr√© una manera simple (incluso considerando la reflexi√≥n en campos privados). </p><br><h2 id="metod-2-we-need-to-go-deeper">  M√©todo 2: necesitamos profundizar </h2><br><p>  Todo ya se ha hecho antes que yo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[1]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[2]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[3]</a> ).  Spen es una estructura, independientemente de <code>T</code> tres campos ocupan la misma cantidad de memoria ( <em>en la misma arquitectura</em> ).  ¬øQu√© pasa si <code>[FieldOffset(0)]</code> ?  Apenas dicho que hecho. </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Exchange&lt;T, U&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> U : unmanaged { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;T&gt; Span_1; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;U&gt; Span_2; }</code> </pre> <br><p>  Pero cuando inicia el programa (o m√°s bien, cuando intenta usar un tipo), <code>TypeLoadException</code> una <code>TypeLoadException</code> : un gen√©rico no puede ser <code>LayoutKind.Explicit</code> .  Bien, no importa, sigamos el camino dif√≠cil: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Exchange { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; ByteSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">sbyte</span></span>&gt; SByteSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span>&gt; UShortSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>&gt; ShortSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt; UIntSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; IntSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>&gt; ULongSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; LongSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; FloatSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; DoubleSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; CharSpan; }</code> </pre> <br><p>  Ahora puedes hacer esto: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Span&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">As2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exchange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exchange() { IntSpan = span }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exchange.ByteSpan; }</code> </pre> <br><p>  El m√©todo funciona con un solo problema: el campo <code>_length</code> copia tal cual, por lo que al convertir <code>int</code> -&gt; <code>byte</code> el intervalo de bytes es 4 veces m√°s peque√±o que la matriz real. <br>  No hay problema </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Raw { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Pinnable; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr Pointer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Length; } [StructLayout(LayoutKind.Explicit)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Exchange { <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Raw RawView; }</code> </pre> <br><p>  Ahora a trav√©s de <code>RawView</code> puede acceder a cada campo de extensi√≥n individual. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Span&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">As2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exchange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exchange() { IntSpan = span }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exchange2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exchange() { RawView = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Raw() { Pinnable = exchange.RawView.Pinnable, Pointer = exchange.RawView.Pointer, Length = exchange.RawView.Length * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exchange2.ByteSpan; }</code> </pre> <br><p>  Y funciona <strong>como deber√≠a</strong> , si ignoras el uso de trucos sucios.  Menos: la versi√≥n gen√©rica del convertidor no se puede crear, debe contentarse con tipos predefinidos. </p><br><h2 id="metod-3-bezumnyy">  M√©todo 3: loco </h2><br><p>  Como cualquier programador normal, me gusta automatizar las cosas.  La necesidad de escribir convertidores para cualquier par de tipos no <code>unmanaged</code> no me agrad√≥.  ¬øQu√© soluci√≥n se puede ofrecer?  As√≠ es, obtenga el <code>CLR</code> para escribir el c√≥digo <em>por usted</em> . </p><br><p>  ¬øC√≥mo lograr esto?  Hay diferentes formas, hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos</a> .  En resumen, el proceso se ve as√≠: <br>  Cree un generador de compilaci√≥n -&gt; cree un generador de m√≥dulos -&gt; cree un tipo -&gt; {Campos, m√©todos, etc.} -&gt; en la salida obtenemos una instancia de <code>Type</code> . <br>  Para comprender exactamente c√≥mo deber√≠a verse el tipo (es una <code>ref struct</code> ), utilizamos cualquier herramienta del tipo <code>ildasm</code> .  En mi caso, era <strong>dotPeek</strong> . <br>  Crear un generador de tipos se parece a esto: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeBuilder = _mBuilder.DefineType(<span class="hljs-string"><span class="hljs-string">$"Generated_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(T).Name}</span></span></span><span class="hljs-string">"</span></span>, TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.ExplicitLayout <span class="hljs-comment"><span class="hljs-comment">// &lt;-    | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit, typeof(ValueType));</span></span></code> </pre> <br><p>  Ahora los campos.  Como no podemos copiar directamente <code>Span&lt;T&gt;</code> a <code>Span&lt;U&gt;</code> debido a la diferencia en las longitudes, necesitamos crear dos tipos de cada conversi√≥n </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Generated_Int32 { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;Int32&gt; Span; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Raw Raw; }</code> </pre> <br><p>  Aqu√≠ <code>Raw</code> podemos declarar con nuestras manos y reutilizar.  No te olvides de <code>IsByRefLikeAttribute</code> .  Con los campos, todo es simple: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spanField = typeBuilder.DefineField(<span class="hljs-string"><span class="hljs-string">"Span"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Span&lt;T&gt;), FieldAttributes.Private); spanField.SetOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rawField = typeBuilder.DefineField(<span class="hljs-string"><span class="hljs-string">"Raw"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Raw), FieldAttributes.Private); rawField.SetOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Eso es todo, el tipo m√°s simple est√° listo.  Ahora guarde en cach√© el m√≥dulo de ensamblaje.  Los tipos personalizados se almacenan en cach√©, por ejemplo, en el diccionario ( <code>T -&gt; Generated_{nameof(T)}</code> ).  Creamos un contenedor que, de acuerdo con los dos tipos <code>TIn</code> y <code>TOut</code> genera dos tipos de ayudantes y realiza las operaciones necesarias en los tramos.  Hay uno pero.  Como en el caso de la reflexi√≥n, es casi imposible usarlo en tramos (o en otras <code>ref struct</code> ).  <em>O no encontr√© una soluci√≥n simple</em> .  Como ser </p><br><h2 id="delegates-to-the-rescue">  Delegados al rescate </h2><br><p>  Los m√©todos de reflexi√≥n generalmente se ven as√≠: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodInfo mi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] otherArgs</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><p>  No llevan informaci√≥n sobre los tipos, por lo que si el boxeo (= embalaje) es aceptable para usted, no hay problemas. <br>  En nuestro caso, <code>@this</code> y <code>otherArgs</code> deben contener una <code>ref struct</code> , que no pude evitar. <br>  Sin embargo, hay una manera m√°s simple.  Imaginemos que un tipo tiene m√©todos getter y setter (no propiedades, sino m√©todos simples creados manualmente). <br>  Por ejemplo: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Generated_Int32.SetSpan(Span&lt;Int32&gt; span) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Span = span;</code> </pre> <br><p>  Adem√°s del m√©todo, podemos declarar un tipo de delegado (expl√≠citamente en el c√≥digo): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SpanSetterDelegate&lt;T&gt;(Span&lt;T&gt; span) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p>  Tenemos que hacer esto porque la acci√≥n est√°ndar deber√≠a tener una firma de <code>Action&lt;Span&lt;T&gt;&gt;</code> , pero los spenes no pueden usarse como argumentos gen√©ricos.  <code>SpanSetterDelegate</code> , sin embargo, es un delegado absolutamente v√°lido. <br>  Crea los delegados necesarios.  Para hacer esto, realice manipulaciones est√°ndar: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mi = type.GetMethod(<span class="hljs-string"><span class="hljs-string">"Method_Name"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ,    public &amp; instance var spanSetter = (SpanSetterDelegate&lt;T&gt;) mi.CreateDelegate(typeof(SpanSetterDelegate&lt;T&gt;), @this);</span></span></code> </pre> <br><p>  Ahora <code>spanSetter</code> se puede usar como, por ejemplo, <code>spanSetter(Span&lt;T&gt;.Empty);</code>  .  En cuanto a <code>@this</code> <sup>2</sup> , esta es una instancia de nuestro tipo din√°mico, creado, por supuesto, a trav√©s de <code>Activator.CreateInstance(type)</code> , porque la estructura tiene un constructor predeterminado sin argumentos. </p><br><p>  Entonces, la √∫ltima frontera: necesitamos generar din√°micamente m√©todos. </p><br><p>  <sup>2</sup> Puede notar que algo va mal aqu√≠: <code>Activator.CreateInstance()</code> empacando una instancia de <code>ref struct</code> .  Ver el final de la siguiente secci√≥n. </p><br><h2 id="znakomtes-reflectionemit">  Meet <code>Reflection.Emit</code> </h2><br><p>  Creo que los m√©todos podr√≠an generarse usando <code>Expression</code> , como  Los cuerpos de nuestros captadores / setters triviales consisten literalmente en un par de expresiones.  Eleg√≠ un enfoque diferente y m√°s directo. </p><br><p>  Si observa el c√≥digo <strong>IL</strong> de un captador trivial, puede ver algo como ( <code>Debug</code> , <code>X86</code> , <code>netframework4.8</code> ) </p><br><pre> <code class="plaintext hljs">nop ldarg.0 ldfld /* - */ stloc.0 br.s /*  */ ldloc.0 ret</code> </pre> <br><p>  Hay toneladas de lugares para detenerse y depurar. <br>  En la versi√≥n de lanzamiento, solo queda lo m√°s importante: </p><br><pre> <code class="plaintext hljs">ldarg.0 ldfld /* - */ ret</code> </pre> <br><p>  El argumento nulo del m√©todo de instancia es ... <code>this</code> .  Por lo tanto, lo siguiente est√° escrito en <strong>IL</strong> : <br>  1) Descargar <code>this</code> <br>  2) Cargue el valor del campo <br>  3) traerlo de vuelta </p><br><p>  Solo eh?  <code>Reflection.Emit</code> tiene una sobrecarga especial que toma, adem√°s del c√≥digo operativo, tambi√©n un par√°metro descriptor de campo.  Justo lo mismo que recibimos anteriormente, por ejemplo, <code>spanField</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getSpan = type.DefineMethod(<span class="hljs-string"><span class="hljs-string">"GetSpan"</span></span>, MethodAttributes.Public | MethodAttributes.HideBySig, CallingConventions.Standard, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Span&lt;T&gt;), Array.Empty&lt;Type&gt;()); gen = getSpan.GetILGenerator(); gen.Emit(OpCodes.Ldarg_0); gen.Emit(OpCodes.Ldfld, spanField); gen.Emit(OpCodes.Ret);</code> </pre> <br><p>  Para el setter, es un poco m√°s complicado, debe cargar esto en la pila, cargar el primer argumento de la funci√≥n, luego llamar a la instrucci√≥n de escritura en el campo y no devolver nada: </p><br><pre> <code class="cs hljs">ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> stfld <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret</code> </pre> <br><p>  Una vez realizado este procedimiento para el campo <code>Raw</code> , declarando los delegados necesarios (o utilizando los est√°ndares), obtenemos un tipo din√°mico y cuatro m√©todos de acceso a partir de los cuales se generan los delegados gen√©ricos correctos. </p><br><p>  Escribimos una clase de contenedor que, utilizando dos par√°metros gen√©ricos ( <code>TIn</code> , <code>TOut</code> ), recibe instancias de <code>Type</code> que hacen referencia a los tipos din√°micos (en cach√©) correspondientes, despu√©s de lo cual crea un objeto de cada tipo y genera cuatro delegados gen√©ricos, a saber </p><br><ol><li>  <code>void SetSpan(Span&lt;TIn&gt; span)</code> para escribir el span de origen en la estructura </li><li>  <code>Raw GetRaw()</code> para leer el contenido de un span como una estructura <code>Raw</code> </li><li>  <code>void SetRaw(Raw raw)</code> para escribir la estructura <code>Raw</code> modificada en el segundo objeto </li><li>  <code>Span&lt;TOut&gt; GetSpan()</code> para devolver el span del tipo deseado con los campos correctamente establecidos y recalculados. </li></ol><br><p>  Curiosamente, las instancias de tipo din√°mico deben crearse una vez.  Al crear un delegado, se pasa una referencia a estos objetos como un par√°metro <code>@this</code> .  <strong>Aqu√≠ hay una violaci√≥n de las reglas.</strong>  <strong><code>Activator.CreateInstance</code> devuelve el <code>object</code> .</strong>  <strong>Aparentemente, esto se debe al hecho de que el tipo din√°mico en s√≠ no result√≥ <code>ref</code> -</strong> <code>type.IsByRef</code> <strong>(</strong> <code>type.IsByRef</code> <s>Like</s> <code>== false</code> <strong>), pero fue posible crear campos <code>ref</code> like.</strong>  <strong>Aparentemente, dicha restricci√≥n est√° presente en el lenguaje, pero el <code>CLR</code> digiere.</strong>  <strong>Quiz√°s es aqu√≠ donde se disparar√°n las rodillas en el caso de un uso no est√°ndar.</strong>  <sup>3</sup> </p><br><p>  Entonces, obtenemos una instancia de tipo gen√©rico que contiene cuatro delegados y dos referencias impl√≠citas a instancias de clases din√°micas.  Los delegados y las estructuras se pueden reutilizar al realizar las mismas castas en una fila.  Para mejorar el rendimiento, volvemos a almacenar en cach√© (ya un convertidor de tipos) para un par <code>(TIn, TOut) -&gt; Generator&lt;TIn, TOut&gt;</code> . </p><br><h2 id="shtrih-posledniy-privodim-tipy-spantin---spantout">  El trazo es el √∫ltimo: le damos tipos, <code>Span&lt;TIn&gt; -&gt; Span&lt;TOut&gt;</code> </h2><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Span&lt;TOut&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;TIn&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      if (span.IsEmpty) return Span&lt;TOut&gt;.Empty; // Caller   ,       if (span.Length * Unsafe.SizeOf&lt;TIn&gt;() % Unsafe.SizeOf&lt;TOut&gt;() != 0) throw new InvalidOperationException(); //      // Span&lt;TIn&gt; _input.Span = span; _spanSetter(span); //  Raw // Raw raw = _input.Raw; var raw = _rawGetter(); var newRaw = new Raw() { Pinnable = raw.Pinnable, //    Pinnable Pointer = raw.Pointer, //   Length = raw.Length * Unsafe.SizeOf&lt;TIn&gt;() / Unsafe.SizeOf&lt;TOut&gt;() //   }; //   Raw    // Raw _output.Raw = newRaw; _rawSetter(newRaw); //     // Span&lt;TOut&gt; _output.Span return _spanGetter(); }</span></span></code> </pre> <br><h1 id="vyvod">  Conclusi√≥n </h1><br><p>  A veces, en aras del inter√©s deportivo, puede omitir algunas de las limitaciones del idioma e implementar una funcionalidad no est√°ndar.  Por supuesto, bajo su propio riesgo y riesgo.  Vale la pena se√±alar que el m√©todo din√°mico le permite abandonar por completo los punteros y <code>unsafe / fixed</code> contextos <code>unsafe / fixed</code> , lo que puede ser una ventaja.  La desventaja obvia es la necesidad de reflexi√≥n y generaci√≥n de tipos. </p><br><h1 id="dlya-teh-kto-dochital-do-konca">  Para aquellos que han le√≠do hasta el final. </h1><br><div class="spoiler">  <b class="spoiler_title">Resultados de referencia ingenuos</b> <div class="spoiler_text"><p>  ¬øY qu√© tan r√°pido es todo? <br>  Compar√© la velocidad de las castas en un escenario tonto que no refleja el uso real / potencial de tales castas y vanos, pero al menos da una idea de la velocidad. </p><br><ol><li> <code>Cast_Explicit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliza la conversi√≥n a trav√©s de un tipo declarado expl√≠citamente, como en el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todo 2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cada casta requiere la asignaci√≥n de dos estructuras peque√±as y accesos a los campos;</font></font></li><li> <code>Cast_IL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementa el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todo 3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero cada vez crea una instancia nuevamente </font></font><code>Generator&lt;TIn, TOut&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que lleva a b√∫squedas constantes en los diccionarios, despu√©s de que el primer pase genera todos los tipos;</font></font></li><li> <code>Cast_IL_Cached</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">almacena en cach√© la instancia del convertidor directamente </font></font><code>Generator&lt;TIn, TOut&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que resulta ser m√°s r√°pido en promedio, porque </font><font style="vertical-align: inherit;">toda la casta se reduce a las llamadas de cuatro delegados;</font></font></li><li> <code>Buffer</code>   ,       ,     .     . </li></ol><br><p>    ‚Äî         <code>int[N]</code>   <code>N/2</code>   . </p><br><p>   ,        ,    .              ,             .    ,          ,            .  ,  <em></em> <em></em> <em>   </em>     <code>unmanaged</code>   <em>  </em> . </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.11.5, OS=Windows 10.0.18362 Intel Core i7-2700K CPU 3.50GHz (Sandy Bridge), 1 CPU, 8 logical and 4 physical cores [Host] : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.3815.0 Clr : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.3815.0 Job=Clr Runtime=Clr InvocationCount=1 UnrollFactor=1</code> </pre><br><div class="scrollable-table"><table><thead><tr><th> Method </th><th> N </th><th> Mean </th><th>  Error </th><th> StdDev </th><th> Median </th><th> Ratio </th><th> RatioSD </th></tr></thead><tbody><tr><td> <strong>Cast_Explicit</strong> </td><td>  <strong>100</strong> </td><td> <strong>362.2 ns</strong> </td><td> <strong>18.0967 ns</strong> </td><td> <strong>52.7888 ns</strong> </td><td> <strong>400.0 ns</strong> </td><td> <strong>1.00</strong> </td><td> <strong>0.00</strong> </td></tr><tr><td> Cast_IL </td><td> 100 </td><td> 1,237.9 ns </td><td> 28.5954 ns </td><td> 67.4027 ns </td><td> 1,200.0 ns </td><td> 3.47 </td><td> 0.51 </td></tr><tr><td> Cast_IL_Cached </td><td> 100 </td><td> 522.8 ns </td><td> 25.2640 ns </td><td> 71.2576 ns </td><td> 500.0 ns </td><td> 1.46 </td><td> 0.27 </td></tr><tr><td> Buffer </td><td> 100 </td><td> 300.0 ns </td><td> 0.0000 ns </td><td> 0.0000 ns </td><td> 300.0 ns </td><td> 0.78 </td><td> 0.11 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> <strong>Cast_Explicit</strong> </td><td>  <strong>1000</strong> </td><td> <strong>2,628.6 ns</strong> </td><td> <strong>54.0688 ns</strong> </td><td> <strong>64.3650 ns</strong> </td><td> <strong>2,600.0 ns</strong> </td><td> <strong>1.00</strong> </td><td> <strong>0.00</strong> </td></tr><tr><td> Cast_IL </td><td> 1000 </td><td> 3,216.7 ns </td><td> 49.8568 ns </td><td> 38.9249 ns </td><td> 3,200.0 ns </td><td> 1.21 </td><td> 0.03 </td></tr><tr><td> Cast_IL_Cached </td><td> 1000 </td><td> 2,484.6 ns </td><td> 44.9717 ns </td><td> 37.5534 ns </td><td> 2,500.0 ns </td><td> 0.94 </td><td> 0.02 </td></tr><tr><td> Buffer </td><td> 1000 </td><td> 2,055.6 ns </td><td> 43.9695 ns </td><td> 73.4631 ns </td><td> 2,000.0 ns </td><td> 0.78 </td><td> 0.03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> <strong>Cast_Explicit</strong> </td><td> <strong>1000000</strong> </td><td> <strong>2,515,157.1 ns</strong> </td><td> <strong>11,809.8538 ns</strong> </td><td> <strong>10,469.1278 ns</strong> </td><td> <strong>2,516,050.0 ns</strong> </td><td> <strong>1.00</strong> </td><td> <strong>0.00</strong> </td></tr><tr><td> Cast_IL </td><td>  1,000,000 </td><td> 2,263,826.7 ns </td><td> 23,724.4930 ns </td><td> 22,191.9054 ns </td><td> 2,262,000.0 ns </td><td> 0.90 </td><td> 0.01 </td></tr><tr><td> Cast_IL_Cached </td><td>  1,000,000 </td><td> 2,265,186.7 ns </td><td> 19,505.5913 ns </td><td> 18,245.5422 ns </td><td> 2,266,300.0 ns </td><td> 0.90 </td><td> 0.01 </td></tr><tr><td> Buffer </td><td>  1,000,000 </td><td> 1,959,547.8 ns </td><td> 39,175.7435 ns </td><td> 49,544.7719 ns </td><td> 1,959,200.0 ns </td><td> 0.78 </td><td> 0.02 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> <strong>Cast_Explicit</strong> </td><td> <strong>100000000</strong> </td><td> <strong>255,751,392.9 ns</strong> </td><td> <strong>2,595,107.7066 ns</strong> </td><td> <strong>2,300,495.3873 ns</strong> </td><td> <strong>255,298,950.0 ns</strong> </td><td> <strong>1.00</strong> </td><td> <strong>0.00</strong> </td></tr><tr><td> Cast_IL </td><td> 100000000 </td><td> 228,709,457.1 ns </td><td> 527,430.9293 ns </td><td> 467,553.7809 ns </td><td> 228,864,100.0 ns </td><td> 0.89 </td><td> 0.01 </td></tr><tr><td> Cast_IL_Cached </td><td> 100000000 </td><td> 227,966,553.8 ns </td><td> 355,027.3545 ns </td><td> 296,463.9203 ns </td><td> 227,903,600.0 ns </td><td> 0.89 </td><td> 0.01 </td></tr><tr><td> Buffer </td><td> 100000000 </td><td> 213,216,776.9 ns </td><td> 1,198,565.1142 ns </td><td> 1,000,856.1536 ns </td><td> 213,517,800.0 ns </td><td> 0.83 </td><td> 0.01 </td></tr></tbody></table></div></div></div><br><div class="spoiler"> <b class="spoiler_title">Acknowledgements</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>JetBrains</strong></a> (      :-))   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>R#</strong></a>    <strong>VS</strong>  standalone- <strong>dotPeek</strong> ,     .  <code>BenchmarkDotNet</code>  BenchmarkDotNet, youtube- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>NDC Conferences</strong></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>DotNext</strong></a>    ,  ,         . </p></div></div><br><h1 id="ps">  PS </h1><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p> <sup>3</sup>         ,      <code>ref</code> ,      ,   .  <s></s>   (   )   .    <code>ref</code> structs,        </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Raw Generated_Int32.GetRaw(Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; span) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Generated_Int32() { Span = span }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inst.Raw; }</code> </pre> <br><p>     ,     <code>Reflection.Emit</code> .      ,   <em></em>  <code>ILGenerator.DeclareLocal</code> .     </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Generated_Int32.GetSpan(Raw raw);</code> </pre> <br><p>    </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> Raw GetRaw&lt;T&gt;(Span&lt;T&gt; span) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged; <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> Span&lt;T&gt; GetSpan&lt;T&gt;(Raw raw) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p> , <em> </em> ,       <code>ref</code> ‚Äî .  Porque     ,      </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getter = type.GetMethod(<span class="hljs-string"><span class="hljs-string">@"GetRaw"</span></span>, BindingFlags.Static | BindingFlags.Public).CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(GetRaw&lt;T&gt;), <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> GetRaw&lt;T&gt;;</code> </pre> <br><p>   ‚Äî  </p><br><pre> <code class="cs hljs">Raw raw = getter(Span&lt;TIn&gt;.Empty); Raw newRaw = convert(raw); Span&lt;TOut&gt; = setter(newRaw);</code> </pre> </div></div><br><p> <em>UPD01:   </em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465077/">https://habr.com/ru/post/465077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465063/index.html">Los 10 errores m√°s comunes al trabajar con la plataforma Spring. Parte 2</a></li>
<li><a href="../465069/index.html">Nuevo en Hadoop: Conozca los diversos formatos de archivo en Hadoop</a></li>
<li><a href="../465071/index.html">TechTrain 2019 IT festival: c√≥mo participaron JUG.ru, JUGNsk y JUG.MSK</a></li>
<li><a href="../465073/index.html">¬°No aparezcas! Transiciones interrumpibles en iOS</a></li>
<li><a href="../465075/index.html">En la cabina del conductor del tren</a></li>
<li><a href="../465081/index.html">CLRium # 6: concurrencia y paralelismo. Aprendiendo la magia de la paralelizaci√≥n de tareas</a></li>
<li><a href="../465083/index.html">Vigilancia de puerta vigilante</a></li>
<li><a href="../465085/index.html">Lista de verificaci√≥n antiphishing</a></li>
<li><a href="../465087/index.html">C√≥mo la NASA contrat√≥ a Snoopy y recogi√≥ la ropa de Barbie</a></li>
<li><a href="../465089/index.html">C√≥mo el azar puede ayudar a los matem√°ticos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>