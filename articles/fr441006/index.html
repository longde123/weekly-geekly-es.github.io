<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔆 😎 👨🏻‍🍳 Un aperçu des méthodes de segmentation d'images dans la bibliothèque d'images scikit 🙈 👩🏼‍✈️ 😖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seuillage 
 C'est le moyen le plus simple de séparer les objets de l'arrière-plan en sélectionnant des pixels au-dessus ou en dessous d'un certain seu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un aperçu des méthodes de segmentation d'images dans la bibliothèque d'images scikit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441006/"><h2>  Seuillage </h2><br>  C'est le moyen le plus simple de séparer les objets de l'arrière-plan en sélectionnant des pixels au-dessus ou en dessous d'un certain seuil.  Ceci est généralement utile lorsque nous allons segmenter des objets en fonction de leur arrière-plan.  Vous pouvez en savoir plus sur le seuil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Les gens familiers avec le film Terminator conviendront probablement que c'était le plus grand film de science-fiction de l'époque.  Dans le film, James Cameron a introduit un concept intéressant d'effets visuels, qui a permis aux téléspectateurs de se cacher derrière les yeux d'un cyborg appelé Terminator.  Cet effet est devenu connu sous le nom de "Terminator Vision" (English Terminator Vision).  Dans un sens, il a séparé les silhouettes des gens de l'arrière-plan.  Cela peut sembler tout à fait inapproprié alors, mais la segmentation d'image est aujourd'hui un élément important de nombreuses techniques de traitement d'image. <br><br><h2>  Segmentation d'image </h2><br>  Il existe un certain nombre de bibliothèques écrites pour l'analyse d'images.  Dans cet article, nous discuterons en détail de scikit-image, une bibliothèque de traitement d'images Python. <br><br><h2>  Scikit-image </h2><br><img src="https://habrastorage.org/webt/g2/fm/vh/g2fmvhs1nha3wxsoofyblton3hq.png" alt="image"><br><br>  Scikit-image est une bibliothèque Python pour le traitement d'images. <br><br><h2>  L'installation </h2><br>  scikit-image est installé comme suit: <br><br><pre><code class="python hljs">pip install -U scikit-image(Linux <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> OSX) pip install scikit-image(Windows) <span class="hljs-comment"><span class="hljs-comment"># For Conda-based distributions conda install scikit-image</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/hy/at/nt/hyatntvr-9i-awiwo2yxcvx_vym.png"><br><a name="habracut"></a><br><h2>  Présentation de l'image Python </h2><br>  Avant de passer aux aspects techniques de la segmentation d'images, il est important de se familiariser un peu avec l'écosystème d'images Scikit et la façon dont il traite les images. <br><br><h3>  Importer une image GrayScale de la bibliothèque skimage </h3><br>  Le module de données skimage contient plusieurs exemples intégrés d'ensembles de données, qui sont généralement stockés au format jpeg ou png. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.binary_blobs() plt.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>)</code> </pre> <br><h3>  Importer une image couleur de la bibliothèque skimage </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.astronaut() plt.imshow(image)</code> </pre> <br><img src="https://habrastorage.org/webt/j2/8b/x5/j28bx5eailfqsuainwhmyskx4ek.png"><br><br><h3>  Importer une image depuis une source externe </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># The I/O module is used for importing the image from skimage import data import numpy as np import matplotlib.pyplot as plt from skimage import io image = io.imread('skimage_logo.png') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/bx/ho/xe/bxhoxercb7yo1soyfgduy9asuwk.png"><br><br><h3>  Téléchargez plusieurs images </h3><br><pre> <code class="python hljs">images = io.ImageCollection(<span class="hljs-string"><span class="hljs-string">'../images/*.png:../images/*.jpg'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Type:'</span></span>, type(images)) images.files Out[]: Type: &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skimage</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageCollection</span></span></span><span class="hljs-class">'&gt;</span></span></code> </pre> <br><h3>  Enregistrement d'images </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#Saving file as 'logo.png' io.imsave('logo.png', logo)</span></span></code> </pre> <br><h2>  Segmentation d'image </h2><br>  Maintenant que nous avons une idée de scikit-image, nous proposons de considérer les détails de la segmentation de l'image.  La segmentation d'image est le processus de division d'une image numérique en plusieurs segments afin de simplifier et / ou de changer la représentation de l'image en quelque chose de plus significatif et plus facile à analyser. <br><br>  Dans cet article, nous considérerons les algorithmes pour les modèles enseignés à la fois avec un enseignant (supervisé) et sans enseignant (non supervisé). <br><br><img src="https://habrastorage.org/webt/zi/93/f7/zi93f7mpnuzuyo_evzeu6jqzxgo.png"><br>  <i>Certains algorithmes de segmentation sont disponibles dans la bibliothèque d'images de scikit.</i> <br><br>  Segmentation avec un enseignant: certaines connaissances préliminaires, peut-être issues de contributions humaines, sont utilisées pour guider l'algorithme. <br><br>  Segmentation sans enseignant: aucune connaissance préalable n'est requise.  Ces algorithmes tentent de diviser automatiquement les images en zones significatives.  L'utilisateur peut toujours configurer certains paramètres pour obtenir les résultats souhaités. <br><br>  Essayons cela sur une image de didacticiel fournie avec un jeu de données d'image scikit prédéfini. <br><br><h3>  Importation régulière </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.segmentation <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> seg <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.filters <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> filters <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.draw <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> draw <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.color <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> color</code> </pre> <br>  Fonction d'imagerie simple <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image, nrows=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ncols=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cmap=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'gray'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> fig, ax = plt.subplots(nrows=nrows, ncols=ncols, figsize=(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>)) ax.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>) ax.axis(<span class="hljs-string"><span class="hljs-string">'off'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fig, ax</code> </pre> <br><h3>  Image </h3><br><pre> <code class="python hljs">text = data.page() image_show(text)</code> </pre> <br><img src="https://habrastorage.org/webt/hr/ci/ac/hrciacrdvu72qvq8yhivtvt1e78.png"><br><br>  Cette image est un peu plus sombre, mais peut-être que nous pouvons toujours choisir une valeur qui nous donnera une segmentation raisonnable sans algorithmes compliqués.  Maintenant, pour nous aider à choisir cette valeur, nous allons utiliser un histogramme. <br><br>  Dans ce cas, l'histogramme montre le nombre de pixels dans l'image avec différentes intensités trouvées dans cette image.  Autrement dit, un histogramme est un graphique dans lequel l'axe X montre toutes les valeurs qui sont dans l'image, et l'axe Y montre la fréquence de ces valeurs. <br><br><pre> <code class="python hljs">fig, ax = plt.subplots(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ax.hist(text.ravel(), bins=<span class="hljs-number"><span class="hljs-number">32</span></span>, range=[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>]) ax.set_xlim(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/8c/ha/nc/8chanc-jg5519ms6yk0w-h90lfc.png"><br><br>  Notre exemple s'est avéré être une image 8 bits, nous avons donc 256 valeurs possibles le long de l'axe X. L'histogramme montre qu'il y a une concentration de pixels assez lumineux (0: noir, 255: blanc).  C'est très probablement notre joli fond de texte clair, mais le reste est un peu flou.  Un histogramme de segmentation idéal serait bimodal afin que nous puissions sélectionner un nombre en plein milieu.  Essayons maintenant de créer des images segmentées basées sur une valeur de seuil simple. <br><br><h3>  Seuil contrôlé </h3><br>  Puisque nous choisissons nous-mêmes une valeur seuil, nous l'appelons une valeur seuil contrôlée. <br><br><pre> <code class="python hljs">text_segmented = text &gt; (value concluded <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> histogram ie <span class="hljs-number"><span class="hljs-number">50</span></span>,<span class="hljs-number"><span class="hljs-number">70</span></span>,<span class="hljs-number"><span class="hljs-number">120</span></span> ) image_show(text_segmented);</code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/iv/2l/gr/iv2lgrmmcgef-0geutdoybn85t0.png"></td><td><img src="https://habrastorage.org/webt/rl/k3/on/rlk3oneyt6yvcuq9mqkwel7jg3k.png"></td><td><img src="https://habrastorage.org/webt/e5/o8/fw/e5o8fwm7cs7xzneo-v29k1_vf7e.png"></td></tr></tbody></table><br>  <i>Gauche: texte&gt; 50 |</i>  <i>Milieu: texte&gt; 70 |</i>  <i>Droite: texte&gt; 120</i> <br><br>  Nous n'avons pas obtenu de résultats parfaits, car l'ombre de gauche crée des problèmes.  Essayons avec le seuil sans surveillance maintenant. <br><br><h3>  Seuil incontrôlé </h3><br>  Seuil non contrôlé Scikit-image dispose d'un certain nombre de méthodes de détermination automatique de seuil qui ne nécessitent pas d'entrée lors du choix du seuil optimal.  Voici quelques-unes des méthodes: otsu, li, local. <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_ <span class="hljs-comment"><span class="hljs-comment"># Hit tab with the cursor after the underscore to get all the methods. image_show(text &lt; text_threshold);</span></span></code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zo/zb/ne/zozbnecnzak8i_-chy9ghhwa7e0.png"></td><td><img src="https://habrastorage.org/webt/h0/ik/-m/h0ik-mxys3qwdruh-gefraebnto.png"></td></tr></tbody></table><br>  <i>Otsu gauche ||</i>  <i>Droite: li</i> <br><br>  Dans le cas de local, nous devons également spécifier block_size.  Le décalage permet d'ajuster l'image pour de meilleurs résultats. <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_local(text,block_size=<span class="hljs-number"><span class="hljs-number">51</span></span>, offset=<span class="hljs-number"><span class="hljs-number">10</span></span>) image_show(text &gt; text_threshold);</code> </pre> <br><img src="https://habrastorage.org/webt/en/ns/zp/ennszp_rpslshqnd0y78mqax76w.png"><br><br>  Cette méthode donne un assez bon effet.  Dans une large mesure, on peut se débarrasser des régions bruyantes. <br><br><h2>  Segmentation avec un algorithme pour un modèle avec un enseignant </h2><br>  Le seuillage est un processus de segmentation très simple, et il ne fonctionnera pas correctement sur une image à contraste élevé, pour laquelle nous aurons besoin d'outils plus avancés. <br><br>  Dans cette section, nous allons utiliser un exemple d'image disponible gratuitement et essayer de segmenter la partie tête en utilisant des méthodes avec l'enseignant. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># import the image from skimage import io image = io.imread('girl.jpg') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/g6/dw/ga/g6dwgagldj71bqemwgosylqkusw.png"><br><br>  <i>Avant d'effectuer une segmentation d'image, il est recommandé d'en supprimer le bruit à l'aide de certains filtres.</i> <br><br>  Cependant, dans notre cas, l'image n'a pas de bruit significatif, nous l'accepterons telle quelle.  L'étape suivante consiste à convertir l'image en niveaux de gris à l'aide de rgb2gray. <br><br><pre> <code class="python hljs">image_gray = color.rgb2gray(image) image_show(image_gray);</code> </pre> <br><img src="https://habrastorage.org/webt/qx/jl/qs/qxjlqspqdsqiaxu6px23j4q7mvs.png"><br><br>  Nous utiliserons deux méthodes de segmentation qui fonctionnent sur des principes complètement différents. <br><br><h3>  Segmentation active des contours </h3><br>  La segmentation du chemin actif est également appelée serpent et est initialisée à l'aide d'un chemin ou d'une ligne défini par l'utilisateur autour d'une région d'intérêt, puis ce chemin est lentement compressé et attiré ou repoussé par la lumière et les bords. <br><br>  Pour notre exemple d'image, dessinons un cercle autour de la tête humaine pour initialiser le serpent. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle_points</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolution, center, radius)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Generate points which define a circle on an image.Centre refers to the centre of the circle """</span></span> radians = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi, resolution) c = center[<span class="hljs-number"><span class="hljs-number">1</span></span>] + radius*np.cos(radians)<span class="hljs-comment"><span class="hljs-comment">#polar co-ordinates r = center[0] + radius*np.sin(radians) return np.array([c, r]).T # Exclude last point because a closed path should not have duplicate points points = circle_points(200, [80, 250], 80)[:-1]</span></span></code> </pre> <br>  Les calculs ci-dessus calculent les coordonnées x et y des points à la périphérie du cercle.  Puisque nous avons donné une résolution de 200, il calculera 200 de ces points. <br><br><pre> <code class="python hljs">fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/4o/f1/bu/4of1buz3h2boatz5lpfpnlogh6g.png"><br><br>  L’algorithme segmente ensuite le visage de la personne du reste de l’image, en ajustant une courbe fermée aux bords du visage. <br><br><img src="https://habrastorage.org/webt/z_/o1/ep/z_o1epmu9zcrxuyju7tr85p9n1o.png"><br><br>  Nous pouvons configurer des paramètres appelés alpha et bêta.  Des valeurs alpha plus élevées accélèrent la contraction de la courbe, tandis que la bêta rend la courbe plus lisse. <br><br><pre> <code class="python hljs">snake = seg.active_contour(image_gray, points,alpha=<span class="hljs-number"><span class="hljs-number">0.06</span></span>,beta=<span class="hljs-number"><span class="hljs-number">0.3</span></span>) fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>) ax.plot(snake[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], snake[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'-b'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/ne/pw/vw/nepwvw8xqanbj61fikjg6qorxq0.png"><br><br><h3>  Segmentation aléatoire des marcheurs </h3><br>  Dans cette méthode, la segmentation est effectuée à l'aide d'un étiquetage interactif, appelé étiquettes.  En dessinant chaque pixel sur l'étiquette pour laquelle la probabilité la plus élevée est calculée, vous pouvez obtenir une segmentation d'image de haute qualité.  Plus de détails sur cette méthode peuvent être trouvés dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet</a> ouvrage. <br><br>  Ensuite, nous utiliserons à nouveau les valeurs précédentes de notre exemple.  Nous aurions pu faire différentes initialisations, mais pour plus de simplicité, restons-en au principe des cercles. <br><br><pre> <code class="python hljs">image_labels = np.zeros(image_gray.shape, dtype=np.uint8)</code> </pre> <br>  L'algorithme de passage aléatoire accepte les étiquettes en entrée.  Ainsi, nous aurons un grand cercle couvrant tout le visage de la personne et un autre petit cercle près du milieu du visage. <br><br><pre> <code class="python hljs">indices = draw.circle_perimeter(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">250</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>)<span class="hljs-comment"><span class="hljs-comment">#from here image_labels[indices] = 1 image_labels[points[:, 1].astype(np.int), points[:, 0].astype(np.int)] = 2 image_show(image_labels);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ol/2n/nw/ol2nnwq0un_qzngiv25atfh3d5g.png"><br>  Maintenant, utilisons Random Walker et voyons ce qui se passe. <br><br><pre> <code class="python hljs">image_segmented = seg.random_walker(image_gray, image_labels) <span class="hljs-comment"><span class="hljs-comment"># Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/au/bs/jn/aubsjn1b1uedkiorghu5izwbbha.png"><br><br>  Le résultat n'est pas le meilleur, les bords du visage sont restés intacts.  Pour corriger cette situation, nous pouvons ajuster le paramètre de passage jusqu'à obtenir le résultat souhaité.  Après plusieurs tentatives, nous avons défini la valeur sur 3000, ce qui fonctionne assez bien. <br><br><pre> <code class="plaintext hljs">image_segmented = seg.random_walker(image_gray, image_labels, beta = 3000) # Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</code> </pre><br><img src="https://habrastorage.org/webt/ii/4s/h1/ii4sh1n0rxcwgply9xmafyerk5a.png"><br><br>  C'est tout pour la segmentation avec l'enseignant, où nous devions fournir certaines données d'entrée, ainsi que configurer certains paramètres.  Cependant, il n'est pas toujours possible pour une personne de regarder l'image, puis de décider quelle contribution apporter et par où commencer.  Heureusement, pour de telles situations, nous avons des méthodes de segmentation incontrôlées. <br><br><h2>  Segmentation sans enseignant </h2><br>  La segmentation sans enseignant ne nécessite pas de connaissances préalables.  Considérez une image si grande qu'il est impossible de voir tous les pixels à la fois.  Ainsi, dans de tels cas, la segmentation sans enseignant peut diviser l'image en plusieurs sous-régions, donc au lieu de millions de pixels, vous avez des dizaines ou des centaines de zones.  Regardons deux de ces algorithmes: <br><br><h3>  Regroupement itératif linéaire simple </h3><br>  La méthode (English Simple Linear Iterative Clustering ou SLIC) utilise un algorithme d'apprentissage automatique appelé K-Means.  Il prend toutes les valeurs de pixels de l'image et essaie de les diviser en un nombre donné de sous-domaines.  Lisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> travail pour des informations détaillées. <br><br>  SLIC fonctionne avec différentes couleurs, nous allons donc utiliser l'image d'origine. <br><br><pre> <code class="python hljs">image_slic = seg.slic(image,n_segments=<span class="hljs-number"><span class="hljs-number">155</span></span>)</code> </pre> <br>  Tout ce que nous devons faire est simplement de définir une valeur moyenne pour chaque segment que nous trouvons, ce qui le fait ressembler davantage à une image. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># label2rgb replaces each discrete label with the average interior color image_show(color.label2rgb(image_slic, image, kind='avg'));</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/7_/kn/b4/7_knb4b5fgefv0vsg3bed3dtx3o.png"><br><br>  Nous avons réduit cette image de 512 * 512 = 262 000 pixels à 155 segments. <br><br><h3>  Felzenszwalb </h3><br>  Cette méthode utilise également un algorithme d'apprentissage automatique appelé clustering d'arbre couvrant un minimum.  Felzenszwaib ne nous dit pas le nombre exact de clusters dans lesquels l'image sera divisée.  Il générera autant de clusters qu'il le jugera bon. <br><br><pre> <code class="python hljs">image_felzenszwalb = seg.felzenszwalb(image) image_show(image_felzenszwalb);</code> </pre> <br><img src="https://habrastorage.org/webt/ht/bk/ao/htbkaotqhcgg_xlbys0_z_0bwie.png"><br><br>  Il y a trop de régions dans l'image.  Comptons le nombre de segments uniques. <br><br><pre> <code class="python hljs">np.unique(image_felzenszwalb).size <span class="hljs-number"><span class="hljs-number">3368</span></span></code> </pre> <br>  Maintenant, recolorons-les en utilisant la valeur moyenne sur le segment, comme nous l'avons fait dans l'algorithme SLIC. <br><br><pre> <code class="python hljs">image_felzenszwalb_colored = color.label2rgb(image_felzenszwalb, image, kind=<span class="hljs-string"><span class="hljs-string">'avg'</span></span>) image_show(image_felzenszwalb_colored);</code> </pre> <br>  Maintenant, nous obtenons moins de segments.  Si nous voulions encore moins de segments, nous pourrions changer le paramètre d'échelle.  Cette approche est parfois appelée sur-segmentation. <br><br><img src="https://habrastorage.org/webt/dw/-2/3-/dw-23-xllphmwajmn1sg-sk-nws.png"><br><br>  Cela ressemble plus à une image postérisée, qui n'est essentiellement qu'une réduction du nombre de couleurs.  Pour les combiner à nouveau (RAG). <br><br><h2>  Conclusion </h2><br>  La segmentation d'image est une étape très importante dans le traitement d'image.  Il s'agit d'un domaine de recherche actif avec une variété d'applications, allant de la vision par ordinateur aux images médicales, au trafic et à la vidéosurveillance.  Python fournit une bibliothèque d'images scikit robuste avec un grand nombre d'algorithmes de traitement d'image.  Il est disponible gratuitement et sans restrictions, soutenu par une communauté active.  Je vous recommande de lire leur documentation.  L'article original se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441006/">https://habr.com/ru/post/fr441006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440994/index.html">Prenez soin de votre entreprise dès le plus jeune âge ou comment créer une startup lean</a></li>
<li><a href="../fr440998/index.html">OpenStack élargit son portefeuille et engage CI / CD</a></li>
<li><a href="../fr441000/index.html">Promotion: Apportez un livre papier et obtenez une remise sur n'importe quel lecteur électronique ONYX BOOX</a></li>
<li><a href="../fr441002/index.html">Ce qui a mis fin au 3e test de Turing: statistiques, dialogues intéressants et impression générale</a></li>
<li><a href="../fr441004/index.html">Splunk quitte la Russie (complètement)</a></li>
<li><a href="../fr441008/index.html">Rabbit MQ dans le système de traitement des résidents</a></li>
<li><a href="../fr441010/index.html">Descendez sur terre mortelle ...</a></li>
<li><a href="../fr441012/index.html">Faits intéressants sur l'histoire du programme lunaire chinois et de la mission spatiale Chang'e-4</a></li>
<li><a href="../fr441014/index.html">Rendu stéréo à petit budget en quelques lignes de code (stéréogramme, anaglyphe, stéréoscope)</a></li>
<li><a href="../fr441018/index.html">Outils de développement et de spécification de programmes NanoCAD Mechanics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>