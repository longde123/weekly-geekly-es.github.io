<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ê ‚ÅâÔ∏è üå∂Ô∏è RabbitMQ vs. Kafka: dos enfoques de mensajer√≠a diferentes üîê üßõüèº üëâüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En los √∫ltimos dos art√≠culos, hablamos sobre IIoT, el Internet industrial de las cosas, construy√≥ una arquitectura para recibir datos de los sensores ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ vs. Kafka: dos enfoques de mensajer√≠a diferentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/416629/"><p>  En los √∫ltimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos,</a> hablamos sobre IIoT, el Internet industrial de las cosas, construy√≥ una arquitectura para recibir datos de los sensores y soldar los sensores.  La piedra angular de las arquitecturas IIoT y, de hecho, de cualquier arquitectura que trabaje con BigData es el procesamiento de flujo de datos.  Se basa en el concepto de mensajer√≠a y colas.  El est√°ndar para trabajar con la mensajer√≠a se ha convertido en Apache Kafka.  Sin embargo, para comprender sus ventajas (y comprender sus desventajas) ser√≠a bueno comprender los conceptos b√°sicos de la operaci√≥n de los sistemas de colas en general, sus mecanismos de operaci√≥n, patrones de uso y funcionalidad b√°sica. </p><br><p><img src="https://habrastorage.org/webt/-5/p1/rn/-5p1rnrr3yks4ukkp0kyovqykli.png"></p><br><p>  Encontramos una excelente serie de art√≠culos que compara la funcionalidad de Apache Kafka y otro gigante (inmerecidamente ignorado) entre los sistemas de colas: RabbitMQ.  Hemos traducido esta serie de art√≠culos, les hemos proporcionado comentarios y los hemos complementado.  Aunque la serie fue escrita en diciembre de 2017, el mundo de los sistemas de mensajer√≠a (y especialmente Apache Kafka) est√° cambiando tan r√°pidamente que para el verano de 2018, algunas cosas han cambiado. </p><a name="habracut"></a><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuente</a> </blockquote><br><h2 id="rabbitmq-vs-kafka">  RabbitMQ vs Kafka </h2><br><p>  La mensajer√≠a es la parte central de muchas arquitecturas, y los dos pilares en esta √°rea son RabbitMQ y Apache Kafka.  Hasta la fecha, Apache Kafka se ha convertido en un est√°ndar casi industrial en procesamiento de datos y an√°lisis, por lo que en esta serie analizaremos m√°s de cerca a RabbitMQ y Kafka en el contexto de su uso en infraestructuras en tiempo real. </p><br><p> Apache Kafka ahora est√° en aumento, pero parece que comenzaron a olvidarse de RabbitMQ.  Todo el bombo se centr√≥ en Kafka, y esto sucede por razones obvias, pero RabbitMQ sigue siendo una gran opci√≥n para la mensajer√≠a.  Una de las razones por las que Kafka ha centrado su atenci√≥n en s√≠ mismo es su obsesi√≥n general con la escalabilidad, y obviamente Kafka es m√°s escalable que RabbitMQ, pero a la mayor√≠a de nosotros no nos preocupa la escala en la que RabbitMQ tiene problemas.  La mayor√≠a de nosotros no somos Google o Facebook.  La mayor√≠a de nosotros tratamos con vol√∫menes diarios de mensajes de cientos de miles a cientos de millones, y no con vol√∫menes de miles de millones a billones (pero, por cierto, hay casos en que las personas escalan RabbitMQ a miles de millones de mensajes diarios). </p><br><p>  Por lo tanto, en nuestra serie de art√≠culos no hablaremos de casos en los que se requiere una escalabilidad extrema (y esta es la prerrogativa de Kafka), sino que nos centraremos en las ventajas √∫nicas que ofrece cada uno de los sistemas en consideraci√≥n.  Curiosamente, cada sistema tiene sus propias ventajas, pero al mismo tiempo son bastante diferentes entre s√≠.  Por supuesto, escrib√≠ mucho sobre RabbitMQ, pero le aseguro que no le doy ninguna preferencia particular.  Me gustan las cosas bien hechas, y RabbitMQ y Kafka son sistemas de mensajer√≠a bastante maduros, confiables y, s√≠, escalables. </p><br><p>  Comenzaremos en el nivel superior y luego comenzaremos a estudiar los diversos aspectos de estas dos tecnolog√≠as.  Esta serie de art√≠culos est√° dirigida a profesionales involucrados en la organizaci√≥n de sistemas de mensajer√≠a o arquitectos / ingenieros que desean comprender los detalles del nivel inferior y su aplicaci√≥n.  No escribiremos c√≥digo, sino que nos centraremos en la funcionalidad que ofrecen ambos sistemas, las plantillas de proceso de mensajer√≠a que ofrece cada uno de ellos y las decisiones que deben tomar los desarrolladores y arquitectos de decisiones. </p><br><h2 id="rabbitmq-protiv-kafka-dva-raznyh-podhoda-k-obmenu-soobscheniyami">  RabbitMQ vs. Kafka: dos enfoques de mensajer√≠a diferentes </h2><br><p>  En esta parte, veremos qu√© son RabbitMQ y Apache Kafka, y su enfoque para la mensajer√≠a.  Ambos sistemas abordan la arquitectura de mensajer√≠a desde diferentes √°ngulos, cada uno de los cuales tiene fortalezas y debilidades.  En este cap√≠tulo, no llegaremos a ninguna conclusi√≥n importante; en cambio, proponemos tomar este art√≠culo como un manual de tecnolog√≠a para principiantes, para que podamos profundizar en los pr√≥ximos art√≠culos de la serie. </p><br><h3 id="rabbitmq">  Rabbitmq </h3><br><p>  RabbitMQ es un sistema de gesti√≥n de colas de mensajes distribuidos.  Distribuido, porque generalmente funciona como un grupo de nodos, donde las colas se distribuyen entre los nodos y, opcionalmente, se replican para ser resistentes a errores y de alta disponibilidad.  Regularmente, implementa AMQP 0.9.1 y ofrece otros protocolos, como STOMP, MQTT y HTTP a trav√©s de m√≥dulos adicionales. </p><br><p>  RabbitMQ utiliza enfoques de mensajer√≠a cl√°sicos e innovadores.  Cl√°sico en el sentido de que se centra en la cola de mensajes e innovador, en la posibilidad de enrutamiento flexible.  Esta caracter√≠stica de enrutamiento es su ventaja √∫nica.  Crear un sistema de mensajer√≠a distribuido r√°pido, escalable y confiable es un logro en s√≠ mismo, pero la funcionalidad de enrutamiento de mensajer√≠a lo hace verdaderamente sobresaliente entre muchas tecnolog√≠as de mensajer√≠a. </p><br><h3 id="exchangei-i-ocheredi">  Intercambio y colas </h3><br><p>  Revisi√≥n s√∫per simplificada: </p><br><ul><li>  Los editores (editores) env√≠an mensajes a los intercambios </li><li>  Exchange'i env√≠o mensajes en colas y a otros intercambios </li><li>  RabbitMQ env√≠a confirmaciones a los editores al recibir un mensaje </li><li>  Los destinatarios (consumidores) mantienen conexiones TCP persistentes a RabbitMQ y anuncian qu√© cola (s) reciben </li><li>  RabbitMQ env√≠a mensajes a los destinatarios </li><li>  Los destinatarios env√≠an confirmaciones de √©xito / error </li><li>  Tras la recepci√≥n exitosa, los mensajes se eliminan de las colas. </li></ul><br><p>  Esta lista contiene una gran cantidad de decisiones que los desarrolladores y administradores deben tomar para obtener las garant√≠as de entrega que necesitan, las caracter√≠sticas de rendimiento, etc., de las cuales hablaremos m√°s adelante. </p><br><p>  Veamos un ejemplo de trabajo con un editor, intercambio, cola y receptor: </p><br><p><img src="https://habrastorage.org/webt/u2/ii/3d/u2ii3dm9jk-nuzly06mpebzac8y.png"><br>  <em>Fig.</em>  <em>1. Un editor y un destinatario</em> </p><br><p>  Qu√© hacer si tiene varios editores de la misma <br>  mensajes?  ¬øQu√© pasa si tenemos varios destinatarios, cada uno de los cuales quiere recibir todos los mensajes? </p><br><p><img src="https://habrastorage.org/webt/ug/tw/3d/ugtw3df8efgqhmwpwfs47b9ivoo.png"><br>  <em>Fig.</em>  <em>2. Varios editores, varios destinatarios independientes</em> </p><br><p>  Como puede ver, los editores env√≠an sus mensajes al mismo intercambiador, que env√≠a cada mensaje en tres colas, cada una de las cuales tiene un destinatario.  En el caso de RabbitMQ, las colas permiten que diferentes destinatarios reciban todos los mensajes.  Compare con el cuadro a continuaci√≥n: </p><br><p><img src="https://habrastorage.org/webt/2_/dj/vd/2_djvdk1k1tnb9u-z9x3q9k2k6o.png"><br>  <em>Fig.</em>  <em>3. M√∫ltiples editores, una cola con m√∫ltiples destinatarios competidores</em> <em><br></em> </p><br><p>  En la Figura 3, vemos tres destinatarios que usan la misma cola.  Estos son destinatarios competidores, es decir, compiten para recibir mensajes de la cola.  Por lo tanto, se puede esperar que, en promedio, cada destinatario reciba un tercio de los mensajes en la cola.  Usamos destinatarios competidores para escalar nuestro sistema de procesamiento de mensajes, y usar RabbitMQ es muy simple para hacer esto: agregar o eliminar destinatarios a pedido.  No importa cu√°ntos destinatarios competidores tenga, RabbitMQ solo entregar√° mensajes a un destinatario. </p><br><p>  Podemos combinar arroz.  2 y 3 para recibir m√∫ltiples conjuntos de destinatarios competidores, donde cada conjunto recibe cada mensaje. </p><br><p><img src="https://habrastorage.org/webt/gr/g4/pk/grg4pk5gfkbocpagiccsvcd3oro.png"><br>  <em>Fig.</em>  <em>4. Varios editores, varias colas con destinatarios competidores.</em> </p><br><p>  Las flechas entre intercambiadores y colas se denominan enlaces, y hablaremos m√°s sobre ellos con m√°s detalle. </p><br><h3 id="garantii">  Garant√≠as </h3><br><p>  RabbitMQ ofrece garant√≠as de "entrega √∫nica" y "al menos una entrega", pero no "exactamente una entrega". </p><br><p>  <em>Nota del traductor: antes de la versi√≥n 0.11 de Kafka, la entrega del mensaje de entrega exactamente una vez no estaba disponible; actualmente, una funcionalidad similar est√° presente en Kafka.</em> <em><br></em> </p><br><p>  Los mensajes se entregan en el orden en que llegan a la cola (despu√©s de todo, esta es la definici√≥n de la cola).  Esto no garantiza que la finalizaci√≥n del procesamiento de mensajes coincida con el mismo pedido cuando tiene destinatarios competidores.  Este no es un error de RabbitMQ, sino la realidad fundamental del procesamiento paralelo de un conjunto ordenado de mensajes.  Este problema se puede resolver utilizando el intercambio de hash coherente, como ver√° en el pr√≥ximo cap√≠tulo sobre plantillas y topolog√≠as. </p><br><h3 id="protalkivanie-push-i-predvaritelnaya-vyborka-poluchateley">  Empujar y buscar previamente a los destinatarios </h3><br><p>  RabbitMQ env√≠a mensajes a los destinatarios (tambi√©n hay una API para extraer mensajes de RabbitMQ, pero esta funcionalidad est√° en desuso en este momento).  Esto puede abrumar a los destinatarios si los mensajes llegan a la cola m√°s r√°pido de lo que los destinatarios pueden procesarlos.  Para evitar esto, cada destinatario puede establecer un l√≠mite de captaci√≥n previa (tambi√©n conocido como l√≠mite de QoS).  De hecho, el l√≠mite de QoS es un l√≠mite en la cantidad de mensajes que el destinatario no ha reconocido.  Act√∫a como un fusible cuando el receptor comienza a retrasarse. </p><br><p>  ¬øPor qu√© se decidi√≥ que los mensajes en la cola se env√≠an (push) y no se descargan (pull)?  En primer lugar, porque hay menos tiempo de retraso.  En segundo lugar, idealmente, cuando tenemos destinatarios competidores de la misma cola, queremos distribuir uniformemente la carga entre ellos.  Si cada destinatario solicita / descarga mensajes, seg√∫n la cantidad que solicite, la distribuci√≥n del trabajo puede volverse bastante desigual.  Cuanto m√°s desigual es la distribuci√≥n de los mensajes, mayor es la demora y una mayor p√©rdida del orden de los mensajes durante el procesamiento.  Estos factores orientan la arquitectura RabbitMQ hacia un mecanismo de inserci√≥n de un mensaje a la vez.  Esta es una de las limitaciones de escalar RabbitMQ.  La limitaci√≥n se mitiga por el hecho de que las confirmaciones se pueden agrupar. </p><br><h3 id="marshrutizaciya">  Enrutamiento </h3><br><p>  Los intercambios son b√°sicamente enrutadores de mensajes para colas y / u otros intercambios.  Para que un mensaje se mueva de un intercambio a una cola o a otro intercambio, es necesario vincularlo.  Diferentes intercambios requieren diferentes enlaces.  Hay cuatro tipos de intercambios y enlaces asociados: </p><br><ul><li>  Fanout  Dirige a todas las colas e intercambiadores obligados a intercambiar el submodelo est√°ndar de Pub. </li><li>  Directo (directo).  Enruta los mensajes en funci√≥n de la clave de enrutamiento que lleva el mensaje, establecida por el editor.  La clave de enrutamiento es una cadena corta.  Los intercambiadores directos env√≠an mensajes a / intercambian colas que tienen una clave de emparejamiento que coincide exactamente con la clave de enrutamiento. </li><li>  Tema (tem√°tico).  Enruta mensajes basados ‚Äã‚Äãen la clave de enrutamiento, pero permite el uso de coincidencias incompletas (comodines). </li><li>  Encabezado (encabezado).  RabbitMQ le permite agregar encabezados de destinatario a los mensajes.  Los intercambios de encabezado env√≠an mensajes de acuerdo con estos valores de encabezado.  Cada enlace incluye una coincidencia exacta de los valores del encabezado.  Puede agregar m√∫ltiples valores al enlace con CUALQUIERA o TODOS los valores necesarios para coincidir. </li><li>  Hashing consistente.  Este es un intercambiador que codifica una clave de enrutamiento o un encabezado de mensaje, y env√≠a solo en una cola.  Esto es √∫til cuando necesita cumplir con las garant√≠as de √≥rdenes de procesamiento y a√∫n as√≠ poder escalar destinatarios. </li></ul><br><p><img src="https://habrastorage.org/webt/jb/2d/gr/jb2dgryq0qn6bivddj265nvuyeu.png"><br>  <em>Fig.</em>  <em>5. Ejemplo de intercambio de temas</em> </p><br><p>  Tambi√©n consideraremos el enrutamiento con m√°s detalle, pero el ejemplo de intercambio de temas se da arriba.  En este ejemplo, los editores publican registros de errores utilizando el formato de clave de enrutamiento LEVEL (Nivel de error) .AppName. </p><br><p>  La cola 1 recibir√° todos los mensajes porque usa un n√∫mero comod√≠n con varias palabras. </p><br><p>  La cola 2 recibir√° cualquier nivel de registro de la aplicaci√≥n ECommerce.WebUI.  Utiliza comodines *, capturando as√≠ el nivel de un nombre de tema √∫nico (ERROR.Ecommerce.WebUI, NOTICE.ECommerce.WebUI, etc.). </p><br><p>  La cola 3 mostrar√° todos los mensajes de ERROR de cualquier aplicaci√≥n.  Utiliza el comod√≠n # para cubrir todas las aplicaciones (ERROR.ECommerce.WebUi, ERROR.SomeApp.SomeSublevel, etc.). </p><br><p>  Gracias a cuatro m√©todos de enrutamiento de mensajes y con la capacidad de intercambiar mensajes para enviar mensajes a otros intercambios, RabbitMQ le permite utilizar un conjunto poderoso y flexible de plantillas de intercambio de mensajes.  Adem√°s, hablaremos sobre intercambios con intercambios de letras muertas, sobre intercambios y colas sin datos (intercambios y colas ef√≠meras), y RabbitMQ ampliar√° todo su potencial. </p><br><h3 id="exchangei-s-nedostavlennymi-soobscheniyami">  Intercambio no entregado </h3><br><p>  <em>Nota del traductor: cuando los mensajes de la cola no se pueden recibir por una raz√≥n u otra (el poder del consumidor no es suficiente, problemas de red, etc.), se pueden retrasar y procesar por separado.</em> </p><br><p>  Podemos configurar colas para que los mensajes se env√≠en a intercambiar en las siguientes condiciones: </p><br><ul><li>  La cola excede el n√∫mero especificado de mensajes. </li><li>  La cola excede el n√∫mero especificado de bytes. </li><li>  El tiempo de transmisi√≥n del mensaje (TTL) ha expirado.  El editor puede establecer la duraci√≥n del mensaje, y la cola tambi√©n puede tener un TTL especificado para el mensaje.  En este caso, se utilizar√° un TTL m√°s corto de los dos. </li></ul><br><p>  Creamos una cola que est√° destinada a intercambios con mensajes no entregados, y estos mensajes se almacenan all√≠ hasta que se tomen medidas. </p><br><p>  Al igual que muchas funciones de RabbitMQ, los intercambios con mensajes que no se pueden entregar hacen posible el uso de plantillas que no se proporcionaron originalmente.  Podemos utilizar mensajes TTL e intercambios con mensajes no entregados para implementar colas diferidas y reintentar colas. </p><br><h3 id="obmenniki-i-ocheredi-bez-dannyh">  Intercambiadores y colas sin datos </h3><br><p>  Los intercambios y las colas se pueden crear din√°micamente, y puede establecer criterios para su eliminaci√≥n autom√°tica.  Esto permite el uso de patrones como los RPC basados ‚Äã‚Äãen mensajes. </p><br><h3 id="dopolnitelnye-moduli">  M√≥dulos adicionales </h3><br><p>  El primer complemento que probablemente desee instalar es el complemento de administraci√≥n, que proporciona un servidor HTTP con una interfaz web y una API REST.  Es muy f√°cil de instalar y tiene una interfaz f√°cil de usar.  La implementaci√≥n de scripts a trav√©s de la API REST tambi√©n es muy simple. </p><br><p>  Adem√°s </p><br><ul><li>  Intercambio de hash constante, intercambio de fragmentaci√≥n y m√°s </li><li>  protocolos como STOMP y MQTT </li><li>  ganchos web </li><li>  tipos adicionales de intercambiadores </li><li>  Integraci√≥n SMTP </li></ul><br><p>  Hay muchas otras cosas que se pueden decir sobre RabbitMQ, pero este es un buen ejemplo que le permite describir lo que RabbitMQ puede hacer.  Ahora nos fijamos en Kafka, que utiliza un enfoque completamente diferente para la mensajer√≠a y, al mismo tiempo, tambi√©n tiene su propio conjunto de caracter√≠sticas distintivas e interesantes. </p><br><h3 id="apache-kafka">  Apache kafka </h3><br><p>  Kafka es un registro de confirmaci√≥n replicado distribuido.  Kafka no tiene un concepto de colas, lo que puede parecer extra√±o al principio, dado que se usa como un sistema de mensajer√≠a.  Las colas han sido durante mucho tiempo sin√≥nimos de sistemas de mensajer√≠a.  Primero, veamos qu√© significa un "registro de confirmaci√≥n de cambios distribuido y replicado": </p><br><ul><li>  Distribuido porque Kafka se implementa como un grupo de nodos, tanto para tolerancia a errores como para escalado </li><li>  Replicado, ya que los mensajes generalmente se replican en m√∫ltiples nodos (servidores). </li><li>  Un registro de confirmaci√≥n porque los mensajes se almacenan en registros segmentados de solo ap√©ndice llamados temas.  Este concepto de registro es la principal ventaja √∫nica de Kafka. </li></ul><br><p>  Comprender el diario (y el tema) y las particiones es la clave para entender Kafka.  Entonces, ¬øc√≥mo difiere un registro particionado de un conjunto de colas?  Imaginemos c√≥mo se ve. </p><br><p><img src="https://habrastorage.org/webt/sg/r-/lr/sgr-lrlwlvgr-hxciwvo5uk3ix0.png"><br>  <em>Fig.</em>  <em>6 Un productor, un segmento, un destinatario</em> </p><br><p>  En lugar de poner mensajes en la cola FIFO y monitorear el estado de este mensaje en la cola, como lo hace RabbitMQ, Kafka simplemente lo agrega al registro, y eso es todo. </p><br><p>  El mensaje permanece, independientemente de si se recibe una o m√°s veces.  Se elimina de acuerdo con la pol√≠tica de retenci√≥n, tambi√©n llamada per√≠odo de tiempo de ventana.  ¬øC√≥mo se toma la informaci√≥n del tema? </p><br><p>  Cada destinatario realiza un seguimiento de d√≥nde se encuentra en el registro: hay un puntero al √∫ltimo mensaje recibido y este puntero se denomina direcci√≥n de desplazamiento.  Los destinatarios admiten esta direcci√≥n a trav√©s de las bibliotecas del cliente y, seg√∫n la versi√≥n de Kafka, la direcci√≥n se almacena en ZooKeeper o en Kafka. </p><br><p>  Una caracter√≠stica distintiva del modelo de registro en diario es que elimina instant√°neamente muchas dificultades con respecto al estado de la entrega de mensajes y, lo que es m√°s importante para los destinatarios, les permite rebobinar, devolver y recibir mensajes en la direcci√≥n relativa anterior.  Por ejemplo, imagine que est√° implementando un servicio que emite facturas que tienen en cuenta los pedidos realizados por los clientes.  El servicio tiene un error y no calcula correctamente todas las facturas en 24 horas.  Con RabbitMQ en el mejor de los casos, deber√° volver a publicar estos pedidos de alguna manera solo en el servicio de la cuenta.  Pero con Kafka, simplemente mueve la direcci√≥n relativa de este destinatario hace 24 horas. </p><br><p>  Entonces, veamos c√≥mo se ve cuando hay un tema en el que hay una partici√≥n y dos destinatarios, cada uno de los cuales debe recibir cada mensaje. </p><br><p><img src="https://habrastorage.org/webt/w1/ii/zh/w1iizhiisxgsumup_ufs8rm_dvk.png"><br>  <em>Fig.</em>  <em>7. Un productor, una partici√≥n, dos receptores independientes.</em> </p><br><p>  Como se puede ver en el diagrama, dos destinatarios independientes reciben la misma partici√≥n, pero leen en diferentes direcciones de desplazamiento.  Quiz√°s el servicio de facturaci√≥n tarda m√°s en procesar los mensajes que el servicio de notificaciones push.  o tal vez el servicio de facturaci√≥n no estuvo disponible por alg√∫n tiempo e intent√≥ ponerse al d√≠a m√°s tarde.  O tal vez hubo un error, y la direcci√≥n de compensaci√≥n tuvo que posponerse durante varias horas. </p><br><p>  Ahora suponga que el servicio de facturaci√≥n debe dividirse en tres partes, porque no puede mantenerse al d√≠a con la velocidad del mensaje.  Con RabbitMQ, simplemente implementamos dos aplicaciones de servicios de facturaci√≥n m√°s que se obtienen de la cola de facturaci√≥n.  Pero Kafka no admite receptores competidores en la misma partici√≥n; el bloque de concurrencia de Kafka es la partici√≥n misma.  Por lo tanto, si necesitamos tres destinatarios de facturas, necesitamos al menos tres particiones.  Entonces ahora tenemos: </p><br><p><img src="https://habrastorage.org/webt/3k/fn/rd/3kfnrdjpllbt0nqidfaxrveqvfc.png"><br>  <em>Fig.</em>  <em>8. Tres particiones y dos grupos de tres destinatarios.</em> </p><br><p>  Por lo tanto, se entiende que necesita al menos tantas particiones como el destinatario horizontal m√°s escalado.  Hablemos un poco sobre las particiones. </p><br><h3 id="particii-i-gruppy-poluchateley">  Particiones y grupos de destinatarios </h3><br><p>  Cada partici√≥n es un archivo separado en el que se garantiza la secuencia de mensajes.  Es importante recordar esto: el orden de los mensajes est√° garantizado en una sola partici√≥n.  En el futuro, esto puede llevar a cierta contradicci√≥n entre los requisitos para la cola de mensajes y los requisitos de rendimiento, ya que el rendimiento en Kafka tambi√©n se escala por particiones.  La partici√≥n no puede admitir destinatarios competidores, por lo que nuestra aplicaci√≥n de facturaci√≥n solo puede usar una parte para cada secci√≥n. </p><br><p>  Los mensajes se pueden redirigir a segmentos mediante un algoritmo c√≠clico o mediante una funci√≥n hash: hash (clave de mensaje)% n√∫mero de particiones.      ,      ,     , ,   ,     ,     .            . </p><br><p>       RabbitMQ.                .   ,     RabbitMQ    ,              .  ,                . </p><br><p>   RabbitMQ                    .  Kafka ,      . </p><br><p>  ,   ,    Kafka   ,   RabbitMQ   ‚Äî    . RabbitMQ     ,            . Kafka      ,      . ,        ,  Kafka     ,     . </p><br><p> ,     ,      ,           (  ).       ,          ,     .  ,      ,      ,        . </p><br><p>      RabbitMQ ‚Äî   Consistent Hashing exchange,      .   Kafka'   ,  Kafka      ,             ,   , ,     ,      -.  RabbitMQ      ,     ,    ,    . </p><br><p>     :   ,     ,    Id 1000     ,     Id 1000    .    ,    ,    .   ,      . </p><br><h3 id="protalkivanie-push-protiv-vygruzki-pull">  (push)   (pull) </h3><br><p> RabbitMQ    (push) ,  ,          .                RabbitMQ   .   , Kafka    (pull),         .     ,          , Kafka  long-polling. </p><br><p>   (pull)    Kafka -  .  Kafka        ,           ,       . </p><br><p>       RabbitMQ,             ,     ,       ,      .   Kafka       ,            . </p><br><h3 id="publikaciya-i-podpiska">    </h3><br><p> Kafka    /¬ª    ,   ,       .       ,            . </p><br><p><img src="https://habrastorage.org/webt/w1/ii/zh/w1iizhiisxgsumup_ufs8rm_dvk.png"><br>  <em>Fig.</em> <em>9.     </em> </p><br><p>       ,       ,       Kafka     : </p><br><p> . 10.  ,         <br> <em><img src="https://habrastorage.org/webt/zl/uu/eu/zluueuxxppnji50tgqnar-pnmfk.png"></em> </p><br><p>           ,   : </p><br><p><img src="https://habrastorage.org/webt/xo/bw/op/xobwopr8b9fey8huqbclx85mh4y.png"><br>  <em>Fig.</em> <em>11.      </em> </p><br><p>         , ,               . </p><br><p> ,     ,  ,     ,  . </p><br><p><img src="https://habrastorage.org/webt/uf/wn/a4/ufwna4h-bmmmr48gp0yo8akk4je.png"><br>  <em>Fig.</em> <em>12.   </em> </p><br><p>          .         . </p><br><p><img src="https://habrastorage.org/webt/ok/vs/ce/okvsce2-xvrnztcupmx-fkbyg5w.png"></p><br><p>      : </p><br><ul><li>      </li><li>      ( ,       ) </li><li>    </li></ul><br><p>           ,               .     ,   ,    . </p><br><p>     Kafka ‚Äì       , , ,     , ,     .    .            ,         .  ,   ,     . </p><br><h3 id="szhatie-zhurnala">   </h3><br><p>     ‚Äî       . ,        50 .        ‚Äì  .   ,   ,         ,  . </p><br><p>  ,    ,     .  ,    ,       .           ,         .  ,    ,      ,    . </p><br><p>                    .   ,  ,        . </p><br><h3 id="podrobnee-ob-uporyadochenii-soobscheniy">     </h3><br><p>  ,           RabbitMQ,    Kafka,   Kafka   .  RabbitMQ           ,    ,   ZooKeeper  Consul. </p><br><p>   RabbitMQ    ,    Kafka.      RabbitMQ,     ,      .  :            . </p><br><p>    .        ,         .     .         ,    .            .       .  ,   ,    -   . </p><br><p>           ,   Kafka,     .     .  ,         ,       . </p><br><p>  ,    . RabbitMQ        ,  Kafka        . </p><br><h3 id="vyvody">  Conclusiones </h3><br><p> RabbitMQ          ,    .           ,     ,     .    ,           .             ,     ,    . </p><br><p>   Kafka         .               ,         .   Kafka       ,  RabbitMQ    . ,  Kafka    ,  RabbitMQ,         ,       . </p><br><p>              RabbitMQ. </p><br><blockquote> , ,      IoT  ,    . : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">t.me/justiothings</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416629/">https://habr.com/ru/post/es416629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416619/index.html">Seminario web abierto "Creaci√≥n de un sitio web en el marco de Yii2"</a></li>
<li><a href="../es416621/index.html">Homo Extensis. Expandiendo las capacidades humanas o c√≥mo combinar humano y robot</a></li>
<li><a href="../es416623/index.html">La objetividad de la psicoterapia.</a></li>
<li><a href="../es416625/index.html">El nuevo sistema de reconocimiento facial instalado por la polic√≠a de Londres no puede reconocer a nadie</a></li>
<li><a href="../es416627/index.html">Gesti√≥n del transportador de TI, o ida y vuelta</a></li>
<li><a href="../es416633/index.html">QUIC, TLS 1.3, DNS sobre HTTPS, luego en todas partes</a></li>
<li><a href="../es416635/index.html">De derecha a izquierda. C√≥mo activar la interfaz del sitio bajo RTL</a></li>
<li><a href="../es416637/index.html">M√∫sica de papel y cart√≥n: una breve historia del vari√≥fono y el "sonido dibujado"</a></li>
<li><a href="../es416639/index.html">Entrevista con un pionero del rejuvenecimiento.</a></li>
<li><a href="../es416641/index.html">8 etapas del proceso de desarrollo de una interfaz de aplicaci√≥n m√≥vil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>