<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉüèΩ üö® üïû Schreiben einer sicheren Browsererweiterung ü¶ó üêü üèõÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Gegensatz zur √ºblichen "Client-Server" -Architektur zeichnen sich dezentrale Anwendungen aus durch: 


- Sie m√ºssen keine Datenbank mit Benutzeranm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben einer sicheren Browsererweiterung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/451796/"><p><img src="https://habrastorage.org/webt/nt/7v/c8/nt7vc8scuypj0o2ngtj1n6fqjlw.png"></p><br><p>  Im Gegensatz zur √ºblichen "Client-Server" -Architektur zeichnen sich dezentrale Anwendungen aus durch: </p><br><ul><li>  Sie m√ºssen keine Datenbank mit Benutzeranmeldungen und Kennw√∂rtern speichern.  Zugriffsinformationen werden ausschlie√ülich von den Benutzern selbst gespeichert, und die Best√§tigung ihrer Authentizit√§t erfolgt auf Protokollebene. </li><li>  Sie m√ºssen keinen Server verwenden.  Die Anwendungslogik kann in einem Blockchain-Netzwerk ausgef√ºhrt werden, in dem die erforderliche Datenmenge gespeichert werden kann. </li></ul><br><p>  Es gibt zwei relativ sichere Repositorys f√ºr Benutzerschl√ºssel - Hardware-Wallets und Browser-Erweiterungen.  Die meisten Hardware-Portemonnaies sind so sicher wie m√∂glich, aber schwierig zu verwenden und alles andere als kostenlos. Browser-Erweiterungen sind jedoch die perfekte Kombination aus Sicherheit und Benutzerfreundlichkeit und k√∂nnen auch f√ºr Endbenutzer v√∂llig kostenlos sein. </p><br><p>  Vor diesem Hintergrund wollten wir die sicherste Erweiterung entwickeln, die die Entwicklung dezentraler Anwendungen vereinfacht und eine einfache API f√ºr die Arbeit mit Transaktionen und Signaturen bietet. <br>  Wir werden Ihnen unten √ºber diese Erfahrung berichten. </p><br><p>  <strong>Der Artikel enth√§lt schrittweise Anweisungen zum Schreiben einer Browsererweiterung mit Codebeispielen und Screenshots.</strong>  Sie finden den gesamten Code im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> .  Jedes Commit entspricht logischerweise einem Abschnitt dieses Artikels. </p><a name="habracut"></a><br><h2 id="kratkaya-istoriya-brauzernyh-rasshireniy">  Eine kurze Geschichte der Browsererweiterungen </h2><br><p>  Browser-Erweiterungen gibt es schon seit geraumer Zeit.  In Internet Explorer erschienen sie 1999, in Firefox - 2004.  Lange Zeit gab es jedoch keinen einheitlichen Standard f√ºr Erweiterungen. </p><br><p>  Wir k√∂nnen sagen, dass es zusammen mit Erweiterungen in der vierten Version von Google Chrome erschien.  Nat√ºrlich gab es damals keine Spezifikation, aber es war die Chrome-API, die ihre Grundlage wurde: Nachdem Chrome einen gro√üen Teil des Browsermarktes erobert und √ºber einen integrierten Anwendungsspeicher verf√ºgt hatte, setzte Chrome tats√§chlich den Standard f√ºr Browsererweiterungen. </p><br><p>  Mozilla hatte seinen eigenen Standard, aber angesichts der Beliebtheit von Erweiterungen f√ºr Chrome entschied sich das Unternehmen f√ºr eine kompatible API.  Auf Initiative von Mozilla wurde 2015 eine spezielle Gruppe innerhalb des World Wide Web Consortium (W3C) gegr√ºndet, um Spezifikationen f√ºr browser√ºbergreifende Erweiterungen zu erarbeiten. </p><br><p> Basierend auf den bereits vorhandenen API-Erweiterungen f√ºr Chrome.  Die Arbeit wurde von Microsoft unterst√ºtzt (Google weigerte sich, an der Entwicklung des Standards teilzunehmen), und als Ergebnis erschien ein Entwurf einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> . </p><br><p>  Formal wird die Spezifikation von Edge, Firefox und Opera unterst√ºtzt (beachten Sie, dass Chrome nicht in dieser Liste enthalten ist).  Tats√§chlich ist der Standard jedoch weitgehend mit Chrome kompatibel, da er tats√§chlich auf der Grundlage seiner Erweiterungen geschrieben wurde.  Weitere Informationen zur WebExtensions-API finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><h2 id="struktura-rasshireniya">  Erweiterungsstruktur </h2><br><p>  Die einzige Datei, die f√ºr die Erweiterung erforderlich ist, ist das Manifest (manifest.json).  Er ist der "Einstiegspunkt" in die Erweiterung. </p><br><h3 id="manifest">  Manifest </h3><br><p>  Gem√§√ü der Spezifikation ist die Manifestdatei eine g√ºltige JSON-Datei.  Eine vollst√§ndige Beschreibung der Manifestschl√ºssel mit Informationen dar√ºber, welche Schl√ºssel in welchem ‚Äã‚ÄãBrowser unterst√ºtzt werden, finden Sie <a href="">hier</a> . </p><br><p>  Schl√ºssel, die nicht in der Spezifikation enthalten sind, werden m√∂glicherweise "ignoriert" (sowohl Chrome als auch Firefox melden Fehler, aber die Erweiterungen funktionieren weiterhin). </p><br><p>  Und ich m√∂chte auf einige Punkte aufmerksam machen. </p><br><ol><li>  <strong>Hintergrund</strong> - Ein Objekt, das die folgenden Felder enth√§lt: <br><ol><li>  <strong>Skripte</strong> - eine Reihe von Skripten, die im Hintergrund ausgef√ºhrt werden (dar√ºber werden wir etwas sp√§ter sprechen); </li><li>  <strong>Seite</strong> - Anstelle von Skripten, die auf einer leeren Seite ausgef√ºhrt werden, k√∂nnen Sie HTML mit Inhalt angeben.  In diesem Fall wird das Skriptfeld ignoriert und die Skripte m√ºssen mit dem Inhalt in die Seite eingef√ºgt werden. </li><li>  <strong>persistent</strong> - ein bin√§res Flag, falls nicht angegeben, beendet der Browser den Hintergrundprozess, wenn er der Ansicht ist, dass er nichts tut, und startet ihn gegebenenfalls neu.  Andernfalls wird die Seite nur entladen, wenn der Browser geschlossen wird.  Wird in Firefox nicht unterst√ºtzt. </li></ol></li><li>  <strong>content_scripts</strong> - Ein Array von Objekten, mit denen Sie verschiedene Skripte auf verschiedene Webseiten laden k√∂nnen.  Jedes Objekt enth√§lt die folgenden wichtigen Felder: <br><ol><li>  <strong>√úbereinstimmungen</strong> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">URL-Muster,</a> anhand dessen bestimmt wird, ob ein bestimmtes Inhaltsskript enthalten sein wird oder nicht. </li><li>  <strong>js</strong> - eine Liste von Skripten, die in diese √úbereinstimmung geladen werden; </li><li> <strong>exclude_matches</strong> - <strong>Schlie√üt</strong> <code>match</code> URLs aus dem <code>match</code> aus, die diesem Feld entsprechen. </li></ol></li><li>  <strong>page_action</strong> - Tats√§chlich ist es das Objekt, das f√ºr das Symbol neben der Adressleiste im Browser und die Interaktion mit diesem verantwortlich ist.  Au√üerdem k√∂nnen Sie ein Popup-Fenster anzeigen, das mithilfe von HTML, CSS und JS festgelegt wird. <br><ol><li>  <strong>default_popup</strong> - Pfad zur HTML-Datei mit einer Popup-Oberfl√§che, kann CSS und JS enthalten. </li></ol></li><li>  <strong>Berechtigungen</strong> - Ein Array zum Verwalten von Erweiterungsrechten.  Es gibt drei Arten von Rechten, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ausf√ºhrlich beschrieben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden.</a> </li><li>  <strong>web_accessible_resources</strong> - Erweiterungsressourcen, die eine Webseite anfordern kann, z. B. Bilder, JS-, CSS- und HTML-Dateien. </li><li>  <strong>extern_connectable</strong> - Hier k√∂nnen Sie explizit die IDs anderer Erweiterungen und die Dom√§nen von Webseiten angeben, von denen aus Sie eine Verbindung herstellen k√∂nnen.  Eine Domain kann eine zweite Ebene oder h√∂her sein.  Funktioniert nicht in Firefox. </li></ol><br><h2 id="kontekst-vypolneniya">  Ausf√ºhrungskontext </h2><br><p>  Die Erweiterung verf√ºgt √ºber drei Kontexte f√ºr die Codeausf√ºhrung, dh die Anwendung besteht aus drei Teilen mit unterschiedlichen Zugriffsebenen auf die Browser-API. </p><br><h3 id="extension-context">  Erweiterungskontext </h3><br><p>  Die meisten APIs sind hier verf√ºgbar.  In diesem Zusammenhang "leben": </p><br><ol><li>  <strong>Hintergrundseite</strong> - Backend-Teil der Erweiterung.  Die Datei wird im Manifest durch die Taste "Hintergrund" angezeigt. </li><li>  <strong>Popup-Seite</strong> - Popup-Seite, die angezeigt wird, wenn Sie auf das Erweiterungssymbol klicken.  Im Manifest <code>browser_action</code> -&gt; <code>default_popup</code> . </li><li>  <strong>Benutzerdefinierte Seite</strong> - Erweiterungsseite, "Leben" in einer separaten Registerkarte des Formulars <code>chrome-extension://&lt;id_&gt;/customPage.html</code> . </li></ol><br><p>  Dieser Kontext existiert unabh√§ngig von Browserfenstern und Registerkarten.  <strong>Die</strong> Hintergrundseite ist in einer einzigen Kopie vorhanden und funktioniert immer (die Ausnahme ist die Ereignisseite, wenn das Hintergrundskript f√ºr ein Ereignis gestartet wird und nach seiner Ausf√ºhrung stirbt).  <strong>Die</strong> Popup- <strong>Seite ist</strong> vorhanden, wenn das Popup-Fenster ge√∂ffnet ist, und die <strong>benutzerdefinierte Seite,</strong> solange die Registerkarte ge√∂ffnet ist.  In diesem Kontext besteht kein Zugriff auf andere Registerkarten und deren Inhalt. </p><br><h3 id="content-script-context">  Inhaltsskriptkontext </h3><br><p>  Die Inhaltsskriptdatei wird zusammen mit jeder Browser-Registerkarte gestartet.  Er hat Zugriff auf einen Teil der Erweiterungs-API und auf den DOM-Baum der Webseite.  Inhaltsskripte sind f√ºr die Interaktion mit der Seite verantwortlich.  Erweiterungen, die den DOM-Baum bearbeiten, tun dies in Inhaltsskripten - beispielsweise in Werbeblockern oder √úbersetzern.  Das Inhaltsskript kann auch √ºber Standard- <code>postMessage</code> mit der Seite kommunizieren. </p><br><h3 id="web-page-context">  Webseitenkontext </h3><br><p>  Dies ist eigentlich die Webseite selbst.  Es hat nichts mit der Erweiterung zu tun und hat dort keinen Zugriff, es sei denn, die Domain dieser Seite ist im Manifest nicht explizit angegeben (mehr dazu weiter unten). </p><br><h2 id="obmen-soobscheniyami">  Messaging </h2><br><p>  Verschiedene Teile der Anwendung m√ºssen Nachrichten miteinander austauschen.  Zu diesem <code>runtime.sendMessage</code> gibt es eine <code>runtime.sendMessage</code> API zum Senden einer <code>background</code> und <code>tabs.sendMessage</code> zum Senden einer Nachricht an eine Seite (Inhaltsskript, Popup oder Webseite, falls <code>tabs.sendMessage</code> vorhanden ist).  Das folgende Beispiel zeigt den Zugriff auf die Chrome-API. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     JSON   const msg = {a: 'foo', b: 'bar'}; // extensionId   ,      ''  ( ui   ) chrome.runtime.sendMessage(extensionId, msg); //    chrome.runtime.onMessage.addListener((msg) =&gt; console.log(msg)) //       id chrome.tabs.sendMessage(tabId, msg) //      id , ,   chrome.tabs.query( {currentWindow: true, active : true}, function(tabArray){ tabArray.forEach(tab =&gt; console.log(tab.id)) } )</span></span></code> </pre> <br><p>  F√ºr eine vollst√§ndige Kommunikation k√∂nnen Sie Verbindungen √ºber <code>runtime.connect</code> erstellen.  Als Antwort erhalten wir <code>runtime.Port</code> , in das Sie, solange es ge√∂ffnet ist, eine beliebige Anzahl von Nachrichten senden k√∂nnen.  Auf der Clientseite sieht es beispielsweise wie folgt aus: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   extensionId        .    const port = chrome.runtime.connect({name: "knockknock"}); port.postMessage({joke: "Knock knock"}); port.onMessage.addListener(function(msg) { if (msg.question === "Who's there?") port.postMessage({answer: "Madame"}); else if (msg.question === "Madame who?") port.postMessage({answer: "Madame... Bovary"});</span></span></code> </pre><br><p>  Server oder Hintergrund: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    '' .  , popup    chrome.runtime.onConnect.addListener(function(port) { console.assert(port.name === "knockknock"); port.onMessage.addListener(function(msg) { if (msg.joke === "Knock knock") port.postMessage({question: "Who's there?"}); else if (msg.answer === "Madame") port.postMessage({question: "Madame who?"}); else if (msg.answer === "Madame... Bovary") port.postMessage({question: "I don't get it."}); }); }); //     .     ,      chrome.runtime.onConnectExternal.addListener(function(port) { ... });</span></span></code> </pre> <br><p>  Es gibt auch ein <code>onDisconnect</code> Ereignis und eine <code>disconnect</code> . </p><br><h2 id="shema-prilozheniya">  Anwendungs√ºbersicht </h2><br><p>  Lassen Sie uns eine Browser-Erweiterung erstellen, die private Schl√ºssel speichert, Zugriff auf √∂ffentliche Informationen bietet (Adresse, √∂ffentlicher Schl√ºssel kommuniziert mit der Seite und Anwendungen von Drittanbietern erm√∂glicht, eine Transaktionssignatur anzufordern. </p><br><h2 id="razrabotka-prilozheniya">  Anwendungsentwicklung </h2><br><p>  Unsere Anwendung sollte sowohl mit dem Benutzer interagieren als auch eine API-Seite zum Aufrufen von Methoden (z. B. zum Signieren von Transaktionen) bereitstellen.  Es funktioniert nicht nur mit <code>contentscript</code> , da es nur Zugriff auf das DOM hat, nicht jedoch auf die JS-Seite.  Wir k√∂nnen keine Verbindung √ºber <code>runtime.connect</code> , da die API f√ºr alle Dom√§nen ben√∂tigt wird und nur bestimmte im Manifest angegeben werden k√∂nnen.  Infolgedessen sieht das Schema folgenderma√üen aus: </p><br><p><img src="https://habrastorage.org/webt/fa/b3/gx/fab3gxq823kwybj9yk_kv8wlogy.png"></p><br><p>  Es wird eine weitere Skript- <code>inpage</code> , die wir in die Seite <code>inpage</code> werden.  Es wird in seinem Kontext ausgef√ºhrt und bietet eine API f√ºr die Arbeit mit der Erweiterung. </p><br><h3 id="nachalo">  Starten Sie </h3><br><p>  Der gesamte Browser-Erweiterungscode ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verf√ºgbar.  Im Beschreibungsprozess werden Links zu Commits angezeigt. </p><br><p>  Beginnen wir mit dem Manifest: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-comment"><span class="hljs-comment">//   , .        chrome://extensions/?id=&lt;id &gt; "name": "Signer", "description": "Extension demo", "version": "0.0.1", "manifest_version": 2, // ,     background,     "background": { "scripts": ["background.js"] }, //  html   popup "browser_action": { "default_title": "My Extension", "default_popup": "popup.html" }, //  . //    :   url   http  https   // contenscript context   contentscript.js.         "content_scripts": [ { "matches": [ "http://*/*", "https://*/*" ], "js": [ "contentscript.js" ], "run_at": "document_start", "all_frames": true } ], //    localStorage  idle api "permissions": [ "storage", // "unlimitedStorage", //"clipboardWrite", "idle" //"activeTab", //"webRequest", //"notifications", //"tabs" ], //   ,       .      fetche'   xhr "web_accessible_resources": ["inpage.js"] }</span></span></code> </pre> <br><p>  Erstellen Sie leere background.js, popup.js, inpage.js und contentcript.js.  F√ºgen Sie popup.html hinzu - und unsere Anwendung kann bereits in Google Chrome heruntergeladen werden und stellen Sie sicher, dass sie funktioniert. </p><br><p>  Um dies zu √ºberpr√ºfen, k√∂nnen Sie den Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier √ºbernehmen</a> .  Zus√§tzlich zu dem, was wir getan haben, ist der Link so konfiguriert, dass das Projekt mithilfe von Webpack erstellt wird.  Um dem Browser eine Anwendung hinzuzuf√ºgen, m√ºssen Sie in chrome: // -Erweiterungen load entpacked und den Ordner mit der entsprechenden Erweiterung ausw√§hlen - in unserem Fall dist. </p><br><p><img src="https://habrastorage.org/webt/ws/ng/qz/wsngqza3qdcjtxycbcwk4awpfqm.png"></p><br><p>  Jetzt ist unsere Erweiterung installiert und funktioniert.  Sie k√∂nnen Entwicklertools f√ºr verschiedene Kontexte wie folgt ausf√ºhren: </p><br><p>  Popup -&gt; </p><br><p><img src="https://habrastorage.org/webt/m3/pr/9d/m3pr9dww991nvn9jsfwj8mvndqq.png"></p><br><p>  Der Zugriff auf die Konsole des Inhaltsskripts erfolgt √ºber die Konsole der Seite selbst, auf der es gestartet wird. <img src="https://habrastorage.org/webt/3t/gn/6v/3tgn6vao3ilxdwyz9zxraegz9vo.png"></p><br><p>  <strong>Messaging</strong> </p><br><p>  Wir m√ºssen also zwei Kommunikationskan√§le einrichten: Inpage &lt;-&gt; Hintergrund und Popup &lt;-&gt; Hintergrund.  Sie k√∂nnen nat√ºrlich einfach Nachrichten an den Port senden und Ihr Protokoll erfinden, aber ich bevorzuge den Ansatz, den ich beim Open-Source-Metamask-Projekt ausspioniert habe. </p><br><p>  Dies ist eine Browser-Erweiterung f√ºr die Arbeit mit dem Ethereum-Netzwerk.  Darin kommunizieren verschiedene Teile der Anwendung √ºber RPC unter Verwendung der dnode-Bibliothek.  Sie k√∂nnen einen Austausch schnell und bequem organisieren, wenn Sie nodejs stream als Transport bereitstellen (dh ein Objekt, das dieselbe Schnittstelle implementiert): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"dnode/browser"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//           ,         // C // API,     const dnode = Dnode({ hello: (cb) =&gt; cb(null, "world") }) // ,     dnode.  nodejs .     'readable-stream' connectionStream.pipe(dnode).pipe(connectionStream) //  const dnodeClient = Dnode() //         API    //    world dnodeClient.once('remote', remote =&gt; { remote.hello(((err, value) =&gt; console.log(value))) })</span></span></code> </pre> <br><p>  Jetzt erstellen wir eine Anwendungsklasse.  Es werden API-Objekte f√ºr Popup und Webseite erstellt und auch ein Knoten f√ºr sie erstellt: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   API  ui popupApi(){ return { hello: cb =&gt; cb(null, 'world') } } //   API   pageApi(){ return { hello: cb =&gt; cb(null, 'world') } } //  popup ui connectPopup(connectionStream){ const api = this.popupApi(); const dnode = Dnode(api); connectionStream.pipe(dnode).pipe(connectionStream); dnode.on('remote', (remote) =&gt; { console.log(remote) }) } //   connectPage(connectionStream, origin){ const api = this.popupApi(); const dnode = Dnode(api); connectionStream.pipe(dnode).pipe(connectionStream); dnode.on('remote', (remote) =&gt; { console.log(origin); console.log(remote) }) } }</span></span></code> </pre> <br><p>  Im Folgenden verwenden wir anstelle des globalen Chrome-Objekts extentionApi, das im Browser von Google auf Chrome und in anderen auf den Browser verweist.  Dies geschieht aus Gr√ºnden der Cross-Browser-Kompatibilit√§t. Im Rahmen dieses Artikels kann jedoch auch chrome.runtime.connect verwendet werden. </p><br><p>  Erstellen Sie die Anwendungsinstanz im Hintergrundskript: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(); <span class="hljs-comment"><span class="hljs-comment">// onConnect    '' (contentscript, popup,   ) extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); //      ,          ,   ui if (processName === 'contentscript'){ const origin = remotePort.sender.url app.connectPage(portStream, origin) }else{ app.connectPopup(portStream) } }</span></span></code> </pre> <br><p>  Da dnode mit Streams arbeitet und wir den Port erhalten, wird eine Adapterklasse ben√∂tigt.  Es wird mithilfe der Bibliothek f√ºr lesbare Streams erstellt, die NodeJS-Streams im Browser implementiert: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Duplex} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'readable-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortStream</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Duplex</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(port){ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>({<span class="hljs-attr"><span class="hljs-attr">objectMode</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port = port; port.onMessage.addListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); port.onDisconnect.addListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onDisconnect.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) } _onMessage(msg) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Buffer.isBuffer(msg)) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> msg._isBuffer; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(msg); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(msg) } } _onDisconnect() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.destroy() } _read(){} _write(msg, encoding, cb) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Buffer.isBuffer(msg)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = msg.toJSON(); data._isBuffer = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port.postMessage(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port.postMessage(msg) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'PortStream - disconnected'</span></span>)) } cb() } }</code> </pre> <br><p>  Erstellen Sie nun eine Verbindung in der Benutzeroberfl√§che: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupUi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupUi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,       ,   stream,  dnode const backgroundPort = extensionApi.runtime.connect({name: 'popup'}); const connectionStream = new PortStream(backgroundPort); const dnode = Dnode(); connectionStream.pipe(dnode).pipe(connectionStream); const background = await new Promise(resolve =&gt; { dnode.once('remote', api =&gt; { resolve(api) }) }); //   API    if (DEV_MODE){ global.background = background; } }</span></span></code> </pre> <br><p>  Dann erstellen wir eine Verbindung im Inhaltsskript: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; setupConnection(); injectScript(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backgroundPort = extensionApi.runtime.connect({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'contentscript'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backgroundStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortStream(backgroundPort); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pageStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PostMessageStream({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'content'</span></span>, <span class="hljs-attr"><span class="hljs-attr">target</span></span>: <span class="hljs-string"><span class="hljs-string">'page'</span></span>, }); pageStream.pipe(backgroundStream).pipe(pageStream); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// inject in-page script let script = document.createElement('script'); script.src = extensionApi.extension.getURL('inpage.js'); const container = document.head || document.documentElement; container.insertBefore(script, container.children[0]); script.onload = () =&gt; script.remove(); } catch (e) { console.error('Injection failed.', e); } }</span></span></code> </pre> <br><p>  Da wir die API nicht im Inhaltsskript, sondern direkt auf der Seite ben√∂tigen, machen wir zwei Dinge: </p><br><ol><li>  Wir erstellen zwei Streams.  Eine befindet sich in Richtung der Seite oben auf postMessage.  Daf√ºr verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Paket</a> der Macher von Metamask.  Der zweite Stream befindet sich im Hintergrund √ºber dem von <code>runtime.connect</code> empfangenen <code>runtime.connect</code> .  Pip sie.  Jetzt hat die Seite einen Stream im Hintergrund. </li><li>  Injizieren Sie das Skript in das DOM.  Wir pumpen das Skript aus (der Zugriff darauf war im Manifest zul√§ssig) und erstellen ein <code>script</code> Tag mit dem Inhalt darin: </li></ol><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; setupConnection(); injectScript(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    const backgroundPort = extensionApi.runtime.connect({name: 'contentscript'}); const backgroundStream = new PortStream(backgroundPort); //    const pageStream = new PostMessageStream({ name: 'content', target: 'page', }); pageStream.pipe(backgroundStream).pipe(pageStream); } function injectScript(){ try { // inject in-page script let script = document.createElement('script'); script.src = extensionApi.extension.getURL('inpage.js'); const container = document.head || document.documentElement; container.insertBefore(script, container.children[0]); script.onload = () =&gt; script.remove(); } catch (e) { console.error('Injection failed.', e); } }</span></span></code> </pre> <br><p>  Erstellen Sie nun ein API-Objekt in der Inpage und starten Sie es global: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; setupInpageApi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupInpageApi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    const connectionStream = new PostMessageStream({ name: 'page', target: 'content', }); const dnode = Dnode(); connectionStream.pipe(dnode).pipe(connectionStream); //   API const pageApi = await new Promise(resolve =&gt; { dnode.once('remote', api =&gt; { resolve(api) }) }); //   window global.SignerApp = pageApi; }</span></span></code> </pre> <br><p>  Wir sind bereit f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Remote Procedure Call (RPC) mit einer separaten API f√ºr die Seite und die Benutzeroberfl√§che</a> .  Wenn Sie eine neue Seite mit dem Hintergrund verbinden, sehen wir Folgendes: </p><br><p><img src="https://habrastorage.org/webt/cy/r_/pm/cyr_pmgm-u5hes5lefaf85gk91m.png"></p><br><p>  Leere API und Herkunft.  Auf der Seite k√∂nnen wir die Hallo-Funktion folgenderma√üen aufrufen: </p><br><p><img src="https://habrastorage.org/webt/3p/fd/tv/3pfdtv17ejnjzh94uajezgz0lce.png"></p><br><p>  Die Arbeit mit R√ºckruffunktionen in modernem JS ist eine schlechte Idee. Daher schreiben wir einen kleinen Helfer, um einen Knoten zu erstellen, mit dem Sie APIs an Utils in einem Objekt √ºbergeben k√∂nnen. </p><br><p>  API-Objekte sehen nun folgenderma√üen aus: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ popupApi() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">hello</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; <span class="hljs-string"><span class="hljs-string">"world"</span></span> } } ... }</code> </pre> <br><p>  Abrufen eines Objekts von der Fernbedienung wie folgt: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {cbToPromise, transformMethods} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../../src/utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pageApi = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { dnode.once(<span class="hljs-string"><span class="hljs-string">'remote'</span></span>, remoteApi =&gt; { <span class="hljs-comment"><span class="hljs-comment">//      callback  promise resolve(transformMethods(cbToPromise, remoteApi)) }) });</span></span></code> </pre> <br><p>  Ein Funktionsaufruf gibt ein Versprechen zur√ºck: </p><br><p><img src="https://habrastorage.org/webt/g7/qq/og/g7qqogo60hrjqm5pre7f5miehs0.png"></p><br><p>  Eine Version mit asynchronen Funktionen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Im Allgemeinen scheint der Ansatz mit RPC und Streams recht flexibel zu sein: Wir k√∂nnen Steam-Multiplexing verwenden und mehrere verschiedene APIs f√ºr verschiedene Aufgaben erstellen.  Im Prinzip kann dnode √ºberall verwendet werden. Die Hauptsache besteht darin, den Transport in Form eines Nodejs-Streams zu verpacken. </p><br><p>  Eine Alternative ist das JSON-Format, das das JSON RPC 2-Protokoll implementiert. Es funktioniert jedoch mit bestimmten Transporten (TCP und HTTP (S)), die in unserem Fall nicht anwendbar sind. </p><br><h3 id="vnutrenniy-steyt-i-localstorage">  Interner Status und localStorage </h3><br><p>  Wir m√ºssen den internen Status der Anwendung speichern - zumindest die Schl√ºssel zum Signieren.  Wir k√∂nnen den Status einfach zur Anwendung und zu den Methoden zum √Ñndern in der Popup-API hinzuf√ºgen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store = { <span class="hljs-attr"><span class="hljs-attr">keys</span></span>: [], }; } addKey(key){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.keys.push(key) } removeKey(index){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.keys.splice(index,<span class="hljs-number"><span class="hljs-number">1</span></span>) } popupApi(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">addKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (key) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addKey(key), <span class="hljs-attr"><span class="hljs-attr">removeKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (index) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.removeKey(index) } } ... }</code> </pre> <br><p>  Im Hintergrund werden wir alles in eine Funktion einschlie√üen und das Anwendungsobjekt in das Fenster schreiben, damit Sie von der Konsole aus damit arbeiten k√∂nnen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupApp(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEV_MODE) { global.app = app; } extensionApi.runtime.onConnect.addListener(connectRemote); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectRemote</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">remotePort</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processName = remotePort.name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> portStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortStream(remotePort); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (processName === <span class="hljs-string"><span class="hljs-string">'contentscript'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> origin = remotePort.sender.url; app.connectPage(portStream, origin) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { app.connectPopup(portStream) } } }</code> </pre> <br><p>  F√ºgen Sie ein paar Schl√ºssel von der UI-Konsole hinzu und sehen Sie, was mit dem Status passiert ist: </p><br><p><img src="https://habrastorage.org/webt/n7/xr/eb/n7xrebxybxbquxx8z8uozgwpfqm.png"></p><br><p>  Der Status muss dauerhaft sein, damit beim Neustart die Schl√ºssel nicht verloren gehen. </p><br><p>  Wir werden es in localStorage speichern und bei jeder √Ñnderung √ºberschreiben.  Anschlie√üend ist auch f√ºr die Benutzeroberfl√§che ein Zugriff darauf erforderlich, und ich m√∂chte die √Ñnderungen auch abonnieren.  Auf dieser Grundlage ist es zweckm√§√üig, einen beobachtbaren Speicher zu erstellen und seine √Ñnderungen zu abonnieren. </p><br><p>  Wir werden die Mobx-Bibliothek verwenden ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/mobxjs/mobx</a> ).  Die Wahl fiel auf sie, da ich nicht mit ihr arbeiten musste, aber ich wollte sie wirklich studieren. </p><br><p>  F√ºgen Sie die Initialisierung des Anfangszustands hinzu und machen Sie den Speicher beobachtbar: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable, action} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(initState = {}) { <span class="hljs-comment"><span class="hljs-comment">//  store      ,       proxy,      this.store = observable.object({ keys: initState.keys || [], }); } // ,   observable    @action addKey(key) { this.store.keys.push(key) } @action removeKey(index) { this.store.keys.splice(index, 1) } ... }</span></span></code> </pre> <br><p>  "Unter der Haube" mobx ersetzte alle Speicherfelder durch Proxy und f√§ngt alle Anrufe an sie ab.  Sie k√∂nnen diese Appelle abonnieren. </p><br><p>  Au√üerdem werde ich oft den Begriff ‚Äûbei √Ñnderung‚Äú verwenden, obwohl dies nicht ganz richtig ist.  Mobx verfolgt den Zugriff auf Felder.  Die von der Bibliothek erstellten Getter und Setter von Proxy-Objekten werden verwendet. </p><br><p>  Action-Dekorateure dienen zwei Zwecken: </p><br><ol><li>  Im strengen Modus mit dem Flag assertceActions verbietet mobx das direkte √Ñndern des Status.  Es wird als gute Praxis angesehen, im strengen Modus zu arbeiten. </li><li>  Selbst wenn die Funktion den Status mehrmals √§ndert - wir √§ndern beispielsweise mehrere Felder in mehrere Codezeilen - werden Beobachter erst benachrichtigt, wenn sie vollst√§ndig sind.  Dies ist besonders wichtig f√ºr das Frontend, wo unn√∂tige Statusaktualisierungen zu unn√∂tigem Rendern von Elementen f√ºhren.  In unserem Fall ist weder die erste noch die zweite besonders relevant. Wir werden jedoch Best Practices befolgen.  Die Dekorateure entschieden sich, an allen Funktionen festzuhalten, die den Status der beobachteten Felder √§ndern. </li></ol><br><p>  F√ºgen Sie im Hintergrund die Initialisierung hinzu und speichern Sie den Status in localStorage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {reaction, toJS} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  . /  / localStorage  JSON    'store' import {loadState, saveState} from "./utils/localStorage"; const DEV_MODE = process.env.NODE_ENV !== 'production'; setupApp(); function setupApp() { const initState = loadState(); const app = new SignerApp(initState); if (DEV_MODE) { global.app = app; } // Setup state persistence //  reaction  ,     .    ,    const localStorageReaction = reaction( () =&gt; toJS(app.store), // -  saveState // ,      ,    ); extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); if (processName === 'contentscript') { const origin = remotePort.sender.url app.connectPage(portStream, origin) } else { app.connectPopup(portStream) } } }</span></span></code> </pre> <br><p>  Die Reaktionsfunktion ist hier interessant.  Sie hat zwei Argumente: </p><br><ol><li>  Datenauswahl. </li><li>  Ein Handler, der bei jeder √Ñnderung mit diesen Daten aufgerufen wird. </li></ol><br><p>  Im Gegensatz zu Redux, bei dem wir den Status explizit als Argument erhalten, merkt sich mobx, auf welche Observable wir uns im Selektor beziehen, und ruft nur dann den Handler auf, wenn sie ge√§ndert werden. </p><br><p>  Es ist wichtig, genau zu verstehen, wie mobx entscheidet, welches Observable wir abonnieren.  Wenn ich einen Selektor in den Code wie diesen <code>() =&gt; app.store</code> , wird die Reaktion niemals aufgerufen, da das Repository selbst nicht beobachtbar ist, sondern nur seine Felder. </p><br><p>  Wenn ich so geschrieben h√§tte <code>() =&gt; app.store.keys</code> , w√ºrde nichts mehr passieren, da sich beim Hinzuf√ºgen / Entfernen von Elementen des Arrays der Link dazu nicht √§ndert. </p><br><p>  Zum ersten Mal f√ºhrt Mobx die Funktion eines Selektors aus und √ºberwacht nur die beobachtbaren Objekte, auf die wir Zugriff haben.  Dies erfolgt √ºber Proxy-Getter.      <code>toJS</code> .    ,        .         ‚Äì ,  . </p><br><p>   popup    .         localStorage: </p><br><p><img src="https://habrastorage.org/webt/fr/dh/6t/frdh6tc_bt_v3zywmgjrnptngcw.png"></p><br><p>   background-    . </p><br><p>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><h2 id="bezopasnoe-hranenie-privatnyh-klyuchey">     </h2><br><p>       :    ,   ,        .   localStorage        . </p><br><p>       locked,        .        locked  . </p><br><p> Mobx      ,       .  ‚Äî   computed properties.     view   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable, action} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     .  crypto-js import {encrypt, decrypt} from "./utils/cryptoUtils"; export class SignerApp { constructor(initState = {}) { this.store = observable.object({ //     .   null -  locked password: null, vault: initState.vault, //    .     view  . get locked(){ return this.password == null }, get keys(){ return this.locked ? undefined : SignerApp._decryptVault(this.vault, this.password) }, get initialized(){ return this.vault !== undefined } }) } //      @action initVault(password){ this.store.vault = SignerApp._encryptVault([], password) } @action lock() { this.store.password = null } @action unlock(password) { this._checkPassword(password); this.store.password = password } @action addKey(key) { this._checkLocked(); this.store.vault = SignerApp._encryptVault(this.store.keys.concat(key), this.store.password) } @action removeKey(index) { this._checkLocked(); this.store.vault = SignerApp._encryptVault([ ...this.store.keys.slice(0, index), ...this.store.keys.slice(index + 1) ], this.store.password ) } ... //    api // private _checkPassword(password) { SignerApp._decryptVault(this.store.vault, password); } _checkLocked() { if (this.store.locked){ throw new Error('App is locked') } } //   /  static _encryptVault(obj, pass){ const jsonString = JSON.stringify(obj) return encrypt(jsonString, pass) } static _decryptVault(str, pass){ if (str === undefined){ throw new Error('Vault not initialized') } try { const jsonString = decrypt(str, pass) return JSON.parse(jsonString) }catch (e) { throw new Error('Wrong password') } } }</span></span></code> </pre> <br><p>        .   .    locked        .   API     . </p><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   rypto-js</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CryptoJS <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'crypto-js'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      .        5000  function strengthenPassword(pass, rounds = 5000) { while (rounds-- &gt; 0){ pass = CryptoJS.SHA256(pass).toString() } return pass } export function encrypt(str, pass){ const strongPass = strengthenPassword(pass); return CryptoJS.AES.encrypt(str, strongPass).toString() } export function decrypt(str, pass){ const strongPass = strengthenPassword(pass) const decrypted = CryptoJS.AES.decrypt(str, strongPass); return decrypted.toString(CryptoJS.enc.Utf8) }</span></span></code> </pre> <br><p>    idle API,       ‚Äî  . , ,   <code>idle</code> , <code>active</code>  <code>locked</code> .  idle   ,  locked ,    .        localStorage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {reaction, toJS} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {loadState, saveState} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/localStorage"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IDLE_INTERVAL = <span class="hljs-number"><span class="hljs-number">30</span></span>; setupApp(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initState = loadState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(initState); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEV_MODE) { global.app = app; } <span class="hljs-comment"><span class="hljs-comment">//     ,    , reaction   reaction( () =&gt; ({ vault: app.store.vault }), saveState ); //  ,    extensionApi.idle.setDetectionInterval(IDLE_INTERVAL); //             extensionApi.idle.onStateChanged.addListener(state =&gt; { if (['locked', 'idle'].indexOf(state) &gt; -1) { app.lock() } }); // Connect to other contexts extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); if (processName === 'contentscript') { const origin = remotePort.sender.url app.connectPage(portStream, origin) } else { app.connectPopup(portStream) } } }</span></span></code> </pre> <br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><h3 id="tranzakcii">  Transaktionen </h3><br><p> ,     :      .     WAVES   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">waves-transactions</a> . </p><br><p>       ,   ,  ‚Äî    ,    : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {action, observable, reaction} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {signTx} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-transactions'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {decrypt, encrypt} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/cryptoUtils"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... @action newMessage(data, origin) { <span class="hljs-comment"><span class="hljs-comment">//       id, ,    . const message = observable.object({ id: uuid(), // ,  uuid origin, // Origin      data, // status: 'new', //   : new, signed, rejected  failed timestamp: Date.now() }); console.log(`new message: ${JSON.stringify(message, null, 2)}`); this.store.messages.push(message); //     mobx   .        return new Promise((resolve, reject) =&gt; { reaction( () =&gt; message.status, //    (status, reaction) =&gt; { //       reaction,        switch (status) { case 'signed': resolve(message.data); break; case 'rejected': reject(new Error('User rejected message')); break; case 'failed': reject(new Error(message.err.message)); break; default: return } reaction.dispose() } ) }) } @action approve(id, keyIndex = 0) { const message = this.store.messages.find(msg =&gt; msg.id === id); if (message == null) throw new Error(`No msg with id:${id}`); try { message.data = signTx(message.data, this.store.keys[keyIndex]); message.status = 'signed' } catch (e) { message.err = { stack: e.stack, message: e.message }; message.status = 'failed' throw e } } @action reject(id) { const message = this.store.messages.find(msg =&gt; msg.id === id); if (message == null) throw new Error(`No msg with id:${id}`); message.status = 'rejected' } ... }</span></span></code> </pre> <br><p>         ,  <code>observable</code>    <code>store.messages</code> . </p><br><p>    <code>observable</code> ,  mobx        messages.     ,       ,      . </p><br><p>    ,      .    reaction,    ""   . </p><br><p>   <code>approve</code>  <code>reject</code>  :     ,   ,  . </p><br><p> Approve  reject    API UI, newMessage ‚Äî  API : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... popupApi() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">addKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (key) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addKey(key), <span class="hljs-attr"><span class="hljs-attr">removeKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (index) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.removeKey(index), <span class="hljs-attr"><span class="hljs-attr">lock</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lock(), <span class="hljs-attr"><span class="hljs-attr">unlock</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (password) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unlock(password), <span class="hljs-attr"><span class="hljs-attr">initVault</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (password) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initVault(password), <span class="hljs-attr"><span class="hljs-attr">approve</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (id, keyIndex) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.approve(id, keyIndex), <span class="hljs-attr"><span class="hljs-attr">reject</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (id) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reject(id) } } pageApi(origin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">signTransaction</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (txParams) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newMessage(txParams, origin) } } ... }</code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/jt/bp/nu/jtbpnu9tbhryijukstktnti3wbu.png"></p><br><p>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  UI</a> . </p><br><h2 id="ui"> UI </h2><br><p>      .   UI   <code>observable</code>     API ,     .  <code>observable</code>   API,   background: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {cbToPromise, setupDnode, transformMethods} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {initApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./ui/index"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupUi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupUi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,     const backgroundPort = extensionApi.runtime.connect({name: 'popup'}); const connectionStream = new PortStream(backgroundPort); //   observable   background'a let backgroundState = observable.object({}); const api = { //  ,    observable updateState: async state =&gt; { Object.assign(backgroundState, state) } }; //  RPC  const dnode = setupDnode(connectionStream, api); const background = await new Promise(resolve =&gt; { dnode.once('remote', remoteApi =&gt; { resolve(transformMethods(cbToPromise, remoteApi)) }) }); //   background observable   background.state = backgroundState; if (DEV_MODE) { global.background = background; } //   await initApp(background) }</span></span></code> </pre><br><p>       .  react-. Background-     props. , ,       store  ,       : </p><br><pre> <code class="plaintext hljs">import {render} from 'react-dom' import App from './App' import React from "react"; //    background     props export async function initApp(background){ render( &lt;App background={background}/&gt;, document.getElementById('app-content') ); }</code> </pre><br><p>   mobx       .     observer   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mobx-react</a>  ,         observable,    .    mapStateToProps  connect,   redux.    " ": </p><br><pre> <code class="plaintext hljs">import React, {Component, Fragment} from 'react' import {observer} from "mobx-react"; import Init from './components/Initialize' import Keys from './components/Keys' import Sign from './components/Sign' import Unlock from './components/Unlock' @observer //          render,    observable     export default class App extends Component { //              , //   observable   background    ,    render() { const {keys, messages, initialized, locked} = this.props.background.state; const {lock, unlock, addKey, removeKey, initVault, deleteVault, approve, reject} = this.props.background; return &lt;Fragment&gt; {!initialized ? &lt;Init onInit={initVault}/&gt; : locked ? &lt;Unlock onUnlock={unlock}/&gt; : messages.length &gt; 0 ? &lt;Sign keys={keys} message={messages[messages.length - 1]} onApprove={approve} onReject={reject}/&gt; : &lt;Keys keys={keys} onAdd={addKey} onRemove={removeKey}/&gt; } &lt;div&gt; {!locked &amp;&amp; &lt;button onClick={() =&gt; lock()}&gt;Lock App&lt;/button&gt;} {initialized &amp;&amp; &lt;button onClick={() =&gt; deleteVault()}&gt;Delete all keys and init&lt;/button&gt;} &lt;/div&gt; &lt;/Fragment&gt; } }</code> </pre> <br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  UI</a> . </p><br><p>          UI      UI.     <code>getState</code>  <code>reaction</code> ,  <code>remote.updateState</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {action, observable, reaction} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {signTx} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-transactions'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {decrypt, encrypt} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/cryptoUtils"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// public getState() { return { keys: this.store.keys, messages: this.store.newMessages, initialized: this.store.initialized, locked: this.store.locked } } ... // connectPopup(connectionStream) { const api = this.popupApi(); const dnode = setupDnode(connectionStream, api); dnode.once('remote', (remote) =&gt; { //  reaction   ,          ui  const updateStateReaction = reaction( () =&gt; this.getState(), (state) =&gt; remote.updateState(state), //     . fireImmediatly   reaction    . //  ,    . Delay   debounce {fireImmediately: true, delay: 500} ); //      dnode.once('end', () =&gt; updateStateReaction.dispose()) }) } ... }</span></span></code> </pre> <br><p>    <code>remote</code>  <code>reaction</code>   ,      UI. </p><br><p>   ‚Äî       : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// Reaction    . reaction( () =&gt; app.store.newMessages.length &gt; 0 ? app.store.newMessages.length.toString() : '', text =&gt; extensionApi.browserAction.setBadgeText({text}), {fireImmediately: true} ); ... }</span></span></code> </pre> <br><p> ,  . -    : </p><br><p><img src="https://habrastorage.org/webt/yo/cz/9b/yocz9bncoevwxrict_3dl_vphek.png"></p><br><p><img src="https://habrastorage.org/webt/ee/8e/uj/ee8eujkmg5iwgfholkyxneqsim4.png"></p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><p>  <strong>Fazit</strong> </p><br><p>      ,     ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> .         . </p><br><p>        ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><p> <strong>,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">siemarell</a></strong> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451796/">https://habr.com/ru/post/de451796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451784/index.html">Hybridlaufwerke f√ºr Enterprise-Speicher. Erfahrung mit Seagate EXOS</a></li>
<li><a href="../de451786/index.html">F√ºhren Sie Instrumententests im Firebase-Testlabor durch. Teil 1: iOS-Projekt</a></li>
<li><a href="../de451790/index.html">Die Gefahren der Datenerfassung im Spiel</a></li>
<li><a href="../de451792/index.html">Vier Javascript-Sniffer, die Sie in Online-Shops fangen</a></li>
<li><a href="../de451794/index.html">Textur-Einr√ºckungspixel</a></li>
<li><a href="../de451798/index.html">Datenmigration mit mongoDB und Spring Boot</a></li>
<li><a href="../de451800/index.html">Ein einfaches Sonarmodem herstellen</a></li>
<li><a href="../de451802/index.html">Die .Net Community der Raiffeisenbank l√§dt zu UPD mitap Broadcast ein</a></li>
<li><a href="../de451806/index.html">iOS Digest Nr. 5 (27. April - 16. Mai)</a></li>
<li><a href="../de451812/index.html">Jetzt werden gute Entwickler an Ansichten und Abonnenten gemessen - und das ist schlecht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>