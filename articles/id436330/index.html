<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎈 ❇️ 👩‍💼 Membuat game untuk Game Boy 🌛 👨‍👩‍👧‍👧 👩🏻‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa minggu yang lalu, saya memutuskan untuk mengerjakan game untuk Game Boy, kreasi yang memberi saya kesenangan besar. Nama kerjanya adalah Aqua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat game untuk Game Boy</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436330/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/913/597/052/91359705210df58524bc0e6c9e9955a8.png" alt="gambar"></div><br>  Beberapa minggu yang lalu, saya memutuskan untuk mengerjakan game untuk Game Boy, kreasi yang memberi saya kesenangan besar.  Nama kerjanya adalah Aqua dan Abu.  Game ini memiliki sumber terbuka dan diposting di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br><h2>  Bagaimana ide ini muncul di benak saya </h2><br>  Baru-baru ini saya mendapat pekerjaan magang membuat backend dalam PHP dan Python untuk situs web universitas saya.  Ini adalah pekerjaan yang bagus dan menarik, dan saya sangat berterima kasih.  Tetapi ... pada saat yang sama, semua kode pengembangan web tingkat tinggi ini telah menginfeksi saya dengan keinginan yang tidak pernah terpuaskan.  Dan itu adalah keinginan untuk pekerjaan tingkat rendah dengan bit. <br><br>  Saya menerima gatal mingguan.io tentang kemacetan permainan dalam surat, yang mengumumkan awal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mini Jam 4</a> .  Itu adalah 48 jam (well, sebenarnya sedikit lebih besar), di mana batasannya adalah untuk membuat grafik dengan gaya Game Boy.  Reaksi logis pertama saya adalah membuat game homebrew untuk Game Boy.  Tema kemacetan adalah "musim" dan "nyala". <br><br>  Setelah berpikir sedikit tentang plot dan mekanisme yang dapat diimplementasikan dalam 48 jam dan sesuai dengan keterbatasan topik, saya datang dengan <s>klon</s> interpretasi baru tingkat dari permainan SNES 1993 Petualangan Tiny Toon: Buster Busts Loose !, di mana pemain dalam peran Baster memainkan sepakbola Amerika . <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XmyJZkJ-zeA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Saya selalu suka bagaimana pencipta tingkat ini mengambil olahraga yang sangat kompleks, menyingkirkan semua trik, posisi, dan elemen strategis, sebagai hasil dari mendapatkan permainan yang sangat menarik dan mudah.  Jelas, pandangan yang disederhanakan tentang sepak bola Amerika tidak akan menggantikan Madden, seperti halnya NBA Jam (ide serupa: hanya 4 pemain di bidang yang jauh lebih kecil dengan gameplay yang lebih mudah daripada di game biasa) tidak akan menggantikan seri 2K.  Tetapi ide ini memiliki daya tarik tertentu, dan angka penjualan NBA Jam mengkonfirmasi hal ini. <br><br>  Bagaimana semua ini berhubungan dengan ide saya?  Saya memutuskan untuk mengambil level sepakbola ini dan membuat ulang sehingga tetap mirip dengan aslinya dan pada saat yang sama segar.  Pertama, saya mengurangi permainan menjadi hanya empat pemain - satu bek dan satu penyerang.  Ini terutama dilakukan karena keterbatasan perangkat keras, tetapi pada saat yang sama itu akan memungkinkan saya untuk bereksperimen sedikit dengan AI yang lebih cerdas, tidak terbatas pada prinsip "lari ke kiri dan kadang-kadang melompat" dari bermain di SNES. <br><br>  Demi kesesuaian dengan topik, saya akan mengganti gerbang dengan kolom terbakar, atau dengan api unggun, atau dengan sesuatu seperti itu (saya belum memutuskan), dan bola sepak dengan obor dan ember air.  Pemenangnya adalah tim yang mengendalikan kedua api unggun, dan di sekitar konsep sederhana ini Anda dapat dengan mudah membuat plot.  Musim juga diperhitungkan: Saya memutuskan bahwa musim akan berubah setiap belokan, sehingga tim pemadam kebakaran mendapat keuntungan di musim panas dan tim pemadam kebakaran di musim dingin.  Keuntungan ini terlihat seperti hambatan di lapangan yang hanya mengganggu tim lawan. <br><br>  Tentu saja, ketika membuat dua tim, dua hewan dibutuhkan yang suka dan tidak suka api.  Pada awalnya saya memikirkan semut api dan beberapa serangga air, berdoa belalang dan sejenisnya, tetapi setelah mempelajari masalah ini, saya tidak menemukan serangga yang aktif di musim dingin, jadi saya menggantinya dengan rubah kutub dan tokek.  Rubah kutub seperti salju, tokek suka berbaring di matahari, jadi semuanya tampak logis.  Pada akhirnya, itu hanya permainan untuk Game Boy. <br><br>  Selain itu, dalam hal ini masih bisa dimengerti, pada akhir kemacetan permainan itu tidak hampir selesai.  Ngomong-ngomong, itu tetap menyenangkan. <br><br><h2>  Pelatihan Game Boy </h2><br>  Pertama, Anda perlu menentukan persyaratan.  Saya memutuskan untuk menulis untuk DMG (nama internal untuk model Game Boy, kependekan dari Dot Matrix Game).  Terutama untuk memenuhi persyaratan permainan yang macet, tetapi juga karena saya benar-benar ingin.  Secara pribadi, saya belum pernah memiliki game untuk DMG (walaupun ada beberapa game untuk Game Boy Color), tetapi saya menemukan 2-bit estetika menjadi batasan yang sangat bagus dan menarik untuk eksperimen.  Mungkin saya akan menambahkan warna tambahan untuk SGB dan CGB, tapi sejauh ini saya belum memikirkannya. <br><br>  Saya juga memutuskan untuk menggunakan kartrid dengan ROM 32K + tanpa RAM, kalau-kalau saya ingin membuat salinan fisik permainan.  CatSkull, yang telah menerbitkan beberapa game Game Boy, seperti Sheep it Up !, Memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kartrid flash 32-kilobyte yang dijual</a> yang sangat cocok untuk saya.  Ini adalah batasan tambahan lain, tetapi saya tidak berpikir bahwa dalam waktu dekat saya dapat mengatasi volume 32K dengan permainan yang begitu sederhana.  Hal yang paling sulit adalah dengan grafis, dan jika semuanya benar-benar buruk, maka saya akan mencoba untuk mengompresnya. <br><br>  Sedangkan untuk pekerjaan Game Boy, maka semuanya cukup rumit.  Namun, jujur ​​saja, dari semua konsol retro yang harus saya kerjakan, Game Boy adalah yang paling menyenangkan.  Saya mulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial yang sangat baik</a> (setidaknya untuk pertama kalinya, karena tidak pernah selesai) oleh penulis AssemblyDigest.  Saya tahu bahwa yang terbaik adalah menulis dalam ASM, betapapun menyakitkannya itu kadang-kadang, karena perangkat kerasnya tidak dirancang untuk C, dan saya tidak yakin bahwa bahasa keren Wiz yang disebutkan dalam tutorial akan cocok untuk jangka panjang.  Plus, saya melakukan ini terutama karena <em>saya dapat</em> bekerja dengan ASM. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Periksa komit 8c0a4ea</a> <br><br>  Hal pertama yang harus dilakukan adalah membuat Game Boy untuk boot.  Jika logo Nintendo tidak ditemukan pada offset <code>$104</code> , dan sisa header tidak dikonfigurasi dengan benar, maka peralatan Game Boy akan menganggap bahwa kartrid dimasukkan dengan tidak benar dan akan menolak untuk memuat.  Untuk mengatasi masalah ini sangat sederhana, karena banyak tutorial yang telah ditulis tentang ini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Inilah cara saya memecahkan masalah tajuk.</a>  Tidak ada yang layak mendapat perhatian khusus. <br><br>  Akan lebih sulit untuk melakukan tindakan yang berarti setelah memuat.  Sangat sederhana untuk membuat sistem masuk ke siklus sibuk tanpa batas di mana ia menjalankan satu baris kode berulang-ulang.  Eksekusi kode dimulai dengan label <code>main</code> (di mana lompatan ke alamat menunjukkan <code>$100</code> ), jadi Anda perlu memasukkan beberapa kode sederhana di sana.  Sebagai contoh: <br><br><pre> <code class="hljs pgsql">main: .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>: halt jr .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span></code> </pre> <br>  dan itu tidak melakukan apa pun kecuali menunggu interupsi untuk memulai, setelah itu kembali ke label <code>.loop</code> .  (Selanjutnya, saya akan menghilangkan deskripsi rinci ASM. Jika Anda bingung, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat dokumentasi assembler yang saya gunakan</a> .) Anda mungkin ingin tahu mengapa saya tidak kembali ke label <code>main</code> .  Ini karena saya ingin semuanya sebelum label <code>.loop</code> menjadi inisialisasi program, dan semuanya setelah itu terjadi setiap frame.  Jadi, saya tidak harus melewati siklus memuat data dari kartrid dan menghapus memori di setiap frame. <br><br>  Mari kita mengambil satu langkah lagi.  Paket assembler RGBDS yang saya gunakan berisi konverter gambar.  Karena pada tahap ini saya belum mengambil sumber daya untuk permainan, saya memutuskan untuk menggunakan tombol monokrom dari halaman Tentang saya sebagai bitmap uji.  Menggunakan RGBGFX, saya mengonversinya ke format Game Boy dan menggunakan perintah .incbin assembler untuk menyisipkannya setelah fungsi <code>main</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26e/1d4/8b2/26e1d48b29e761edb6df6c6a3a3d035b.png" alt="gambar"></div><br>  Untuk menampilkannya di layar, saya perlu yang berikut: <br><br><ol><li>  LCD mati </li><li>  Atur palet </li><li>  Setel Posisi Gulir </li><li>  Bersihkan Memori Video (VRAM) </li><li>  Memuat grafik ubin ke dalam VRAM </li><li>  Unduh peta latar belakang ubin VRAM </li><li>  Nyalakan kembali LCD </li></ol><br><h3>  LCD mati </h3><br>  Bagi pemula, ini menjadi kendala paling serius.  Pada Game Boy pertama, tidak mungkin hanya menulis data ke VRAM kapan saja.  Perlu menunggu saat ketika sistem tidak menarik apa pun.  Meniru cahaya fosfor di televisi CRT lama, interval antara setiap frame ketika VRAM terbuka disebut Vertikal-Kosong, atau VBlank (dalam CRT itu adalah dorongan untuk memadamkan sinar kineskop selama pemindaian terbalik).  (Ada juga HBlank di antara setiap baris layar, tetapi sangat pendek.) Namun, kita dapat mengatasi masalah ini dengan mematikan layar LCD, yaitu, kita <em>dapat</em> merekam dalam VRAM tanpa memandang di mana trek fosfor dari layar CRT berada. <br><br>  Jika Anda bingung, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ulasan ini harus menjelaskan banyak hal kepada Anda</a> .  Di dalamnya, pertanyaan dianggap dari sudut pandang SNES, jadi jangan lupa bahwa tidak ada berkas elektron, dan angkanya berbeda, tetapi di semua hal lain itu cukup berlaku.  Pada dasarnya, kita perlu mengatur bendera FBlank. <br><br>  Namun, trik Game Boy adalah Anda hanya dapat mematikan LCD selama VBlank.  Artinya, kita harus menunggu VBlank.  Untuk melakukan ini, gunakan interupsi.  Interupsi adalah sinyal bahwa Game Boy mengirim perangkat keras ke CPU.  Jika interrupt handler diatur, prosesor berhenti bekerja dan memanggil handler.  Game Boy mendukung lima interupsi, dan salah satunya dimulai ketika VBlank dimulai. <br><br>  Interupsi dapat ditangani dengan dua cara berbeda.  Yang pertama dan paling umum adalah tugas <em>penangan interupsi</em> yang berfungsi seperti yang saya jelaskan di atas.  Namun, kami dapat mengaktifkan interupsi tertentu dan menonaktifkan semua penangan dengan mengatur flag aktifkan untuk interupsi ini dan menggunakan opcode <code>di</code> .  Biasanya tidak melakukan apa-apa, tetapi memiliki efek samping keluar dari HALT opcode, yang menghentikan CPU sebelum terjadi gangguan.  (Ini juga terjadi ketika penangan dihidupkan, yang memungkinkan kita untuk keluar dari siklus HALT di <code>main</code> .) Jika Anda tertarik, kami juga akan membuat penangan VBlank dari waktu ke waktu, tetapi banyak yang akan tergantung pada nilai-nilai tertentu di alamat tertentu.  Karena tidak ada yang diatur dalam RAM sejauh ini, upaya untuk memanggil VBlank handler dapat menyebabkan sistem crash. <br><br>  Untuk mengatur nilai, kita perlu mengirim perintah ke register perangkat keras Game Boy.  Ada alamat memori khusus yang terkait langsung dengan berbagai bagian peralatan, dalam kasus kami, CPU, yang memungkinkan Anda untuk mengubah cara kerjanya.  Kami sangat tertarik dengan alamat <code>$FFFF</code> (bidang bit interrupt enable), <code>$FF0F</code> (bidang bit interrupt yang diaktifkan tetapi tidak tertangani) dan <code>$FF40</code> (kontrol LCD).  Daftar register ini dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di halaman yang</a> terkait dengan bagian "Dokumentasi" dari daftar Awesome Game Boy Development. <br><br>  Untuk mematikan LCD, kita nyalakan VBlank interrupt saja, menetapkan <code>$FFFF</code> nilai <code>$01</code> , jalankan HALT sampai kondisi <code>$FF0F == $01</code> terpenuhi, dan kemudian tetapkan bit 7 dari alamat <code>$FF40</code> ke 0. <br><br><h3>  Mengatur palet dan posisi gulir </h3><br>  Ini mudah dilakukan.  Sekarang setelah LCD mati, kita tidak perlu khawatir tentang VBlank.  Untuk mengatur posisi pengguliran, cukup untuk mengatur register X dan Y ke 0. Dengan palet, semuanya sedikit lebih rumit.  Di Game Boy, Anda dapat menetapkan corak dari grafik pertama ke keempat dari salah satu dari 4 corak abu-abu (atau hijau rawa, jika Anda mau), yang berguna untuk membuat transisi dan sejenisnya.  Saya menetapkan gradien sederhana sebagai palet, didefinisikan sebagai daftar bit <code>%11100100</code> . <br><br><h3>  Menghapus VRAM dan memuat grafik ubin </h3><br>  Saat diluncurkan, semua data grafis dan peta latar belakang hanya akan terdiri dari logo Nintendo yang bergulir, yang ditampilkan ketika sistem melakukan booting.  Jika saya mengaktifkan sprite (dinonaktifkan secara default), mereka akan menjadi sampah yang tersebar di layar.  Anda perlu menghapus memori video untuk memulai dari awal. <br><br>  Untuk melakukan ini, saya memerlukan fungsi seperti <code>memset</code> dari C. (Saya juga membutuhkan <code>memcpy</code> analog untuk menyalin data grafik.) Fungsi <code>memset</code> mengatur fragmen memori yang ditentukan ke byte tertentu.  Ini akan mudah bagi saya untuk mengimplementasikan ini sendiri, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial AssemblyDigest</a> sudah memiliki fungsi-fungsi ini, jadi saya menggunakannya. <br><br>  Pada titik ini, saya dapat menghapus VRAM dengan <code>memset</code> dengan menulis <code>$00</code> (meskipun komit pertama menggunakan nilai <code>$FF</code> , yang juga cocok), dan kemudian memuat ubin ubin ke dalam VRAM menggunakan <code>memcpy</code> .  Lebih khusus lagi, saya perlu menyalinnya ke alamat <code>$9000</code> , karena ini ubin yang hanya digunakan untuk grafik latar belakang.  (Alamat <code>$8000-$87FF</code> hanya digunakan untuk ubin sprite, dan alamat <code>$8800-$8FFF</code> umum untuk kedua jenis.) <br><br><h3>  Pengaturan Peta Ubin </h3><br>  Game Boy memiliki satu lapisan latar belakang, dibagi menjadi 8x8 ubin.  Lapisan latar belakang itu sendiri membutuhkan sekitar 32x32 ubin, yaitu, ia memiliki ukuran total 256x256.  (Sebagai perbandingan: layar konsol memiliki resolusi 160x144.) Saya perlu secara manual menunjukkan ubin yang membentuk garis gambar saya demi baris.  Untungnya, semua ubin disusun secara berurutan, jadi saya hanya perlu mengisi setiap baris dengan nilai dari <code>N*11</code> hingga <code>N*11 + 10</code> , di mana <code>N</code> adalah nomor baris, dan 22 elemen ubin lainnya mengisi <code>$FF</code> . <br><br><h3>  Menghidupkan LCD </h3><br>  Di sini kita tidak perlu menunggu VBlank, karena layar masih tidak akan menyala sampai VBlank, jadi saya hanya menulis ke register kontrol LCD lagi.  Saya juga menyertakan lapisan latar belakang dan sprite, dan juga menunjukkan alamat yang benar dari peta ubin dan grafik ubin.  Setelah itu saya mendapat hasil sebagai berikut.  Saya juga menyalakan interrupt handler lagi menggunakan <code>ei</code> opcode. <br><br>  Pada titik ini, untuk membuatnya lebih menarik, saya menulis interrupt handler yang sangat sederhana untuk VBlank.  Dengan menambahkan opcode transisi seharga <code>$40</code> , saya dapat membuat fungsi apa pun yang dibutuhkan penangan.  Dalam hal ini, saya menulis fungsi sederhana yang menggulung layar ke atas dan ke bawah. <br><br>  Inilah hasil akhirnya.  [Tambahan: Saya baru menyadari bahwa GIF tidak diulang dengan benar, itu harus terus-menerus mentransfer gambar.] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd0/c84/9db/fd0c849dbe3bc68910d186b1ef014c66.gif"></div><br>  Sejauh ini, tidak ada yang mengejutkan, tetapi secara teori masih keren bahwa saya bisa mendapatkan Warna Game Boy lama saya dan melihat bagaimana kode saya sendiri dieksekusi di atasnya. <br><br><h2>  Bersenang-senang dengan lembaran kotak-kotak </h2><br>  Untuk menggambar sesuatu di layar, saya secara alami membutuhkan semacam sprite.  Setelah mempelajari PPU (Picture Processing Unit) dari konsol Game Boy, saya memutuskan untuk fokus pada sprite 8x8 atau 8x16.  Mungkin, saya akan membutuhkan opsi terakhir, tetapi hanya untuk merasakan ukurannya, saya dengan cepat menuliskan screenshot permainan dalam skala 1: 8 pada kertas kotak-kotak. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/b5b/ece/887b5becec39b13f2fd167e9436c63e5.jpg"></div><br>  Saya ingin meninggalkan bagian atas layar di bawah HUD.  Menurut saya itu akan terlihat lebih alami daripada dari bawah, karena ketika sudah habis, maka jika karakter perlu untuk sementara memblokir HUD, seperti di Super Mario Bros, mereka dapat melakukannya.  Game ini tidak akan memiliki platforming yang kompleks, dan bahkan desain levelnya juga, jadi saya tidak perlu menunjukkan tampilan lapangan yang sangat umum.  Posisi karakter di layar dan, mungkin, rintangan yang muncul dari waktu ke waktu akan cukup.  Karena itu, saya bisa membeli sprite yang cukup besar. <br><br>  Jadi, jika satu kotak adalah satu ubin 8x8, maka satu sprite <em>tidak</em> akan cukup, tidak peduli berapa ukuran yang saya pilih.  Ini terutama benar mengingat bahwa hampir tidak akan ada gerakan vertikal dalam game, dengan pengecualian melompat.  Jadi saya memutuskan untuk membuat sprite dari empat sprite 8x16.  Pengecualian adalah ekor rubah, yang menempati dua spanduk 8x16.  Setelah perhitungan sederhana, menjadi jelas bahwa dua rubah dan dua tokek akan menempati 20 dari 40 sprite, artinya, akan dimungkinkan untuk menambahkan lebih banyak sprite tambahan.  (Spanduk 8x8 dengan cepat akan keluar dari batas saya, yang saya tidak ingin lakukan pada tahap awal pengembangan.) <br><br>  Untuk saat ini, saya hanya perlu menggambar sprite.  Di bawah ini adalah sketsa kasar pada kertas kotak-kotak.  Saya memiliki sprite menunggu, sprite "berpikir" untuk memilih apakah akan lulus atau berlari, seperti dalam permainan SNES ... dan hanya itu.  Saya juga berencana untuk membuat sprite karakter berjalan, karakter melompat dan karakter yang lawan ambil.  Tapi sebagai permulaan, saya menggambar hanya menunggu dan berpikir sprite, agar tidak menyulitkan.  Saya masih tidak melakukan sisanya, saya perlu melakukan ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/623/20c/124/62320c12434cacf0c0ca06a2aad33fae.jpg"></div><br>  Ya, saya tahu, saya tidak menggambar dengan baik.  Perspektif adalah hal yang sulit.  (Ya, dan wajah rubah kutub ini mengerikan.) Tapi itu sangat cocok untukku.  Desain karakter tidak memiliki fitur khusus, tetapi cocok untuk permainan yang macet.  Tentu saja, saya menggunakan tokek dan rubah kutub asli sebagai referensi.  Apakah itu tidak terlihat? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fe/b2e/936/1feb2e936415aeceaf8cd35596d7e55d.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/215/cc8/568/215cc856884bb518df111799d6e10a87.jpg"></div><br>  Anda tidak bisa mengatakannya.  (Sebagai catatan: baru saja melihat foto-foto ini lagi, saya menyadari bahwa ada perbedaan besar antara tokek dan kadal. Saya tidak tahu apa yang harus dilakukan dengan ini, kecuali menganggap saya bodoh ...) Saya pikir Anda dapat menebak bahwa sumber inspirasi untuk Blaze the Cat dari seri game Sonic menjadi kepala rubah. <br><br>  Awalnya, saya ingin para pembela dan pemain depan dalam setiap tim memiliki jenis kelamin yang berbeda dan lebih mudah untuk membedakan di antara mereka.  (Saya juga akan membiarkan para pemain memilih jenis kelamin karakter mereka.) Namun, ini akan membutuhkan lebih banyak gambar.  Jadi saya memilih tokek jantan dan rubah betina. <br><br>  Dan akhirnya, saya menggambar splash screen karena ada tempat untuk itu di selembar kertas kotak-kotak. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c67/5ac/30a/c675ac30af04025014da7eee842d285d.jpg"></div><br>  Ya, pose aksi masih jauh dari ideal.  Rubah kutub harus lebih kesal dan lari, dan tokek harus terlihat mengancam.  Defender Fox di latar belakang - referensi menyenangkan untuk seni di kotak Doom. <br><br><h2>  Digitalisasi sprite </h2><br>  Kemudian saya mulai mengubah gambar kertas menjadi sprite.  Untuk ini, saya menggunakan program GraphicsGale, yang baru-baru ini dibuat gratis.  (Saya tahu Anda bisa menggunakan asesprite, tapi saya lebih suka GraphicsGale.) Bekerja pada sprite ternyata jauh lebih rumit dari yang saya harapkan.  Masing-masing kotak dari sprite yang ditunjukkan di atas membutuhkan hingga 4 piksel dalam kisi 2x2.  Dan kotak ini sering memiliki JAUH lebih detail dari 4 piksel.  Karena itu, saya harus menyingkirkan banyak detail sketsa.  Kadang-kadang bahkan sulit untuk mematuhi bentuk yang sederhana, karena itu perlu untuk meninggalkan tempat yang dapat diterima oleh mata atau hidung.  Tapi menurut saya semuanya terlihat baik, bahkan jika sprite menjadi sangat berbeda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/789/d16/39f789d16e3c10c85fa4f0613a0cf571.png"></div><br>  Mata rubah kehilangan bentuk almond dan berubah menjadi garis setinggi dua piksel.  Mata tokek mempertahankan kebulatannya.  Kepala tokek harus diperbesar, menyingkirkan pundak yang lebar, dan semua tikungan yang bisa dimiliki rubah secara signifikan dihaluskan.  Tapi jujur, semua perubahan mudah ini tidak terlalu buruk.  Kadang-kadang saya sulit memilih variasi mana yang lebih baik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/32f/d71/a5232fd71193a02dfaebdc2c043edbe5.png"></div><br>  GraphicsGale juga memiliki fungsi yang mudah digunakan untuk lapisan dan animasi.  Ini berarti bahwa saya dapat menghidupkan ekor rubah secara terpisah dari tubuhnya.  Ini sangat membantu untuk menghemat ruang VRAM yang berharga karena saya tidak perlu menduplikasi ekor di setiap bingkai.  Selain itu, ini berarti Anda bisa mengibas-ngibaskan ekor Anda dengan kecepatan variabel, melambat ketika karakter berdiri, dan mempercepat saat berlari.  Namun, ini membuat pemrograman sedikit lebih rumit.  Tapi saya tetap akan mengambil tugas ini.  Saya memilih 4 frame animasi, karena ini sudah cukup. <br><br>  Anda mungkin memperhatikan bahwa rubah kutub menggunakan tiga warna abu-abu paling terang, sedangkan tokek menggunakan tiga warna abu-abu paling gelap.  Pada GameBoy, ini dapat diterima, karena meskipun hanya ada tiga warna dalam sprite, konsol memungkinkan Anda menentukan dua palet.  Saya membuatnya sehingga palet 0 digunakan untuk rubah, dan palet 1 digunakan untuk tokek. Itu semua set palet yang tersedia sudah berakhir, tetapi saya tidak berpikir saya membutuhkan yang lain. <br><br>  Saya juga harus menjaga latar belakang.  Saya tidak peduli dengan sketsa-sketsanya, karena saya merencanakan bahwa itu akan menjadi warna solid atau pola geometris sederhana.  Saya belum mendigitalkan screen saver, karena saya tidak punya cukup waktu. <br><br><h2>  Memuat sprite ke dalam game </h2><br>  Periksa dengan komitmen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">be99d97</a> . <br><br>  Setelah masing-masing bingkai grafis karakter disimpan, dimungkinkan untuk mulai mengonversinya ke format GameBoy.  Ternyata di RGBDS ada utilitas yang sangat nyaman untuk ini yang disebut RGBGFX.  Anda dapat memanggilnya dengan perintah <code>rgbgfx -h -o output.bin input.png</code> dan itu akan membuat satu set ubin yang kompatibel dengan GameBoy.  (Sakelar -h menentukan mode ubin yang kompatibel dengan 8x16 sehingga konversi dilakukan dari atas ke bawah, dan bukan dari kiri ke kanan.) Namun, itu tidak memberikan binding dan tidak dapat melacak ubin duplikat ketika setiap frame adalah gambar yang terpisah.  Tapi kami akan meninggalkan masalah ini nanti. <br><br>  Setelah menghasilkan file .bin keluaran, cukup tambahkan di assembler menggunakan <code>incbin "output.bin"</code> .  Untuk menyatukan semuanya, saya membuat file umum "gfxinclude.z80", yang berisi semua grafik yang akan ditambahkan. <br><br>  Namun, sangat membosankan untuk membuat ulang grafik secara manual setiap kali sesuatu berubah.  Jadi saya mengedit file build.bat, menambahkan baris <code>for %%f in (gfx/*.png) do rgbds\rgbgfx -h -o gfx/bin/%%f.bin gfx/%%f</code> , yang mengubah setiap file. png di folder gfx / ke file bin dan menyimpannya ke gfx / bin.  Ini sangat menyederhanakan hidup saya. <br><br>  Untuk membuat grafik latar belakang, saya menggunakan cara yang <em>jauh</em> lebih malas.  RGBASM memiliki arahan <code>dw `</code> .  Ini diikuti oleh garis 8 nilai dari 0 hingga 4 sama dengan satu baris data piksel.  Karena sprite latar sangat sederhana, ternyata lebih mudah untuk menyalin dan menempelkan pola geometris sederhana untuk membuat pola yang solid, bergaris atau kotak-kotak.  Di sini, misalnya, terlihat seperti ubin tanah. <br><br><pre> <code class="hljs powershell">bg_dirt: dw `00110011 dw `00000000 dw `01100110 dw `00000000 dw `11001100 dw `00000000 dw `10011001 dw `00000000</code> </pre> <br>  Dia menciptakan serangkaian garis bergeser dengan ilusi perspektif.  Ini adalah pendekatan yang sederhana namun cerdas.  Dengan rumput itu sedikit lebih rumit.  Awalnya, itu adalah sekelompok garis horizontal 2 piksel tinggi, tetapi saya secara manual menambahkan beberapa piksel yang menambahkan sedikit noise yang membuat rumput terlihat lebih baik: <br><br><pre> <code class="hljs powershell">bg_grass: dw `12121112 dw `12121212 dw `22112211 dw `11121212 dw `22112211 dw `21212121 dw `12121212 dw `12211222</code> </pre> <br><h2>  Render gambar </h2><br>  Di GameBoy, sprite disimpan di area yang disebut OAM, atau Object Attribute Memory.  Ini hanya berisi atribut (arah, palet dan prioritas), serta nomor ubin.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cukup bagi saya untuk mengisi area memori ini untuk menampilkan sprite di layar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meski ada fitur kecil. Pertama, Anda perlu memuat gambar dari ROM ke VRAM. GameBoy hanya dapat membuat ubin yang disimpan di area khusus memori yang disebut VRAM. Untungnya, untuk menyalin dari ROM ke VRAM, itu sudah cukup untuk melakukannya </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada tahap inisialisasi program. Ternyata dengan hanya 6 sprite karakter dan 4 ubin ekor, saya sudah mengambil seperempat area VRAM yang dialokasikan untuk sprite. (VRAM biasanya dibagi menjadi area latar belakang dan sprite, dan 128 byte adalah umum untuk mereka.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, akses ke OAM hanya dimungkinkan selama VBlank. Saya mulai dengan mengatakan bahwa VBlank sedang menunggu perhitungan sprite, tetapi saya mengalami masalah karena perhitungan sprite berlangsung sepanjang waktu yang dialokasikan oleh VBlank dan tidak mungkin untuk menyelesaikannya. Solusi di sini adalah menulis ke </font><font style="vertical-align: inherit;">area memori </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terpisah</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di luar VBlank dan cukup menyalinnya ke OAM selama VBlank. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ternyata, GameBoy memiliki prosedur penyalinan perangkat keras khusus, semacam DMA (Akses Memori Langsung, akses langsung ke memori) yang melakukan hal itu. Dengan menulis ke register tertentu dan pergi ke siklus sibuk di HiRAM (karena ROM tidak tersedia selama DMA), Anda dapat menyalin data dari RAM ke OAM lebih cepat daripada menggunakan fungsi</font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika tertarik, maka detail menarik bisa ditemukan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap ini, saya hanya bisa membuat prosedur yang menentukan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apa yang</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nantinya akan ditulis ke DMA. </font><font style="vertical-align: inherit;">Untuk melakukan ini, saya perlu menyimpan keadaan objek di tempat lain. </font><font style="vertical-align: inherit;">Minimal, hal-hal berikut diperlukan:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketik (tokek, rubah kutub atau membawa barang dari salah satu tim) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arahan </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posisi X </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posisi Y </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bingkai animasi </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Timer animasi </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam keputusan pertama, sangat berantakan, saya memeriksa jenis objek, dan bergantung padanya, saya beralih ke prosedur yang secara spritically menggambar objek jenis ini. Prosedur rubah kutub, misalnya, mengambil posisi dalam X, tergantung pada arahnya, ditambahkan atau dikurangi 16, menambahkan dua sprite ekor, dan kemudian bergerak naik turun sprite utama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah tangkapan layar tentang bagaimana sprite terlihat di VRAM saat merender di layar. Bagian kiri adalah sprite individu, angka heksadesimal di sebelahnya, dari atas ke bawah - posisi vertikal dan horizontal, ubin dan bendera atribut. Di sebelah kanan Anda dapat melihat bagaimana semuanya terlihat setelah perakitan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e9/e7d/240/8e9e7d2401e1a07d0c77e2f0c6c99e3d.png"></div><br>       .                <code>and</code>   <code>%11</code>    .           VRAM 4 *   (     4 ),   4  ,   VRAM.   (      ),    <em></em> ,        . <br><br>  ,   ,       <em></em> ,     <code>and</code>  <em></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan derajat dua yang dipilih oleh saya adalah 0, kenaikan timer objek dilakukan. Dengan demikian, setiap objek individu dapat menghitung mundur penghitung waktu animasi pada kecepatan yang diperlukan. Ini bekerja dengan sempurna dan memungkinkan saya untuk memperlambat ekor ke tingkat yang masuk akal.</font></font><br><br><h2>  Kesulitan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi jika semuanya begitu sederhana. Jangan lupa bahwa saya berhasil semua ini dalam kode, menggunakan subprocedure saya sendiri untuk setiap objek, dan jika Anda harus melanjutkan, Anda perlu melakukan ini di setiap frame. Saya harus menentukan cara melanjutkan ke sprite berikutnya, serta ubin apa itu terdiri dari, memanipulasi register secara manual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu adalah sistem yang sama sekali tidak stabil. Untuk menggambar satu frame, perlu untuk menyulap sejumlah besar register dan waktu CPU. Nyaris mustahil untuk menambahkan dukungan untuk personel lain, dan bahkan jika saya berhasil, dukungan sistem akan sangat menyakitkan. </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Percayalah, itu benar-benar kekacauan.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya membutuhkan sistem di mana kode untuk rendering sprite akan digeneralisasikan dan langsung, sehingga tidak akan menjalin kondisi, manipulasi register dan operator matematika. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana saya memperbaikinya? </font><font style="vertical-align: inherit;">Saya akan membicarakan hal ini di bagian artikel selanjutnya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47d/f64/3a2/47df643a2bd620cf8899b3601162748b.gif" alt="gambar"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436330/">https://habr.com/ru/post/id436330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436320/index.html">Banyak properti atau properti-objek: kriteria pemilihan</a></li>
<li><a href="../id436322/index.html">@Pythonetc Desember 2018</a></li>
<li><a href="../id436324/index.html">Kiat dan trik dari saluran Telegram saya @pythonetc, Desember 2018</a></li>
<li><a href="../id436326/index.html">Desentralisasi ulang web. Selamanya kali ini</a></li>
<li><a href="../id436328/index.html">PVS-Studio 7.00</a></li>
<li><a href="../id436332/index.html">PVS-Studio 7.00</a></li>
<li><a href="../id436334/index.html">Konsep pembelajaran melalui interaksi sensorimotor</a></li>
<li><a href="../id436338/index.html">Bagaimana cara kerja bandara Vnukovo</a></li>
<li><a href="../id436340/index.html">Pisahkan level logging untuk setiap permintaan</a></li>
<li><a href="../id436342/index.html">Pengantar optimasi yang kuat [... dan daftar belanja kecil yang saya lupa ...]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>