<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äç‚öïÔ∏è üèóÔ∏è üêΩ Guide de l'API Vavr Collections üëãüèº üë®üèæ‚Äçüíº üö¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="VAVR (anciennement Javaslang) est une biblioth√®que fonctionnelle √† but non lucratif pour Java 8+. Il vous permet d'√©crire du code fonctionnel de type ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide de l'API Vavr Collections</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474402/">  <b>VAVR</b> (anciennement Javaslang) est une biblioth√®que fonctionnelle √† but non lucratif pour Java 8+.  Il vous permet d'√©crire du code fonctionnel de type Scala en Java et sert √† r√©duire la quantit√© de code et √† am√©liorer sa qualit√©.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Site de la biblioth√®que</a> . <br><br>  Sous la coupe se trouve une traduction d'un article syst√©matisant les informations sur <b>l'API Vavr Collections</b> . <br><a name="habracut"></a><br>  Traduit par <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@middle_java</a></b> <br><br>  Derni√®re modification de l'article original: 15 ao√ªt 2019 <br><br><h2>  1. Pr√©sentation </h2><br>  La biblioth√®que Vavr, pr√©c√©demment connue sous le nom de Javaslang, est une biblioth√®que fonctionnelle pour Java.  Dans cet article, nous explorons sa puissante API de collecte. <br><br>  Consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article pour</a> plus d'informations sur cette biblioth√®que. <br><br><h2>  2. Collections persistantes </h2><br>  Une collection persistante, lorsqu'elle est modifi√©e, cr√©e une nouvelle version de la collection sans changer la version actuelle. <br><br>  La prise en charge de plusieurs versions de la m√™me collection peut entra√Æner une utilisation inefficace du processeur et de la m√©moire.  Cependant, la biblioth√®que de collections Vavr surmonte cela en partageant la structure de donn√©es entre diff√©rentes versions de la collection. <br><br>  Ceci est fondamentalement diff√©rent de <code>unmodifiableCollection()</code> de la classe d'utilitaires Java <code>Collections</code> , qui fournit simplement un wrapper pour la collection de base. <br><br>  Tenter de modifier une telle collection <code>UnsupportedOperationException</code> au lieu de cr√©er une nouvelle version.  De plus, la collection de base est toujours modifiable par un lien direct avec elle. <br><br><h2>  3. Traversable </h2><br>  <code>Traversable</code> est le type de base de toutes les collections Vavr.  Cette interface d√©finit des m√©thodes communes √† toutes les structures de donn√©es. <br><br>  Il fournit des m√©thodes par d√©faut utiles, telles que <code>size()</code> , <code>get()</code> , <code>filter()</code> , <code>isEmpty()</code> et d'autres h√©rit√©es des sous-interfaces. <br><br>  Nous explorons davantage la biblioth√®que de la collection. <br><br><h2>  4. Seq </h2><br>  Commen√ßons par les s√©quences. <br><br>  L'interface <code>Seq</code> est une structure de donn√©es s√©quentielle.  Il s'agit de l'interface parent pour <code>List</code> , <code>Stream</code> , <code>Queue</code> , <code>Array</code> , <code>Vector</code> et <code>CharSeq</code> .  Toutes ces structures de donn√©es ont leurs propres propri√©t√©s uniques, dont nous parlerons ci-dessous. <br><br><h3>  4.1.  Liste </h3><br>  <code>List</code> est une op√©ration calcul√©e √©nergiquement (√©valu√©e avec impatience, est effectu√©e d√®s que les valeurs de ses op√©randes sont connues) une s√©quence d'√©l√©ments qui √©tendent l'interface <code>LinearSeq</code> . <br><br>  Les <code>List</code> persistantes <code>List</code> construites r√©cursivement en utilisant la <b>t√™te</b> et la <b>queue</b> : <br><br><ul><li>  <b>La t√™te</b> est le premier √©l√©ment </li><li>  <b>Queue</b> - une liste contenant les √©l√©ments restants (cette liste est √©galement form√©e de la t√™te et de la queue) </li></ul><br>  L'API <code>List</code> contient des m√©thodes d'usine statiques que vous pouvez utiliser pour cr√©er une <code>List</code> .  Vous pouvez utiliser la m√©thode static <code>of()</code> pour cr√©er une instance de <code>List</code> partir d'un ou plusieurs objets. <br><br>  Vous pouvez √©galement utiliser la m√©thode static <code>empty()</code> pour cr√©er une <code>List</code> vide et la m√©thode <code>ofAll()</code> pour cr√©er une <code>List</code> de type <code>Iterable</code> : <br><br><pre> <code class="java hljs">List &lt; String &gt; list = List.of( <span class="hljs-string"><span class="hljs-string">"Java"</span></span>, <span class="hljs-string"><span class="hljs-string">"PHP"</span></span>, <span class="hljs-string"><span class="hljs-string">"Jquery"</span></span>, <span class="hljs-string"><span class="hljs-string">"JavaScript"</span></span>, <span class="hljs-string"><span class="hljs-string">"JShell"</span></span>, <span class="hljs-string"><span class="hljs-string">"JAVA"</span></span>);</code> </pre> <br>  Regardons quelques exemples de manipulation de liste. <br><br>  Nous pouvons utiliser la m√©thode <code>drop()</code> et ses variantes pour supprimer les premiers <code>N</code> √©l√©ments: <br><br><pre> <code class="java hljs">List list1 = list.drop(<span class="hljs-number"><span class="hljs-number">2</span></span>); assertFalse(list1.contains(<span class="hljs-string"><span class="hljs-string">"Java"</span></span>) &amp;&amp; list1.contains(<span class="hljs-string"><span class="hljs-string">"PHP"</span></span>)); List list2 = list.dropRight(<span class="hljs-number"><span class="hljs-number">2</span></span>); assertFalse(list2.contains(<span class="hljs-string"><span class="hljs-string">"JAVA"</span></span>) &amp;&amp; list2.contains(<span class="hljs-string"><span class="hljs-string">"JShell"</span></span>)); List list3 = list.dropUntil(s - &gt; s.contains(<span class="hljs-string"><span class="hljs-string">"Shell"</span></span>)); assertEquals(list3.size(), <span class="hljs-number"><span class="hljs-number">2</span></span>); List list4 = list.dropWhile(s - &gt; s.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); assertTrue(list4.isEmpty());</code> </pre> <br>  <code>drop(int n)</code> supprime <code>n</code> √©l√©ments de la liste, √† partir du premier √©l√©ment, tandis que <code>dropRight()</code> fait de m√™me, √† partir du dernier √©l√©ment de la liste. <br><br>  <code>dropUntil()</code> supprime les √©l√©ments de la liste jusqu'√† ce que le pr√©dicat soit <code>true</code> , tandis que <code>dropWhile()</code> supprime les √©l√©ments jusqu'√† ce que le pr√©dicat soit <code>true</code> . <br><br>  Il existe √©galement des <code>dropRightWhile()</code> et <code>dropRightUntil()</code> qui suppriment les √©l√©ments en partant de la droite. <br><br>  Ensuite, <code>take(int n)</code> utilis√© pour r√©cup√©rer des √©l√©ments de la liste.  Il prend <code>n</code> √©l√©ments de la liste puis s'arr√™te.  Il y a aussi <code>takeRight(int n)</code> , qui prend des √©l√©ments de la fin de la liste: <br><br><pre> <code class="java hljs">List list5 = list.take(<span class="hljs-number"><span class="hljs-number">1</span></span>); assertEquals(list5.single(), <span class="hljs-string"><span class="hljs-string">"Java"</span></span>); List list6 = list.takeRight(<span class="hljs-number"><span class="hljs-number">1</span></span>); assertEquals(list5.single(), <span class="hljs-string"><span class="hljs-string">"Java"</span></span>); List list7 = list.takeUntil(s - &gt; s.length() &gt; <span class="hljs-number"><span class="hljs-number">6</span></span>); assertEquals(list3.size(), <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Enfin, <code>takeUntil()</code> prend des √©l√©ments de la liste jusqu'√† ce que le pr√©dicat devienne <code>true</code> .  Il existe une variante de <code>takeWhile()</code> qui prend √©galement un argument de pr√©dicat. <br><br>  De plus, l'API a d'autres m√©thodes utiles, par exemple m√™me <code>distinct()</code> , qui renvoie une liste d'√©l√©ments avec des doublons supprim√©s, ainsi que <code>distinctBy()</code> , qui accepte <code>Comparator</code> pour d√©terminer l'√©galit√©. <br><br>  Il est tr√®s int√©ressant qu'il y ait aussi <code>intersperse()</code> , qui ins√®re un √©l√©ment entre chaque √©l√©ment de la liste.  Cela peut √™tre tr√®s pratique pour les op√©rations avec <code>String</code> : <br><br><pre> <code class="java hljs">List list8 = list .distinctBy((s1, s2) - &gt; s1.startsWith(s2.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) + <span class="hljs-string"><span class="hljs-string">""</span></span>) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); assertEquals(list3.size(), <span class="hljs-number"><span class="hljs-number">2</span></span>); String words = List.of(<span class="hljs-string"><span class="hljs-string">"Boys"</span></span>, <span class="hljs-string"><span class="hljs-string">"Girls"</span></span>) .intersperse(<span class="hljs-string"><span class="hljs-string">"and"</span></span>) .reduce((s1, s2) - &gt; s1.concat(<span class="hljs-string"><span class="hljs-string">" "</span></span> + s2)) .trim(); assertEquals(words, <span class="hljs-string"><span class="hljs-string">"Boys and Girls"</span></span>);</code> </pre> <br>  Vous voulez diviser la liste en cat√©gories?  Et pour cela il y a une API: <br><br><pre> <code class="java hljs">Iterator &lt; List &lt; String &gt;&gt; iterator = list.grouped(<span class="hljs-number"><span class="hljs-number">2</span></span>); assertEquals(iterator.head().size(), <span class="hljs-number"><span class="hljs-number">2</span></span>); Map &lt; Boolean, List &lt; String &gt;&gt; map = list.groupBy(e - &gt; e.startsWith(<span class="hljs-string"><span class="hljs-string">"J"</span></span>)); assertEquals(map.size(), <span class="hljs-number"><span class="hljs-number">2</span></span>); assertEquals(map.get(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).get().size(), <span class="hljs-number"><span class="hljs-number">1</span></span>); assertEquals(map.get(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).get().size(), <span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br>  La m√©thode <code>group(int n)</code> divise <code>List</code> en groupes de <code>n</code> √©l√©ments chacun.  La m√©thode <code>groupdBy()</code> prend une <code>Function</code> qui contient la logique de fractionnement de la liste et renvoie une <code>Map</code> avec deux √©l√©ments: <code>true</code> et <code>false</code> . <br><br>  La <code>true</code> cl√© est mapp√©e sur la <code>List</code> √©l√©ments satisfaisant √† la condition sp√©cifi√©e dans <code>Function</code> .  La <code>false</code> cl√© correspond √† la <code>List</code> √©l√©ments qui ne remplissent pas cette condition. <br><br>  Comme pr√©vu, lors de la modification de la <code>List</code> , la <code>List</code> origine ne change pas r√©ellement.  Au lieu de cela, la nouvelle version de <code>List</code> toujours renvoy√©e. <br><br>  Nous pouvons √©galement interagir avec <code>List</code> utilisant la s√©mantique de la pile - extraire des √©l√©ments selon le principe ¬´dernier entr√©, premier sorti¬ª (LIFO).  En ce sens, des m√©thodes API telles que <code>peek()</code> , <code>pop()</code> et <code>push()</code> existent pour manipuler la pile: <br><br><pre> <code class="java hljs">List &lt; Integer &gt; intList = List.empty(); List &lt; Integer &gt; intList1 = intList.pushAll(List.rangeClosed(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)); assertEquals(intList1.peek(), Integer.valueOf(<span class="hljs-number"><span class="hljs-number">10</span></span>)); List intList2 = intList1.pop(); assertEquals(intList2.size(), (intList1.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br>  La fonction <code>pushAll()</code> est utilis√©e pour ins√©rer une plage d'entiers sur la pile, et la fonction <code>peek()</code> est utilis√©e pour r√©cup√©rer l'√©l√©ment head de la pile.  Il existe √©galement une m√©thode <code>peekOption()</code> qui peut encapsuler le r√©sultat dans un objet <code>Option</code> . <br><br>  Il existe d'autres m√©thodes int√©ressantes et vraiment utiles dans l'interface <code>List</code> qui sont document√©es en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©tail</a> dans les documents <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java</a> . <br><br><h3>  4.2.  File d'attente </h3><br>  La <code>Queue</code> immuable stocke les √©l√©ments, vous permettant de les r√©cup√©rer selon le principe FIFO (premier entr√©, premier sorti). <br><br>  <code>Queue</code> int√©rieur se compose de deux listes li√©es: la <code>List</code> avant et la <code>List</code> arri√®re.  La <code>List</code> avant contient les √©l√©ments qui sont supprim√©s de la file d'attente et la <code>List</code> arri√®re contient les √©l√©ments mis en file d'attente. <br><br>  Cela vous permet de mettre les op√©rations de mise en file d'attente et de retrait de la file d'attente √† la complexit√© <b>O (1)</b> .  Lorsque la <code>List</code> se termine dans la <code>List</code> avant lorsqu'elle est supprim√©e de la file d'attente, la <code>List</code> arri√®re <code>List</code> invers√©e et devient la nouvelle <code>List</code> avant. <br><br>  Cr√©ons une file d'attente: <br><br><pre> <code class="java hljs">Queue &lt; Integer &gt; queue = Queue.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); Queue &lt; Integer &gt; secondQueue = queue.enqueueAll(List.of(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, queue.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">5</span></span>, secondQueue.size()); Tuple2 &lt; Integer, Queue &lt; Integer &gt;&gt; result = secondQueue.dequeue(); assertEquals(Integer.valueOf(<span class="hljs-number"><span class="hljs-number">1</span></span>), result._1); Queue &lt; Integer &gt; tailQueue = result._2; assertFalse(tailQueue.contains(secondQueue.get(<span class="hljs-number"><span class="hljs-number">0</span></span>)));</code> </pre> <br>  La fonction <code>dequeue()</code> supprime l'√©l√©ment head de <code>Queue</code> et renvoie <code>Tuple2&lt;T, Q&gt;</code> .  Le premier √©l√©ment du tuple est l'√©l√©ment head retir√© de la file d'attente, le deuxi√®me √©l√©ment du tuple est le reste des √©l√©ments <code>Queue</code> . <br><br>  Nous pouvons utiliser la <code>combination(n)</code> pour obtenir toutes les <code>N</code> combinaisons possibles d'√©l√©ments dans la <code>Queue</code> : <br><br><pre> <code class="java hljs">Queue &lt; Queue &lt; Integer &gt;&gt; queue1 = queue.combinations(<span class="hljs-number"><span class="hljs-number">2</span></span>); assertEquals(queue1.get(<span class="hljs-number"><span class="hljs-number">2</span></span>).toCharSeq(), CharSeq.of(<span class="hljs-string"><span class="hljs-string">"23"</span></span>));</code> </pre> <br>  Encore une fois, la <code>Queue</code> origine ne change pas lors de l'ajout / suppression d'√©l√©ments de la file d'attente. <br><br><h3>  4.3.  Stream </h3><br>  <code>Stream</code> est une impl√©mentation d'une liste li√©e paresseusement qui est significativement diff√©rente de <code>java.util.stream</code> .  Contrairement √† <code>java.util.stream</code> , <code>Stream</code> Vavr stocke les donn√©es et calcule paresseusement les √©l√©ments suivants. <br>  Disons que nous avons des entiers <code>Stream</code> : <br><br><pre> <code class="java hljs">Stream &lt; Integer &gt; s = Stream.of(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Lors de l'impression du r√©sultat de <code>s.toString()</code> dans la console, seul <b>Stream (2 ,?)</b> sera affich√©.  Cela signifie que seul l'√©l√©ment de t√™te de <code>Stream</code> √©t√© calcul√©, alors que les √©l√©ments de queue ne l'ont pas √©t√©. <br><br>  Appeler <code>s.get(3)</code> puis afficher le r√©sultat de <code>s.tail()</code> renvoie <b>Stream (1, 3, 4 ,?)</b> .  Au contraire, si vous n'appelez pas d'abord <code>s.get(3)</code> - ce qui fera que <code>Stream</code> calculera le dernier √©l√©ment - seul <b>Stream (1 ,?)</b> sera le r√©sultat de <code>s.tail()</code> <b>)</b> .  Cela signifie que seul le premier √©l√©ment de queue a √©t√© calcul√©. <br><br>  Ce comportement peut am√©liorer les performances et permet √† <code>Stream</code> d'√™tre utilis√© pour repr√©senter des s√©quences qui sont (th√©oriquement) infiniment longues. <br>  <code>Stream</code> dans Vavr est immuable et peut √™tre <code>Empty</code> ou <code>Cons</code> .  <code>Cons</code> composent de l'√©l√©ment de t√™te et de la queue calcul√©e paresseusement du <code>Stream</code> .  Contrairement √† <code>List</code> , <code>Stream</code> stocke que l'√©l√©ment head en m√©moire.  Les √©l√©ments de queue sont calcul√©s selon les besoins. <br><br>  Cr√©ons un <code>Stream</code> de 10 entiers positifs et calculons la somme des nombres pairs: <br><br><pre> <code class="java hljs">Stream &lt; Integer &gt; intStream = Stream.iterate(<span class="hljs-number"><span class="hljs-number">0</span></span>, i - &gt; i + <span class="hljs-number"><span class="hljs-number">1</span></span>) .take(<span class="hljs-number"><span class="hljs-number">10</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">10</span></span>, intStream.size()); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> evenSum = intStream.filter(i - &gt; i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) .sum() .longValue(); assertEquals(<span class="hljs-number"><span class="hljs-number">20</span></span>, evenSum);</code> </pre> <br>  Contrairement √† l'API <code>Stream</code> de Java 8, <code>Stream</code> dans Vavr est une structure de donn√©es pour stocker une s√©quence d'√©l√©ments. <br><br>  Par cons√©quent, il a des m√©thodes telles que <code>get()</code> , <code>append()</code> , <code>insert()</code> et autres pour manipuler ses √©l√©ments.  <code>drop()</code> , <code>distinct()</code> et certaines autres m√©thodes d√©crites pr√©c√©demment sont √©galement disponibles. <br><br>  Enfin, montrons rapidement <code>tabulate()</code> dans <code>Stream</code> .  Cette m√©thode retourne un <code>Stream</code> longueur <code>n</code> contenant des √©l√©ments qui sont le r√©sultat de l'application de la fonction: <br><br><pre> <code class="java hljs">Stream &lt; Integer &gt; s1 = Stream.tabulate(<span class="hljs-number"><span class="hljs-number">5</span></span>, (i) - &gt; i + <span class="hljs-number"><span class="hljs-number">1</span></span>); assertEquals(s1.get(<span class="hljs-number"><span class="hljs-number">2</span></span>).intValue(), <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Nous pouvons √©galement utiliser <code>zip()</code> pour cr√©er un <code>Stream</code> partir de <code>Tuple2&lt;Integer, Integer&gt;</code> , qui contient des √©l√©ments form√©s en combinant deux <code>Stream</code> : <br><br><pre> <code class="java hljs">Stream &lt; Integer &gt; s = Stream.of(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); Stream &lt; Tuple2 &lt; Integer, Integer &gt;&gt; s2 = s.zip(List.of(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>)); Tuple2 &lt; Integer, Integer &gt; t1 = s2.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); assertEquals(t1._1().intValue(), <span class="hljs-number"><span class="hljs-number">2</span></span>); assertEquals(t1._2().intValue(), <span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre> <br><h3>  4.4.  Array </h3><br>  <code>Array</code> est une s√©quence index√©e immuable qui fournit un acc√®s al√©atoire efficace.  Il est bas√© sur un <b>tableau d'</b> objets Java.  Il s'agit essentiellement d'un wrapper <code>Traversable</code> pour un tableau d'objets de type <code>T</code> <br><br>  Vous pouvez cr√©er une instance d' <code>Array</code> √† l'aide de la m√©thode static <code>of()</code> .  De plus, vous pouvez cr√©er une plage d'√©l√©ments √† l'aide des m√©thodes statiques <code>range()</code> et <code>rangeBy()</code> .  La m√©thode <code>rangeBy()</code> poss√®de un troisi√®me param√®tre qui vous permet de d√©terminer l'√©tape. <br><br>  Les m√©thodes <code>range()</code> et <code>rangeBy()</code> cr√©eront des √©l√©ments, en commen√ßant uniquement de la valeur initiale √† la valeur finale moins un.  Si nous devons inclure la valeur finale, nous pouvons utiliser <code>rangeClosed()</code> ou <code>rangeClosedBy()</code> : <br><br><pre> <code class="java hljs">Array &lt; Integer &gt; rArray = Array.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); assertFalse(rArray.contains(<span class="hljs-number"><span class="hljs-number">5</span></span>)); Array &lt; Integer &gt; rArray2 = Array.rangeClosed(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); assertTrue(rArray2.contains(<span class="hljs-number"><span class="hljs-number">5</span></span>)); Array &lt; Integer &gt; rArray3 = Array.rangeClosedBy(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); assertEquals(list3.size(), <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Travaillons avec les √©l√©ments en utilisant l'index: <br><br><pre> <code class="java hljs">Array &lt; Integer &gt; intArray = Array.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); Array &lt; Integer &gt; newArray = intArray.removeAt(<span class="hljs-number"><span class="hljs-number">1</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, intArray.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, newArray.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, newArray.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).intValue()); Array &lt; Integer &gt; array2 = intArray.replace(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); assertEquals(s1.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).intValue(), <span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br><h3>  4.5.  Vecteur </h3><br>  <code>Vector</code> est un croisement entre <code>Array</code> et <code>List</code> , fournissant une autre s√©quence index√©e d'√©l√©ments, permettant √† la fois un acc√®s al√©atoire et une modification en temps constant: <br><br><pre> <code class="java hljs">Vector &lt; Integer &gt; intVector = Vector.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); Vector &lt; Integer &gt; newVector = intVector.replace(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, intVector.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, newVector.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, intVector.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).intValue()); assertEquals(<span class="hljs-number"><span class="hljs-number">6</span></span>, newVector.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).intValue());</code> </pre> <br><h3>  4.6.  Charseq </h3><br>  <code>CharSeq</code> est un objet de collection pour repr√©senter une s√©quence de caract√®res primitifs.  Il s'agit essentiellement d'un wrapper pour <code>String</code> avec l'ajout d'op√©rations de collecte. <br><br>  Pour cr√©er <code>CharSeq</code> vous devez proc√©der comme suit. <br><br><pre> <code class="java hljs">CharSeq chars = CharSeq.of(<span class="hljs-string"><span class="hljs-string">"vavr"</span></span>); CharSeq newChars = chars.replace(<span class="hljs-string"><span class="hljs-string">'v'</span></span>, <span class="hljs-string"><span class="hljs-string">'V'</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, chars.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, newChars.size()); assertEquals(<span class="hljs-string"><span class="hljs-string">'v'</span></span>, chars.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); assertEquals(<span class="hljs-string"><span class="hljs-string">'V'</span></span>, newChars.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); assertEquals(<span class="hljs-string"><span class="hljs-string">"Vavr"</span></span>, newChars.mkString());</code> </pre> <br><h2>  5. D√©finir </h2><br>  Cette section pr√©sente les diff√©rentes impl√©mentations de <code>Set</code> dans la biblioth√®que de collections.  Une caract√©ristique unique de la structure de donn√©es <code>Set</code> est qu'elle n'autorise pas les valeurs en double. <br><br>  Il existe diff√©rentes impl√©mentations de <code>Set</code> .  Le principal est <code>HashSet</code> .  <code>TreeSet</code> n'autorise pas les √©l√©ments en double et peut √™tre tri√©.  <code>LinkedHashSet</code> pr√©serve l'ordre d'insertion des √©l√©ments. <br><br>  Examinons ces impl√©mentations de plus pr√®s. <br><br><h3>  5.1.  Hashset </h3><br>  <code>HashSet</code> a des m√©thodes d'usine statiques pour cr√©er de nouvelles instances.  Nous avons √©tudi√© certaines d'entre elles plus haut dans cet article, par exemple les <code>ofAll()</code> et les variations des m√©thodes <code>range()</code> . <br><br>  La diff√©rence entre les deux <b>ensembles</b> peut √™tre obtenue en utilisant la m√©thode <code>diff()</code> .  De plus, les m√©thodes <code>union()</code> et <code>intersect()</code> renvoient l'union et l'intersection de deux <b>ensembles</b> : <br><br><pre> <code class="java hljs">HashSet &lt; Integer &gt; set0 = HashSet.rangeClosed(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); HashSet &lt; Integer &gt; set0 = HashSet.rangeClosed(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); assertEquals(set0.union(set1), HashSet.rangeClosed(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)); assertEquals(set0.diff(set1), HashSet.rangeClosed(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); assertEquals(set0.intersect(set1), HashSet.rangeClosed(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>));</code> </pre> <br>  Nous pouvons √©galement effectuer des op√©rations de base, telles que l'ajout et la suppression d'√©l√©ments: <br><br><pre> <code class="java hljs">HashSet &lt; String &gt; set = HashSet.of(<span class="hljs-string"><span class="hljs-string">"Red"</span></span>, <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>); HashSet &lt; String &gt; newSet = set.add(<span class="hljs-string"><span class="hljs-string">"Yellow"</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, set.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, newSet.size()); assertTrue(newSet.contains(<span class="hljs-string"><span class="hljs-string">"Yellow"</span></span>));</code> </pre> <br>  L'impl√©mentation <code>HashSet</code> est bas√©e sur le <b>trieur de tableaux Hash (HAMT)</b> , qui offre des performances sup√©rieures par rapport √† <code>HashTable</code> et sa structure le rend appropri√© pour prendre en charge les collections persistantes. <br><br><h3>  5.2.  Treeset </h3><br>  <code>TreeSet</code> est une impl√©mentation de l'interface <code>SortedSet</code> .  Il stocke un ensemble d'√©l√©ments tri√©s et est impl√©ment√© √† l'aide d'arbres de recherche binaires.  Toutes ses op√©rations sont effectu√©es pendant le temps <b>O (log n)</b> . <br><br>  Par d√©faut, les √©l√©ments <code>TreeSet</code> sont tri√©s dans leur ordre naturel. <br>  Cr√©ons un <code>SortedSet</code> utilisant un ordre de tri naturel: <br><br><pre> <code class="java hljs">SortedSet &lt; String &gt; set = TreeSet.of(<span class="hljs-string"><span class="hljs-string">"Red"</span></span>, <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>); assertEquals(<span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, set.head()); SortedSet &lt; Integer &gt; intSet = TreeSet.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, intSet.average().get().intValue());</code> </pre> <br>  Pour organiser les √©l√©ments de mani√®re personnalis√©e, transmettez une instance de <code>Comparator</code> lors de la cr√©ation du <code>TreeSet</code> .  Vous pouvez √©galement cr√©er une cha√Æne √† partir d'un ensemble d'√©l√©ments: <br><br><pre> <code class="java hljs">SortedSet &lt; String &gt; reversedSet = TreeSet.of(Comparator.reverseOrder(), <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>); assertEquals(<span class="hljs-string"><span class="hljs-string">"Red"</span></span>, reversedSet.head()); String str = reversedSet.mkString(<span class="hljs-string"><span class="hljs-string">" and "</span></span>); assertEquals(<span class="hljs-string"><span class="hljs-string">"Red and Green and Blue"</span></span>, str);</code> </pre> <br><h3>  5.3.  Bitset </h3><br>  Les collections Vavr ont √©galement une impl√©mentation <code>BitSet</code> immuable.  L'interface <code>BitSet</code> √©tend l'interface <code>BitSet</code> .  <code>BitSet</code> peut √™tre cr√©√© √† l'aide de m√©thodes statiques dans <code>BitSet.Builder</code> . <br>  Comme avec d'autres impl√©mentations de la structure de donn√©es <code>Set</code> , <code>BitSet</code> ne vous permet pas d'ajouter des enregistrements en double √† un ensemble. <br><br>  Il h√©rite des m√©thodes de manipulation de l'interface <code>Traversable</code> .  Notez qu'il est diff√©rent de <code>java.util.BitSet</code> de la biblioth√®que Java standard.  <code>BitSet</code> donn√©es <code>BitSet</code> ne peuvent pas contenir de valeurs de <code>String</code> . <br><br>  Envisagez de cr√©er une instance de <code>BitSet</code> √† l'aide de la m√©thode d'usine <code>of()</code> : <br><br><pre> <code class="java hljs">BitSet &lt; Integer &gt; bitSet = BitSet.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>); BitSet &lt; Integer &gt; bitSet1 = bitSet.takeUntil(i - &gt; i &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>); assertEquals(list3.size(), <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Pour s√©lectionner les quatre <code>BitSet</code> √©l√©ments <code>BitSet</code> nous avons utilis√© la commande <code>takeUntil()</code> .  L'op√©ration a renvoy√© une nouvelle instance.  Notez que la m√©thode <code>takeUntil()</code> est d√©finie dans l'interface <code>Traversable</code> , qui est l'interface parent de <code>BitSet</code> . <br><br>  Les autres m√©thodes et op√©rations d√©crites ci-dessus d√©finies dans l'interface <code>Traversable</code> s'appliquent √©galement √† <code>BitSet</code> . <br><br><h2>  6. Carte </h2><br>  <code>Map</code> est une structure de donn√©es de valeur-cl√©.  <code>Map</code> dans Vavr est immuable et comporte des impl√©mentations pour <code>HashMap</code> , <code>TreeMap</code> et <code>LinkedHashMap</code> . <br><br>  En r√®gle g√©n√©rale, les contrats de <b>carte</b> n'autorisent pas les cl√©s en double, tandis que les valeurs en double mapp√©es sur diff√©rentes cl√©s peuvent l'√™tre. <br><br><h3>  6.1.  Hashmap </h3><br>  <code>HashMap</code> est une impl√©mentation de l'interface <code>Map</code> immuable.  Il stocke les paires cl√©-valeur √† l'aide d'un hachage de cl√©s. <br><br>  <code>Map</code> dans Vavr utilise <code>Tuple2</code> pour repr√©senter des paires cl√©-valeur au lieu du type d' <code>Entry</code> traditionnel: <br><br><pre> <code class="java hljs">Map &lt; Integer, List &lt; Integer &gt;&gt; map = List.rangeClosed(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) .groupBy(i - &gt; i % <span class="hljs-number"><span class="hljs-number">2</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, map.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">6</span></span>, map.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).get().size()); assertEquals(<span class="hljs-number"><span class="hljs-number">5</span></span>, map.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).get().size());</code> </pre> <br>  Comme <code>HashSet</code> , l'impl√©mentation de <code>HashMap</code> bas√©e sur le <b>trieur de tableaux Hash (HAMT)</b> , ce qui conduit √† un temps constant pour presque toutes les op√©rations. <br>  <b>Les</b> √©l√©ments de <b>carte</b> peuvent √™tre filtr√©s par cl√© √† l'aide de la m√©thode <code>filterKeys()</code> ou par valeur √† l'aide de la m√©thode <code>filterValues()</code> .  Les deux m√©thodes prennent <code>Predicate</code> comme argument: <br><br><pre> <code class="java hljs">Map &lt; String, String &gt; map1 = HashMap.of(<span class="hljs-string"><span class="hljs-string">"key1"</span></span>, <span class="hljs-string"><span class="hljs-string">"val1"</span></span>, <span class="hljs-string"><span class="hljs-string">"key2"</span></span>, <span class="hljs-string"><span class="hljs-string">"val2"</span></span>, <span class="hljs-string"><span class="hljs-string">"key3"</span></span>, <span class="hljs-string"><span class="hljs-string">"val3"</span></span>); Map &lt; String, String &gt; fMap = map1.filterKeys(k - &gt; k.contains(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) || k.contains(<span class="hljs-string"><span class="hljs-string">"2"</span></span>)); assertFalse(fMap.containsKey(<span class="hljs-string"><span class="hljs-string">"key3"</span></span>)); Map &lt; String, String &gt; map1 = map1.filterValues(v - &gt; v.contains(<span class="hljs-string"><span class="hljs-string">"3"</span></span>)); assertEquals(list3.size(), <span class="hljs-number"><span class="hljs-number">1</span></span>); assertTrue(fMap2.containsValue(<span class="hljs-string"><span class="hljs-string">"val3"</span></span>));</code> </pre> <br>  Vous pouvez √©galement transformer des √©l√©ments de <b>carte</b> √† l'aide de la m√©thode <code>map()</code> .  Par exemple, convertissons <b>map1</b> en <code>Map&lt;String, Integer&gt;</code> : <br><br><pre> <code class="java hljs">Map &lt; String, Integer &gt; map2 = map1.map( (k, v) - &gt; Tuple.of(k, Integer.valueOf(v.charAt(v.length() - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-string"><span class="hljs-string">""</span></span>))); assertEquals(map2.get(<span class="hljs-string"><span class="hljs-string">"key1"</span></span>).get().intValue(), <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><h3>  6.2.  Treemap </h3><br>  Immutable <code>TreeMap</code> est une impl√©mentation de l'interface <code>SortedMap</code> .  Comme avec <code>TreeSet</code> , une instance personnalis√©e de <code>Comparator</code> utilis√©e pour personnaliser le tri des √©l√©ments <code>TreeMap</code> . <br>  <code>SortedMap</code> la cr√©ation de <code>SortedMap</code> : <br><br><pre> <code class="java hljs">SortedMap &lt; Integer, String &gt; map = TreeMap.of(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"Three"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"Two"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"Four"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"One"</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">1</span></span>, map.keySet().toJavaArray()[<span class="hljs-number"><span class="hljs-number">0</span></span>]); assertEquals(<span class="hljs-string"><span class="hljs-string">"Four"</span></span>, map.get(<span class="hljs-number"><span class="hljs-number">4</span></span>).get());</code> </pre> <br>  Par d√©faut, les entr√©es <code>TreeMap</code> sont tri√©es dans l'ordre des cl√©s naturelles.  Cependant, vous pouvez sp√©cifier le <code>Comparator</code> √† utiliser pour le tri: <br><br><pre> <code class="java hljs">TreeMap &lt; Integer, String &gt; treeMap2 = TreeMap.of(Comparator.reverseOrder(), <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"three"</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"six"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"one"</span></span>); assertEquals(treeMap2.keySet().mkString(), <span class="hljs-string"><span class="hljs-string">"631"</span></span>);</code> </pre> <br>  Comme dans le cas de <code>TreeSet</code> , l'impl√©mentation <code>TreeMap</code> est √©galement cr√©√©e √† l'aide de l'arbre, par cons√©quent, ses op√©rations ont le temps <b>O (log n)</b> .  La <code>map.get(key)</code> renvoie <code>Option</code> , qui contient la valeur de la cl√© de <b>carte</b> sp√©cifi√©e. <br><br><h2>  7. Compatibilit√© Java </h2><br>  L'API Vavr Collection est enti√®rement compatible avec Java Collection Framework.  Voyons comment cela se fait dans la pratique. <br><br><h3>  7.1.  Convertir de Java √† Vavr </h3><br>  Chaque impl√©mentation de collection dans Vavr poss√®de une <code>ofAll()</code> fabrique statique <code>ofAll()</code> qui accepte <code>java.util.Iterable</code> .  Cela vous permet de cr√©er une collection <b>Vavr √†</b> partir d'une collection <b>Java</b> .  De m√™me, une autre m√©thode d'usine <code>ofAll()</code> accepte directement Java <code>Stream</code> . <br><br>  Pour convertir une <code>List</code> Java en une <code>List</code> immuable: <br><br><pre> <code class="java hljs">java.util.List &lt; Integer &gt; javaList = java.util.Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); List &lt; Integer &gt; vavrList = List.ofAll(javaList); java.util.stream.Stream &lt; Integer &gt; javaStream = javaList.stream(); Set &lt; Integer &gt; vavrSet = HashSet.ofAll(javaStream);</code> </pre> <br>  Une autre fonction utile est <code>collector()</code> , qui peut √™tre utilis√©e en conjonction avec <code>Stream.collect()</code> pour obtenir la collection Vavr: <br><br><pre> <code class="java hljs">List &lt; Integer &gt; vavrList = IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) .boxed() .filter(i - &gt; i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) .collect(List.collector()); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, vavrList.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, vavrList.head().intValue());</code> </pre> <br><h3>  7.2.  Convertir de Vavr √† Java </h3><br>  L'interface <code>Value</code> poss√®de de nombreuses m√©thodes de conversion d'un type <b>Vavr</b> vers un type <b>Java</b> .  Ces m√©thodes ont le format <code>toJavaXXX()</code> . <br><br>  Prenons quelques exemples: <br><br><pre> <code class="java hljs">Integer[] array = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .toJavaArray(Integer.class); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, array.length); java.util.Map &lt; String, Integer &gt; map = List.of(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"3"</span></span>) .toJavaMap(i - &gt; Tuple.of(i, Integer.valueOf(i))); assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, map.get(<span class="hljs-string"><span class="hljs-string">"2"</span></span>).intValue());</code> </pre> <br>  Nous pouvons √©galement utiliser Java 8 <code>Collectors</code> pour collecter des √©l√©ments des collections Vavr: <br><br><pre> <code class="java hljs">java.util.Set &lt; Integer &gt; javaSet = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .collect(Collectors.toSet()); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, javaSet.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">1</span></span>, javaSet.toArray()[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre> <br><h3>  7.3.  Vues des collections Java </h3><br>  De plus, la biblioth√®que propose <b>des vues de collection</b> qui fonctionnent mieux lorsqu'elles sont converties en collections Java.  Les m√©thodes de transformation de la section pr√©c√©dente it√®rent sur (it√®rent) tous les √©l√©ments pour cr√©er une collection Java. <br><br>  Les vues, quant √† elles, impl√©mentent des interfaces Java standard et d√©l√®guent les appels de m√©thode √† la collection de base Vavr. <br><br>  Au moment d'√©crire ces lignes, seule la vue <code>List</code> est prise en charge.  Chaque collection s√©quentielle a deux m√©thodes: l'une pour cr√©er une repr√©sentation immuable, l'autre pour mutable. <br><br>  L'appel de m√©thodes pour modifier une vue immuable <code>UnsupportedOperationException</code> . <br><br>  Regardons un exemple: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span>(expected = UnsupportedOperationException.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">givenVavrList_whenViewConverted_thenException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ java.util.List &lt; Integer &gt; javaList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .asJava(); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, javaList.get(<span class="hljs-number"><span class="hljs-number">2</span></span>).intValue()); javaList.add(<span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br>  Pour cr√©er une vue immuable: <br><br><pre> <code class="java hljs">java.util.List &lt; Integer &gt; javaList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .asJavaMutable(); javaList.add(<span class="hljs-number"><span class="hljs-number">4</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, javaList.get(<span class="hljs-number"><span class="hljs-number">3</span></span>).intValue());</code> </pre> <br><h2>  8. Conclusions </h2><br>  Dans ce didacticiel, nous avons d√©couvert les diff√©rentes structures de donn√©es fonctionnelles fournies par l'API Vavr Collections.  Il existe √©galement des m√©thodes API utiles et productives qui peuvent √™tre trouv√©es dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation Java</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le</a> Guide de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisateur des</a> collections Vavr. <br><br>  Enfin, il est important de noter que la biblioth√®que d√©finit √©galement <code>Try</code> , <code>Option</code> , <code>Either</code> et <code>Future</code> , qui √©tendent l'interface <code>Value</code> et, par cons√©quent, impl√©mentent l'interface Java <code>Iterable</code> .  Cela signifie que dans certaines situations, ils peuvent se comporter comme des collections. <br><br>  Le code source complet de tous les exemples de cet article se trouve sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Github</a> . <br><br>  Mat√©riaux suppl√©mentaires: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/en/post/421839</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.baeldung.com/vavr</a> <br><br>  Traduit par <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474402/">https://habr.com/ru/post/fr474402/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474390/index.html">√âv√©nements num√©riques √† Saint-P√©tersbourg du 4 au 10 novembre</a></li>
<li><a href="../fr474392/index.html">Installez CentOS 8 sur VDS 256</a></li>
<li><a href="../fr474394/index.html">Utilisation de coroutines natives en Java</a></li>
<li><a href="../fr474396/index.html">Dell assemblera pour l'industrie p√©troli√®re le supercalculateur industriel le plus puissant de l'histoire</a></li>
<li><a href="../fr474400/index.html">Mythes sur la disponibilit√© du contraste des couleurs</a></li>
<li><a href="../fr474404/index.html">Analyse des probl√®mes r√©solus du championnat de programmation de Yandex (d√©veloppement front-end) 2019</a></li>
<li><a href="../fr474406/index.html">La premi√®re apparition de BlueKeep √† l'√©tat sauvage enregistr√©e</a></li>
<li><a href="../fr474408/index.html">R√©volution ou √©volution du mod√®le objet page?</a></li>
<li><a href="../fr474414/index.html">Nous √©crivons notre propre moteur voxel</a></li>
<li><a href="../fr474418/index.html">Conf√©rence DEFCON 27. B√©n√©ficier des produits de piratage pour macOS. Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>