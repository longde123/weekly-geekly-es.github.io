<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî¥ üßëüèø‚Äçü§ù‚Äçüßëüèæ üòô Le probl√®me du premier visualiseur ou la difficile conversion des flux vid√©o WebRTC en HLS ‚è±Ô∏è üë¥üèº üõÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Egor ferma le couvercle de l'ordinateur portable et se frotta les yeux rouges par manque de sommeil. "Les clients continuent de se plaindre du gel du ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le probl√®me du premier visualiseur ou la difficile conversion des flux vid√©o WebRTC en HLS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flashphoner/blog/480432/"><p><img src="https://habrastorage.org/webt/af/bt/ar/afbtarp3iizqyc4vnhqj2dxxmte.jpeg"></p><br><p>  Egor ferma le couvercle de l'ordinateur portable et se frotta les yeux rouges par manque de sommeil.  "Les clients continuent de se plaindre du gel du flux, le nouveau groupe de correctifs n'a pas aid√© du tout! Alors, que faire avec ce HLS (censur√©)?"  Il a dit dans le vide de l'√©tude. </p><a name="habracut"></a><br><h2 id="brauzer-eto-ne-tolko-gipertekst-no-i-strimer">  Le navigateur n'est pas seulement hypertexte, mais aussi un streamer </h2><br><p>  Les navigateurs ont acquis des joueurs depuis longtemps, mais avec un encodeur vid√©o et le streaming, l'histoire est diff√©rente.  D√©sormais, dans presque tous les navigateurs de la derni√®re version, vous pouvez trouver des modules d'encodage, de streaming, de d√©codage et de lecture.  Ces fonctions sont disponibles via l'API JavaScript et l'impl√©mentation est appel√©e Web Real Time Communications ou WebRTC.  Cette biblioth√®que int√©gr√©e aux navigateurs peut faire beaucoup: capturer de la vid√©o √† partir d'une cam√©ra int√©gr√©e, virtuelle ou USB, compresser avec les codecs H.264, VP8, VP9, ‚Äã‚Äãl'envoyer au r√©seau via le protocole SRTP, c'est-√†-dire  fonctionne comme un encodeur de streamer vid√©o logiciel.  En cons√©quence, nous voyons un navigateur qui a quelque chose de similaire √† ffmpeg ou gstreamer sous le capot, qui comprime bien la vid√©o, diffuse sur RTP et lit les flux vid√©o. </p><br><p>  WebRTC vous donne la libert√© d'impl√©menter une vari√©t√© de cas de streaming en JavaScript: </p><br><ul><li>  diffuser le flux du navigateur vers le serveur pour enregistrement et distribution ult√©rieure </li><li>  poste √† poste </li><li>  lire le flux d'un autre utilisateur et envoyer le v√¥tre (chat vid√©o) </li><li>  convertir d'autres protocoles par le serveur, par exemple RTMP, RTSP, etc., et jouer dans le navigateur en tant que WebRTC </li></ul><br><p>  Les scripts de contr√¥le de flux raffin√©s peuvent ressembler √† ceci: </p><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      session.createStream({name:‚Äùmystream‚Äù}).publish(); //   session.createStream({name:‚Äùmystream‚Äù}).play();</span></span></code> </pre> <br><h2 id="hls-rabotaet-tam-gde-ne-rabotaet-webrtc">  HLS fonctionne lorsque WebRTC ne fonctionne pas </h2><br><p>  WebRTC fonctionne dans les derni√®res versions des navigateurs, cependant, il existe deux des facteurs suivants: 1) Tous les utilisateurs ne mettent pas √† jour les navigateurs en temps opportun et peuvent tr√®s bien s'asseoir sur une sorte de Chrome pendant trois ans.  2) Presque une fois par semaine, des mises √† jour sont publi√©es et de nouveaux navigateurs, WebView, ainsi que d'autres clients et messagers instantan√©s qui peuvent surfer sur Internet.  Inutile de dire que tous ne prennent pas en charge WebRTC, et si c'est le cas, il peut √™tre assez tronqu√©.  Voyez comment les choses vont maintenant: </p><br><p><img src="https://habrastorage.org/webt/r8/wf/y8/r8wfy8p3nvyulliesmqnwhurhcw.png"></p><br><p>  Maux de t√™te s√©par√©s - les appareils Apple pr√©f√©r√©s de tous.  Ils ont r√©cemment re√ßu un soutien pour WebRTC et, parfois, sont surprenants dans leur comportement par rapport aux navigateurs Webkit orthodoxes.  Et lorsque WebRTC ne fonctionne pas ou ne fonctionne pas tr√®s bien, HLS fonctionne tr√®s bien.  √Ä cet √©gard, la compatibilit√© est requise, et quelque chose comme un convertisseur qui convertira WebRTC en HLS et le lira sur presque tous les appareils. </p><br><p>  Initialement, HLS n'a pas √©t√© con√ßu pour les flux en temps r√©el.  En effet, quelle peut √™tre la dur√©e de la vid√©o sur HTTP?  La t√¢che de HLS est de couper la vid√©o en morceaux et de la livrer au lecteur en douceur, sans pr√©cipitation, en la t√©l√©chargeant une par une.  Le lecteur HLS attend un flux vid√©o strictement form√© et fluide.  Et ici, un conflit survient, car WebRTC, au contraire, peut se permettre de perdre des paquets en raison d'exigences en temps r√©el et d'une faible latence et avoir un FPS / GOP flottant et un d√©bit binaire variable - pour √™tre l'exact oppos√© de HLS en termes de pr√©visibilit√© et de dimensionnalit√© du flux. </p><br><p>  Une approche √©vidente - la d√©pack√©tisation WebRTC (SRTP) et la <a href="https://flashphoner.com/vosproizvedenie-webrtc-i-rtmp-videopotokov-po-hls/%3Flang%3Dru">conversion</a> ult√©rieure en HLS, peuvent ne pas fonctionner dans le lecteur Apple HLS natif ou fonctionner sous une forme inadapt√©e √† la production avec des frises.  Un lecteur natif signifie ici un lecteur utilis√© dans Apple iOS Safari, Mac OS Safari, Apple TV. </p><br><p>  Par cons√©quent, si vous remarquez la frise HLS dans le lecteur natif, c'est peut-√™tre cela, et la source du flux est WebRTC ou un autre flux dynamique avec un balisage in√©gal.  De plus, dans la mise en ≈ìuvre de lecteurs natifs d'Apple, il existe un comportement qui ne peut √™tre compris que de mani√®re empirique.  Par exemple, le serveur doit commencer √† envoyer des segments HLS imm√©diatement, imm√©diatement apr√®s le retour de la liste de lecture m3u8.  Le retard par seconde menace de geler.  Si la configuration du flux binaire a chang√© au cours du processus (ce qui est assez fr√©quent avec le streaming WebRTC), il y aura √©galement une frise. </p><br><h2 id="borba-s-frizami-v-nativnyh-pleerah">  Lutte contre les frises chez les joueurs natifs </h2><br><p>  Ainsi, la d√©pack√©tisation et la mise en paquets WebRTC directes et honn√™tes dans HLS ne fonctionnent g√©n√©ralement pas.  Dans le serveur vid√©o en streaming <a href="https://flashphoner.com/">Web Call Server (WCS)</a> , nous r√©solvons le probl√®me de deux mani√®res, et nous proposons la troisi√®me alternative: </p><br><p>  1) Transcodage. </p><br><p>  C'est le moyen le plus fiable d'aligner le flux WebRTC sur les exigences HLS, de d√©finir le GOP, le FPS, etc. souhait√©s.  Cependant, dans certains cas, le transcodage n'est pas une bonne solution, par exemple, le transcodage de flux 4k de vid√©o VR est une id√©e m√©diocre.  Ces flux lourds sont tr√®s co√ªteux √† transcoder en termes de temps CPU ou de ressources GPU. </p><br><p><img src="https://habrastorage.org/webt/lk/sb/ap/lksbapmjw9cmefbwccx6l7vx3xs.png"></p><br><p>  2) Adaptation et alignement du flux WebRTC √† la vol√©e selon les exigences du HLS. </p><br><p>  Ce sont des analyseurs sp√©ciaux qui analysent le flux binaire H.264 et le corrigent pour les fonctionnalit√©s / bogues des lecteurs Apple HLS natifs.  Ici, nous devons admettre que les joueurs non natifs comme video.js et hls.js sont plus tol√©rants envers les flux avec un d√©bit binaire dynamique et FPS, qui est WebRTC et ne ralentit pas l√† o√π l'impl√©mentation de r√©f√©rence d'Apple HLS tombe essentiellement dans un gel perp√©tuel. </p><br><p><img src="https://habrastorage.org/webt/hh/c0/0j/hhc00j_fa7tj6frr5tme-rkqojg.png"></p><br><p>  3) Utilisez RTMP comme source de flux au lieu de WebRTC. </p><br><p>  Malgr√© le fait que le flash soit retir√©, le protocole RTMP est activement utilis√© pour le streaming, prenez le m√™me OBS Studio.  Et je dois admettre que les encodeurs RTMP produisent g√©n√©ralement des flux plus homog√®nes que WebRTC et ne produisent donc pratiquement pas de frises dans HLS, c'est-√†-dire  La conversion RTMP&gt; HLS du point de vue des frises semble beaucoup plus appropri√©e, y compris dans les lecteurs HLS natifs.  Par cons√©quent, si le streaming est effectu√© √† partir du bureau et d'OBS, il est pr√©f√©rable de l'utiliser pour la conversion en HLS.  Si la source est un navigateur Chrome, alors RTMP ne peut pas √™tre utilis√© sans installer de plugins, et ici uniquement WebRTC. </p><br><p><img src="https://habrastorage.org/webt/tm/ne/i2/tmnei2sj-cuw2fpw0wajlyxuz7m.png"></p><br><p>  Les trois m√©thodes d√©crites ci-dessus sont test√©es et fonctionnent, il est donc possible de choisir en fonction des conditions de la t√¢che. </p><br><h2 id="webrtc-v-hls-na-cdn">  WebRTC √† HLS sur CDN </h2><br><p>  Certains probl√®mes peuvent attendre dans un syst√®me distribu√© lorsque plusieurs serveurs de distribution de flux WebRTC sont situ√©s entre la source de flux WebRTC et le lecteur HLS, √† savoir <a href="https://flashphoner.com/cdn-dlya-striminga-webrtc-s-nizkoj-zaderzhkoj/%3Flang%3Dru">CDN</a> , dans notre cas, bas√© sur le serveur WCS.  Cela ressemble √† ceci: il y a Origin - un serveur qui re√ßoit un flux WebRTC, il y a des serveurs Edge - qui distribuent ce flux, y compris HLS.  Il peut y avoir de nombreux serveurs, ce qui permet une mise √† l'√©chelle horizontale du syst√®me.  Par exemple, 1000 serveurs HLS peuvent √™tre connect√©s √† un serveur Origin, dans ce cas, la capacit√© du syst√®me est mise √† l'√©chelle 1000 fois. </p><br><p><img src="https://habrastorage.org/webt/nq/hq/fq/nqhqfqm9_lzyrpxtofqk89jzw6u.png"></p><br><p>  Le probl√®me a d√©j√† √©t√© identifi√© un peu plus haut, et ce probl√®me se pose g√©n√©ralement dans les lecteurs natifs: iOS Safari, Mac OS Safari, Apple TV.  Par natif, nous entendons un lecteur qui fonctionne avec une indication directe de l'URL de la liste de lecture dans la balise, par exemple, <code>&lt;video src="https://host/test.m3u8"/&gt;</code> .  D√®s que le joueur a demand√© une liste de lecture, et que cette action est en fait la premi√®re √©tape de la lecture du flux HLS, le serveur doit imm√©diatement, sans d√©lai, commencer √† envoyer des segments vid√©o HLS.  Si le serveur ne commence pas √† donner des segments imm√©diatement, le joueur d√©cide qu'il a √©t√© tromp√© et arr√™te de jouer.  Encore une fois, ce comportement est typique des lecteurs HLS natifs d'Apple, mais nous ne pouvons pas dire aux utilisateurs - "veuillez ne pas utiliser iPhone Mac et Apple TV pour lire les flux HLS", les utilisateurs ne comprendront pas. </p><br><p>  Ainsi, lorsque vous essayez de lire le flux HLS sur le serveur Edge, le serveur doit imm√©diatement commencer √† renvoyer des segments, mais comment le fera-t-il s'il n'a pas de flux?  En effet, lors de la tentative de lecture d'un flux sur ce serveur est manquant.  La logique CDN fonctionne sur le principe du chargement diff√©r√© - nous ne dirigerons pas le flux vers le serveur jusqu'√† ce que quelqu'un demande ce flux sur ce serveur.  Il y a un probl√®me de connexion du premier - le premier qui a demand√© le flux HLS au serveur Edge et a eu l'insouciance de le faire du joueur natif d'Apple recevra une frise pour la raison qu'il faut un certain temps pour commander ce flux depuis le serveur Origin, pour l'obtenir sur Edge et proc√©der au d√©coupage HLS.  M√™me si cela prend trois secondes, le joueur ne l'enregistrera pas.  Il ira dans la frise. </p><br><p><img src="https://habrastorage.org/webt/g9/he/wh/g9hewhbfu04ypt81daubg0qouvy.png"></p><br><p>  L√† encore, deux d√©cisions se profilent: l'une est normale, l'autre pas tr√®s.  On pourrait abandonner l'approche Lazy Loading dans le CDN et envoyer du trafic √† tous les n≈ìuds, qu'il y ait ou non des t√©l√©spectateurs.  Une solution, peut-√™tre adapt√©e √† ceux qui ne sont pas limit√©s en termes de trafic et de ressources informatiques.  Origin g√©n√®rera du trafic vers tous les serveurs Edge, par cons√©quent, tous les serveurs et le r√©seau entre eux seront constamment charg√©s.  Ce sch√©ma ne conviendrait peut-√™tre qu'√† certaines solutions sp√©cifiques avec un petit nombre de flux entrants.  Lors de la r√©plication d'un grand nombre de threads, un tel sch√©ma sera clairement inefficace en termes de ressources.  Et si vous vous souvenez que nous ne r√©solvons que le ¬´probl√®me de la premi√®re connexion √† partir du navigateur natif¬ª, il est clair que cela n'en vaut pas la peine. </p><br><p><img src="https://habrastorage.org/webt/dx/n4/yf/dxn4yf28u8gtrczrshxc-smjjuq.png"></p><br><p>  La deuxi√®me option est plus √©l√©gante, mais aussi une solution de contournement.  Nous donnons au premier utilisateur connect√© une image vid√©o, mais ce n'est toujours pas le flux qu'il souhaite voir - c'est un pr√©chargeur.  Comme nous devons donner quelque chose maintenant et le faire imm√©diatement, mais nous n'avons pas le flux source (il est toujours command√© et livr√© depuis Origin), nous d√©cidons de demander au client d'attendre un peu et de lui montrer une vid√©o du pr√©chargeur avec une animation anim√©e.  L'utilisateur attend quelques secondes, le pr√©chargeur tourne et lorsque le flux r√©el arrive, l'utilisateur commence √† afficher le flux r√©el.  En cons√©quence, le premier utilisateur a vu le pr√©chargeur, et les suivants qui se sont enfin connect√©s ont vu le flux HLS normal provenant du CDN, travaillant sur le principe du chargement diff√©r√©.  Probl√®me d'ing√©nierie r√©solu. </p><br><h2 id="no-ne-do-konca">  Mais pas jusqu'au bout </h2><br><p>  Il semblerait que tout fonctionne tr√®s bien.  Le CDN fonctionne, les flux HLS sont extraits des serveurs Edge et le probl√®me de la premi√®re connexion est r√©solu.  Et voici un autre pi√®ge - nous donnons le pr√©chargeur dans un rapport d'aspect fixe de 16: 9, et CDN peut inclure des flux de n'importe quel format: 16: 9, 4: 3, 2: 1 (vid√©o VR).  Et c'est un probl√®me, car si vous donnez au lecteur un pr√©chargeur au format 16: 9, et que le flux command√© sera au format 4: 3, alors le joueur natif attend √† nouveau la frise. </p><br><p>  Par cons√©quent, une nouvelle t√¢che se pose - vous devez savoir avec quel format le flux entre dans le CDN et donner au pr√©chargeur dans le m√™me rapport.  Une caract√©ristique des flux WebRTC est la pr√©servation du rapport d'aspect lors du changement de r√©solution et pendant le transcodage - si le navigateur d√©cide de r√©duire la r√©solution, il l'abaisse dans le m√™me rapport.  Si le serveur d√©cide de transcoder le flux, il conserve les proportions dans la m√™me proportion.  Par cons√©quent, il est logique que si nous voulons afficher le pr√©chargeur pour HLS, nous le montrons dans le m√™me rapport d'aspect dans lequel le flux entre. </p><br><p><img src="https://habrastorage.org/webt/kn/ee/dr/kneedrbpqw4mfyrvrnpxufev0ui.png"></p><br><p>  Le CDN fonctionne comme suit: lorsque le trafic p√©n√®tre dans le serveur d'origine, il informe les autres serveurs du r√©seau, y compris les serveurs Edge, du nouveau flux.  Le probl√®me est qu'√† ce stade, la r√©solution du flux source peut ne pas encore √™tre connue.  La r√©solution est port√©e par les configurations de flux binaire H.264 avec l'image cl√©.  Par cons√©quent, il peut arriver que le serveur Edge re√ßoive des informations indiquant qu'il existe un flux, mais qu'il ne conna√Ætra pas sa r√©solution et son rapport hauteur / largeur, ce qui ne lui permettra pas de g√©n√©rer correctement le pr√©chargeur.  √Ä cet √©gard, il est n√©cessaire de signaler la pr√©sence d'un flux dans le CDN uniquement s'il y a une image cl√© - cela est garanti pour donner au serveur Edge des informations sur la taille et permettre au pr√©chargeur correct d'√™tre g√©n√©r√© pour √©viter ¬´le probl√®me du premier visualiseur connect√©¬ª. </p><br><p><img src="https://habrastorage.org/webt/vh/uy/aw/vhuyawuhtqsmyc8zg806egppu6i.png"></p><br><h2 id="itogi">  R√©sum√© </h2><br><p>  La conversion de WebRTC en HLS fournit g√©n√©ralement des frises lorsqu'il est jou√© dans des lecteurs Apple natifs.  Le probl√®me est r√©solu en analysant et en ajustant le flux binaire H.264 aux exigences HLS d'Apple, soit en transcodant, soit en utilisant la migration vers le protocole RTMP et l'encodeur comme source de flux.  Dans un r√©seau distribu√© avec chargement paresseux de flux, il y a un probl√®me du premier visualiseur connect√©, qui est r√©solu en utilisant le pr√©chargeur et en d√©terminant la r√©solution du c√¥t√© du serveur d'origine - le point d'entr√©e du flux dans le CDN. </p><br><h2 id="ssylki">  Les r√©f√©rences </h2><br><p>  <a href="https://flashphoner.com/">Serveur d'appel Web</a> - Serveur WebRTC </p><br><p>  CDN de <a href="https://flashphoner.com/cdn-dlya-striminga-webrtc-s-nizkoj-zaderzhkoj/%3Flang%3Dru">streaming WebRTC √† faible latence</a> - CDN bas√© sur WCS </p><br><p>  <a href="https://flashphoner.com/vosproizvedenie-webrtc-i-rtmp-videopotokov-po-hls/%3Flang%3Dru">Lecture de flux vid√©o WebRTC et RTMP sur HLS</a> - Fonctions serveur pour convertir des flux de diverses sources en HLS </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480432/">https://habr.com/ru/post/fr480432/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480416/index.html">Maths g√©n√©riques dangereux en C #</a></li>
<li><a href="../fr480422/index.html">Google Style Guide en C ++. Partie 1</a></li>
<li><a href="../fr480424/index.html">Google Style Guide en C ++. Partie 9</a></li>
<li><a href="../fr480428/index.html">La m√©thode de raccourci le plus simple. Alphabet et police pour elle.</a></li>
<li><a href="../fr480430/index.html">Fonctionnement du codec vid√©o. Partie 2. Quoi, pourquoi, comment</a></li>
<li><a href="../fr480438/index.html">√âv√©nements num√©riques √† Moscou du 16 au 22 d√©cembre</a></li>
<li><a href="../fr480440/index.html">√âv√©nements num√©riques √† Saint-P√©tersbourg du 16 au 22 d√©cembre</a></li>
<li><a href="../fr480444/index.html">D√©tective Habra: 24 heures de la vie de 24 publications</a></li>
<li><a href="../fr480446/index.html">√âcriture du proxy inverse Grafana sur Go</a></li>
<li><a href="../fr480452/index.html">OWASP Moscow Meetup # 9: Records de performance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>