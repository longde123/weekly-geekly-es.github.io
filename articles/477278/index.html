<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„Ä∞Ô∏è üêü üßùüèª Pruebas frontend üêæ ü¶î üå´Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una estrategia efectiva para la prueba de c√≥digo automatizada es extremadamente importante para garantizar el trabajo r√°pido y de alta calidad de los ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas frontend</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/477278/">  Una estrategia efectiva para la prueba de c√≥digo automatizada es extremadamente importante para garantizar el trabajo r√°pido y de alta calidad de los equipos de programadores involucrados en el soporte y desarrollo de proyectos web.  El autor del art√≠culo dice que en la empresa <a href="https://www.stackpath.com/">StackPath</a> , en la que trabaja, ahora todo funciona <a href="https://www.stackpath.com/">bien</a> con las pruebas.  Tienen muchas herramientas para verificar el c√≥digo.  Pero de tal variedad, debe elegir cu√°l es el m√°s adecuado para cada caso.  Este es un tema aparte.  Y despu√©s de seleccionar las herramientas necesarias, a√∫n debe tomar una decisi√≥n sobre el orden de su uso. <br> <a href="https://habr.com/ru/company/ruvds/blog/477278/"><img src="https://habrastorage.org/getpro/habr/post_images/1bd/f09/0a3/1bdf090a307b28098ab0758186db9d2c.svg" alt="imagen"></a> <br>  El autor del art√≠culo dice que StackPath est√° satisfecho con el nivel de confianza en la calidad del c√≥digo que se logr√≥ gracias al sistema de prueba aplicado.  Aqu√≠ quiere compartir una descripci√≥n de los principios de prueba desarrollados por la compa√±√≠a y hablar sobre las herramientas utilizadas. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Principios de prueba</font> </h2><br>  Antes de hablar sobre herramientas espec√≠ficas, vale la pena pensar en la respuesta a la pregunta de qu√© son buenas pruebas.  Antes de comenzar a trabajar en nuestro <a href="https://control.stackpath.com/">portal</a> para clientes, formulamos y escribimos los principios que nos gustar√≠a seguir al crear pruebas.  Lo que hicimos en primer lugar es exactamente lo que nos ayud√≥ con la elecci√≥n de las herramientas. <br><br>  Aqu√≠ est√°n los cuatro principios en cuesti√≥n. <br><br><h3>  <font color="#3AC1EF">‚ñç Principio n√∫mero 1.</font>  <font color="#3AC1EF">Las pruebas deben entenderse como tareas de optimizaci√≥n</font> </h3><br>  Una estrategia de prueba efectiva es resolver el problema de maximizar un cierto valor (en este caso, el nivel de confianza de que la aplicaci√≥n funcionar√° correctamente) y minimizar ciertos costos (aqu√≠ los "costos" est√°n representados por el tiempo requerido para soportar y ejecutar las pruebas).  Al escribir pruebas, a menudo hacemos las siguientes preguntas relacionadas con el principio descrito anteriormente: <br><br><ul><li>  ¬øCu√°l es la probabilidad de que esta prueba encuentre un error? </li><li>  ¬øEsta prueba mejora nuestro sistema de prueba y los costos de los recursos necesarios para escribirla valen los beneficios derivados de ella? </li><li>  ¬øEs posible obtener el mismo nivel de confianza en la entidad que se est√° probando que esta prueba proporciona creando otra prueba que sea m√°s f√°cil de escribir, mantener y ejecutar? </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Principio No. 2.</font>  <font color="#3AC1EF">Se debe evitar el uso excesivo de mox.</font> </h3><br>  Una de mis explicaciones favoritas del concepto de "mok" se dio en <a href="http://blog.testdouble.com/talks/2018-03-06-please-dont-mock-me/">esta</a> presentaci√≥n de la conferencia Assert.js 2018. El orador abri√≥ la pregunta m√°s profundamente de lo que voy a abrir aqu√≠.  En el discurso, la creaci√≥n de mokas se compara con "perforar agujeros en la realidad".  Y creo que esta es una forma muy visual de percibir a los moks.  Aunque hay mokas en nuestras pruebas, comparamos la disminuci√≥n en el "costo" de las pruebas que proporcionan los mokas debido a la simplificaci√≥n del proceso de redacci√≥n y ejecuci√≥n de pruebas, con la disminuci√≥n en el valor de las pruebas que hace que se haga otro agujero en la realidad. <br><br>  Anteriormente, nuestros programadores depend√≠an en gran medida de las pruebas unitarias escritas para que todas las dependencias secundarias fueran reemplazadas por mokas utilizando la API de representaci√≥n de <a href="https://airbnb.io/enzyme/docs/api/shallow.html">enzimas</a> poco profundas.  Las entidades representadas de esta manera se verificaron utilizando instant√°neas de <a href="https://jestjs.io/docs/en/snapshot-testing">Jest</a> .  Todas esas pruebas fueron escritas usando un patr√≥n similar: <br><br><pre><code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'renders '</span></span>, () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = shallow();   <span class="hljs-comment"><span class="hljs-comment">//  ,              expect(wrapper).toMatchSnapshot(); });</span></span></code> </pre> <br>  Estas pruebas est√°n llenas de realidad en muchos lugares.  Este enfoque hace que sea muy f√°cil lograr una cobertura de c√≥digo del 100% con las pruebas.  Al escribir tales pruebas, debe pensar muy poco, pero si no verifica todos los numerosos puntos de integraci√≥n, tales pruebas no son particularmente valiosas.  Todas las pruebas pueden completarse con √©xito, pero esto no da mucha confianza en la operatividad de la aplicaci√≥n.  Y lo que es peor, todos los mokas tienen un "precio" oculto que tienes que pagar despu√©s de que se escriben las pruebas. <br><br><h3>  <font color="#3AC1EF">‚ñç Principio No. 3.</font>  <font color="#3AC1EF">Las pruebas deber√≠an facilitar la refactorizaci√≥n del c√≥digo, no complicarlo.</font> </h3><br>  Las pruebas como la que se muestra arriba complican la refactorizaci√≥n.  Si encuentro que en muchos lugares del proyecto hay un c√≥digo duplicado, y despu√©s de un tiempo formateo este c√≥digo como un componente separado, todas las pruebas para los componentes en los que usar√© este nuevo componente fallar√°n.  Los componentes derivados de la t√©cnica de renderizado superficial ya son otra cosa.  Donde sol√≠a tener marcado repetido, ahora hay un nuevo componente. <br><br>  Una refactorizaci√≥n m√°s compleja, que implica agregar algunos componentes a un proyecto y eliminar algunos componentes m√°s, genera a√∫n m√°s confusi√≥n.  El hecho es que debe agregar nuevas pruebas al sistema y eliminar las pruebas innecesarias del mismo.  La regeneraci√≥n de instant√°neas es una tarea simple, pero ¬øcu√°l es el valor de tales pruebas?  Incluso si pueden encontrar un error, ser√≠a mejor si se lo perdieran en una serie de cambios de instant√°neas y simplemente verificaran nuevas instant√°neas sin dedicar demasiado tiempo a ello. <br><br>  Como resultado, tales pruebas no ayudan particularmente a refactorizar.  Idealmente, ninguna prueba deber√≠a fallar si realizo una refactorizaci√≥n, despu√©s de lo cual lo que ve el usuario y con lo que interact√∫a no ha cambiado.  Y viceversa: si cambi√© lo que est√° contactando el usuario, al menos una prueba deber√≠a fallar.  Si las pruebas siguen estas dos reglas, son una herramienta excelente para garantizar que algo que los usuarios encuentran no cambie durante la refactorizaci√≥n. <br><br><h3>  <font color="#3AC1EF">‚ñç Principio No. 4.</font>  <font color="#3AC1EF">Las pruebas deben reproducir c√≥mo los usuarios reales trabajan con la aplicaci√≥n.</font> </h3><br>  Me gustar√≠a que las pruebas fallaran solo si algo ha cambiado con lo que el usuario interact√∫a.  Esto significa que las pruebas deber√≠an funcionar con la aplicaci√≥n de la misma manera que los usuarios trabajan con ella.  Por ejemplo, una prueba realmente debe interactuar con elementos de formulario y, al igual que un usuario, debe ingresar texto en los campos de entrada de texto.  Las pruebas no deber√≠an acceder a los componentes y llamar independientemente a los m√©todos de su ciclo de vida, no deber√≠an escribir algo en el estado de los componentes o hacer algo que se base en las complejidades de la implementaci√≥n de los componentes.  Dado que, en √∫ltima instancia, quiero verificar la parte del sistema que est√° en contacto con el usuario, es l√≥gico esforzarme por asegurar que las pruebas, al interactuar con el sistema, reproduzcan las acciones de los usuarios reales lo m√°s cerca posible. <br><br><h2>  <font color="#3AC1EF">Herramientas de prueba</font> </h2><br>  Ahora que hemos definido los objetivos que queremos lograr, hablemos sobre las herramientas que hemos elegido para esto. <br><br><h3>  <font color="#3AC1EF">‚ñçTypeScript</font> </h3><br>  Nuestra base de c√≥digo usa TypeScript.  Nuestros servicios de back-end est√°n escritos en Go e interact√∫an entre s√≠ mediante gRPC.  Esto nos permite generar clientes gRPC escritos para usar en un servidor GraphQL.  Los resolvers del servidor GraphQL se escriben usando tipos generados usando <a href="https://github.com/dotansimha/graphql-code-generator">graphql-code-generator</a> .  Y, por √∫ltimo, nuestras consultas, mutaciones, as√≠ como los componentes y ganchos de suscripci√≥n est√°n totalmente escritos.  La cobertura completa de nuestra base de c√≥digo con tipos elimina toda una clase de errores causados ‚Äã‚Äãpor el hecho de que el formulario de datos no es lo que el programador espera.  La generaci√≥n de tipos a partir de los archivos de esquema y protobuf garantiza que todo nuestro sistema, en todas las partes de la pila de tecnolog√≠as utilizadas, permanezca homog√©neo. <br><br><h3>  <font color="#3AC1EF">‚ñçJest (prueba unitaria)</font> </h3><br>  Como marco para probar el c√≥digo, usamos <a href="https://jestjs.io/">Jest</a> y <a href="https://testing-library.com/docs/react-testing-library/intro">@ testing-library / react</a> .  En las pruebas creadas con estas herramientas, probamos funciones o componentes de forma aislada del resto del sistema.  Por lo general, probamos funciones y componentes que se usan con mayor frecuencia en una aplicaci√≥n, o aquellos que tienen muchas formas de ejecutar c√≥digo.  Tales rutas son dif√≠ciles de verificar durante la integraci√≥n o las pruebas de extremo a extremo (E2E). <br><br>  Las pruebas unitarias para nosotros son un medio para probar piezas peque√±as.  Las pruebas integrales y de extremo a extremo hacen un excelente trabajo al verificar el sistema a mayor escala, lo que le permite verificar el nivel general del estado de la aplicaci√≥n.  Pero a veces debe asegurarse de que los peque√±os detalles funcionen, y escribir pruebas de integraci√≥n para todos los usos posibles del c√≥digo es demasiado costoso. <br><br>  Por ejemplo, debemos verificar que la navegaci√≥n del teclado funcione en el componente responsable de trabajar con la lista desplegable.  Pero al mismo tiempo, no querr√≠amos verificar todas las variantes posibles de dicho comportamiento al probar toda la aplicaci√≥n.  Como resultado, probamos exhaustivamente la navegaci√≥n de forma aislada, y cuando probamos p√°ginas usando el componente apropiado, solo prestamos atenci√≥n a verificar las interacciones de nivel superior. <br><br><h2>  <font color="#3AC1EF">Herramientas de prueba</font> </h2><br><h3>  <font color="#3AC1EF">‚ñçCypress (pruebas de integraci√≥n)</font> </h3><br>  Las pruebas de integraci√≥n creadas con <a href="https://www.cypress.io/">Cypress</a> son el n√∫cleo de nuestro sistema de pruebas.  Cuando comenzamos a crear el portal StackPath, estas fueron las primeras pruebas que escribimos, ya que son muy valiosas con muy poca sobrecarga para su creaci√≥n.  Cypress muestra toda nuestra aplicaci√≥n en un navegador y ejecuta scripts de prueba.  Toda nuestra interfaz funciona exactamente de la misma manera que cuando los usuarios trabajan con ella.  Es cierto que la capa de red del sistema se reemplaza por mokami.  Cada consulta de red que normalmente llegar√≠a al servidor GraphQL devuelve datos condicionales a la aplicaci√≥n. <br><br>  El uso de simulacros para simular la capa de red de una aplicaci√≥n tiene muchos puntos fuertes: <br><br><ul><li>  Las pruebas son m√°s r√°pidas.  Incluso si el backend del proyecto es extremadamente r√°pido, el tiempo requerido para devolver las respuestas a las solicitudes realizadas durante todo el conjunto de pruebas puede ser bastante considerable.  Y si Moki es responsable del retorno de las respuestas, las respuestas se devuelven instant√°neamente. </li><li>  Las pruebas se est√°n volviendo m√°s confiables.  Una de las dificultades de realizar pruebas completas de un proyecto es que es necesario tener en cuenta el estado variable de la red y los datos del servidor, que pueden cambiar.  Si se simula el acceso real a la red utilizando moxas, esta variabilidad desaparece. </li><li>  Es f√°cil reproducir situaciones que requieren la repetici√≥n exacta de ciertas condiciones.  Por ejemplo, en un sistema real, ser√° dif√≠cil hacer que ciertas solicitudes fallen de manera estable.  Si necesita verificar la reacci√≥n correcta de la aplicaci√≥n ante solicitudes fallidas, entonces moki le permitir√° reproducir f√°cilmente situaciones de emergencia. </li></ul><br>  Aunque reemplazar todo el backend con mok parece una tarea desalentadora, todos los datos condicionales se escriben usando los mismos tipos de TypeScript generados que se usan en la aplicaci√≥n.  Es decir, esta informaci√≥n, al menos, en t√©rminos de estructura, se garantiza que es equivalente a lo que devolver√≠a un backend normal.  Durante la mayor√≠a de las pruebas, soportamos con bastante tranquilidad las desventajas de usar mooks en lugar de llamadas reales al servidor. <br><br>  Adem√°s, los programadores est√°n muy contentos de trabajar con Cypress.  Las pruebas se ejecutan en el Cypress Test Runner.  Las descripciones de prueba se muestran a la izquierda, y la aplicaci√≥n de prueba se ejecuta en el elemento <code>iframe</code> principal.  Despu√©s de comenzar la prueba, puede estudiar sus etapas individuales y descubrir c√≥mo se comport√≥ la aplicaci√≥n en un momento u otro.  Dado que la herramienta para ejecutar pruebas se ejecuta en el navegador, puede utilizar las herramientas del navegador del desarrollador para depurar las pruebas. <br><br>  Al escribir pruebas de front-end, a menudo sucede que lleva mucho tiempo comparar lo que hace la prueba con el estado del DOM en un cierto punto de la prueba.  Cypress simplifica enormemente esta tarea, ya que el desarrollador puede ver todo lo que sucede con la aplicaci√≥n bajo prueba.  <a href="">Aqu√≠ hay un</a> video clip que demuestra esto. <br><br>  Estas pruebas ilustran perfectamente nuestros principios de prueba.  La relaci√≥n entre su valor y su "precio" nos conviene.  Las pruebas reproducen de manera muy similar las acciones del usuario real que interact√∫a con la aplicaci√≥n.  Y solo la capa de red del proyecto fue reemplazada por mokami. <br><br><h3>  <font color="#3AC1EF">‚ñçCypress (prueba de extremo a extremo)</font> </h3><br>  Nuestras pruebas E2E tambi√©n se escriben usando Cypress, pero en ellas no usamos moki para simular el nivel de red de un proyecto o para simular cualquier otra cosa.  Al realizar pruebas, la aplicaci√≥n accede al servidor GraphQL real, que funciona con instancias reales de servicios de back-end. <br><br>  Las pruebas de extremo a extremo son extremadamente valiosas para nosotros.  El hecho es que son los resultados de tales pruebas los que nos permiten saber si algo funciona como se esperaba o no.  No se utilizan simulacros durante tales pruebas, como resultado, la aplicaci√≥n funciona exactamente de la misma manera que cuando es utilizada por clientes reales.  Sin embargo, debe tenerse en cuenta que las pruebas de extremo a extremo son "m√°s caras" que otras.  Son m√°s lentos, m√°s dif√≠ciles de escribir, dada la posibilidad de fallas a corto plazo durante su implementaci√≥n.  Se requiere m√°s trabajo para garantizar que el sistema permanezca en un estado conocido antes de ejecutar las pruebas. <br><br>  Por lo general, las pruebas deben ejecutarse en un momento en que el sistema se encuentra en alg√∫n estado conocido.  Una vez completada la prueba, el sistema cambia a otro estado conocido.  En el caso de las pruebas de integraci√≥n, no es dif√≠cil lograr este comportamiento del sistema, ya que las llamadas a la API se reemplazan por mokas y, como resultado, cada prueba se ejecuta en condiciones predeterminadas controladas por el programador.  Pero en el caso de las pruebas E2E, ya es m√°s dif√≠cil hacerlo, ya que el almac√©n de datos del servidor contiene informaci√≥n que puede cambiar durante la prueba.  Como resultado, el desarrollador necesita encontrar alguna forma de asegurarse de que cuando comience la prueba, el sistema est√© en un estado previamente conocido. <br><br>  Al comienzo de la ejecuci√≥n de prueba de extremo a extremo, ejecutamos un script que, al realizar llamadas directas a la API, crea una nueva cuenta con pilas, sitios, cargas de trabajo, monitores y similares.  Cada sesi√≥n de prueba implica el uso de una nueva instancia de dicha cuenta, pero todo lo dem√°s de vez en cuando permanece sin cambios.  El script, despu√©s de hacer todo lo necesario, forma un archivo que contiene los datos que se utilizan para ejecutar las pruebas (generalmente contiene informaci√≥n sobre identificadores de instancia y dominios).  Como resultado, resulta que el script le permite llevar el sistema a un estado previamente conocido antes de ejecutar las pruebas. <br><br>  Dado que las pruebas de extremo a extremo son "m√°s caras" que otros tipos de pruebas, nosotros, en comparaci√≥n con las pruebas de integraci√≥n, escribimos menos pruebas de extremo a extremo.  Nos esforzamos por garantizar que las pruebas cubran las caracter√≠sticas cr√≠ticas de la aplicaci√≥n.  Por ejemplo, esto es registrar usuarios y su inicio de sesi√≥n, crear y configurar un sitio / carga de trabajo, etc.  Gracias a las extensas pruebas de integraci√≥n, sabemos que, en general, nuestra interfaz es funcional.  Pero las pruebas de extremo a extremo son necesarias solo para asegurarse de que cuando se conecta la interfaz al backend, no ocurra algo que otras pruebas no puedan detectar. <br><br><h2>  <font color="#3AC1EF">Contras de nuestra estrategia de prueba integral</font> </h2><br>  Aunque estamos muy satisfechos con las pruebas y la estabilidad de la aplicaci√≥n, tambi√©n existen desventajas al usar una estrategia de prueba integral como la nuestra. <br><br>  Para comenzar, la aplicaci√≥n de dicha estrategia de prueba significa que todos los miembros del equipo deben estar familiarizados con muchas herramientas de prueba, y no solo con una.  Todos necesitan saber Jest, @ testing-library / react y Cypress.  Pero al mismo tiempo, los desarrolladores no solo necesitan conocer estas herramientas.  Tambi√©n deben poder tomar decisiones sobre en qu√© situaci√≥n se debe utilizar.  ¬øVale la pena probar alguna nueva oportunidad para escribir una prueba de extremo a extremo, o es suficiente la prueba de integraci√≥n?  ¬øEs necesario, adem√°s de la prueba de extremo a extremo o de integraci√≥n, escribir una prueba unitaria para verificar los peque√±os detalles de la implementaci√≥n de esta nueva caracter√≠stica? <br><br>  Sin lugar a dudas, esto, por as√≠ decirlo, "carga la cabeza" de nuestros programadores, mientras usan la √∫nica herramienta que no experimentar√≠an tal carga.  Por lo general, comenzamos con las pruebas de integraci√≥n, y despu√©s de eso, si vemos que la caracter√≠stica en estudio es de particular importancia y depende en gran medida de la parte del servidor del proyecto, agregamos la prueba de extremo a extremo adecuada.  O comenzamos con pruebas unitarias, haciendo esto si creemos que una prueba unitaria no podr√° verificar todas las sutilezas de implementar un mecanismo determinado. <br><br>  Por supuesto, todav√≠a nos enfrentamos a situaciones en las que no est√° claro por d√≥nde empezar.  Pero, como constantemente tenemos que tomar decisiones con respecto a las pruebas, comienzan a surgir ciertos patrones de situaciones comunes.  Por ejemplo, generalmente probamos sistemas de validaci√≥n de formularios mediante pruebas unitarias.  Esto se hace debido al hecho de que durante la prueba debe verificar muchos escenarios diferentes.  Al mismo tiempo, todos en el equipo lo saben y no pierden el tiempo planeando una estrategia de prueba cuando uno de ellos necesita probar el sistema de validaci√≥n de formularios. <br><br>  Otro inconveniente del enfoque que utilizamos es la complicaci√≥n de recopilar datos sobre la cobertura del c√≥digo mediante pruebas.  Aunque esto es posible, es mucho m√°s complicado que en una situaci√≥n en la que uno se usa para probar un proyecto.  Aunque la b√∫squeda de un n√∫mero hermoso de cobertura de c√≥digo mediante pruebas puede conducir a un deterioro en la calidad de las pruebas, dicha informaci√≥n es valiosa en t√©rminos de encontrar "agujeros" en el conjunto de pruebas utilizado.  El problema de usar varias herramientas de prueba es que, para comprender qu√© parte del c√≥digo no se ha probado, debe combinar informes sobre la cobertura del c√≥digo con las pruebas recibidas de diferentes sistemas.  Es posible, pero definitivamente es mucho m√°s dif√≠cil que leer un informe generado por cualquier medio de prueba. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Cuando utilizamos muchas herramientas de prueba, nos enfrentamos a tareas dif√≠ciles.  Pero cada una de estas herramientas cumple su propio prop√≥sito.  Al final, creemos que hicimos lo correcto al incluirlos en nuestro sistema de prueba de c√≥digo.  Pruebas de integraci√≥n: aqu√≠ es donde es mejor comenzar a crear un sistema de prueba al comienzo del trabajo en una nueva aplicaci√≥n o al equipar pruebas de un proyecto existente.  Ser√° √∫til tratar de agregar pruebas de extremo a extremo al proyecto lo antes posible, verificando las caracter√≠sticas m√°s importantes del proyecto. <br><br>  Cuando hay pruebas integrales y de extremo a extremo en el conjunto de pruebas, esto deber√≠a llevar al hecho de que el desarrollador recibir√° un cierto nivel de confianza en la operatividad de la aplicaci√≥n cuando se realicen cambios.  Si, durante el curso del trabajo en el proyecto, comenzaron a aparecer errores que no son detectados por las pruebas, vale la pena considerar qu√© pruebas podr√≠an detectar estos errores y si la aparici√≥n de errores indica fallas en todo el sistema de prueba utilizado en el proyecto. <br><br>  Por supuesto, no acudimos de inmediato a nuestro sistema de prueba actual.  Adem√°s, esperamos que este sistema, a medida que nuestro proyecto crezca, se desarrolle.  Pero ahora realmente nos gusta nuestro enfoque para las pruebas. <br><br>  <b>Estimados lectores!</b>  ¬øQu√© estrategias sigues en las pruebas frontend?  ¬øQu√© herramientas de prueba frontend usas? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477278/">https://habr.com/ru/post/477278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477266/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 390 (18-24 de noviembre de 2019)</a></li>
<li><a href="../477268/index.html">Optimizaci√≥n de soluciones de b√∫squeda en github</a></li>
<li><a href="../477272/index.html">Primera introducci√≥n a AssemblyScript</a></li>
<li><a href="../477274/index.html">¬øC√≥mo deshacerse del c√≥digo CSS no utilizado? Parte 1</a></li>
<li><a href="../477276/index.html">¬øC√≥mo deshacerse del c√≥digo CSS no utilizado? Parte 2</a></li>
<li><a href="../477282/index.html">Perfilar el c√≥digo del proyecto Go y resolver problemas de asignaci√≥n de memoria</a></li>
<li><a href="../477284/index.html">¬øPor qu√© se requiere JavaScript en modo estricto?</a></li>
<li><a href="../477286/index.html">Axios o Fetch: ¬øqu√© usar en 2019?</a></li>
<li><a href="../477288/index.html">John Lewis en la Conferencia de Deshacer el Envejecimiento 2018</a></li>
<li><a href="../477290/index.html">Eventos digitales en Mosc√∫ del 25 de noviembre al 1 de diciembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>