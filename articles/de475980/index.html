<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋 🧑‍🤝‍🧑 📔 Geringe Konnektivität, Architektur und Teamorganisation 🔘 🤚🏽 🏪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Übersetzung des Artikels wurde speziell für Studenten des Kurses "DevOps Practices and Tools" erstellt . 



 Dieser Artikel beschreibt die Bezieh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geringe Konnektivität, Architektur und Teamorganisation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/475980/">  <i>Die Übersetzung des Artikels wurde speziell für Studenten des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"DevOps Practices and Tools" erstellt</a> .</i> <br><br><img src="https://habrastorage.org/webt/7w/ik/zi/7wikzim_t6aovrjziyxtoiklmta.png"><br><hr><br>  Dieser Artikel beschreibt die Beziehung zwischen Codestruktur und Organisationsstruktur in der Softwareentwicklung.  Ich diskutiere, warum Software und Teams nicht einfach skaliert werden können, welche Lektionen wir in der Natur und im Internet sehen können und wie wir die Konnektivität von Software und Teams reduzieren können, um die Skalierungsprobleme zu überwinden. <br><a name="habracut"></a><br>  Der Artikel basiert auf meiner 20-jährigen Erfahrung mit der Erstellung großer Softwaresysteme und dem Eindruck des Buches <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Accelerate: Die Wissenschaft von Lean Software und DevOps: Aufbau und Skalierung leistungsfähiger Technologieunternehmen“</a> (Nicole Forsgren, Jez Humble und Gene Kim), in dem Nachforschungen belegen die meisten meiner Behauptungen hier.  Dieses Buch ist zum Lesen sehr zu empfehlen. <br><br><img src="https://habrastorage.org/webt/tw/l1/_q/twl1_qravregb6hyfvoyc9uhjpm.jpeg"><br><br><h3>  Software und Befehle skalieren nicht </h3><br>  Oft ist die erste Veröffentlichung, die vielleicht von ein oder zwei Leuten geschrieben wurde, überraschend einfach.  Es hat möglicherweise eingeschränkte Funktionen, ist jedoch schnell geschrieben und entspricht den Kundenanforderungen.  Die Interaktion mit dem Kunden ist zu diesem Zeitpunkt hervorragend, da der Kunde in der Regel in direktem Kontakt mit den Entwicklern steht.  Alle Fehler werden schnell behoben und neue Funktionen können problemlos hinzugefügt werden.  Nach einer Weile verlangsamt sich das Tempo.  Version 2.0 dauert etwas länger als erwartet.  Es ist schwieriger, Fehler zu beheben, und es gibt neue Funktionen, es ist nicht so einfach.  Die natürliche Antwort darauf ist das Hinzufügen neuer Entwickler zum Team.  Obwohl es so aussieht, als würde jeder zusätzliche Mitarbeiter die Produktivität verringern.  Es besteht das Gefühl, dass die Software mit zunehmender Komplexität verkümmert.  In extremen Fällen stellen Unternehmen möglicherweise fest, dass sie Programme mit sehr kostspieligem Support verwenden, bei denen es fast unmöglich ist, Änderungen vorzunehmen.  Das Problem ist, dass Sie keine „Fehler“ machen müssen, um dies zu erreichen.  Es ist so verbreitet, dass man sagen kann, dass dies eine „natürliche“ Eigenschaft von Software ist. <br><br>  Warum passiert das?  Es gibt zwei Gründe: die im Zusammenhang mit dem Code und dem Team.  Sowohl Code als auch Befehle lassen sich nicht gut skalieren. <br><br>  Wenn die Codebasis wächst, wird es für eine Person immer schwieriger, sie zu verstehen.  Es gibt feste kognitive Grenzen einer Person.  Und zwar kann sich eine Person die Details eines kleinen Systems merken, aber nur, bis es mehr als seinen kognitiven Bereich erreicht.  Sobald ein Team auf fünf oder mehr Personen angewachsen ist, ist es für eine Person fast unmöglich, sich darüber im Klaren zu sein, wie alle Teile des Systems funktionieren.  Und wenn niemand das ganze System versteht, taucht Angst auf.  In einem großen, eng gekoppelten System ist es sehr schwierig, die Auswirkung von signifikanten Änderungen zu verstehen, da das Ergebnis nicht lokalisiert ist.  Um die Auswirkungen von Änderungen zu minimieren, beginnen Entwickler, Problemumgehungen und Codeduplizierungen zu verwenden, anstatt gemeinsame Features zu identifizieren und Abstraktionen und Generalisierungen zu erstellen.  Dies kompliziert das System weiter und verstärkt diese negativen Trends.  Entwickler fühlen sich nicht länger für Code verantwortlich, den sie nicht verstehen und nicht gerne überarbeiten.  Die technische Verschuldung wächst.  Es macht auch die Arbeit unangenehm und unbefriedigend und stimuliert einen „Talentabfluss“, wenn die besten Entwickler abreisen, die leicht Arbeit an anderer Stelle finden können. <br><br>  Teams skalieren auch nicht.  Wenn die Teams wachsen, wird die Kommunikation komplexer.  Eine einfache Formel kommt ins Spiel: <br><br> <code>c = n(n-1)/2</code> <br> <br>  <i>(wobei n die Anzahl der Personen und c die Anzahl der möglichen Verbindungen zwischen Teammitgliedern ist)</i> <br><br><div class="scrollable-table"><table><tbody><tr><td>  Anzahl der Teammitglieder </td><td>  Anzahl der möglichen Verbindungen </td></tr><tr><td>  1 </td><td>  0 </td></tr><tr><td>  2 </td><td>  1 </td></tr><tr><td>  5 </td><td>  10 </td></tr><tr><td>  10 </td><td>  45 </td></tr><tr><td>  100 </td><td>  4950 </td></tr></tbody></table></div><br><br>  Mit dem Wachstum ihres Teams wächst ihr Bedarf an Kommunikation und Koordination exponentiell.  Wenn ein bestimmtes Team überschritten wird, ist es für ein Team sehr schwierig, eine integrale Struktur zu bleiben, und die natürliche menschliche soziale Tendenz, sich in kleinere Gruppen aufzuteilen, führt zur Bildung informeller Untergruppen, auch wenn das Management nicht daran teilnimmt.  Die Kommunikation mit Kollegen wird schwieriger und wird natürlich durch neue Führungskräfte und Top-Down-Kommunikation ersetzt.  Teammitglieder werden von Kollegen im System zu regulären Produktionsmitarbeitern.  Die Motivation leidet, es gibt kein Gefühl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Eigenverantwortung</a> aufgrund des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Effekts der Verantwortungsdiffusion</a> . <br><br>  Das Management greift in dieser Phase häufig ein und nähert sich formell der Schaffung neuer Teams und Managementstrukturen.  Es ist jedoch weder formal noch informell von Bedeutung, dass es für große Unternehmen schwierig ist, Motivation und Interesse aufrechtzuerhalten. <br><br>  Normalerweise geben unerfahrene Entwickler und schlechtes Management diesen Skalierungspathologien die Schuld.  Das ist aber unfair.  Skalierungsprobleme sind eine „natürliche“ Eigenschaft wachsender und sich entwickelnder Software.  Dies geschieht immer dann, wenn Sie das Problem nicht in einem frühen Stadium finden, den Abweichungspunkt nicht verstehen und keine Anstrengungen unternehmen, um das Problem zu lösen.  Softwareentwicklungsteams werden ständig zusammengestellt, die Menge an Software in der Welt wächst ständig und der größte Teil der Software ist relativ klein.  Daher wird ein erfolgreiches und sich entwickelndes Produkt häufig von einem Team erstellt, das keine Erfahrung in der Entwicklung in großem Maßstab hat.  Und es ist unrealistisch, von Entwicklern zu erwarten, dass sie den Wendepunkt erkennen und verstehen, was zu tun ist, wenn sich Skalenprobleme manifestieren. <br><br><h3>  Nature Scaling-Lektionen </h3><br>  Ich habe kürzlich das ausgezeichnete Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Scale“ von Geoffrey West</a> gelesen.  Es geht um die Skalenmathematik in biologischen und sozioökonomischen Systemen.  Seine These ist, dass alle großen komplexen Systeme den grundlegenden Skalengesetzen gehorchen.  Dies ist eine faszinierende Lektüre, die ich sehr empfehlen kann.  In diesem Artikel möchte ich mich auf seine Sichtweise konzentrieren, dass viele biologische und soziale Systeme überraschend gut skalieren.  Schauen Sie sich den Körper eines Säugetiers an.  Alle Säugetiere haben die gleichen Zelltypen, Knochenstrukturen, Nerven- und Kreislaufsysteme.  Der Größenunterschied zwischen Maus und Blauwal beträgt jedoch ca. 10 ^ 7.  Wie nutzt die Natur die gleichen Materialien und Strukturen für Organismen unterschiedlichster Größe?  Die Antwort scheint zu sein, dass die Evolution fraktal verzweigte Strukturen entdeckt hat.  Schau dir den Baum an.  Jeder Teil davon sieht aus wie ein kleiner Baum.  Das gleiche gilt für das Kreislauf- und Nervensystem von Säugetieren. Es handelt sich um verzweigte fraktale Netzwerke, in denen ein kleiner Teil Ihrer Lunge oder Blutgefäße wie eine kleinere Version des Ganzen aussieht. <br><br><img src="https://habrastorage.org/webt/fn/h8/fh/fnh8fhg3914dqtibtecvi6fvn8k.jpeg"><br><br>  Können wir diese Ideen aus der Natur übernehmen und auf Software anwenden?  Ich denke, wir können wichtige Lektionen lernen.  Wenn wir große Systeme bauen können, die aus kleinen Teilen bestehen, die selbst wie komplette Systeme aussehen, können wir die Pathologien enthalten, die die meisten Programme betreffen, wenn sie wachsen und sich entwickeln. <br><br>  Gibt es Softwaresysteme, die sich erfolgreich um mehrere Größenordnungen skalieren lassen?  Die Antwort liegt auf der Hand - das Internet, ein globales Softwaresystem mit Millionen von Knoten.  Subnetze sehen wirklich aus und funktionieren wie kleinere Versionen des gesamten Internets. <br><br><h3>  Anzeichen für lose gekoppelte Software </h3><br>  Die Fähigkeit, separate, lose gekoppelte Komponenten in einem großen System zu isolieren, ist die Hauptmethode für eine erfolgreiche Skalierung.  Das Internet ist in der Tat ein Beispiel für eine lose gekoppelte Architektur.  Dies bedeutet, dass jeder Knoten, Dienst oder jede Anwendung im Netzwerk die folgenden Eigenschaften aufweist: <br><br><ul><li>  Es wird ein gemeinsames Kommunikationsprotokoll verwendet. </li><li>  Die Datenübertragung erfolgt über einen eindeutigen Vertrag mit anderen Knoten. </li><li>  Für die Kommunikation sind keine Kenntnisse über bestimmte Implementierungstechnologien erforderlich. </li><li>  Versionierung und Bereitstellung sind unabhängig. </li></ul><br>  Das Internet ist skalierbar, da es sich um ein Netzwerk von Knoten handelt, die über eine Reihe klar definierter Protokolle kommunizieren.  Knoten interagieren nur über Protokolle, deren Implementierungsdetails den interagierenden Knoten nicht bekannt sein sollten.  Das globale Internet wird nicht als einzelnes System bereitgestellt.  Jeder Knoten verfügt über eine eigene Version und ein eigenes Bereitstellungsverfahren.  Einzelne Knoten erscheinen und verschwinden unabhängig voneinander.  Die Übermittlung an Internet-Protokolle ist das einzige, was für das gesamte System wirklich wichtig ist.  Wer jeden Knoten erstellt hat, wann er erstellt oder gelöscht wurde, welche Version er hat, welche spezifischen Technologien und Plattformen er verwendet, all dies hat nichts mit dem Internet als Ganzes zu tun.  Das ist es, was wir unter lose gekoppelter Software verstehen. <br><br><h3>  Zeichen einer locker gekoppelten Organisation </h3><br>  Wir können Teams nach denselben Prinzipien skalieren: <br><br><ul><li>  Jedes Subteam sollte wie eine kleine Softwareentwicklungsorganisation aussehen. </li><li>  Interne Prozesse und Teamkommunikation sollten nicht über das Team hinausgehen. </li><li>  Die zur Implementierung der Software verwendeten Technologien und Prozesse sollten nicht außerhalb des Teams diskutiert werden. </li><li>  Teams sollten nur über externe Themen miteinander kommunizieren: gemeinsame Protokolle, Funktionen, Service-Levels und Ressourcen. </li></ul><br>  Kleine Entwicklungsteams sind effektiver als große. Sie müssen daher große Teams in kleinere Gruppen aufteilen.  Die Lektionen der Natur und des Internets besagen, dass Untergruppen wie einzelne kleine Softwareentwicklungsorganisationen aussehen sollten.  Wie klein sind sie  Idealerweise von ein bis fünf Personen. <br><br>  Wichtig ist, dass jedes Team wie eine kleine unabhängige Softwareentwicklungsorganisation aussieht.  Andere Arten, Teams zu organisieren, sind weniger effektiv.  Oft besteht die Versuchung, ein großes Team in Funktionen zu unterteilen.  Aus diesem Grund verfügen wir über ein Architektenteam, ein Entwicklungsteam, ein DBA-Team, ein Testerteam, ein Bereitstellungsteam und ein Supportteam. Dies löst jedoch keines der oben genannten Skalierungsprobleme.  Alle Teams sollten an der Entwicklung eines Features teilnehmen und häufig iterativ, wenn Sie Projektmanagement im Stil eines Wasserfalls vermeiden möchten. <br><br>  Kommunikationsbarrieren zwischen diesen Funktionsteams werden zu einem Haupthindernis für eine effiziente und rechtzeitige Bereitstellung.  Teams sind eng miteinander verbunden, da sie wichtige interne Details austauschen müssen, um zusammenzuarbeiten.  Darüber hinaus stimmen die Interessen verschiedener Teams nicht überein: Entwickler erhalten in der Regel eine Auszeichnung für neue Funktionen, Tester für Qualität und Unterstützung für Stabilität.  Diese unterschiedlichen Interessen können zu Konflikten und schlechten Ergebnissen führen.  Warum sollten sich Entwickler um Protokolle sorgen, wenn sie diese nie lesen?  Warum sollten sich Tester um die Lieferung kümmern, wenn sie für die Qualität verantwortlich sind? <br><br>  Stattdessen sollten wir Teams für lose gekoppelte Services organisieren, die Geschäftsfunktionen unterstützen, oder für eine logische Gruppe von Funktionen.  Jeder Unterbefehl sollte seine eigene Software entwerfen, codieren, testen, bereitstellen und warten.  Höchstwahrscheinlich sind die Mitglieder eines solchen Teams Spezialisten mit einem breiten Profil und keine engen Spezialisten, da es in einem kleinen Team erforderlich sein wird, diese Rollen zu trennen.  Sie sollten sich auf die maximal mögliche Automatisierung von Prozessen konzentrieren: automatisiertes Testen, Bereitstellen, Überwachen.  Teams müssen ihre eigenen Tools auswählen und die Architektur für ihre Systeme entwerfen.  Obwohl die für die Interaktion von Diensten verwendeten Protokolle auf Organisationsebene festgelegt werden sollten, sollte die Auswahl der zu ihrer Implementierung verwendeten Tools an die Teams delegiert werden.  Und das passt sehr gut zum DevOps-Modell. <br><br>  Der Grad der Unabhängigkeit eines Teams spiegelt den Grad der Verbundenheit der gesamten Organisation wider.  Im Idealfall sollte sich die Organisation um die Funktionalität der Software und letztendlich den geschäftlichen Nutzen des Teams sowie die Kosten für die Teamressourcen kümmern. <br><br>  In diesem Fall spielt der Softwarearchitekt eine wichtige Rolle.  Es sollte sich nicht auf bestimmte Tools und Technologien konzentrieren, die von Teams verwendet werden, oder die Details der internen Architektur von Diensten beeinträchtigen.  Stattdessen sollte der Schwerpunkt auf Protokollen und Interaktionen zwischen verschiedenen Diensten und dem Zustand des gesamten Systems liegen. <br><br><h3>  Conways umgekehrtes Gesetz: Die Organisationsstruktur muss die Zielarchitektur modellieren </h3><br>  Wie passen schwache Softwarekohärenz und schwache Teamkohärenz zusammen?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Conways Gesetz</a> besagt: <br><blockquote>  <i>"Organisationen, die Systeme entwerfen, sind auf ein Design beschränkt, das die Kommunikationsstruktur dieser Organisation kopiert."</i> </blockquote><br>  Dies basiert auf der Beobachtung, dass die Architektur eines Softwaresystems die Struktur der Organisation widerspiegelt, die es erstellt.  Wir können Conways Gesetz "hacken", indem wir es umdrehen.  Organisieren Sie unsere Teams, um die gewünschte Architektur widerzuspiegeln.  In diesem Sinne müssen wir lose gekoppelte Teams mit lose gekoppelten Softwarekomponenten ausrichten.  Aber sollte es eine Eins-zu-Eins-Beziehung sein?  Ich denke im Idealfall ja.  Obwohl es gut zu sein scheint, wenn ein kleines Team an mehreren lose gekoppelten Diensten arbeitet.  Ich würde sagen, dass der Wendepunkt für die Skalierung für Teams größer ist als für Software, so dass dieser Organisationsstil akzeptabel erscheint.  Es ist wichtig, dass die Softwarekomponenten mit ihrer eigenen Versionierung und Bereitstellung getrennt bleiben, auch wenn einige von ihnen von einem Team entwickelt werden.  Wir möchten in der Lage sein, das Team zu teilen, wenn es zu groß wird, indem wir entwickelte Dienste auf verschiedene Teams übertragen.  Dies ist jedoch nicht möglich, wenn die Dienste eng miteinander verbunden sind oder einen Prozess, eine Versionierung oder eine Bereitstellung gemeinsam nutzen. <br><br>  Wir müssen die Arbeit mehrerer Teams an denselben Komponenten vermeiden.  Dies ist ein Anti-Muster.  In gewisser Hinsicht sogar noch schlimmer als die Arbeit eines großen Teams mit einer großen Codebasis, da Kommunikationsbarrieren zwischen Teams zu einem noch stärkeren Gefühl von mangelnder Eigenverantwortung und Kontrolle führen. <br><br><img src="https://habrastorage.org/webt/mj/z9/nl/mjz9nlpipokz7va4jnxhkeoygfk.png"><br><br>  Die Interaktion zwischen lose gekoppelten Teams, die lose gekoppelte Software erstellen, wird minimiert.  Nehmen Sie noch einmal das Internet-Beispiel.  Häufig können Sie die von einem anderen Unternehmen bereitgestellte API verwenden, ohne direkt damit zu kommunizieren (wenn der Vorgang einfach ist und Dokumentation vorhanden ist).  Wenn Teams interagieren, sollten interne Teamentwicklungs- und Implementierungsprozesse nicht diskutiert werden.  Stattdessen sollten Funktionalität, Servicelevel und Ressourcen erörtert werden. <br><br>  Die Verwaltung lose verbundener Teams, die lose verbundene Software erstellen, sollte einfacher sein als Alternativen.  Eine große Organisation sollte sich darauf konzentrieren, Teams klare Ziele und Anforderungen in Bezug auf Funktionalität und Servicelevel zu liefern.  Die Ressourcenanforderungen sollten vom Team stammen, obwohl sie von der Organisation verwendet werden können, um die Kapitalrendite zu messen. <br><br><h3>  Locker gekoppelte Teams entwickeln locker gekoppelte Software </h3><br>  Eine schwache Konnektivität in der Software und zwischen den Teams ist der Schlüssel zum Aufbau einer hocheffektiven Organisation.  Und meine Erfahrung bestätigt diesen Punkt.  Ich habe in Organisationen gearbeitet, in denen die Teams nach Funktionen, nach Software-Ebene oder sogar nach Kunden getrennt waren.  Ich habe auch in großen chaotischen Teams auf einer einzigen Codebasis gearbeitet.  In all diesen Fällen gab es jedoch Probleme mit der Skalierung, die oben erwähnt wurden.  Die angenehmste Erfahrung war immer, als mein Team eine vollwertige Einheit war, die unabhängig mit der Erstellung, Prüfung und Bereitstellung unabhängiger Dienste befasst war.  Aber Sie müssen sich nicht auf meine Lebensgeschichten verlassen.  Accelerate (oben beschrieben) hat Forschungsergebnisse, die diese Ansicht stützen. <br><br>  <i><b>Wenn Sie dieses Material bis zum Ende gelesen haben, empfehlen wir Ihnen, sich eine Aufzeichnung eines offenen Webinars zum Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Ein Tag im Leben von DevOps“</a> anzusehen.</b></i> <i><br></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475980/">https://habr.com/ru/post/de475980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475958/index.html">Die Geschichte, wie sich das Mädchen in der IT versammelt hat</a></li>
<li><a href="../de475960/index.html">AHURATUS Smart Home Sprachassistent</a></li>
<li><a href="../de475968/index.html">Interessante Neuigkeiten Vue 3</a></li>
<li><a href="../de475974/index.html">Wie wir im Zug einen Hackathon machten und was daraus wurde</a></li>
<li><a href="../de475978/index.html">Wofür ist das Hauptquartier des Zuges?</a></li>
<li><a href="../de475982/index.html">Wie lerne ich eine Fremdsprache?</a></li>
<li><a href="../de475986/index.html">PocketBook 740 Pro Reader Übersicht: 7,8 Zoll, Audio- und IPX8-Schutz</a></li>
<li><a href="../de475988/index.html">ML.NET Model Builder-Aktualisierungen</a></li>
<li><a href="../de475990/index.html">Erstellen moderner Cloud-Anwendungen mit Pulumi und .NET Core</a></li>
<li><a href="../de475992/index.html">Schreiben eines VLC-Plugins zum Erlernen der englischen Sprache</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>