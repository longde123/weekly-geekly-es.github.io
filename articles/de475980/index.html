<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëã üßë‚Äçü§ù‚Äçüßë üìî Geringe Konnektivit√§t, Architektur und Teamorganisation üîò ü§öüèΩ üè™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die √úbersetzung des Artikels wurde speziell f√ºr Studenten des Kurses "DevOps Practices and Tools" erstellt . 



 Dieser Artikel beschreibt die Bezieh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geringe Konnektivit√§t, Architektur und Teamorganisation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/475980/">  <i>Die √úbersetzung des Artikels wurde speziell f√ºr Studenten des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"DevOps Practices and Tools" erstellt</a> .</i> <br><br><img src="https://habrastorage.org/webt/7w/ik/zi/7wikzim_t6aovrjziyxtoiklmta.png"><br><hr><br>  Dieser Artikel beschreibt die Beziehung zwischen Codestruktur und Organisationsstruktur in der Softwareentwicklung.  Ich diskutiere, warum Software und Teams nicht einfach skaliert werden k√∂nnen, welche Lektionen wir in der Natur und im Internet sehen k√∂nnen und wie wir die Konnektivit√§t von Software und Teams reduzieren k√∂nnen, um die Skalierungsprobleme zu √ºberwinden. <br><a name="habracut"></a><br>  Der Artikel basiert auf meiner 20-j√§hrigen Erfahrung mit der Erstellung gro√üer Softwaresysteme und dem Eindruck des Buches <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûAccelerate: Die Wissenschaft von Lean Software und DevOps: Aufbau und Skalierung leistungsf√§higer Technologieunternehmen‚Äú</a> (Nicole Forsgren, Jez Humble und Gene Kim), in dem Nachforschungen belegen die meisten meiner Behauptungen hier.  Dieses Buch ist zum Lesen sehr zu empfehlen. <br><br><img src="https://habrastorage.org/webt/tw/l1/_q/twl1_qravregb6hyfvoyc9uhjpm.jpeg"><br><br><h3>  Software und Befehle skalieren nicht </h3><br>  Oft ist die erste Ver√∂ffentlichung, die vielleicht von ein oder zwei Leuten geschrieben wurde, √ºberraschend einfach.  Es hat m√∂glicherweise eingeschr√§nkte Funktionen, ist jedoch schnell geschrieben und entspricht den Kundenanforderungen.  Die Interaktion mit dem Kunden ist zu diesem Zeitpunkt hervorragend, da der Kunde in der Regel in direktem Kontakt mit den Entwicklern steht.  Alle Fehler werden schnell behoben und neue Funktionen k√∂nnen problemlos hinzugef√ºgt werden.  Nach einer Weile verlangsamt sich das Tempo.  Version 2.0 dauert etwas l√§nger als erwartet.  Es ist schwieriger, Fehler zu beheben, und es gibt neue Funktionen, es ist nicht so einfach.  Die nat√ºrliche Antwort darauf ist das Hinzuf√ºgen neuer Entwickler zum Team.  Obwohl es so aussieht, als w√ºrde jeder zus√§tzliche Mitarbeiter die Produktivit√§t verringern.  Es besteht das Gef√ºhl, dass die Software mit zunehmender Komplexit√§t verk√ºmmert.  In extremen F√§llen stellen Unternehmen m√∂glicherweise fest, dass sie Programme mit sehr kostspieligem Support verwenden, bei denen es fast unm√∂glich ist, √Ñnderungen vorzunehmen.  Das Problem ist, dass Sie keine ‚ÄûFehler‚Äú machen m√ºssen, um dies zu erreichen.  Es ist so verbreitet, dass man sagen kann, dass dies eine ‚Äûnat√ºrliche‚Äú Eigenschaft von Software ist. <br><br>  Warum passiert das?  Es gibt zwei Gr√ºnde: die im Zusammenhang mit dem Code und dem Team.  Sowohl Code als auch Befehle lassen sich nicht gut skalieren. <br><br>  Wenn die Codebasis w√§chst, wird es f√ºr eine Person immer schwieriger, sie zu verstehen.  Es gibt feste kognitive Grenzen einer Person.  Und zwar kann sich eine Person die Details eines kleinen Systems merken, aber nur, bis es mehr als seinen kognitiven Bereich erreicht.  Sobald ein Team auf f√ºnf oder mehr Personen angewachsen ist, ist es f√ºr eine Person fast unm√∂glich, sich dar√ºber im Klaren zu sein, wie alle Teile des Systems funktionieren.  Und wenn niemand das ganze System versteht, taucht Angst auf.  In einem gro√üen, eng gekoppelten System ist es sehr schwierig, die Auswirkung von signifikanten √Ñnderungen zu verstehen, da das Ergebnis nicht lokalisiert ist.  Um die Auswirkungen von √Ñnderungen zu minimieren, beginnen Entwickler, Problemumgehungen und Codeduplizierungen zu verwenden, anstatt gemeinsame Features zu identifizieren und Abstraktionen und Generalisierungen zu erstellen.  Dies kompliziert das System weiter und verst√§rkt diese negativen Trends.  Entwickler f√ºhlen sich nicht l√§nger f√ºr Code verantwortlich, den sie nicht verstehen und nicht gerne √ºberarbeiten.  Die technische Verschuldung w√§chst.  Es macht auch die Arbeit unangenehm und unbefriedigend und stimuliert einen ‚ÄûTalentabfluss‚Äú, wenn die besten Entwickler abreisen, die leicht Arbeit an anderer Stelle finden k√∂nnen. <br><br>  Teams skalieren auch nicht.  Wenn die Teams wachsen, wird die Kommunikation komplexer.  Eine einfache Formel kommt ins Spiel: <br><br> <code>c = n(n-1)/2</code> <br> <br>  <i>(wobei n die Anzahl der Personen und c die Anzahl der m√∂glichen Verbindungen zwischen Teammitgliedern ist)</i> <br><br><div class="scrollable-table"><table><tbody><tr><td>  Anzahl der Teammitglieder </td><td>  Anzahl der m√∂glichen Verbindungen </td></tr><tr><td>  1 </td><td>  0 </td></tr><tr><td>  2 </td><td>  1 </td></tr><tr><td>  5 </td><td>  10 </td></tr><tr><td>  10 </td><td>  45 </td></tr><tr><td>  100 </td><td>  4950 </td></tr></tbody></table></div><br><br>  Mit dem Wachstum ihres Teams w√§chst ihr Bedarf an Kommunikation und Koordination exponentiell.  Wenn ein bestimmtes Team √ºberschritten wird, ist es f√ºr ein Team sehr schwierig, eine integrale Struktur zu bleiben, und die nat√ºrliche menschliche soziale Tendenz, sich in kleinere Gruppen aufzuteilen, f√ºhrt zur Bildung informeller Untergruppen, auch wenn das Management nicht daran teilnimmt.  Die Kommunikation mit Kollegen wird schwieriger und wird nat√ºrlich durch neue F√ºhrungskr√§fte und Top-Down-Kommunikation ersetzt.  Teammitglieder werden von Kollegen im System zu regul√§ren Produktionsmitarbeitern.  Die Motivation leidet, es gibt kein Gef√ºhl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Eigenverantwortung</a> aufgrund des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Effekts der Verantwortungsdiffusion</a> . <br><br>  Das Management greift in dieser Phase h√§ufig ein und n√§hert sich formell der Schaffung neuer Teams und Managementstrukturen.  Es ist jedoch weder formal noch informell von Bedeutung, dass es f√ºr gro√üe Unternehmen schwierig ist, Motivation und Interesse aufrechtzuerhalten. <br><br>  Normalerweise geben unerfahrene Entwickler und schlechtes Management diesen Skalierungspathologien die Schuld.  Das ist aber unfair.  Skalierungsprobleme sind eine ‚Äûnat√ºrliche‚Äú Eigenschaft wachsender und sich entwickelnder Software.  Dies geschieht immer dann, wenn Sie das Problem nicht in einem fr√ºhen Stadium finden, den Abweichungspunkt nicht verstehen und keine Anstrengungen unternehmen, um das Problem zu l√∂sen.  Softwareentwicklungsteams werden st√§ndig zusammengestellt, die Menge an Software in der Welt w√§chst st√§ndig und der gr√∂√üte Teil der Software ist relativ klein.  Daher wird ein erfolgreiches und sich entwickelndes Produkt h√§ufig von einem Team erstellt, das keine Erfahrung in der Entwicklung in gro√üem Ma√üstab hat.  Und es ist unrealistisch, von Entwicklern zu erwarten, dass sie den Wendepunkt erkennen und verstehen, was zu tun ist, wenn sich Skalenprobleme manifestieren. <br><br><h3>  Nature Scaling-Lektionen </h3><br>  Ich habe k√ºrzlich das ausgezeichnete Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûScale‚Äú von Geoffrey West</a> gelesen.  Es geht um die Skalenmathematik in biologischen und sozio√∂konomischen Systemen.  Seine These ist, dass alle gro√üen komplexen Systeme den grundlegenden Skalengesetzen gehorchen.  Dies ist eine faszinierende Lekt√ºre, die ich sehr empfehlen kann.  In diesem Artikel m√∂chte ich mich auf seine Sichtweise konzentrieren, dass viele biologische und soziale Systeme √ºberraschend gut skalieren.  Schauen Sie sich den K√∂rper eines S√§ugetiers an.  Alle S√§ugetiere haben die gleichen Zelltypen, Knochenstrukturen, Nerven- und Kreislaufsysteme.  Der Gr√∂√üenunterschied zwischen Maus und Blauwal betr√§gt jedoch ca. 10 ^ 7.  Wie nutzt die Natur die gleichen Materialien und Strukturen f√ºr Organismen unterschiedlichster Gr√∂√üe?  Die Antwort scheint zu sein, dass die Evolution fraktal verzweigte Strukturen entdeckt hat.  Schau dir den Baum an.  Jeder Teil davon sieht aus wie ein kleiner Baum.  Das gleiche gilt f√ºr das Kreislauf- und Nervensystem von S√§ugetieren. Es handelt sich um verzweigte fraktale Netzwerke, in denen ein kleiner Teil Ihrer Lunge oder Blutgef√§√üe wie eine kleinere Version des Ganzen aussieht. <br><br><img src="https://habrastorage.org/webt/fn/h8/fh/fnh8fhg3914dqtibtecvi6fvn8k.jpeg"><br><br>  K√∂nnen wir diese Ideen aus der Natur √ºbernehmen und auf Software anwenden?  Ich denke, wir k√∂nnen wichtige Lektionen lernen.  Wenn wir gro√üe Systeme bauen k√∂nnen, die aus kleinen Teilen bestehen, die selbst wie komplette Systeme aussehen, k√∂nnen wir die Pathologien enthalten, die die meisten Programme betreffen, wenn sie wachsen und sich entwickeln. <br><br>  Gibt es Softwaresysteme, die sich erfolgreich um mehrere Gr√∂√üenordnungen skalieren lassen?  Die Antwort liegt auf der Hand - das Internet, ein globales Softwaresystem mit Millionen von Knoten.  Subnetze sehen wirklich aus und funktionieren wie kleinere Versionen des gesamten Internets. <br><br><h3>  Anzeichen f√ºr lose gekoppelte Software </h3><br>  Die F√§higkeit, separate, lose gekoppelte Komponenten in einem gro√üen System zu isolieren, ist die Hauptmethode f√ºr eine erfolgreiche Skalierung.  Das Internet ist in der Tat ein Beispiel f√ºr eine lose gekoppelte Architektur.  Dies bedeutet, dass jeder Knoten, Dienst oder jede Anwendung im Netzwerk die folgenden Eigenschaften aufweist: <br><br><ul><li>  Es wird ein gemeinsames Kommunikationsprotokoll verwendet. </li><li>  Die Daten√ºbertragung erfolgt √ºber einen eindeutigen Vertrag mit anderen Knoten. </li><li>  F√ºr die Kommunikation sind keine Kenntnisse √ºber bestimmte Implementierungstechnologien erforderlich. </li><li>  Versionierung und Bereitstellung sind unabh√§ngig. </li></ul><br>  Das Internet ist skalierbar, da es sich um ein Netzwerk von Knoten handelt, die √ºber eine Reihe klar definierter Protokolle kommunizieren.  Knoten interagieren nur √ºber Protokolle, deren Implementierungsdetails den interagierenden Knoten nicht bekannt sein sollten.  Das globale Internet wird nicht als einzelnes System bereitgestellt.  Jeder Knoten verf√ºgt √ºber eine eigene Version und ein eigenes Bereitstellungsverfahren.  Einzelne Knoten erscheinen und verschwinden unabh√§ngig voneinander.  Die √úbermittlung an Internet-Protokolle ist das einzige, was f√ºr das gesamte System wirklich wichtig ist.  Wer jeden Knoten erstellt hat, wann er erstellt oder gel√∂scht wurde, welche Version er hat, welche spezifischen Technologien und Plattformen er verwendet, all dies hat nichts mit dem Internet als Ganzes zu tun.  Das ist es, was wir unter lose gekoppelter Software verstehen. <br><br><h3>  Zeichen einer locker gekoppelten Organisation </h3><br>  Wir k√∂nnen Teams nach denselben Prinzipien skalieren: <br><br><ul><li>  Jedes Subteam sollte wie eine kleine Softwareentwicklungsorganisation aussehen. </li><li>  Interne Prozesse und Teamkommunikation sollten nicht √ºber das Team hinausgehen. </li><li>  Die zur Implementierung der Software verwendeten Technologien und Prozesse sollten nicht au√üerhalb des Teams diskutiert werden. </li><li>  Teams sollten nur √ºber externe Themen miteinander kommunizieren: gemeinsame Protokolle, Funktionen, Service-Levels und Ressourcen. </li></ul><br>  Kleine Entwicklungsteams sind effektiver als gro√üe. Sie m√ºssen daher gro√üe Teams in kleinere Gruppen aufteilen.  Die Lektionen der Natur und des Internets besagen, dass Untergruppen wie einzelne kleine Softwareentwicklungsorganisationen aussehen sollten.  Wie klein sind sie  Idealerweise von ein bis f√ºnf Personen. <br><br>  Wichtig ist, dass jedes Team wie eine kleine unabh√§ngige Softwareentwicklungsorganisation aussieht.  Andere Arten, Teams zu organisieren, sind weniger effektiv.  Oft besteht die Versuchung, ein gro√ües Team in Funktionen zu unterteilen.  Aus diesem Grund verf√ºgen wir √ºber ein Architektenteam, ein Entwicklungsteam, ein DBA-Team, ein Testerteam, ein Bereitstellungsteam und ein Supportteam. Dies l√∂st jedoch keines der oben genannten Skalierungsprobleme.  Alle Teams sollten an der Entwicklung eines Features teilnehmen und h√§ufig iterativ, wenn Sie Projektmanagement im Stil eines Wasserfalls vermeiden m√∂chten. <br><br>  Kommunikationsbarrieren zwischen diesen Funktionsteams werden zu einem Haupthindernis f√ºr eine effiziente und rechtzeitige Bereitstellung.  Teams sind eng miteinander verbunden, da sie wichtige interne Details austauschen m√ºssen, um zusammenzuarbeiten.  Dar√ºber hinaus stimmen die Interessen verschiedener Teams nicht √ºberein: Entwickler erhalten in der Regel eine Auszeichnung f√ºr neue Funktionen, Tester f√ºr Qualit√§t und Unterst√ºtzung f√ºr Stabilit√§t.  Diese unterschiedlichen Interessen k√∂nnen zu Konflikten und schlechten Ergebnissen f√ºhren.  Warum sollten sich Entwickler um Protokolle sorgen, wenn sie diese nie lesen?  Warum sollten sich Tester um die Lieferung k√ºmmern, wenn sie f√ºr die Qualit√§t verantwortlich sind? <br><br>  Stattdessen sollten wir Teams f√ºr lose gekoppelte Services organisieren, die Gesch√§ftsfunktionen unterst√ºtzen, oder f√ºr eine logische Gruppe von Funktionen.  Jeder Unterbefehl sollte seine eigene Software entwerfen, codieren, testen, bereitstellen und warten.  H√∂chstwahrscheinlich sind die Mitglieder eines solchen Teams Spezialisten mit einem breiten Profil und keine engen Spezialisten, da es in einem kleinen Team erforderlich sein wird, diese Rollen zu trennen.  Sie sollten sich auf die maximal m√∂gliche Automatisierung von Prozessen konzentrieren: automatisiertes Testen, Bereitstellen, √úberwachen.  Teams m√ºssen ihre eigenen Tools ausw√§hlen und die Architektur f√ºr ihre Systeme entwerfen.  Obwohl die f√ºr die Interaktion von Diensten verwendeten Protokolle auf Organisationsebene festgelegt werden sollten, sollte die Auswahl der zu ihrer Implementierung verwendeten Tools an die Teams delegiert werden.  Und das passt sehr gut zum DevOps-Modell. <br><br>  Der Grad der Unabh√§ngigkeit eines Teams spiegelt den Grad der Verbundenheit der gesamten Organisation wider.  Im Idealfall sollte sich die Organisation um die Funktionalit√§t der Software und letztendlich den gesch√§ftlichen Nutzen des Teams sowie die Kosten f√ºr die Teamressourcen k√ºmmern. <br><br>  In diesem Fall spielt der Softwarearchitekt eine wichtige Rolle.  Es sollte sich nicht auf bestimmte Tools und Technologien konzentrieren, die von Teams verwendet werden, oder die Details der internen Architektur von Diensten beeintr√§chtigen.  Stattdessen sollte der Schwerpunkt auf Protokollen und Interaktionen zwischen verschiedenen Diensten und dem Zustand des gesamten Systems liegen. <br><br><h3>  Conways umgekehrtes Gesetz: Die Organisationsstruktur muss die Zielarchitektur modellieren </h3><br>  Wie passen schwache Softwarekoh√§renz und schwache Teamkoh√§renz zusammen?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Conways Gesetz</a> besagt: <br><blockquote>  <i>"Organisationen, die Systeme entwerfen, sind auf ein Design beschr√§nkt, das die Kommunikationsstruktur dieser Organisation kopiert."</i> </blockquote><br>  Dies basiert auf der Beobachtung, dass die Architektur eines Softwaresystems die Struktur der Organisation widerspiegelt, die es erstellt.  Wir k√∂nnen Conways Gesetz "hacken", indem wir es umdrehen.  Organisieren Sie unsere Teams, um die gew√ºnschte Architektur widerzuspiegeln.  In diesem Sinne m√ºssen wir lose gekoppelte Teams mit lose gekoppelten Softwarekomponenten ausrichten.  Aber sollte es eine Eins-zu-Eins-Beziehung sein?  Ich denke im Idealfall ja.  Obwohl es gut zu sein scheint, wenn ein kleines Team an mehreren lose gekoppelten Diensten arbeitet.  Ich w√ºrde sagen, dass der Wendepunkt f√ºr die Skalierung f√ºr Teams gr√∂√üer ist als f√ºr Software, so dass dieser Organisationsstil akzeptabel erscheint.  Es ist wichtig, dass die Softwarekomponenten mit ihrer eigenen Versionierung und Bereitstellung getrennt bleiben, auch wenn einige von ihnen von einem Team entwickelt werden.  Wir m√∂chten in der Lage sein, das Team zu teilen, wenn es zu gro√ü wird, indem wir entwickelte Dienste auf verschiedene Teams √ºbertragen.  Dies ist jedoch nicht m√∂glich, wenn die Dienste eng miteinander verbunden sind oder einen Prozess, eine Versionierung oder eine Bereitstellung gemeinsam nutzen. <br><br>  Wir m√ºssen die Arbeit mehrerer Teams an denselben Komponenten vermeiden.  Dies ist ein Anti-Muster.  In gewisser Hinsicht sogar noch schlimmer als die Arbeit eines gro√üen Teams mit einer gro√üen Codebasis, da Kommunikationsbarrieren zwischen Teams zu einem noch st√§rkeren Gef√ºhl von mangelnder Eigenverantwortung und Kontrolle f√ºhren. <br><br><img src="https://habrastorage.org/webt/mj/z9/nl/mjz9nlpipokz7va4jnxhkeoygfk.png"><br><br>  Die Interaktion zwischen lose gekoppelten Teams, die lose gekoppelte Software erstellen, wird minimiert.  Nehmen Sie noch einmal das Internet-Beispiel.  H√§ufig k√∂nnen Sie die von einem anderen Unternehmen bereitgestellte API verwenden, ohne direkt damit zu kommunizieren (wenn der Vorgang einfach ist und Dokumentation vorhanden ist).  Wenn Teams interagieren, sollten interne Teamentwicklungs- und Implementierungsprozesse nicht diskutiert werden.  Stattdessen sollten Funktionalit√§t, Servicelevel und Ressourcen er√∂rtert werden. <br><br>  Die Verwaltung lose verbundener Teams, die lose verbundene Software erstellen, sollte einfacher sein als Alternativen.  Eine gro√üe Organisation sollte sich darauf konzentrieren, Teams klare Ziele und Anforderungen in Bezug auf Funktionalit√§t und Servicelevel zu liefern.  Die Ressourcenanforderungen sollten vom Team stammen, obwohl sie von der Organisation verwendet werden k√∂nnen, um die Kapitalrendite zu messen. <br><br><h3>  Locker gekoppelte Teams entwickeln locker gekoppelte Software </h3><br>  Eine schwache Konnektivit√§t in der Software und zwischen den Teams ist der Schl√ºssel zum Aufbau einer hocheffektiven Organisation.  Und meine Erfahrung best√§tigt diesen Punkt.  Ich habe in Organisationen gearbeitet, in denen die Teams nach Funktionen, nach Software-Ebene oder sogar nach Kunden getrennt waren.  Ich habe auch in gro√üen chaotischen Teams auf einer einzigen Codebasis gearbeitet.  In all diesen F√§llen gab es jedoch Probleme mit der Skalierung, die oben erw√§hnt wurden.  Die angenehmste Erfahrung war immer, als mein Team eine vollwertige Einheit war, die unabh√§ngig mit der Erstellung, Pr√ºfung und Bereitstellung unabh√§ngiger Dienste befasst war.  Aber Sie m√ºssen sich nicht auf meine Lebensgeschichten verlassen.  Accelerate (oben beschrieben) hat Forschungsergebnisse, die diese Ansicht st√ºtzen. <br><br>  <i><b>Wenn Sie dieses Material bis zum Ende gelesen haben, empfehlen wir Ihnen, sich eine Aufzeichnung eines offenen Webinars zum Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûEin Tag im Leben von DevOps‚Äú</a> anzusehen.</b></i> <i><br></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475980/">https://habr.com/ru/post/de475980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475958/index.html">Die Geschichte, wie sich das M√§dchen in der IT versammelt hat</a></li>
<li><a href="../de475960/index.html">AHURATUS Smart Home Sprachassistent</a></li>
<li><a href="../de475968/index.html">Interessante Neuigkeiten Vue 3</a></li>
<li><a href="../de475974/index.html">Wie wir im Zug einen Hackathon machten und was daraus wurde</a></li>
<li><a href="../de475978/index.html">Wof√ºr ist das Hauptquartier des Zuges?</a></li>
<li><a href="../de475982/index.html">Wie lerne ich eine Fremdsprache?</a></li>
<li><a href="../de475986/index.html">PocketBook 740 Pro Reader √úbersicht: 7,8 Zoll, Audio- und IPX8-Schutz</a></li>
<li><a href="../de475988/index.html">ML.NET Model Builder-Aktualisierungen</a></li>
<li><a href="../de475990/index.html">Erstellen moderner Cloud-Anwendungen mit Pulumi und .NET Core</a></li>
<li><a href="../de475992/index.html">Schreiben eines VLC-Plugins zum Erlernen der englischen Sprache</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>