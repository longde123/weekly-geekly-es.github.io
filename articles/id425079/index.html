<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏽 🛌🏼 👉🏼 IPSec yang sulit dengan Linux 🎡 🔀 🏢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengembangkan infrastruktur TI, cepat atau lambat, tugas tersebut datang untuk berintegrasi dengan layanan apa pun dari organisasi besar. Ini mungkin,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IPSec yang sulit dengan Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425079/"><img src="https://habrastorage.org/webt/9i/ar/ia/9iariac5i8g79f_qasyzcuf5tnc.png"><br><br>  Mengembangkan infrastruktur TI, cepat atau lambat, tugas tersebut datang untuk berintegrasi dengan layanan apa pun dari organisasi besar.  Ini mungkin, misalnya, bank atau operator telekomunikasi.  Sebagai aturan, organisasi besar telah menetapkan kebijakan keamanan informasi, yang secara khusus memerlukan implementasi layanan dengan infrastruktur di luar mereka melalui saluran terenkripsi - IPSec.  Pada saat yang sama, dalam organisasi <s>startup</s> kecil tidak ada pengalaman dalam mengatur skema seperti itu, dan dari peralatan hanya ada VDS dengan Linux.  Terlebih lagi, yang mengejutkan saya, praktis tidak ada materi dalam Runet yang menggambarkan alat pemecahan masalah Linux.  Mari kita coba untuk menghilangkan celah ini dan menggambarkan bagian praktis dari pengaturan. <br><a name="habracut"></a><br>  Skema umum layanan disajikan di bawah ini.  Sebagai aturan, dalam organisasi besar, semuanya sudah terstandarisasi, diaktifkan, segala macam kemungkinan enkripsi dan potongan jaringan lainnya dilakukan pada peralatan terpisah (tsiska-juniper dan lainnya seperti mereka), dan, yang lebih penting, oleh <b>individu</b> (mungkin setiap kotak biru pada diagram di bawah ini) dilayani oleh orang yang berbeda).  Anda memiliki satu mesin virtual yang dengannya layanan akan diluncurkan dan IPSec akan diatur. <br><br><img src="https://habrastorage.org/webt/cw/1p/g0/cw1pg0gmvnixufv4anjqa2vgxrq.png"><br><br>  Harap dicatat bahwa IPSec sendiri diatur antara satu alamat IP (dalam contoh saya <code>10.0.255.1 &lt;-&gt; 10.0.1.1</code> ), dan layanan itu sendiri diatur antara yang lain ( <code>192.168.255.1&lt;-&gt; 192.168.1.1</code> ).  Skema semacam itu juga disebut <i>IPSec Network-Network</i> . <br><br>  Contoh sederhana adalah Anda bekerja di <i>SuperService</i> perusahaan yang muda namun sangat ambisius, dan Anda perlu mengatur interaksi dengan API tertutup <i>MegaTelecom</i> .  Infrastruktur Anda adalah satu server VDS, infrastruktur mitra Anda adalah sekelompok peralatan jaringan dan server.  Tugas ini dibagi menjadi dua tahap: <br><br><ol><li>  Untuk mengatur transportasi (bagaimana pekerjaan akan terjadi). </li><li>  Konfigurasikan layanan (jalankan aplikasi langsung di server). </li></ol><br>  Jadi, manajer <i>SuperService</i> memutuskan untuk mengatur koneksi ke beberapa organisasi besar untuk menyelesaikan masalah bisnis.  Dia menoleh ke <i>MegaTelecom</i> , di mana mereka mengiriminya <b>spesifikasi teknis</b> untuk koneksi.  Salah satu kondisi ini adalah <b>IPSec</b> .  Kondisi ini datang dalam bentuk piring <i>excel</i> , contoh yang saya sajikan di bawah ini.  Dalam gambar, saya menyoroti parameter yang signifikan secara teknis dengan warna kuning.  Formatnya mungkin berbeda, tetapi esensinya tetap sama. <br><br><img src="https://habrastorage.org/webt/wi/jk/7t/wijk7treuikfegnmkk9sof2pnze.png"><br><br>  Awalnya, itu tidak terisi di pihak Anda, itu harus diisi dan dikirim untuk persetujuan kepada mitra.  Setelah setuju, Anda dapat duduk dan mencoba menyetel mesin Linux Anda. <br><br><h3>  Konsep IPSec </h3><br>  Selanjutnya, saya akan memberikan sedikit teori untuk orang-orang yang sama sekali tidak akrab dengan teknologi.  Semua yang akan saya jelaskan lebih lanjut mengacu pada Ethernet murni dan IPv4.  Saya tidak akan masuk ke enkripsi, algoritma pertukaran kunci, melainkan fokus pada bagian jaringan. <br><br>  <b>IPSec</b> - seperangkat teknik dan protokol untuk mengatur koneksi yang aman. <br><br>  Tidak seperti teknologi tunneling lainnya (GRE, PPP, L2TP, bahkan MPLS-TE), tidak ada interface tunnel eksplisit yang dibuat untuk IPSec melalui mana traffic dapat dialihkan.  Sebagai gantinya, IPSec memberikan konsep yang disebut <b>Security Assotiations (SA)</b> .  <i>SA</i> adalah terowongan dari satu perangkat jaringan ke perangkat lainnya.  Tapi jangan lupa bahwa <i>SA</i> bukan antarmuka jaringan dalam arti kata normal, perutean klasik tidak berfungsi di sini.  Alih-alih tabel routing, konsep <b>Kebijakan Keamanan (SP)</b> bekerja di sini.  Kami secara eksplisit meresepkan sesuatu seperti daftar akses (ACL) untuk melewati lalu lintas melalui SA tertentu.  Semua hal ini didefinisikan dalam kerangka kerja yang disebut <b>ISAKMP</b> . <br><blockquote>  <b>ISAKMP</b> - deskripsi prosedur IPSec, dalam literatur mereka menyebutnya kerangka kerja.  Ini menggambarkan istilah SA, SP, SAD (Database Assosiasi Keamanan), SPD (Database Kebijakan Keamanan), kebutuhan untuk menginstal terowongan tambahan ... ISAKMP dirancang agar tidak bergantung pada teknologi tunneling, algoritma otentikasi, dan enkripsi.  Dia hanya memperkenalkan definisi yang diperlukan. <br><br>  <b>IKE (v1 / 2)</b> - langsung protokol otentikasi.  Dia sudah mengimplementasikan algoritma pertukaran kunci dan aplikasinya. <br><br>  Berkat konsep Cisco, ISAKMP dan IKE sekarang dianggap sama. </blockquote>  Sebelum mengenkripsi lalu lintas, para pihak harus menyetujui parameter (dan kunci) enkripsi ini.  Untuk melakukan ini, sebuah terowongan bantu naik di antara kedua sisi (ini juga disebut terowongan ISAKMP), yang beroperasi sepanjang waktu.  Terowongan dua arah ini adalah koneksi UDP (secara default pada port 500).  Untuk mengatur terowongan bantu ini, para pihak harus saling mengautentikasi (kata sandi harus cocok).  Ini dilakukan oleh <b>protokol IKEv1 / 2 (Internet Key Exchange)</b> .  Dan sudah ada di terowongan <i>ISAKMP yang</i> terorganisir, para pihak sepakat untuk mengenkripsi lalu lintas pengguna secara langsung. <br><br>  Organisasi IPSec sendiri dibagi menjadi dua fase: <br><br><ol><li>  Membuat Terowongan Bantu ISAKMP </li><li>  Membuat terowongan data pengguna </li></ol><br>  Seperti yang saya tulis, dalam konsep IPSec (atau lebih tepatnya, dalam konsep <i>ISAKMP</i> ) terowongan disebut <i>SA</i> . <br><br>  Fase pertama (organisasi ISAKMP SA) dapat dilakukan dalam dua mode: <br><br><ol><li>  pihak - pihak <b>utama secara</b> bergantian bertukar parameter negosiasi.  Itu dianggap lebih aman, digunakan untuk saluran permanen (kasing kami). </li><li>  <b>agresif</b> - dalam satu pesan, inisiator mengirim semua parameter koordinasi yang diperlukan, digunakan saat menghubungkan pengguna jarak jauh untuk sesi sementara (untuk membuatnya lebih cepat). </li></ol><br>  Anda harus memahami bahwa terowongan SA <b>utama</b> adalah <b>searah</b> .  Untuk pengiriman data dua arah melalui saluran IPSec, harus ada dua terowongan: sumber (src) → penerima (dst) dan sebaliknya. <br><br>  Dalam semua metode enkripsi, header tambahan ditambahkan ke paket IP asli, terjadi enkapsulasi.  Ada dua metode untuk enkapsulasi ini - <b>AH (Authentication Header)</b> dan <b>ESP (Encapsulation Security Payload)</b> .  AH hanya mengautentikasi paket (ditandatangani secara digital oleh pengirim), ESP dan mengautentikasi (tanda-tanda), dan mengenkripsi.  Hari ini, AH hampir tidak pernah digunakan, semuanya dikemas dalam ESP. <br><br>  Anda dapat mengenkripsi dan mengautentikasi paket IP sumber tanpa memperhitungkan header IP (mode transportasi) atau dengannya (mode terowongan).  <b>Transportasi</b> digunakan ketika direncanakan untuk mengatur terowongannya menggunakan teknologi lain (bukan IPSec / ESP).  Misalnya, GRE, l2tp, ppp.  Untuk tujuan menghubungkan beberapa layanan ke infrastruktur internal organisasi besar, secara praktis tidak digunakan.  Saya menggunakan skenario ini untuk menggabungkan beberapa kantor menjadi satu VPN melalui IPSec.  Kami lebih tertarik pada mode <b>terowongan</b> .  Seperti yang dapat Anda lihat dari gambar, satu header IP tambahan ditambahkan di sini. <br><br><img src="https://habrastorage.org/webt/kc/pl/qe/kcplqeh1wmwmwlsidaj7ckvsnh0.png"><br><blockquote>  Omong-omong, ada contoh nyata menggunakan enkapsulasi AH.  Misalkan kita memiliki dua jaringan yang terhubung ke router yang berbeda.  Host harus mengirimkan informasi dengan MTU 1500 byte tanpa fragmentasi, tetapi kami memiliki bagian perantara yang hanya mendukung 1380 byte.  Seluruh trek dipercaya.  Kita dapat mengambil keuntungan dari fakta bahwa IPSec tidak membuat antarmuka terowongan, dalam arti klasik di mana lalu lintas tidak dialihkan.  Kami akan membuat <i>SA</i> tipe terowongan <i>SA</i> (kami tidak perlu mengenkripsi), lalu lintas akan menuju ke sana.  Hanya paket IP eksternal (sesuai dengan header IP eksternal) yang akan difragmentasi dalam lalu lintas, yang internal akan disusun kembali tanpa perubahan. <br><br><img src="https://habrastorage.org/webt/o9/ni/p6/o9nip6nargofgqz9_77nfrbcily.png"><br></blockquote><img width="60%" align="right" src="https://habrastorage.org/webt/ar/v1/w1/arv1w1hdlpdoosmczuno9o1prue.png"><br>  Perhatikan bahwa header <i>ESP</i> naik <b>sebelum transportasi TCP / UDP</b> .  Ingat bidang IP memiliki bidang Protokol?  Berdasarkan bidang ini, peralatan jaringan (dan penghuni akhir) dengan benar memproses paket IP.  Jadi untuk ESP jumlahnya adalah 50. Daftar lengkap protokol untuk bidang ini dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki</a> , itu bisa sangat berguna. <br><br><img align="right" src="https://habrastorage.org/webt/aa/ha/cs/aahacsstzsqw1ljf1x1j7omrm4c.png">  Tidak adanya header lapisan transport (TCP / UDP / ICMP sudah dienkripsi!) Memberlakukan batasan pada teknologi seperti NAT.  Ingat, NAT dengan terjemahan port (overload, PAT, MASQARADE, ini memiliki banyak nama) berfungsi berdasarkan port protokol transport.  Dan di terowongan IPSec terenkripsi mereka tidak!  Untuk mengatasi masalah ini, ada teknologi seperti <b>IPSec NAT-Traversal (NAT-T)</b> .  Selama fase pertama, para pihak sepakat tentang penggunaan NAT-T.  Jika kedua belah pihak mendukung NAT-T (dan bahkan pada port UDP yang sama), maka header UDP ditambahkan ke terowongan yang dihasilkan untuk lalu lintas, dengan paket mana yang akan melalui router dengan terjemahan alamat jaringan. <br><br>  Terowongan itu sendiri tidak akan naik, Anda perlu mengarahkan lalu lintas di sana.  Seperti yang saya tulis di atas, aturan perutean tidak berfungsi di sini, Anda perlu menulis Kebijakan <b>Keamanan (SP)</b> . <br><br>  Kebijakan terdiri dari alamat sumber, alamat tujuan, arah (masuk, keluar, fwd) dan parameter terowongan pengguna (di sini ESP akan dijelaskan hanya apakah itu AH, versi terowongan, atau transportasi).  Ini lebih seperti mengatur aturan untuk NAT.  NAT juga tidak memiliki entri tabel routing yang cukup.  Dan di sana juga, peraturan ditunjukkan di <i>mana, di mana dan bagaimana</i> , dan bukan di <i>mana dan melalui apa</i> .  Dan juga dengan gerakan tangan yang salah, Anda dapat memblokir semua komunikasi di server jauh. <br><blockquote>  Semua manipulasi IPSec menambahkan header.  Setidaknya mereka akan memakan 40 byte lagi dari paket aslinya.  Jadi, misalnya, dengan MTU standar untuk PPPoE 1380 byte koneksi, MTU yang sebenarnya adalah &lt;1340. </blockquote><h3>  IPSec di Linux </h3><br>  Mari berlatih menggunakan contoh distribusi DEB.  Saya hanya akan mempertimbangkan kasus dengan otorisasi berdasarkan <i>pre-shared-key (PSK)</i> , kami akan mengonfigurasi skema dari awal artikel. <br><br>  IPSec sendiri didukung oleh kernel, tetapi dukungan ini sangat terbatas.  Sebenarnya, modul-modul yang kuat hanya berkaitan dengan enkripsi dan kunci (pemrosesan paket) yang telah diterima (ditransfer ke kernel).  Dan untuk lulus di sana parameter dan aturan yang Anda butuhkan untuk memproses lalu lintas, Anda memerlukan perangkat lunak terpisah.  Sebagai perangkat lunak seperti itu, ada beberapa solusi: <br><br><ol><li>  KAME bermigrasi dari BSD </li><li>  xSWAN (strongswan, freeswan, libreswan, dll) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shorewall</a> </li></ol><br>  Bagiku, versi KAME yang paling sederhana (dapat diprediksi), dan kami akan terus memutarnya. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># deb-       root@localhost: ~# apt-get install racoon ipsec-tools</span></span></code> </pre><br>  Secara tradisional, KAME terdiri dari dua komponen <br><br><ol><li>  <b>Daemon racoon</b> untuk mengontrol terowongan <i>ISAKMP</i> . </li><li>  Utilitas <b>Setkey</b> untuk mengelola terowongan SA dengan data. </li></ol><br>  Mari kita mulai dengan yang pertama.  <i>Racoon</i> bertanggung jawab atas pengaturan otorisasi terowongan di bawah IKE.  Ini adalah daemon, dikonfigurasikan dengan satu file konfigurasi ( <code>/etc/racoon.conf</code> ), diluncurkan oleh skrip init biasa ( <code>/etc/init.d/racoon &lt;start|stop|restart&gt;</code> ). <br><br><div class="spoiler">  <b class="spoiler_title">root @ localhost: ~ # cat /etc/racoon.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      remote  sainfo     # #      PSK  path pre_shared_key "/etc/racoon/psk.txt"; log debug; listen { #  ,      ISAKMP  isakmp 10.0.1.1 [500]; strict_address; } #   remote      IPSec. #      tunnel-group  ASA. #   IP-   anonymous #          . #     user-network # remote anonymous remote 10.0.255.1 { nat_traversal off; exchange_mode main; my_identifier address 10.0.1.1; proposal { encryption_algorithm 3des; hash_algorithm sha1; authentication_method pre_shared_key; dh_group modp1024; lifetime time 86400 sec; } } #   IPSec.  transform-set  ASA. # # ,      #       . #         # sainfo address &lt;src&gt; address &lt;dst&gt; #      ,       # sainfo anonymous sainfo address 192.168.1.1 any address 192.168.255.1 any { pfs_group modp1024; lifetime time 28800 sec; encryption_algorithm 3des; authentication_algorithm hmac_sha1; compression_algorithm deflate; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">root @ localhost: ~ # cat /etc/racoon/psk.txt</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   PSK- #  &lt;REMOTE IP ADDR&gt; &lt;PASSWORD&gt; #  -      ,     racoon 10.0.255.1 SUPERPASSWORD</span></span></code> </pre><br></div></div><br>  Seperti biasa, detail dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>man 5 racoon.conf</code></a> <br><br>  Selanjutnya, kita akan <i>mengambil</i> utilitas <i>setkey</i> .  Itu juga dimulai sebagai daemon ( <code>/etc/init.d/setkey &lt;start|stop|restart&gt;</code> ), tetapi sebenarnya ia menjalankan script <code>/etc/ipsec-tools.conf</code> .  Seperti yang saya katakan, itu sudah membuat terowongan untuk lalu lintas pengguna.  Yaitu mengatur <b>SA dan SP</b> untuk mereka.  Ini adalah sesuatu seperti <i>kripto-peta</i> di ASA.  Opsi termudah bagi kita adalah menambahkan SP saja.  Kemudian SA akan dibangun secara otomatis berdasarkan parameter fase kedua yang ditentukan dalam pengaturan <i>racoon</i> . <br><br>  Tetapi dimungkinkan untuk tidak menggunakan parameter fase kedua dari <i>racoon sama sekali</i> , tetapi untuk mengatur SA melalui utilitas ini.  Detail dan sintaksis dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>man 8 setkey</code></a> .  Tetapi saya akan memberikan contoh konfigurasi yang paling sederhana. <br><br><div class="spoiler">  <b class="spoiler_title">root @ localhost: ~ # cat /etc/ipsec-tools.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs">flush; spdflush; spdadd 192.168.1.1/32 192.168.255.1/32 any -P out ipsec esp/tunnel/10.0.1.1-10.0.255.1/require; spdadd 192.168.255.1/32 192.168.1.1/32 any -P <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ipsec esp/tunnel/10.0.255.1-10.0.1.1/require;</code> </pre><br></div></div><br>  Saat ini, utilitas <i>setkey</i> diduplikasi oleh modul <i>iproute2</i> . <br>  Sebagai bagian dari itu, ada dua tim manajemen catatan SA dan SP. <br><br><ol><li>  kondisi ip xfrm </li><li>  <b>kebijakan</b> ip xfrm </li></ol><br>  Selain mengelola utilitas ini, Anda dapat melihat status SA dan <i>SP</i> terorganisir yang diterapkan untuk lalu lintas.  Lebih detail dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>man 8 ip-xfrm</code></a> . <br><blockquote>  Lihatlah tablet aslinya.  Ada beberapa alamat IP untuk IPSec dan layanan.  Alamat IP internal sedang difilter di dalam infrastruktur <i>Megatelecom</i> .  Tetapi kami hanya memiliki satu mesin virtual.  Alamat IP internal entah bagaimana akan muncul di dalamnya, dan paket-paket ke dalam terowongan harus pergi darinya.  Ada beberapa opsi untuk mencapai skenario ini: <br><br><ol><li>  Rute statis tanpa mendeteksi penghentian, tetapi dengan indikasi eksplisit antarmuka keluar dan alamat IP. </li><li>  Menentukan rute berdasarkan kebijakan berbasis routing (PBR di Linux alias <i>aturan ip</i> ). </li><li>  Terjemahan Alamat ( <i>NAT / MASQARADE</i> ). </li></ol><br>  Dari sudut pandang saya, opsi pertama cocok di sini. <br><br>  Kami dapat menambahkan alamat IP (sekunder) tambahan ke antarmuka kami, sementara itu lebih baik untuk membuat <b>alias</b> untuk antarmuka ini <br> <code>root@localhost: ~# ip addr add 192.168.1.1/32 dev eth1 label eth1:1</code> <br>  dan konfigurasikan rute ke server <i>Megatelecom</i> dari alamat IP ini. <br> <code>root@localhost: ~# ip route add 192.168.255.1/32 dev eth1:1 src 192.168.1.1</code> <br>  Tetapi jika Anda melakukannya, tidak ada yang akan mulai.  Faktanya adalah bahwa ketika menambahkan rute dalam formulir ini, stasiun Linux akan mencoba menentukan alamat MAC penerima, itu akan melakukannya melalui ARP ... Komputer akan mengirim permintaan ARP <code>Who has IP 192.168.255.1</code> .  Karena 192.168.255.1 tidak pada jaringan yang sama dengan 192.168.1.1 (mask / 32!), Tidak akan ada respons terhadap ARP.  Tetapi ketika Anda mencoba untuk terhubung, <code>No route to host</code> akan dikembalikan dari alamat IP lokal.  Untuk mengalahkan ini, kita perlu menetapkan catatan ARP statis: <br> <code>root@localhost: ~# arp -s 192.168.255.1 00:00:00:00:00:01 -i eth1:1</code> <br>  Semacam hack hidup.  Omong-omong, manipulasi semacam itu mungkin tidak mengarah pada operasi yang benar dari tumpukan IP Linux.  Dalam salah satu kasus, perintah <code>ip route</code> tidak menghasilkan hasil yang diinginkan, perlu untuk mem-boot ulang tumpukan jaringan. <br></blockquote><h3>  Pemeriksaan Kesehatan </h3><br><br>  Jangan lupa, terowongan hanya akan naik ketika lalu lintas masuk ke dalamnya!  Diperlukan untuk memulai ping dari antarmuka tertentu (alamat IP) sebelum tujuan. <br> <code>root@localhost: ~# ping -I 192.168.1.1 192.168.255.1</code> <br>  Dengan sedikit keterlambatan, harus ada balasan dari sisi sebaliknya (kecuali tentu saja ICMP ditutup di mana saja di situs). <br><br>  Kita bisa melihat apakah terowongan ISAKMP telah naik. <br><br><div class="spoiler">  <b class="spoiler_title">racoonctl show-sa isakmp</b> <div class="spoiler_text"><pre> <code class="bash hljs">root@localhost: ~<span class="hljs-comment"><span class="hljs-comment"># racoonctl show-sa isakmp Destination Cookies Created 10.0.1.1.500 356a7e11111a93f:367111530375c065 2018-10-02 09:18:28</span></span></code> </pre><br></div></div><br>  Kita juga bisa melihat terowongan dengan data pengguna. <br><br><div class="spoiler">  <b class="spoiler_title">racoonctl show-sa esp</b> <div class="spoiler_text"><pre> <code class="bash hljs">10.0.1.1 10.0.255.1 esp mode=tunnel spi=2148175815(0x800a8fc7) reqid=0(0x00000000) E: 3des-cbc 799e587f 6a2b4b78 5590cc2a 3d3ee331 f7e7f472 01abcdef A: hmac-sha1 01c5161f 46679a36 5d07ee9d f159fc9a 01abcdef seq=0x00000000 replay=4 flags=0x00000000 state=mature created: Oct 2 09:22:44 2018 current: Oct 2 10:39:21 2018 diff: 4597(s) hard: 28800(s) soft: 23040(s) last: Oct 2 09:22:45 2018 hard: 0(s) soft: 0(s) current: 84(bytes) hard: 0(bytes) soft: 0(bytes) allocated: 1 hard: 0 soft: 0 sadb_seq=1 pid=3764 refcnt=0 10.0.255.1 10.0.1.1 esp mode=tunnel spi=45614328(0x02b804f8) reqid=0(0x00000000) E: 3des-cbc 97cedcf1 644e8bbb c22b4e2c fa08a874 01abcdef 211ad19e A: hmac-sha1 1ab3e79d 3fd924a0 01abcdef 6c9ac89a 01abcdef seq=0x00000000 replay=4 flags=0x00000000 state=mature created: Oct 2 09:22:44 2018 current: Oct 2 10:39:21 2018 diff: 4597(s) hard: 28800(s) soft: 23040(s) last: Oct 2 09:22:45 2018 hard: 0(s) soft: 0(s) current: 84(bytes) hard: 0(bytes) soft: 0(bytes) allocated: 1 hard: 0 soft: 0 sadb_seq=0 pid=3764 refcnt=0</code> </pre><br></div></div><br>  Dapat berguna dalam <i>tcpdump untuk</i> melihat logika untuk membangun koneksi.  Di sini Anda juga dapat melihat fase pembuatan koneksi dan lalu lintas yang sudah <b>dienkripsi</b> dalam ESP.  Tentu saja, ada teknik untuk menguraikannya, tetapi biasanya kesimpulan ini sudah cukup. <br><br><div class="spoiler">  <b class="spoiler_title">root @ localhost: ~ # tcpdump -i eth1 host 10.0.255.1</b> <div class="spoiler_text"><pre> <code class="bash hljs">18:01:06.409631 IP 10.0.1.1.500 &gt; 10.0.255.1.500: isakmp: phase 1 I ident 18:01:06.439276 IP 10.0.255.1.500 &gt; 10.0.1.1.500: isakmp: phase 1 R ident 18:01:06.440840 IP 10.0.1.1.500 &gt; 10.0.255.1.500: isakmp: phase 1 I ident 18:01:06.475244 IP 10.0.255.1.1.500 &gt; 10.0.1.1.500: isakmp: phase 1 R ident 18:01:06.477032 IP 10.0.1.1.500 &gt; 10.0.255.1.500: isakmp: phase 1 I ident[E] 18:01:06.487785 IP 10.0.255.1.500 &gt; 10.0.1.1.500: isakmp: phase 1 R ident[E] 18:01:06.488048 IP 10.0.1.1.500 &gt; 10.0.255.1.500: isakmp: phase 2/others I inf[E] 18:01:07.412451 IP 10.0.1.1.500 &gt; 10.0.255.1.500: isakmp: phase 2/others I oakley-quick[E] 18:01:07.465363 IP 10.0.255.1.500 &gt; 10.0.1.1.500: isakmp: phase 2/others R oakley-quick[E] 18:01:07.465940 IP 10.0.1.1.500 &gt; 10.0.255.1.500: isakmp: phase 2/others I oakley-quick[E] 18:01:08.467373 IP 10.0.1.1 &gt; 10.0.255.1: ESP(spi=0x7aabfa82,seq=0x1), length 116 18:01:08.480141 IP 10.0.255.1 &gt; 10.0.1.1: ESP(spi=0x0386f867,seq=0x1), length 116</code> </pre><br></div></div><br><blockquote>  Saat menghubungkan dari jarak jauh melalui SSH, agar tidak menghasilkan banyak jendela, lebih mudah untuk menjalankan tcpdump di latar belakang: <br><br> <code>root@localhost: ~# tcpdump -i eth1 -w ipsec.pcap esp &amp; <br></code> <br><br>  Kami mulai ping, telnet, netcat ... <br><br> <code>root@localhost: ~# killall tcpdump <br> root@localhost: ~# tcpdump -vr ipsec.pcap <br></code> <br></blockquote>  Juga di log Anda dapat melihat status koneksi yang berhasil.  Ini menunjukkan keberhasilan pendirian kedua fase IPSec. <br><br><div class="spoiler">  <b class="spoiler_title">root @ localhost: ~ # cat /var/log/daemon.log</b> <div class="spoiler_text"><pre> <code class="bash hljs">Oct 3 17:53:26 vm22433 racoon: INFO: IPsec-SA request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 10.0.255.1 queued due to no phase1 found. Oct 3 17:53:26 vm22433 racoon: INFO: initiate new phase 1 negotiation: 10.0.1.1[500]&lt;=&gt;10.0.255.1[500] Oct 3 17:53:26 vm22433 racoon: INFO: begin Identity Protection mode. Oct 3 17:53:26 vm22433 racoon: INFO: received Vendor ID: CISCO-UNITY Oct 3 17:53:26 vm22433 racoon: INFO: received Vendor ID: DPD Oct 3 17:53:26 vm22433 racoon: INFO: received Vendor ID: draft-ietf-ipsra-isakmp-xauth-06.txt Oct 3 17:53:26 vm22433 racoon: INFO: ISAKMP-SA established 10.0.1.1[500]-10.0.255.1[500] spi:ebddc300af62ae42:abcdef0123 Oct 3 17:53:27 vm22433 racoon: INFO: initiate new phase 2 negotiation: 10.0.1.1[500]&lt;=&gt;10.0.255.1[500] Oct 3 17:53:27 vm22433 racoon: INFO: received RESPONDER-LIFETIME: 4608000 kbytes Oct 3 17:53:27 vm22433 racoon: WARNING: attribute has been modified. Oct 3 17:53:27 vm22433 racoon: INFO: IPsec-SA established: ESP/Tunnel 10.0.1.1[500]-&gt;10.0.255.1[500] spi=238677(0xe39eabc) Oct 3 17:53:27 vm22433 racoon: INFO: IPsec-SA established: ESP/Tunnel 10.0.1.1[500]-&gt;10.0.255.1500] spi=7204011111(0x44b4aaa)</code> </pre></div></div><br>  Itu saja.  Tetap menambahkan semua manipulasi yang diperlukan ke startup, dan Anda dapat memulai integrasi aplikasi. <br><br>  PS: Permintaan untuk melaporkan semua kesalahan atau ketidakakuratan dalam artikel melalui pesan pribadi.  Ketika saya men-tweak artikelnya, komentarnya akan terlihat konyol. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425079/">https://habr.com/ru/post/id425079/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425069/index.html">Menguji presenter menggunakan PromiseKit</a></li>
<li><a href="../id425071/index.html">Bagaimana cara melindungi dari stack overflow (pada Cortex M)?</a></li>
<li><a href="../id425073/index.html">Pembuatan repositori git yang mudah di OneDrive</a></li>
<li><a href="../id425075/index.html">Visi Mesin: Menginstal, Mengonfigurasi, dan Menggunakan Google Cloud Vision dalam PHP</a></li>
<li><a href="../id425077/index.html">Kotlin di bawah tenda - lihat bytecode yang didekompilasi</a></li>
<li><a href="../id425081/index.html">Negara tidak tahu berapa banyak yang dihabiskan untuk TI. Kami membuktikan pada angka</a></li>
<li><a href="../id425083/index.html">Stat postgres tanpa saraf dan ketegangan</a></li>
<li><a href="../id425085/index.html">7 praktik wadah terbaik oleh Google</a></li>
<li><a href="../id425087/index.html">Openspace Agility: Memperkenalkan Agile di seluruh perusahaan (sekarang dengan kepemimpinan!)</a></li>
<li><a href="../id425089/index.html">TI di Dunia Satwa: Pencarian Makanan Semut dan TCP / IP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>