<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏽 🌽 🧚🏽 Escribimos un sistema operativo en Rust. Implementando memoria de página (nuevo) 🥙 🧔🏼 🙎🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este artículo, descubriremos cómo implementar el soporte de memoria de página en nuestro núcleo. Primero, estudiaremos varios métodos para que los ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos un sistema operativo en Rust. Implementando memoria de página (nuevo)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445618/">  En este artículo, descubriremos cómo implementar el soporte de memoria de página en nuestro núcleo.  Primero, estudiaremos varios métodos para que los marcos de la tabla de páginas físicas estén disponibles para el núcleo, y discutiremos sus ventajas y desventajas.  Luego implementamos la función de traducción de direcciones y la función de crear una nueva asignación. <br><br>  Esta serie de artículos publicados en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> .  Si tiene alguna pregunta o problema, abra el ticket correspondiente allí.  Todas las fuentes para el artículo están <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en este hilo</a> . <br><br>  <i><b>¿Otro artículo sobre paginación?</b></i> <i><br></i>  <i>Si sigue este ciclo, vio el artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Memoria de página: Nivel avanzado"</a> a fines de enero.</i>  <i>Pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">me criticaron</a> por las tablas de páginas recursivas.</i>  <i>Por lo tanto, decidí volver a escribir el artículo, usando un enfoque diferente para acceder a los marcos.</i> <br><a name="habracut"></a><br>  <i>Aquí hay una nueva opción.</i>  <i>El artículo todavía explica cómo funcionan las tablas de páginas recursivas, pero utilizamos una implementación más simple y poderosa.</i>  <i>No eliminaremos el artículo anterior, pero lo marcaremos como obsoleto y no lo actualizaremos.</i> <i><br><br></i>  <i>¡Espero que disfrutes la nueva opción!</i> <br><br><h1>  Contenido </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Actualizaciones de dependencia</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acceso a tablas de páginas.</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapeo de identidad</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapa de desplazamiento fijo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapeo completo de memoria física</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Exhibición temporal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tablas de página recursivas</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte de arranque</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Información de arranque</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Macro de punto de entrada</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementación</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acceso a tablas de páginas.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Traducción de direcciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Usando MappedPageTable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crea un nuevo mapeo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Selección de marco</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Resumen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Que sigue</a> </li></ul><br><a name="1"></a><h1>  Introduccion </h1><br>  Desde el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">último artículo,</a> aprendimos sobre los principios de la memoria de paginación y cómo funcionan las tablas de páginas de cuatro niveles en <code>x86_64</code> .  También encontramos que el cargador ya configuró la jerarquía de la tabla de páginas para nuestro núcleo, por lo que el núcleo se ejecuta en direcciones virtuales.  Esto aumenta la seguridad porque el acceso no autorizado a la memoria provoca un error de página en lugar de cambiar aleatoriamente la memoria física. <br><br>  El artículo terminó sin poder acceder a las tablas de páginas de nuestro núcleo, porque están almacenadas en la memoria física y el núcleo ya se está ejecutando en direcciones virtuales.  Aquí continuamos con el tema y exploramos diferentes opciones para acceder a los marcos de la tabla de páginas desde el núcleo.  Discutiremos las ventajas y desventajas de cada uno de ellos, y luego elegiremos la opción adecuada para nuestro núcleo. <br><br>  Se requiere soporte para el cargador de arranque, por lo que lo configuraremos primero.  Luego implementamos una función que se ejecuta en toda la jerarquía de las tablas de páginas para traducir las direcciones virtuales en físicas.  Finalmente, aprenderemos cómo crear nuevas asignaciones en tablas de páginas y cómo encontrar marcos de memoria no utilizados para crear nuevas tablas. <br><br><a name="1_1"></a><h3>  Actualizaciones de dependencia </h3><br>  Este artículo requiere que registre la versión 0.4.0 o superior del <code>bootloader</code> y la versión 0.5.2 o superior <code>x86_64</code> en las dependencias.  Puede actualizar las dependencias en <code>Cargo.toml</code> : <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = "0.4.0" x86_64 = "0.5.2"</code> </pre> <br>  Para ver los cambios en estas versiones, consulte <a href="">el registro del cargador de arranque</a> y el <a href="">registro x86_64</a> . <br><br><a name="2"></a><h1>  Acceso a tablas de páginas. </h1><br>  Acceder a las tablas de páginas desde el núcleo no es tan fácil como parece.  Para comprender el problema, eche otro vistazo a la jerarquía de tablas de cuatro niveles del artículo anterior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  Lo importante es que cada entrada de página almacena la dirección <i>física</i> de la siguiente tabla.  Esto evita la traducción de estas direcciones, lo que reduce el rendimiento y conduce fácilmente a bucles sin fin. <br><br>  El problema es que no podemos acceder directamente a las direcciones físicas desde el núcleo, ya que también funciona en direcciones virtuales.  Por ejemplo, cuando vamos a la dirección <code>4 KiB</code> , tenemos acceso a la dirección <i>virtual</i> <code>4 KiB</code> , y no a la dirección <i>física</i> donde se almacena la tabla de páginas del 4to nivel.  Si queremos acceder a la dirección física de <code>4 KiB</code> , entonces necesitamos usar alguna dirección virtual, que se traduce en ella. <br><br>  Por lo tanto, para acceder a los marcos de las tablas de páginas, debe asignar algunas páginas virtuales a estos marcos.  Hay diferentes formas de crear tales asignaciones. <br><br><a name="2_1"></a><h3>  Mapeo de identidad </h3><br>  Una solución simple es la <b>visualización idéntica de todas las tablas de páginas</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  En este ejemplo, vemos la visualización idéntica de cuadros.  Las direcciones físicas de las tablas de páginas son al mismo tiempo direcciones virtuales válidas, por lo que podemos acceder fácilmente a las tablas de páginas de todos los niveles, comenzando con el registro CR3. <br><br>  Sin embargo, este enfoque satura el espacio de direcciones virtuales y hace que sea difícil encontrar grandes áreas contiguas de memoria libre.  Digamos que queremos crear un área de memoria virtual de 1000 KiB en la figura anterior, por ejemplo, para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mostrar un archivo en la memoria</a> .  No podemos comenzar con la región <code>28 KiB</code> , porque descansa en una página ya ocupada en <code>1004  KiB</code> .  Por lo tanto, tendrá que buscar más hasta encontrar un fragmento grande adecuado, por ejemplo, con <code>1008  KiB</code> .  Existe el mismo problema de fragmentación que en la memoria segmentada. <br><br>  Además, la creación de nuevas tablas de páginas es mucho más complicada, ya que necesitamos encontrar marcos físicos cuyas páginas correspondientes aún no se utilizan.  Por ejemplo, para nuestro archivo, reservamos un área de 1000 KiB de memoria <i>virtual</i> , comenzando en la dirección <code>1008  KiB</code> .  Ahora ya no podemos usar ningún marco con una dirección física entre <code>1000  KiB</code> y <code>2008  KiB</code> , porque no se puede mostrar de forma idéntica. <br><br><a name="2_2"></a><h3>  Mapa de desplazamiento fijo </h3><br>  Para evitar abarrotar el espacio de direcciones virtuales, puede mostrar las tablas de páginas en un <b>área de memoria separada</b> .  Por lo tanto, en lugar de identificar el mapeo, mapeamos cuadros con un desplazamiento fijo en el espacio de direcciones virtuales.  Por ejemplo, el desplazamiento puede ser 10 TiB: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4a/c8a/5ea/f4ac8a5ea64fd215de176248b5f74e20.svg"><br><br>  Al asignar este rango de memoria virtual únicamente para mostrar tablas de páginas, evitamos los problemas de visualización idéntica.  Reservar un área tan grande de espacio de direcciones virtuales solo es posible si el espacio de direcciones virtuales es mucho mayor que el tamaño de la memoria física.  En <code>x86_64</code> esto no es un problema porque el espacio de direcciones de 48 bits es de 256 TiB. <br><br>  Pero este enfoque tiene la desventaja de que al crear cada tabla de páginas, debe crear una nueva asignación.  Además, no permite el acceso a tablas en otros espacios de direcciones, lo que sería útil al crear un nuevo proceso. <br><br><a name="2_3"></a><h3>  Mapeo completo de memoria física </h3><br>  Podemos resolver estos problemas <b>mostrando toda la memoria física</b> , y no solo los cuadros de la tabla de páginas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/3cf/7df/c393cf7df76515739e1d9274160c4b5d.svg"><br><br>  Este enfoque permite que el núcleo acceda a la memoria física arbitraria, incluidos los cuadros de la tabla de páginas de otros espacios de direcciones.  Se reserva un rango de memoria virtual del mismo tamaño que antes, pero solo no quedan páginas inigualables. <br><br>  La desventaja de este enfoque es que se necesitan tablas de páginas adicionales para mostrar la memoria física.  Estas tablas de páginas deben almacenarse en algún lugar, por lo que utilizan parte de la memoria física, lo que puede ser un problema en dispositivos con una pequeña cantidad de RAM. <br><br>  Sin embargo, en x86_64 podemos usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enormes páginas de</a> 2 MiB para mostrar en lugar del tamaño predeterminado de 4 KiB.  Por lo tanto, para mostrar 32 GiB de memoria física, solo se requieren 132 KiB por tabla de páginas: solo una tabla de tercer nivel y 32 tablas de segundo nivel.  Las páginas enormes también se almacenan en caché de manera más eficiente porque usan menos entradas en el búfer de traducción dinámica (TLB). <br><br><a name="2_4"></a><h3>  Exhibición temporal </h3><br>  Para dispositivos con muy poca memoria física, solo puede <b>mostrar tablas de páginas temporalmente</b> cuando necesita acceder a ellas.  Para comparaciones temporales, se requiere una visualización idéntica de solo la tabla de primer nivel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00a/3ab/5ce/00a3ab5ce85057d3679a48379d3d2297.svg"></div><br><br>  En esta figura, una tabla de nivel 1 gestiona los primeros 2 MiB de espacio de direcciones virtuales.  Esto es posible porque el acceso desde el registro CR3 es a través de cero entradas en las tablas de los niveles 4, 3 y 2. El registro con el índice <code>8</code> traduce la página virtual a <code>32 KiB</code> en un marco físico a <code>32 KiB</code> , identificando así la tabla del nivel 1. En la figura, esto se muestra con una flecha horizontal. <br><br>  Al escribir en la tabla de nivel 1 asignada de forma idéntica, nuestro núcleo puede crear hasta 511 comparaciones de tiempo (512 menos el registro necesario para el mapeo de identidad).  En el ejemplo anterior, el núcleo crea dos comparaciones de tiempo: <br><br><ul><li>  Asignación de una entrada nula en una tabla de nivel 1 a un marco a <code>24 KiB</code> .  Esto crea un mapeo temporal de la página virtual en <code>0 KiB</code> al marco físico de la tabla de nivel de página 2 indicado por la flecha punteada. </li><li>  Coincide con el noveno registro de una tabla de nivel 1 con un marco a <code>4 KiB</code> .  Esto crea un mapeo temporal de la página virtual a <code>36 KiB</code> al marco físico de la tabla de nivel 4 de página indicado por la flecha punteada. </li></ul><br>  Ahora el núcleo puede acceder a una tabla de nivel 2 escribiendo en una página que comienza en <code>0 KiB</code> y a una tabla de nivel 4 escribiendo en una página que comienza en <code>33 KiB</code> . <br><br>  Por lo tanto, el acceso a un marco arbitrario de la tabla de páginas con asignaciones temporales consta de las siguientes acciones: <br><br><ul><li>  Encuentre una entrada gratuita en la tabla de nivel 1 que se muestra idénticamente. <br></li><li>  Asigne esta entrada al marco físico de la tabla de páginas a la que queremos acceder. <br></li><li>  Acceda a este marco a través de la página virtual asociada con la entrada. <br></li><li>  Vuelva a establecer el registro como no utilizado, eliminando así la asignación temporal. </li></ul><br>  Con este enfoque, el espacio de direcciones virtuales permanece limpio, ya que las mismas 512 páginas virtuales se usan constantemente.  La desventaja es algo engorroso, especialmente porque una nueva comparación puede requerir cambiar varios niveles de la tabla, es decir, necesitamos repetir el proceso descrito varias veces. <br><br><a name="2_5"></a><h3>  Tablas de página recursivas </h3><br>  Otro enfoque interesante que no requiere tablas de páginas adicionales es la <b>coincidencia recursiva</b> . <br><br>  La idea es traducir algunos registros de la tabla de cuarto nivel en ella misma.  Por lo tanto, en realidad reservamos una parte del espacio de direcciones virtuales y asignamos todos los marcos de tabla actuales y futuros a este espacio. <br><br>  Veamos un ejemplo para entender cómo funciona todo esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  La única diferencia con el ejemplo al principio del artículo es un registro adicional con el índice <code>511</code> en la tabla de nivel 4, que se asigna al marco físico <code>4 KiB</code> , que se encuentra en esta tabla. <br><br>  Cuando la CPU pasa a este registro, no se refiere a la tabla de nivel 3, sino que nuevamente se refiere a la tabla de nivel 4. Esto es similar a una función recursiva que se llama a sí misma.  Es importante que el procesador asuma que cada entrada en la tabla de nivel 4 apunta a una tabla de nivel 3, por lo que ahora trata la tabla de nivel 4 como una tabla de nivel 3. Esto funciona porque las tablas de todos los niveles en x86_64 tienen la misma estructura. <br><br>  Al seguir un registro recursivo una o más veces antes de comenzar la conversión real, podemos reducir efectivamente el número de niveles por los que pasa el procesador.  Por ejemplo, si seguimos el registro recursivo una vez, y luego vamos a la tabla de nivel 3, el procesador piensa que la tabla de nivel 3 es una tabla de nivel 2. Continuando, considera la tabla de nivel 2 como una tabla de nivel 1, y la tabla de nivel 1 como asignada marco en la memoria física.  Esto significa que ahora podemos leer y escribir en la tabla de nivel de página 1 porque el procesador piensa que este es un marco mapeado.  La siguiente figura muestra los cinco pasos de dicha traducción: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  Del mismo modo, podemos seguir una entrada recursiva dos veces antes de comenzar la conversión para reducir el número de niveles pasados ​​a dos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Veamos este procedimiento paso a paso.  Primero, la CPU sigue una entrada recursiva en la tabla de nivel 4 y piensa que ha alcanzado la tabla de nivel 3. Luego sigue el registro recursivo nuevamente y piensa que ha alcanzado el nivel 2. Pero en realidad todavía está en el nivel 4. Luego la CPU va a la nueva dirección y entra en la tabla de nivel 3, pero cree que ya está en la tabla de nivel 1. Finalmente, en el siguiente punto de entrada en la tabla de nivel 2, el procesador cree que ha accedido al marco de memoria física.  Esto nos permite leer y escribir en una tabla de nivel 2. <br><br>  También se accede a las tablas de los niveles 3 y 4. Para acceder a la tabla del nivel 3, seguimos un registro recursivo tres veces: el procesador cree que ya está en la tabla del nivel 1, y en el siguiente paso llegamos al nivel 3, que la CPU considera como un marco mapeado.  Para acceder a la tabla de nivel 4, simplemente seguimos el registro recursivo cuatro veces hasta que el procesador procese la tabla de nivel 4 como un marco mapeado (en azul en la figura a continuación). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  El concepto es difícil de entender al principio, pero en la práctica funciona bastante bien. <br><br><h4>  Cálculo de dirección </h4><br>  Por lo tanto, podemos acceder a las tablas de todos los niveles siguiendo un registro recursivo una o más veces.  Dado que los índices en tablas de cuatro niveles se derivan directamente de la dirección virtual, se deben crear direcciones virtuales especiales para este método.  Como recordamos, los índices de la tabla de páginas se extraen de la dirección de la siguiente manera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Supongamos que queremos acceder a una tabla de nivel 1 que muestra una página específica.  Como aprendimos anteriormente, debe pasar por un registro recursivo una vez, y luego a través de los índices de los niveles 4º, 3º y 2º.  Para hacer esto, movemos todos los bloques de direcciones un bloque a la derecha y establecemos el índice del registro recursivo en el lugar del índice inicial del nivel 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Para acceder a la tabla de nivel 2 de esta página, movemos todos los bloques de índice dos bloques a la derecha y establecemos el índice recursivo en el lugar de ambos bloques de origen: nivel 4 y nivel 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Para acceder a la tabla de nivel 3, hacemos lo mismo, solo nos desplazamos a la derecha con tres bloques de direcciones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Finalmente, para acceder a la tabla de nivel 4, mueva todo cuatro bloques a la derecha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Ahora puede calcular direcciones virtuales para tablas de páginas de los cuatro niveles.  Incluso podemos calcular una dirección que apunta exactamente a una entrada específica de la tabla de páginas multiplicando su índice por 8, el tamaño de la entrada de la tabla de páginas. <br><br>  La siguiente tabla muestra la estructura de direcciones para acceder a varios tipos de marcos: <br><br><table><thead><tr><th>  Dirección virtual para </th><th>  Estructura de direcciones ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">octal</a> ) </th></tr></thead><tbody><tr><td>  Pagina </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Entrada en la mesa de nivel 1 </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Entrada en una mesa de nivel 2 </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Entrada en una mesa de nivel 3 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Entrada en la mesa del nivel 4 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Aquí <code></code> es el índice de nivel 4, <code></code> es el nivel 3, <code></code> es el nivel 2 y <code>DDD</code> es el índice de nivel 1 para el cuadro visualizado, <code>EEEE</code> es su desplazamiento.  <code>RRR</code> es el índice del registro recursivo.  Un índice (tres dígitos) se convierte en un desplazamiento (cuatro dígitos) al multiplicar por 8 (el tamaño de la entrada de la tabla de páginas).  Con este desplazamiento, la dirección resultante apunta directamente a la entrada de la tabla de páginas correspondiente. <br><br>  <code>SSSS</code> son bits de expansión del dígito firmado, es decir, son todas copias del bit 47. Este es un requisito especial para las direcciones válidas en la arquitectura x86_64, que discutimos en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo anterior</a> . <br><br>  Las direcciones son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">octales</a> , ya que cada carácter octal representa tres bits, lo que le permite separar claramente los índices de tablas de 9 bits en diferentes niveles.  Esto no es posible en el sistema hexadecimal, donde cada carácter representa cuatro bits. <br><br><h4>  Código de óxido </h4><br>  Puede construir tales direcciones en código Rust utilizando operaciones bit a bit: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// the virtual address whose corresponding page tables you want to access let addr: usize = […]; let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12);</span></span></code> </pre> <br>  Este código supone que una asignación recursiva del último registro de nivel 4 con el índice <code>0o777</code> (511) coincide recursivamente.  Actualmente, este no es el caso, por lo que el código aún no funcionará.  Vea a continuación cómo decirle al cargador que configure una asignación recursiva. <br><br>  Como alternativa a la realización manual de operaciones bit a bit, puede usar el tipo <code>RecursivePageTable</code> de la caja <code>x86_64</code> , que proporciona abstracciones seguras para diversas operaciones de tabla.  Por ejemplo, el siguiente código muestra cómo convertir una dirección virtual a su dirección física correspondiente: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. let level_4_table_addr = […]; let level_4_table_ptr = level_4_table_addr as *mut PageTable; let recursive_page_table = unsafe { let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap(); } /// Retrieve the physical address for the given virtual address let addr: u64 = […] let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset()))</span></span></code> </pre> <br>  Nuevamente, este código requiere un mapeo recursivo correcto.  Con esta asignación, el <code>level_4_table_addr</code> faltante <code>level_4_table_addr</code> calcula como en el primer ejemplo de código. <br><br><hr><br>  El mapeo recursivo es un método interesante que muestra cuán poderosa puede ser la correspondencia a través de una sola tabla.  Es relativamente fácil de implementar y requiere una configuración mínima (solo una entrada recursiva), por lo que esta es una buena opción para los primeros experimentos. <br><br>  Pero tiene algunas desventajas: <br><br><ul><li>  Una gran cantidad de memoria virtual (512 GiB).  Esto no es un problema en un gran espacio de direcciones de 48 bits, pero puede conducir a un comportamiento de caché subóptimo. <br></li><li>  Facilita el acceso solo al espacio de direcciones actualmente activo.  El acceso a otros espacios de direcciones todavía es posible cambiando la entrada recursiva, pero se requiere una coincidencia temporal para el cambio.  Describimos cómo hacer esto en un artículo anterior (obsoleto). <br></li><li>  Depende en gran medida del formato de tabla de páginas x86 y puede no funcionar en otras arquitecturas. </li></ul><br><a name="3"></a><h1>  Soporte de arranque </h1><br>  Todos los enfoques descritos anteriormente requieren cambios en las tablas de página y la configuración correspondiente.  Por ejemplo, para mapear la memoria física de forma idéntica o recursiva mapear registros de una tabla de cuarto nivel.  El problema es que no podemos realizar esta configuración sin acceso a las tablas de páginas. <br><br>  Entonces, necesito ayuda del gestor de arranque.  Tiene acceso a las tablas de páginas, por lo que puede crear cualquier pantalla que necesitemos.  En su implementación actual, la caja del <code>bootloader</code> admite los dos enfoques anteriores utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones de carga</a> : <br><br><ul><li>  La función <code>map_physical_memory</code> mapea la memoria física completa en algún lugar del espacio de direcciones virtuales.  Por lo tanto, el kernel obtiene acceso a toda la memoria física y puede aplicar un enfoque con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">visualización de la memoria física completa</a> . <br></li><li>  Usando la función <code>recursive_page_table</code> , el cargador muestra recursivamente una entrada de tabla de página de cuarto nivel.  Esto permite que el núcleo funcione de acuerdo con el método descrito en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sección "Tablas de páginas recursivas"</a> . </li></ul><br>       ,    ,        (      ,     ).           <code>map_physical_memory</code> : <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = { version = "0.4.0", features = ["map_physical_memory"]}</code> </pre> <br>    ,           .      ,    <i> </i> . <br><br><a name="3_1"></a><h3>   </h3><br>  <code>bootloader</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BootInfo</a>   ,  .   ,         , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  semver</a> .       : <code>memory_map</code>  <code>physical_memory_offset</code> : <br><br><ul><li>  <code>memory_map</code>     .   ,             ,   VGA.       BIOS  UEFI,       .       ,          .        . <br></li><li> <code>physical_memory_offset</code>       .      ,     .         . </li></ul><br>     <code>BootInfo</code>    <code>&amp;'static BootInfo</code>   <code>_start</code> .  : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument […] }</span></span></code> </pre> <br>     ,            . <br><br><a name="3_2"></a><h3>    </h3><br>   <code>_start</code>    ,     .  ,           ,           . <br><br>  ,        ,  <code>bootloader</code>   <code>entry_point</code> .       : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] }</span></span></code> </pre> <br>        <code>extern "C"</code>  <code>no_mangle</code> ,            <code>_start</code> .  <code>kernel_main</code>      Rust,        .  ,     ,      , ,       ,     <br><br><a name="4"></a><h1>  </h1><br>          , ,   . -,     ,    .      ,    ,     .       ,    . <br><br>        <code>memory</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br>      <code>src/memory.rs</code> . <br><br><a name="4_1"></a><h3>     </h3><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>      ,    ,        ,     <code>CR3</code> .       :  <code>active_level_4_table</code>         : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::PageTable; /// Returns a mutable reference to the active level 4 table. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable { use x86_64::{registers::control::Cr3, VirtAddr}; let (level_4_table_frame, _) = Cr3::read(); let phys = level_4_table_frame.start_address(); let virt = VirtAddr::new(phys.as_u64() + physical_memory_offset); let page_table_ptr: *mut PageTable = virt.as_mut_ptr(); &amp;mut *page_table_ptr // unsafe }</span></span></code> </pre> <br>       4-    <code>CR3</code> .           ,  <code>physical_memory_offset</code> . ,      <code>*mut PageTable</code>  <code>as_mut_ptr</code> ,        <code>&amp;mut PageTable</code> .    <code>&amp;mut</code>  <code>&amp;</code> ,           . <br><br>      unsafe,   Rust    <code>unsafe fn</code>     .   ,          .       .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC</a>     Rust. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos usar esta función para generar los registros de la tabla de cuarto nivel:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::active_level_4_table; let l4_table = unsafe { active_level_4_table(boot_info.physical_memory_offset) }; for (i, entry) in l4_table.iter().enumerate() { if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); } } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>   <code>physical_memory_offset</code>     <code>BootInfo</code> .    <code>iter</code>         <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enumerate</a></code>    <code>i</code>   .    ,    512     . <br><br>    ,    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a33/def/50d/a33def50db528880395b665882aabe75.png"><br><br>     ,       .     ,        ,  ,      . <br><br>           ,         : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in the for loop in src/main.rs use x86_64::{structures::paging::PageTable, VirtAddr}; if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); // get the physical address from the entry and convert it let phys = entry.frame().unwrap().start_address(); let virt = phys.as_u64() + boot_info.physical_memory_offset; let ptr = VirtAddr::new(virt).as_mut_ptr(); let l3_table: &amp;PageTable = unsafe { &amp;*ptr }; // print non-empty entries of the level 3 table for (i, entry) in l3_table.iter().enumerate() { if !entry.is_unused() { println!(" L3 Entry {}: {:?}", i, entry); } } }</span></span></code> </pre> <br>          , ,      .     ,     ,      . <br><br>     ,   ,     .             ,       . <br><br><a name="4_2"></a><h3>   </h3><br>            ,     .  ,     : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::{PhysAddr, VirtAddr}; /// Translates the given virtual address to the mapped physical address, or /// `None` if the address is not mapped. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. pub unsafe fn translate_addr(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { translate_addr_inner(addr, physical_memory_offset) }</span></span></code> </pre> <br>      <code>translate_addr_inner</code> ,     .   , Rust    <code>unsafe fn</code>    .    ,       <code>unsafe</code> . <br><br>       : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// Private function that is called by `translate_addr`. /// /// This function is safe to limit the scope of `unsafe` because Rust treats /// the whole body of unsafe functions as an unsafe block. This function must /// only be reachable through `unsafe fn` from outside of this module. fn translate_addr_inner(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { use x86_64::structures::paging::page_table::FrameError; use x86_64::registers::control::Cr3; // read the active level 4 frame from the CR3 register let (level_4_table_frame, _) = Cr3::read(); let table_indexes = [ addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index() ]; let mut frame = level_4_table_frame; // traverse the multi-level page table for &amp;index in &amp;table_indexes { // convert the frame into a page table reference let virt = frame.start_address().as_u64() + physical_memory_offset; let table_ptr: *const PageTable = VirtAddr::new(virt).as_ptr(); let table = unsafe {&amp;*table_ptr}; // read the page table entry and update `frame` let entry = &amp;table[index]; frame = match entry.frame() { Ok(frame) =&gt; frame, Err(FrameError::FrameNotPresent) =&gt; return None, Err(FrameError::HugeFrame) =&gt; panic!("huge pages not supported"), }; } // calculate the physical address by adding the page offset Some(frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br>     <code>active_level_4_table</code>         <code>CR3</code> ,      .  ,    . <br><br>  <code>VirtAddr</code>           .       ,            <code>for</code> .      ,     . <code>frame</code>               , . .     1. <br><br>      <code>physical_memory_offset</code>        .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>PageTableEntry::frame</code></a>    .      ,  <code>None</code> .      2   1 ,      . <br><br> ,      : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; use x86_64::VirtAddr; let addresses = [ // the identity-mapped vga buffer page 0xb8000, // some code page 0x20010a, // some stack page 0x57ac_001f_fe48, // virtual address mapped to physical address 0 boot_info.physical_memory_offset, ]; for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); let phys = unsafe { translate_addr(virt, boot_info.physical_memory_offset) }; println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>    ,   : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0b/e32/db8/a0be32db8b6353452f9d40d7b1d350ad.png"><br><br>   ,     <code>0xb8000</code>      .          ,    ,        .  <code>physical_memory_offset</code>      <code>0</code> ,   ,         .             . <br><br><a name="4_3"></a><h3>  MappedPageTable </h3><br>      —    ,   <code>x86_64</code>    .         ,  <code>translate_addr</code> ,            . <br><br>   —  ,       : <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Mapper</code></a>  ,   . , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>translate_page</code></a>         ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>map_to</code></a>      . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MapperAllSizes</code></a>   <code>Mapper</code>    .  ,   ,      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>translate_addr</code></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>translate</code></a> . </li></ul><br>    ,     .   <code>x86_64</code>   ,  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MappedPageTable</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>RecursivePageTable</code></a> .  ,      -  (,  ).    ,      . <br><br>        <code>physical_memory_offset</code> ,     MappedPageTable.   ,    <code>init</code>   <code>memory</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::structures::paging::{PhysFrame, MapperAllSizes, MappedPageTable}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::PhysAddr; <span class="hljs-comment"><span class="hljs-comment">/// Initialize a new MappedPageTable. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn init(physical_memory_offset: u64) -&gt; impl MapperAllSizes { let level_4_table = active_level_4_table(physical_memory_offset); let phys_to_virt = move |frame: PhysFrame| -&gt; *mut PageTable { let phys = frame.start_address().as_u64(); let virt = VirtAddr::new(phys + physical_memory_offset); virt.as_mut_ptr() }; MappedPageTable::new(level_4_table, phys_to_virt) } // make private unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable {…}</span></span></code> </pre> <br>      <code>MappedPageTable</code>  ,       .         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>impl Trait</code></a> .    ,       <code>RecursivePageTable</code>    . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MappedPageTable::new</code></a>   :       4   <code>phys_to_virt</code> ,         <code>*mut PageTable</code> .         <code>active_level_4_table</code> .    ,   <code>physical_memory_offset</code>   . <br><br>    <code>active_level_4_table</code>  ,         <code>init</code> . <br><br>    <code>MapperAllSizes::translate_addr</code>     <code>memory::translate_addr</code> ,       <code>kernel_main</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS // new: different imports use blog_os::memory; use x86_64::{structures::paging::MapperAllSizes, VirtAddr}; // new: initialize a mapper let mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let addresses = […]; // same as before for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); // new: use the `mapper.translate_addr` method let phys = mapper.translate_addr(virt); println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>       ,   ,       : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/51d/5ed/d9c/51d5edd9c004e1238b321dee51fdf8b3.png"><br><br>   ,   <code>physical_memory_offset</code>     <code>0x0</code> .      <code>MappedPageTable</code> ,         .         ,   <code>map_to</code> ,       .         <code>memory::translate_addr</code> ,   ,  . <br><br><a name="4_4"></a><h3>    </h3><br>         ,    .         . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>map_to</code></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Mapper</code></a> ,     .  ,     : ,    ; ,     ;          <code>frame_allocator</code> .   ,          ,        . <br><br><h4>  <code>create_example_mapping</code> </h4><br>     —    <code>create_example_mapping</code> ,      <code>0xb8000</code> ,     VGA.    ,      ,     :           ,     . <br><br>  <code>create_example_mapping</code>  : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Page, Size4KiB, Mapper, FrameAllocator}; /// Creates an example mapping for the given page to frame `0xb8000`. pub fn create_example_mapping( page: Page, mapper: &amp;mut impl Mapper&lt;Size4KiB&gt;, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { mapper.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br>     <code>page</code> ,   ,    <code>mapper</code>  <code>frame_allocator</code> .  <code>mapper</code>   <code>Mapper&lt;Size4KiB&gt;</code> ,    <code>map_to</code> .   <code>Size4KiB</code> ,   <code>Mapper</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PageSize</a></code> ,      4 ,       2   1 .      4 ,    <code>Mapper&lt;Size4KiB&gt;</code>   <code>MapperAllSizes</code> . <br><br>     <code>PRESENT</code> ,       ,   <code>WRITABLE</code> ,       .  <code>map_to</code> :      ,     <code>unsafe</code> .     .   «  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . <br><br>  <code>map_to</code>   ,    <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Result</a></code> .      ,     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>expect</code></a>      .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MapperFlush</code></a> ,             (TLB)    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>flush</code></a> .   <code>Result</code> ,     [ <code>#[must_use]</code> ]  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> ,      </a> . <br><br><h4>  <code>FrameAllocator</code> </h4><br>   <code>create_example_mapping</code> ,    <code>FrameAllocator</code> .   ,        ,    .       1    ,       .         ,    3   ,        3, 2  1. <br><br>      ,       .     ,    <code>None</code> .    <code>EmptyFrameAllocator</code>    : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br>    ,        .        ,   ,         1.            , ,    <code>0x1000</code> . <br><br>   ,     <code>0x1000</code> ,       : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory; use x86_64::{structures::paging::Page, VirtAddr}; let mut mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let mut frame_allocator = memory::EmptyFrameAllocator; // map a previously unmapped page let page = Page::containing_address(VirtAddr::new(0x1000)); memory::create_example_mapping(page, &amp;mut mapper, &amp;mut frame_allocator); // write the string `New!` to the screen through the new mapping let page_ptr: *mut u64 = page.start_address().as_mut_ptr(); unsafe { page_ptr.offset(400).write_volatile(0x_f021_f077_f065_f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>       <code>0x1000</code> ,   <code>create_example_mapping</code>      <code>mapper</code>  <code>frame_allocator</code> .    <code>0x1000</code>     VGA,       ,   . <br><br>            <code>400</code> .      ,      VGA      <code>println</code> .   <code>0x_f021_f077_f065_f04e</code> ,    <i>“New!”</i>   .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">«  VGA»</a> ,    VGA   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>write_volatile</code></a> . <br><br>     QEMU,    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/248/1a0/4cf2481a07f40c681954ff4954dce866.png"><br><br>     <code>0x1000</code>     <i>“New!”</i>  . ,        . <br><br>   ,       1   <code>0x1000</code> .     ,        1,  <code>map_to</code>  ,      <code>EmptyFrameAllocator</code>    .  ,   ,     <code>0xdeadbeaf000</code>  <code>0x1000</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] let page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); […] }</span></span></code> </pre> <br>   ,       : <br><br><pre> <code class="plaintext hljs">panicked at 'map_to failed: FrameAllocationFailed', /…/result.rs:999:5</code> </pre> <br>   ,        1,    <code>FrameAllocator</code> .   ,        ? <br><br><a name="4_5"></a><h3>   </h3><br>         .    : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br>  <code>frames</code>      .      <code>alloc</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Iterator::next</code></a> . <br><br>   <code>BootInfoFrameAllocator</code>    <code>memory_map</code> ,       <code>BootInfo</code> .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">« »</a> ,     BIOS/UEFI.         ,      . <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MemoryRegion</code></a> ,    ,    (, ,   . .)   .  ,      ,     <code>BootInfoFrameAllocator</code> . <br><br>  <code>BootInfoFrameAllocator</code>     <code>init_frame_allocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br>         <code>MemoryMap</code>     : <br><br><ul><li> -,   <code>iter</code>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MemoryRegion</code></a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>filter</code></a>      .       ,  ,  ,   (,   )      ,    <code>InUse</code>  .  ,    ,   <code>Usable</code>   - . <br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>map</code></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">range</a>  Rust         . <br></li><li>    :         <code>into_iter</code> ,     4096-    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>step_by</code></a> .  4096  (= 4 ) —   ,      .      ,         .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>flat_map</code></a>  <code>map</code> ,   <code>Iterator&lt;Item = u64&gt;</code>  <code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code> . <br></li><li>         <code>PhysFrame</code> ,    <code>Iterator&lt;Item = PhysFrame&gt;</code> .          <code>BootInfoFrameAllocator</code> . </li></ul><br>      <code>kernel_main</code> ,    <code>BootInfoFrameAllocator</code>  <code>EmptyFrameAllocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); […] }</span></span></code> </pre> <br>              -  <i>“New!”</i>  .    <code>map_to</code>      : <br><br><ul><li>      <code>frame_allocator</code> . <br></li><li>        . <br></li><li>         . <br></li><li>     . </li></ul><br>    <code>create_example_mapping</code> —    ,         .            . <br><br><a name="5"></a><h1>  Resumen </h1><br>              ,   ,    ,      .           . <br><br>             ,    .  <code>bootloader</code>       cargo.        <code>&amp;BootInfo</code>    . <br><br>          ,   ,     <code>MappedPageTable</code>  <code>x86_64</code> .   ,           <code>FrameAllocator</code>   ,  . <br><br><a name="6"></a><h1>  ? </h1><br>          ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445618/">https://habr.com/ru/post/445618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445596/index.html">Consejos y trucos de Kubernetes: páginas de error personalizadas en NGINX Ingress</a></li>
<li><a href="../445600/index.html">[Encuesta y maldad] Hosting, se equivoquen</a></li>
<li><a href="../445602/index.html">PHP Rusia 2019: su "estadio" para el idioma de la primera liga</a></li>
<li><a href="../445608/index.html">Juego terminado: los analistas informan un aumento en el número de ataques DDoS en el segmento de juegos</a></li>
<li><a href="../445612/index.html">Almacenamiento en clúster para pequeños clústeres web basados ​​en drbd + ocfs2</a></li>
<li><a href="../445620/index.html">¿Qué hace un escritor de UX?</a></li>
<li><a href="../445622/index.html">Nuevo en Java 12: The Teeing Collector</a></li>
<li><a href="../445626/index.html">¿Qué tan profundo es la madriguera del conejo? CLRium # 5: recolector de basura</a></li>
<li><a href="../445632/index.html">Del analizador del póster del teatro Python al bot Telegram. Parte 2</a></li>
<li><a href="../445638/index.html">Prácticas para ciegos en el Museo de Arte Moderno de Garaje</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>