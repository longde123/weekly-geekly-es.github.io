<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèΩ üåΩ üßöüèΩ Escribimos un sistema operativo en Rust. Implementando memoria de p√°gina (nuevo) ü•ô üßîüèº üôéüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, descubriremos c√≥mo implementar el soporte de memoria de p√°gina en nuestro n√∫cleo. Primero, estudiaremos varios m√©todos para que los ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos un sistema operativo en Rust. Implementando memoria de p√°gina (nuevo)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445618/">  En este art√≠culo, descubriremos c√≥mo implementar el soporte de memoria de p√°gina en nuestro n√∫cleo.  Primero, estudiaremos varios m√©todos para que los marcos de la tabla de p√°ginas f√≠sicas est√©n disponibles para el n√∫cleo, y discutiremos sus ventajas y desventajas.  Luego implementamos la funci√≥n de traducci√≥n de direcciones y la funci√≥n de crear una nueva asignaci√≥n. <br><br>  Esta serie de art√≠culos publicados en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> .  Si tiene alguna pregunta o problema, abra el ticket correspondiente all√≠.  Todas las fuentes para el art√≠culo est√°n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en este hilo</a> . <br><br>  <i><b>¬øOtro art√≠culo sobre paginaci√≥n?</b></i> <i><br></i>  <i>Si sigue este ciclo, vio el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Memoria de p√°gina: Nivel avanzado"</a> a fines de enero.</i>  <i>Pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">me criticaron</a> por las tablas de p√°ginas recursivas.</i>  <i>Por lo tanto, decid√≠ volver a escribir el art√≠culo, usando un enfoque diferente para acceder a los marcos.</i> <br><a name="habracut"></a><br>  <i>Aqu√≠ hay una nueva opci√≥n.</i>  <i>El art√≠culo todav√≠a explica c√≥mo funcionan las tablas de p√°ginas recursivas, pero utilizamos una implementaci√≥n m√°s simple y poderosa.</i>  <i>No eliminaremos el art√≠culo anterior, pero lo marcaremos como obsoleto y no lo actualizaremos.</i> <i><br><br></i>  <i>¬°Espero que disfrutes la nueva opci√≥n!</i> <br><br><h1>  Contenido </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Actualizaciones de dependencia</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acceso a tablas de p√°ginas.</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapeo de identidad</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapa de desplazamiento fijo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapeo completo de memoria f√≠sica</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Exhibici√≥n temporal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tablas de p√°gina recursivas</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte de arranque</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informaci√≥n de arranque</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Macro de punto de entrada</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci√≥n</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acceso a tablas de p√°ginas.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Traducci√≥n de direcciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Usando MappedPageTable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crea un nuevo mapeo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Selecci√≥n de marco</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Resumen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Que sigue</a> </li></ul><br><a name="1"></a><h1>  Introduccion </h1><br>  Desde el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√∫ltimo art√≠culo,</a> aprendimos sobre los principios de la memoria de paginaci√≥n y c√≥mo funcionan las tablas de p√°ginas de cuatro niveles en <code>x86_64</code> .  Tambi√©n encontramos que el cargador ya configur√≥ la jerarqu√≠a de la tabla de p√°ginas para nuestro n√∫cleo, por lo que el n√∫cleo se ejecuta en direcciones virtuales.  Esto aumenta la seguridad porque el acceso no autorizado a la memoria provoca un error de p√°gina en lugar de cambiar aleatoriamente la memoria f√≠sica. <br><br>  El art√≠culo termin√≥ sin poder acceder a las tablas de p√°ginas de nuestro n√∫cleo, porque est√°n almacenadas en la memoria f√≠sica y el n√∫cleo ya se est√° ejecutando en direcciones virtuales.  Aqu√≠ continuamos con el tema y exploramos diferentes opciones para acceder a los marcos de la tabla de p√°ginas desde el n√∫cleo.  Discutiremos las ventajas y desventajas de cada uno de ellos, y luego elegiremos la opci√≥n adecuada para nuestro n√∫cleo. <br><br>  Se requiere soporte para el cargador de arranque, por lo que lo configuraremos primero.  Luego implementamos una funci√≥n que se ejecuta en toda la jerarqu√≠a de las tablas de p√°ginas para traducir las direcciones virtuales en f√≠sicas.  Finalmente, aprenderemos c√≥mo crear nuevas asignaciones en tablas de p√°ginas y c√≥mo encontrar marcos de memoria no utilizados para crear nuevas tablas. <br><br><a name="1_1"></a><h3>  Actualizaciones de dependencia </h3><br>  Este art√≠culo requiere que registre la versi√≥n 0.4.0 o superior del <code>bootloader</code> y la versi√≥n 0.5.2 o superior <code>x86_64</code> en las dependencias.  Puede actualizar las dependencias en <code>Cargo.toml</code> : <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = "0.4.0" x86_64 = "0.5.2"</code> </pre> <br>  Para ver los cambios en estas versiones, consulte <a href="">el registro del cargador de arranque</a> y el <a href="">registro x86_64</a> . <br><br><a name="2"></a><h1>  Acceso a tablas de p√°ginas. </h1><br>  Acceder a las tablas de p√°ginas desde el n√∫cleo no es tan f√°cil como parece.  Para comprender el problema, eche otro vistazo a la jerarqu√≠a de tablas de cuatro niveles del art√≠culo anterior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  Lo importante es que cada entrada de p√°gina almacena la direcci√≥n <i>f√≠sica</i> de la siguiente tabla.  Esto evita la traducci√≥n de estas direcciones, lo que reduce el rendimiento y conduce f√°cilmente a bucles sin fin. <br><br>  El problema es que no podemos acceder directamente a las direcciones f√≠sicas desde el n√∫cleo, ya que tambi√©n funciona en direcciones virtuales.  Por ejemplo, cuando vamos a la direcci√≥n <code>4 KiB</code> , tenemos acceso a la direcci√≥n <i>virtual</i> <code>4 KiB</code> , y no a la direcci√≥n <i>f√≠sica</i> donde se almacena la tabla de p√°ginas del 4to nivel.  Si queremos acceder a la direcci√≥n f√≠sica de <code>4 KiB</code> , entonces necesitamos usar alguna direcci√≥n virtual, que se traduce en ella. <br><br>  Por lo tanto, para acceder a los marcos de las tablas de p√°ginas, debe asignar algunas p√°ginas virtuales a estos marcos.  Hay diferentes formas de crear tales asignaciones. <br><br><a name="2_1"></a><h3>  Mapeo de identidad </h3><br>  Una soluci√≥n simple es la <b>visualizaci√≥n id√©ntica de todas las tablas de p√°ginas</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  En este ejemplo, vemos la visualizaci√≥n id√©ntica de cuadros.  Las direcciones f√≠sicas de las tablas de p√°ginas son al mismo tiempo direcciones virtuales v√°lidas, por lo que podemos acceder f√°cilmente a las tablas de p√°ginas de todos los niveles, comenzando con el registro CR3. <br><br>  Sin embargo, este enfoque satura el espacio de direcciones virtuales y hace que sea dif√≠cil encontrar grandes √°reas contiguas de memoria libre.  Digamos que queremos crear un √°rea de memoria virtual de 1000 KiB en la figura anterior, por ejemplo, para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mostrar un archivo en la memoria</a> .  No podemos comenzar con la regi√≥n <code>28 KiB</code> , porque descansa en una p√°gina ya ocupada en <code>1004  KiB</code> .  Por lo tanto, tendr√° que buscar m√°s hasta encontrar un fragmento grande adecuado, por ejemplo, con <code>1008  KiB</code> .  Existe el mismo problema de fragmentaci√≥n que en la memoria segmentada. <br><br>  Adem√°s, la creaci√≥n de nuevas tablas de p√°ginas es mucho m√°s complicada, ya que necesitamos encontrar marcos f√≠sicos cuyas p√°ginas correspondientes a√∫n no se utilizan.  Por ejemplo, para nuestro archivo, reservamos un √°rea de 1000 KiB de memoria <i>virtual</i> , comenzando en la direcci√≥n <code>1008  KiB</code> .  Ahora ya no podemos usar ning√∫n marco con una direcci√≥n f√≠sica entre <code>1000  KiB</code> y <code>2008  KiB</code> , porque no se puede mostrar de forma id√©ntica. <br><br><a name="2_2"></a><h3>  Mapa de desplazamiento fijo </h3><br>  Para evitar abarrotar el espacio de direcciones virtuales, puede mostrar las tablas de p√°ginas en un <b>√°rea de memoria separada</b> .  Por lo tanto, en lugar de identificar el mapeo, mapeamos cuadros con un desplazamiento fijo en el espacio de direcciones virtuales.  Por ejemplo, el desplazamiento puede ser 10 TiB: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4a/c8a/5ea/f4ac8a5ea64fd215de176248b5f74e20.svg"><br><br>  Al asignar este rango de memoria virtual √∫nicamente para mostrar tablas de p√°ginas, evitamos los problemas de visualizaci√≥n id√©ntica.  Reservar un √°rea tan grande de espacio de direcciones virtuales solo es posible si el espacio de direcciones virtuales es mucho mayor que el tama√±o de la memoria f√≠sica.  En <code>x86_64</code> esto no es un problema porque el espacio de direcciones de 48 bits es de 256 TiB. <br><br>  Pero este enfoque tiene la desventaja de que al crear cada tabla de p√°ginas, debe crear una nueva asignaci√≥n.  Adem√°s, no permite el acceso a tablas en otros espacios de direcciones, lo que ser√≠a √∫til al crear un nuevo proceso. <br><br><a name="2_3"></a><h3>  Mapeo completo de memoria f√≠sica </h3><br>  Podemos resolver estos problemas <b>mostrando toda la memoria f√≠sica</b> , y no solo los cuadros de la tabla de p√°ginas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/3cf/7df/c393cf7df76515739e1d9274160c4b5d.svg"><br><br>  Este enfoque permite que el n√∫cleo acceda a la memoria f√≠sica arbitraria, incluidos los cuadros de la tabla de p√°ginas de otros espacios de direcciones.  Se reserva un rango de memoria virtual del mismo tama√±o que antes, pero solo no quedan p√°ginas inigualables. <br><br>  La desventaja de este enfoque es que se necesitan tablas de p√°ginas adicionales para mostrar la memoria f√≠sica.  Estas tablas de p√°ginas deben almacenarse en alg√∫n lugar, por lo que utilizan parte de la memoria f√≠sica, lo que puede ser un problema en dispositivos con una peque√±a cantidad de RAM. <br><br>  Sin embargo, en x86_64 podemos usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enormes p√°ginas de</a> 2 MiB para mostrar en lugar del tama√±o predeterminado de 4 KiB.  Por lo tanto, para mostrar 32 GiB de memoria f√≠sica, solo se requieren 132 KiB por tabla de p√°ginas: solo una tabla de tercer nivel y 32 tablas de segundo nivel.  Las p√°ginas enormes tambi√©n se almacenan en cach√© de manera m√°s eficiente porque usan menos entradas en el b√∫fer de traducci√≥n din√°mica (TLB). <br><br><a name="2_4"></a><h3>  Exhibici√≥n temporal </h3><br>  Para dispositivos con muy poca memoria f√≠sica, solo puede <b>mostrar tablas de p√°ginas temporalmente</b> cuando necesita acceder a ellas.  Para comparaciones temporales, se requiere una visualizaci√≥n id√©ntica de solo la tabla de primer nivel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00a/3ab/5ce/00a3ab5ce85057d3679a48379d3d2297.svg"></div><br><br>  En esta figura, una tabla de nivel 1 gestiona los primeros 2 MiB de espacio de direcciones virtuales.  Esto es posible porque el acceso desde el registro CR3 es a trav√©s de cero entradas en las tablas de los niveles 4, 3 y 2. El registro con el √≠ndice <code>8</code> traduce la p√°gina virtual a <code>32 KiB</code> en un marco f√≠sico a <code>32 KiB</code> , identificando as√≠ la tabla del nivel 1. En la figura, esto se muestra con una flecha horizontal. <br><br>  Al escribir en la tabla de nivel 1 asignada de forma id√©ntica, nuestro n√∫cleo puede crear hasta 511 comparaciones de tiempo (512 menos el registro necesario para el mapeo de identidad).  En el ejemplo anterior, el n√∫cleo crea dos comparaciones de tiempo: <br><br><ul><li>  Asignaci√≥n de una entrada nula en una tabla de nivel 1 a un marco a <code>24 KiB</code> .  Esto crea un mapeo temporal de la p√°gina virtual en <code>0 KiB</code> al marco f√≠sico de la tabla de nivel de p√°gina 2 indicado por la flecha punteada. </li><li>  Coincide con el noveno registro de una tabla de nivel 1 con un marco a <code>4 KiB</code> .  Esto crea un mapeo temporal de la p√°gina virtual a <code>36 KiB</code> al marco f√≠sico de la tabla de nivel 4 de p√°gina indicado por la flecha punteada. </li></ul><br>  Ahora el n√∫cleo puede acceder a una tabla de nivel 2 escribiendo en una p√°gina que comienza en <code>0 KiB</code> y a una tabla de nivel 4 escribiendo en una p√°gina que comienza en <code>33 KiB</code> . <br><br>  Por lo tanto, el acceso a un marco arbitrario de la tabla de p√°ginas con asignaciones temporales consta de las siguientes acciones: <br><br><ul><li>  Encuentre una entrada gratuita en la tabla de nivel 1 que se muestra id√©nticamente. <br></li><li>  Asigne esta entrada al marco f√≠sico de la tabla de p√°ginas a la que queremos acceder. <br></li><li>  Acceda a este marco a trav√©s de la p√°gina virtual asociada con la entrada. <br></li><li>  Vuelva a establecer el registro como no utilizado, eliminando as√≠ la asignaci√≥n temporal. </li></ul><br>  Con este enfoque, el espacio de direcciones virtuales permanece limpio, ya que las mismas 512 p√°ginas virtuales se usan constantemente.  La desventaja es algo engorroso, especialmente porque una nueva comparaci√≥n puede requerir cambiar varios niveles de la tabla, es decir, necesitamos repetir el proceso descrito varias veces. <br><br><a name="2_5"></a><h3>  Tablas de p√°gina recursivas </h3><br>  Otro enfoque interesante que no requiere tablas de p√°ginas adicionales es la <b>coincidencia recursiva</b> . <br><br>  La idea es traducir algunos registros de la tabla de cuarto nivel en ella misma.  Por lo tanto, en realidad reservamos una parte del espacio de direcciones virtuales y asignamos todos los marcos de tabla actuales y futuros a este espacio. <br><br>  Veamos un ejemplo para entender c√≥mo funciona todo esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  La √∫nica diferencia con el ejemplo al principio del art√≠culo es un registro adicional con el √≠ndice <code>511</code> en la tabla de nivel 4, que se asigna al marco f√≠sico <code>4 KiB</code> , que se encuentra en esta tabla. <br><br>  Cuando la CPU pasa a este registro, no se refiere a la tabla de nivel 3, sino que nuevamente se refiere a la tabla de nivel 4. Esto es similar a una funci√≥n recursiva que se llama a s√≠ misma.  Es importante que el procesador asuma que cada entrada en la tabla de nivel 4 apunta a una tabla de nivel 3, por lo que ahora trata la tabla de nivel 4 como una tabla de nivel 3. Esto funciona porque las tablas de todos los niveles en x86_64 tienen la misma estructura. <br><br>  Al seguir un registro recursivo una o m√°s veces antes de comenzar la conversi√≥n real, podemos reducir efectivamente el n√∫mero de niveles por los que pasa el procesador.  Por ejemplo, si seguimos el registro recursivo una vez, y luego vamos a la tabla de nivel 3, el procesador piensa que la tabla de nivel 3 es una tabla de nivel 2. Continuando, considera la tabla de nivel 2 como una tabla de nivel 1, y la tabla de nivel 1 como asignada marco en la memoria f√≠sica.  Esto significa que ahora podemos leer y escribir en la tabla de nivel de p√°gina 1 porque el procesador piensa que este es un marco mapeado.  La siguiente figura muestra los cinco pasos de dicha traducci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  Del mismo modo, podemos seguir una entrada recursiva dos veces antes de comenzar la conversi√≥n para reducir el n√∫mero de niveles pasados ‚Äã‚Äãa dos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Veamos este procedimiento paso a paso.  Primero, la CPU sigue una entrada recursiva en la tabla de nivel 4 y piensa que ha alcanzado la tabla de nivel 3. Luego sigue el registro recursivo nuevamente y piensa que ha alcanzado el nivel 2. Pero en realidad todav√≠a est√° en el nivel 4. Luego la CPU va a la nueva direcci√≥n y entra en la tabla de nivel 3, pero cree que ya est√° en la tabla de nivel 1. Finalmente, en el siguiente punto de entrada en la tabla de nivel 2, el procesador cree que ha accedido al marco de memoria f√≠sica.  Esto nos permite leer y escribir en una tabla de nivel 2. <br><br>  Tambi√©n se accede a las tablas de los niveles 3 y 4. Para acceder a la tabla del nivel 3, seguimos un registro recursivo tres veces: el procesador cree que ya est√° en la tabla del nivel 1, y en el siguiente paso llegamos al nivel 3, que la CPU considera como un marco mapeado.  Para acceder a la tabla de nivel 4, simplemente seguimos el registro recursivo cuatro veces hasta que el procesador procese la tabla de nivel 4 como un marco mapeado (en azul en la figura a continuaci√≥n). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  El concepto es dif√≠cil de entender al principio, pero en la pr√°ctica funciona bastante bien. <br><br><h4>  C√°lculo de direcci√≥n </h4><br>  Por lo tanto, podemos acceder a las tablas de todos los niveles siguiendo un registro recursivo una o m√°s veces.  Dado que los √≠ndices en tablas de cuatro niveles se derivan directamente de la direcci√≥n virtual, se deben crear direcciones virtuales especiales para este m√©todo.  Como recordamos, los √≠ndices de la tabla de p√°ginas se extraen de la direcci√≥n de la siguiente manera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Supongamos que queremos acceder a una tabla de nivel 1 que muestra una p√°gina espec√≠fica.  Como aprendimos anteriormente, debe pasar por un registro recursivo una vez, y luego a trav√©s de los √≠ndices de los niveles 4¬∫, 3¬∫ y 2¬∫.  Para hacer esto, movemos todos los bloques de direcciones un bloque a la derecha y establecemos el √≠ndice del registro recursivo en el lugar del √≠ndice inicial del nivel 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Para acceder a la tabla de nivel 2 de esta p√°gina, movemos todos los bloques de √≠ndice dos bloques a la derecha y establecemos el √≠ndice recursivo en el lugar de ambos bloques de origen: nivel 4 y nivel 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Para acceder a la tabla de nivel 3, hacemos lo mismo, solo nos desplazamos a la derecha con tres bloques de direcciones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Finalmente, para acceder a la tabla de nivel 4, mueva todo cuatro bloques a la derecha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Ahora puede calcular direcciones virtuales para tablas de p√°ginas de los cuatro niveles.  Incluso podemos calcular una direcci√≥n que apunta exactamente a una entrada espec√≠fica de la tabla de p√°ginas multiplicando su √≠ndice por 8, el tama√±o de la entrada de la tabla de p√°ginas. <br><br>  La siguiente tabla muestra la estructura de direcciones para acceder a varios tipos de marcos: <br><br><table><thead><tr><th>  Direcci√≥n virtual para </th><th>  Estructura de direcciones ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">octal</a> ) </th></tr></thead><tbody><tr><td>  Pagina </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Entrada en la mesa de nivel 1 </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Entrada en una mesa de nivel 2 </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Entrada en una mesa de nivel 3 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Entrada en la mesa del nivel 4 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Aqu√≠ <code></code> es el √≠ndice de nivel 4, <code></code> es el nivel 3, <code></code> es el nivel 2 y <code>DDD</code> es el √≠ndice de nivel 1 para el cuadro visualizado, <code>EEEE</code> es su desplazamiento.  <code>RRR</code> es el √≠ndice del registro recursivo.  Un √≠ndice (tres d√≠gitos) se convierte en un desplazamiento (cuatro d√≠gitos) al multiplicar por 8 (el tama√±o de la entrada de la tabla de p√°ginas).  Con este desplazamiento, la direcci√≥n resultante apunta directamente a la entrada de la tabla de p√°ginas correspondiente. <br><br>  <code>SSSS</code> son bits de expansi√≥n del d√≠gito firmado, es decir, son todas copias del bit 47. Este es un requisito especial para las direcciones v√°lidas en la arquitectura x86_64, que discutimos en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> . <br><br>  Las direcciones son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">octales</a> , ya que cada car√°cter octal representa tres bits, lo que le permite separar claramente los √≠ndices de tablas de 9 bits en diferentes niveles.  Esto no es posible en el sistema hexadecimal, donde cada car√°cter representa cuatro bits. <br><br><h4>  C√≥digo de √≥xido </h4><br>  Puede construir tales direcciones en c√≥digo Rust utilizando operaciones bit a bit: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// the virtual address whose corresponding page tables you want to access let addr: usize = [‚Ä¶]; let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12);</span></span></code> </pre> <br>  Este c√≥digo supone que una asignaci√≥n recursiva del √∫ltimo registro de nivel 4 con el √≠ndice <code>0o777</code> (511) coincide recursivamente.  Actualmente, este no es el caso, por lo que el c√≥digo a√∫n no funcionar√°.  Vea a continuaci√≥n c√≥mo decirle al cargador que configure una asignaci√≥n recursiva. <br><br>  Como alternativa a la realizaci√≥n manual de operaciones bit a bit, puede usar el tipo <code>RecursivePageTable</code> de la caja <code>x86_64</code> , que proporciona abstracciones seguras para diversas operaciones de tabla.  Por ejemplo, el siguiente c√≥digo muestra c√≥mo convertir una direcci√≥n virtual a su direcci√≥n f√≠sica correspondiente: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. let level_4_table_addr = [‚Ä¶]; let level_4_table_ptr = level_4_table_addr as *mut PageTable; let recursive_page_table = unsafe { let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap(); } /// Retrieve the physical address for the given virtual address let addr: u64 = [‚Ä¶] let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset()))</span></span></code> </pre> <br>  Nuevamente, este c√≥digo requiere un mapeo recursivo correcto.  Con esta asignaci√≥n, el <code>level_4_table_addr</code> faltante <code>level_4_table_addr</code> calcula como en el primer ejemplo de c√≥digo. <br><br><hr><br>  El mapeo recursivo es un m√©todo interesante que muestra cu√°n poderosa puede ser la correspondencia a trav√©s de una sola tabla.  Es relativamente f√°cil de implementar y requiere una configuraci√≥n m√≠nima (solo una entrada recursiva), por lo que esta es una buena opci√≥n para los primeros experimentos. <br><br>  Pero tiene algunas desventajas: <br><br><ul><li>  Una gran cantidad de memoria virtual (512 GiB).  Esto no es un problema en un gran espacio de direcciones de 48 bits, pero puede conducir a un comportamiento de cach√© sub√≥ptimo. <br></li><li>  Facilita el acceso solo al espacio de direcciones actualmente activo.  El acceso a otros espacios de direcciones todav√≠a es posible cambiando la entrada recursiva, pero se requiere una coincidencia temporal para el cambio.  Describimos c√≥mo hacer esto en un art√≠culo anterior (obsoleto). <br></li><li>  Depende en gran medida del formato de tabla de p√°ginas x86 y puede no funcionar en otras arquitecturas. </li></ul><br><a name="3"></a><h1>  Soporte de arranque </h1><br>  Todos los enfoques descritos anteriormente requieren cambios en las tablas de p√°gina y la configuraci√≥n correspondiente.  Por ejemplo, para mapear la memoria f√≠sica de forma id√©ntica o recursiva mapear registros de una tabla de cuarto nivel.  El problema es que no podemos realizar esta configuraci√≥n sin acceso a las tablas de p√°ginas. <br><br>  Entonces, necesito ayuda del gestor de arranque.  Tiene acceso a las tablas de p√°ginas, por lo que puede crear cualquier pantalla que necesitemos.  En su implementaci√≥n actual, la caja del <code>bootloader</code> admite los dos enfoques anteriores utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones de carga</a> : <br><br><ul><li>  La funci√≥n <code>map_physical_memory</code> mapea la memoria f√≠sica completa en alg√∫n lugar del espacio de direcciones virtuales.  Por lo tanto, el kernel obtiene acceso a toda la memoria f√≠sica y puede aplicar un enfoque con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">visualizaci√≥n de la memoria f√≠sica completa</a> . <br></li><li>  Usando la funci√≥n <code>recursive_page_table</code> , el cargador muestra recursivamente una entrada de tabla de p√°gina de cuarto nivel.  Esto permite que el n√∫cleo funcione de acuerdo con el m√©todo descrito en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secci√≥n "Tablas de p√°ginas recursivas"</a> . </li></ul><br>       ,    ,        (      ,     ).           <code>map_physical_memory</code> : <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = { version = "0.4.0", features = ["map_physical_memory"]}</code> </pre> <br>    ,           .      ,    <i> </i> . <br><br><a name="3_1"></a><h3>   </h3><br>  <code>bootloader</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BootInfo</a>   ,  .   ,         , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  semver</a> .       : <code>memory_map</code>  <code>physical_memory_offset</code> : <br><br><ul><li>  <code>memory_map</code>     .   ,             ,   VGA.       BIOS  UEFI,       .       ,          .        . <br></li><li> <code>physical_memory_offset</code>       .      ,     .         . </li></ul><br>     <code>BootInfo</code>    <code>&amp;'static BootInfo</code>   <code>_start</code> .  : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument [‚Ä¶] }</span></span></code> </pre> <br>     ,            . <br><br><a name="3_2"></a><h3>    </h3><br>   <code>_start</code>    ,     .  ,           ,           . <br><br>  ,        ,  <code>bootloader</code>   <code>entry_point</code> .       : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] }</span></span></code> </pre> <br>        <code>extern "C"</code>  <code>no_mangle</code> ,            <code>_start</code> .  <code>kernel_main</code>      Rust,        .  ,     ,      , ,       ,     <br><br><a name="4"></a><h1>  </h1><br>          , ,   . -,     ,    .      ,    ,     .       ,    . <br><br>        <code>memory</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br>      <code>src/memory.rs</code> . <br><br><a name="4_1"></a><h3>     </h3><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>      ,    ,        ,     <code>CR3</code> .       :  <code>active_level_4_table</code>         : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::PageTable; /// Returns a mutable reference to the active level 4 table. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable { use x86_64::{registers::control::Cr3, VirtAddr}; let (level_4_table_frame, _) = Cr3::read(); let phys = level_4_table_frame.start_address(); let virt = VirtAddr::new(phys.as_u64() + physical_memory_offset); let page_table_ptr: *mut PageTable = virt.as_mut_ptr(); &amp;mut *page_table_ptr // unsafe }</span></span></code> </pre> <br>       4-    <code>CR3</code> .           ,  <code>physical_memory_offset</code> . ,      <code>*mut PageTable</code>  <code>as_mut_ptr</code> ,        <code>&amp;mut PageTable</code> .    <code>&amp;mut</code>  <code>&amp;</code> ,           . <br><br>      unsafe,   Rust    <code>unsafe fn</code>     .   ,          .       .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC</a>     Rust. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos usar esta funci√≥n para generar los registros de la tabla de cuarto nivel:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::active_level_4_table; let l4_table = unsafe { active_level_4_table(boot_info.physical_memory_offset) }; for (i, entry) in l4_table.iter().enumerate() { if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); } } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>   <code>physical_memory_offset</code>     <code>BootInfo</code> .    <code>iter</code>         <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enumerate</a></code>    <code>i</code>   .    ,    512     . <br><br>    ,    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a33/def/50d/a33def50db528880395b665882aabe75.png"><br><br>     ,       .     ,        ,  ,      . <br><br>           ,         : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in the for loop in src/main.rs use x86_64::{structures::paging::PageTable, VirtAddr}; if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); // get the physical address from the entry and convert it let phys = entry.frame().unwrap().start_address(); let virt = phys.as_u64() + boot_info.physical_memory_offset; let ptr = VirtAddr::new(virt).as_mut_ptr(); let l3_table: &amp;PageTable = unsafe { &amp;*ptr }; // print non-empty entries of the level 3 table for (i, entry) in l3_table.iter().enumerate() { if !entry.is_unused() { println!(" L3 Entry {}: {:?}", i, entry); } } }</span></span></code> </pre> <br>          , ,      .     ,     ,      . <br><br>     ,   ,     .             ,       . <br><br><a name="4_2"></a><h3>   </h3><br>            ,     .  ,     : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::{PhysAddr, VirtAddr}; /// Translates the given virtual address to the mapped physical address, or /// `None` if the address is not mapped. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. pub unsafe fn translate_addr(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { translate_addr_inner(addr, physical_memory_offset) }</span></span></code> </pre> <br>      <code>translate_addr_inner</code> ,     .   , Rust    <code>unsafe fn</code>    .    ,       <code>unsafe</code> . <br><br>       : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// Private function that is called by `translate_addr`. /// /// This function is safe to limit the scope of `unsafe` because Rust treats /// the whole body of unsafe functions as an unsafe block. This function must /// only be reachable through `unsafe fn` from outside of this module. fn translate_addr_inner(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { use x86_64::structures::paging::page_table::FrameError; use x86_64::registers::control::Cr3; // read the active level 4 frame from the CR3 register let (level_4_table_frame, _) = Cr3::read(); let table_indexes = [ addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index() ]; let mut frame = level_4_table_frame; // traverse the multi-level page table for &amp;index in &amp;table_indexes { // convert the frame into a page table reference let virt = frame.start_address().as_u64() + physical_memory_offset; let table_ptr: *const PageTable = VirtAddr::new(virt).as_ptr(); let table = unsafe {&amp;*table_ptr}; // read the page table entry and update `frame` let entry = &amp;table[index]; frame = match entry.frame() { Ok(frame) =&gt; frame, Err(FrameError::FrameNotPresent) =&gt; return None, Err(FrameError::HugeFrame) =&gt; panic!("huge pages not supported"), }; } // calculate the physical address by adding the page offset Some(frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br>     <code>active_level_4_table</code>         <code>CR3</code> ,      .  ,    . <br><br>  <code>VirtAddr</code>           .       ,            <code>for</code> .      ,     . <code>frame</code>               , . .     1. <br><br>      <code>physical_memory_offset</code>        .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>PageTableEntry::frame</code></a>    .      ,  <code>None</code> .      2   1 ,      . <br><br> ,      : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; use x86_64::VirtAddr; let addresses = [ // the identity-mapped vga buffer page 0xb8000, // some code page 0x20010a, // some stack page 0x57ac_001f_fe48, // virtual address mapped to physical address 0 boot_info.physical_memory_offset, ]; for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); let phys = unsafe { translate_addr(virt, boot_info.physical_memory_offset) }; println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>    ,   : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0b/e32/db8/a0be32db8b6353452f9d40d7b1d350ad.png"><br><br>   ,     <code>0xb8000</code>      .          ,    ,        .  <code>physical_memory_offset</code>      <code>0</code> ,   ,         .             . <br><br><a name="4_3"></a><h3>  MappedPageTable </h3><br>      ‚Äî    ,   <code>x86_64</code>    .         ,  <code>translate_addr</code> ,            . <br><br>   ‚Äî  ,       : <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Mapper</code></a>  ,   . , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>translate_page</code></a>         ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>map_to</code></a>      . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MapperAllSizes</code></a>   <code>Mapper</code>    .  ,   ,      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>translate_addr</code></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>translate</code></a> . </li></ul><br>    ,     .   <code>x86_64</code>   ,  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MappedPageTable</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>RecursivePageTable</code></a> .  ,      -  (,  ).    ,      . <br><br>        <code>physical_memory_offset</code> ,     MappedPageTable.   ,    <code>init</code>   <code>memory</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::structures::paging::{PhysFrame, MapperAllSizes, MappedPageTable}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::PhysAddr; <span class="hljs-comment"><span class="hljs-comment">/// Initialize a new MappedPageTable. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn init(physical_memory_offset: u64) -&gt; impl MapperAllSizes { let level_4_table = active_level_4_table(physical_memory_offset); let phys_to_virt = move |frame: PhysFrame| -&gt; *mut PageTable { let phys = frame.start_address().as_u64(); let virt = VirtAddr::new(phys + physical_memory_offset); virt.as_mut_ptr() }; MappedPageTable::new(level_4_table, phys_to_virt) } // make private unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable {‚Ä¶}</span></span></code> </pre> <br>      <code>MappedPageTable</code>  ,       .         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>impl Trait</code></a> .    ,       <code>RecursivePageTable</code>    . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MappedPageTable::new</code></a>   :       4   <code>phys_to_virt</code> ,         <code>*mut PageTable</code> .         <code>active_level_4_table</code> .    ,   <code>physical_memory_offset</code>   . <br><br>    <code>active_level_4_table</code>  ,         <code>init</code> . <br><br>    <code>MapperAllSizes::translate_addr</code>     <code>memory::translate_addr</code> ,       <code>kernel_main</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS // new: different imports use blog_os::memory; use x86_64::{structures::paging::MapperAllSizes, VirtAddr}; // new: initialize a mapper let mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let addresses = [‚Ä¶]; // same as before for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); // new: use the `mapper.translate_addr` method let phys = mapper.translate_addr(virt); println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>       ,   ,       : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/51d/5ed/d9c/51d5edd9c004e1238b321dee51fdf8b3.png"><br><br>   ,   <code>physical_memory_offset</code>     <code>0x0</code> .      <code>MappedPageTable</code> ,         .         ,   <code>map_to</code> ,       .         <code>memory::translate_addr</code> ,   ,  . <br><br><a name="4_4"></a><h3>    </h3><br>         ,    .         . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>map_to</code></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Mapper</code></a> ,     .  ,     : ,    ; ,     ;          <code>frame_allocator</code> .   ,          ,        . <br><br><h4>  <code>create_example_mapping</code> </h4><br>     ‚Äî    <code>create_example_mapping</code> ,      <code>0xb8000</code> ,     VGA.    ,      ,     :           ,     . <br><br>  <code>create_example_mapping</code>  : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Page, Size4KiB, Mapper, FrameAllocator}; /// Creates an example mapping for the given page to frame `0xb8000`. pub fn create_example_mapping( page: Page, mapper: &amp;mut impl Mapper&lt;Size4KiB&gt;, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { mapper.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br>     <code>page</code> ,   ,    <code>mapper</code>  <code>frame_allocator</code> .  <code>mapper</code>   <code>Mapper&lt;Size4KiB&gt;</code> ,    <code>map_to</code> .   <code>Size4KiB</code> ,   <code>Mapper</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PageSize</a></code> ,      4 ,       2   1 .      4 ,    <code>Mapper&lt;Size4KiB&gt;</code>   <code>MapperAllSizes</code> . <br><br>     <code>PRESENT</code> ,       ,   <code>WRITABLE</code> ,       .  <code>map_to</code> :      ,     <code>unsafe</code> .     .   ¬´  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . <br><br>  <code>map_to</code>   ,    <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Result</a></code> .      ,     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>expect</code></a>      .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MapperFlush</code></a> ,             (TLB)    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>flush</code></a> .   <code>Result</code> ,     [ <code>#[must_use]</code> ]  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> ,      </a> . <br><br><h4>  <code>FrameAllocator</code> </h4><br>   <code>create_example_mapping</code> ,    <code>FrameAllocator</code> .   ,        ,    .       1    ,       .         ,    3   ,        3, 2  1. <br><br>      ,       .     ,    <code>None</code> .    <code>EmptyFrameAllocator</code>    : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br>    ,        .        ,   ,         1.            , ,    <code>0x1000</code> . <br><br>   ,     <code>0x1000</code> ,       : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory; use x86_64::{structures::paging::Page, VirtAddr}; let mut mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let mut frame_allocator = memory::EmptyFrameAllocator; // map a previously unmapped page let page = Page::containing_address(VirtAddr::new(0x1000)); memory::create_example_mapping(page, &amp;mut mapper, &amp;mut frame_allocator); // write the string `New!` to the screen through the new mapping let page_ptr: *mut u64 = page.start_address().as_mut_ptr(); unsafe { page_ptr.offset(400).write_volatile(0x_f021_f077_f065_f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>       <code>0x1000</code> ,   <code>create_example_mapping</code>      <code>mapper</code>  <code>frame_allocator</code> .    <code>0x1000</code>     VGA,       ,   . <br><br>            <code>400</code> .      ,      VGA      <code>println</code> .   <code>0x_f021_f077_f065_f04e</code> ,    <i>‚ÄúNew!‚Äù</i>   .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬´  VGA¬ª</a> ,    VGA   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>write_volatile</code></a> . <br><br>     QEMU,    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/248/1a0/4cf2481a07f40c681954ff4954dce866.png"><br><br>     <code>0x1000</code>     <i>‚ÄúNew!‚Äù</i>  . ,        . <br><br>   ,       1   <code>0x1000</code> .     ,        1,  <code>map_to</code>  ,      <code>EmptyFrameAllocator</code>    .  ,   ,     <code>0xdeadbeaf000</code>  <code>0x1000</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] let page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); [‚Ä¶] }</span></span></code> </pre> <br>   ,       : <br><br><pre> <code class="plaintext hljs">panicked at 'map_to failed: FrameAllocationFailed', /‚Ä¶/result.rs:999:5</code> </pre> <br>   ,        1,    <code>FrameAllocator</code> .   ,        ? <br><br><a name="4_5"></a><h3>   </h3><br>         .    : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br>  <code>frames</code>      .      <code>alloc</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Iterator::next</code></a> . <br><br>   <code>BootInfoFrameAllocator</code>    <code>memory_map</code> ,       <code>BootInfo</code> .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬´ ¬ª</a> ,     BIOS/UEFI.         ,      . <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MemoryRegion</code></a> ,    ,    (, ,   . .)   .  ,      ,     <code>BootInfoFrameAllocator</code> . <br><br>  <code>BootInfoFrameAllocator</code>     <code>init_frame_allocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br>         <code>MemoryMap</code>     : <br><br><ul><li> -,   <code>iter</code>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MemoryRegion</code></a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>filter</code></a>      .       ,  ,  ,   (,   )      ,    <code>InUse</code>  .  ,    ,   <code>Usable</code>   - . <br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>map</code></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">range</a>  Rust         . <br></li><li>    :         <code>into_iter</code> ,     4096-    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>step_by</code></a> .  4096  (= 4 ) ‚Äî   ,      .      ,         .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>flat_map</code></a>  <code>map</code> ,   <code>Iterator&lt;Item = u64&gt;</code>  <code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code> . <br></li><li>         <code>PhysFrame</code> ,    <code>Iterator&lt;Item = PhysFrame&gt;</code> .          <code>BootInfoFrameAllocator</code> . </li></ul><br>      <code>kernel_main</code> ,    <code>BootInfoFrameAllocator</code>  <code>EmptyFrameAllocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); [‚Ä¶] }</span></span></code> </pre> <br>              -  <i>‚ÄúNew!‚Äù</i>  .    <code>map_to</code>      : <br><br><ul><li>      <code>frame_allocator</code> . <br></li><li>        . <br></li><li>         . <br></li><li>     . </li></ul><br>    <code>create_example_mapping</code> ‚Äî    ,         .            . <br><br><a name="5"></a><h1>  Resumen </h1><br>              ,   ,    ,      .           . <br><br>             ,    .  <code>bootloader</code>       cargo.        <code>&amp;BootInfo</code>    . <br><br>          ,   ,     <code>MappedPageTable</code>  <code>x86_64</code> .   ,           <code>FrameAllocator</code>   ,  . <br><br><a name="6"></a><h1>  ? </h1><br>          ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445618/">https://habr.com/ru/post/445618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445596/index.html">Consejos y trucos de Kubernetes: p√°ginas de error personalizadas en NGINX Ingress</a></li>
<li><a href="../445600/index.html">[Encuesta y maldad] Hosting, se equivoquen</a></li>
<li><a href="../445602/index.html">PHP Rusia 2019: su "estadio" para el idioma de la primera liga</a></li>
<li><a href="../445608/index.html">Juego terminado: los analistas informan un aumento en el n√∫mero de ataques DDoS en el segmento de juegos</a></li>
<li><a href="../445612/index.html">Almacenamiento en cl√∫ster para peque√±os cl√∫steres web basados ‚Äã‚Äãen drbd + ocfs2</a></li>
<li><a href="../445620/index.html">¬øQu√© hace un escritor de UX?</a></li>
<li><a href="../445622/index.html">Nuevo en Java 12: The Teeing Collector</a></li>
<li><a href="../445626/index.html">¬øQu√© tan profundo es la madriguera del conejo? CLRium # 5: recolector de basura</a></li>
<li><a href="../445632/index.html">Del analizador del p√≥ster del teatro Python al bot Telegram. Parte 2</a></li>
<li><a href="../445638/index.html">Pr√°cticas para ciegos en el Museo de Arte Moderno de Garaje</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>