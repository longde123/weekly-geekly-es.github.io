<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèæ üîî ‚ôæ Como restaurar v√≠deos do Full Throttle Remastered. Parte 2 ‚ò™Ô∏è üëí üèïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No meu post anterior , falei sobre como extra√≠mos conte√∫do de arquivos FMV de origem e criamos ferramentas para analisar aproximadamente 67 GB de arqu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como restaurar v√≠deos do Full Throttle Remastered. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422367/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1de/374/14c/1de37414cbdd0d9728e11244fd636b5f.png" alt="imagem"></div><br>  No meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">post</a> anterior <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,</a> falei sobre como extra√≠mos conte√∫do de arquivos FMV de origem e criamos ferramentas para analisar aproximadamente 67 GB de arquivos em busca de componentes intermedi√°rios usados ‚Äã‚Äãpara criar FMV.  Essas pe√ßas s√£o a base para a cria√ß√£o de conte√∫do FMV remasterizado e foram usadas como "desenhos de montagem" para iniciar o projeto. <br><br>  Conforme declarado no artigo anterior, o fluxo de trabalho de remasteriza√ß√£o √© dividido em tr√™s ramos: remasteriza√ß√£o de quadros desenhados √† m√£o, remasteriza√ß√£o de modelos 3D e remasteriza√ß√£o de som.  Abaixo, falarei sobre os recursos do fluxo de trabalho e os truques que usamos para automatizar a cria√ß√£o da parte principal do v√≠deo. <br><a name="habracut"></a><br>  Aumentamos o tamanho de todos os quadros desenhados √† m√£o originais para corresponder √† resolu√ß√£o de 4K (3840x2160).  Levando em considera√ß√£o a adi√ß√£o da largura da cena refeita e o fato de o jogo ter sido exibido em pixels n√£o quadrados, isso significava que todos os recursos remasterizados precisavam ser criados em uma resolu√ß√£o de 4440x2400 pixels. <br><br>  Decidimos usar o Adobe Animate para remasterizar todos os quadros FMV desenhados √† m√£o, porque j√° t√≠nhamos um fluxo de trabalho pronto ap√≥s o desenvolvimento do Day of the Tentacle Remastered.  A equipe de artistas dominou bem esse processo, por isso n√£o consideramos outras op√ß√µes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e2/b57/098/3e2b57098e68ff84ee833c7b56a3ad35.gif"></div><br>  <em>Exemplo de remasteriza√ß√£o de um quadro desenhado √† m√£o</em> <br><br>  Os modelos 3D originais dos arquivos estavam no 3D Studio Release 3. Felizmente, as vers√µes modernas do 3D Studio Max foram capazes de importar todos os dados das malhas e dos quadros-chave cinematogr√°ficos usando outro script de automa√ß√£o.  Depois disso, convertemos esse arquivo intermedi√°rio para trabalhar no Autodesk Maya, onde os artistas fazem sua m√°gica de remasteriza√ß√£o. <br><br>  Para dar √†s superf√≠cies das malhas um novo estilo, novos shaders foram aplicados, texturas de alta qualidade foram aplicadas e essas malhas foram significativamente suplementadas para dar ao modelo uma apar√™ncia mais suave.  Al√©m disso, a janela do quadro foi expandida para todas as c√¢meras de entrada de v√≠deo para corresponder √† resolu√ß√£o de trabalho de 4440x2400 pixels, porque a c√¢mera original foi projetada para uma propor√ß√£o mais estreita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df9/949/7bd/df99497bdfb6c540ef07e330cb9142b8.gif"></div><br>  <em>Exemplo de remasteriza√ß√£o de modelos 3D</em> <br><br>  Quanto ao √°udio, conseguimos encontrar a maioria das vers√µes originais de alta qualidade, mas houve exce√ß√µes.  As grava√ß√µes do est√∫dio de dublagem em ingl√™s foram empacotadas em arquivos, mas a dublagem em outros idiomas, contratada por parceiros externos, n√£o estava dispon√≠vel para n√≥s.  Al√©m disso, conseguimos encontrar a m√∫sica original de The Gone Jackals, usada no FMV.  Algumas vers√µes de efeitos sonoros (SFX) foram substitu√≠das por sons mais "apertados" por um tipo de som semelhante. <br><br>  Abaixo est√° um fluxograma que explica aproximadamente como processamos os recursos de origem e os vinculamos ao conte√∫do remasterizado.  Os quadros de v√≠deo originais extra√≠dos (usando o SanExtract.exe) foram usados ‚Äã‚Äãcomo uma "fonte" para compara√ß√£o com todos os arquivos de dados do arquivo morto.  Os arquivos de manifesto de arquivamento s√£o gerados usando uma pesquisa recursiva de todos os dados de arquivamento;  eles foram usados ‚Äã‚Äãpara encontrar rapidamente todos os arquivos exclusivos de um determinado tipo. <br><br>  A ferramenta SanWrangler foi usada para comparar visualmente a "fonte" original de quadros e dados arquivados.  O usu√°rio pode anexar visualmente os arquivos archive aos quadros originais e salv√°-los como um mapa de depend√™ncia no formato XML.  Ap√≥s criar o mapa de depend√™ncia, bastava usar um script Python para gerar automaticamente quadros desenhados manualmente a partir dos recursos originais do arquivo "desenho", bem como "desenhos de montagem" para o Maya 3D.  Esses arquivos se tornaram o ponto de partida para a equipe de artistas, que passou a remasterizar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/fa0/30a/c2dfa030a1899e9fb679ebd17caf1ee2.png"></div><br>  <em>Extraindo recursos originais e criando "desenhos de montagem"</em> <br><br>  Essa foi a primeira de muitas etapas que resultaram na obten√ß√£o de vers√µes remasterizadas do FMV prontas.  Sim, √© claro, agora temos o ponto de partida de todos os arquivos que precisam ser refeitos, mas como conectar todos esses fragmentos? <br><br>  Abaixo, falarei sobre os m√©todos de automa√ß√£o usados ‚Äã‚Äãno fluxo de trabalho de fabrica√ß√£o do FMV.  Esses m√©todos podem ser usados ‚Äã‚Äãn√£o apenas para gerar FMV e aplicar n√£o apenas a um jogo;  Eu acho que eles s√£o bastante universais e podem ser usados ‚Äã‚Äãem muitos aspectos do desenvolvimento de jogos. <br><br>  Como a maioria dos fluxos de trabalho de cria√ß√£o de gr√°ficos, esse processo ser√° iterativo.  Em algum lugar do arquivo de origem, pode haver um bug que precisa ser corrigido pelo artista e, √†s vezes, era necess√°rio reexportar arquivos dependentes de recursos.  Acho que todos n√≥s preferimos que esse trabalho seja feito por um computador, e n√£o por uma pessoa propensa a erros. <br><br>  Sab√≠amos exatamente como o v√≠deo do Full Throttle Remastered deveria parecer e soar, ent√£o precis√°vamos melhorar seus gr√°ficos e sons.  Todos os v√≠deos tiveram que corresponder aos originais, quadro a quadro, incluindo caminhos da c√¢mera, volume do som, movimento panor√¢mico etc.  Para conseguir isso, precis√°vamos saber como era o fluxo de trabalho da cria√ß√£o de FMVs originais.  E esses 67 GB de dados dos arquivos da LucasArts continham muitas pistas sobre como tudo funcionava no original.  Eles foram um √≥timo come√ßo para n√≥s. <br><br><h1>  O processo de cria√ß√£o do FMV original </h1><br>  Pode parecer um pouco nost√°lgico, mas acho importante discutir os aspectos da "arqueologia digital" dessa remasteriza√ß√£o de jogos.  No final, entender o processo de cria√ß√£o do original permitir√° que voc√™ responda muitas perguntas e d√™ dicas sobre como os recursos se transformaram em um resultado final.  E ao criar novos FMVs refeitos, precisamos aplicar as mesmas transforma√ß√µes aos nossos recursos remasterizados originais, para que o produto final pare√ßa o mais pr√≥ximo poss√≠vel do original.  Incluindo, precis√°vamos do seguinte: <br><br><ul><li>  Localiza√ß√£o das trilhas de √°udio na linha do tempo </li><li>  Configura√ß√µes de volume e pan para faixas de √°udio ao jogar no jogo </li><li>  Composi√ß√£o do quadro e posicionamento de cada quadro de v√≠deo no produto final </li></ul><br>  Uma ferramenta chamada SMUSHFT (SMUSH for Full Throttle) permitiu ao criador do FMV colocar recursos de v√≠deo e √°udio na linha do tempo e depois codificar o filme FMV resultante (no formato .san), que foi lido pelo mecanismo do jogo.  Todos os v√≠deos foram divididos em uma s√©rie de quadros que foram colados para criar o resultado final.  O SMUSHFT permitiu ao usu√°rio mover visualmente esses recursos ao longo da linha do tempo e, se necess√°rio, refazer o v√≠deo. <br><br>  Voc√™ n√£o pode mencionar que eu n√£o participei da cria√ß√£o do jogo original.  Eu s√≥ conseguia adivinhar como os recursos originais foram criados, estudando dados arquivados e analisando formatos e arquivos execut√°veis ‚Äã‚Äãcompactados nesses dados.  Parece que os modelos 3D foram criados no Autodesk 3D Studio Release 3, e as pe√ßas desenhadas √† m√£o foram criadas no DeluxePaint Animation v1.0.  Tamb√©m n√£o sei em que est√°gios a gera√ß√£o de dados de forma de onda para √°udio consistia, mas cada clipe de √°udio usado (no formato .sad) cont√©m informa√ß√µes sobre o volume e o panorama dos quadros-chave, usados ‚Äã‚Äãpara misturar o som durante o jogo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/921/61a/c0392161ae29aa540fe78d7a6485a232.png"></div><br>  <em>O processo de cria√ß√£o do FMV original</em> <br><br>  Depois de criar essas partes separadas do quadro, o processo de combina√ß√£o do quadro foi realizado.  Esse processo combinou renderiza√ß√µes de quadros 3D com quadros de anima√ß√£o desenhados √† m√£o (junto com todo o resto), criando um produto final usado pela ferramenta SMUSHFT (arquivos .nut).  Depois que o projeto estava pronto para a codifica√ß√£o, o v√≠deo foi processado e o resultado final (.san) j√° podia ser reproduzido no mecanismo do jogo. <br><br>  A SMUSHFT executou a codifica√ß√£o final do formato do arquivo do v√≠deo original (.san) e cada arquivo de v√≠deo possu√≠a um arquivo de projeto (.pro) descrevendo a montagem do v√≠deo (som, v√≠deo, localiza√ß√£o das legendas).  Quer√≠amos extrair essas informa√ß√µes para gerar o arquivo de projeto do Adobe Premiere Pro e us√°-lo para codificar a vers√£o convertida do v√≠deo em resolu√ß√£o 4K.  Para fazer isso, precis√°vamos fazer engenharia reversa do arquivo de projeto SMUSHFT. <br><br><h1>  Formatos de arquivo de engenharia reversa </h1><br>  √â √≥timo ter c√≥digo fonte, porque voc√™ pode apenas estud√°-lo e entender como o arquivo do projeto foi criado / lido.  Sem o c√≥digo fonte, √© necess√°rio abrir o arquivo do projeto em um editor hexadecimal e analisar os padr√µes dentro do arquivo.  √â exatamente assim que usamos para extrair conte√∫do √∫til do arquivo de projeto SMUSHFT. <br><br>  Como poder√≠amos executar o SMUSHFT original no DOSBox, vimos a interface do usu√°rio do programa, que nos deu dicas sobre o formato do arquivo.  D√™ uma olhada nesta captura de tela da abertura do arquivo .pro original: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/854/63b/cbb85463b67ad09d81d939f442f9fdc0.png"></div><br>  <em>Projeto SMUSHFT de amostra</em> <br><br>  Aqui voc√™ pode observar o seguinte: existem recursos nomeados no arquivo (2027.NUT, 2027.SAD, IN_06A.NUT, etc.).  Esses recursos nomeados provavelmente exibir√£o caracteres ASCII dentro do arquivo.  Al√©m disso, existem contadores de quadros na parte superior da linha do tempo e, √† esquerda da linha do tempo, h√° um n√∫mero crescente de camadas.  E o √∫ltimo - cada recurso na linha do tempo est√° localizado em um n√∫mero de quadro espec√≠fico e tem uma certa dura√ß√£o.  Se conseguirmos extrair essas informa√ß√µes dos arquivos originais do projeto, ele nos informar√° onde colocar automaticamente novos recursos na linha do tempo do Adobe Premiere Pro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/de5/904/3e5de59049c14a72bb8373a0c72b48a0.png"></div><br>  <em>Projeto de amostra do Adobe Premiere Pro</em> <br><br>  Ao abrir o arquivo do projeto original em um editor hexadecimal, voc√™ pode obter algumas informa√ß√µes bastante √∫teis.  Veja o exemplo acima em hexadecimal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/008/054/b5f00805485c3d4a8af811c4dc359063.png"></div><br>  <em>Arquivo de projeto SMUSHFT no Hex Editor</em> <br><br>  Podemos come√ßar a olhar o arquivo .pro com um editor hexadecimal (prefiro o Hexplorer) e tentar procurar padr√µes.  Voc√™ pode encontrar facilmente recursos nomeados no formato ASCII com um byte zero no final.  Aproximadamente na mesma √°rea de mem√≥ria, h√° um grupo de valores armazenados como curtos (n√∫mero inteiro de dois bytes).  Comparando n√∫meros exibidos no SMUSHFT com <br>  Os n√∫meros do arquivo do projeto em formato hexadecimal nos fornecem a base para a convers√£o correta do arquivo original do projeto em um editor de v√≠deo moderno como o Adobe Premiere Pro. <br><br><h1>  Kit de ferramentas de automa√ß√£o </h1><br>  A maior parte desse fluxo de trabalho foi automatizada e n√£o exigiu interven√ß√£o humana.  Uma das raz√µes para isso foi que o conte√∫do de todos os v√≠deos foi completamente copiado do original;  na verdade, est√°vamos apenas atualizando o conte√∫do.  E, portanto, praticamente n√£o tivemos a oportunidade de alterar completamente o formato FMV.  N√≥s apenas precis√°vamos encontrar uma maneira de recriar o v√≠deo usando recursos de alta resolu√ß√£o, minimizando o tempo gasto no produto. <br><br>  Primeiro, devo dizer que um passo inicial s√©rio antes de automatizar todo o processo deve ser uma conversa com uma equipe de criadores de conte√∫do (gr√°ficos e √°udio).  O motivo √© que a maioria dos processos de automa√ß√£o exige que os criadores sigam um determinado conjunto de regras sobre a prepara√ß√£o de projetos, locais de arquivos, ferramentas usadas etc.  Em nosso projeto, isso significava que t√≠nhamos que discutir ferramentas para criar o conte√∫do de quadros desenhados √† m√£o, modelos 3D e sons e, em seguida, um editor de v√≠deo para reunir tudo isso.  Tamb√©m foi necess√°rio concordar sobre quais partes do fluxo de trabalho ser√£o executadas manualmente e quais ser√£o automatizadas. <br><br>  Como resultado, decidimos o seguinte: <br><br><ul><li>  Os quadros desenhados manualmente ser√£o criados no Adobe Animate com uma resolu√ß√£o de 4440x2400 pixels. </li><li>  Modelos e anima√ß√µes 3D ser√£o criados no Autodesk Maya e renderizados manualmente, tamb√©m com uma resolu√ß√£o de 4440x2400 pixels. </li><li>  Os arquivos de √°udio ser√£o criados no formato .wav com par√¢metros de 48KHz e 16 bits </li><li>  Fragmentos do v√≠deo ser√£o gerados inicialmente automaticamente, e o artista poder√° alterar qualquer parte que ele precisar (com algumas exce√ß√µes) </li><li>  As etapas finais da costura e codifica√ß√£o do FMV ser√£o automatizadas </li></ul><br>  Para tornar as ferramentas o mais automatizadas poss√≠vel, usamos v√°rios m√©todos.  O Python foi escolhido como a "cola" que conecta tudo, porque √© bem expandido por v√°rias bibliotecas, e o c√≥digo √© f√°cil de escrever e manter.  Tamb√©m aproveitamos o suporte interno para manipula√ß√µes de arquivos independentes da plataforma (copiar, mover, excluir). <br><br><h2>  Python - chamando arquivos execut√°veis, obtendo resultados </h2><br>  A biblioteca de subprocessos do Python foi ideal para n√≥s, pois permite alterar a execu√ß√£o de outros arquivos execut√°veis ‚Äã‚Äãe at√© aguardar a conclus√£o de suas tarefas.  Ele permite que voc√™ obtenha o c√≥digo retornado pelo programa e acesse o buffer stdout &amp; stderr. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess <span class="hljs-comment"><span class="hljs-comment"># The command to execute command = 'SanExtract.exe -f -i credits.san -o \"C:/output_dir/\" ' # Execute the command via subprocess child = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) # Wait for process to complete, returns stdout &amp; stderr buffers stdout, stderr = child.communicate() # Retrieve the return code from the process return_code = child.returncode</span></span></code> </pre> <br>  <em>Um exemplo de intera√ß√£o com arquivos execut√°veis ‚Äã‚Äãem Python</em> <br><br><h2>  Python - API do Win32 </h2><br>  A API do Win32 √© muito √∫til porque nos deu acesso para transmitir mensagens de teclado e mouse do Windows a partir de um script.  Por exemplo, voc√™ pode criar uma fun√ß√£o que clica no mouse em determinadas coordenadas X, Y da tela: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32api <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClickXY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y)</span></span></span><span class="hljs-function">:</span></span> win32api.SetCursorPos((x,y)) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,x,y,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,x,y,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <em>Exemplo de simula√ß√£o de clique em mouse Python</em> <br><br>  Voc√™ pode at√© enviar eventos de pressionamento de tecla para o teclado (com ou sem modificadores): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32api <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32con <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PressKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code, modifierCode=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> modifierCode: win32api.keybd_event(modifierCode, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) win32api.keybd_event(code, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_EXTENDEDKEY | <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) time.sleep(<span class="hljs-number"><span class="hljs-number">0.021</span></span>) win32api.keybd_event(code, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_EXTENDEDKEY | win32con.KEYEVENTF_KEYUP, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> modifierCode: win32api.keybd_event(modifierCode, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_KEYUP, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <em>Exemplo de simula√ß√£o de teclado Python</em> <br><br>  Existem muitas outras possibilidades, mas os exemplos acima realmente ajudaram a alcan√ßar nossos objetivos.  Voc√™ pode enviar eventos do teclado para qualquer programa ativo e ele come√ßar√° a digit√°-los, como se estiv√©ssemos inserindo algo no teclado, incluindo pressionar as teclas de atalho. <br><br><h2>  Python - vis√£o computacional para clicar em bot√µes </h2><br>  A experi√™ncia mais exclusiva foi o uso do software de vis√£o computacional nas ferramentas que n√£o puderam ser automatizadas atrav√©s de scripts internos.  A maioria das ferramentas modernas tem suporte a scripts, mas ainda requer interven√ß√£o do usu√°rio.  Por exemplo, o 3D Studio Max permite executar arquivos MAXScript na linha de comando.  No nosso caso, executamos o script para importar automaticamente o arquivo de malha 3D, ap√≥s o qual o 3D Studio Max √© iniciado automaticamente e exibe a caixa de di√°logo Importar forma, na qual o usu√°rio deve clicar nos bot√µes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/b3e/4f9/ddcb3e4f9a830a8e72d9697eacf19b74.png"></div><br>  <em>Caixa de di√°logo Exemplo de importa√ß√£o de formas</em> <br><br>  Ent√£o - escrevemos um script para automa√ß√£o e agora temos que sentar na frente da tela, pressionando as teclas?  Em vez de ficar sentado no teclado e esperar a janela pop-up aparecer, podemos fazer o script fazer uma captura de tela, usar a liga√ß√£o OpenCV ao Python para encontrar o modelo da imagem do bot√£o e clicar automaticamente nele.  Aqui est√° a apar√™ncia do modelo de imagem para o exemplo descrito acima. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1e/67c/af3/b1e67caf30b4ea94761063bb6ead063c.png"></div><br>  <em>Modelo de imagem para ok_button.png</em> <br><br>  Vale ressaltar que o modelo de imagem cont√©m recursos adicionais (texto para ‚ÄúObjeto √∫nico‚Äù e ‚ÄúObjetos m√∫ltiplos‚Äù).  Isso nos permite obter um resultado de pesquisa mais determin√≠stico.  A seguir, √© apresentado um exemplo de script Python usado para clicar automaticamente em um local encontrado de um modelo de imagem: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ImageGrab <span class="hljs-comment"><span class="hljs-comment"># "Constants" TEMPLATE_THRESHOLD = 0.25 CLICK_OFFSET = 20 # Read the template image to search for template_image = cv2.imread('images/ok_button.png', 0) # Screenshot the current desktop and load it to a cv2 format screen = ImageGrab.grab() screen.save('screen.png') screen_image = cv2.imread('screen.png', 0) # Search for the template within the screenshot and retrieve search results match_result = cv2.matchTemplate(screen_image, template_image, cv2.TM_SQDIFF_NORMED) min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(match_result) # If below the threshold, it's likely we know where to click if min_val &lt; TEMPLATE_THRESHOLD: ClickXY(min_loc[0]+CLICK_OFFSET, min_loc[1]+CLICK_OFFSET)</span></span></code> </pre> <br>  <em>Um exemplo de clicar em um elemento de exibi√ß√£o usando OpenCV, escrito em Python</em> <br><br>  Todos os exemplos acima s√£o baseados em Python.  Mas h√° momentos em que precisamos de um controle mais preciso sobre o sistema de janelas do sistema operacional Windows.  Isso nos levou a desenvolver ferramentas nativas usando a API de automa√ß√£o do Windows. <br><br><h2>  Windows Native (C ++) - API de automa√ß√£o do Windows </h2><br>  A API de automa√ß√£o do Windows fornece acesso √† API de acessibilidade ativa da Microsoft (MSAA) herdada, bem como √† API de automa√ß√£o de interface do usu√°rio da Microsoft.  Voc√™ pode ler mais sobre isso na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√°gina da Microsoft</a> . <br><br>  Como resultado, conseguimos obter solicita√ß√µes para determinados elementos da interface do Windows (bot√µes, campos de texto, guias, itens de menu), descobrir onde esses elementos est√£o localizados espacialmente na tela e clicar / interagir com eles.  O Windows SDK tamb√©m possui ferramentas de teste que permitem ver quais propriedades est√£o dispon√≠veis.  Eles nos permitiram descobrir o que pode ser automatizado em cada programa espec√≠fico. <br><br>  O aplicativo Inspect.exe √© bastante √∫til para exibir a hierarquia do gerenciamento de janelas do programa;  fornece uma id√©ia aproximada de onde est√£o localizados objetos, como controles de menu, e como se referir a elementos de janela usando chamadas de API de automa√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f2/d3f/650/0f2d3f650f30c4982f10d9d31b94c35c.png"></div><br>  <em>Exemplo Inspect.exe</em> <br><br>  Depois de aprender a hierarquia de controle do programa Windows, voc√™ saber√° como encontr√°-lo no identificador da janela principal e aprender√° como clicar em diferentes elementos atrav√©s da API: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;WinUser.h&gt; #include &lt;UIAutomation.h&gt; // Click on a sub-menu item given the Window &amp; Menu handles. void ClickSubMenu(HWND hwnd, HMENU hmenu, const char *pMenuName) { // Iterate through the menu items of the window int menu_item_count = GetMenuItemCount(hmenu); for(int menu_id = 0; menu_id &lt; menu_item_count; ++menu_id) { char menu_name[MAX_PATH]; int len = GetMenuString(hmenu, menu_id, reinterpret_cast&lt;LPSTR&gt;(&amp;menu_name[0]), sizeof(menu_name), MF_BYPOSITION); // Look for the specific menu you're searching for and click it // Make sure to set the window active before doing it... if(!strcmp(pMenuName, menu_name)) { // now get the rect and click the center RECT rect; BOOL success = GetMenuItemRect(hwnd, hmenu, menu_id, &amp;rect); if(success) { SetActiveWindow(hwnd); POINT point = GetMiddlePoint(rect); SetCursorPos(point.x, point.y); mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, point.x, point.y, 0, 0); mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTUP, point.x, point.y, 0, 0); Sleep(DO_TASK_INTERVAL_WAIT_MS); } } } }</span></span></span></span></code> </pre> <br>  <em>Um exemplo de como empurrar um controle de janela em C ++</em> <br><br>  E, √© claro, passar as teclas digitadas na janela ativa tamb√©m √© simples: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;WinUser.h&gt; #include &lt;UIAutomation.h&gt; // Type the character string to the given window handle static void TypeCharacters(HWND window_handle, const char *pString) { int len = strlen(pString); for(int count = 0; count &lt; len; ++count) { SendMessage(window_handle, WM_CHAR, (WPARAM)pString[count], (LPARAM)0); Sleep(CHARACTER_REPEAT_INTERVAL_MS); } }</span></span></span></span></code> </pre> <br>  <em>Exemplo de simula√ß√£o de teclado C ++</em> <br><br>  Obviamente, essas APIs t√™m muito mais recursos.  Descobri que, gra√ßas √† ferramenta Inspect.exe, voc√™ pode esclarecer quais elementos da janela do programa podem ser acessados. <br><br><h2>  Formatos de texto intermedi√°rios </h2><br>  Parte do nosso fluxo de trabalho foi salvar os arquivos em formato de texto e alterar os valores nesses arquivos de texto.  No final, as ferramentas possuem uma interface de usu√°rio para alterar o estado dos dados auxiliares.  E se voc√™ sabe quais devem ser esses dados auxiliares, n√£o √© necess√°rio trabalhar com a ferramenta, basta alterar os dados auxiliares.  O truque √© saber como manipular esses dados de suporte;  ao alterar os formatos de arquivo propriet√°rios, isso pode ser um desafio.  N√£o seria legal se todos tivessem um arquivo de texto simples com o qual voc√™ possa trabalhar? <br><br>  O truque √© encontrar uma maneira de contornar os formatos de arquivo propriet√°rios usados ‚Äã‚Äãpela maioria das ferramentas.  A solu√ß√£o geralmente √© usar as op√ß√µes de Importa√ß√£o e Exporta√ß√£o encontradas nas ferramentas comerciais mais modernas.  Aqui est√£o alguns exemplos: <br><br>  O Adobe Premiere Pro salva os arquivos em um formato propriet√°rio, mas voc√™ pode importar / exportar projetos como o Final Cut Pro XML.  Ap√≥s exportar para XML, voc√™ pode alterar o XML da maneira que precisamos e reimportar o projeto novamente para o Adobe Premiere Pro. <br><br>  Outro exemplo √© a corre√ß√£o das refer√™ncias de textura usadas no obsoleto formato de malha 3D do Autodesk 3D Studio Release 3. Ao importar o arquivo de malha original, salvamos a malha rec√©m-convertida em um arquivo .fbx intermedi√°rio usando caracteres ASCII.  Nesse formato, voc√™ pode processar um arquivo de texto e substituir todas as linhas de links de textura pelas corretas. <br><br>  O Adobe Animate / Flash √© muito engra√ßado, pois os arquivos .fla s√£o na verdade um pouco "quebrados". Arquivos zip.  No formato n√£o compactado, eles s√£o armazenados no formato XFL, que pode se referir a outros objetos XFL (por exemplo, bitmaps) de uma pasta local.  O engenheiro chefe da Double Fine, Oliver Franzke, criou um script Python modificado para compactar / descompactar arquivos .fla usando ZIP, para que possamos criar / modificar esses arquivos. <br><br><h1>  Exemplos de uso </h1><br><h2>  3D Studio Max </h2><br>  A vers√£o moderna do 3D Studio Max foi usada para importar o arquivo .prj original para a cena e salvar no formato .CIB do formato ASCII.  Para cada arquivo .prj que precisava ser convertido, um arquivo MaxScript (.ms) era gerado automaticamente a partir do script Python, semelhante √† seguinte: <br><br><pre> <code class="bash hljs">importFile <span class="hljs-string"><span class="hljs-string">"G:\FullThrottle_Backup\FullThrottle_SourceAssets\BENBIKE.PRJ"</span></span> <span class="hljs-comment"><span class="hljs-comment">#noPrompt</span></span></code> </pre> <br>  <em>Exemplo de importa√ß√£o de um modelo 3d usando o MaxScript</em> <br><br>  Depois disso, esse arquivo .ms foi chamado simplesmente pelo comando Python para executar no 3dsmax.exe: <br><br><pre> <code class="bash hljs">3dsmax.exe -U MAXScript <span class="hljs-string"><span class="hljs-string">"C:\FullThrottleRemastered\import_prj.ms"</span></span></code> </pre> <br>  <em>Um exemplo de comando de console para chamar um arquivo execut√°vel com o arquivo MaxScript especificado</em> <br><br>  Como mencionado acima, neste caso, o 3D Studio Max abriu uma caixa de di√°logo na qual voc√™ precisou clicar.  O pacote OpenCV com Python ajudou a clicar no bot√£o nesta janela para que o arquivo original seja importado sem a interven√ß√£o do usu√°rio.  Ap√≥s a importa√ß√£o do arquivo, uma s√©rie de teclas de menu foi pressionada (usando o win32api Python) para iniciar outro arquivo MAXScript, que exportou o modelo como um arquivo .fbx no formato ASCII.  Como .fbx foi salvo como um arquivo de texto normal, todas as depend√™ncias das depend√™ncias de textura do modelo foram substitu√≠das por links para imagens em um formato moderno.  Em seguida, o arquivo .fbx modificado foi novamente carregado automaticamente no 3DSMax e exportado como um arquivo .max.  Nesse ponto, o arquivo .max pode ser enviado ao artista para remasteriza√ß√£o. <br><br><h2>  Adobe Animate / Flash </h2><br>  O Adobe Animate / Flash foi usado para remasterizar todos os recursos FMV desenhados √† m√£o.  Pegamos as molduras originais desenhadas √† m√£o (tamanho 320x200 pixels) encontradas pela ferramenta SanWrangler e as usamos como ‚Äúdesenhos de montagem‚Äù.  A escala da imagem foi ampliada para caber 4440x2400 pixels, ap√≥s o que um arquivo .fla foi gerado automaticamente usando um script Python. <br><br>  Foi o suficiente para gerar automaticamente o arquivo .fla a partir do zero, usando nosso conhecimento do formato XFL Adobe Animate / Flash.  Conseguimos usar o kit de ferramentas j√° criado por Oliver Franzke para gerar desenhos de montagem de arquivos de anima√ß√£o desenhados √† m√£o. <br><br><h2>  Adobe Premiere Pro </h2><br>  A API de automa√ß√£o do Windows realmente nos ajudou a determinar quais controles do Premiere Pro est√£o na tela.  Em alguns casos, eles n√£o tinham teclas de atalho.  Ap√≥s receber as coordenadas dos itens de menu, foi necess√°rio mover o cursor para essas coordenadas e enviar um evento de clique do mouse. <br><br>  Tudo isso √© √≥timo, mas alguns controles s√£o renderizados de outras maneiras e, portanto, s√£o invis√≠veis para a API de automa√ß√£o do Windows.  Nesse caso, decidimos usar um monte de OpenCV e Python para poder usar o OpenCV em um ambiente de script.  Isso foi especialmente √∫til ao trabalhar com o Adobe Premiere Pro: embora tenha suporte parcial para scripts JavaScript, o tipo de controle necess√°rio n√£o estava dispon√≠vel por meio da API. <br><br>  Al√©m disso, os arquivos de projeto do Adobe Premiere Pro s√£o armazenados em um formato bin√°rio propriet√°rio.  Portanto, n√£o pod√≠amos apenas criar magicamente o arquivo do Premiere Pro, mas poder√≠amos usar a fun√ß√£o de importa√ß√£o, o que nos permitia importar os dados para o arquivo do Final Cut Pro, que possui o formato XML.  Depois, bastava gerar o arquivo XML correto, posicionando adequadamente todos os recursos na linha do tempo e depois importar automaticamente esse Final Cut Pro .xml para convert√™-lo no formato desejado.  Em seguida, poder√≠amos colocar os quadros exportados em uma fila automatizada para combin√°-los em um v√≠deo finalizado. <br><br><h1>  Todas as etapas </h1><br>  Abaixo est√° um diagrama de blocos generalizado que mostra todas as partes automatizadas de um novo fluxo de trabalho.  Cada segmento automatizado √© cercado por um ret√¢ngulo arredondado com informa√ß√µes adicionais sobre as t√©cnicas de automa√ß√£o usadas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f26/2c7/7cf/f262c77cf9d06f1fb6828e356ce40cc8.png"></div><br>  <em>Fluxograma de automa√ß√£o FMV remasterizado simplificado</em> <br><br>  Voc√™ notar√° que a maior parte do trabalho com o Adobe Premiere Pro requer o uso de Python, al√©m de c√≥digo nativo especializado do Windows.  O motivo √© a estrutura complexa das janelas do Premiere Pro, bem como a necessidade de usar a API nativa do Windows Automation para garantir a intera√ß√£o adequada com todas as janelas filho dependentes desse aplicativo. <br><br><h1>  Todos juntos </h1><br>  Usando os m√©todos descritos acima, conseguimos configurar v√°rias m√°quinas de automa√ß√£o para dividir o trabalho em todos os v√≠deos em partes.  Al√©m disso, um Slack Bot foi integrado ao fluxo de trabalho para enviar feedback sobre automa√ß√£o ao nosso canal Slack, de acordo com o estado dos v√≠deos que passam pelo pipeline de processamento, para que possamos saber quando algo der errado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/36d/f19/9b536df197475f6235282ac084c2efc8.gif"></div><br>  <em>Exemplo de automa√ß√£o do Adobe Premiere Pro</em> <br><br><h1>  Os problemas que estamos enfrentando </h1><br>  Tudo isso parece √≥timo, mas, de fato, ao implementar o projeto, tivemos problemas.  Vou listar apenas os pontos principais. <br><br>  1) Itera√ß√£o da mistura do √°udio final.  A remasteriza√ß√£o de todos os arquivos de √°udio foi realizada gradualmente.  Portanto, quando tivemos, por exemplo, o efeito sonoro ‚ÄúBOOM!‚Äù, O engenheiro de som n√£o fazia ideia de onde inseri-lo no mix de √°udio; portanto, ele teve que esperar que o v√≠deo fosse codificado para descobrir o que havia dado errado. <br><br>  2) Armazenamento de arquivos intermedi√°rios n√£o compactados.  Os quadros foram armazenados em formato n√£o compactado at√© o √∫ltimo momento da codifica√ß√£o no v√≠deo final.  Portanto, era necess√°rio armazenar um grande n√∫mero de quadros no armazenamento local, alguns dos quais armazenados no sistema de controle de vers√£o.  Esse aumento no volume armazenado foi muito vis√≠vel e pode ser bastante caro ao usar alguns sistemas de controle de vers√£o (usamos o Perforce). <br><br>  3) Prazo de execu√ß√£o.  Uma parte s√≥lida do fluxo de trabalho foi automatizada, e isso permitiu que os engenheiros fizessem outras coisas.  No entanto, o tempo necess√°rio para criar um v√≠deo pode ser bastante longo.  A parte que consome mais tempo √© a codifica√ß√£o de quadros em resolu√ß√£o de 4k.  T√≠nhamos maneiras de investigar o estado dos recursos dentro do Perforce para entender quais etapas precisam ser executadas novamente, mas esse m√©todo n√£o foi dividido em partes como gostar√≠amos. <br><br><h1>  Pr√≥ximas etapas </h1><br>  Sim, o artigo acabou sendo volumoso!  Embora nossa implementa√ß√£o desse fluxo de trabalho seja bastante espec√≠fica para o projeto, acredito que certos m√©todos de automa√ß√£o podem ser usados ‚Äã‚Äãno desenvolvimento de qualquer jogo.  Depois de descobrir o v√≠deo, voc√™ pode considerar um t√≥pico relacionado - tocar FMV durante a execu√ß√£o do jogo.  Isso inclui problemas como a codifica√ß√£o de um fluxo de √°udio multil√≠ngue, bem como a sincroniza√ß√£o de quadros ao reproduzir o FMV original.  Aguarde a terceira parte do artigo! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt422367/">https://habr.com/ru/post/pt422367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt422355/index.html">Jogos ao longo do tempo: acelerando o aplicativo no n√≠vel de percep√ß√£o</a></li>
<li><a href="../pt422357/index.html">Aprendizado profundo para determinar o estilo e o g√™nero das pinturas</a></li>
<li><a href="../pt422361/index.html">S√≠ndrome corporativa</a></li>
<li><a href="../pt422363/index.html">Confer√™ncia PyCon Russia 2018: v√≠deo de todos os relat√≥rios e apresenta√ß√µes</a></li>
<li><a href="../pt422365/index.html">A Yandex apresentou uma queixa contra uma decis√£o judicial para remover links para conte√∫do pirata</a></li>
<li><a href="../pt422369/index.html">Projetando pain√©is para o site de com√©rcio eletr√¥nico de an√°lise da web. Parte 2: Boletins por e-mail. Painel estrat√©gico</a></li>
<li><a href="../pt422371/index.html">Revis√£o da bicicleta el√©trica Twitter TW-E9L</a></li>
<li><a href="../pt422373/index.html">Convidamos voc√™ para reuni√µes de c√≥digo aberto em setembro (Moscou e S√£o Petersburgo)</a></li>
<li><a href="../pt422375/index.html">Os contratos s√£o diferentes ou o que voc√™ se inscreveu</a></li>
<li><a href="../pt422377/index.html">ESP8266 + FLProg - Par√¢metros do sistema do usu√°rio e sincroniza√ß√£o com o servidor de hor√°rio exato</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>