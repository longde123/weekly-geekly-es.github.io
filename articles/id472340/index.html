<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•‹ ğŸ™ğŸ¼ ğŸ§‘ğŸ½â€ğŸ¤â€ğŸ§‘ğŸ» Apakah GraphQL kehilangan relevansi di era HTTP / 2? ğŸ’¨ â›“ï¸ ğŸŒ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Phil Sturgeon baru-baru ini memposting tweet yang banyak memukul penggemar GraphQL. Tweet ini berbicara tentang bagaimana GraphQL, menurut definisi, s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apakah GraphQL kehilangan relevansi di era HTTP / 2?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472340/">  Phil Sturgeon baru-baru ini memposting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://twitter.com/philsturgeon/status/1177804924064804864%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%26ref_url%3Dhttps%253A%252F%252Fcdn.embedly.com%252Fwidgets%252Fmedia.html%253Ftype%253Dtext%25252Fhtml%2526key%253Da19fcc184b9711e1b4764040d3dc5c07%2526schema%253Dtwitter%2526url%253Dhttps%25253A%252F%252Ftwitter.com%252Fphilsturgeon%252Fstatus%252F1177804924064804864%2526image%253Dhttps%25253A%252F%252Fi.embed.ly%252F1%252Fimage%25253Furl%25253D">tweet</a> yang banyak memukul penggemar GraphQL.  Tweet ini berbicara tentang bagaimana GraphQL, menurut definisi, sebuah teknologi yang bertentangan dengan esensi HTTP / 2.  Fakta bahwa standar HTTP / 3 telah dirilis, dan bahwa pembuat tweet tidak benar-benar memahami mereka yang, memilih GraphQL, menempuh jalur ketidakcocokan.  Untuk lebih memahami alasan sikap Phil terhadap GraphQL, lihat materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/f6/_e/s9/f6_es9rltblh2sxhiesno4aznac.jpeg"></a> <br><br>  Sekitar waktu yang sama, sebuah pengumuman dibuat tentang proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vulcain</a> .  Pesan ini termasuk kata-kata: "TL / DR: GraphQL Anda tidak lagi membutuhkan!".  Dan akhirnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> hebat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari</a> Mark Nottingham diterbitkan tentang fitur hebat HTTP / 2 dan apa arti fitur-fitur itu bagi mereka yang mendesain API.  Darrel Miller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://twitter.com/darrel_miller/status/1183425699677376515%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%26ref_url%3Dhttps%253A%252F%252Fcdn.embedly.com%252Fwidgets%252Fmedia.html%253Ftype%253Dtext%25252Fhtml%2526key%253Da19fcc184b9711e1b4764040d3dc5c07%2526schema%253Dtwitter%2526url%253Dhttps%25253A%252F%252Ftwitter.com%252Fdarrel_miller%252Fstatus%252F1183425699677376515%2526image%253Dhttps%25253A%252F%252Fi.embed.ly%252F1%252Fimage%25253Furl%25253D">membagikan</a> tautan ke artikel ini dengan pelanggannya. <br><br>  Apa yang terjadi membuat saya berpikir tentang GraphQL dan HTTP / 2.  Jika semuanya mulai berfungsi menggunakan HTTP / 2 (dan HTTP / 3), apakah ini berarti kita tidak punya alasan untuk menggunakan GraphQL?  Saya ingin mencari tahu hari ini. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">HTTP / 2 inovasi</font> </h2><br>  Untuk memulai, mari cari tahu apa yang ada dalam teknologi HTTP / 2 yang dapat memengaruhi nilai GraphQL di mata pengembang.  HTTP / 2 memiliki banyak hal yang ditawarkan.  Ini, misalnya, format biner baru dan kompresi tajuk yang ditingkatkan.  Namun dalam kasus kami, peran utama dimainkan oleh bagaimana pengiriman permintaan dan tanggapan diproses saat menggunakan HTTP / 2. <br><br>  Membuka koneksi TCP adalah operasi yang mahal.  Klien yang menggunakan HTTP / 1 cenderung tidak sering menjalankannya.  Karena alasan ini, karena beban tambahan yang besar pada sistem, pengembang sering mencoba membatasi jumlah permintaan dengan beralih ke berbagai teknologi.  Ini, misalnya, menjalankan kueri batch, menggunakan bahasa kueri, menyematkan kode CSS / JS dalam kode halaman, menggunakan sprite sheet alih-alih gambar individual, dan sebagainya.  Dalam HTTP / 1.1.  upaya telah dilakukan untuk memecahkan beberapa masalah ini menggunakan koneksi persisten dan pemrosesan data yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disalurkan melalui pipa</a> .  Dua teknologi ini memungkinkan browser mengirim, dalam koneksi yang sama, beberapa permintaan, dan menerima jawaban.  Kerugian dari skema pertukaran data seperti itu adalah bahwa itu tunduk pada masalah pemblokiran awal antrian ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Head-of-line blocking</a> ).  Masalah ini diungkapkan dalam kenyataan bahwa satu permintaan lambat dapat memperlambat pemrosesan semua permintaan yang mengikutinya.  Para ahli yang bekerja pada HTTP / 2 menyarankan berbagai cara untuk menyelesaikan masalah ini.  Bersama dengan protokol biner baru, HTTP / 2 memperkenalkan strategi pengiriman data baru.  Selama interaksi sistem menggunakan protokol HTTP / 2, satu koneksi dibuka, di mana multiplexing permintaan dan respons dilakukan menggunakan tingkat biner baru yang dirancang untuk bekerja dengan frame ketika setiap frame adalah bagian dari aliran.  Dengan menggunakan mekanisme ini, klien dan server dapat membuat ulang aliran permintaan dan respons berdasarkan informasi tentang mereka yang ada dalam bingkai.  Ini memungkinkan HTTP / 2 untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara efektif</a> mendukung pemrosesan banyak permintaan yang dieksekusi dalam satu koneksi. <br><br>  Tapi itu belum semuanya.  HTTP / 2 memiliki konsep baru yang disebut Server Push.  Jika Anda tidak merinci, maka kami dapat mengatakan bahwa teknologi ini memungkinkan server mengirim data ke klien terlebih dahulu, melakukan ini sebelum klien meminta data ini.  Contoh paling mencolok dari perilaku ini adalah mengirimkan stylesheet dan sumber daya JavaScript ke klien terlebih dahulu.  Dalam proses menghasilkan respons terhadap permintaan HTTP, server dapat mengetahui bahwa file CSS tertentu diperlukan untuk membuat halaman HTML, dan mengetahui sebelumnya bahwa klien akan segera menghubunginya untuk file ini.  Ini memungkinkan server untuk mengirim file yang diberikan kepada klien bahkan sebelum klien memintanya.  Ini adalah cara kerja proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vulcain</a> tersebut di atas, menggunakan teknologi ini untuk mengatur pemuatan sumber daya terkait secara efisien. <br><br>  Jadi, sementara semuanya jelas.  Tapi apa hubungannya semua ini dengan GraphQL? <br><br><h2>  <font color="#3AC1EF">GraphQL: satu permintaan yang menyelesaikan semua masalah</font> </h2><br>  Teknologi GraphQL sebagian karena daya tariknya karena membantu pengembang mengatasi kelemahan khas koneksi HTTP / 1. <br><br>  Itulah sebabnya GraphQL memungkinkan pelanggan, dalam satu sesi untuk berkomunikasi dengan server, untuk memenuhi permintaan untuk menerima hampir semua hal.  Ini dapat dikontraskan dengan Hypermedia-API, ketika menggunakan yang biasanya Anda perlu melakukan banyak permintaan jaringan (kadang-kadang, bagaimanapun, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">caching</a> dapat memperbaiki situasi). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f6/f7d/0f7/3f6f7d0f7d89abc5c854fd576e3f32f7.png"></div><br>  <i><font color="#999999">Kemampuan untuk menerima banyak sumber daya dalam satu permintaan tunggal adalah salah satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kekuatan GraphQL</a> , di mana pencipta teknologi ini menarik perhatian pengguna potensial.</font></i> <br><br>  Banyak dari mereka yang mengatakan bahwa tidak ada yang membutuhkan teknologi GraphQL dengan munculnya HTTP / 2 berarti kemungkinan ini.  Menggunakan batch API, bahasa query (seperti GraphQL), mengoptimalkan hubungan, dan bahkan membuat titik akhir yang diperbesar, sekarang terlihat kurang menarik daripada sebelumnya.  Masalahnya adalah "biaya" untuk melakukan kueri menjadi kecil.  Dan itu benar.  Tapi apakah ini hanya mengapa kita menggunakan GraphQL?  Saya kira tidak. <br><br><h2>  <font color="#3AC1EF">Mungkin faktanya adalah bahwa sekarang masih hari-hari awal klien HTTP / 2 dan beberapa aplikasi server?</font> </h2><br>  Saya tidak berpikir bahwa pertanyaan yang diajukan dalam judul bagian ini berfungsi sebagai penjelasan yang layak untuk fakta bahwa kita masih banyak menggunakan GraphQL.  Tapi perlu disebutkan.  Menggunakan tingkat aplikasi HTTP / 2 di beberapa ekosistem adalah tantangan yang masih jauh dari penyelesaian.  Cari, misalnya, kata "Rack / Rails over HTTP / 2."  Itu akan menarik.  Masalahnya adalah bahwa banyak bagian server aplikasi dibangun menggunakan pola permintaan / respons.  Akibatnya, beralih ke konsep aliran HTTP / 2 tidak sesederhana itu.  Terutama - dalam kasus beberapa kerangka kerja.  Tetapi ini adalah alasan yang tidak layak, banyak ekosistem yang secara sempurna mendukung skema interaksi antara klien dan server, dan, secara teori, kita masih harus berusaha untuk meningkatkan interaksi tersebut.  (Kebanyakan proxy juga mendukung ini, tetapi tidak mudah untuk mengatur sesuatu seperti mengirim data ke klien atas inisiatif server jika aplikasi server macet di masa lalu menggunakan pola permintaan / respons). <br><br><h2>  <font color="#3AC1EF">GraphQL lebih dari mengurangi waktu menerima dan mengirimkan data, atau mengoptimalkan jumlah informasi yang dikirim</font> </h2><br>  Meskipun mengurangi waktu menerima dan mengirimkan data dan mengoptimalkan jumlah informasi yang dikirimkan adalah kekuatan GraphQL yang terus-menerus kita dengar, teknologi ini memberi kita lebih banyak. <br><br>  Kekuatan teknologi GraphQL terletak pada fokusnya pada sistem klien.  Klien adalah lingkungan di mana GraphQL membuat banyak kompromi.  Dalam beberapa tahun terakhir, ini telah mengganggu banyak orang.  Jadi, Daniel Jacobson menulis banyak artikel bagus tentang beberapa masalah ini 5-7 tahun yang lalu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sana</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> - beberapa publikasi.  Dia mengatakan di salah satu dari mereka: "API REST kami, meskipun mereka dapat menangani permintaan umum, tidak dioptimalkan untuk semua permintaan ini." <br><br>  Harap dicatat bahwa ide ini valid tidak hanya ketika diterapkan pada teknologi REST.  Aplikasi klien seringkali harus melakukan lebih banyak permintaan server daripada yang diinginkan pengembangnya.  Aplikasi ini harus berurusan dengan penerimaan data yang tidak perlu dari server.  Ini lebih lanjut tentang merancang API yang menyenangkan untuk dibuat sehingga mereka mendukung banyak kegunaan yang berbeda.  Cara yang biasa untuk menyelesaikan masalah ini adalah memiliki logika klien sedekat mungkin dengan logika server.  Contoh dari pendekatan ini adalah adaptor klien Netflix yang disebutkan dalam artikel 2012 ini.  Sejak itu, beberapa tim Netflix bahkan telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beralih</a> ke GraphQL.  Pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BFF</a> juga ditujukan untuk memecahkan masalah tersebut. <br><br>  Teknologi GraphQL mengubah konsep batas antara klien dan server, membantu kami membuat sistem server yang dapat memasukkan informasi tentang bagaimana mereka akan digunakan oleh klien.  Ini cukup jelas dimanifestasikan ketika menggunakan teknologi permintaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konstan</a> , karena di sini kita berbicara, pada dasarnya, tentang sumber daya server yang dihasilkan atas inisiatif klien. <br><br>  Ketika berpikir tentang relevansi GraphQL di dunia HTTP / 2, ingatlah bahwa kita berbicara tentang abstraksi server.  Mendukung berbagai kasus penggunaan data server dapat menyebabkan masalah dalam API berbasis titik akhir tradisional.  GraphQL memungkinkan mereka yang mendukung API untuk berkonsentrasi memberi pengguna API berbagai fitur.  Pada saat yang sama, pemilik API tidak dapat khawatir tentang meningkatnya beban pelanggan yang ada, dan bahwa dukungan untuk API akan menjadi jauh lebih rumit karena kebutuhan untuk mendukung banyak sumber daya yang berbeda.  (Dukungan untuk banyak sumber daya yang berbeda memiliki kelemahannya. Jadi, skema semacam itu mempersulit optimalisasi kinerja. Sumber daya seperti itu tidak selalu di-cache dengan baik. API yang dapat disetel secara ketat menghadapi masalah yang sama). <br><br><h2>  <font color="#3AC1EF">Sistem Klien dan Pengembangan GraphQL</font> </h2><br>  Pada artikel ini, saya terutama berbicara tentang server, tetapi penting untuk diingat bahwa pengembang klien sangat menyukai teknologi GraphQL.  Jika Anda menggabungkan fragmen GraphQL dengan pendekatan komponen dari kerangka front-end modern, Anda mendapatkan abstraksi yang benar-benar luar biasa.  Dan, sekali lagi, jika kita menambahkan kueri konstan di sini, kita dapat mengatakan bahwa GraphQL membuat hidup lebih mudah bagi pengembang sistem klien. <br><br><h2>  <font color="#3AC1EF">GraphQL adalah sistem holistik dengan fitur luar biasa</font> </h2><br>  GraphQL bukanlah sesuatu yang memiliki kemampuan yang sepenuhnya unik.  Ada alternatif untuk sistem ini.  Skema yang diketik?  Sama halnya dengan OpenAPI!  Abstraksi server yang mendukung berbagai kasus penggunaan klien?  Ini dapat diimplementasikan dengan banyak cara.  Introspeksi diri?  Menggunakan Hypermedia memungkinkan klien untuk menemukan tindakan dan mulai bekerja dengan entitas root.  Alat GraphiQL yang Lezat?  Saya yakin sesuatu yang serupa dibuat untuk OpenAPI.  Kemungkinan GraphQL selalu dapat diciptakan kembali menggunakan teknologi lain.  Namun, GraphQL adalah sistem holistik.  Inilah yang menarik banyak pengembang untuk GraphQL yang senang menggunakan sistem ini.  Saya menduga bahwa ini adalah salah satu alasan untuk penyebaran dan pengembangan GraphQL yang cepat.  Selain itu, karena pembangunan GraphQL-API didokumentasikan dengan baik, perpustakaan GraphQL yang dirancang untuk berbagai bahasa biasanya berkualitas tinggi dan populer. <br><br><h2>  <font color="#3AC1EF">Jaringan masih menjadi faktor pembatas (atau mungkin akan selalu seperti ini?)</font> </h2><br>  Inilah pemikiran lain yang ingin saya utarakan.  Ada perasaan bahwa jaringan, ketika harus bekerja dengan API, akan selalu memainkan peran beberapa faktor pembatas.  Tidak masalah seberapa cepat permintaan jaringan.  Itu sebabnya kami tidak mendesain API web dengan cara yang sama seperti objek biasa yang digunakan dalam berbagai bahasa pemrograman.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> , misalnya, kita berbicara tentang mengapa antarmuka dengan tingkat detail yang tinggi tidak terlalu cocok untuk membuat sistem yang dirancang untuk pekerjaan jarak jauh dengannya. <br><br>  Sementara HTTP / 2 jelas mendorong pelaksanaan permintaan dengan rincian tinggi, saya pikir ada beberapa trade-off yang harus dilakukan di sini. <br><br><h2>  <font color="#3AC1EF">Bisakah HTTP / 2 membantu GraphQL?</font> </h2><br>  Jadi, GraphQL memberi pengembang banyak alat penting dan berguna, tetapi HTTP / 2 juga merupakan teknologi yang hebat.  Mari kita melihat ke masa depan dan berpikir tentang manfaat yang dapat dimanfaatkan sistem GraphQL dari menggunakan HTTP / 2.  Misalnya, mungkin terlihat seperti ini: <br><br><pre><code class="plaintext hljs">query {   viewer {     name     posts(first: 100) @stream {       title     }   } }</code> </pre> <br>  Ternyata kita bisa menggunakan abstraksi sisi-server GraphQL, bahasa query deklaratif dari teknologi ini, dan pada saat yang sama menggunakan kemampuan stream HTTP / 2.  Saya pikir soket web digunakan di sini.  Saya masih perlu mencari tahu ini, tapi saya yakin banyak yang sudah menjelajahi arahan GraphQL seperti <code>@defer</code> , <code>@stream</code> dan <code>@stream</code> . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  HTTP / 2 adalah teknologi hebat (dan contoh-contoh yang diberikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> hanyalah semacam keajaiban).  GraphQL hanya dapat dianggap sebagai teknologi yang mengurangi jumlah sesi komunikasi client-server, atau membantu mengoptimalkan volume data yang dikirimkan.  Jika demikian, maka siapa pun yang melihat GraphQL dari perspektif yang sama akan cukup senang menggunakan API berdasarkan kemampuan HTTP / 2.  Namun, jika Anda melihat di GraphQL kombinasi teknologi yang memberikan pengembang banyak hal berguna, menjadi jelas bahwa kekuatan GraphQL sama sekali tidak terbatas pada peningkatan penggunaan sumber daya jaringan dan penghematan lalu lintas. <br><br>  <b>Pembaca yang budiman!</b>  Jika Anda menggunakan teknologi GraphQL, beri tahu kami apa yang paling tidak Anda sukai tentangnya. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472340/">https://habr.com/ru/post/id472340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472320/index.html">Wawancara dengan Zabbix: 12 jawaban jujur</a></li>
<li><a href="../id472326/index.html">Industri luar angkasa kami ... Dan jika Anda melihat masalah industri dari sudut pandang seorang geek?</a></li>
<li><a href="../id472334/index.html">Hidup dengan kupon atau cara kami mengoptimalkan pekerjaan layanan sosial</a></li>
<li><a href="../id472336/index.html">Akselerasi instagram.com. Bagian 3</a></li>
<li><a href="../id472338/index.html">Siapa pembunuh JavaScript?</a></li>
<li><a href="../id472344/index.html">Dua "Sahabat," atau Phlogiston Perang Saudara</a></li>
<li><a href="../id472350/index.html">Bagaimana Methodius menjadi Anna: pengalaman mengembangkan dan meluncurkan pengklasifikasi pesan suara. Bagian 1</a></li>
<li><a href="../id472352/index.html">TechnoText, episode II. Kami memberi tahu bagaimana penulis Habr hidup dan mengerjakan artikel</a></li>
<li><a href="../id472354/index.html">Antara kursi dan monitor duduk kerentanan utama dalam sistem: orang-VAP</a></li>
<li><a href="../id472356/index.html">Microsoft vs IBM: perubahan besar dalam dukungan Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>