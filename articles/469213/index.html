<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§£ #‚É£ üí™üèø Explorando analizadores combinatorios con Rust üë¶üèª ü§∂üèΩ ‚ûï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les presento la traducci√≥n del art√≠culo "Combinadores de analizador de aprendizaje con √≥xido" . 


 Este art√≠culo ense√±a los conceptos b√°si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Explorando analizadores combinatorios con Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469213/"><p>  Hola Habr!  Les presento la traducci√≥n del art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Combinadores de analizador de aprendizaje con √≥xido"</a> . </p><br><p>  <em>Este art√≠culo ense√±a los conceptos b√°sicos de analizadores combinatorios para personas que ya est√°n familiarizadas con Rust.</em>  <em>Se supone que no se requiere ning√∫n otro conocimiento, y se explicar√° todo lo que no est√© directamente relacionado con Rust, as√≠ como algunos aspectos inesperados de su uso.</em>  <em>Este art√≠culo no lo ayudar√° a aprender Rust si a√∫n no lo sabe, y en este caso, lo m√°s probable es que no comprenda bien los analizadores combinatorios.</em>  <em>Si quieres aprender Rust, te recomiendo el libro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Rust Programming Language"</a> .</em> </p><a name="habracut"></a><br><h3 id="s-tochki-zreniya-novichka">  Desde el punto de vista del principiante </h3><br><p>  En la vida de cada programador, llega un momento en que necesita un analizador. </p><br><p>  Un programador novato preguntar√°: "¬øQu√© es un analizador sint√°ctico?" </p><br><p>  El programador de nivel medio dir√°: "Es simple, escribir√© una expresi√≥n regular". </p><br><p>  El maestro programador dir√°: "Al√©jate, s√© que Lex y Yacc". </p><br><p>  Un novato piensa lo mejor de todo. </p><br><p>  No es que las expresiones regulares sean malas.  (Pero, por favor, no intente escribir un analizador complejo como una expresi√≥n regular). No es que no sea divertido usar herramientas poderosas como generadores de analizador y lexer que se han perfeccionado a la perfecci√≥n durante milenios.  Pero aprender los conceptos b√°sicos de los analizadores sint√©ticos es un <em>placer</em> .  Esto tambi√©n es lo que extra√±ar√° si tiene p√°nico cuando usa expresiones regulares o generadores de analizadores, los cuales son solo abstracciones sobre el problema real.  En la mente de un principiante, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">como dijo un hombre</a> , hay muchas posibilidades.  Seg√∫n el experto, solo hay una opci√≥n correcta. </p><br><p>  En este art√≠culo, aprenderemos c√≥mo construir un analizador desde cero con <br>  utilizando un m√©todo com√∫n en lenguajes de programaci√≥n funcional conocidos como <em>analizador combinatorio</em> .  Tienen la ventaja de ser sorprendentemente poderosos tan pronto como captas su idea b√°sica, mientras permanecen muy cerca del principio b√°sico.  Porque las √∫nicas abstracciones aqu√≠ ser√°n aquellas que crees t√∫ mismo.  Los principales combinadores que usar√° aqu√≠ los construir√° usted mismo. </p><br><h3 id="kak-rabotat-s-etoy-statyoy">  C√≥mo trabajar con este art√≠culo </h3><br><p> Se recomienda encarecidamente que comience con un nuevo proyecto Rust y escriba fragmentos de c√≥digo en <code>src/lib.rs</code> medida que lo lee (puede pegarlo directamente desde la p√°gina, pero <code>src/lib.rs</code> mejor, ya que esto garantiza autom√°ticamente que lo leer√° por completo).  Todas las partes del c√≥digo que necesita est√°n organizadas en orden en el art√≠culo.  Tenga en cuenta que a veces se introducen versiones <em>modificadas</em> de funciones que escribi√≥ anteriormente, y en estos casos debe reemplazar la versi√≥n anterior por la nueva. </p><br><p>  El c√≥digo fue escrito para <code>rustc</code> versi√≥n 1.34.0 usando la edici√≥n de idioma <code>2018</code> .  Puede usar cualquier versi√≥n del compilador, aseg√∫rese de estar usando una versi√≥n que admita la edici√≥n <code>2018</code> (aseg√∫rese de que su <code>Cargo.toml</code> contiene <code>edition = "2018"</code> ).  Este proyecto no necesita dependencias externas. </p><br><p>  Para realizar las pruebas presentadas en el art√≠culo, como se esperaba, <code>cargo test</code> . </p><br><h3 id="xcruciating-yazyk-razmetki">  Lenguaje de marcado Xcruciating </h3><br><p>  Vamos a escribir un analizador para una versi√≥n simplificada de XML.  Se ve as√≠: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parent-element</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">single-element</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">attribute</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parent-element</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Los elementos XML se abren con el car√°cter <code>&lt;</code> y un identificador que consiste en una letra seguida de cualquier n√∫mero de letras, n√∫meros y <code>-</code> .  Esto es seguido por espacios y una lista opcional de pares de atributos: otro identificador como se defini√≥ anteriormente, seguido de <code>=</code> y una cadena entre comillas dobles.  Finalmente, hay un s√≠mbolo de cierre <code>/&gt;</code> para indicar un elemento sin elementos secundarios, o <code>&gt;</code> para indicar la existencia de la siguiente secuencia de elementos secundarios, y una etiqueta de cierre que comienza con <code>&lt;/</code> , seguida de un identificador que debe coincidir con la etiqueta de apertura y un s√≠mbolo de cierre <code>&gt;</code> . </p><br><p>  Eso es todo lo que apoyaremos.  No habr√° espacios de nombres, ni nodos de texto, y <em>ciertamente</em> no habr√° verificaci√≥n de esquema.  Ni siquiera tenemos que preocuparnos por escapar de las comillas para las cadenas: comienzan con la primera comilla doble, y terminan con la siguiente, y eso es todo. </p><br><p>  Vamos a analizar estos elementos en una estructura que se ve as√≠: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Clone, Debug, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, attributes: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt;, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Element&gt;, }</code> </pre> <br><p>  No hay tipos sofisticados, solo una cadena para el nombre (este es el identificador al comienzo de cada etiqueta), atributos en forma de pares de cadenas (identificador y valor) y una lista de elementos secundarios que se ven exactamente como los padres. </p><br><p>  (Si est√° imprimiendo, aseg√∫rese de incluir la secci√≥n de <code>derive</code> . La necesitar√° m√°s adelante). </p><br><h3 id="opredelenie-parsera">  Definici√≥n del analizador </h3><br><p>  Bueno, entonces es hora de escribir un analizador. </p><br><p>  El an√°lisis es el proceso de obtener datos estructurados de un flujo de informaci√≥n.  Un analizador es lo que resalta esta estructura. </p><br><p>  En la disciplina que vamos a explorar, el analizador, en su forma m√°s simple, es una funci√≥n que toma alguna entrada y devuelve la salida analizada junto con el resto de la entrada, o un error que dice "No pude analizar esto". </p><br><p>  El analizador tambi√©n se ve en sus formas m√°s complejas.  Puede complicar lo que significan entrada, salida y error, y si necesita buenos mensajes de error que necesita, pero el analizador sigue siendo el mismo: algo que consume entrada y produce alg√∫n tipo de salida analizada junto con qu√© sobrante de la entrada o le permite saber que no puede analizar la entrada a la salida. </p><br><p>  Escrib√°moslo como un tipo de funci√≥n. </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(Input) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(Input, Output), Error&gt;</code> </pre> <br><p>  M√°s espec√≠ficamente: en nuestro caso, queremos completar los tipos y obtener una funci√≥n similar a esta.  Todo lo que vamos a hacer es convertir la cadena a una estructura de <code>Element</code> .  Por el momento, no queremos entrar en los detalles de los mensajes de error, as√≠ que solo devuelva la parte de la l√≠nea que no pudimos analizar.  Como resultado, nuestra funci√≥n se ver√° as√≠: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, Element), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;</code> </pre> <br><p>  Usamos un segmento de cadena porque es un puntero efectivo a un fragmento de una cadena, y luego podemos separarlo como queramos "consumiendo" los datos de entrada, cortando el fragmento analizado y devolviendo el resto junto con el resultado. </p><br><p>  Puede ser m√°s limpio usar <code>&amp;[u8]</code> (un segmento de bytes que coinciden con caracteres ASCII) como tipo de entrada, especialmente porque los segmentos de cadena se comportan de manera un poco diferente a la mayor√≠a de los segmentos, especialmente porque no puede indexarlos con uno n√∫meros de <code>input[0]</code> , debe utilizar el fragmento de <code>input[0..1]</code> .  Por otro lado, tienen muchos m√©todos que son √∫tiles para analizar cadenas que no tienen segmentos de bytes. </p><br><p>  De hecho, confiaremos en m√©todos, no en el uso de √≠ndices de caracteres, porque Unicode.  En UTF-8, y todas las cadenas Rust son cadenas UTF-8 v√°lidas, estos √≠ndices no siempre corresponden a caracteres individuales, y es mejor que todas las partes interesadas soliciten a la biblioteca est√°ndar que solo trabaje con nosotros. </p><br><h3 id="nash-pervyy-parser">  Nuestro primer analizador </h3><br><p>  Intentemos escribir un analizador que solo mire el primer car√°cter de una cadena <br>  y decide si es la letra <code>a</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the_letter_a</span></span></span></span>(input: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, ()), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> input.chars().next() { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-string"><span class="hljs-string">'a'</span></span>) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[<span class="hljs-string"><span class="hljs-string">'a'</span></span>.len_utf8()..], ())), _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } }</code> </pre> <br><p>  Primero, veamos los tipos de entrada y salida: tomamos un segmento de cadena como entrada y devolvemos el <code>Result</code> con <code>(&amp;str, ())</code> , o un error con <code>&amp;str</code> .  El par <code>(&amp;str, ())</code> es un punto interesante: como dijimos que deber√≠amos devolver una tupla del siguiente contenido, <br>  resultado del an√°lisis y el resto de la entrada.  <code>&amp;str</code> es la siguiente entrada, y el resultado es solo un tipo de bloque <code>()</code> , porque si este analizador funciona correctamente, solo puede tener un resultado (encontramos la letra <code>a</code> ), y realmente no necesitamos devolver <br>  la letra <code>a</code> en este caso solo necesitamos indicar que logramos encontrarla. </p><br><p>  Entonces, veamos el c√≥digo del analizador en s√≠.  No bromeamos diciendo que confiando en la biblioteca est√°ndar podemos evitar el dolor de cabeza con Unicode: obtenemos un iterador sobre los caracteres de la cadena usando el m√©todo <code>chars()</code> y tomamos el primer car√°cter de √©l.  Este ser√° un elemento de tipo <code>char</code> envuelto en <code>Option</code> , en el que <code>None</code> significar√° que estamos tratando de extraer <code>char</code> de una cadena vac√≠a. </p><br><p>  Para empeorar las cosas, <code>char</code> no <code>char</code> necesariamente lo que piensas de √©l como un personaje Unicode.  Es probable que esto sea lo que Unicode llama un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"grupo de grafemas"</a> , que puede consistir en varios caracteres, que en realidad son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"valores escalares"</a> , que est√°n dos niveles por debajo de los grupos de grafemas.  Sin embargo, este camino conduce a la locura, y para nuestros prop√≥sitos, honestamente, es poco probable que veamos <code>chars</code> fuera de ASCII, as√≠ que paremos all√≠. </p><br><p>  Asignamos el patr√≥n <code>Some('a')</code> , que es el resultado espec√≠fico que estamos buscando, y si eso coincide, devolvemos nuestro valor de √©xito: <br>  <code>Ok((&amp;input['a'.len_utf8()..], ()))</code> .  Es decir, eliminamos la parte que acabamos de analizar ( <code>'a'</code> ) del segmento de l√≠nea y devolvemos el resto junto con nuestro valor analizado, que est√° vac√≠o <br>  <code>()</code>  Siempre recordando el monstruo Unicode, antes de cortar, descubrimos la longitud en UTF-8 del personaje <code>'a'</code> trav√©s de la biblioteca est√°ndar: es 1 (pero nunca se olvide del monstruo Unicode). </p><br><p>  Si obtenemos alg√∫n otro <code>Some(char)</code> , o si obtenemos <code>None</code> , entonces devolvemos un error.  Como recordar√°, nuestro tipo de error es simplemente un corte de cadena, que pasamos como <code>input</code> y que no se pudo analizar.  No comenz√≥ con <code>a</code> , as√≠ que este es nuestro error.  Esto no es un gran error, pero al menos es un poco mejor que simplemente "algo est√° mal en alguna parte". </p><br><p>  En realidad, no necesitamos este analizador para analizar el XML, pero lo primero que tendremos que hacer es encontrar el car√°cter de apertura <code>&lt;</code> , por lo que necesitamos algo muy similar.  Tambi√©n tendremos que analizar <code>&gt;</code> , <code>/</code> y <code>=</code> espec√≠ficamente, por lo que tal vez podamos hacer una funci√≥n que construya el analizador para el car√°cter que queremos. </p><br><h3 id="sozdanie-parsera">  Crear un analizador </h3><br><p>  Pensemos incluso en esto: escribiremos una funci√≥n que cree un analizador para una cadena est√°tica de <em>cualquier longitud</em> , y no solo un car√°cter.  Esto es a√∫n m√°s simple porque el fragmento de l√≠nea ya es un corte de l√≠nea UTF-8 v√°lido, y no necesitamos pensar en el monstruo Unicode. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">match_literal</span></span></span></span>(expected: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, ()), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> input.get(<span class="hljs-number"><span class="hljs-number">0</span></span>..expected.len()) { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == expected =&gt; { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[expected.len()..], ())) } _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } }</code> </pre> <br><p>  Ahora se ve un poco diferente. </p><br><p>  En primer lugar, veamos los tipos.  Ahora nuestra funci√≥n toma la cadena <code>expected</code> como argumento y <em>devuelve</em> algo similar a un analizador, en lugar de ser un analizador en s√≠.  Esta es una funci√≥n que devuelve <em>una funci√≥n de orden superior</em> .  Esencialmente, estamos escribiendo una funci√≥n que <em>hace una</em> funci√≥n similar a nuestra funci√≥n <code>the_letter_a</code> anteriormente. </p><br><p>  Por lo tanto, en lugar de realizar un trabajo en el cuerpo de la funci√≥n, devolvemos un cierre que realiza este trabajo y que corresponde a la firma de nuestro tipo para el analizador de la anterior. </p><br><p>  La coincidencia de patrones se ve igual, excepto que no podemos hacer coincidir nuestro literal de cadena directamente, porque no sabemos exactamente qu√©, por lo tanto, usamos la condici√≥n de coincidencia <code>if next == expected</code> .  De lo contrario, es exactamente lo mismo que antes, justo dentro del cuerpo del circuito. </p><br><h3 id="testirovanie-nashego-parsera">  Probar nuestro analizador </h3><br><p>  Escribamos una prueba para esto para asegurarnos de que lo hacemos bien. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">literal_parser</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parse_joe = match_literal(<span class="hljs-string"><span class="hljs-string">"Hello Joe!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, ())), parse_joe(<span class="hljs-string"><span class="hljs-string">"Hello Joe!"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">" Hello Robert!"</span></span>, ())), parse_joe(<span class="hljs-string"><span class="hljs-string">"Hello Joe! Hello Robert!"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello Mike!"</span></span>), parse_joe(<span class="hljs-string"><span class="hljs-string">"Hello Mike!"</span></span>) ); }</code> </pre> <br><p>  Primero creamos un analizador: <code>match_literal("Hello Joe!")</code> .  Deber√≠a consumir la cadena <code>"Hello Joe!"</code>  y devuelve el resto de la cadena, o falla y devuelve la cadena completa. </p><br><p>  En el primer caso, simplemente le pasamos la fila exacta que esperamos, y vemos que devuelve una cadena vac√≠a y el valor <code>()</code> , que significa "hemos analizado la cadena esperada, y no necesita que se devuelva". </p><br><p>  En el segundo, alimentamos la cadena <code>"Hello Joe! Hello Robert!"</code>  y vemos que realmente usa la cadena <code>"Hello Joe!"</code>  y devuelve el resto de la entrada: <code>" Hello Robert!"</code>  (liderando el espacio y todo lo dem√°s). </p><br><p>  En el tercero, ingresamos la entrada incorrecta: <code>"Hello Mike!"</code>  y tenga en cuenta que realmente rechaza la entrada con un error.  No es que <code>Mike</code> est√© equivocado, generalmente no es lo que buscaba el analizador. </p><br><h3 id="parser-dlya-chego-to-menee-specifichnogo">  Analizador de algo menos espec√≠fico </h3><br><p>  Entonces esto nos permite analizar <code>&lt;</code> , <code>&gt;</code> , <code>=</code> e incluso <code>&lt;/</code> y <code>/&gt;</code> .  Ya casi hemos terminado! </p><br><p>  El siguiente despu√©s del car√°cter de apertura <code>&lt;</code> es el nombre del elemento.  No podemos hacer esto con una simple comparaci√≥n de cadenas.  Pero <em>podr√≠amos</em> hacerlo con regex ... </p><br><p>  ... pero deteng√°monos.  Esta ser√° una expresi√≥n regular que ser√° muy f√°cil de replicar en c√≥digo simple, y para esto no necesitamos usar el paquete <code>regex</code> .  Veamos si podemos escribir nuestro propio analizador para esto, usando solo la biblioteca est√°ndar Rust. </p><br><p>  Recuerde la regla para el identificador del nombre del elemento, se ve as√≠: un car√°cter alfab√©tico, seguido de cero o m√°s de cualquier s√≠mbolo alfab√©tico, <br>  car√°cter, n√∫mero o gui√≥n. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identifier</span></span></span></span>(input: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> matched = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chars = input.chars(); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> chars.next() { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next.is_alphabetic() =&gt; matched.push(next), _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) = chars.next() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next.is_alphanumeric() || next == <span class="hljs-string"><span class="hljs-string">'-'</span></span> { matched.push(next); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next_index = matched.len(); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[next_index..], matched)) }</code> </pre> <br><p>  Como siempre, primero miramos el tipo.  Esta vez no escribimos una funci√≥n para crear un analizador, simplemente escribimos el analizador en s√≠, como por primera vez.  La diferencia notable aqu√≠ es que, en lugar del tipo de resultado <code>()</code> devolvemos una <code>String</code> en la tupla junto con la entrada restante.  Esta <code>String</code> contendr√° el identificador que acabamos de analizar. </p><br><p>  Con eso en mente, primero creamos una <code>String</code> vac√≠a y la llamamos <code>matched</code> .  Este ser√° nuestro resultado.  Tambi√©n obtenemos un iterador para los caracteres de <code>input</code> , que vamos a comenzar a dividir. </p><br><p>  El primer paso es ver si hay un s√≠mbolo al principio.  Extraemos el primer car√°cter del iterador y verificamos si es una letra: <code>next.is_alphabetic()</code> .  La biblioteca est√°ndar de Rust, por supuesto, nos ayudar√° con Unicode: corresponder√° a letras en cualquier alfabeto, y no solo en ASCII.  Si es una letra, la ponemos en nuestra cadena en la variable <code>matched</code> , y si no, no miramos el identificador del elemento e inmediatamente regresamos con un error. </p><br><p>  En el segundo paso, continuamos sacando los caracteres del iterador, envi√°ndolos a la l√≠nea que creamos hasta que <code>is_alphanumeric()</code> car√°cter que no satisfaga la funci√≥n <code>is_alphanumeric()</code> (es similar a <code>is_alphabetic()</code> excepto que tambi√©n incluye n√∫meros en cualquier alfabeto) o gui√≥n <code>'-'</code> . </p><br><p>  Cuando vemos por primera vez algo que no cumple con estos criterios, terminamos el an√°lisis, rompemos el ciclo y devolvemos una <code>String</code> , recordando cortar el fragmento que usamos de la <code>input</code> .  Del mismo modo, si los caracteres terminan en un iterador, significa que hemos llegado al final de la entrada. </p><br><p>  Vale la pena se√±alar que no regresamos con un error cuando vemos algo que no es alfanum√©rico o guiones.  Ya tenemos suficiente para crear un identificador v√°lido despu√©s de que coincidamos con esta primera letra, y es bastante normal que despu√©s de analizar nuestro identificador haya m√°s elementos en la l√≠nea de entrada para el an√°lisis, por lo que simplemente detenemos el an√°lisis y devolvemos nuestro resultado.  Solo si no podemos encontrar incluso esta primera letra, en realidad devolvemos un error, porque en este caso definitivamente no hubo un identificador. </p><br><p>  Recuerde que la estructura del <code>Element</code> es en lo que vamos a analizar nuestro documento XML. </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, attributes: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt;, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Element&gt;, }</code> </pre> <br><p>  De hecho, acabamos de terminar el analizador para la primera parte, el campo de <code>name</code> .  <code>String</code> que devuelve nuestro analizador va directamente all√≠.  Tambi√©n es el analizador correcto para la primera parte de cada <code>attribute</code> . </p><br><p>  Vamos a verlo </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identifier_parser</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"i-am-an-identifier"</span></span>.to_string())), identifier(<span class="hljs-string"><span class="hljs-string">"i-am-an-identifier"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">" entirely an identifier"</span></span>, <span class="hljs-string"><span class="hljs-string">"not"</span></span>.to_string())), identifier(<span class="hljs-string"><span class="hljs-string">"not entirely an identifier"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"!not at all an identifier"</span></span>), identifier(<span class="hljs-string"><span class="hljs-string">"!not at all an identifier"</span></span>) ); }</code> </pre> <br><p>  Vemos que en el primer caso, la cadena <code>"i-am-an-identifier"</code> analiza por completo, dejando solo una cadena vac√≠a.  En el segundo caso, el analizador devuelve <code>"not"</code> como identificador, y el resto de la cadena se devuelve como la entrada restante.  En el tercer caso, el analizador falla inmediatamente, porque el primer car√°cter que encuentra no es una letra. </p><br><h3 id="kombinatory">  Combinadores </h3><br><p>  Ahora podemos analizar el car√°cter de apertura <code>&lt;</code> , y podemos analizar el siguiente identificador, pero necesitamos analizar <em>ambos</em> .  Por lo tanto, el siguiente paso es escribir otra funci√≥n de analizador combinatorio, pero una que tome dos <em>analizadores</em> como entrada y devuelva un <em>analizador</em> nuevo que los analice a ambos en orden.  En otras palabras, <em>un combinador de</em> analizadores <em>sint√©ticos</em> porque combina los dos analizadores sint√°cticos en uno nuevo.  Veamos si podemos hacer esto. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span></span>&lt;P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, (R1, R2)), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, R1), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;, P2: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, R2), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser1(input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, result1)) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser2(next_input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((final_input, result2)) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((final_input, (result1, result2))), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), }, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } }</code> </pre> <br><p>  Aqu√≠ se vuelve un poco m√°s complicado, pero ya sabes qu√© hacer: comienza por ver los tipos. </p><br><p>  En primer lugar, tenemos cuatro tipos de variables: <code>P1</code> , <code>P2</code> , <code>R1</code> y <code>R2</code> .  Estos son <code>Parser 1</code> , <code>Parser 2</code> , <code>Result 1</code> y <code>Result 2</code> .  <code>P1</code> y <code>P2</code> son funciones, y notar√° que siguen un patr√≥n bien establecido de funciones de analizador: al igual que el valor de retorno, toman <code>&amp;str</code> como entrada y devuelven <code>Result</code> par de la entrada y el resultado restantes, o un error. </p><br><p>  Pero observe los tipos de resultados de cada funci√≥n: <code>P1</code> es el analizador que da <code>R1</code> si tiene √©xito, y <code>P2</code> tambi√©n da <code>R2</code> .  Y el resultado del √∫ltimo analizador devuelto por nuestra funci√≥n es <code>(R1, R2)</code> .  Por lo tanto, la tarea de este analizador es primero iniciar el analizador <code>P1</code> en la entrada, guardar su resultado, luego iniciar <code>P2</code> en la entrada que devolvi√≥ <code>P1</code> , y si ambos funcionan, combinamos los dos resultados en una tupla <code>(R1, R2)</code> </p><br><p>  El c√≥digo muestra que esto es exactamente lo que hace.  Comenzamos iniciando el primer analizador en la entrada, luego el segundo analizador, luego combinamos los dos resultados en una tupla y lo devolvemos.  Si alguno de estos analizadores falla, regresaremos inmediatamente con el error que emiti√≥. </p><br><p>  Por lo tanto, debemos poder combinar nuestros dos analizadores, <code>match_literal</code> e <code>identifier</code> , para <code>match_literal</code> realmente <code>match_literal</code> primer fragmento de nuestra primera etiqueta XML.  Escribamos una prueba para ver si funciona. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tag_opener = pair(match_literal(<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>), identifier); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>, ((), <span class="hljs-string"><span class="hljs-string">"my-first-element"</span></span>.to_string()))), tag_opener(<span class="hljs-string"><span class="hljs-string">"&lt;my-first-element/&gt;"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"oops"</span></span>), tag_opener(<span class="hljs-string"><span class="hljs-string">"oops"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"!oops"</span></span>), tag_opener(<span class="hljs-string"><span class="hljs-string">"&lt;!oops"</span></span>)); }</code> </pre> <br><p>  Parece que funciona!  Pero mira este tipo de resultado: <code>((), String)</code> .  Obviamente, solo nos interesa el valor correcto, <code>String</code> .  Esto suceder√° con bastante frecuencia: algunos de nuestros analizadores solo coinciden con patrones en la entrada sin producir valores, por lo que su salida puede ignorarse de forma segura.  Para adaptarnos a este patr√≥n, vamos a utilizar nuestro combinador de <code>pair</code> para escribir otros dos combinadores: <code>left</code> , que descarta el resultado del primer analizador y devuelve solo el segundo, y su opuesto es el <code>right</code> .  Usamos un analizador en nuestra prueba anterior, que descarta la parte izquierda y guarda solo nuestra <code>String</code> , en lugar del <code>pair</code> . </p><br><h3 id="vvedenie-v-funktor">  Introducci√≥n al Functor </h3><br><p>  Pero antes de ir tan lejos, introduzcamos otro combinador que simplificar√° en gran medida la escritura de estos dos: <code>map</code> . </p><br><p>  Este combinador tiene una tarea: cambiar el tipo de resultado. , ,    ,   <code>((), String)</code>     ,      <code>String</code> . </p><br><p>      ,  ,      .     : <code>|(_left, right)| right</code> .  ,     <code>Fn(A) -&gt; B</code>  <code>A</code> ‚Äî    ,  <code>B</code> ‚Äî . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>&lt;P, F, A, B&gt;(parser: P, map_fn: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, B), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, A), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(A) -&gt; B, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser(input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, result)) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, map_fn(result))), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } }</code> </pre> <br><p>    ? <code>P</code> ‚Äî  .  <code>A</code>  . <code>F</code> ‚Äî  ,       <code>P</code>    ,    ,  <code>P</code>   ,     ‚Äî <code>B</code>  <code>A</code> </p><br><p>     <code>parser(input)</code> ,   ,   <code>result</code>       <code>map_fn(result)</code> ,  <code>A</code>  <code>B</code> ,     . </p><br><p>   ,        ,    <code>map</code>   ,    <code>Result</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>&lt;P, F, A, B&gt;(parser: P, map_fn: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, B), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, A), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(A) -&gt; B, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| parser(input) .map(|(next_input, result)| (next_input, map_fn(result))) }</code> </pre> <br><p>   ‚Äî ,   ¬´¬ª  Haskell    ,  .        <code>A</code> ,       <code>map</code> ,      <code>A</code>  <code>B</code>       ,    <code>B</code>  ,  .        Rust,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Option</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Result</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Iterator</code></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Future</code></a> ,     .     :    -         Rust,         ,    ,    ,   ,       <code>map</code> . </p><br><h3 id="vremya-dlya-tipazha">    </h3><br><p> ,   ,         : <code>Fn(&amp;str) -&gt; Result&lt;(&amp;str, Output), &amp;str&gt;</code> . ,    ,    ,  ,   ,   ,     ,              . </p><br><p>         ,    : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParseResult</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, Output), &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;;</code> </pre> <br><p>   ,  ,     ,     <code>ParseResult&lt;String&gt;</code>  .     ,      ,      Rust       .      ,   <code>rustc</code> ,     ,   . </p><br><p>   <code>'a</code> ,   ,      <em> </em> . </p><br><p>  .       ,       ,      .    ,     . </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt;; }</code> </pre> <br><p>         :  <code>parse()</code> ,    :   ,   ,   . </p><br><p>     ,        ,    : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, F, Output&gt; Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;Output&gt;, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>(input) } }</code> </pre> <br><p>  ,        ,   ,      <code>Parser</code> ,          . </p><br><p> ,   ,          .    <code>map</code>  ,   . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, F, A, B&gt;(parser: P, map_fn: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, B&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(A) -&gt; B, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| parser.parse(input) .map(|(next_input, result)| (next_input, map_fn(result))) }</code> </pre> <br><p>      :       ,      <code>parser.parse(input)</code> ,     ,    <code>P</code> ,   ,    <code>Parser</code> ,      ,   <code>Parser</code> .         ,     .      <code>'a'</code> ,    ,       . </p><br><p>     <code>pair</code>   ,     : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (R1, R2)&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser1.parse(input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, result1)) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser2.parse(next_input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((final_input, result2)) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((final_input, (result1, result2))), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), }, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } }</code> </pre> <br><p>     :            <code>parser.parse(input)</code>  <code>parser(input)</code> . </p><br><p>   ,       <code>pair</code> ,       <code>map</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (R1, R2)&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| { parser1.parse(input).and_then(|(next_input, result1)| { parser2.parse(next_input) .map(|(last_input, result2)| (last_input, (result1, result2))) }) } }</code> </pre> <br><p>  <code>and_then</code>  <code>Result</code>   <code>map</code> ,   ,        <code>Result</code> ,    <code>Result</code> .             <code>match</code> .  <code>and_then</code>   ,  ,        <code>map</code> ,    <code>left</code>  <code>right</code> . </p><br><h3 id="left-i-right"> Left  Right </h3><br><p>  <code>pair</code>  <code>map</code>  ,    <code>left</code>  <code>right</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">left</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt;, { map(pair(parser1, parser2), |(left, _right)| left) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt;, { map(pair(parser1, parser2), |(_left, right)| right) }</code> </pre><br><p>    <code>pair</code> ,          ,      <code>map</code>      ,    . </p><br><p>          ,     ,            . </p><br><p>      ,    <code>Parser</code>  <code>ParseResult</code> . <code>match_literal</code>   : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">match_literal</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(expected: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, ()&gt; { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> input.get(<span class="hljs-number"><span class="hljs-number">0</span></span>..expected.len()) { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == expected =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[expected.len()..], ())), _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } }</code> </pre> <br><p>       ,    ,       ‚Äî <code>&amp;'a str</code> ,  <code>rustc</code> . </p><br><p>  <code>identifier</code> ,     ,   ,      : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identifier</span></span></span></span>(input: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; {</code> </pre> <br><p>   . <code>()</code>   .    . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tag_opener = right(match_literal(<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>), identifier); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"my-first-element"</span></span>.to_string())), tag_opener.parse(<span class="hljs-string"><span class="hljs-string">"&lt;my-first-element/&gt;"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"oops"</span></span>), tag_opener.parse(<span class="hljs-string"><span class="hljs-string">"oops"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"!oops"</span></span>), tag_opener.parse(<span class="hljs-string"><span class="hljs-string">"&lt;!oops"</span></span>)); }</code> </pre> <br><h3 id="odin-ili-bolshe">    </h3><br><p>      .      <code>&lt;</code>     .  ?       . </p><br><p> ,   ,     .       ,    . </p><br><p> , ,         - , <em> </em>       : . </p><br><p>          (  )  .      . </p><br><p>    ‚Äî      <em>   </em> ,   <code>&lt;element attribute="value"/&gt;</code>   ,      .       ,     ,   <em>  </em>  . </p><br><p>          <code>identifier</code> ,      .  ,          . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one_or_more</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;A&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> input| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, first_item)) = parser.parse(input) { input = next_input; result.push(first_item); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, next_item)) = parser.parse(input) { input = next_input; result.push(next_item); } <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((input, result)) } }</code> </pre> <br><p>  ,    ,    ,  <code>A</code> ,        <code>Vec&lt;A&gt;</code> ‚Äî   <code>A</code> . </p><br><p>      <code>identifier</code> .     ,     ,    .       ,      ,           . </p><br><p>    ,  :         <em></em>  ?       : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zero_or_more</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;A&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> input| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, next_item)) = parser.parse(input) { input = next_input; result.push(next_item); } <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((input, result)) } }</code> </pre> <br><p>    ,  ,     . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one_or_more_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parser = one_or_more(match_literal(<span class="hljs-string"><span class="hljs-string">"ha"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(), (), ()])), parser.parse(<span class="hljs-string"><span class="hljs-string">"hahaha"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"ahah"</span></span>), parser.parse(<span class="hljs-string"><span class="hljs-string">"ahah"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>), parser.parse(<span class="hljs-string"><span class="hljs-string">""</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zero_or_more_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parser = zero_or_more(match_literal(<span class="hljs-string"><span class="hljs-string">"ha"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(), (), ()])), parser.parse(<span class="hljs-string"><span class="hljs-string">"hahaha"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">"ahah"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[])), parser.parse(<span class="hljs-string"><span class="hljs-string">"ahah"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[])), parser.parse(<span class="hljs-string"><span class="hljs-string">""</span></span>)); }</code> </pre> <br><p>      :  <code>one_or_more</code>     ,             ,   <code>zero_or_more</code>      ,    . </p><br><p>            ,       ,     .     <code>one_or_more</code>   <code>zero_or_more</code> , -  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one_or_more</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;A&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { map(pair(parser, zero_or_more(parser)), |(head, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> tail)| { tail.insert(<span class="hljs-number"><span class="hljs-number">0</span></span>, head); tail }) }</code> </pre> <br><p>      Rust,           <code>cons</code>  <code>Vec</code> ,   ,     Lisp,    ,   . ,   :  . </p><br><p>    ,          :    ,       .  :                (       ).       ,      ,   <code>Clone</code> ,      ,     ,          . </p><br><p>    <em></em> .  ,      <code>one_or_more</code>   ,  ,       ,      ,        ,     -  ,    ,   <code>RangeBound</code>            : <code>range(0..)</code>  <code>zero_or_more</code> , <code>range(1..)</code>  <code>one_or_more</code> , <code>range(5..=6)</code>     ,    . </p><br><p>       .           <code>zero_or_more</code>  <code>one_or_more</code> . </p><br><p>      ,        ‚Äî  ,    <code>Rc</code>    ? </p><br><h3 id="predikatnyy-kombinator">   </h3><br><p>      ,         <code>one_or_more</code>      <code>zero_or_more</code> . </p><br><p>   ,  .     ,  <em></em>  .     ,    ,     ,       <code>&gt;</code>  <code>/&gt;</code> .    ,  <em></em>  .    ,   ,       ,        <em>  </em>  <em>  </em> ,    . </p><br><p>       .       . </p><br><p> -.         <code>match_literal</code>  ,    .   ?   -    ,       Unicode,    .        Rust,  ,  <code>char</code>   <code>is_whitespace</code> ,    <code>is_alphabetic</code>  <code>is_alphanumeric</code> . </p><br><p> -.     ,      ,   <code>is_whitespace</code> ,     <code>identifier</code> . </p><br><p> -.    ,     .      <code>any_char</code> ,    <code>char</code>   ,      ,   <code>pred</code> ,       ,    : <code>pred(any_char, |c| c.is_whitespace())</code> .    ,      ,    :      . </p><br><p>  <code>any_char</code> ,   ,       UTF-8. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any_char</span></span></span></span>(input: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> input.chars().next() { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[next.len_utf8()..], next)), _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } }</code> </pre> <br><p>   <code>pred</code>     ,   , .    ,       .     ,      <code>true</code> ,    .       ,    . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pred</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A, F&gt;(parser: P, predicate: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;A) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, value)) = parser.parse(input) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> predicate(&amp;value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, value)); } } <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input) } }</code> </pre> <br><p>   ,  ,    : </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predicate_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parser = pred(any_char, |c| *c == <span class="hljs-string"><span class="hljs-string">'o'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">"mg"</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>)), parser.parse(<span class="hljs-string"><span class="hljs-string">"omg"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"lol"</span></span>), parser.parse(<span class="hljs-string"><span class="hljs-string">"lol"</span></span>)); }</code> </pre> <br><p>     ,     <code>whitespace_char</code>    : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whitespace_char</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt; { pred(any_char, |c| c.is_whitespace()) }</code> </pre> <br><p>  ,     <code>whitespace_char</code> ,     ,    , <em>   </em> ,    , <em>   </em> .        <code>space1</code>  <code>space0</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">space1</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt;&gt; { one_or_more(whitespace_char()) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">space0</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt;&gt; { zero_or_more(whitespace_char()) }</code> </pre> <br><h3 id="citiruemye-stroki">   </h3><br><p>          ? ,    ,          .     <code>identifier</code>    (  ,      <code>any_char</code>  <code>pred</code>   <code>*_or_more</code> ). <code>match_literal("=")</code>   <code>=</code> .         ,     .  ,      ,     . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quoted_string</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { map( right( match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), left( zero_or_more(pred(any_char, |c| *c != <span class="hljs-string"><span class="hljs-string">'"'</span></span>)), match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), ), ), |chars| chars.into_iter().collect(), ) }</code> </pre> <br><p>       ,     ,    ,      ,   . </p><br><p>     <code>map</code> -   ,    ,    ,     ,    ,    :   .  <code>map</code>  <code>right</code> ,    <code>right</code> ‚Äî  ,   : <code>match_literal("\"")</code> .     . </p><br><p>    <code>right</code> ‚Äî   .      <code>left</code> ,    ,  <em></em>   <code>left</code> , ,   ,   <code>match_literal("\"")</code> ‚Äî  .  ,   ‚Äî    . </p><br><p>     <code>pred</code>  <code>any_char</code> ,   ,    <em>   </em> ,      <code>zero_or_more</code> ,   : </p><br><ul><li>   </li><li>       ,  <em></em>    </li><li>    </li></ul><br><p>   <code>right</code>  <code>left</code>          . </p><br><p>  ,   . ,   <code>zero_or_more</code> ? <code>Vec&lt;A&gt;</code>      <code>A</code> .  <code>any_char</code>  <code>char</code> .  ,    ,  <code>Vec&lt;char&gt;</code> .     <code>map</code> :   ,   <code>Vec&lt;char&gt;</code>  <code>String</code> ,   ,     <code>String</code>  <code>Iterator&lt;Item = char&gt;</code> ,      <code>vec_of_chars.into_iter().collect()</code>     ,    <code>String</code> . </p><br><p>     ,  ,    ,    ,  ,     ,   ,  ,            . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quoted_string_parser</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello Joe!"</span></span>.to_string())), quoted_string().parse(<span class="hljs-string"><span class="hljs-string">"\"Hello Joe!\""</span></span>) ); }</code> </pre> <br><p> , , ,  ,    . </p><br><h3 id="nakonec-atributy-razbora"> ,   </h3><br><p>     , ,  <code>=</code>    .   ,      . </p><br><p>      .   ,      <code>Vec&lt;(String, String)&gt;</code> ,      <code>(String, String)</code> ,       <code>zero_or_more</code> . ,     . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute_pair</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt; { pair(identifier, right(match_literal(<span class="hljs-string"><span class="hljs-string">"="</span></span>), quoted_string())) }</code> </pre> <br><p>   !  :           <code>pair</code> ,       <code>identifier</code> ,    <code>String</code> ,  <code>right</code>   <code>=</code> ,      ,    <code>quoted_string</code> ,     <code>String</code> . </p><br><p>      <code>zero_or_more</code> ,   ,        . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attributes</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt;&gt; { zero_or_more(right(space1(), attribute_pair())) }</code> </pre> <br><p>    :     , <br>   .   <code>right</code>       . </p><br><p>   . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute_parser</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(( <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[ (<span class="hljs-string"><span class="hljs-string">"one"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"1"</span></span>.to_string()), (<span class="hljs-string"><span class="hljs-string">"two"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"2"</span></span>.to_string()) ] )), attributes().parse(<span class="hljs-string"><span class="hljs-string">" one=\"1\" two=\"2\""</span></span>) ); }</code> </pre> <br><p>  !  ! </p><br><p>   , ,      rustc ,      ,          .  ,              .  ,    rustc,  ,   ,    <code>#![type_length_limit = "‚Ä¶some big number‚Ä¶"]</code>   ,      .   ,    <code>#![type_length_limit = "16777216"]</code> ,          . ,   ! </p><br><h3 id="tak-teper-zavershenie">    </h3><br><p>   , ,      ,    ,        NP-.        element:        ,   ,    ,        <code>zero_or_more</code> , ? </p><br><p> ,     ,     . ,   ,      ,    :   <code>&lt;</code> ,    .  ,       <code>(String, Vec&lt;(String, String)&gt;)</code>   . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">element_start</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt;)&gt; { right(match_literal(<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>), pair(identifier, attributes())) }</code> </pre> <br><p>    ,        ,       . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { map( left(element_start(), match_literal(<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>)), |(name, attributes)| Element { name, attributes, children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }, ) }</code> </pre> <br><p> ,  ,      ‚Äî     <code>Element</code> ! </p><br><p>      . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single_element_parser</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(( <span class="hljs-string"><span class="hljs-string">""</span></span>, Element { name: <span class="hljs-string"><span class="hljs-string">"div"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(<span class="hljs-string"><span class="hljs-string">"class"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"float"</span></span>.to_string())], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[] } )), single_element().parse(<span class="hljs-string"><span class="hljs-string">"&lt;div class=\"float\"/&gt;"</span></span>) ); }</code> </pre> <br><p> ‚Ä¶   ,       . </p><br><p>    <code>single_element</code>  ,          ,    ,    . ,        ,       ,       ‚Äî ,       ‚Äî   . </p><br><p>   ,        ,      ... </p><br><h3 id="beskonechnost-ne-predel">    </h3><br><p>   -      Rust, , ,      . </p><br><p>        .  ,      : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span></span>&lt;A&gt; { Cons(A, List&lt;A&gt;), Nil, }</code> </pre> <br><p>   rustc    ,     <code>List&lt;A&gt;</code>   ,     <code>List::&lt;A&gt;::Cons</code>    <code>List&lt;A&gt;</code> ,      .   rustc,      ,   ,     <em></em>  . </p><br><p>             ,       Rust.    ,   Rust,   ,     <em></em>     ,     <em></em>  ,    .    ,      . </p><br><p>    ,    .  ,   <code>List::Cons</code>   <code>A</code>   <em></em> <code>A</code> ,     <code>A</code>  <em></em>   <code>A</code> .    ,   ,   ,    ,    <code>List::Cons</code>      ,    .    ,           Rust ‚Äî  <code>Box</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span></span>&lt;A&gt; { Cons(A, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;List&lt;A&gt;&gt;), Nil, }</code> </pre> <br><p>     <code>Box</code>   ,       .  ,          ,            <code>Box&lt;dyn Parser&lt;'a, A&gt;&gt;</code> . </p><br><p>   .  ?  ,        -    ,    ,          .       :   .      .  ,      ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  SIMD</a> (     ). </p><br><p> ,     <code>Parser</code>     <em>Box</em>     ,      . </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BoxedParser</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { parser: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>&lt;P&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { BoxedParser { parser: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(parser), } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.parser.parse(input) } }</code> </pre> <br><p> ,  ,    <code>BoxedParser</code>    <code>box</code> .    <code>BoxedParser</code>       (  <code>BoxedParser</code> ,      ),    <code>BoxedParser::new(parser)</code> ,    ,      <code>Box</code>    . ,   <code>Parser</code>  ,         . </p><br><p>          <code>Box</code> ,  <code>BoxedParser</code>    <code>Parser</code>  ,   . ,   ,  ,           ,    ,     <em>  </em> ,  , ,   <em> </em> .        . </p><br><h3 id="vozmozhnost-predstavlyaet-sebya">    </h3><br><p> ,  ,       ,     . </p><br><p>    ,   ?      ,       ,       .    <code>quoted_string</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quoted_string</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { map( right( match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), left( zero_or_more(pred(any_char, |c| *c != <span class="hljs-string"><span class="hljs-string">'"'</span></span>)), match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), ), ), |chars| chars.into_iter().collect(), ) }</code> </pre> <br><p>     ,             .             <code>Parser</code> ? </p><br><p>   ,     ,     <code>impl Trait</code>     ,   <code>impl Trait</code>     . </p><br><p> ‚Ä¶      <code>BoxedParser</code> .       ,   <code>impl Parser&lt;'a, A&gt;</code> ,    <em></em>  ,   <code>BoxedParser&lt;'a, A&gt;</code> . </p><br><p>   ,          ,           ,   <code>Parser</code> . </p><br><p>     <code>map</code> ,    <code>Parser</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>&lt;F, NewOutput&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, map_fn: F) -&gt; BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span> + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(Output) -&gt; NewOutput + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { BoxedParser::new(map(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, map_fn)) } }</code> </pre> <br><p>   <code>'a</code> , ,    .  ,            ‚Äî     ,          ,       <code>impl Trait</code> . </p><br><p>       <code>quoted_string</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quoted_string</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { right( match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), left( zero_or_more(pred(any_char, |c| *c != <span class="hljs-string"><span class="hljs-string">'"'</span></span>)), match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), ), ) .map(|chars| chars.into_iter().collect()) }</code> </pre> <br><p>   ,   ,  <code>.map()</code>    <code>right()</code> . </p><br><p>         <code>pair</code> , <code>left</code>  <code>right</code> ,       ,    ,    ,        <code>pair</code> .    ,       ,     <code>map</code> ,         . </p><br><p>    ‚Äî <code>pred</code> .        <code>Parser</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pred</span></span></span></span>&lt;F&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, pred_fn: F) -&gt; BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span> + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Output) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { BoxedParser::new(pred(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, pred_fn)) }</code> </pre> <br><p>       <code>quoted_string</code>   <code>pred</code> ,   : </p><br><pre> <code class="rust hljs">zero_or_more(any_char.pred(|c| *c != <span class="hljs-string"><span class="hljs-string">'"'</span></span>)),</code> </pre> <br><p>  ,     ,   ,     <code>zero_or_more</code>   ‚Äî    ¬´    <code>any_char</code>    ¬ª,    .  ,        <code>zero_or_more</code>  <code>one_or_more</code>  . </p><br><p>     <code>quoted_string</code> ,    <code>map</code>  <code>single_element</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { left(element_start(), match_literal(<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>)).map(|(name, attributes)| Element { name, attributes, children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }) }</code> </pre> <br><p>      <code>element_start</code>  ,    ,  ,   .          ... </p><br><p> ‚Ä¶  ,       .             ,     . </p><br><p>    <code>map</code>  <code>pred</code>  <code>Box</code> ‚Äî <em></em>     ! </p><br><h3 id="obrabotka-detey-elementa">    </h3><br><p>         .    <code>single_element</code> ,   ,     <code>&gt;</code> ,    <code>/&gt;</code> .            ,        ,     . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { left(element_start(), match_literal(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>)).map(|(name, attributes)| Element { name, attributes, children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }) }</code> </pre> <br><p> ,     ?     ,    ,      ,         <code>zero_or_more</code> ,     ?  ,      , ‚Äî      : ,   <em></em>  , <em></em>  . </p><br><p>   ,   ,      :     ,  ,      .    ,  ,   ,     <em>   </em> .   , ,   ,    ,   ,        ,    . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">either</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, A&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser1.parse(input) { ok @ <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(_) =&gt; ok, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(_) =&gt; parser2.parse(input), } }</code> </pre> <br><p>       <code>element</code> ,     ,    (     <code>open_element</code>   ,       <code>element</code> ). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { either(single_element(), open_element()) }</code> </pre> <br><p>       .         ,  ,    ,    .      , ? </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(expected_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { right(match_literal(<span class="hljs-string"><span class="hljs-string">"&lt;/"</span></span>), left(identifier, match_literal(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>))) .pred(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |name| name == &amp;expected_name) }</code> </pre> <br><p>   <code>pred</code>   ,   ? </p><br><p>           ,   : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { pair( open_element(), left(zero_or_more(element()), close_element(‚Ä¶oops)), ) }</code> </pre> <br><p>        <code>close_element</code> ?  ,      . </p><br><p>   .       ,   <code>parent_element</code> ,     <code>open_element</code>   <code>element</code>   <code>parent_element</code> ,  ,       XML. </p><br><p> ,  ,     <code>and_then</code> ? ,  .    <code>and_then</code> :   -,   ,  ,       <em></em> ,    .     <code>pair</code> ,   ,   ,       ,     .  , <code>and_then</code>   <code>Result</code>  <code>Option</code> ,   ,      ,   <code>Result</code>  <code>Option</code>      <em></em> ,   ,     ( ,    )). </p><br><p> ,      . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and_then</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, F, A, B, NextP&gt;(parser: P, f: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, B&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, NextP: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, B&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(A) -&gt; NextP, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser.parse(input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, result)) =&gt; f(result).parse(next_input), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } }</code> </pre> <br><p>   ,    ,    <code>P</code> ,   ,     <code>A</code> .    <code>F</code> ,  <code>map</code>    <code>A</code>  <code>B</code> ,     ,  <code>and_then</code>    <code>A</code>  <em>  </em> <code>NextP</code> ,     <code>B</code> .    ‚Äî <code>B</code> ,    ,  ,     <code>NextP</code>   . </p><br><p>    :        ,     ,  ,     ,      <code>f</code>   ( <code>A</code> ),  ,    <code>f(result)</code> ,       <code>B</code> .   <em></em>          .    ,        ,    ,       <code>B</code> </p><br><p>  :        <code>P</code> ,    ,    <code>f</code>     <code>P</code> ,        <code>NextP</code> ,    ,    . </p><br><p>        <code>Parser</code> ,    <code>map</code> ,    . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and_then</span></span></span></span>&lt;F, NextParser, NewOutput&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, f: F) -&gt; BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span> + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NextParser: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(Output) -&gt; NextParser + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { BoxedParser::new(and_then(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, f)) }</code> </pre> <br><p> , ,    ? </p><br><p>  ,   <em></em>  <code>pair</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (R1, R2)&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>, R2: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { parser1.and_then(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |result1| parser2.map(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |result2| (result1.clone(), result2))) }</code> </pre> <br><p>    ,   : <code>parser2.map()</code>  <code>parser2</code>     ,    <code>Fn</code> ,   <code>FnOnce</code> ,     <code>parser2</code> ,     .  ,  Rust.     ,      ,        <code>pair</code> . </p><br><p> ,         Rust,            <code>close_element</code> ,   ,         . </p><br><p>    : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { pair( open_element(), left(zero_or_more(element()), close_element(‚Ä¶oops)), ) }</code> </pre> <br><p> ,   <code>and_then</code> ,            <code>close_element</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { open_element().and_then(|el| { left(zero_or_more(element()), close_element(el.name.clone())).map(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |children| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> el = el.clone(); el.children = children; el }) }) }</code> </pre> <br><p>     ,   <code>and_then</code>    <code>open_element()</code> ,    ,    <code>close_element</code> .  ,       <code>open_element</code>      <code>and_then</code> .  ,         <code>Element</code>  <code>open_element</code> , ,   ,      . </p><br><p>  ,  <code>map</code>    ,    <code>Element</code> ( <code>el</code> )   .    <code>clone()</code> ,      <code>Fn</code>       .       ( <code>Vec&lt;Element&gt;</code> )       <code>Element</code> ,        . </p><br><p> ,     ,      <code>element</code>  ,    <code>open_element</code>  <code>parent_element</code> ,      ,     ,   ,   ! </p><br><h3 id="sobiraetes-li-vy-skazat-slovo-m-ili-dolzhen-ya">      ""   ? </h3><br><p> ,    ,   <code>map</code>  ¬´¬ª   Haskell? </p><br><p> <code>and_then</code> ‚Äî    ,     Rust,      ,   <code>map</code> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>flat_map</code></a>  <code>Iterator</code> ,     ,   . </p><br><p>     ‚Äî "".     <code>Thing&lt;A&gt;</code> ,      <code>and_then</code> ,        <code>A</code>  <code>Thing&lt;B&gt;</code> ,        <code>Thing&lt;B&gt;</code> ‚Äî  . </p><br><p>     , ,     <code>Option&lt;A&gt;</code> ,   ,    <code>Some(A)</code>  <code>None</code> ,     ,   <code>Some(A)</code> ,   <code>Some(B)</code> </p><br><p>     . ,     <code>Future&lt;A&gt;</code>     ,  <code>and_then</code>      <code>Future&lt;B&gt;</code> ,      <code>Future&lt;B&gt;</code>    <code>Future&lt;A&gt;</code>  ,     <code>Future&lt;A&gt;</code> .        <code>Future&lt;A&gt;</code> ,   ‚Äî   <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a></sup> ,   <code>Future&lt;B&gt;</code> .  ,   <code>Future</code>     ,    <code>and_then</code>   <em>  </em> ,       <code>Future</code> ,  .     ,     <em></em> <code>Future</code> ,       . </p><br><p>      ,   Rust       ,   ,     ,  ,  ,       ,    ,    .  . </p><br><h3 id="probely-redux"> , Redux </h3><br><p>   . </p><br><p>      ,    XML,      .       ,              (  ,        ,  <code>&lt; div / &gt;</code> ,    ). </p><br><p>               . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whitespace_wrap</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { right(space0(), left(parser, space0())) }</code> </pre> <br><p>    <code>element</code>  ,          <code>element</code> ,  ,          ,   . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { whitespace_wrap(either(single_element(), parent_element())) }</code> </pre> <br><h3 id="my-na-finishnoy-pryamoy">    ! </h3><br><p>  ,    !    ,  . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xml_parser</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doc = <span class="hljs-string"><span class="hljs-string">r#" &lt;top label="Top"&gt; &lt;semi-bottom label="Bottom"/&gt; &lt;middle&gt; &lt;bottom label="Another bottom"/&gt; &lt;/middle&gt; &lt;/top&gt;"#</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parsed_doc = Element { name: <span class="hljs-string"><span class="hljs-string">"top"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(<span class="hljs-string"><span class="hljs-string">"label"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"Top"</span></span>.to_string())], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[ Element { name: <span class="hljs-string"><span class="hljs-string">"semi-bottom"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(<span class="hljs-string"><span class="hljs-string">"label"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"Bottom"</span></span>.to_string())], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }, Element { name: <span class="hljs-string"><span class="hljs-string">"middle"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[Element { name: <span class="hljs-string"><span class="hljs-string">"bottom"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(<span class="hljs-string"><span class="hljs-string">"label"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"Another bottom"</span></span>.to_string())], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }], }, ], }; <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, parsed_doc)), element().parse(doc)); }</code> </pre> <br><p>  ,    -   ,   ,      : </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mismatched_closing_tag</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doc = <span class="hljs-string"><span class="hljs-string">r#" &lt;top&gt; &lt;bottom/&gt; &lt;/middle&gt;"#</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"&lt;/middle&gt;"</span></span>), element().parse(doc)); }</code> </pre> <br><p>    ,        .     ,      <em></em>  ,       ,  , <em></em> .  ,  , ,  ,          .     ,       ,    , ,   ,    . </p><br><p>     :     ,   !  ,      ,  ,               <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a></sup> . </p><br><p>  ,   ,       .      ! </p><br><h3 id="dopolnitelnye-resursy">   </h3><br><p>  ,    ,       Rust ,   ,        - ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> ,       ,       . </p><br><p>        ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>pom</code></a> ,           ,    . </p><br><p>       Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>nom</code></a>   ,    <code>pom</code>    (    ,  ),          ,     . </p><br><p>        Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>combine</code></a> ,    . </p><br><p>       Haskell  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parsec</a> . </p><br><p> ,            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>¬´  Haskell¬ª</em></a> ,          ,      Haskell. </p><br><h2 id="licenziya">  </h2><br><p>      Bodil Stokke        Creative Commons Attribution-NonCommercial-ShareAlike 4.0.     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://creativecommons.org/licenses/by-nc-sa/4.0/</a> . </p><br><h2 id="snoski">  </h2><br><p> 1:       . </p><br><p> 2: ,      . </p><br><h2 id="ot-perevodchikov">   </h2><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">andreevlex</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">funkill</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/469213/">https://habr.com/ru/post/469213/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../469195/index.html">DevOpsProdigy KubeGraf v1.1.0</a></li>
<li><a href="../469203/index.html">Fuerte "caffe" para el desayuno y los hackathons: por qu√© es importante para el desarrollo de la comunidad de Data Science</a></li>
<li><a href="../469205/index.html">Datos del museo Art. Desempaquete "Electr√≥nica MS 0511"</a></li>
<li><a href="../469209/index.html">La diferencia entre las l√°mparas LED de Philips y las caras</a></li>
<li><a href="../469211/index.html">C√≥mo ICD est√° desarrollando un ecosistema para clientes bancarios</a></li>
<li><a href="../469215/index.html">Trabajar con fechas en el lenguaje R (caracter√≠sticas b√°sicas, as√≠ como paquetes lubridate y timeperiodsR)</a></li>
<li><a href="../469217/index.html">En mi humilde opini√≥n Saint TeamLead Conf 2019</a></li>
<li><a href="../469219/index.html">Las 20 mejores funciones de navegaci√≥n en IntelliJ IDEA. Parte 2</a></li>
<li><a href="../469221/index.html">Cascadeur: prediciendo la pose de seis puntos de un personaje</a></li>
<li><a href="../469223/index.html">Retroiluminaci√≥n LED como puerta trasera</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>