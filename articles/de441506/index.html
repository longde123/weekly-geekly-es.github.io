<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💜 👆 🎯 Paket-Streaming-Protokoll für PSP1N-Mikrocontroller 👈🏾 🧔🏾 🎯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Erklärung des Problems 


 Bei der Entwicklung eines anderen Geräts auf einem Mikrocontroller stieß ich auf eine Situation, in der eine kontinuierlich...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Paket-Streaming-Protokoll für PSP1N-Mikrocontroller</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441506/"><h3 id="postanovka-zadachi">  Erklärung des Problems </h3><br><p>  Bei der Entwicklung eines anderen Geräts auf einem Mikrocontroller stieß ich auf eine Situation, in der eine kontinuierliche Aufzeichnung einer großen Datenmenge erforderlich war.  Das Gerät musste einen Datensatz, der aus einem Zeitstempel und sechs ADC-Messungen von 100 Mal pro Sekunde bestand, auf einer SD-Karte speichern (nennen wir diesen Datensatz ein Paket) und diese Daten dann in Form von Grafiken auf einem Computer analysieren.  Parallel zum Schreiben von Daten auf eine SD-Karte und deren Übertragung über UART war dies ebenfalls erforderlich.  Diese Daten sollten so wenig Platz wie möglich beanspruchen, da viele Daten vorhanden sind.  Gleichzeitig war es notwendig, diese Pakete irgendwie zu trennen, da die Daten in einem kontinuierlichen Strom gingen.  Nachdem ich im Internet nichts Gutes gestöbert hatte, fand ich es nicht, und so wurde beschlossen, mein eigenes Protokoll und meine eigenen Bibliotheken dafür zu erstellen. </p><br><h3 id="i-tut-poyavilsya-on--packet-streaming-protocol-psp1n">  Und dann erschien er - Packet Streaming Protocol (PSP1N) </h3><br><p>  Aufgrund einiger Überlegungen wurde Folgendes entschieden: In dem Protokoll werden die Daten in Paketen übertragen, die aus N Bytes bestehen, wobei das erste Bit jedes Bytes dem Startbitzeichen für die Paketsynchronisation (daher der Protokollname) zugewiesen wird, die verbleibenden sieben Bits den Daten zugewiesen werden.  Die Reihenfolge und Größe der Daten sind im Voraus bekannt. </p><a name="habracut"></a><br><p>  <strong><em>Ein Beispiel:</em></strong> </p><br><p>  Wir weisen 32 Bit für den Zeitstempel zu, 60 Bit für die ADC-Messungen (6 Kanäle mit 10 Bit), insgesamt 92 Bit.  Da Sie 7 Bits nützlicher Daten in einem Byte übertragen können, besteht das Paket aus 14 Bytes (92 Bits / 7 Bit = 13,14 ... auf 14 aufrunden).  Es gibt 112 Informationsbits in 14 Bytes, von denen 14 Bit durch das Startbitattribut von 92 Bits nützlicher Daten belegt sind, es gibt 6 nicht verwendete Bits (in die wir einige weitere Informationen schreiben können, aber der Einfachheit halber werden wir sie nicht verwenden). </p><br><p><img src="https://habrastorage.org/webt/ze/mf/lf/zemflfgwrxlos_oeqmzl8n08w88.gif"></p><br><p>  Wo das 7. Bit das Vorzeichen des Startbits ist (zeigt den Beginn des Pakets an), sind 6,5,4,3,2,1,0 Datenbits. </p><br><p>  Die empfangende Seite weiß auch, dass sie ein Paket von 14 Bytes empfängt, in dem das erste Bit des ersten Bytes das Startbit (1) ist (in den verbleibenden Bytes sind die Startbits 0), dann in den Datenbits in der Reihenfolge 32 Bits des Zeitstempels, dann 10 Bits der ADC-Messnummer. 1, dann 10 Bit ADC # 2 und so weiter ... </p><br><p>  Ebenso erfolgt das Schreiben auf die SD-Karte und das Lesen von dieser gemäß dem Protokoll.  Insgesamt erhalten wir für einen Tag Aufzeichnung auf einer SD-Karte 115,4 MB Informationen (14 Byte x 100 Messungen pro Sekunde x 3600 Sek. X 24 Stunden). </p><br><p>  Eine solche Datenstruktur ist immer noch praktisch, da wir in Zukunft Datenblöcke von überall in der Datei auswählen und in Form von Diagrammen anzeigen können, wodurch nicht die gesamte Datei in den Arbeitsspeicher geladen wird (der mehrere zehn Gigabyte erreichen kann).  Außerdem können wir das bequeme Scrollen dieser Diagramme implementieren, indem wir die erforderlichen Pakete laden. </p><br><p><img src="https://habrastorage.org/webt/dy/wi/_a/dywi_a67ztu05h5o-bpnetlfmge.gif"></p><br><h4 id="pora-pristupit-k-programmnoy-realizacii-dlya-mikrokontrollera">  Es ist Zeit, die Software-Implementierung für den Mikrocontroller zu starten </h4><br><p>  Wir schreiben die Bibliothek für den Mikrocontroller in C ++. </p><br><p>  Erstellen Sie der Einfachheit halber eine Klasse: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PSP</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   init: startBit -   0  1 *arrayByte -      sizeArrayByte -     */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte startBit, byte* arrayByte, byte sizeArrayByte)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/*      pushData: sizeBit -     value -   (       ) */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte sizeBit, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/*       popData: return     . */</span></span> <span class="hljs-function"><span class="hljs-function">byte* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: byte startBit; <span class="hljs-comment"><span class="hljs-comment">//  byte* arrayByte; //   byte sizeArrayByte; //   byte position = 0; //    bool clearFlag = false; //   void setStartBit(byte &amp;value); //     void clearStartBit(byte &amp;value); //     };</span></span></code> </pre> <br><p>  Bei der Initialisierungsmethode ist meiner Meinung nach alles klar: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> PSP::init(byte startBit, byte* arrayByte, byte sizeArrayByte) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;startBit = startBit; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;arrayByte = arrayByte; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;sizeArrayByte = sizeArrayByte; }</code> </pre> <br><p>  Das Hinzufügen von Daten ist komplizierter. Hier platzieren wir die Daten durch listige bitweise Manipulationen in unserem Byte-Array. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> PSP::pushData(byte sizeBit, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> value) { byte <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>; byte y; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> remBit = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      //   ,     if (!clearFlag) { for (byte i = 0; i &lt; sizeArrayByte; i++) { arrayByte[i] = 0; } clearFlag = true; } //        7      while (remBit &gt; -1) { free = 7 - (position) % 7; //        y = (position) / 7; //     //       remBit = sizeBit - free; //      if (remBit &lt; 0) { arrayByte[y] |= value &lt;&lt; ~remBit + 1; //   ,    position += sizeBit; //        remBit = -1; //      } //      else if (remBit &gt; 0) { arrayByte[y] |= value &gt;&gt; remBit; //     ,    position += sizeBit - remBit; sizeBit = remBit; //        } //         else if (remBit == 0) { arrayByte[y] |= value; //    position += sizeBit; remBit = -1; //      } clearStartBit(arrayByte[y]); //   } setStartBit(arrayByte[0]); //   }</span></span></code> </pre> <br><p>  Methode zum Abrufen eines Arrays von Bytes eines Pakets </p><br><pre> <code class="cpp hljs">byte* PSP::popData() { position = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   clearFlag = false; //    return arrayByte; //   }</span></span></code> </pre> <br><p>  Und zum Schluss noch ein paar Zusatzfunktionen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      void PSP::setStartBit(byte &amp;value) { if (startBit == 0) value &amp;= ~(1 &lt;&lt; 7); else value |= 1 &lt;&lt; 7; } //      void PSP::clearStartBit(byte &amp;value) { if (startBit == 1) value &amp;= ~(1 &lt;&lt; 7); else value |= 1 &lt;&lt; 7; }</span></span></code> </pre> <br><h3 id="podvedem-itogi">  Zusammenfassend </h3><br><p>  Als Ergebnis der geleisteten Arbeit wurden das kompakte Protokoll für das Streaming von Daten PSP1N und vorgefertigte Bibliotheken, die hier von <a href="">GitHub</a> heruntergeladen werden können, „geboren“.  In diesem Repository finden Sie: </p><br><blockquote><ol><li>  Beispiel für die Verwendung der Bibliothek "ExampleColsolePSP1N / C #" </li><li>  PSP1N_CPP / enthält die PSP-Bibliothek für die Arbeit mit dem Protokoll und ein Beispiel für dessen Verwendung auf Arduino </li><li>  PSP1N_CSHARP / Protokollbibliothek für .NET </li></ol><br></blockquote><p>  Um die Funktionsweise des Protokolls zu demonstrieren, können Sie die Skizze in Arduino flashen und im Beispiel ExampleSerialPortRead auf dem Computer Daten vom Mikrocontroller über den COM-Port empfangen.  Dort werden diese Daten entschlüsselt und in einer Konsolenanwendung angezeigt.  Ich werde ein anderes Mal über die in C # geschriebene Bibliothek für die empfangende Seite sprechen. </p><br><p>  <em>TestingConsole:</em> </p><br><p><img src="https://habrastorage.org/webt/td/eo/mt/tdeomt1j388ttvmrfcb25s9lcnm.gif"></p><br><blockquote>  UPDATE (31.03.19): Der Kodierungs- und Dekodierungsalgorithmus wurde geändert </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441506/">https://habr.com/ru/post/de441506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441490/index.html">Worauf Sie bei der Auswahl eines Lesegeräts achten sollten - Betriebssysteme und Hardware</a></li>
<li><a href="../de441496/index.html">Ton auf dem Draht: die Geschichte des Telegraphen</a></li>
<li><a href="../de441498/index.html">Kuril Online</a></li>
<li><a href="../de441500/index.html">Hubschrauber Vorfahren. Die wahre Ursache für Unzufriedenheit unter britischen Teenagern</a></li>
<li><a href="../de441502/index.html">Warum muss die Fernbedienungsanwendung meinen Standort kennen?</a></li>
<li><a href="../de441508/index.html">Habraiting 2017: die besten Materialien für 2017</a></li>
<li><a href="../de441510/index.html">Stonehenge. Die Geheimnisse der Megalithen</a></li>
<li><a href="../de441514/index.html">So "teilen" Sie den ADC richtig</a></li>
<li><a href="../de441516/index.html">Fraktale in irrationalen Zahlen</a></li>
<li><a href="../de441518/index.html">Was gibt einen wissenschaftlichen Ansatz für ethische Fragen: der Quellcode der politischen Korrektheit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>