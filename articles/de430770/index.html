<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔛 👐🏻 🙅🏾 Backup für Linux oder wie man einen Snapshot erstellt 🔲 🚴🏼 🍖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Ich arbeite bei Veeam am Veeam Agent für Linux-Projekt. Mit diesem Produkt können Sie einen Linux-Computer sichern. "Agent" im Namen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Backup für Linux oder wie man einen Snapshot erstellt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/430770/">  Hallo allerseits!  Ich arbeite bei Veeam am Veeam Agent für Linux-Projekt.  Mit diesem Produkt können Sie einen Linux-Computer sichern.  "Agent" im Namen bedeutet, dass Sie mit dem Programm physische Maschinen sichern können.  Virtualalkans sichern ebenfalls, befinden sich jedoch auf dem Gastbetriebssystem. <br><br>  Die Inspiration für diesen Artikel war mein Bericht auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux Piter-</a> Konferenz, den ich als Artikel für alle interessierten Habragiteli herausgeben wollte. <br><br>  In diesem Artikel werde ich das Thema des Erstellens eines Snapshots erläutern, mit dem Sie die Probleme, die beim Erstellen unseres eigenen Mechanismus zum Erstellen von Snapshots von Blockgeräten aufgetreten sind, sichern und erläutern können. <br><br>  Alle Interessierten bitten um einen Schnitt! <br><br><img src="https://habrastorage.org/webt/7w/qi/zh/7wqizhorjrpayiif7gin7adkisk.png"><br><a name="habracut"></a><br><h2>  Ein bisschen Theorie am Anfang </h2><br>  In der Vergangenheit gibt es zwei Ansätze zum Erstellen von Sicherungen: Dateisicherung und Volumensicherung.  Im ersten Fall kopieren wir jede Datei als separates Objekt, im zweiten kopieren wir den gesamten Inhalt des Volumes als eine Art Bild. <br><br>  Beide Methoden haben viele Vor- und Nachteile, aber wir werden sie durch das Prisma der Wiederherstellung nach einem Fehler betrachten: <br><br><ul><li>  Bei der Dateisicherung müssen wir für eine vollständige Wiederherstellung des gesamten Servers zuerst das Betriebssystem und dann die erforderlichen Dienste installieren und erst dann die Dateien aus der Sicherung wiederherstellen. </li><li>  Bei der Volumensicherung reicht es für eine vollständige Wiederherstellung aus, einfach alle Volumes des Computers ohne unnötigen Aufwand seitens der Person wiederherzustellen. </li></ul><br>  Im Fall einer Volumensicherung können Sie das System natürlich schneller wiederherstellen, und dies ist ein wichtiges <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkmal des Systems</a> .  Aus diesem Grund empfehlen wir für uns die Volumensicherung als bevorzugte Option. <br><br>  Wie nehmen und speichern wir das gesamte Volumen?  Natürlich werden wir durch einfaches Kopieren nichts Gutes erreichen.  Während des Kopierens treten einige Aktivitäten mit Daten auf dem Volume auf. Infolgedessen werden die inkonsistenten Daten in der Sicherung angezeigt.  Die Dateisystemstruktur wird verletzt, Datenbankdateien werden beschädigt sowie andere Dateien, mit denen während des Kopierens Vorgänge ausgeführt werden. <br><br>  Um all diese Probleme zu vermeiden, hat die fortschrittliche Menschheit eine Snapshot-Technologie entwickelt - Snapshot.  Theoretisch ist alles einfach: Wir erstellen eine unveränderte Kopie - einen Schnappschuss - und sichern Daten daraus.  Wenn das Backup beendet ist, zerstören wir den Snapshot.  Es klingt einfach, aber wie immer gibt es Nuancen. <br><br>  Aufgrund dessen wurden viele Implementierungen dieser Technologie geboren.  Beispielsweise bieten auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Device Mapper</a> basierende Lösungen wie LVM und Thin Provisioning Snapshots mit vollem Volumen, erfordern jedoch ein spezielles Festplattenlayout in der Phase der Systeminstallation, was bedeutet, dass sie im Allgemeinen nicht geeignet sind. <br><br>  BTRFS und ZFS ermöglichen das Erstellen von Snapshots von Dateisystem-Substrukturen, was sehr cool ist, aber im Moment ist ihr Anteil auf den Servern gering, und wir versuchen, eine universelle Lösung zu finden. <br><br>  Angenommen, auf unserem Blockgerät befindet sich eine banale EXT.  In diesem Fall können wir <a href="">dm-snap verwenden</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dm-bow</a> wird übrigens gerade entwickelt), aber hier ist seine eigene Nuance.  Sie müssen ein kostenloses Blockgerät bereithalten, damit Sie Snapshot-Daten dort ablegen können. <br>  Bei der Betrachtung alternativer Backup-Lösungen haben wir festgestellt, dass sie in der Regel ihr Kernelmodul verwenden, um Snapshots von Blockgeräten zu erstellen.  Wir haben uns für diesen Weg entschieden und unser Modul geschrieben.  Es wurde beschlossen, es unter der GPL-Lizenz zu vertreiben, damit es auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a> öffentlich verfügbar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> . <br><br><h2>  Wie es funktioniert - theoretisch </h2><br><h3>  Mikroskop-Schnappschuss </h3><br>  Nun werden wir das allgemeine Prinzip der Funktionsweise des Moduls betrachten und uns eingehender mit den wichtigsten Fragen befassen. <br><br>  Tatsächlich ist veeamsnap (wie wir unser Kernelmodul genannt haben) ein Blockgerätetreiberfilter. <br><br><img src="https://habrastorage.org/webt/gi/kg/ct/gikgctn2xian0bhuauiogpqqe5c.png"><br><br>  Seine Aufgabe ist es, Anfragen nach einem Blockgerätetreiber abzufangen. <br><br>  Nachdem das Modul eine Schreibanforderung abgefangen hat, kopiert es Daten vom ursprünglichen Blockgerät in den Snapshot-Datenbereich.  Wir nennen diesen Bereich Snapstore. <br><br><img src="https://habrastorage.org/webt/cl/hz/lt/clhzltlt564esinieyefu9gwqka.png"><br><br>  Und was ist der Schnappschuss selbst?  Dies ist ein virtuelles Blockgerät, eine Kopie des Originalgeräts zu einem bestimmten Zeitpunkt.  Wenn Sie auf Datenblöcke auf diesem Gerät zugreifen, können Sie diese entweder vom Snap-In oder vom Originalgerät lesen. <br><br>  Ich möchte darauf hinweisen, dass der Snapshot genau das Blockgerät ist, das zum Zeitpunkt des Entfernens des Snapshots vollständig mit dem Original identisch war.  Dank dessen können wir das Dateisystem auf einem Snapshot mounten und die erforderliche Vorverarbeitung durchführen. <br><br>  Zum Beispiel können wir eine Karte der belegten Blöcke aus dem Dateisystem erhalten.  Der einfachste Weg, dies zu tun, ist die Verwendung von ioctl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GETFSMAP</a> . <br>  Mit Daten auf belegten Blöcken können Sie nur die neuesten Daten aus einem Snapshot lesen. <br><br>  Sie können auch einige Dateien ausschließen.  Nun, eine völlig optionale Aktion: Indizieren Sie die Dateien, die in das Backup fallen, für die Möglichkeit eines granularen Restaurants in der Zukunft. <br><br><h3>  CoW vs RoW </h3><br>  Lassen Sie uns ein wenig auf die Auswahl des Snapshot-Algorithmus eingehen.  Die Auswahl hier ist nicht sehr umfangreich: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Copy-on-Write oder Redirect-on-Write</a> . <br><br>  Redirect-on-Write beim Abfangen einer Schreibanforderung leitet sie an den Snap weiter. Danach werden auch alle Anforderungen zum Lesen dieses Blocks dorthin geleitet.  Ein großartiger Algorithmus für Speichersysteme, die auf B + -Bäumen wie BTRFS, ZFS und Thin Provisioning basieren.  Die Technologie ist so alt wie die Welt, manifestiert sich jedoch besonders gut in Hypervisoren, in denen Sie eine neue Datei erstellen und dort für die Dauer des Snapshots neue Blöcke schreiben können.  Die Leistung ist im Vergleich zu CoW ausgezeichnet.  Es gibt jedoch ein dickes Minus: Die Struktur des Originalgeräts ändert sich. Wenn Sie den Snapshot entfernen, müssen Sie alle Blöcke aus dem Snap an den ursprünglichen Speicherort kopieren. <br><br>  Copy-on-Write kopiert beim Abfangen einer Anforderung Daten in den Snapstore, die geändert werden müssen, und kann anschließend an der ursprünglichen Stelle überschrieben werden.  Wird zum Erstellen von Snapshots für LVM-Volumes und Schattenkopien von VSS verwendet.  Offensichtlich ist es besser geeignet, um Schnappschüsse von Blockgeräten zu erstellen, weil  ändert nicht die Struktur des Originalgeräts, und wenn Sie den Snapshot löschen (oder abstürzen), können Sie ihn einfach verwerfen, ohne Daten zu riskieren.  Der Nachteil dieses Ansatzes ist eine Leistungsverschlechterung, da jeder Schreiboperation einige Lese- / Schreiboperationen hinzugefügt werden. <br><br>  Da Datensicherheit unsere oberste Priorität ist, haben wir uns auf CoW konzentriert. <br><br>  Bisher sieht alles einfach aus, also gehen wir die Probleme des wirklichen Lebens durch. <br><br><h2>  Wie es funktioniert - in der Praxis </h2><br><h3>  Konsistenter Zustand </h3><br>  Für ihn wurde alles konzipiert. <br>  Wenn zum Beispiel zum Zeitpunkt der Erstellung eines Schnappschusses (in erster Näherung können wir davon ausgehen, dass er sofort erstellt wird) ein Datensatz in einer Datei aufgezeichnet wird, ist die Datei in einem Schnappschuss unvollständig, was bedeutet, dass sie beschädigt und bedeutungslos ist.  Ähnlich verhält es sich mit Datenbankdateien und dem Dateisystem selbst. <br><br>  Aber wir leben im 21. Jahrhundert!  Es gibt Protokollierungsmechanismen, die vor solchen Problemen schützen!  Die Wahrheit ist, dass es ein wichtiges „Aber“ gibt: Dieser Schutz ist nicht vor Versagen, sondern vor seinen Folgen.  Bei der Wiederherstellung eines konsistenten Zustands gemäß dem Protokoll werden unvollständige Vorgänge verworfen, was bedeutet, dass sie verloren gehen.  Daher ist es wichtig, die Priorität auf den Schutz vor der Ursache zu verlagern, anstatt die Folgen zu behandeln. <br><br>  Das System kann gewarnt werden, dass jetzt ein Snapshot erstellt wird.  Dafür hat der Kernel die Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">freeze_bdev</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">thaw_bdev</a> .  Sie ziehen die Dateisystemfunktionen freeze_fs und unfreeze_fs.  Wenn Sie den ersten aufrufen, muss das System den Cache zurücksetzen, die Erstellung neuer Anforderungen an das Blockgerät unterbrechen und auf den Abschluss aller zuvor generierten Anforderungen warten.  Und wenn unfreeze_fs aufgerufen wird, stellt das Dateisystem seine normale Funktion wieder her. <br><br>  Es stellt sich heraus, dass wir das Dateisystem warnen können.  Was ist mit Anwendungen?  Hier ist leider alles schlecht.  Unter Windows gibt es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VSS-</a> Mechanismus, der mithilfe von Writers die Interaktion mit anderen Produkten ermöglicht. Unter Linux geht jeder seinen eigenen Weg.  Im Moment hat dies dazu geführt, dass der Systemadministrator die Aufgabe hat, Skripte vor dem Einfrieren und nach dem Auftauen selbst zu schreiben (zu kopieren, zu <s>stehlen</s> , zu kaufen usw.), um seine Anwendung für den Snapshot vorzubereiten.  In der nächsten Version werden wir unsererseits die Unterstützung für Oracle Application Processing einführen, die von unseren Kunden am häufigsten angeforderte Funktion.  Dann werden möglicherweise andere Anwendungen unterstützt, aber insgesamt ist die Situation eher traurig. <br><br><h3>  Wo soll der Druckknopf platziert werden? </h3><br>  Dies ist das zweite Problem, das uns im Weg steht.  Auf den ersten Blick ist das Problem nicht offensichtlich, aber nach ein wenig Verständnis sehen wir, dass dies immer noch ein Splitter ist. <br><br>  Die einfachste Lösung besteht natürlich darin, den Snap im RAM zu platzieren.  Für den Entwickler ist die Option einfach großartig!  Alles ist schnell, sehr bequem zum Debuggen, aber es gibt einen Stau: RAM ist eine wertvolle Ressource, und niemand wird uns dort einen großen Schnappschuss geben. <br><br>  OK, machen wir die Snap-Datei zu einer regulären Datei.  Es tritt jedoch ein anderes Problem auf: Sie können das Volume, auf dem sich der Snapstop befindet, nicht sichern.  Der Grund ist einfach: Wir fangen Aufzeichnungsanforderungen ab, was bedeutet, dass wir unsere eigenen Aufzeichnungsanforderungen im Snap-In abfangen.  Pferde liefen auf wissenschaftliche Weise herum - Deadlock.  Dann besteht der akute Wunsch, dafür eine separate Festplatte zu verwenden, aber niemand wird für uns Festplatten zu unserem Server hinzufügen.  Sie müssen in der Lage sein, an dem zu arbeiten, was ist. <br><br>  Das Remote-Positionieren des Snap-Ins ist eine hervorragende Idee, kann jedoch in sehr engen Kreisen von Netzwerken mit hoher Bandbreite und mikroskopischen Latenzen implementiert werden.  Andernfalls gibt es eine rundenbasierte Strategie, während Sie den Schnappschuss auf der Maschine halten. <br><br>  Sie müssen den Snap also irgendwie schwierig auf der lokalen Festplatte platzieren.  In der Regel ist jedoch der gesamte Speicherplatz auf lokalen Datenträgern bereits auf Dateisysteme verteilt, und gleichzeitig müssen Sie sich überlegen, wie Sie das Deadlock-Problem umgehen können. <br><br>  Die Richtung für die Reflexion ist im Prinzip eine: Sie müssen irgendwie Speicherplatz im Dateisystem zuweisen, aber direkt mit dem Blockgerät arbeiten.  Die Lösung für dieses Problem wurde im Benutzerbereichscode im Dienst implementiert. <br><br>  Es gibt einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fallocate</a> -Systemaufruf, mit dem Sie eine leere Datei mit der gewünschten Größe erstellen können.  Tatsächlich werden jedoch nur Metadaten im Dateisystem erstellt, die den Speicherort der Datei auf dem Volume beschreiben.  Mit ioctl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FIEMAP</a> können wir eine Karte des Speicherorts der Dateiblöcke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abrufen</a> . <br><br>  Und voila: Wir erstellen eine Datei unter Snap mit Fallocate. FIEMAP gibt uns eine Karte des Speicherorts der Blöcke dieser Datei, die wir zur Arbeit in unserem veeamsnap-Modul übertragen können.  Wenn das Modul auf den Snapstor zugreift, sendet es Anforderungen direkt an das Blockgerät in uns bekannten Blöcken und ohne Deadlocks. <br><br>  Aber es gibt eine Nuance.  Der Fallocate-Systemaufruf wird nur von XFS, EXT4 und BTRFS unterstützt.  Bei anderen Dateisystemen wie EXT3 müssen Sie es vollständig schreiben, um die Datei zuzuweisen.  Die Funktionalität wird durch eine längere Zeit für die Zubereitung von Schnappschüssen beeinträchtigt, es gibt jedoch keine andere Wahl.  Auch hier müssen Sie in der Lage sein, an dem zu arbeiten, was ist. <br><br>  Was ist, wenn ioctl FIEMAP ebenfalls nicht unterstützt wird?  Dies ist die Realität von NTFS und FAT32, wo die alte FIBMAP nicht einmal unterstützt wird.  Ich musste einen bestimmten generischen Algorithmus implementieren, dessen Funktionsweise nicht von den Funktionen des Dateisystems abhängt.  Kurz gesagt lautet der Algorithmus: <br><br><ol><li>  Der Dienst erstellt eine Datei und beginnt mit dem Schreiben eines bestimmten Musters. </li><li>  Das Modul fängt Schreibanforderungen ab und überprüft die zu schreibenden Daten. </li><li>  Wenn die Blockdaten mit dem angegebenen Muster übereinstimmen, wird der Block als zum Snapstop gehörend markiert. </li></ol><br>  Ja, schwierig, ja, langsam, aber besser als nichts.  Es wird in seltenen Fällen für Dateisysteme ohne FIEMAP- und FIBMAP-Unterstützung verwendet. <br><br><h3>  Schnappschuss-Überlauf </h3><br>  Vielmehr endet der Platz, den wir unter Snapstore zugewiesen haben.  Das Wesentliche des Problems ist, dass neue Daten nirgends verworfen werden können, was bedeutet, dass der Snapshot unbrauchbar wird. <br>  Was zu tun ist? <br><br>  Natürlich müssen Sie die Größe der Schnappschüsse erhöhen.  Wie viel?  Der einfachste Weg, die Größe von Snappants festzulegen, besteht darin, den Prozentsatz des freien Speicherplatzes auf dem Volume zu bestimmen (wie bei VSS).  Bei einem Volumen von 20 TB sind 10% 2 TB - was für einen entladenen Server sehr viel ist.  Bei einem Volumen von 200 GB sind 10% 20 GB, was für einen Server, der seine Daten intensiv aktualisiert, möglicherweise zu wenig ist.  Und es gibt immer noch dünne Bände ... <br><br>  Im Allgemeinen kann nur der Systemadministrator des Servers die optimale Größe des erforderlichen Snap-In im Voraus ermitteln. Das heißt, Sie müssen die Person zum Nachdenken anregen und ihre Expertenmeinung abgeben.  Dies entspricht nicht dem Prinzip „Es funktioniert einfach“. <br><br>  Um dieses Problem zu lösen, haben wir den Stretch-Snapshot-Algorithmus entwickelt.  Die Idee ist, den Druckknopf in Teile zu zerlegen.  Gleichzeitig werden nach der Erstellung eines Snapshots nach Bedarf neue Teile erstellt. <br><br><img src="https://habrastorage.org/webt/7l/wi/72/7lwi72wjiwrmq9-jms-tartz6go.png"><br><br>  Nochmals kurz der Algorithmus: <br><br><ol><li>  Vor dem Erstellen eines Snapshots wird der erste Teil des Snapshots erstellt und dem Modul übergeben. </li><li>  Wenn der Schnappschuss erstellt wird, füllt sich der Teil. </li><li>  Sobald die Hälfte des Teils voll ist, wird eine Anfrage an den Dienst gesendet, um einen neuen zu erstellen. </li><li>  Der Dienst erstellt es und gibt die Daten an das Modul weiter. </li><li>  Das Modul beginnt, die nächste Charge zu füllen. </li><li>  Der Algorithmus wird wiederholt, bis die Sicherung abgeschlossen ist oder bis die Verwendung von freiem Speicherplatz begrenzt ist. </li></ol><br>  Es ist wichtig zu beachten, dass das Modul Zeit haben muss, um bei Bedarf neue Teile von Snapposts zu erstellen. Andernfalls - Überlauf, Zurücksetzen von Snapshots und keine Sicherung.  Daher ist die Bedienung eines solchen Algorithmus nur auf Dateisystemen mit Fallocate-Unterstützung möglich, in denen Sie schnell eine leere Datei erstellen können. <br><br>  Was ist in anderen Fällen zu tun?  Wir versuchen, die erforderliche Größe zu erraten und den gesamten Snappast vollständig zu erstellen.  Laut unseren Statistiken verwendet die überwiegende Mehrheit der Linux-Server jetzt EXT4 und XFS.  EXT3 ist auf älteren Maschinen zu finden.  In SLES / openSUSE können Sie jedoch auf BTRFS stoßen. <br><br><h3>  Blockverfolgung ändern (CBT) </h3><br>  Inkrementelle oder differenzielle Sicherung (Radieschen-Meerrettich ist übrigens süßer oder nicht, ich schlage vor, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier zu</a> lesen) - ohne diese können Sie sich kein Sicherungsprodukt für Erwachsene vorstellen.  Und damit dies funktioniert, benötigen Sie CBT.  Wenn jemand etwas verpasst hat: Mit CBT können Sie Änderungen verfolgen und nur die Daten in die Sicherung schreiben, die seit der letzten Sicherung geändert wurden. <br><br><img src="https://habrastorage.org/webt/fk/mf/z0/fkmfz0-pa9lbjdktlu2yovstkuk.png"><br><br>  Viele haben ihre eigenen Erfahrungen in diesem Bereich.  In VMware vSphere ist diese Funktion beispielsweise seit Version 4 im Jahr 2009 verfügbar.  In Hyper-V wurde die Unterstützung mit Windows Server 2016 eingeführt. Um frühere Versionen zu unterstützen, wurde bereits 2012 ein eigener VeeamFCT-Treiber entwickelt.  Daher wurden wir für unser Modul nicht original und verwendeten bereits funktionierende Algorithmen. <br>  Wie es funktioniert. <br><br><img src="https://habrastorage.org/webt/hs/fn/vj/hsfnvjyzfywjynwynlh9jkibaug.png"><br><br>  Das gesamte verfolgte Volumen ist in Blöcke unterteilt.  Das Modul verfolgt einfach alle Schreibanforderungen und markiert die geänderten Blöcke in der Tabelle.  Tatsächlich ist die CBT-Tabelle ein Array von Bytes, wobei jedes Byte einem Block entspricht und die Nummer des Snapshots enthält, in dem es geändert wurde. <br>  Während der Sicherung wird die Snapshot-Nummer in den Sicherungsmetadaten aufgezeichnet.  Wenn Sie also die Nummern des aktuellen Snapshots und die Nummer kennen, aus der die vorherige erfolgreiche Sicherung erstellt wurde, können Sie die Karte des Speicherorts der geänderten Blöcke berechnen. <br><br>  Es gibt zwei Nuancen. <br><br>  Wie bereits erwähnt, wird der Snapshot-Nummer in der CBT-Tabelle ein Byte zugewiesen. Dies bedeutet, dass die maximale Länge der inkrementellen Kette nicht mehr als 255 betragen darf. Wenn dieser Schwellenwert erreicht ist, wird die Tabelle zurückgesetzt und eine vollständige Sicherung durchgeführt.  Es mag unpraktisch erscheinen, aber tatsächlich ist eine Kette von 255 Schritten bei weitem nicht die beste Lösung, wenn Sie einen Sicherungsplan erstellen. <br>  Das zweite Merkmal ist die Speicherung der CBT-Tabelle nur im RAM.  Wenn Sie den Zielcomputer neu starten oder das Modul entladen, wird es zurückgesetzt, und Sie müssen erneut eine vollständige Sicherung erstellen.  Eine solche Lösung ermöglicht es, das Problem des Modulstarts beim Systemstart nicht zu lösen.  Außerdem müssen beim Ausschalten des Systems keine CBT-Tabellen gespeichert werden. <br><br><h3>  Leistungsproblem </h3><br>  Backup ist immer eine gute Belastung für die E / A Ihrer Geräte.  Wenn bereits genügend aktive Aufgaben vorhanden sind, kann der Sicherungsprozess Ihr System in eine Art <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Faultier</a> verwandeln. <br>  Mal sehen warum. <br><br>  Stellen Sie sich vor, der Server schreibt einige Daten einfach linear.  Die Aufnahmegeschwindigkeit ist in diesem Fall maximal, alle Verzögerungen werden minimiert, die Leistung tendiert zum Maximum.  Jetzt fügen wir hier den Sicherungsprozess hinzu, der bei jedem Schreibvorgang noch den Copy-on-Write-Algorithmus ausführen muss. Dies ist eine zusätzliche Leseoperation mit anschließendem Schreibvorgang.  Und vergessen Sie nicht, dass Sie für die Sicherung immer noch Daten von demselben Volume lesen müssen.  Mit einem Wort, Ihr schöner linearer Zugriff wird zu einem gnadenlosen Direktzugriff mit allen Konsequenzen. <br><br>  Wir müssen offensichtlich etwas damit anfangen, und wir haben eine Pipeline implementiert, um Anforderungen nicht einzeln, sondern in ganzen Paketen zu verarbeiten.  Es funktioniert so. <br><br><img src="https://habrastorage.org/webt/br/js/pz/brjspz1fvl7yjtk_hqc_hyupb1a.png"><br><br>  Beim Abfangen von Anforderungen werden sie in eine Warteschlange gestellt, wo sie von einem speziellen Stream in Portionen aufgenommen werden.  Zu diesem Zeitpunkt werden CoW-Anforderungen erstellt, die auch stapelweise verarbeitet werden.  Bei der Verarbeitung von CoW-Anforderungen werden zunächst alle Leseoperationen für den gesamten Teil ausgeführt, wonach Schreiboperationen ausgeführt werden.  Erst nachdem die Verarbeitung des gesamten Teils der CoW-Anforderungen abgeschlossen ist, werden abgefangene Anforderungen ausgeführt.  Ein solcher Förderer ermöglicht den Zugriff auf die Platte in großen Datenblöcken, wodurch Zeitverluste minimiert werden. <br><br><h3>  Drosselung </h3><br>  Bereits beim Debuggen tauchte eine weitere Nuance auf.  Während der Sicherung reagierte das System nicht mehr, d.h.  System-E / A-Anforderungen wurden mit langen Verzögerungen ausgeführt.  Anforderungen zum Lesen von Daten aus einem Schnappschuss wurden jedoch mit einer Geschwindigkeit nahe dem Maximum ausgeführt. <br>  Ich musste den Sicherungsprozess ein wenig erwürgen, indem ich den Drosselungsmechanismus implementierte.  Zu diesem Zweck wird der Prozess, der aus dem Snapshot-Image gelesen wird, in einen Wartezustand versetzt, wenn die Warteschlange abgefangener Anforderungen nicht leer ist.  Erwartungsgemäß wurde das System zum Leben erweckt. <br><br><img src="https://habrastorage.org/webt/6c/f1/cj/6cf1cjerzumb96qaeslvikyobpo.png"><br><br>  Wenn die Belastung des E / A-Systems stark zunimmt, wartet der Lesevorgang aus dem Snapshot.  Hier haben wir uns von dem Prinzip leiten lassen, dass es besser ist, die Sicherung mit einem Fehler zu beenden, als den Server zu stören. <br><br><h3>  Deadlock </h3><br>  Ich denke, wir müssen genauer erklären, was es ist. <br><br>  Bereits in der Testphase stießen wir mit der Diagnose von sieben Problemen - einem Zurücksetzen - auf Situationen, in denen das System vollständig hängen blieb. <br><br>  Sie begannen zu verstehen.  Es stellte sich heraus, dass eine solche Situation beobachtet werden kann, wenn Sie beispielsweise einen Snapshot des Blockgeräts erstellen, auf dem sich das LVM-Volume befindet, und den Snapshot auf demselben LVM-Volume platzieren.  Ich möchte Sie daran erinnern, dass LVM das Device Mapper-Kernelmodul verwendet. <br><br><img src="https://habrastorage.org/webt/xs/n7/ac/xsn7ac1peh0sefyanlbk_2yrvb8.png"><br><br>  In dieser Situation sendet das Modul beim Abfangen einer Schreibanforderung beim Schreiben der Daten in das Snap-In die Schreibanforderung an das LVM-Volume.  Der Geräte-Mapper leitet diese Anforderung an das Blockierungsgerät weiter.  Eine Anfrage vom Device Mapper wird erneut vom Modul abgefangen.  Eine neue Anfrage kann jedoch erst bearbeitet werden, wenn die vorherige bearbeitet wurde.  Infolgedessen wird die Anforderungsverarbeitung blockiert, und Sie werden von einem Deadlock begrüßt. <br><br>  Um dies zu verhindern, bietet das Kernelmodul selbst eine Zeitüberschreitung für das Kopieren von Daten in das Snap-In.  Auf diese Weise können Sie Deadlocks und Absturzsicherungen erkennen.  Die Logik hier ist dieselbe: Es ist besser, nicht zu sichern, als den Server anzuhalten. <br><br><h3>  Round-Robin-Datenbank </h3><br>  Dies ist bereits ein Problem, das Benutzer nach der Veröffentlichung der ersten Version haben. <br>  Es stellte sich heraus, dass es solche Dienste gibt, die nur ständig dieselben Blöcke überschreiben.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein markantes Beispiel sind Überwachungsdienste, die ständig Daten zum Systemzustand generieren und diese in einem Kreis überschreiben. </font><font style="vertical-align: inherit;">Verwenden Sie für solche Aufgaben spezielle zyklische Datenbanken ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellte sich heraus, dass bei einer Sicherung solcher Basen der Snapshot garantiert überläuft. </font><font style="vertical-align: inherit;">In einer detaillierten Untersuchung des Problems haben wir einen Fehler in der Implementierung des CoW-Algorithmus festgestellt. </font><font style="vertical-align: inherit;">Wenn derselbe Block überschrieben wurde, wurden die Daten jedes Mal in das Snap-In kopiert. </font><font style="vertical-align: inherit;">Ergebnis: Duplizieren von Daten im Snap. </font></font><br><br><img src="https://habrastorage.org/webt/tk/vf/ox/tkvfox_gygmf4gxh0cz_igw_jzw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich haben wir den Algorithmus geändert. </font><font style="vertical-align: inherit;">Jetzt wird das Volume in Blöcke unterteilt und die Daten in den Snap-Block kopiert. </font><font style="vertical-align: inherit;">Wenn der Block bereits einmal kopiert wurde, wird dieser Vorgang nicht wiederholt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auswahl der Blockgröße </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn nun der Snapstrap in Blöcke zerlegt wird, stellt sich die Frage: Wie groß sind die Blöcke tatsächlich, um Snappastes aufzuteilen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem ist zweifach. Wenn der Block groß gemacht wird, ist die Bedienung für sie einfacher. Wenn sich jedoch mindestens ein Sektor ändert, müssen Sie den gesamten Block an das Rig senden, wodurch die Wahrscheinlichkeit einer Überfüllung des Rigs erhöht wird. </font></font><br><br><img src="https://habrastorage.org/webt/dk/fy/a_/dkfya_bevzkd5mx10_pnkbxbajm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je kleiner die Blockgröße ist, desto mehr nützliche Daten werden natürlich an den Snapstore gesendet. Wie wirkt sich dies natürlich auf die Leistung aus? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie suchten empirisch nach der Wahrheit und kamen auf 16 KB. Beachten Sie auch, dass Windows VSS auch 16 KiB-Blöcke verwendet.</font></font><br><br><h2>  Anstelle einer Schlussfolgerung </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist alles für jetzt. </font><font style="vertical-align: inherit;">Ich werde viele andere, nicht weniger interessante Probleme hinterlassen, wie die Abhängigkeit von Kernelversionen, die Auswahl der Modulverteilungsoptionen, die kABI-Kompatibilität, die Arbeit unter Backport-Bedingungen usw. </font><font style="vertical-align: inherit;">Der Artikel erwies sich als umfangreich, daher beschloss ich, mich mit den interessantesten Problemen zu befassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt bereiten wir uns auf Release 3.0 vor, der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modulcode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist auf </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Github</font></a><font style="vertical-align: inherit;"> und jeder kann ihn unter der GPL-Lizenz verwenden.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430770/">https://habr.com/ru/post/de430770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430754/index.html">Fügen Sie 2D-Sprites mithilfe von handgezeichneten normalen Karten Tiefe hinzu</a></li>
<li><a href="../de430756/index.html">Herstellung der WX-Maus im Nova Slider 600</a></li>
<li><a href="../de430762/index.html">So wählen Sie eine USV aus, um die Kosten zu optimieren</a></li>
<li><a href="../de430766/index.html">Alles dreht sich um Agile 1: Beliebte Agenda-Mythen</a></li>
<li><a href="../de430768/index.html">Interview mit ADOM-Erfinder Thomas Biscap</a></li>
<li><a href="../de430774/index.html">Bist du bereit für KI auf Werbetafeln?</a></li>
<li><a href="../de430776/index.html">Eine IP zu erstellen ist der einzige Weg</a></li>
<li><a href="../de430778/index.html">3DEXPERIENCE End-to-End-Entwurfsprozess für elektrische Systeme</a></li>
<li><a href="../de430780/index.html">Sequenz-zu-Sequenz-Teil-1-Modelle</a></li>
<li><a href="../de430782/index.html">Wie viele Programmierer benötigen Sie, um zuvor geschriebenen Code zu unterstützen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>