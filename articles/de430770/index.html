<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîõ üëêüèª üôÖüèæ Backup f√ºr Linux oder wie man einen Snapshot erstellt üî≤ üö¥üèº üçñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Ich arbeite bei Veeam am Veeam Agent f√ºr Linux-Projekt. Mit diesem Produkt k√∂nnen Sie einen Linux-Computer sichern. "Agent" im Namen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Backup f√ºr Linux oder wie man einen Snapshot erstellt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/430770/">  Hallo allerseits!  Ich arbeite bei Veeam am Veeam Agent f√ºr Linux-Projekt.  Mit diesem Produkt k√∂nnen Sie einen Linux-Computer sichern.  "Agent" im Namen bedeutet, dass Sie mit dem Programm physische Maschinen sichern k√∂nnen.  Virtualalkans sichern ebenfalls, befinden sich jedoch auf dem Gastbetriebssystem. <br><br>  Die Inspiration f√ºr diesen Artikel war mein Bericht auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux Piter-</a> Konferenz, den ich als Artikel f√ºr alle interessierten Habragiteli herausgeben wollte. <br><br>  In diesem Artikel werde ich das Thema des Erstellens eines Snapshots erl√§utern, mit dem Sie die Probleme, die beim Erstellen unseres eigenen Mechanismus zum Erstellen von Snapshots von Blockger√§ten aufgetreten sind, sichern und erl√§utern k√∂nnen. <br><br>  Alle Interessierten bitten um einen Schnitt! <br><br><img src="https://habrastorage.org/webt/7w/qi/zh/7wqizhorjrpayiif7gin7adkisk.png"><br><a name="habracut"></a><br><h2>  Ein bisschen Theorie am Anfang </h2><br>  In der Vergangenheit gibt es zwei Ans√§tze zum Erstellen von Sicherungen: Dateisicherung und Volumensicherung.  Im ersten Fall kopieren wir jede Datei als separates Objekt, im zweiten kopieren wir den gesamten Inhalt des Volumes als eine Art Bild. <br><br>  Beide Methoden haben viele Vor- und Nachteile, aber wir werden sie durch das Prisma der Wiederherstellung nach einem Fehler betrachten: <br><br><ul><li>  Bei der Dateisicherung m√ºssen wir f√ºr eine vollst√§ndige Wiederherstellung des gesamten Servers zuerst das Betriebssystem und dann die erforderlichen Dienste installieren und erst dann die Dateien aus der Sicherung wiederherstellen. </li><li>  Bei der Volumensicherung reicht es f√ºr eine vollst√§ndige Wiederherstellung aus, einfach alle Volumes des Computers ohne unn√∂tigen Aufwand seitens der Person wiederherzustellen. </li></ul><br>  Im Fall einer Volumensicherung k√∂nnen Sie das System nat√ºrlich schneller wiederherstellen, und dies ist ein wichtiges <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkmal des Systems</a> .  Aus diesem Grund empfehlen wir f√ºr uns die Volumensicherung als bevorzugte Option. <br><br>  Wie nehmen und speichern wir das gesamte Volumen?  Nat√ºrlich werden wir durch einfaches Kopieren nichts Gutes erreichen.  W√§hrend des Kopierens treten einige Aktivit√§ten mit Daten auf dem Volume auf. Infolgedessen werden die inkonsistenten Daten in der Sicherung angezeigt.  Die Dateisystemstruktur wird verletzt, Datenbankdateien werden besch√§digt sowie andere Dateien, mit denen w√§hrend des Kopierens Vorg√§nge ausgef√ºhrt werden. <br><br>  Um all diese Probleme zu vermeiden, hat die fortschrittliche Menschheit eine Snapshot-Technologie entwickelt - Snapshot.  Theoretisch ist alles einfach: Wir erstellen eine unver√§nderte Kopie - einen Schnappschuss - und sichern Daten daraus.  Wenn das Backup beendet ist, zerst√∂ren wir den Snapshot.  Es klingt einfach, aber wie immer gibt es Nuancen. <br><br>  Aufgrund dessen wurden viele Implementierungen dieser Technologie geboren.  Beispielsweise bieten auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Device Mapper</a> basierende L√∂sungen wie LVM und Thin Provisioning Snapshots mit vollem Volumen, erfordern jedoch ein spezielles Festplattenlayout in der Phase der Systeminstallation, was bedeutet, dass sie im Allgemeinen nicht geeignet sind. <br><br>  BTRFS und ZFS erm√∂glichen das Erstellen von Snapshots von Dateisystem-Substrukturen, was sehr cool ist, aber im Moment ist ihr Anteil auf den Servern gering, und wir versuchen, eine universelle L√∂sung zu finden. <br><br>  Angenommen, auf unserem Blockger√§t befindet sich eine banale EXT.  In diesem Fall k√∂nnen wir <a href="">dm-snap verwenden</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dm-bow</a> wird √ºbrigens gerade entwickelt), aber hier ist seine eigene Nuance.  Sie m√ºssen ein kostenloses Blockger√§t bereithalten, damit Sie Snapshot-Daten dort ablegen k√∂nnen. <br>  Bei der Betrachtung alternativer Backup-L√∂sungen haben wir festgestellt, dass sie in der Regel ihr Kernelmodul verwenden, um Snapshots von Blockger√§ten zu erstellen.  Wir haben uns f√ºr diesen Weg entschieden und unser Modul geschrieben.  Es wurde beschlossen, es unter der GPL-Lizenz zu vertreiben, damit es auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a> √∂ffentlich verf√ºgbar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> . <br><br><h2>  Wie es funktioniert - theoretisch </h2><br><h3>  Mikroskop-Schnappschuss </h3><br>  Nun werden wir das allgemeine Prinzip der Funktionsweise des Moduls betrachten und uns eingehender mit den wichtigsten Fragen befassen. <br><br>  Tats√§chlich ist veeamsnap (wie wir unser Kernelmodul genannt haben) ein Blockger√§tetreiberfilter. <br><br><img src="https://habrastorage.org/webt/gi/kg/ct/gikgctn2xian0bhuauiogpqqe5c.png"><br><br>  Seine Aufgabe ist es, Anfragen nach einem Blockger√§tetreiber abzufangen. <br><br>  Nachdem das Modul eine Schreibanforderung abgefangen hat, kopiert es Daten vom urspr√ºnglichen Blockger√§t in den Snapshot-Datenbereich.  Wir nennen diesen Bereich Snapstore. <br><br><img src="https://habrastorage.org/webt/cl/hz/lt/clhzltlt564esinieyefu9gwqka.png"><br><br>  Und was ist der Schnappschuss selbst?  Dies ist ein virtuelles Blockger√§t, eine Kopie des Originalger√§ts zu einem bestimmten Zeitpunkt.  Wenn Sie auf Datenbl√∂cke auf diesem Ger√§t zugreifen, k√∂nnen Sie diese entweder vom Snap-In oder vom Originalger√§t lesen. <br><br>  Ich m√∂chte darauf hinweisen, dass der Snapshot genau das Blockger√§t ist, das zum Zeitpunkt des Entfernens des Snapshots vollst√§ndig mit dem Original identisch war.  Dank dessen k√∂nnen wir das Dateisystem auf einem Snapshot mounten und die erforderliche Vorverarbeitung durchf√ºhren. <br><br>  Zum Beispiel k√∂nnen wir eine Karte der belegten Bl√∂cke aus dem Dateisystem erhalten.  Der einfachste Weg, dies zu tun, ist die Verwendung von ioctl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GETFSMAP</a> . <br>  Mit Daten auf belegten Bl√∂cken k√∂nnen Sie nur die neuesten Daten aus einem Snapshot lesen. <br><br>  Sie k√∂nnen auch einige Dateien ausschlie√üen.  Nun, eine v√∂llig optionale Aktion: Indizieren Sie die Dateien, die in das Backup fallen, f√ºr die M√∂glichkeit eines granularen Restaurants in der Zukunft. <br><br><h3>  CoW vs RoW </h3><br>  Lassen Sie uns ein wenig auf die Auswahl des Snapshot-Algorithmus eingehen.  Die Auswahl hier ist nicht sehr umfangreich: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Copy-on-Write oder Redirect-on-Write</a> . <br><br>  Redirect-on-Write beim Abfangen einer Schreibanforderung leitet sie an den Snap weiter. Danach werden auch alle Anforderungen zum Lesen dieses Blocks dorthin geleitet.  Ein gro√üartiger Algorithmus f√ºr Speichersysteme, die auf B + -B√§umen wie BTRFS, ZFS und Thin Provisioning basieren.  Die Technologie ist so alt wie die Welt, manifestiert sich jedoch besonders gut in Hypervisoren, in denen Sie eine neue Datei erstellen und dort f√ºr die Dauer des Snapshots neue Bl√∂cke schreiben k√∂nnen.  Die Leistung ist im Vergleich zu CoW ausgezeichnet.  Es gibt jedoch ein dickes Minus: Die Struktur des Originalger√§ts √§ndert sich. Wenn Sie den Snapshot entfernen, m√ºssen Sie alle Bl√∂cke aus dem Snap an den urspr√ºnglichen Speicherort kopieren. <br><br>  Copy-on-Write kopiert beim Abfangen einer Anforderung Daten in den Snapstore, die ge√§ndert werden m√ºssen, und kann anschlie√üend an der urspr√ºnglichen Stelle √ºberschrieben werden.  Wird zum Erstellen von Snapshots f√ºr LVM-Volumes und Schattenkopien von VSS verwendet.  Offensichtlich ist es besser geeignet, um Schnappsch√ºsse von Blockger√§ten zu erstellen, weil  √§ndert nicht die Struktur des Originalger√§ts, und wenn Sie den Snapshot l√∂schen (oder abst√ºrzen), k√∂nnen Sie ihn einfach verwerfen, ohne Daten zu riskieren.  Der Nachteil dieses Ansatzes ist eine Leistungsverschlechterung, da jeder Schreiboperation einige Lese- / Schreiboperationen hinzugef√ºgt werden. <br><br>  Da Datensicherheit unsere oberste Priorit√§t ist, haben wir uns auf CoW konzentriert. <br><br>  Bisher sieht alles einfach aus, also gehen wir die Probleme des wirklichen Lebens durch. <br><br><h2>  Wie es funktioniert - in der Praxis </h2><br><h3>  Konsistenter Zustand </h3><br>  F√ºr ihn wurde alles konzipiert. <br>  Wenn zum Beispiel zum Zeitpunkt der Erstellung eines Schnappschusses (in erster N√§herung k√∂nnen wir davon ausgehen, dass er sofort erstellt wird) ein Datensatz in einer Datei aufgezeichnet wird, ist die Datei in einem Schnappschuss unvollst√§ndig, was bedeutet, dass sie besch√§digt und bedeutungslos ist.  √Ñhnlich verh√§lt es sich mit Datenbankdateien und dem Dateisystem selbst. <br><br>  Aber wir leben im 21. Jahrhundert!  Es gibt Protokollierungsmechanismen, die vor solchen Problemen sch√ºtzen!  Die Wahrheit ist, dass es ein wichtiges ‚ÄûAber‚Äú gibt: Dieser Schutz ist nicht vor Versagen, sondern vor seinen Folgen.  Bei der Wiederherstellung eines konsistenten Zustands gem√§√ü dem Protokoll werden unvollst√§ndige Vorg√§nge verworfen, was bedeutet, dass sie verloren gehen.  Daher ist es wichtig, die Priorit√§t auf den Schutz vor der Ursache zu verlagern, anstatt die Folgen zu behandeln. <br><br>  Das System kann gewarnt werden, dass jetzt ein Snapshot erstellt wird.  Daf√ºr hat der Kernel die Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">freeze_bdev</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">thaw_bdev</a> .  Sie ziehen die Dateisystemfunktionen freeze_fs und unfreeze_fs.  Wenn Sie den ersten aufrufen, muss das System den Cache zur√ºcksetzen, die Erstellung neuer Anforderungen an das Blockger√§t unterbrechen und auf den Abschluss aller zuvor generierten Anforderungen warten.  Und wenn unfreeze_fs aufgerufen wird, stellt das Dateisystem seine normale Funktion wieder her. <br><br>  Es stellt sich heraus, dass wir das Dateisystem warnen k√∂nnen.  Was ist mit Anwendungen?  Hier ist leider alles schlecht.  Unter Windows gibt es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VSS-</a> Mechanismus, der mithilfe von Writers die Interaktion mit anderen Produkten erm√∂glicht. Unter Linux geht jeder seinen eigenen Weg.  Im Moment hat dies dazu gef√ºhrt, dass der Systemadministrator die Aufgabe hat, Skripte vor dem Einfrieren und nach dem Auftauen selbst zu schreiben (zu kopieren, zu <s>stehlen</s> , zu kaufen usw.), um seine Anwendung f√ºr den Snapshot vorzubereiten.  In der n√§chsten Version werden wir unsererseits die Unterst√ºtzung f√ºr Oracle Application Processing einf√ºhren, die von unseren Kunden am h√§ufigsten angeforderte Funktion.  Dann werden m√∂glicherweise andere Anwendungen unterst√ºtzt, aber insgesamt ist die Situation eher traurig. <br><br><h3>  Wo soll der Druckknopf platziert werden? </h3><br>  Dies ist das zweite Problem, das uns im Weg steht.  Auf den ersten Blick ist das Problem nicht offensichtlich, aber nach ein wenig Verst√§ndnis sehen wir, dass dies immer noch ein Splitter ist. <br><br>  Die einfachste L√∂sung besteht nat√ºrlich darin, den Snap im RAM zu platzieren.  F√ºr den Entwickler ist die Option einfach gro√üartig!  Alles ist schnell, sehr bequem zum Debuggen, aber es gibt einen Stau: RAM ist eine wertvolle Ressource, und niemand wird uns dort einen gro√üen Schnappschuss geben. <br><br>  OK, machen wir die Snap-Datei zu einer regul√§ren Datei.  Es tritt jedoch ein anderes Problem auf: Sie k√∂nnen das Volume, auf dem sich der Snapstop befindet, nicht sichern.  Der Grund ist einfach: Wir fangen Aufzeichnungsanforderungen ab, was bedeutet, dass wir unsere eigenen Aufzeichnungsanforderungen im Snap-In abfangen.  Pferde liefen auf wissenschaftliche Weise herum - Deadlock.  Dann besteht der akute Wunsch, daf√ºr eine separate Festplatte zu verwenden, aber niemand wird f√ºr uns Festplatten zu unserem Server hinzuf√ºgen.  Sie m√ºssen in der Lage sein, an dem zu arbeiten, was ist. <br><br>  Das Remote-Positionieren des Snap-Ins ist eine hervorragende Idee, kann jedoch in sehr engen Kreisen von Netzwerken mit hoher Bandbreite und mikroskopischen Latenzen implementiert werden.  Andernfalls gibt es eine rundenbasierte Strategie, w√§hrend Sie den Schnappschuss auf der Maschine halten. <br><br>  Sie m√ºssen den Snap also irgendwie schwierig auf der lokalen Festplatte platzieren.  In der Regel ist jedoch der gesamte Speicherplatz auf lokalen Datentr√§gern bereits auf Dateisysteme verteilt, und gleichzeitig m√ºssen Sie sich √ºberlegen, wie Sie das Deadlock-Problem umgehen k√∂nnen. <br><br>  Die Richtung f√ºr die Reflexion ist im Prinzip eine: Sie m√ºssen irgendwie Speicherplatz im Dateisystem zuweisen, aber direkt mit dem Blockger√§t arbeiten.  Die L√∂sung f√ºr dieses Problem wurde im Benutzerbereichscode im Dienst implementiert. <br><br>  Es gibt einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fallocate</a> -Systemaufruf, mit dem Sie eine leere Datei mit der gew√ºnschten Gr√∂√üe erstellen k√∂nnen.  Tats√§chlich werden jedoch nur Metadaten im Dateisystem erstellt, die den Speicherort der Datei auf dem Volume beschreiben.  Mit ioctl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FIEMAP</a> k√∂nnen wir eine Karte des Speicherorts der Dateibl√∂cke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abrufen</a> . <br><br>  Und voila: Wir erstellen eine Datei unter Snap mit Fallocate. FIEMAP gibt uns eine Karte des Speicherorts der Bl√∂cke dieser Datei, die wir zur Arbeit in unserem veeamsnap-Modul √ºbertragen k√∂nnen.  Wenn das Modul auf den Snapstor zugreift, sendet es Anforderungen direkt an das Blockger√§t in uns bekannten Bl√∂cken und ohne Deadlocks. <br><br>  Aber es gibt eine Nuance.  Der Fallocate-Systemaufruf wird nur von XFS, EXT4 und BTRFS unterst√ºtzt.  Bei anderen Dateisystemen wie EXT3 m√ºssen Sie es vollst√§ndig schreiben, um die Datei zuzuweisen.  Die Funktionalit√§t wird durch eine l√§ngere Zeit f√ºr die Zubereitung von Schnappsch√ºssen beeintr√§chtigt, es gibt jedoch keine andere Wahl.  Auch hier m√ºssen Sie in der Lage sein, an dem zu arbeiten, was ist. <br><br>  Was ist, wenn ioctl FIEMAP ebenfalls nicht unterst√ºtzt wird?  Dies ist die Realit√§t von NTFS und FAT32, wo die alte FIBMAP nicht einmal unterst√ºtzt wird.  Ich musste einen bestimmten generischen Algorithmus implementieren, dessen Funktionsweise nicht von den Funktionen des Dateisystems abh√§ngt.  Kurz gesagt lautet der Algorithmus: <br><br><ol><li>  Der Dienst erstellt eine Datei und beginnt mit dem Schreiben eines bestimmten Musters. </li><li>  Das Modul f√§ngt Schreibanforderungen ab und √ºberpr√ºft die zu schreibenden Daten. </li><li>  Wenn die Blockdaten mit dem angegebenen Muster √ºbereinstimmen, wird der Block als zum Snapstop geh√∂rend markiert. </li></ol><br>  Ja, schwierig, ja, langsam, aber besser als nichts.  Es wird in seltenen F√§llen f√ºr Dateisysteme ohne FIEMAP- und FIBMAP-Unterst√ºtzung verwendet. <br><br><h3>  Schnappschuss-√úberlauf </h3><br>  Vielmehr endet der Platz, den wir unter Snapstore zugewiesen haben.  Das Wesentliche des Problems ist, dass neue Daten nirgends verworfen werden k√∂nnen, was bedeutet, dass der Snapshot unbrauchbar wird. <br>  Was zu tun ist? <br><br>  Nat√ºrlich m√ºssen Sie die Gr√∂√üe der Schnappsch√ºsse erh√∂hen.  Wie viel?  Der einfachste Weg, die Gr√∂√üe von Snappants festzulegen, besteht darin, den Prozentsatz des freien Speicherplatzes auf dem Volume zu bestimmen (wie bei VSS).  Bei einem Volumen von 20 TB sind 10% 2 TB - was f√ºr einen entladenen Server sehr viel ist.  Bei einem Volumen von 200 GB sind 10% 20 GB, was f√ºr einen Server, der seine Daten intensiv aktualisiert, m√∂glicherweise zu wenig ist.  Und es gibt immer noch d√ºnne B√§nde ... <br><br>  Im Allgemeinen kann nur der Systemadministrator des Servers die optimale Gr√∂√üe des erforderlichen Snap-In im Voraus ermitteln. Das hei√üt, Sie m√ºssen die Person zum Nachdenken anregen und ihre Expertenmeinung abgeben.  Dies entspricht nicht dem Prinzip ‚ÄûEs funktioniert einfach‚Äú. <br><br>  Um dieses Problem zu l√∂sen, haben wir den Stretch-Snapshot-Algorithmus entwickelt.  Die Idee ist, den Druckknopf in Teile zu zerlegen.  Gleichzeitig werden nach der Erstellung eines Snapshots nach Bedarf neue Teile erstellt. <br><br><img src="https://habrastorage.org/webt/7l/wi/72/7lwi72wjiwrmq9-jms-tartz6go.png"><br><br>  Nochmals kurz der Algorithmus: <br><br><ol><li>  Vor dem Erstellen eines Snapshots wird der erste Teil des Snapshots erstellt und dem Modul √ºbergeben. </li><li>  Wenn der Schnappschuss erstellt wird, f√ºllt sich der Teil. </li><li>  Sobald die H√§lfte des Teils voll ist, wird eine Anfrage an den Dienst gesendet, um einen neuen zu erstellen. </li><li>  Der Dienst erstellt es und gibt die Daten an das Modul weiter. </li><li>  Das Modul beginnt, die n√§chste Charge zu f√ºllen. </li><li>  Der Algorithmus wird wiederholt, bis die Sicherung abgeschlossen ist oder bis die Verwendung von freiem Speicherplatz begrenzt ist. </li></ol><br>  Es ist wichtig zu beachten, dass das Modul Zeit haben muss, um bei Bedarf neue Teile von Snapposts zu erstellen. Andernfalls - √úberlauf, Zur√ºcksetzen von Snapshots und keine Sicherung.  Daher ist die Bedienung eines solchen Algorithmus nur auf Dateisystemen mit Fallocate-Unterst√ºtzung m√∂glich, in denen Sie schnell eine leere Datei erstellen k√∂nnen. <br><br>  Was ist in anderen F√§llen zu tun?  Wir versuchen, die erforderliche Gr√∂√üe zu erraten und den gesamten Snappast vollst√§ndig zu erstellen.  Laut unseren Statistiken verwendet die √ºberwiegende Mehrheit der Linux-Server jetzt EXT4 und XFS.  EXT3 ist auf √§lteren Maschinen zu finden.  In SLES / openSUSE k√∂nnen Sie jedoch auf BTRFS sto√üen. <br><br><h3>  Blockverfolgung √§ndern (CBT) </h3><br>  Inkrementelle oder differenzielle Sicherung (Radieschen-Meerrettich ist √ºbrigens s√º√üer oder nicht, ich schlage vor, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier zu</a> lesen) - ohne diese k√∂nnen Sie sich kein Sicherungsprodukt f√ºr Erwachsene vorstellen.  Und damit dies funktioniert, ben√∂tigen Sie CBT.  Wenn jemand etwas verpasst hat: Mit CBT k√∂nnen Sie √Ñnderungen verfolgen und nur die Daten in die Sicherung schreiben, die seit der letzten Sicherung ge√§ndert wurden. <br><br><img src="https://habrastorage.org/webt/fk/mf/z0/fkmfz0-pa9lbjdktlu2yovstkuk.png"><br><br>  Viele haben ihre eigenen Erfahrungen in diesem Bereich.  In VMware vSphere ist diese Funktion beispielsweise seit Version 4 im Jahr 2009 verf√ºgbar.  In Hyper-V wurde die Unterst√ºtzung mit Windows Server 2016 eingef√ºhrt. Um fr√ºhere Versionen zu unterst√ºtzen, wurde bereits 2012 ein eigener VeeamFCT-Treiber entwickelt.  Daher wurden wir f√ºr unser Modul nicht original und verwendeten bereits funktionierende Algorithmen. <br>  Wie es funktioniert. <br><br><img src="https://habrastorage.org/webt/hs/fn/vj/hsfnvjyzfywjynwynlh9jkibaug.png"><br><br>  Das gesamte verfolgte Volumen ist in Bl√∂cke unterteilt.  Das Modul verfolgt einfach alle Schreibanforderungen und markiert die ge√§nderten Bl√∂cke in der Tabelle.  Tats√§chlich ist die CBT-Tabelle ein Array von Bytes, wobei jedes Byte einem Block entspricht und die Nummer des Snapshots enth√§lt, in dem es ge√§ndert wurde. <br>  W√§hrend der Sicherung wird die Snapshot-Nummer in den Sicherungsmetadaten aufgezeichnet.  Wenn Sie also die Nummern des aktuellen Snapshots und die Nummer kennen, aus der die vorherige erfolgreiche Sicherung erstellt wurde, k√∂nnen Sie die Karte des Speicherorts der ge√§nderten Bl√∂cke berechnen. <br><br>  Es gibt zwei Nuancen. <br><br>  Wie bereits erw√§hnt, wird der Snapshot-Nummer in der CBT-Tabelle ein Byte zugewiesen. Dies bedeutet, dass die maximale L√§nge der inkrementellen Kette nicht mehr als 255 betragen darf. Wenn dieser Schwellenwert erreicht ist, wird die Tabelle zur√ºckgesetzt und eine vollst√§ndige Sicherung durchgef√ºhrt.  Es mag unpraktisch erscheinen, aber tats√§chlich ist eine Kette von 255 Schritten bei weitem nicht die beste L√∂sung, wenn Sie einen Sicherungsplan erstellen. <br>  Das zweite Merkmal ist die Speicherung der CBT-Tabelle nur im RAM.  Wenn Sie den Zielcomputer neu starten oder das Modul entladen, wird es zur√ºckgesetzt, und Sie m√ºssen erneut eine vollst√§ndige Sicherung erstellen.  Eine solche L√∂sung erm√∂glicht es, das Problem des Modulstarts beim Systemstart nicht zu l√∂sen.  Au√üerdem m√ºssen beim Ausschalten des Systems keine CBT-Tabellen gespeichert werden. <br><br><h3>  Leistungsproblem </h3><br>  Backup ist immer eine gute Belastung f√ºr die E / A Ihrer Ger√§te.  Wenn bereits gen√ºgend aktive Aufgaben vorhanden sind, kann der Sicherungsprozess Ihr System in eine Art <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Faultier</a> verwandeln. <br>  Mal sehen warum. <br><br>  Stellen Sie sich vor, der Server schreibt einige Daten einfach linear.  Die Aufnahmegeschwindigkeit ist in diesem Fall maximal, alle Verz√∂gerungen werden minimiert, die Leistung tendiert zum Maximum.  Jetzt f√ºgen wir hier den Sicherungsprozess hinzu, der bei jedem Schreibvorgang noch den Copy-on-Write-Algorithmus ausf√ºhren muss. Dies ist eine zus√§tzliche Leseoperation mit anschlie√üendem Schreibvorgang.  Und vergessen Sie nicht, dass Sie f√ºr die Sicherung immer noch Daten von demselben Volume lesen m√ºssen.  Mit einem Wort, Ihr sch√∂ner linearer Zugriff wird zu einem gnadenlosen Direktzugriff mit allen Konsequenzen. <br><br>  Wir m√ºssen offensichtlich etwas damit anfangen, und wir haben eine Pipeline implementiert, um Anforderungen nicht einzeln, sondern in ganzen Paketen zu verarbeiten.  Es funktioniert so. <br><br><img src="https://habrastorage.org/webt/br/js/pz/brjspz1fvl7yjtk_hqc_hyupb1a.png"><br><br>  Beim Abfangen von Anforderungen werden sie in eine Warteschlange gestellt, wo sie von einem speziellen Stream in Portionen aufgenommen werden.  Zu diesem Zeitpunkt werden CoW-Anforderungen erstellt, die auch stapelweise verarbeitet werden.  Bei der Verarbeitung von CoW-Anforderungen werden zun√§chst alle Leseoperationen f√ºr den gesamten Teil ausgef√ºhrt, wonach Schreiboperationen ausgef√ºhrt werden.  Erst nachdem die Verarbeitung des gesamten Teils der CoW-Anforderungen abgeschlossen ist, werden abgefangene Anforderungen ausgef√ºhrt.  Ein solcher F√∂rderer erm√∂glicht den Zugriff auf die Platte in gro√üen Datenbl√∂cken, wodurch Zeitverluste minimiert werden. <br><br><h3>  Drosselung </h3><br>  Bereits beim Debuggen tauchte eine weitere Nuance auf.  W√§hrend der Sicherung reagierte das System nicht mehr, d.h.  System-E / A-Anforderungen wurden mit langen Verz√∂gerungen ausgef√ºhrt.  Anforderungen zum Lesen von Daten aus einem Schnappschuss wurden jedoch mit einer Geschwindigkeit nahe dem Maximum ausgef√ºhrt. <br>  Ich musste den Sicherungsprozess ein wenig erw√ºrgen, indem ich den Drosselungsmechanismus implementierte.  Zu diesem Zweck wird der Prozess, der aus dem Snapshot-Image gelesen wird, in einen Wartezustand versetzt, wenn die Warteschlange abgefangener Anforderungen nicht leer ist.  Erwartungsgem√§√ü wurde das System zum Leben erweckt. <br><br><img src="https://habrastorage.org/webt/6c/f1/cj/6cf1cjerzumb96qaeslvikyobpo.png"><br><br>  Wenn die Belastung des E / A-Systems stark zunimmt, wartet der Lesevorgang aus dem Snapshot.  Hier haben wir uns von dem Prinzip leiten lassen, dass es besser ist, die Sicherung mit einem Fehler zu beenden, als den Server zu st√∂ren. <br><br><h3>  Deadlock </h3><br>  Ich denke, wir m√ºssen genauer erkl√§ren, was es ist. <br><br>  Bereits in der Testphase stie√üen wir mit der Diagnose von sieben Problemen - einem Zur√ºcksetzen - auf Situationen, in denen das System vollst√§ndig h√§ngen blieb. <br><br>  Sie begannen zu verstehen.  Es stellte sich heraus, dass eine solche Situation beobachtet werden kann, wenn Sie beispielsweise einen Snapshot des Blockger√§ts erstellen, auf dem sich das LVM-Volume befindet, und den Snapshot auf demselben LVM-Volume platzieren.  Ich m√∂chte Sie daran erinnern, dass LVM das Device Mapper-Kernelmodul verwendet. <br><br><img src="https://habrastorage.org/webt/xs/n7/ac/xsn7ac1peh0sefyanlbk_2yrvb8.png"><br><br>  In dieser Situation sendet das Modul beim Abfangen einer Schreibanforderung beim Schreiben der Daten in das Snap-In die Schreibanforderung an das LVM-Volume.  Der Ger√§te-Mapper leitet diese Anforderung an das Blockierungsger√§t weiter.  Eine Anfrage vom Device Mapper wird erneut vom Modul abgefangen.  Eine neue Anfrage kann jedoch erst bearbeitet werden, wenn die vorherige bearbeitet wurde.  Infolgedessen wird die Anforderungsverarbeitung blockiert, und Sie werden von einem Deadlock begr√º√üt. <br><br>  Um dies zu verhindern, bietet das Kernelmodul selbst eine Zeit√ºberschreitung f√ºr das Kopieren von Daten in das Snap-In.  Auf diese Weise k√∂nnen Sie Deadlocks und Absturzsicherungen erkennen.  Die Logik hier ist dieselbe: Es ist besser, nicht zu sichern, als den Server anzuhalten. <br><br><h3>  Round-Robin-Datenbank </h3><br>  Dies ist bereits ein Problem, das Benutzer nach der Ver√∂ffentlichung der ersten Version haben. <br>  Es stellte sich heraus, dass es solche Dienste gibt, die nur st√§ndig dieselben Bl√∂cke √ºberschreiben.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein markantes Beispiel sind √úberwachungsdienste, die st√§ndig Daten zum Systemzustand generieren und diese in einem Kreis √ºberschreiben. </font><font style="vertical-align: inherit;">Verwenden Sie f√ºr solche Aufgaben spezielle zyklische Datenbanken ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellte sich heraus, dass bei einer Sicherung solcher Basen der Snapshot garantiert √ºberl√§uft. </font><font style="vertical-align: inherit;">In einer detaillierten Untersuchung des Problems haben wir einen Fehler in der Implementierung des CoW-Algorithmus festgestellt. </font><font style="vertical-align: inherit;">Wenn derselbe Block √ºberschrieben wurde, wurden die Daten jedes Mal in das Snap-In kopiert. </font><font style="vertical-align: inherit;">Ergebnis: Duplizieren von Daten im Snap. </font></font><br><br><img src="https://habrastorage.org/webt/tk/vf/ox/tkvfox_gygmf4gxh0cz_igw_jzw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich haben wir den Algorithmus ge√§ndert. </font><font style="vertical-align: inherit;">Jetzt wird das Volume in Bl√∂cke unterteilt und die Daten in den Snap-Block kopiert. </font><font style="vertical-align: inherit;">Wenn der Block bereits einmal kopiert wurde, wird dieser Vorgang nicht wiederholt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auswahl der Blockgr√∂√üe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn nun der Snapstrap in Bl√∂cke zerlegt wird, stellt sich die Frage: Wie gro√ü sind die Bl√∂cke tats√§chlich, um Snappastes aufzuteilen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem ist zweifach. Wenn der Block gro√ü gemacht wird, ist die Bedienung f√ºr sie einfacher. Wenn sich jedoch mindestens ein Sektor √§ndert, m√ºssen Sie den gesamten Block an das Rig senden, wodurch die Wahrscheinlichkeit einer √úberf√ºllung des Rigs erh√∂ht wird. </font></font><br><br><img src="https://habrastorage.org/webt/dk/fy/a_/dkfya_bevzkd5mx10_pnkbxbajm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je kleiner die Blockgr√∂√üe ist, desto mehr n√ºtzliche Daten werden nat√ºrlich an den Snapstore gesendet. Wie wirkt sich dies nat√ºrlich auf die Leistung aus? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie suchten empirisch nach der Wahrheit und kamen auf 16 KB. Beachten Sie auch, dass Windows VSS auch 16 KiB-Bl√∂cke verwendet.</font></font><br><br><h2>  Anstelle einer Schlussfolgerung </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist alles f√ºr jetzt. </font><font style="vertical-align: inherit;">Ich werde viele andere, nicht weniger interessante Probleme hinterlassen, wie die Abh√§ngigkeit von Kernelversionen, die Auswahl der Modulverteilungsoptionen, die kABI-Kompatibilit√§t, die Arbeit unter Backport-Bedingungen usw. </font><font style="vertical-align: inherit;">Der Artikel erwies sich als umfangreich, daher beschloss ich, mich mit den interessantesten Problemen zu befassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt bereiten wir uns auf Release 3.0 vor, der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modulcode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist auf </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Github</font></a><font style="vertical-align: inherit;"> und jeder kann ihn unter der GPL-Lizenz verwenden.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430770/">https://habr.com/ru/post/de430770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430754/index.html">F√ºgen Sie 2D-Sprites mithilfe von handgezeichneten normalen Karten Tiefe hinzu</a></li>
<li><a href="../de430756/index.html">Herstellung der WX-Maus im Nova Slider 600</a></li>
<li><a href="../de430762/index.html">So w√§hlen Sie eine USV aus, um die Kosten zu optimieren</a></li>
<li><a href="../de430766/index.html">Alles dreht sich um Agile 1: Beliebte Agenda-Mythen</a></li>
<li><a href="../de430768/index.html">Interview mit ADOM-Erfinder Thomas Biscap</a></li>
<li><a href="../de430774/index.html">Bist du bereit f√ºr KI auf Werbetafeln?</a></li>
<li><a href="../de430776/index.html">Eine IP zu erstellen ist der einzige Weg</a></li>
<li><a href="../de430778/index.html">3DEXPERIENCE End-to-End-Entwurfsprozess f√ºr elektrische Systeme</a></li>
<li><a href="../de430780/index.html">Sequenz-zu-Sequenz-Teil-1-Modelle</a></li>
<li><a href="../de430782/index.html">Wie viele Programmierer ben√∂tigen Sie, um zuvor geschriebenen Code zu unterst√ºtzen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>