<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴 🐯 👩🏽‍🎨 Analisis log Nginx menggunakan Amazon Athena dan Cube.js 👾 🤳🏼 ⛹️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Biasanya, Nginx menggunakan produk komersial atau alternatif open-source, seperti Prometheus + Grafana, untuk memantau dan menganalisis kinerja Nginx....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis log Nginx menggunakan Amazon Athena dan Cube.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447886/"><p>  Biasanya, Nginx menggunakan produk komersial atau alternatif open-source, seperti Prometheus + Grafana, untuk memantau dan menganalisis kinerja Nginx.  Ini adalah opsi yang baik untuk pemantauan atau analitik waktu nyata, tetapi tidak terlalu nyaman untuk analisis historis.  Pada sumber daya populer apa pun, jumlah data dari log nginx tumbuh dengan cepat, dan logis untuk menggunakan sesuatu yang lebih khusus untuk menganalisis sejumlah besar data. </p><br><p> Pada artikel ini saya akan memberi tahu Anda cara menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Athena</a> untuk menganalisis log menggunakan Nginx sebagai contoh, dan menunjukkan cara mengkompilasi dashboard analitis dari data ini menggunakan kerangka <a href="">cube.js</a> open-source.  Berikut adalah arsitektur solusi lengkap: </p><br><p><img src="https://habrastorage.org/webt/km/xo/3i/kmxo3izommuyzgajw20t6-aolcg.png" alt="Arsitektur"></p><br><p>  TL: DR; <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan ke dasbor jadi</a> . </p><a name="habracut"></a><br><p>  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fluentd</a> untuk mengumpulkan informasi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AWS Kinesis Data Firehose</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AWS Glue</a> untuk diproses, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AWS S3</a> untuk penyimpanan.  Dengan bundel ini Anda dapat menyimpan tidak hanya log nginx, tetapi juga acara lainnya, serta log layanan lainnya.  Anda dapat mengganti beberapa bagian dengan bagian yang serupa untuk tumpukan Anda, misalnya, Anda dapat menulis log ke kinesis langsung dari nginx, mem-bypass fluentd, atau menggunakan logstash untuk ini. </p><br><h2 id="sobiraem-logi-nginx">  Mengumpulkan Log Nginx </h2><br><p>  Secara default, log Nginx terlihat seperti ini: </p><br><pre><code class="bash hljs">4/9/2019 12:58:17 PM1.1.1.1 - - [09/Apr/2019:09:58:17 +0000] <span class="hljs-string"><span class="hljs-string">"GET /sign-up HTTP/2.0"</span></span> 200 9168 <span class="hljs-string"><span class="hljs-string">"https://example.com/sign-in"</span></span> <span class="hljs-string"><span class="hljs-string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36"</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> 4/9/2019 12:58:17 PM1.1.1.1 - - [09/Apr/2019:09:58:17 +0000] <span class="hljs-string"><span class="hljs-string">"GET /sign-in HTTP/2.0"</span></span> 200 9168 <span class="hljs-string"><span class="hljs-string">"https://example.com/sign-up"</span></span> <span class="hljs-string"><span class="hljs-string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36"</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span></code> </pre> <br><p>  Mereka dapat diuraikan, tetapi jauh lebih mudah untuk memperbaiki konfigurasi Nginx sehingga menampilkan log di JSON: </p><br><pre> <code class="plaintext hljs">log_format json_combined escape=json '{ "created_at": "$msec", ' '"remote_addr": "$remote_addr", ' '"remote_user": "$remote_user", ' '"request": "$request", ' '"status": $status, ' '"bytes_sent": $bytes_sent, ' '"request_length": $request_length, ' '"request_time": $request_time, ' '"http_referrer": "$http_referer", ' '"http_x_forwarded_for": "$http_x_forwarded_for", ' '"http_user_agent": "$http_user_agent" }'; access_log /var/log/nginx/access.log json_combined;</code> </pre> <br><h3 id="s3-dlya-hraneniya">  S3 untuk penyimpanan </h3><br><p>  Untuk menyimpan log, kami akan menggunakan S3.  Ini memungkinkan Anda untuk menyimpan dan menganalisis log di satu tempat, karena Athena dapat bekerja dengan data dalam S3 secara langsung.  Nanti di artikel saya akan memberitahu Anda cara melipat dan memproses log dengan benar, tetapi pertama-tama kita perlu ember bersih dalam S3, di mana tidak ada lagi yang akan disimpan.  Sebaiknya pikirkan terlebih dahulu di wilayah mana Anda akan membuat ember, karena Athena tidak tersedia di semua wilayah. </p><br><h3 id="sozdaem-shemu-v-konsoli-athena">  Buat diagram di konsol Athena </h3><br><p>  Buat tabel di Athena untuk log.  Ini diperlukan untuk menulis dan membaca, jika Anda berencana menggunakan Kinesis Firehose.  Buka konsol Athena dan buat tabel: </p><br><div class="spoiler">  <b class="spoiler_title">Pembuatan tabel SQL</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`kinesis_logs_nginx`</span></span>( <span class="hljs-string"><span class="hljs-string">`created_at`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-string"><span class="hljs-string">`remote_addr`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-string"><span class="hljs-string">`remote_user`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-string"><span class="hljs-string">`request`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-string"><span class="hljs-string">`status`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, <span class="hljs-string"><span class="hljs-string">`bytes_sent`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, <span class="hljs-string"><span class="hljs-string">`request_length`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, <span class="hljs-string"><span class="hljs-string">`request_time`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-string"><span class="hljs-string">`http_referrer`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-string"><span class="hljs-string">`http_x_forwarded_for`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-string"><span class="hljs-string">`http_user_agent`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ROW</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FORMAT</span></span> SERDE <span class="hljs-string"><span class="hljs-string">'org.apache.hadoop.hive.ql.io.orc.OrcSerde'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> INPUTFORMAT <span class="hljs-string"><span class="hljs-string">'org.apache.hadoop.hive.ql.io.orc.OrcInputFormat'</span></span> OUTPUTFORMAT <span class="hljs-string"><span class="hljs-string">'org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat'</span></span> LOCATION <span class="hljs-string"><span class="hljs-string">'s3://&lt;YOUR-S3-BUCKET&gt;'</span></span> TBLPROPERTIES (<span class="hljs-string"><span class="hljs-string">'has_encrypted_data'</span></span>=<span class="hljs-string"><span class="hljs-string">'false'</span></span>);</code> </pre> </div></div><br><h3 id="sozdaem-kinesis-firehose-stream">  Buat Kinesis Firehose Stream </h3><br><p>  Kinesis Firehose akan menulis data yang diterima dari Nginx ke S3 dalam format yang dipilih, dibagi menjadi direktori dalam format YYYY / MM / DD / HH.  Ini berguna saat membaca data.  Anda tentu saja dapat menulis langsung ke S3 dari fluentd, tetapi dalam hal ini Anda harus menulis JSON, yang tidak efisien karena ukuran file yang besar.  Selain itu, saat menggunakan PrestoDB atau Athena, JSON adalah format data paling lambat.  Jadi buka konsol Firehose Kinesis, klik "Buat aliran pengiriman", pilih "PUT langsung" di bidang "pengiriman": </p><br><p><img src="https://habrastorage.org/webt/xe/vb/mc/xevbmcpntl3aqkgg50lh844gxe4.png" alt="Kinesis Firehose Console 1"></p><br><p>  Pada tab berikutnya, pilih "Rekam konversi format" - "Diaktifkan" dan pilih "Apache ORC" sebagai format untuk perekaman.  Menurut beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Owen O'Malley</a> , ini adalah format optimal untuk PrestoDB dan Athena.  Sebagai diagram, kami menunjukkan tabel yang kami buat di atas.  Harap dicatat bahwa Anda dapat menentukan lokasi S3 di kinesis, hanya skema yang digunakan dari tabel.  Tetapi jika Anda menentukan lokasi S3 lain, maka membaca catatan ini dari tabel ini tidak akan berfungsi. </p><br><p><img src="https://habrastorage.org/webt/vu/y1/ro/vuy1royrwm3pb3jle5nvclzskd0.png" alt="Kinesis firehose console 2"></p><br><p>  Kami memilih S3 untuk penyimpanan dan ember yang kami buat sebelumnya.  Aws Glue Crawler, yang akan saya bicarakan nanti, tidak tahu cara bekerja dengan awalan di bucket S3, jadi penting untuk membiarkannya kosong. </p><br><p><img src="https://habrastorage.org/webt/jq/0u/bs/jq0ubs7jvqmehbfqaaycrmxryso.png" alt="Kinesis firehose console 3"></p><br><p>  Opsi yang tersisa dapat diubah tergantung pada beban Anda, saya biasanya menggunakan yang standar.  Perhatikan bahwa kompresi S3 tidak tersedia, tetapi ORC menggunakan kompresi asli secara default. </p><br><h3 id="fluentd">  Fluentd </h3><br><p>  Sekarang kami telah mengkonfigurasi penyimpanan dan penerimaan log, Anda perlu mengkonfigurasi pengiriman.  Kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fluentd</a> karena saya suka Ruby, tetapi Anda dapat menggunakan Logstash atau mengirim log ke kinesis secara langsung.  Anda dapat memulai server Fluentd dengan beberapa cara, saya akan berbicara tentang buruh pelabuhan, karena sederhana dan nyaman. </p><br><p>  Pertama, kita memerlukan file konfigurasi fluent.conf.  Buat dan tambahkan sumber: </p><br><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">ketik</a> maju <br>  port 24224 <br>  ikat 0.0.0.0 </p><br><br><p>  Sekarang Anda dapat memulai server Fluentd.  Jika Anda memerlukan konfigurasi lebih lanjut, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker Hub</a> memiliki panduan terperinci, termasuk cara merakit gambar Anda. </p><br><pre> <code class="bash hljs">$ docker run \ -d \ -p 24224:24224 \ -p 24224:24224/udp \ -v /data:/fluentd/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> \ -v &lt;PATH-TO-FLUENT-CONF&gt;:/fluentd/etc fluentd \ -c /fluentd/etc/fluent.conf fluent/fluentd:stable</code> </pre> <br><p>  Konfigurasi ini menggunakan jalur <code>/fluentd/log</code> ke cache log sebelum mengirim.  Anda dapat melakukannya tanpa ini, tetapi kemudian ketika Anda me-restart, Anda bisa kehilangan semua yang di-cache oleh kerja yang berlebihan.  Port apa pun juga dapat digunakan, 24224 adalah port Fluentd default. </p><br><p>  Sekarang kami telah menjalankan Fluentd, kami dapat mengirim log Nginx di sana.  Kami biasanya menjalankan Nginx dalam wadah Docker, dalam hal ini Docker memiliki driver log asli untuk Fluentd: </p><br><pre> <code class="bash hljs">$ docker run \ --<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>-driver=fluentd \ --<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>-opt fluentd-address=&lt;FLUENTD-SERVER-ADDRESS&gt;\ --<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>-opt tag=\<span class="hljs-string"><span class="hljs-string">"{{.Name}}\" \ -v /some/content:/usr/share/nginx/html:ro \ -d \ nginx</span></span></code> </pre> <br><p>  Jika Anda menjalankan Nginx secara berbeda, Anda dapat menggunakan file log, Fluentd memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin file tail</a> . </p><br><p>  Tambahkan parsing log yang dikonfigurasi di atas ke konfigurasi Fasih: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">YOUR-NGINX-TAG.</span></span></span><span class="hljs-tag">*&gt;</span></span> @type parser key_name log emit_invalid_record_to_error false <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parse</span></span></span><span class="hljs-tag">&gt;</span></span> @type json <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parse</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Dan mengirim log ke Kinesis menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin firehose kinesis</a> : </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">match</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">YOUR-NGINX-TAG.</span></span></span><span class="hljs-tag">*&gt;</span></span> @type kinesis_firehose region region delivery_stream_name <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">YOUR-KINESIS-STREAM-NAME</span></span></span><span class="hljs-tag">&gt;</span></span> aws_key_id <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">YOUR-AWS-KEY-ID</span></span></span><span class="hljs-tag">&gt;</span></span> aws_sec_key <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">YOUR_AWS-SEC_KEY</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">match</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2 id="athena">  Athena </h2><br><p>  Jika Anda mengonfigurasi semuanya dengan benar, maka setelah beberapa saat (secara default, Kinesis menulis data yang diterima setiap 10 menit) Anda akan melihat file log dalam S3.  Di menu "monitoring" Kinesis Firehose, Anda dapat melihat berapa banyak data yang ditulis ke S3, serta kesalahan.  Jangan lupa untuk memberikan akses tulis ke Bucket S3 untuk peran Kinesis.  Jika Kinesis tidak dapat menguraikan sesuatu, ia akan menambahkan kesalahan dalam keranjang yang sama. </p><br><p>  Sekarang Anda dapat melihat data di Athena.  Mari temukan beberapa pertanyaan baru yang kami berikan kesalahan: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">"db_name"</span></span>.<span class="hljs-string"><span class="hljs-string">"table_name"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">status</span></span> &gt; <span class="hljs-number"><span class="hljs-number">499</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> created_at <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><h3 id="skanirovanie-vseh-zapisey-na-kazhdyy-zapros">  Pindai semua catatan untuk setiap permintaan </h3><br><p>  Sekarang log kami diproses dan ditumpuk dalam S3 dalam ORC, dikompresi dan siap untuk dianalisis.  Kinesis Firehose bahkan menempatkannya di direktori setiap jam.  Namun, sementara tabel tidak dipartisi, Athena akan memuat data sepanjang waktu untuk setiap kueri, dengan pengecualian langka.  Ini adalah masalah besar karena dua alasan: </p><br><ul><li>  Jumlah data terus bertambah, memperlambat permintaan; </li><li>  Athena ditagih berdasarkan jumlah data yang dipindai, dengan minimum 10 MB untuk setiap permintaan. </li></ul><br><p>  Untuk memperbaikinya, kami menggunakan AWS Glue Crawler, yang akan memindai data dalam S3 dan merekam informasi partisi di Glue Metastore.  Ini akan memungkinkan kami untuk menggunakan partisi sebagai filter untuk permintaan di Athena, dan itu hanya akan memindai direktori yang ditentukan dalam permintaan. </p><br><h3 id="nastraivaem-amazon-glue-crawler">  Kustomisasi Amazon Glue Crawler </h3><br><p>  Amazon Glue Crawler memindai semua data dalam bucket S3 dan membuat tabel partisi.  Buat Glue Crawler dari konsol AWS Glue dan tambahkan bucket tempat Anda menyimpan data.  Anda dapat menggunakan satu perayap untuk beberapa kotak, dalam hal ini ini akan membuat tabel dalam database yang ditentukan dengan nama yang cocok dengan nama kotak.  Jika Anda berencana untuk menggunakan data ini sepanjang waktu, pastikan untuk menyesuaikan jadwal peluncuran Crawler sesuai dengan kebutuhan Anda.  Kami menggunakan satu Crawler untuk semua tabel, yang berjalan setiap jam. </p><br><h3 id="particirovannye-tablicy">  Tabel dipartisi </h3><br><p>  Setelah mulai pertama perayap, tabel untuk setiap ember yang dipindai harus muncul dalam database yang ditentukan dalam pengaturan.  Buka konsol Athena dan temukan tabel dengan log Nginx.  Mari kita coba membaca sesuatu: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">"default"</span></span>.<span class="hljs-string"><span class="hljs-string">"part_demo_kinesis_bucket"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span>( partition_0 = <span class="hljs-string"><span class="hljs-string">'2019'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> partition_1 = <span class="hljs-string"><span class="hljs-string">'04'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> partition_2 = <span class="hljs-string"><span class="hljs-string">'08'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> partition_3 = <span class="hljs-string"><span class="hljs-string">'06'</span></span> );</code> </pre> <br><p>  Kueri ini akan memilih semua catatan yang diterima dari 6 pagi hingga 7 pagi pada 8 April 2019.  Tetapi seberapa jauh lebih efektif daripada hanya membaca dari tabel yang tidak dipartisi?  Mari cari tahu dan pilih catatan yang sama dengan memfilternya dengan stempel waktu: </p><br><p><img src="https://habrastorage.org/webt/mu/bg/me/mubgmef262bxyte5dsqsa1q_hag.png" alt="Permintaan tanpa partisi"></p><br><p>  3,59 detik dan 244,34 megabita data pada dataset, di mana hanya ada satu minggu log.  Mari kita coba filter berdasarkan partisi: </p><br><p><img src="https://habrastorage.org/webt/9-/n4/dc/9-n4dczjdvcrspm0zbypq-ul5cs.png" alt="Permintaan Filter Partisi"></p><br><p>  Sedikit lebih cepat, tetapi yang paling penting - hanya 1,23 megabita data!  Akan jauh lebih murah jika bukan untuk harga minimum 10 megabyte per permintaan.  Namun itu jauh lebih baik, dan pada dataset besar perbedaannya akan jauh lebih mengesankan. </p><br><h2 id="sobiraem-deshbord-s-pomoschyu-cubejs">  Buat dasbor menggunakan Cube.js </h2><br><p>  Untuk membangun dasbor, kami menggunakan kerangka analitik Cube.js.  Ini memiliki beberapa fungsi, tetapi kami tertarik pada dua: kemampuan untuk secara otomatis menggunakan filter pada partisi dan pra-agregasi data.  Ini menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skema data yang</a> ditulis dalam Javascript untuk menghasilkan SQL dan mengeksekusi query database.  Semua yang diperlukan dari kami adalah untuk menunjukkan cara menggunakan filter partisi dalam skema data. </p><br><p>  Ayo buat aplikasi baru Cube.js.  Karena kita sudah menggunakan AWS-stack, logis untuk menggunakan Lambda untuk penyebaran.  Anda bisa menggunakan templat ekspres untuk pembuatan jika Anda berencana untuk meng-host backend Cube.js di Heroku atau Docker.  Dokumentasi menjelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode hosting</a> lainnya. </p><br><pre> <code class="bash hljs">$ npm install -g cubejs-cli $ cubejs create nginx-log-analytics -t serverless -d athena</code> </pre> <br><p>  Variabel lingkungan digunakan untuk mengonfigurasi akses ke database di cube.js.  Generator akan membuat file .env di mana Anda dapat menentukan kunci untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Athena</a> . </p><br><p>  Sekarang kita membutuhkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skema data</a> di mana kita menunjukkan bagaimana log kita disimpan.  Di sana Anda dapat menentukan cara membaca metrik untuk dasbor. </p><br><p>  Di direktori <code>schema</code> , buat file <code>Logs.js</code>  Berikut adalah contoh model data untuk nginx: </p><br><div class="spoiler">  <b class="spoiler_title">Kode model</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> partitionFilter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">` date(from_iso8601_timestamp(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">)) &lt;= date_parse(partition_0 || partition_1 || partition_2, '%Y%m%d') AND date(from_iso8601_timestamp(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${to}</span></span></span><span class="hljs-string">)) &gt;= date_parse(partition_0 || partition_1 || partition_2, '%Y%m%d') `</span></span> cube(<span class="hljs-string"><span class="hljs-string">`Logs`</span></span>, { <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: <span class="hljs-string"><span class="hljs-string">` select * from part_demo_kinesis_bucket WHERE </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${FILTER_PARAMS.Logs.createdAt.filter(partitionFilter)}</span></span></span><span class="hljs-string"> `</span></span>, <span class="hljs-attr"><span class="hljs-attr">measures</span></span>: { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`count`</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">errorCount</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`count`</span></span>, <span class="hljs-attr"><span class="hljs-attr">filters</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${CUBE.isError}</span></span></span><span class="hljs-string"> = 'Yes'`</span></span> } ] }, <span class="hljs-attr"><span class="hljs-attr">errorRate</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`number`</span></span>, <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: <span class="hljs-string"><span class="hljs-string">`100.0 * </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${errorCount}</span></span></span><span class="hljs-string"> / </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${count}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">format</span></span>: <span class="hljs-string"><span class="hljs-string">`percent`</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">dimensions</span></span>: { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: { <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: <span class="hljs-string"><span class="hljs-string">`status`</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`number`</span></span> }, <span class="hljs-attr"><span class="hljs-attr">isError</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`string`</span></span>, <span class="hljs-attr"><span class="hljs-attr">case</span></span>: { <span class="hljs-attr"><span class="hljs-attr">when</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${CUBE}</span></span></span><span class="hljs-string">.status &gt;= 400`</span></span>, <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">`Yes`</span></span> }], <span class="hljs-attr"><span class="hljs-attr">else</span></span>: { <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">`No`</span></span> } } }, <span class="hljs-attr"><span class="hljs-attr">createdAt</span></span>: { <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: <span class="hljs-string"><span class="hljs-string">`from_unixtime(created_at)`</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`time`</span></span> } } });</code> </pre> </div></div><br><p>  Di sini kita menggunakan variabel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FILTER_PARAMS</a> untuk menghasilkan kueri SQL dengan filter partisi. </p><br><p>  Kami juga menentukan metrik dan parameter yang ingin kami tampilkan di dasbor, dan menentukan pra-agregasi.  Cube.js akan membuat tabel tambahan dengan data pra-agregat dan secara otomatis memperbarui data begitu tersedia.  Ini tidak hanya mempercepat permintaan, tetapi juga mengurangi biaya menggunakan Athena. </p><br><p>  Tambahkan informasi ini ke file skema data: </p><br><pre> <code class="javascript hljs">preAggregations: { <span class="hljs-attr"><span class="hljs-attr">main</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`rollup`</span></span>, <span class="hljs-attr"><span class="hljs-attr">measureReferences</span></span>: [count, errorCount], <span class="hljs-attr"><span class="hljs-attr">dimensionReferences</span></span>: [isError, status], <span class="hljs-attr"><span class="hljs-attr">timeDimensionReference</span></span>: createdAt, <span class="hljs-attr"><span class="hljs-attr">granularity</span></span>: <span class="hljs-string"><span class="hljs-string">`day`</span></span>, <span class="hljs-attr"><span class="hljs-attr">partitionGranularity</span></span>: <span class="hljs-string"><span class="hljs-string">`month`</span></span>, <span class="hljs-attr"><span class="hljs-attr">refreshKey</span></span>: { <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: FILTER_PARAMS.Logs.createdAt.filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`select CASE WHEN from_iso8601_timestamp(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${to}</span></span></span><span class="hljs-string">) + interval '3' day &gt; now() THEN date_trunc('hour', now()) END`</span></span> ) } } }</code> </pre> <br><p>  Dalam model ini, kami menunjukkan bahwa perlu untuk melakukan agregat data untuk semua metrik yang digunakan, dan untuk menggunakan partisi bulanan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mempartisi pra-agregasi</a> dapat secara signifikan mempercepat pengumpulan dan pembaruan data. </p><br><p>  Sekarang kita bisa membuat dashboard! </p><br><p>  Backend Cube.js menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">REST API</a> dan satu set perpustakaan klien untuk kerangka kerja front-end yang populer.  Kami akan menggunakan versi Bereaksi klien untuk membangun dasbor.  Cube.js hanya menyediakan data, jadi kami membutuhkan pustaka untuk visualisasi - Saya suka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">restart</a> , tetapi Anda bisa menggunakan apa saja. </p><br><p>  Server Cube.js menerima permintaan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">format JSON</a> , yang menunjukkan metrik yang diperlukan.  Misalnya, untuk menghitung berapa banyak kesalahan yang diberikan Nginx per hari, Anda perlu mengirim permintaan berikut: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"measures"</span></span>: [<span class="hljs-string"><span class="hljs-string">"Logs.errorCount"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"timeDimensions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"dimension"</span></span>: <span class="hljs-string"><span class="hljs-string">"Logs.createdAt"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dateRange"</span></span>: [<span class="hljs-string"><span class="hljs-string">"2019-01-01"</span></span>, <span class="hljs-string"><span class="hljs-string">"2019-01-07"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"granularity"</span></span>: <span class="hljs-string"><span class="hljs-string">"day"</span></span> } ] }</code> </pre> <br><p>  Instal klien Cube.js dan React library komponen melalui NPM: </p><br><pre> <code class="bash hljs">$ npm i --save @cubejs-client/core @cubejs-client/react</code> </pre> <br><p>  Kami mengimpor komponen cubejs dan QueryRenderer untuk membongkar data, dan mengumpulkan dasbor: </p><br><div class="spoiler">  <b class="spoiler_title">Kode dasbor</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LineChart, Line, XAxis, YAxis } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'recharts'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cubejs <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@cubejs-client/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { QueryRenderer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@cubejs-client/react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cubejsApi = cubejs( <span class="hljs-string"><span class="hljs-string">'YOUR-CUBEJS-API-TOKEN'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">apiUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'http://localhost:4000/cubejs-api/v1'</span></span> }, ); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;QueryRenderer query={{ measures: [</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'Logs.errorCount'</span></span></span></span><span class="hljs-function"><span class="hljs-params">], timeDimensions: [{ dimension: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'Logs.createdAt'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, dateRange: [</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'2019-01-01'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'2019-01-07'</span></span></span></span><span class="hljs-function"><span class="hljs-params">], granularity: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'day'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }] }} cubejsApi={cubejsApi} render={({ resultSet }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!resultSet) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Loading...'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;LineChart data={resultSet.rawData()}&gt; &lt;XAxis dataKey="Logs.createdAt"/&gt; &lt;YAxis/&gt; &lt;Line type="monotone" dataKey="Logs.errorCount" stroke="#8884d8"/&gt; &lt;/LineChart&gt; ); }} /&gt; ) }</code> </pre> </div></div><br><p>  Sumber dasbor tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CodeSandbox</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447886/">https://habr.com/ru/post/id447886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447876/index.html">Semuanya sangat buruk atau tipe baru intersepsi lalu lintas</a></li>
<li><a href="../id447878/index.html">Memeriksa rdesktop dan xrdp dengan PVS-Studio</a></li>
<li><a href="../id447880/index.html">Memvalidasi rdesktop dan xrdp menggunakan analisa PVS-Studio</a></li>
<li><a href="../id447882/index.html">Alat jaringan, atau di mana memulai pentester?</a></li>
<li><a href="../id447884/index.html">Kami mencari tahu bagaimana 5G akan bekerja dalam kisaran milimeter di jalan dan di dalam ruangan</a></li>
<li><a href="../id447890/index.html">Terima kasih Tuhan aku bukan manajer</a></li>
<li><a href="../id447892/index.html">Dua kontes PHDays baru: bypass IDS dan peretasan pabrik</a></li>
<li><a href="../id447894/index.html">MODX Digest # 3 (25 Maret - 8 April 2019)</a></li>
<li><a href="../id447896/index.html">Gambar dari sketsa kasar: bagaimana tepatnya jaringan saraf NVIDIA GauGAN bekerja</a></li>
<li><a href="../id447898/index.html">Filsuf cukup makan atau pemrograman .NET kompetitif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>