<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïπÔ∏è üôáüèº ü§æüèø Cron unter Linux: Verlauf, Verwendung und Ger√§t üíå üè£ üíü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Klassiker schrieb, dass Happy Hours nicht eingehalten werden. In diesen wilden Zeiten gab es weder Programmierer noch Unix, aber heutzutage wissen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cron unter Linux: Verlauf, Verwendung und Ger√§t</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468061/"><img src="https://habrastorage.org/webt/tm/ya/6j/tmya6jd_1sbhnfncczo1nf2g7_y.jpeg"><br><p>  Der Klassiker schrieb, dass Happy Hours nicht eingehalten werden.  In diesen wilden Zeiten gab es weder Programmierer noch Unix, aber heutzutage wissen Programmierer sehr gut: Anstelle von ihnen wird cron der Zeit folgen. </p><br><p>  Befehlszeilenprogramme sind f√ºr mich sowohl Schw√§che als auch Routine.  sed, awk, wc, cut und andere alte Programme werden t√§glich von Skripten auf unseren Servern ausgef√ºhrt.  Viele von ihnen sind als Aufgaben f√ºr cron konzipiert, einen Planer aus den 70er Jahren. </p><br><p>  Lange Zeit habe ich cron oberfl√§chlich verwendet, ohne auf Details einzugehen, aber nachdem ich einmal einen Fehler beim Ausf√ºhren des Skripts festgestellt hatte, beschloss ich, es gr√ºndlich herauszufinden.  So erschien dieser Artikel beim Schreiben, in dem ich POSIX crontab kennenlernte, die wichtigsten Cron-Varianten in popul√§ren Linux-Distributionen und das Ger√§t einiger von ihnen. </p><br><p>  Verwenden Sie Linux und f√ºhren Sie Aufgaben in cron aus?  Interessiert an der Unix-Systemanwendungsarchitektur?  Dann sind wir unterwegs! </p><a name="habracut"></a><br><h1 id="soderzhanie">  Inhalt </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Herkunft der Arten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Posix crontab</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bestseller - Vixie cron 3.0pl1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cron auf Debian und Ubuntu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cronie auf Red Hat, Fedora und CentOS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cronie in SLES und openSUSE</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vixie Cron Ger√§t</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachwort</a> </li></ul><br><h1 id="proishozhdenie-vidov">  Herkunft der Arten </h1><br><p>  Die regelm√§√üige Ausf√ºhrung von Benutzer- oder Systemprogrammen ist ein offensichtlicher Bedarf f√ºr alle Betriebssysteme.  Der Bedarf an Diensten, die eine zentralisierte Planung und Ausf√ºhrung von Aufgaben erm√∂glichen, haben Programmierer daher schon sehr lange erkannt. </p><br><p> Unix-√§hnliche Betriebssysteme haben ihren Stammbaum von Version 7 Unix, das in den 1970er Jahren von Bell Labs entwickelt wurde, einschlie√ülich des ber√ºhmten Ken Thompson.  Zusammen mit Version 7 Unix wurde auch cron bereitgestellt, ein Dienst zur regelm√§√üigen Ausf√ºhrung von Superuser-Aufgaben. </p><br><p>  Ein typisches modernes Cron ist ein einfaches Programm, aber der Algorithmus der Originalversion war noch einfacher: Der Dienst wurde einmal pro Minute aktiviert, las das Task-Plate aus einer einzelnen Datei (/ etc / lib / crontab) und f√ºhrte f√ºr den Superuser die Aufgaben aus, die in der aktuellen Minute ausgef√ºhrt werden sollten . </p><br><p>  Anschlie√üend wurden mit allen Unix-√§hnlichen Betriebssystemen erweiterte Optionen f√ºr einen einfachen und n√ºtzlichen Dienst bereitgestellt. </p><br><p>  Verallgemeinerte Beschreibungen des Crontab-Formats und der Grundprinzipien des Dienstprogramms im Jahr 1992 wurden in den Hauptstandard f√ºr Unix-√§hnliche Betriebssysteme - POSIX - aufgenommen, und somit wurde Cron aus dem De-facto-Standard zum De-jure-Standard. </p><br><p>  Im Jahr 1987 ver√∂ffentlichte Paul Vixie nach Befragung von Unix-Benutzern nach Vorschl√§gen f√ºr Cron eine weitere Version des Daemons, die einige der Probleme des herk√∂mmlichen Cron behebt und die Syntax von Tabellendateien erweitert. </p><br><p>  Mit der dritten Version begann Vixie cron, die Anforderungen von POSIX zu erf√ºllen. Au√üerdem verf√ºgte das Programm √ºber eine liberale Lizenz, oder es gab √ºberhaupt keine Lizenz, au√üer f√ºr die W√ºnsche in README: Der Autor gibt keine Garantien, Sie k√∂nnen den Namen des Autors nicht l√∂schen und Sie k√∂nnen das Programm nur mit verkaufen Quellcode.  Diese Anforderungen erwiesen sich als kompatibel mit den Prinzipien der freien Software, die in jenen Jahren immer beliebter wurden. Einige der wichtigsten Linux-Distributionen, die Anfang der 90er Jahre erschienen, nahmen Vixie cron als System und entwickeln es noch weiter. </p><br><p>  Insbesondere entwickeln Red Hat und SUSE die Vixie-Cron-Crony-Gabel, w√§hrend Debian und Ubuntu das urspr√ºngliche Vixie-Cron mit vielen Patches verwenden. </p><br><p>  Machen wir uns zun√§chst mit dem in POSIX beschriebenen benutzerdefinierten Dienstprogramm crontab vertraut. Anschlie√üend analysieren wir die in Vixie cron vorgestellten Syntaxerweiterungen und die Verwendung von Vixie cron-Variationen in g√§ngigen Linux-Distributionen.  Und schlie√ülich ist die Kirsche auf dem Kuchen eine Analyse des Cron Daemon-Ger√§ts. </p><br><h1 id="posix-crontab">  Posix crontab </h1><br><p>  Wenn der urspr√ºngliche Cron immer f√ºr den Superuser funktioniert hat, erledigen moderne Scheduler h√§ufig die Aufgaben normaler Benutzer, was sicherer und bequemer ist. </p><br><p>  Cron s werden mit zwei Programmen ausgeliefert: dem st√§ndig laufenden Cron-Daemon und dem Crontab-Dienstprogramm, das den Benutzern zur Verf√ºgung steht.  Mit letzterem k√∂nnen Sie aufgabentabellen bearbeiten, die f√ºr jeden Benutzer im System spezifisch sind, w√§hrend der D√§mon Aufgaben aus Benutzer- und Systemtabellen startet. </p><br><p>  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POSIX-Standard</a> beschreibt das Verhalten des D√§mons nicht und nur das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Crontab-</a> Benutzerprogramm wird formalisiert.  Das Vorhandensein von Mechanismen zum Starten von Benutzeraufgaben ist nat√ºrlich impliziert, wird jedoch nicht im Detail beschrieben. </p><br><p>  Mit dem Dienstprogramm crontab k√∂nnen Sie vier Dinge tun: Bearbeiten Sie die Benutzeraufgabentabelle im Editor, laden Sie die Tabelle aus der Datei, zeigen Sie die aktuelle Aufgabentabelle an und l√∂schen Sie die Aufgabentabelle.  Beispiele f√ºr das Dienstprogramm crontab: </p><br><pre><code class="plaintext hljs">crontab -e #    crontab -l #    crontab -r #    crontab path/to/file.crontab #     </code> </pre> <br><p>  Beim Aufruf von <code>crontab -e</code> wird der in der Standard-Umgebungsvariablen <code>EDITOR</code> angegebene Editor verwendet. </p><br><p>  Die Aufgaben selbst werden im folgenden Format beschrieben: </p><br><pre> <code class="plaintext hljs"># -  # # ,   * * * * * /path/to/exec -a -b -c # ,   10-    10 * * * * /path/to/exec -a -b -c # ,   10-            10 2 * * * /path/to/exec -a -b -c &gt; /tmp/cron-job-output.log</code> </pre> <br><p>  Die ersten f√ºnf Datensatzfelder: Minuten [1..60], Stunden [0..23], Tage des Monats [1..31], Monate [1..12], Wochentage [0..6], wobei 0 - Sonntag.  Das letzte, sechste Feld ist eine Zeichenfolge, die vom Standardbefehlsinterpreter ausgef√ºhrt wird. </p><br><p>  In den ersten f√ºnf Feldern k√∂nnen die Werte mit einem Komma aufgelistet werden: </p><br><pre> <code class="plaintext hljs"># ,         1,10 * * * * /path/to/exec -a -b -c</code> </pre> <br><p>  Oder durch einen Bindestrich: </p><br><pre> <code class="plaintext hljs"># ,          0-9 * * * * /path/to/exec -a -b -c</code> </pre> <br><p>  Der Benutzerzugriff auf die Aufgabenplanung wird in den POSIX-Dateien cron.allow und cron.deny geregelt, in denen jeweils Benutzer mit Zugriff auf crontab und Benutzer ohne Zugriff auf das Programm aufgelistet sind.  Der Standard regelt nicht den Speicherort dieser Dateien. </p><br><p>  Laufende Programme m√ºssen gem√§√ü dem Standard mindestens vier Umgebungsvariablen √ºbergeben werden: </p><br><ol><li>  HOME ist das Home-Verzeichnis des Benutzers. </li><li>  LOGNAME - Benutzeranmeldung. </li><li>  PATH ist der Pfad, √ºber den die Standardsystemdienstprogramme gefunden werden. </li><li>  SHELL ist der Pfad zur verwendeten Shell. </li></ol><br><p>  Es ist bemerkenswert, dass POSIX nichts dar√ºber aussagt, woher die Werte f√ºr diese Variablen stammen. </p><br><h1 id="hit-prodazh--vixie-cron-30pl1">  Bestseller - Vixie cron 3.0pl1 </h1><br><p>  Der gemeinsame Vorfahr der beliebten Cron-Varianten ist Vixie Cron 3.0pl1, das auf der Mailingliste comp.sources.unix von 1992 aufgef√ºhrt ist.  Die Hauptmerkmale dieser Version werden wir genauer betrachten. </p><br><p>  Vixie Cron gibt es in zwei Programmen (Cron und Crontab).  Wie √ºblich ist der D√§mon f√ºr das Lesen und Starten von Aufgaben aus der Systemaufgabentabelle und den Aufgabentabellen einzelner Benutzer verantwortlich, und das Dienstprogramm crontab ist f√ºr das Bearbeiten von Benutzertabellen verantwortlich. </p><br><h3 id="tablica-zadach-i-fayly-konfiguracii">  Aufgabentabelle und Konfigurationsdateien </h3><br><p>  Die Superuser-Aufgabentabelle befindet sich in / etc / crontab.  Die Syntax der Systemtabelle entspricht der Syntax von Vixie cron, angepasst an die Tatsache, dass in der sechsten Spalte der Name des Benutzers angegeben ist, in dessen Auftrag die Aufgabe gestartet wird: </p><br><pre> <code class="plaintext hljs">#     vlad * * * * * vlad /path/to/exec</code> </pre> <br><p>  Allgemeine Benutzeraufgabentabellen befinden sich in / var / cron / tabs / username und verwenden die allgemeine Syntax.  Wenn das Dienstprogramm crontab gestartet wird, werden diese Dateien im Auftrag des Benutzers bearbeitet. </p><br><p>  Die Benutzerlisten mit Zugriff auf crontab werden in den Dateien / var / cron / allow und / var / cron / verweigern verwaltet, wobei es ausreicht, den Benutzernamen als separate Zeile hinzuzuf√ºgen. </p><br><h3 id="rasshirennyy-sintaksis">  Erweiterte Syntax </h3><br><p>  Im Vergleich zu POSIX crontab enth√§lt die L√∂sung von Paul Vixie einige sehr n√ºtzliche √Ñnderungen an der Syntax der Utility-Task-Tabelle. </p><br><p>  Eine neue Tabellensyntax ist verf√ºgbar geworden: Sie k√∂nnen beispielsweise Wochentage oder Monate nach Namen angeben (Mo, Di usw.): </p><br><pre> <code class="plaintext hljs">#         * * * Jan Mon,Tue /path/to/exec</code> </pre> <br><p>  Sie k√∂nnen den Schritt angeben, durch den Aufgaben gestartet werden: </p><br><pre> <code class="plaintext hljs">#       */2 * * * Mon,Tue /path/to/exec</code> </pre> <br><p>  Schritte und Intervalle k√∂nnen gemischt werden: </p><br><pre> <code class="plaintext hljs">#             0-10/2 * * * * /path/to/exec</code> </pre> <br><p>  Es werden intuitive Alternativen zur regul√§ren Syntax unterst√ºtzt (Neustart, j√§hrlich, j√§hrlich, monatlich, w√∂chentlich, t√§glich, Mitternacht, st√ºndlich): </p><br><pre> <code class="plaintext hljs">#     @reboot /exec/on/reboot #     @daily /exec/daily #     @hourly /exec/daily</code> </pre> <br><h3 id="sreda-vypolneniya-zadach">  Task-Ausf√ºhrungsumgebung </h3><br><p>  Mit Vixie cron k√∂nnen Sie die Umgebung laufender Anwendungen √§ndern. </p><br><p>  Die Umgebungsvariablen USER, LOGNAME und HOME werden nicht nur vom Daemon bereitgestellt, sondern aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">passwd-Datei √ºbernommen</a> .  Die PATH-Variable erh√§lt den Wert "/ usr / bin: / bin" und SHELL den Wert "/ bin / sh".  Die Werte aller Variablen au√üer LOGNAME k√∂nnen in Benutzertabellen ge√§ndert werden. </p><br><p>  Einige Umgebungsvariablen (haupts√§chlich SHELL und HOME) werden von cron selbst verwendet, um die Aufgabe auszuf√ºhren.  So k√∂nnte es aussehen, wenn Sie bash anstelle des Standard-sh verwenden, um benutzerdefinierte Aufgaben auszuf√ºhren: </p><br><pre> <code class="plaintext hljs">SHELL=/bin/bash HOME=/tmp/ # exec   bash-  /tmp/ * * * * * /path/to/exec</code> </pre> <br><p>  Letztendlich werden alle in der Tabelle definierten Umgebungsvariablen (von cron verwendet oder f√ºr den Prozess erforderlich) an die laufende Task √ºbertragen. </p><br><p>  Das Dienstprogramm crontab verwendet den in der Umgebungsvariablen VISUAL oder EDITOR angegebenen Editor zum Bearbeiten von Dateien.  Wenn diese Variablen in der Umgebung, in der crontab gestartet wurde, nicht definiert sind, wird "/ usr / ucb / vi" verwendet (ucb ist wahrscheinlich die University of California, Berkeley). </p><br><h1 id="cron-v-debian-i-ubuntu">  Cron auf Debian und Ubuntu </h1><br><p>  Debian- und Derivate-Entwickler haben eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stark modifizierte</a> Version von Vixie Cron Version 3.0pl1 ver√∂ffentlicht.  Es gibt keine Unterschiede in der Syntax von Tabellendateien. F√ºr Benutzer ist dies das gleiche Vixie-Cron.  Gr√∂√üte neue Funktionen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Syslog-</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SELinux-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PAM-</a> Unterst√ºtzung. </p><br><p>  Von den weniger auff√§lligen, aber greifbaren √Ñnderungen - dem Speicherort der Konfigurationsdateien und Aufgabentabellen. </p><br><p>  Benutzertabellen in Debian befinden sich im Verzeichnis / var / spool / cron / crontabs, die Systemtabelle befindet sich noch in / etc / crontab.  Debian-spezifische Aufgabentabellen werden in /etc/cron.d abgelegt, von wo aus der Cron-Daemon sie automatisch liest.  Die Benutzerzugriffskontrolle wird durch die Dateien /etc/cron.allow und /etc/cron.deny geregelt. </p><br><p>  Die Standard-Shell / bin / sh wird weiterhin als Standard-Shell verwendet. Debian fungiert als kleine POSIX-kompatible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dash-</a> Shell, die ohne Lesen einer Konfiguration gestartet wird (im nicht interaktiven Modus). </p><br><p>  Cron selbst wird in den neuesten Versionen von Debian √ºber systemd gestartet, und die Startkonfiguration kann unter /lib/systemd/system/cron.service eingesehen werden.  Die Konfiguration des Dienstes enth√§lt nichts Besonderes. Eine feinere Aufgabenverwaltung kann √ºber Umgebungsvariablen erfolgen, die direkt in der Crontab jedes Benutzers deklariert sind. </p><br><h1 id="cronie-v-redhat-fedora-i-centos">  cronie auf RedHat, Fedora und CentOS </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cronie</a> - Gabel von Vixie cron Version 4.1.  Wie in Debian wurde die Syntax nicht ge√§ndert, aber die Unterst√ºtzung f√ºr PAM und SELinux, das Arbeiten in einem Cluster, das Verfolgen von Dateien mithilfe von inotify und andere Funktionen wurden hinzugef√ºgt. </p><br><p>  Die Standardkonfiguration befindet sich an den √ºblichen Stellen: Die Systemtabelle befindet sich in / etc / crontab, Pakete legen ihre Tabellen in /etc/cron.d ab, Benutzertabellen befinden sich in / var / spool / cron / crontabs. </p><br><p>  Der Daemon wird unter systemd ausgef√ºhrt. Die Dienstkonfiguration lautet /lib/systemd/system/crond.service. </p><br><p>  Beim Start verwenden Red Hat-√§hnliche Distributionen standardm√§√üig / bin / sh, deren Rolle Standard-Bash ist.  Es ist zu beachten, dass beim Ausf√ºhren von Cron-Tasks √ºber / bin / sh die Bash-Shell im POSIX-kompatiblen Modus startet und im nicht interaktiven Modus keine zus√§tzliche Konfiguration liest. </p><br><h1 id="cronie-v-sles-i-opensuse">  cronie in SLES und openSUSE </h1><br><p>  Die deutsche SLES-Distribution und ihr openSUSE-Derivat verwenden dieselbe Cronie.  Der Daemon wird hier auch unter systemd ausgef√ºhrt. Die Dienstkonfiguration befindet sich in /usr/lib/systemd/system/cron.service.  Konfiguration: / etc / crontab, /etc/cron.d, / var / spool / cron / tabs.  As / bin / sh verh√§lt sich wie die gleiche Bash, die im POSIX-kompatiblen nicht interaktiven Modus gestartet wird. </p><br><h1 id="ustroystvo-vixie-cron">  Vixie Cron Ger√§t </h1><br><p>  Moderne Nachkommen von Cron haben sich im Vergleich zu Vixie Cron nicht radikal ver√§ndert, aber dennoch neue F√§higkeiten erworben, die nicht erforderlich sind, um die Prinzipien des Programms zu verstehen.  Viele dieser Erweiterungen sind chaotisch und verwirren den Code.  Der urspr√ºngliche Cron-Quellcode von Paul Vixie ist eine Freude zu lesen. </p><br><p>  Aus diesem Grund habe ich mich entschlossen, das Cron-Ger√§t am Beispiel eines gemeinsamen Programms f√ºr beide Bereiche der Cron-Entwicklung zu analysieren - Vixie cron 3.0pl1.  Ich werde die Beispiele vereinfachen, indem ich ifdefs entferne, die das Lesen erschweren, und die sekund√§ren Details weglasse. </p><br><p>  Die Arbeit des D√§mons kann in mehrere Phasen unterteilt werden: </p><br><ol><li>  Initialisierung des Programms. </li><li>  Sammeln und aktualisieren Sie die Liste der auszuf√ºhrenden Aufgaben. </li><li>  Die Haupt-Cron-Loop-Operation. </li><li>  Aufgabenstart. </li></ol><br><p>  Sortieren wir sie der Reihe nach. </p><br><h3 id="inicializaciya">  Initialisierung </h3><br><p>  Beim Start installiert cron nach √úberpr√ºfung der Prozessargumente die Signalhandler SIGCHLD und SIGHUP.  Der erste protokolliert den Abschluss des untergeordneten Prozesses, der zweite schlie√üt den Dateideskriptor der Protokolldatei: </p><br><pre> <code class="cpp hljs">signal(SIGCHLD, sigchld_handler); signal(SIGHUP, sighup_handler);</code> </pre> <br><p>  Der Cron-Daemon im System arbeitet immer alleine, nur als Superuser und aus dem Cron-Hauptverzeichnis.  Die folgenden Aufrufe erstellen eine Dateisperre mit der PID des Daemon-Prozesses, stellen sicher, dass der Benutzer korrekt ist, und √§ndern das aktuelle Verzeichnis in das Hauptverzeichnis: </p><br><pre> <code class="cpp hljs">acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); set_cron_uid(); set_cron_cwd();</code> </pre> <br><p>  Der Standardpfad wird festgelegt, der beim Starten der Prozesse verwendet wird: </p><br><pre> <code class="cpp hljs">setenv(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, _PATH_DEFPATH, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Dann wird der Prozess ‚Äûd√§monisiert‚Äú: Er erstellt eine untergeordnete Kopie des Prozesses, indem er fork und eine neue Sitzung im untergeordneten Prozess aufruft (Aufruf von setsid).  Der √ºbergeordnete Prozess ist nicht mehr erforderlich - und der Auftrag wird abgeschlossen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> _exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><p>  Durch das Beenden des √ºbergeordneten Prozesses wird die Sperre f√ºr die Sperrdatei aufgehoben.  Au√üerdem m√ºssen Sie die PID in der Datei auf das untergeordnete Element aktualisieren.  Danach wird die Aufgabendatenbank gef√ºllt: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> database.head = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.tail = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.mtime = (<span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; load_database(&amp;database);</code> </pre> <br><p>  Weitere Cron fahren mit dem Hauptarbeitszyklus fort.  Schauen Sie sich vorher das Laden der Aufgabenliste an. </p><br><h3 id="sbor-i-obnovlenie-spiska-zadach">  Sammeln und Aktualisieren der Aufgabenliste </h3><br><p>  Die Funktion load_database ist f√ºr das Laden der Aufgabenliste verantwortlich.  Es √ºberpr√ºft die Crontab des Hauptsystems und das Verzeichnis mit Benutzerdateien.  Wenn sich die Dateien und das Verzeichnis nicht ge√§ndert haben, wird die Liste der Aufgaben nicht erneut gelesen.  Andernfalls beginnt sich eine neue Aufgabenliste zu bilden. </p><br><p>  Herunterladen einer Systemdatei mit speziellen Datei- und Tabellennamen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     ,  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (syscron_stat.st_mtime) { process_crontab(<span class="hljs-string"><span class="hljs-string">"root"</span></span>, <span class="hljs-string"><span class="hljs-string">"*system*"</span></span>, SYSCRONTAB, &amp;syscron_stat, &amp;new_db, old_db); }</code> </pre> <br><p>  Laden von Benutzertabellen in einer Schleife: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> != (dp = readdir(dir))) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>], tabname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dp-&gt;d_name[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(fname, dp-&gt;d_name); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(tabname, CRON_TAB(fname)); process_crontab(fname, fname, tabname, &amp;statbuf, &amp;new_db, old_db); }</code> </pre><br><p>  Dann wird die alte Datenbank durch eine neue ersetzt. </p><br><p>  In den obigen Beispielen stellt das Aufrufen der Funktion process_crontab sicher, dass der Benutzer vorhanden ist, der dem Tabellendateinamen entspricht (es sei denn, es handelt sich um den Superuser), und ruft dann load_user auf.  Letzterer liest die Datei selbst bereits Zeile f√ºr Zeile: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((status = load_env(envstr, file)) &gt;= OK) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ERR: free_user(u); u = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> done; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: e = load_entry(file, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, pw, envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e) { e-&gt;next = u-&gt;crontab; u-&gt;crontab = e; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: envp = env_set(envp, envstr); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><p>  Hier wird entweder die Umgebungsvariable (Zeilen der Form VAR = Wert) durch die Funktionen load_env / env_set festgelegt oder die Aufgabenbeschreibung (* * * * * / path / to / exec) wird von der Funktion load_entry gelesen. </p><br><p>  Die von load_entry zur√ºckgegebene Eintragsentit√§t ist unsere Aufgabe, die in der allgemeinen Liste der Aufgaben aufgef√ºhrt ist.  In der Funktion selbst wird eine lange Analyse des Zeitformats durchgef√ºhrt, aber wir sind mehr an der Bildung von Umgebungsvariablen und Startparametern f√ºr Aufgaben interessiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*         passwd*/</span></span> e-&gt;uid = pw-&gt;pw_uid; e-&gt;gid = pw-&gt;pw_gid; <span class="hljs-comment"><span class="hljs-comment">/*    (/bin/sh),      */</span></span> e-&gt;envp = env_copy(envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"SHELL=%s"</span></span>, _PATH_BSHELL); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"HOME=%s"</span></span>, pw-&gt;pw_dir); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"PATH=%s"</span></span>, _PATH_DEFPATH); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     passwd */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"%s=%s"</span></span>, <span class="hljs-string"><span class="hljs-string">"LOGNAME"</span></span>, pw-&gt;pw_name); e-&gt;envp = env_set(e-&gt;envp, envstr);</code> </pre> <br><p>  Der Hauptzyklus arbeitet auch mit der aktuellen Liste der Aufgaben. </p><br><h3 id="glavnyy-cikl">  Hauptzyklus </h3><br><p>  Das urspr√ºngliche Cron aus Version 7 Unix funktionierte ganz einfach: In einem Zyklus las ich die Konfiguration erneut, f√ºhrte die Aufgaben der aktuellen Minute als Superuser aus und schlief bis zum Beginn der n√§chsten Minute.  Dieser einfache Ansatz auf √§lteren Maschinen erforderte zu viele Ressourcen. </p><br><p>  In SysV wurde eine alternative Version vorgeschlagen, bei der der D√§mon entweder bis zur n√§chsten Minute, f√ºr die die Aufgabe definiert wurde, oder f√ºr 30 Minuten einschlief.  Ressourcen zum erneuten Lesen der Konfiguration und zum √úberpr√ºfen von Aufgaben in diesem Modus wurden weniger verbraucht, es wurde jedoch unpraktisch, die Liste der Aufgaben schnell zu aktualisieren. </p><br><p>  Vixie cron √ºberpr√ºfte einmal pro Minute wieder die Aufgabenlisten, da die Ressourcen auf Standard-Unix-Computern Ende der 80er Jahre viel gr√∂√üer geworden waren: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  ,       */</span></span> run_reboot_jobs(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime    */</span></span> cron_sync(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (TRUE) { <span class="hljs-comment"><span class="hljs-comment">/*  ,     TargetTime    ,    */</span></span> cron_sleep(); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> cron_tick(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime     */</span></span> TargetTime += <span class="hljs-number"><span class="hljs-number">60</span></span>; }</code> </pre><br><p>  Die Funktion cron_sleep, die die Funktionen job_runqueue (Aufz√§hlung und Start von Aufgaben) und do_command (Beginn jeder einzelnen Aufgabe) aufruft, ist direkt an der Ausf√ºhrung von Aufgaben beteiligt.  Die letzte Funktion sollte genauer betrachtet werden. </p><br><h3 id="zapusk-zadachi">  Aufgabenstart </h3><br><p>  Die Funktion do_command wird in einem guten Unix-Stil ausgef√ºhrt, dh sie verzweigt sich f√ºr die asynchrone Ausf√ºhrung von Aufgaben.  Der √ºbergeordnete Prozess startet weiterhin Aufgaben, der untergeordnete Prozess bereitet den Aufgabenprozess vor: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   fork */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*  :          */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> child_process(e, u); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> _exit(OK_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  In child_process steckt viel Logik: Es nimmt Standardausgaben und Fehlerfl√ºsse auf sich selbst auf, sodass es dann an Mail gesendet werden kann (wenn die Umgebungsvariable MAILTO in der Aufgabentabelle angegeben ist), und wartet schlie√ülich auf den Abschluss des Hauptaufgabenprozesses. </p><br><p>  Der Aufgabenprozess wird von einer anderen Gabelung gebildet: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (vfork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(ERROR_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* -   ,   .. */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-comment"><span class="hljs-comment">/* *     ,    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  ,    , *       */</span></span> setgid(e-&gt;gid); setuid(e-&gt;uid); chdir(env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*   SHELL      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *shell = env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*       , *    ,       */</span></span> execle(shell, shell, <span class="hljs-string"><span class="hljs-string">"-c"</span></span>, e-&gt;cmd, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*  ‚Äî    ?   */</span></span> perror(<span class="hljs-string"><span class="hljs-string">"execl"</span></span>); _exit(ERROR_EXIT); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*    :      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  Hier im Allgemeinen und die ganze Cron.  Ich habe einige interessante Details ausgelassen, zum Beispiel die Ber√ºcksichtigung von Remotebenutzern, aber die Hauptsache skizziert. </p><br><h1 id="posleslovie">  Nachwort </h1><br><p>  Cron ist ein √ºberraschend einfaches und n√ºtzliches Programm, das in den besten Traditionen der Unix-Welt erstellt wurde.  Sie macht nichts √úberfl√ºssiges, aber sie macht ihren Job in den letzten Jahrzehnten bemerkenswert.  Das Kennenlernen des Codes der mit Ubuntu gelieferten Version dauerte nicht l√§nger als eine Stunde und ich hatte viel Spa√ü!  Hoffe ich konnte es mit dir teilen. </p><br><p>  Ich wei√ü nichts √ºber Sie, aber es ist ein wenig traurig f√ºr mich zu erkennen, dass die moderne Programmierung mit ihrer Tendenz, sich zu komplizieren und zu abstrahieren, l√§ngst nicht mehr so ‚Äã‚Äãeinfach ist. </p><br><p>  Es gibt viele moderne Alternativen zu cron: Mit systemd-timern k√∂nnen Sie komplexe Systeme mit Abh√§ngigkeiten organisieren. In fcron k√∂nnen Sie den Ressourcenverbrauch nach Aufgaben flexibler steuern.  Aber ich pers√∂nlich hatte immer die einfachste Crontab. </p><br><p>  Mit einem Wort, liebe Unix, benutze einfache Programme und vergiss nicht, Mana f√ºr deine Plattform zu lesen! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468061/">https://habr.com/ru/post/de468061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468049/index.html">Verwenden von werf zum Ausrollen komplexer Helmdiagramme</a></li>
<li><a href="../de468051/index.html">VDS mit lizenziertem Windows Server f√ºr 100 Rubel: Mythos oder Realit√§t?</a></li>
<li><a href="../de468053/index.html">Maschinelles Lernen f√ºr Ihre Wohnungssuche. Teil 1</a></li>
<li><a href="../de468057/index.html">Unix-√§hnliche Betriebssystementwicklung - Multitasking und Systemaufrufe (7)</a></li>
<li><a href="../de468059/index.html">Meine zweite Woche mit Haiku: viele versteckte Diamanten und angenehme √úberraschungen sowie einige Probleme</a></li>
<li><a href="../de468063/index.html">Angulareact</a></li>
<li><a href="../de468065/index.html">Mentale Produktmanagementmodelle f√ºr alle</a></li>
<li><a href="../de468067/index.html">So funktioniert Alpha Compositing</a></li>
<li><a href="../de468071/index.html">Eduard Medwedew, CTO bei Tungsten Labs: ‚ÄûWir sind so weit gewachsen, dass Technologie massiven Schaden anrichten kann.‚Äú</a></li>
<li><a href="../de468073/index.html">Andrei Terekhov: "Sie k√∂nnen so viel sagen, wie Sie m√∂chten, dass Amerikaner besser sind, aber unser Auto bricht nie zusammen."</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>