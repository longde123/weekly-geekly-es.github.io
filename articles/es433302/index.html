<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è≠Ô∏è ü•â üóìÔ∏è Primeros pasos para el √≥xido üë©‚Äçüë¶‚Äçüë¶ üï• üë®üèø‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos Recientemente me encontr√© con un nuevo lenguaje de programaci√≥n Rust. Me di cuenta de que era diferente de los dem√°s que hab√≠a encontrado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Primeros pasos para el √≥xido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433302/"><p><img src="https://habrastorage.org/webt/ra/od/jn/raodjnsmyuf5nphvpqwkhcwliyi.jpeg" alt="imagen"></p><br><p>  Hola a todos  Recientemente me encontr√© con un nuevo lenguaje de programaci√≥n Rust.  Me di cuenta de que era diferente de los dem√°s que hab√≠a encontrado antes.  Por lo tanto, decid√≠ cavar m√°s profundo.  Quiero compartir los resultados y mis impresiones: </p><br><ul><li>  Comenzar√© con las caracter√≠sticas principales, en mi opini√≥n, de Rust </li><li>  Describir√© detalles de sintaxis interesantes </li><li>  Explicar√© por qu√© no es probable que Rust se apodere del mundo </li></ul><br><p>  Explicar√© de inmediato que he estado escribiendo en Java durante unos diez a√±os, as√≠ que discutir√© desde mi campanario. </p><a name="habracut"></a><br><h1 id="killer-feature">  Caracter√≠stica asesina </h1><br><p> Rust est√° tratando de tomar una posici√≥n intermedia entre los lenguajes de bajo nivel como C / C ++ y Java / C # / Python / Ruby de alto nivel ... Cuanto m√°s cerca est√© el lenguaje del hardware, m√°s control, m√°s f√°cil ser√° predecir c√≥mo se ejecutar√° el c√≥digo.  Pero tener acceso completo a la memoria es mucho m√°s f√°cil de dispararle a la pierna.  A diferencia de C / C ++, apareci√≥ Python / Java y todo lo dem√°s.  No necesitan pensar en borrar la memoria.  Lo peor es NPE, las fugas no son tan comunes.  Pero para que esto funcione, necesita, como m√≠nimo, un recolector de basura, que, a su vez, comienza a vivir su vida, en paralelo con el c√≥digo de usuario, lo que reduce su previsibilidad.  La m√°quina virtual a√∫n proporciona independencia de la plataforma, pero cu√°nto se necesita es un punto discutible, no lo plantear√© ahora. </p><br><p>  Rust es un lenguaje de bajo nivel, el compilador genera un binario, que no requiere trucos adicionales para funcionar.  Toda la l√≥gica para eliminar objetos innecesarios est√° integrada en el c√≥digo en el momento de la compilaci√≥n, es decir.  tampoco hay recolector de basura en tiempo de ejecuci√≥n.  Rust tampoco tiene referencias nulas y los tipos son seguros, lo que lo hace a√∫n m√°s confiable que Java. </p><br><p>  En el n√∫cleo de la gesti√≥n de la memoria est√° la idea de poseer una referencia de objeto y pedir prestado.  Si solo una variable posee cada objeto, tan pronto como caduque al final del bloque, todo lo que se√±ala puede borrarse recursivamente.  Los enlaces tambi√©n pueden ser prestados para leer o escribir.  Aqu√≠ funciona el principio de un escritor y muchos lectores. </p><br><p>  Este concepto se puede demostrar en el siguiente c√≥digo.  Se llama a <em>Test</em> <em>()</em> desde el m√©todo <em>main ()</em> , que crea una estructura de datos recursiva <em>MyStruct</em> que implementa la interfaz destructor.  <em>Drop le</em> permite configurar la l√≥gica para que se ejecute antes de que se destruya el objeto.  Algo similar al finalizador en Java, solo que a diferencia de Java, el momento de la llamada al m√©todo <em>drop ()</em> es bastante seguro. </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { test(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"End of main"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = MyStruct { v: <span class="hljs-number"><span class="hljs-number">1</span></span>, s: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new( <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(MyStruct { v: <span class="hljs-number"><span class="hljs-number">2</span></span>, s: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-literal"><span class="hljs-literal">None</span></span>), }) ), }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"End of test"</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyStruct</span></span></span></span> { v: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, s: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;MyStruct&gt;&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyStruct { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cleaning {}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.v) } }</code> </pre> <br><p>  La conclusi√≥n ser√° la siguiente: </p><br><pre> <code class="plaintext hljs">End of test Cleaning 1 Cleaning 2 End of main</code> </pre> <br><p>  Es decir  antes de salir de <em>test (), la</em> memoria se borr√≥ recursivamente.  El compilador se encarg√≥ de esto insertando el c√≥digo necesario.  Qu√© es <em>Box</em> y <em>Option</em> describir√° un poco m√°s tarde. </p><br><p>  De esta manera, Rust toma la seguridad de los lenguajes de alto nivel y la previsibilidad de los lenguajes de programaci√≥n de bajo nivel. </p><br><h1 id="chto-esche-interesnogo">  Que mas interesante </h1><br><p>  A continuaci√≥n, enumero las caracter√≠sticas del lenguaje en orden descendente de importancia, en mi opini√≥n. </p><br><h2 id="oop">  Oop </h2><br><p>  Aqu√≠ el √≥xido generalmente est√° por delante del resto.  Si la mayor√≠a de los idiomas han llegado a la conclusi√≥n de que la herencia m√∫ltiple debe ser abandonada, entonces en Rust no hay herencia en absoluto.  Es decir  una clase solo puede implementar interfaces en cualquier cantidad, pero no puede heredar de otras clases.  En t√©rminos de Java, esto significar√≠a hacer que todas las clases sean finales.  En general, la variedad sint√°ctica para mantener la POO no es tan grande.  Quiz√°s esto sea lo mejor. </p><br><p>  Para combinar datos, hay estructuras que pueden contener implementaci√≥n.  Las interfaces se denominan rasgos y tambi√©n pueden contener implementaciones predeterminadas.  No llegan a clases abstractas, porque  no puede contener campos; muchos se quejan de esta restricci√≥n.  La sintaxis es la siguiente, creo que los comentarios no son necesarios aqu√≠: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { MyPrinter { value: <span class="hljs-number"><span class="hljs-number">10</span></span> }.print(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Printer</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Printer { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPrinter</span></span></span></span> { value: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Printer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyPrinter { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value) } }</code> </pre> <br><p>  De las caracter√≠sticas que not√©, vale la pena se√±alar lo siguiente: </p><br><ul><li>  Las clases no tienen constructores.  Solo hay inicializadores que especifican valores para campos a trav√©s de llaves.  Si necesita un constructor, esto se hace a trav√©s de m√©todos est√°ticos. </li><li>  El m√©todo de instancia difiere del est√°tico al tener la <em>auto</em> referencia como primer argumento. </li><li>  Las clases, interfaces y m√©todos tambi√©n pueden generalizarse.  Pero a diferencia de Java, esta informaci√≥n no se pierde en el momento de la compilaci√≥n. </li></ul><br><h2 id="esche-nemnogo-bezopasnosti">  Algo m√°s de seguridad </h2><br><p>  Como dije, Rust presta gran atenci√≥n a la confiabilidad del c√≥digo e intenta evitar la mayor√≠a de los errores en la etapa de compilaci√≥n.  Para esto, se excluy√≥ la capacidad de hacer que los enlaces est√©n vac√≠os.  Me record√≥ a los tipos anulables de Kotlin.  <em>La opci√≥n se</em> usa para crear enlaces vac√≠os.  Al igual que en Kotlin, al intentar acceder a una variable de este tipo, el compilador golpear√° las manos, obligando a insertar cheques.  Intentar extraer el valor sin verificarlo puede provocar un error.  Pero esto ciertamente no se puede hacer por accidente como, por ejemplo, en Java. </p><br><p>  Tambi√©n me gust√≥ el hecho de que todas las variables y campos de clase son inmutables por defecto.  Hola de nuevo Kotlin.  Si el valor puede cambiar, esto debe indicarse expl√≠citamente con la palabra clave <em>mut</em> .  Creo que el deseo de inmutabilidad mejora en gran medida la legibilidad y la previsibilidad del c√≥digo.  Aunque la <em>opci√≥n</em> por alguna raz√≥n es mutable, no entend√≠ esto, aqu√≠ est√° el c√≥digo de la documentaci√≥n: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = x.take(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(x, <span class="hljs-literal"><span class="hljs-literal">None</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(y, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>));</code> </pre> <br><h2 id="perechisleniya">  Traslados </h2><br><p>  El √≥xido se llama <em>enum</em> .  Solo adem√°s de un n√∫mero limitado de valores pueden contener datos y m√©todos arbitrarios.  Por lo tanto, es algo entre enumeraciones y clases en Java.  La <em>opci√≥n de enumeraci√≥n</em> est√°ndar en mi primer ejemplo solo pertenece a este tipo: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  Hay una construcci√≥n especial para procesar tales valores: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> a { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"empty"</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(v) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, v) } }</code> </pre> <br><h2 id="a-takzhe">  Tambi√©n </h2><br><p>  No tengo la intenci√≥n de escribir un libro de texto sobre Rust, pero simplemente quiero enfatizar sus caracter√≠sticas.  En esta secci√≥n describir√© qu√© m√°s es √∫til, pero, en mi opini√≥n, no es tan √∫nico: </p><br><ul><li>  Los fan√°ticos de la programaci√≥n funcional no se sentir√°n decepcionados; hay lambdas para ellos.  El iterador tiene m√©todos para procesar la colecci√≥n, por ejemplo, <em>filter</em> y <em>for_each</em> .  Algo as√≠ como las secuencias de Java. </li><li>  La construcci√≥n de <em>coincidencia</em> tambi√©n se puede usar para cosas m√°s complejas que la <em>enumeraci√≥n</em> regular, por ejemplo, para procesar patrones. </li><li>  Hay una gran cantidad de clases integradas, por ejemplo, colecciones: <em>Vec, LinkedList, HashMap</em> , etc. </li><li>  Puedes crear macros </li><li>  Es posible agregar m√©todos a clases existentes </li><li>  Inferencia de tipo autom√°tica compatible </li><li>  Junto con el lenguaje viene un marco de prueba est√°ndar </li><li>  La utilidad de <em>carga</em> incorporada se usa para construir y administrar dependencias </li></ul><br><h1 id="lozhki-degtya">  Volar en la pomada </h1><br><p>  Esta secci√≥n es necesaria para completar la imagen. </p><br><h2 id="killer-problem">  Problema asesino </h2><br><p>  El principal inconveniente proviene de la caracter√≠stica principal.  Tienes que pagar por todo.  En Rust, es muy inconveniente trabajar con estructuras de datos de gr√°ficos mutables, porque  cualquier objeto no debe tener m√°s de un enlace.  Para evitar esta limitaci√≥n, hay un mont√≥n de clases integradas: </p><br><ul><li>  <em>Box</em> : un valor inmutable en el mont√≥n, un an√°logo de envoltorios para primitivas en Java </li><li>  <em>Celda</em> - valor variable </li><li>  <em>RefCell</em> - valor variable accesible por referencia </li><li>  <em>Rc</em> - contador de referencia, para m√∫ltiples referencias a un objeto </li></ul><br><p>  Y esta es una lista incompleta.  Para la primera muestra de Rust, decid√≠ imprudentemente escribir una lista vinculada individualmente con m√©todos b√°sicos.  Finalmente, el enlace al nodo <em>result√≥ en la</em> siguiente <em>Opci√≥n &lt;Rc &lt;RefCell &lt;ListNode&gt; &gt;&gt;</em> : </p><br><ul><li>  <em>Opci√≥n</em> : para procesar un enlace vac√≠o </li><li>  <em>Rc</em> : para enlaces m√∫ltiples, como  el √∫ltimo nodo est√° referenciado por el nodo anterior y la hoja en s√≠ </li><li>  <em>RefCell</em> - para enlace mutable </li><li>  <em>ListNode</em> : el siguiente elemento en s√≠ </li></ul><br><p>  Parece regular, un total de tres envoltorios alrededor de un objeto.  El c√≥digo para simplemente agregar un elemento al final de la lista es muy engorroso y hay cosas no obvias en √©l, como la clonaci√≥n y los pr√©stamos: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListNode</span></span></span></span> { val: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, next: Node, } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LinkedList</span></span></span></span> { root: Node, last: Node, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> LinkedList { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, val: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; LinkedList { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = Rc::new(RefCell::new(ListNode { val: val, next: <span class="hljs-literal"><span class="hljs-literal">None</span></span> })); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.root.is_none()){ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.root = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n.clone()); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.last.map(|v| { v.borrow_mut().next = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n.clone()) }); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.last = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> } ...</code> </pre> <br><p>  En Kotlin, lo mismo parece mucho m√°s simple: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newNode = ListNode(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, value); root = root ?: newNode; last?.next = newNode last = newNode; }</code> </pre> <br><p>  Como descubr√≠ m√°s tarde, tales estructuras no son t√≠picas de Rust, y mi c√≥digo es completamente no idiom√°tico.  La gente incluso escribe art√≠culos completos: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">10 maneras de hacer una lista en Rust</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otra forma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tormento similar al m√≠o</a> </li></ul><br><p>  Aqu√≠ Rust sacrifica la legibilidad por seguridad.  Adem√°s, estos ejercicios a√∫n pueden conducir a enlaces en bucle que se cuelgan en la memoria, porque  Ning√∫n recolector de basura se los llevar√°.  No escrib√≠ c√≥digo de trabajo en Rust, as√≠ que es dif√≠cil para m√≠ decir cu√°nto complican la vida tales dificultades.  Ser√≠a interesante recibir comentarios de ingenieros en ejercicio. </p><br><h2 id="slozhnost-izucheniya">  Dificultad para aprender </h2><br><p>  El largo proceso de aprendizaje de Rust se sigue en gran medida de la secci√≥n anterior.  Antes de escribir algo, debe dedicar tiempo a dominar el concepto clave de la propiedad de la memoria, como  impregna cada l√≠nea.  Por ejemplo, la lista m√°s simple me llev√≥ un par de noches, mientras que en Kotlin se escribe lo mismo en 10 minutos, aunque este no es mi idioma de trabajo.  Adem√°s, muchos enfoques familiares para escribir algoritmos o estructuras de datos en Rust se ver√°n diferentes o no funcionar√°n en absoluto.  Es decir  al cambiar a √©l, se requerir√° una reestructuraci√≥n m√°s profunda del pensamiento, solo dominar la sintaxis no ser√° suficiente.  Esto est√° lejos de JavaScript, que se traga y aguanta todo.  Creo que Rust nunca ser√° el idioma que se les ense√±a a los ni√±os en una escuela de programaci√≥n.  Incluso C / C ++ tiene m√°s posibilidades en este sentido. </p><br><h1 id="v-itoge">  Al final </h1><br><p>  La idea de administrar la memoria en la etapa de compilaci√≥n me pareci√≥ muy interesante.  En C / C ++, no tengo experiencia, por lo que no lo comparar√© con el puntero inteligente.  La sintaxis es generalmente agradable y no hay nada superfluo.  Critiqu√© a Rust por la complejidad de implementar estructuras de datos gr√°ficos, pero sospecho que esta es una caracter√≠stica de todos los lenguajes de programaci√≥n que no son GC.  Quiz√°s la comparaci√≥n con Kotlin no fue del todo honesta. </p><br><h1 id="todo">  Todo </h1><br><p>  En este art√≠culo, no toqu√© el subproceso m√∫ltiple en absoluto, creo que este es un gran tema por separado.  Todav√≠a hay planes para escribir alg√∫n tipo de estructura de datos o algoritmo m√°s complicado que la lista, si tiene ideas, por favor comparta en los comentarios.  Ser√≠a interesante saber qu√© tipos de aplicaciones se escriben generalmente en Rust. </p><br><h1 id="pochitat">  Leer </h1><br><p>  Si est√° interesado en Rust, aqu√≠ hay algunos enlaces: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rust de programaci√≥n: desarrollo de sistemas r√°pido y seguro</a> : un buen libro, tambi√©n hay una versi√≥n electr√≥nica </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentaci√≥n de √≥xido</a> - documentaci√≥n oficial, hay ejemplos </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo de √≥xido idiom√°tico</a> - lista de art√≠culos </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ruRust / easy</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ruRust / general</a> - canales en Gitter </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">r / rust /</a> - Reddit </li></ul><br><p>  <strong>UPD: Gracias a todos por sus comentarios.</strong>  <strong>Aprend√≠ muchas cosas √∫tiles para m√≠.</strong>  <strong>Inexactitudes y errores tipogr√°ficos corregidos, enlaces agregados.</strong>  <strong>Creo que tales discusiones contribuyen en gran medida al estudio de las nuevas tecnolog√≠as.</strong> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433302/">https://habr.com/ru/post/es433302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433292/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 279 (del 10 al 16 de diciembre)</a></li>
<li><a href="../es433294/index.html">Algunas recomendaciones simples de trabajo en equipo</a></li>
<li><a href="../es433296/index.html">Gesti√≥n financiera en una empresa de TI.</a></li>
<li><a href="../es433298/index.html">Network Digest: 17 materiales expertos sobre Wi-Fi y 5G</a></li>
<li><a href="../es433300/index.html">Creaci√≥n de un centro de medios en casa. Prologo</a></li>
<li><a href="../es433304/index.html">Prueba de carga con langosta. Parte 3</a></li>
<li><a href="../es433306/index.html">Visual studio 2019</a></li>
<li><a href="../es433308/index.html">Transferencia de la configuraci√≥n de PBX al servicio 3CX PBX Express</a></li>
<li><a href="../es433316/index.html">Resumen del dise√±o: incorporaci√≥n, retroalimentaci√≥n, b√∫squeda de ideas y toma de decisiones.</a></li>
<li><a href="../es433318/index.html">garbage.collect ()</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>