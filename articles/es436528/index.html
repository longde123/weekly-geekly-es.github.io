<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>憋  じ Depuraci贸n de una red utilizando eBPF (RHEL 8 Beta)  げ </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todo con las pasadas vacaciones! 

 Decidimos dedicar nuestro primer art铆culo despu茅s de las vacaciones a Linux, es decir, a nuestro maravilloso curso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Depuraci贸n de una red utilizando eBPF (RHEL 8 Beta)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/436528/"> Todo con las pasadas vacaciones! <br><br>  Decidimos dedicar nuestro primer art铆culo despu茅s de las vacaciones a Linux, es decir, a nuestro maravilloso curso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Administrador de Linux</a> , que tenemos en la cohorte de los cursos m谩s din谩micos, es decir, con los materiales y pr谩cticas m谩s relevantes.  Bueno y, en consecuencia, ofrecemos art铆culos interesantes y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una lecci贸n abierta</a> . <br><br>  <i>Publicado por Matteo Croce</i> <i><br></i>  <i>T铆tulo original: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Depuraci贸n de red con eBPF (RHEL 8 Beta)</a></i> <br><br>  <b>Introduccion</b> <br><br>  La creaci贸n de redes es una experiencia emocionante, pero no siempre se evitan los problemas.  La resoluci贸n de problemas puede ser complicada, ya que intenta reproducir el comportamiento incorrecto que ocurre "en el campo". <br><br>  Afortunadamente, existen herramientas que pueden ayudar con esto: espacios de nombres de red, m谩quinas virtuales, <code>tc</code> y <code>netfilter</code> .  Se pueden reproducir configuraciones de red simples usando espacios de nombres de red y dispositivos veth, mientras que configuraciones m谩s complejas requieren conectar m谩quinas virtuales con un puente de software y usar herramientas de red est谩ndar, como <code>iptables</code> o <code>tc</code> , para simular un comportamiento incorrecto.  Si hay un problema con las respuestas ICMP generadas cuando el servidor SSH <code>iptables -A INPUT -p tcp --dport 22 -j REJECT --reject-with icmp-host-unreachable</code> , <code>iptables -A INPUT -p tcp --dport 22 -j REJECT --reject-with icmp-host-unreachable</code> en el espacio de nombres correcto puede ayudar a resolver el problema. <br><br>  Este art铆culo describe c贸mo solucionar problemas complejos de red con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eBPF (BPF extendido)</a> , una versi贸n avanzada del Berkeley Packet Filter.  eBPF es una tecnolog铆a relativamente nueva, el proyecto se encuentra en una etapa temprana, por lo que la documentaci贸n y el SDK a煤n no est谩n listos.  Pero esperemos mejoras, especialmente porque el XDP (eXpress Data Path) viene con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Red Hat Enterprise Linux 8 Beta</a> , que puede descargar y ejecutar ahora mismo. <br><br>  eBPF no resolver谩 todos los problemas, pero sigue siendo una poderosa herramienta de depuraci贸n de red que merece atenci贸n.  Estoy seguro de que jugar谩 un papel muy importante en el futuro de las redes. <br><br><img src="https://habrastorage.org/webt/qf/la/jo/qflajolwk-bjp2zwjzpnixmqlma.png"><a name="habracut"></a><br><br>  <b>El problema</b> <br><br>  Depur茅 el problema de red <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Open vSwitch (OVS)</a> , que implic贸 una instalaci贸n muy compleja: algunos paquetes TCP se dispersaron y se entregaron en el orden incorrecto, y el ancho de banda de las m谩quinas virtuales cay贸 de 6 Gb / s estables a 2-4 Gb / s fluctuantes.  El an谩lisis mostr贸 que el primer paquete TCP de cada conexi贸n con el indicador PSH se envi贸 en el orden incorrecto: solo el primero y el 煤nico por conexi贸n. <br><br>  Trat茅 de reproducir esta configuraci贸n con dos m谩quinas virtuales y, despu茅s de muchos art铆culos de ayuda y consultas de b煤squeda, descubr铆 que ni <code>iptables</code> ni <code>nftables</code> pueden manipular indicadores TCP, mientras que <code>tc</code> puede, sino solo sobrescribiendo los indicadores e interrumpiendo nuevas conexiones y TCP en general <br><br>  Podr铆a ser posible resolver el problema con una combinaci贸n de <code>iptables</code> , <code>conntrack</code> y <code>tc</code> , pero decid铆 que este es un gran trabajo para eBPF. <br><br>  <b>驴Qu茅 es eBPF?</b> <br><br>  eBPF es una versi贸n mejorada del filtro de paquetes Berkeley.  Ella trae muchas mejoras a BPF.  En particular, le permite escribir en la memoria, y no solo leer, por lo que los paquetes no solo se pueden filtrar, sino tambi茅n editar. <br><br>  A menudo, eBPF simplemente se llama BPF, y el propio BPF se llama cBPF (BPF cl谩sico (cl谩sico)), por lo que la palabra "BPF" puede usarse para referirse a ambas versiones, dependiendo del contexto: en este art铆culo siempre hablo de la versi贸n extendida. <br><br>  "Under the hood" eBPF tiene una m谩quina virtual muy simple que puede ejecutar peque帽os fragmentos de bytecode y editar algunos buffers de memoria.  Existen limitaciones en eBPF que lo protegen del uso malicioso: <br><br><ul><li>  Los ciclos est谩n prohibidos para que el programa siempre finalice en un momento espec铆fico; </li><li>  Solo puede acceder a la memoria a trav茅s de la pila y el b煤fer de memoria virtual; </li><li>  Solo se pueden llamar las funciones permitidas del kernel. </li></ul><br>  Un programa puede cargarse en el kernel de varias formas mediante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">depuraci贸n y rastreo</a> .  En nuestro caso, eBPF est谩 interesado en trabajar con subsistemas de red.  Hay dos formas de usar el programa eBPF: <br><br><ul><li>  Conectado a trav茅s de XDP al comienzo de la ruta RX de una tarjeta de red f铆sica o virtual; </li><li>  Conectado v铆a <code>tc</code> a qdisc en entrada o salida. </li></ul><br>  Para crear un programa eBPF para conectarse, simplemente escriba el c贸digo C y convi茅rtalo a bytecode.  El siguiente es un ejemplo simple con XDP: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">SEC</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">prog</span></span>") <span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xdp_main</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">struct</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xdp_md</span></span> *<span class="hljs-selector-tag"><span class="hljs-selector-tag">ctx</span></span>) { void *data_end = (void *)(uintptr_t)ctx-&gt;data_end; void *data = (void *)(uintptr_t)ctx-&gt;data; struct ethhdr *eth = data; struct iphdr *iph = (struct iphdr *)(eth + 1); struct icmphdr *icmph = (struct icmphdr *)(iph + 1); <span class="hljs-comment"><span class="hljs-comment">/* sanity check needed by the eBPF verifier */</span></span> if (icmph + 1 &gt; data_end) return XDP_PASS; <span class="hljs-comment"><span class="hljs-comment">/* matched a pong packet */</span></span> if (eth-&gt;h_proto != ntohs(ETH_P_IP) || iph-&gt;protocol != IPPROTO_ICMP || icmph-&gt;type != ICMP_ECHOREPLY) return XDP_PASS; if (iph-&gt;ttl) { <span class="hljs-comment"><span class="hljs-comment">/* save the old TTL to recalculate the checksum */</span></span> uint16_t *ttlproto = (uint16_t *)&amp;iph-&gt;ttl; uint16_t old_ttlproto = *ttlproto; <span class="hljs-comment"><span class="hljs-comment">/* set the TTL to a pseudorandom number 1 &lt; x &lt; TTL */</span></span> iph-&gt;ttl = bpf_get_prandom_u32() % iph-&gt;ttl + 1; <span class="hljs-comment"><span class="hljs-comment">/* recalculate the checksum; otherwise, the IP stack will drop it */</span></span> csum_replace2(&amp;iph-&gt;check, old_ttlproto, *ttlproto); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">XDP_PASS</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">char</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">license</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SEC</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">license</span></span>") = "<span class="hljs-selector-tag"><span class="hljs-selector-tag">GPL</span></span>";</code> </pre> <br>  El fragmento anterior, sin <code>include</code> expresiones, ayudantes y c贸digo opcional, es un programa XDP que cambia el TTL de las respuestas de eco ICMP recibidas, es decir, pongs, por un n煤mero aleatorio.  La funci贸n principal obtiene la estructura <code>xdp_md</code> , que contiene dos punteros al principio y al final del paquete. <br><br>  Para compilar nuestro c贸digo en el bytecode eBPF, se requiere un compilador con el soporte adecuado.  Clang lo admite y crea el bytecode eBPF especificando bpf como destino en el momento de la compilaci贸n: <br><br><pre> <code class="bash hljs">$ clang -O2 -target bpf -c xdp_manglepong.c -o xdp_manglepong.o</code> </pre> <br>  El comando anterior crea un archivo que, a primera vista, parece un archivo de objeto normal, pero despu茅s de una inspecci贸n m谩s cercana, resulta que el tipo de computadora especificado es Linux eBPF, y no el tipo nativo de sistema operativo: <br><br><pre> <code class="bash hljs">$ readelf -h xdp_manglepong.o ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2<span class="hljs-string"><span class="hljs-string">'s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (Relocatable file) Machine: Linux BPF &lt;--- HERE [...]</span></span></code> </pre> <br>  Una vez recibido el contenedor de un archivo de objeto normal, el programa eBPF est谩 listo para descargar y conectarse al dispositivo a trav茅s de XDP.  Esto se puede hacer usando <code>ip</code> del paquete <code>iproute2</code> con la siguiente sintaxis: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ip -force link set dev wlan0 xdp object xdp_manglepong.o verbose</span></span></code> </pre> <br>  Este comando especifica la interfaz wlan0 de destino y, gracias a la opci贸n -force, sobrescribe cualquier c贸digo eBPF existente que ya se haya cargado.  Despu茅s de cargar el bytecode eBPF, el sistema se comporta de la siguiente manera: <br><br><pre> <code class="bash hljs">$ ping -c10 192.168.85.1 PING 192.168.85.1 (192.168.85.1) 56(84) bytes of data. 64 bytes from 192.168.85.1: icmp_seq=1 ttl=41 time=0.929 ms 64 bytes from 192.168.85.1: icmp_seq=2 ttl=7 time=0.954 ms 64 bytes from 192.168.85.1: icmp_seq=3 ttl=17 time=0.944 ms 64 bytes from 192.168.85.1: icmp_seq=4 ttl=64 time=0.948 ms 64 bytes from 192.168.85.1: icmp_seq=5 ttl=9 time=0.803 ms 64 bytes from 192.168.85.1: icmp_seq=6 ttl=22 time=0.780 ms 64 bytes from 192.168.85.1: icmp_seq=7 ttl=32 time=0.847 ms 64 bytes from 192.168.85.1: icmp_seq=8 ttl=50 time=0.750 ms 64 bytes from 192.168.85.1: icmp_seq=9 ttl=24 time=0.744 ms 64 bytes from 192.168.85.1: icmp_seq=10 ttl=42 time=0.791 ms --- 192.168.85.1 ping statistics --- 10 packets transmitted, 10 received, 0% packet loss, time 125ms rtt min/avg/max/mdev = 0.744/0.849/0.954/0.082 ms</code> </pre> <br>  Cada paquete pasa a trav茅s de eBPF, que finalmente realiza algunos cambios y decide si descarta el paquete o se salta. <br><br>  <b>C贸mo puede ayudar eBPF</b> <br><br>  Volviendo al problema de red original, recordamos que era necesario marcar varios indicadores TCP, uno por conexi贸n, y ni <code>iptables</code> ni <code>tc</code> pod铆an hacer esto.  Escribir c贸digo para este escenario no es nada dif铆cil: configure dos m谩quinas virtuales conectadas por un puente OVS y simplemente conecte eBPF a uno de los dispositivos virtuales de VM. <br><br>  Parece una gran soluci贸n, pero tenga en cuenta que XDP solo admite el procesamiento de paquetes recibidos, y conectar el eBPF a la ruta <code>rx</code> de la m谩quina virtual receptora no tendr谩 ning煤n efecto en el conmutador. <br><br>  Para resolver este problema, eBPF debe cargarse usando <code>tc</code> y conectarse a la ruta de salida de la VM, porque <code>tc</code> puede cargar y conectar programas eBPF a qdisk.  Para marcar los paquetes que salen del host, eBPF debe estar conectado al qdisk de salida. <br><br>  Al cargar el programa eBPF, existen algunas diferencias entre la API <code>XDP</code> y <code>tc</code> : por defecto, diferentes nombres de secci贸n, el tipo de estructura del argumento de la funci贸n principal, diferentes valores de retorno.  Pero esto no es un problema.  A continuaci贸n se muestra un fragmento de un programa que marca TCP cuando se une a una acci贸n tc: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RATIO 10 SEC(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"action"</span></span></span><span class="hljs-meta">) int bpf_main(struct __sk_buff *skb) { void *data = (void *)(uintptr_t)skb-&gt;data; void *data_end = (void *)(uintptr_t)skb-&gt;data_end; struct ethhdr *eth = data; struct iphdr *iph = (struct iphdr *)(eth + 1); struct tcphdr *tcphdr = (struct tcphdr *)(iph + 1); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* sanity check needed by the eBPF verifier */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((void *)(tcphdr + 1) &gt; data_end) return TC_ACT_OK; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* skip non-TCP packets */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (eth-&gt;h_proto != __constant_htons(ETH_P_IP) || iph-&gt;protocol != IPPROTO_TCP) return TC_ACT_OK; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* incompatible flags, or PSH already set */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (tcphdr-&gt;syn || tcphdr-&gt;fin || tcphdr-&gt;rst || tcphdr-&gt;psh) return TC_ACT_OK; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bpf_get_prandom_u32() % RATIO == 0) tcphdr-&gt;psh = 1; return TC_ACT_OK; } char _license[] SEC(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"license"</span></span></span><span class="hljs-meta">) = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GPL"</span></span></span><span class="hljs-meta">;</span></span></code> </pre> <br>  La compilaci贸n en bytecode se realiza como se muestra en el ejemplo XDP anterior utilizando lo siguiente: <br><br><pre> <code class="bash hljs">clang -O2 -target bpf -c tcp_psh.c -o tcp_psh.o</code> </pre> <br>  Pero la descarga es diferente: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># tc qdisc add dev eth0 clsact # tc filter add dev eth0 egress matchall action bpf object-file tcp_psh.o</span></span></code> </pre> <br>  Ahora el eBPF se carga en el lugar correcto y los paquetes que salen de la VM est谩n marcados.  Despu茅s de verificar los paquetes recibidos en la segunda VM, veremos lo siguiente: <br><br><img src="https://habrastorage.org/webt/iz/kd/dq/izkddqprcvumlcgvdxvtzrecbmg.png"><br><br>  <code>tcpdump</code> confirma que el nuevo c贸digo eBPF est谩 funcionando y que aproximadamente 1 de cada 10 paquetes TCP tiene establecido el indicador PSH.  隆Solo se necesitaron 20 l铆neas de c贸digo C para marcar selectivamente los paquetes TCP que salen de la m谩quina virtual, reproducir el error que ocurre "en la batalla", y todo sin recompilar o incluso reiniciar!  Esto simplific贸 enormemente la verificaci贸n de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soluci贸n Open vSwitch</a> , que era imposible de lograr con otras herramientas. <br><br>  <b>Conclusi贸n</b> <br><br>  eBPF es una tecnolog铆a bastante nueva, y la comunidad tiene una opini贸n clara sobre su implementaci贸n.  Tambi茅n vale la pena se帽alar que los proyectos basados en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eBPF</a> , como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bpfilter</a> , se est谩n volviendo m谩s populares y, como resultado, muchos proveedores de equipos est谩n comenzando a implementar el soporte de eBPF directamente en las tarjetas de red. <br><br>  eBPF no resolver谩 todos los problemas, por lo que no debe abusar de 茅l, pero sigue siendo una herramienta muy poderosa para la depuraci贸n de la red y merece atenci贸n.  Estoy seguro de que jugar谩 un papel importante en el futuro de las redes. <br><br>  <b>El fin</b> <br><br>  Estamos esperando sus comentarios aqu铆, y tambi茅n lo invitamos a visitar nuestra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lecci贸n abierta</a> , donde tambi茅n puede hacer preguntas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436528/">https://habr.com/ru/post/es436528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436514/index.html">Creando historias para Instagram desde PHP</a></li>
<li><a href="../es436518/index.html">Haiku 尾1 - make / b / OS great again</a></li>
<li><a href="../es436520/index.html">No utilice los servicios de verificaci贸n en l铆nea cuando filtre datos personales.</a></li>
<li><a href="../es436522/index.html">Contrariamente a las instrucciones</a></li>
<li><a href="../es436524/index.html">Experiencia de programaci贸n Unix *</a></li>
<li><a href="../es436530/index.html">Ctrl-Alt-Del: Aprender a amar el c贸digo heredado</a></li>
<li><a href="../es436536/index.html">C贸mo simplificar la implementaci贸n de aplicaciones en la nube: introdujo una nueva especificaci贸n abierta</a></li>
<li><a href="../es436538/index.html">Dificultades para operar el sistema de alarma de seguridad.</a></li>
<li><a href="../es436542/index.html">Ping眉ino, virtualizaci贸n y $ 23 mil millones: c贸mo y por qu茅 la tecnolog铆a en la nube ha cambiado para siempre el mundo de TI</a></li>
<li><a href="../es436544/index.html">Marketplace responder谩 por todo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>