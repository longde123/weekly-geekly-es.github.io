<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßû ‚úäüèª üéé Cloud Smart Home. Teil 1: Controller und Sensoren üë© ü•ã üîõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dank der rasanten Entwicklung von Mikroelektronik, Kommunikationskan√§len, Internet-Technologien und k√ºnstlicher Intelligenz wird das Thema Smart Homes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cloud Smart Home. Teil 1: Controller und Sensoren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467219/"><img src="https://habrastorage.org/webt/q6/ni/9k/q6ni9k05gsedjwzqbsyfr_zc7sc.png"><br><br>  Dank der rasanten Entwicklung von Mikroelektronik, Kommunikationskan√§len, Internet-Technologien und k√ºnstlicher Intelligenz wird das Thema Smart Homes heute immer relevanter.  Das Wohnen von Menschen hat sich seit der Steinzeit und in der Zeit der industriellen Revolution 4.0 erheblich ver√§ndert, und das Internet der Dinge wurde bequem, funktional und sicher.  Es kommen L√∂sungen auf den Markt, die eine Wohnung oder ein Landhaus in ausgefeilte Informationssysteme verwandeln, die von √ºberall auf der Welt mit einem Smartphone verwaltet werden.  Dar√ºber hinaus sind f√ºr die Mensch-Maschine-Interaktion keine Programmiersprachenkenntnisse mehr erforderlich. Dank der Spracherkennungs- und Sprachsynthesealgorithmen spricht eine Person ihre Muttersprache mit einem Smart Home. <br><br>  Einige derzeit auf dem Markt befindliche Smart-Home-Systeme sind eine logische Entwicklung von Cloud-basierten Video√ºberwachungssystemen, deren Entwickler die Notwendigkeit einer umfassenden L√∂sung nicht nur f√ºr die √úberwachung, sondern auch f√ºr die Verwaltung entfernter Objekte erkannt haben. <br><br>  Wir bieten Ihnen eine Reihe von drei Artikeln an, in denen Sie alle Hauptkomponenten des vom Autor pers√∂nlich entwickelten und in Betrieb genommenen Cloud-Smart-Home-Systems kennenlernen.  Der erste Artikel befasst sich mit Terminal-Client-Ger√§ten, die in einem Smart Home installiert sind, der zweite mit der Architektur eines Cloud-Speicher- und Datenverarbeitungssystems und der dritte mit einer Client-Anwendung zur Verwaltung des Systems auf mobilen und station√§ren Ger√§ten. <br><a name="habracut"></a><br><h1>  Smart Home-Ausr√ºstung </h1><br>  Lassen Sie uns zun√§chst dar√ºber sprechen, wie Sie aus einer gew√∂hnlichen Wohnung, einem Cottage oder einem Cottage ein intelligentes Zuhause machen k√∂nnen.  Zu diesem Zweck ist es in der Regel erforderlich, folgende Ger√§te im Haus aufzustellen: <br><br><ol><li>  Sensoren, die verschiedene Umgebungsparameter messen; </li><li>  Aktuatoren, die auf externe Objekte wirken; </li><li>  Eine Steuerung, die Berechnungen gem√§√ü Sensormessungen und eingebetteter Logik durchf√ºhrt und Befehle an Aktuatoren ausgibt. </li></ol><br>  Die folgende Abbildung zeigt das Diagramm eines Smart Homes, auf dem Sensoren f√ºr Wasserleckage (1) im Badezimmer, Temperatur (2) und Beleuchtung (3) im Schlafzimmer, eine Smart-Steckdose (4) in der K√ºche und eine Video√ºberwachungskamera (5) im Flur vorhanden sind. <br><br><img src="https://habrastorage.org/webt/nq/en/f-/nqenf-epwiuqhsimy3ft2wbyvpo.png"><br><br>  Derzeit werden h√§ufig drahtlose Sensoren verwendet, die unter den Protokollen RF433, Z-Wave, ZigBee, Bluetooth und WiFi arbeiten.  Ihre Hauptvorteile sind einfache Installation und Verwendung sowie geringe Kosten und Zuverl√§ssigkeit, weil  Hersteller versuchen, ihre Ger√§te auf den Massenmarkt zu bringen und sie dem durchschnittlichen Benutzer zur Verf√ºgung zu stellen. <br><br>  Sensoren und Aktoren sind in der Regel √ºber eine drahtlose Schnittstelle mit dem Smart Home Controller (6) verbunden - einem speziellen Mikrocomputer, der alle diese Ger√§te in ein einziges Netzwerk integriert und steuert. <br><br>  Einige L√∂sungen k√∂nnen jedoch gleichzeitig einen Sensor, einen Aktuator und eine Steuerung kombinieren.  Beispielsweise kann eine Smart-Buchse so programmiert werden, dass sie nach einem Zeitplan ein- oder ausgeschaltet wird, und eine Cloud-basierte Video√ºberwachungskamera kann Videos basierend auf einem Bewegungsmeldersignal aufzeichnen.  In den einfachsten F√§llen k√∂nnen Sie auf einen separaten Controller verzichten. Um jedoch ein flexibles System mit vielen Szenarien zu erstellen, ist dies erforderlich. <br><br>  Um den Smart-Home-Controller mit dem globalen Netzwerk zu verbinden, kann ein herk√∂mmlicher Internet-Router (7) verwendet werden, der in jedem Haushalt seit langem ein bekanntes Haushaltsger√§t ist.  Es gibt noch ein weiteres Argument f√ºr den Smart-Home-Controller: Wenn die Verbindung zum Internet unterbrochen wird, funktioniert das Smart-Home aufgrund des im Controller gespeicherten Logikblocks und nicht im Cloud-Dienst normal weiter. <br><br><h1>  Smart Home Controller </h1><br>  Der in diesem Artikel beschriebene Controller f√ºr das Cloud-Smart-Home-System wurde auf der Grundlage des im M√§rz 2018 ver√∂ffentlichten Einplatinen-Mikrocomputers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raspberry Pi 3 Modell B + entwickelt</a> , der √ºber ausreichende Ressourcen und Leistung f√ºr Smart-Home-Aufgaben verf√ºgt.  Es besteht aus einem vierkernigen Cortex-A53-Prozessor mit einer 64-Bit-ARMv8-A-Architektur, die mit 1,4 GHz getaktet ist, sowie 1 GB RAM, Wi-Fi 802.11ac, Bluetooth 4.2 und einem Gigabit-Ethernet-Adapter, der √ºber den USB 2.0-Bus funktioniert. <br><br><img src="https://habrastorage.org/webt/ki/di/-_/kidi-_hdoclhmawxeqcgxvjxnwm.jpeg"><br><br>  Die Montage des Controllers ist sehr einfach: Der Mikrocomputer (1) wird in ein Kunststoffgeh√§use (2) eingebaut, dann werden eine 8-GB-microSD-Karte mit Software (3) und ein USB-Z-Wave-Netzwerkcontroller (4) in die entsprechenden Steckpl√§tze eingesetzt.  Der Smart-Home-Controller wird √ºber ein 5-V-, 2,1-A- (5) Netzteil und ein USB-Micro-USB-Kabel (6) an das Stromnetz angeschlossen.  Jeder Controller verf√ºgt √ºber eine eindeutige Identifikationsnummer, die beim ersten Start in der Konfigurationsdatei aufgezeichnet wird und f√ºr die Interaktion mit Cloud-Smart-Home-Diensten erforderlich ist. <br><br>  Die Smart Home Controller-Software wurde vom Autor dieses Artikels basierend auf dem Betriebssystem <b>Linux Raspbian Stretch</b> entwickelt.  Es besteht aus den folgenden Hauptsubsystemen: <br><br><ul><li>  Serverprozess f√ºr die Interaktion mit Smart-Home-Ger√§ten und der Cloud; </li><li>  grafische Benutzeroberfl√§che zur Konfiguration der Steuerung und der Betriebsparameter; </li><li>  Datenbanken zum Speichern der Controller-Konfiguration. </li></ul><br><img src="https://habrastorage.org/webt/s6/lx/k-/s6lxk-xr0gnx8cy5wohn6u8pgqo.png"><br><br>  <b>Die Datenbank des</b> Smart Home Controllers basiert auf dem eingebetteten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SQLite</a> DBMS und ist eine Datei auf der SD-Karte mit Systemsoftware.  Es dient als Repository f√ºr die Controller-Konfiguration - Informationen zu den angeschlossenen Ger√§ten und ihrem aktuellen Status, ein Block logischer Produktionsregeln sowie Informationen, die indiziert werden m√ºssen (z. B. Dateinamen des lokalen Videoarchivs).  Beim Neustart des Controllers werden diese Informationen gespeichert, sodass der Controller bei einem Stromausfall wiederhergestellt werden kann. <br><br>  <b>Die grafische Oberfl√§che des</b> Smart-Home-Controllers wurde in PHP 7 mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slim-</a> Mikroframeworks entwickelt.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.lig">lighttpd</a> -Webserver, der aufgrund seiner guten Leistung und des geringen Ressourcenbedarfs h√§ufig in eingebetteten Ger√§ten verwendet wird, ist f√ºr den Betrieb der Anwendung verantwortlich. <br><br> <a href=""><img src="https://habrastorage.org/webt/p6/jh/w0/p6jhw0khe-pnljdtzf54qjrtgna.png"></a> <br>  <font color="grey">(Klicken Sie auf das Bild, um es in h√∂herer Aufl√∂sung zu √∂ffnen.)</font> <br><br>  Die Hauptfunktion der grafischen Oberfl√§che besteht darin, Smart-Home-Ger√§te (IP-Kameras und Sensoren) an die Steuerung anzuschlie√üen.  Die Webanwendung liest die Konfiguration und den aktuellen Status des Controllers und der damit verbundenen Ger√§te aus der SQLite-Datenbank.  Um die Konfiguration des Controllers zu √§ndern, sendet er Steuerbefehle im JSON-Format √ºber die RESTful-API des Serverprozesses. <br><br><h1>  Serverprozess </h1><br>  <b>Der Serverprozess</b> ist eine Schl√ºsselkomponente, die alle grundlegenden Arbeiten zur Automatisierung der Informationsprozesse erledigt, die die Grundlage eines Smart Homes bilden: Empfangen und Verarbeiten von Sensordaten, Ausf√ºhren von Steueraktionen in Abh√§ngigkeit von der zugrunde liegenden Logik.  Der Zweck des Serverprozesses besteht darin, mit Smart-Home-Ger√§ten zu interagieren, Produktionslogikregeln zu befolgen, Befehle von der grafischen Oberfl√§che und der Cloud zu empfangen und zu verarbeiten.  Der Serverprozess in diesem Smart Home-Controller ist als Multithread-Anwendung implementiert, die in C ++ entwickelt und als separater Systemdienst des <b>Linux Raspbian-</b> Betriebssystems gestartet wurde. <br><br>  Die Hauptbl√∂cke des Serverprozesses sind: <br><br><ol><li>  Nachrichtenmanager </li><li>  IP-Kamera-Server; </li><li>  Z-Wave-Ger√§teserver; </li><li>  Regeln f√ºr die Serverproduktionslogik; </li><li>  Datenbank der Konfiguration des Controllers und des Blocks logischer Regeln; </li><li>  RESTful API-Server f√ºr die Interaktion mit der grafischen Oberfl√§che; </li><li>  MQTT-Client f√ºr die Interaktion mit der Cloud. </li></ol><br>  Die Bl√∂cke des Serverprozesses werden als separate Streams implementiert, deren Informationen in Form von Nachrichten im JSON-Format (oder Datenstrukturen, die dieses Format im Prozessspeicher darstellen) √ºbertragen werden. <br><br><img src="https://habrastorage.org/webt/vl/vm/md/vlvmmduxt7nsh-bjkpshrywrcqa.png"><br><br>  Die Hauptkomponente des Serverprozesses ist der <b>Nachrichtenmanager</b> , der Nachrichten im JSON-Format f√ºr alle Bl√∂cke des Serverprozesses weiterleitet.  Die Arten von JSON-Nachrichteninformationsfeldern und die Werte, die sie akzeptieren k√∂nnen, sind in der Tabelle aufgef√ºhrt: <br><br><div class="scrollable-table"><table><tbody><tr><th>  deviceType </th><th>  Protokoll </th><th>  messageType </th><th>  deviceState </th><th>  Befehl </th></tr><tr><td>  Kamera </td><td>  onvif </td><td>  sensorData </td><td>  auf </td><td>  Streaming (Ein / Aus) </td></tr><tr><td>  Sensor </td><td>  zwave </td><td>  Befehl </td><td>  aus </td><td>  Aufnahme (Ein / Aus) </td></tr><tr><td>  Effektor </td><td>  mqtt </td><td>  businessLogicRule </td><td>  Streaming (Ein / Aus) </td><td>  evice (Hinzuf√ºgen / Entfernen) </td></tr><tr><td></td><td>  Gesch√§ftslogik </td><td>  configurationData </td><td>  Aufnahme (Ein / Aus) </td><td></td></tr><tr><td></td><td>  Bluetooth </td><td>  deviceState </td><td>  Fehler </td><td></td></tr><tr><td></td><td>  WiFi </td><td></td><td></td><td></td></tr><tr><td></td><td>  rf </td><td></td><td></td><td></td></tr></tbody></table></div><br><br>  Eine Meldung von einem Kamerabewegungsdetektor sieht beispielsweise folgenderma√üen aus: <br><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"vendor"</span></span>: <span class="hljs-string"><span class="hljs-string">"*****"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"3.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"timestampMs"</span></span>: <span class="hljs-string"><span class="hljs-string">"1566293475475"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"clientType"</span></span>: <span class="hljs-string"><span class="hljs-string">"gateway"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"deviceId"</span></span>: <span class="hljs-string"><span class="hljs-string">"1616453d-30cd-44b7-9bf0-************"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"deviceType"</span></span>: <span class="hljs-string"><span class="hljs-string">"camera"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"protocol"</span></span>: <span class="hljs-string"><span class="hljs-string">"onvif"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"messageType"</span></span>: <span class="hljs-string"><span class="hljs-string">"sensorData"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sensorType"</span></span>: <span class="hljs-string"><span class="hljs-string">"camera"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"label"</span></span>: <span class="hljs-string"><span class="hljs-string">"motionDetector"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sensorData"</span></span>: <span class="hljs-string"><span class="hljs-string">"on"</span></span> }</code> </pre> <br><h1>  Produktionslogik </h1><br>  Um eine Nachricht vom Dispatcher zu empfangen oder zu senden, abonniert der Serverprozessblock Nachrichten eines bestimmten Typs.  Das Abonnement ist eine logische Produktionsregel vom Typ <i>"If ... then ..."</i> im JSON-Format und eine Verkn√ºpfung zum Nachrichtenhandler im Serverprozessblock.  Damit der IP-Kameraserver beispielsweise Befehle von der GUI und der Cloud empfangen kann, m√ºssen Sie die folgende Regel hinzuf√ºgen: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"if"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"and"</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">"equal"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"deviceId"</span></span>: <span class="hljs-string"><span class="hljs-string">"1616453d-30cd-44b7-9bf0-************"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"equal"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"messageType"</span></span>: <span class="hljs-string"><span class="hljs-string">"command"</span></span> } } ] }, <span class="hljs-attr"><span class="hljs-attr">"then"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"result"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> } }</code> </pre><br>  Wenn die im <b>Vorg√§nger</b> (linke Seite) der Regel angegebenen Bedingungen erf√ºllt sind, wird die <b>Regel</b> (rechte Seite) der Regel ausgef√ºhrt und der Handler erh√§lt Zugriff auf den Hauptteil der JSON-Nachricht.  Der Antezedenz unterst√ºtzt logische Operatoren, die einen Vergleich von JSON-Schl√ºssel-Wert-Paaren durchf√ºhren: <br><br><ol><li>  gleich "gleich"; </li><li>  ungleich "not_equal"; </li><li>  weniger "weniger"; </li><li>  mehr "gr√∂√üer"; </li><li>  kleiner oder gleich "less_or_equal"; </li><li>  gr√∂√üer oder gleich gr√∂√üer_oder_gleich. </li></ol><br>  Die Vergleichsergebnisse k√∂nnen mit den Operatoren der Booleschen Algebra miteinander verkn√ºpft werden: <br><br><ol><li>  Und "und"; </li><li>  ODER "oder"; </li><li>  NICHT "nicht". </li></ol><br>  Wenn Sie also Operatoren und Operanden in polnischer Notation schreiben, ist es m√∂glich, ziemlich komplexe Bedingungen mit einer gro√üen Anzahl von Parametern zu bilden. <br><br>  Genau derselbe Mechanismus, der auf JSON-Nachrichten und Produktionsregeln im JSON-Format basiert, wird im Produktionslogik-Serverblock verwendet, um Wissen darzustellen und mithilfe sensorischer Daten von Smart-Home-Sensoren logische Schlussfolgerungen zu ziehen. <br><br>  Mit einer mobilen Anwendung erstellt ein Benutzer Skripte, nach denen ein Smart Home funktionieren soll.  Zum Beispiel: <i>"Wenn der Sensor zum √ñffnen der Vordert√ºr funktioniert hat, schalten Sie das Licht im Flur ein</i> . <i>"</i>  Die Anwendung liest die Kennungen von Sensoren (√ñffnungssensor) und Aktoren (Smart Socket oder Smart Lamp) aus der Datenbank und generiert eine logische Regel im JSON-Format, die an den Smart Home Controller gesendet wird.  Dieser Mechanismus wird im dritten Artikel unserer Reihe ausf√ºhrlicher er√∂rtert, in dem wir √ºber eine Clientanwendung zur Verwaltung eines Smart Homes sprechen. <br><br>  Der oben beschriebene Produktionslogikmechanismus wird mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RapidJSON-</a> Bibliothek implementiert, einem SAX-Parser des JSON-Formats in C ++.  Das konsistente Lesen und Parsen einer Reihe von Produktionsregeln erleichtert die Implementierung der Datenabgleichsfunktion in Antezedenzien: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CRuleEngine::Process(PProperties pFact) { m_pActions-&gt;clear(); rapidjson::Reader reader; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(TStringMap::value_type&amp; rRule : m_Rules) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sRuleId = rRule.first; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sRuleBody = rRule.second; <span class="hljs-function"><span class="hljs-function">CRuleHandler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ruleHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pFact)</span></span></span></span>; rapidjson::<span class="hljs-function"><span class="hljs-function">StringStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ruleStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sRuleBody.c_str())</span></span></span></span>; rapidjson::ParseResult parseResult = reader.Parse(ruleStream, ruleHandler); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!parseResult) { m_Logger.LogMessage( NLogger2::ePriorityLevelError, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"JSON parse error"</span></span>), <span class="hljs-string"><span class="hljs-string">"CRuleEngine::Process()"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"RuleId: "</span></span>) + sRuleId); } PProperties pAction = ruleHandler.GetAction(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pAction) { pAction-&gt;Set(<span class="hljs-string"><span class="hljs-string">"ruleId"</span></span>, sRuleId); m_pActions-&gt;push_back(pAction); } } }</code> </pre><br>  Hier ist <b>pFact</b> eine Struktur, die Schl√ºssel-Wert-Paare aus einer JSON-Nachricht enth√§lt. <b>M_Rules</b> ist ein String-Array von Produktionsregeln.  Der Vergleich der eingehenden Nachricht und der Produktionsregel wird in der Funktion <b>reader.Parse (ruleStream, ruleHandler) durchgef√ºhrt</b> , wobei <b>ruleHandler</b> ein Objekt ist, das die Logik von Booleschen Operatoren und Vergleichsoperatoren enth√§lt.  <b>sRuleId</b> ist eine eindeutige <b>Regelkennung</b> , mit der Regeln in der Datenbank eines Smart-Home-Controllers gespeichert und bearbeitet werden k√∂nnen.  <b>m_pActions</b> - Ein Array mit den Ergebnissen logischer Inferenz: JSON-Nachrichten, die Konsistenzen aus der <b>Regelbasis</b> enthalten und an den Nachrichtenmanager weitergeleitet werden, damit Abonnentenstr√∂me sie verarbeiten k√∂nnen. <br><br>  Die Leistung von RapidJSON ist vergleichbar mit der Funktion <b>strlen ()</b> , und die minimalen Systemressourcenanforderungen erm√∂glichen die Verwendung dieser Bibliothek in eingebetteten Ger√§ten.  Durch die Verwendung von Nachrichten und logischen Regeln im JSON-Format k√∂nnen Sie ein flexibles System f√ºr den Informationsaustausch zwischen allen Komponenten des Smart Home-Controllers implementieren. <br><br><h2>  Sensoren und Aktoren Z-Wave </h2><br>  Der Hauptvorteil eines Smart Homes besteht darin, dass es verschiedene Umgebungsparameter unabh√§ngig messen und je nach Situation n√ºtzliche Funktionen ausf√ºhren kann.  Dazu werden Sensoren und Aktoren an den Smart Home Controller angeschlossen.  In der aktuellen Version handelt es sich um drahtlose Ger√§te, die nach dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Z-Wave-</a> Protokoll mit einer speziell f√ºr Russland zugewiesenen Frequenz von <b>869 MHz betrieben werden</b> .  F√ºr ihre Arbeit werden sie zu einem Mesh-Netzwerk zusammengefasst, in dem Signalverst√§rker vorhanden sind, um den Abdeckungsbereich zu vergr√∂√üern.  Die Ger√§te verf√ºgen au√üerdem √ºber einen speziellen Energiesparmodus - sie verbringen die meiste Zeit im Ruhemodus und senden nur dann Informationen, wenn sich ihr Status √§ndert, was die Lebensdauer der eingebauten Batterie erheblich verl√§ngern kann. <br><br><img src="https://habrastorage.org/webt/d8/ur/dp/d8urdpbsw6yxxxxqov8uj-hphzs.jpeg"><br><br>  Auf dem Markt finden Sie jetzt eine ziemlich gro√üe Anzahl verschiedener Z-Wave-Ger√§te.  Betrachten Sie als Beispiel einige: <br><br><ol><li>  Die Zipato PAN16 Smart-Buchse kann die folgenden Parameter messen: Stromverbrauch (kW / h), Leistung (W), Spannung (V) und Strom (A) im Netz.  Es hat auch einen eingebauten Schalter, mit dem Sie das angeschlossene Elektroger√§t steuern k√∂nnen; </li><li>  Der Neo Coolcam-Lecksensor erkennt das Vorhandensein von versch√ºtteter Fl√ºssigkeit, indem die Kontakte der entfernten Sonde geschlossen werden. </li><li>  Der Rauchmelder Zipato PH-PSG01 wird ausgel√∂st, wenn Rauchpartikel in die Gasanalysatorkammer gelangen. </li><li>  Der Bewegungssensor Neo Coolcam analysiert die Infrarotstrahlung des menschlichen K√∂rpers.  Zus√§tzlich gibt es einen Lichtsensor (Lx); </li><li>  Der Philio PST02-A Multisensor misst Temperatur (¬∞ C), Belichtung (%), T√ºr√∂ffnung und Anwesenheit einer Person im Raum. </li><li>  Z-Wave USB Stick ZME E UZB1 Netzwerkcontroller, an den die Sensoren angeschlossen sind. </li></ol><br>  Es ist sehr wichtig, dass die Ger√§te und die Steuerung mit derselben Frequenz arbeiten, da sie sich sonst zum Zeitpunkt der Verbindung einfach nicht sehen.  Bis zu 232 Ger√§te k√∂nnen an einen Z-Wave-Netzwerkcontroller angeschlossen werden, was f√ºr eine Wohnung oder ein Landhaus v√∂llig ausreicht.  Um den Versorgungsbereich des Netzwerks in Innenr√§umen zu erweitern, kann ein Smart Socket als Signalverst√§rker verwendet werden. <br><br><img src="https://habrastorage.org/webt/o_/q2/oa/o_q2oa4n9w7hpqzr2vihyois9he.png"><br><br>  Im Serverprozess des Smart-Home-Controllers, der im vorherigen Abschnitt erl√§utert wurde, ist der Z-Wave-Server f√ºr die Interaktion mit Z-Wave-Ger√§ten verantwortlich.  Um Informationen von Sensoren zu erhalten, verwendet er die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenZWave-</a> Bibliothek in C ++, die eine Schnittstelle f√ºr die Interaktion mit einem USB-Controller des Z-Wave-Netzwerks bietet und mit vielen Sensoren und Aktoren zusammenarbeitet.  Der vom Sensor gemessene Wert des Umgebungsparameters wird vom Z-Wave-Server in Form einer JSON-Nachricht aufgezeichnet: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"vendor"</span></span>: <span class="hljs-string"><span class="hljs-string">"*****"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"3.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"timestampMs"</span></span>: <span class="hljs-string"><span class="hljs-string">"1566479791290"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"clientType"</span></span>: <span class="hljs-string"><span class="hljs-string">"gateway"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"deviceId"</span></span>: <span class="hljs-string"><span class="hljs-string">"20873eb0-dd5e-4213-a175-************"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"deviceType"</span></span>: <span class="hljs-string"><span class="hljs-string">"sensor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"protocol"</span></span>: <span class="hljs-string"><span class="hljs-string">"zwave"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"messageType"</span></span>: <span class="hljs-string"><span class="hljs-string">"sensorData"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"homeId"</span></span>: <span class="hljs-string"><span class="hljs-string">"0xefa0cfa7"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"nodeId"</span></span>: <span class="hljs-string"><span class="hljs-string">"20"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sensorType"</span></span>: <span class="hljs-string"><span class="hljs-string">"METER"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"label"</span></span>: <span class="hljs-string"><span class="hljs-string">"Voltage"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sensorData"</span></span>: <span class="hljs-string"><span class="hljs-string">"229.3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"units"</span></span>: <span class="hljs-string"><span class="hljs-string">"V"</span></span> }</code> </pre><br>  Es wird dann an den Server Process Message Manager weitergeleitet, damit Abonnententhreads es empfangen k√∂nnen.  Der Hauptteilnehmer ist der Produktionslogikserver, der die Werte von Nachrichtenfeldern in den Antezedenzen logischer Regeln vergleicht.  Die Ergebnisse der logischen Ausgabe mit Steuerbefehlen werden an den Nachrichtenmanager zur√ºckgesendet und von dort an den Z-Wave-Server weitergeleitet, der sie dekodiert und an den USB-Controller des Z-Wave-Netzwerks sendet.  Dann fallen sie in das Executive-Ger√§t, das den Zustand der Umgebung ver√§ndert, und das Smart Home leistet somit n√ºtzliche Arbeit. <br><br> <a href=""><img src="https://habrastorage.org/webt/_s/1m/wk/_s1mwk6ysdi5l9ynhtawcbaolfg.png"></a> <br>  <font color="grey">(Klicken Sie auf das Bild, um es in h√∂herer Aufl√∂sung zu √∂ffnen.)</font> <br><br>  Z-Wave-Ger√§te werden √ºber die grafische Oberfl√§che des Smart-Home-Controllers angeschlossen.  Gehen Sie dazu zur Seite mit der Liste der Ger√§te und klicken Sie auf die Schaltfl√§che "Hinzuf√ºgen".  Der Befehl add √ºber die RESTful-API gelangt in den Serverprozess und wird dann vom Nachrichtenmanager an den Z-Wave-Server gesendet, wodurch der Z-Wave-USB-Controller in den speziellen Ger√§temodus versetzt wird.  Als n√§chstes m√ºssen Sie auf dem Z-Wave-Ger√§t eine Reihe von schnellen Dr√ºcken (3 Dr√ºcken innerhalb von 1,5 Sekunden) auf die Servicetaste ausf√ºhren.  Ein USB-Controller verbindet das Ger√§t mit dem Netzwerk und sendet Informationen dar√ºber an den Z-Wave-Server.  Dadurch wird wiederum ein neuer Datensatz in der SQLite-Datenbank mit den Parametern des neuen Ger√§ts erstellt.  Nach einem vorgegebenen Zeitintervall kehrt die grafische Oberfl√§che zur Seite der Liste der Z-Wave-Ger√§te zur√ºck, liest Informationen aus der Datenbank und zeigt das neue Ger√§t in der Liste an.  Gleichzeitig erh√§lt jedes Ger√§t eine eigene eindeutige Kennung, die in den Regeln f√ºr Produktionsinferenzen und bei der Arbeit in der Cloud verwendet wird.  Die Funktionsweise dieses Algorithmus ist im UML-Diagramm dargestellt: <br><br> <a href=""><img src="https://habrastorage.org/webt/np/01/lc/np01lc-tc4xbqzxccv18tfuxuz4.png"></a> <br>  <font color="grey">(Klicken Sie auf das Bild, um es in h√∂herer Aufl√∂sung zu √∂ffnen.)</font> <br><br><h2>  IP-Kamera-Verbindung </h2><br>  Das in diesem Artikel behandelte Cloud-Smart-Home-System ist eine Modernisierung des ebenfalls vom Autor entwickelten Cloud-Video√ºberwachungssystems, das seit mehreren Jahren auf dem Markt ist und viele Installationen in Russland hat. <br><br>  Bei Cloud-Video√ºberwachungssystemen ist eines der akuten Probleme die begrenzte Auswahl an Ger√§ten, mit denen eine Integration m√∂glich ist.  Die f√ºr die Verbindung zur Cloud verantwortliche Software ist im Camcorder installiert, was sofort ernsthafte Anforderungen an die Hardware stellt - den Prozessor und die Menge an freiem Speicher.  Dies erkl√§rt haupts√§chlich den h√∂heren Preis f√ºr Cloud-basierte Video√ºberwachungskameras im Vergleich zu herk√∂mmlichen IP-Kameras.  Dar√ºber hinaus ist eine lange Verhandlungsphase mit Herstellern von CCTV-Kameras erforderlich, um Zugriff auf das Kameradateisystem und alle erforderlichen Entwicklungstools zu erhalten. <br><br><img src="https://habrastorage.org/webt/zx/c-/sq/zxc-sqnecsbismwgwmztyclcg9k.jpeg"><br><br>  Andererseits verf√ºgen alle modernen IP-Kameras √ºber Standardprotokolle f√ºr die Interaktion mit anderen Ger√§ten (insbesondere DVRs).  Die Verwendung eines separaten Controllers, der √ºber das Standardprotokoll eine Verbindung herstellt und Videostreams von IP-Kameras in die Cloud √ºbertr√§gt, bietet daher erhebliche Wettbewerbsvorteile f√ºr Cloud-Video√ºberwachungssysteme.  Wenn der Client bereits ein Video√ºberwachungssystem installiert hat, das auf einfachen IP-Kameras basiert, kann es erweitert und in ein vollwertiges, bew√∂lktes Smart Home verwandelt werden. <br><br>  Das beliebteste Protokoll f√ºr IP-Video√ºberwachungssysteme, das jetzt ausnahmslos von allen Herstellern von IP-Kameras unterst√ºtzt wird, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ONVIF Profile S</a> , dessen Spezifikationen in der Beschreibungssprache der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WSDL-</a> Webdienste vorhanden sind.  Mithilfe von Dienstprogrammen aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gSOAP-</a> Toolkit kann der Quellcode von Diensten generiert werden, die mit IP-Kameras arbeiten: <br><br><pre> <code class="bash hljs">$ wsdl2h -o onvif.h \ https://www.onvif.org/ver10/device/wsdl/devicemgmt.wsdl \ https://www.onvif.org/ver10/events/wsdl/event.wsdl \ https://www.onvif.org/ver10/media/wsdl/media.wsdl \ https://www.onvif.org/ver20/ptz/wsdl/ptz.wsdl $ soapcpp2 -Cwvbj -c++11 -d cpp_files/onvif -i onvif.h</code> </pre><br>  Als Ergebnis erhalten wir eine Reihe von Header- "* .h" - und Quelldateien "* .cpp" in C ++, die direkt in einer Anwendung oder einer separaten Bibliothek abgelegt und mit dem GCC-Compiler kompiliert werden k√∂nnen.  Aufgrund der vielen Funktionen ist der Code gro√ü und erfordert zus√§tzliche Optimierung.  Der Mikrocomputer Raspberry Pi 3 Modell B + verf√ºgt √ºber eine ausreichende Leistung, um diesen Code auszuf√ºhren. Wenn der Code jedoch auf eine andere Plattform portiert werden muss, m√ºssen die Prozessorarchitektur und die Systemressourcen korrekt ausgew√§hlt werden. <br><br>  IP-Kameras, die den ONVIF-Standard unterst√ºtzen, werden in einem lokalen Netzwerk mit einer speziellen Multicast-Gruppe mit der Adresse <b>239.255.255.250 verbunden</b> .  Es gibt ein Protokoll <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WS-Discovery</a> , mit dem Sie die Suche nach Ger√§ten im lokalen Netzwerk automatisieren k√∂nnen. <br><br>  Die Smart-Oberfl√§che des Smart-Home-Controllers implementiert die Suchfunktion f√ºr IP-Kameras in der PHP-Sprache, was bei der Interaktion mit Webdiensten √ºber XML-Nachrichten sehr praktisch ist.  Wenn Sie die Men√ºpunkte <i>Ger√§te&gt; IP-Kameras&gt; Scannen</i> ausw√§hlen, wird der Suchalgorithmus f√ºr IP-Kameras gestartet und das Ergebnis in einer Tabelle angezeigt: <br><br> <a href=""><img src="https://habrastorage.org/webt/ew/xk/m6/ewxkm6g2tl7-2nqvjeyzfed8ees.png"></a> <br>  <font color="grey">(Klicken Sie auf das Bild, um es in h√∂herer Aufl√∂sung zu √∂ffnen.)</font> <br><br>  Wenn Sie dem Controller eine Kamera hinzuf√ºgen, k√∂nnen Sie die Einstellungen festlegen, nach denen sie mit der Cloud interagieren soll.  Auch in dieser Phase wird ihm automatisch eine eindeutige Ger√§tekennung zugewiesen, anhand derer er in Zukunft in der Cloud leicht identifiziert werden kann. <br><br><img src="https://habrastorage.org/webt/jp/uq/al/jpuqalxe9cryxzzg2dpynptjjmy.png"><br><br>  Als N√§chstes wird eine Nachricht im JSON-Format generiert, die alle Parameter der hinzugef√ºgten Kamera enth√§lt, und √ºber den Befehl RESTful API an den Serverprozess des Smart Home-Controllers gesendet. Dort werden die Kameraparameter dekodiert und in der internen SQLite-Datenbank gespeichert. Au√üerdem werden die folgenden Verarbeitungsthreads gestartet: <br><br><ol><li>  Herstellen einer RTSP-Verbindung zum Empfangen von Video- und Audiostreams; </li><li>  Transcodieren von Audio aus den Formaten G.711 mu-Law, G.711 A-Law, G.723 usw.  zum AAC-Format; </li><li>  Transcodieren von H.264-Video- und AAC-Audio-Streams in den FLV-Container und √úbertragen in die Cloud mithilfe von RTMP; </li><li>  Herstellen einer Verbindung mit dem Endpunkt des IP-Kamera-Bewegungsmelders √ºber das ONVIF-Protokoll und dessen periodisches Abrufen; </li><li>  periodisches Generieren eines Miniaturbild-Vorschaubilds und Senden an die Cloud unter Verwendung des MQTT-Protokolls; </li><li>  Lokale Aufzeichnung von Video- und Audiostreams in Form separater Dateien im MP4-Format auf einer SD- oder Flash-Karte eines Smart-Home-Controllers. </li></ol><br><img src="https://habrastorage.org/webt/4m/yc/yb/4mycybe00ye3dxglny-fcgsohua.png"><br><br>  Um eine Verbindung mit Kameras herzustellen, Videostreams im Serverprozess zu transkodieren, zu verarbeiten und aufzuzeichnen, werden Funktionen aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FFmpeg</a> 4.1.0-Bibliothek verwendet. <br><br>  Im Leistungstest wurden 3 Kameras an die Steuerung angeschlossen: <br><br><ol><li>  HiWatch DS-I114W (Aufl√∂sung - 720p, Komprimierungsformat - H.264, Bitrate - 1 Mb / s, Ton G.711 mu-Law); </li><li>  Mikrodigitales MDC-M6290FTD-1 (Aufl√∂sung - 1080p, Komprimierungsformat - H.264, Bitrate - 1 Mb / s, ohne Ton); </li><li>  Dahua DH-IPC-HDW4231EMP-AS-0360B (Aufl√∂sung - 1080p, Komprimierungsformat - H.264, Bitrate - 1,5 Mb / s, AAC-Sound). </li></ol><br><img src="https://habrastorage.org/webt/h2/dv/mk/h2dvmkujuqu4sdp6daccgdimnre.png"><br><br>  Alle drei Streams wurden gleichzeitig in die Cloud ausgegeben, die Tontranscodierung wurde nur von einer Kamera durchgef√ºhrt, die Aufzeichnung des lokalen Archivs wurde deaktiviert.  Die CPU-Auslastung betrug ca. 5%, die RAM-Auslastung 32 MB (pro Prozess) und 56 MB (insgesamt mit Betriebssystem). <br><br>  Somit k√∂nnen ungef√§hr 20 bis 30 Kameras (abh√§ngig von Aufl√∂sung und Bitrate) an den Smart-Home-Controller angeschlossen werden, was f√ºr ein Video√ºberwachungssystem eines dreist√∂ckigen H√§uschens oder eines kleinen Lagers ausreicht.  Bei Aufgaben, bei denen eine hohe Leistung erforderlich ist, k√∂nnen Sie einen Nettop mit einem Intel Multi-Core-Prozessor und Linux Debian Sarge OS verwenden.  Derzeit befindet sich der Controller im Testbetrieb, und die Daten zu seiner Leistung werden aktualisiert. <br><br><h2>  Cloud-Interaktion </h2><br>  Cloud Smart Home speichert Benutzerdaten (Video- und Sensormessungen) in der Cloud.  Die Cloud-Speicherarchitektur wird im n√§chsten Artikel unserer Reihe ausf√ºhrlicher erl√§utert.  Lassen Sie uns nun √ºber die Schnittstelle zum √úbertragen von Informationsnachrichten vom Smart Home-Controller in die Cloud sprechen. <br><br>  Die Zust√§nde angeschlossener Ger√§te und Sensormessungen werden mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MQTT-</a> Protokolls √ºbertragen, das aufgrund seiner Einfachheit und Energieeffizienz h√§ufig in IoT-Projekten verwendet wird.  MQTT verwendet ein Client-Server-Modell, wenn Clients bestimmte Themen im Broker abonnieren und ihre Nachrichten ver√∂ffentlichen.  Der Broker sendet Nachrichten an alle Abonnenten gem√§√ü den durch die QoS-Stufe (Quality of Service) festgelegten Regeln: <br><br><ul><li>  QoS 0 - h√∂chstens einmal (keine Liefergarantie); </li><li>  QoS 1 - mindestens einmal (mit Lieferbest√§tigung); </li><li>  QoS 2 - genau einmal (mit zus√§tzlicher Lieferbest√§tigung). </li></ul><br>  In unserem Fall wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eclipse Mosquitto</a> als MQTT-Broker verwendet.  Der Name des Themas ist die eindeutige Kennung des Smart-Home-Controllers.  Der MQTT-Client im Serverprozess abonniert dieses Thema und √ºbersetzt JSON-Nachrichten, die vom Nachrichtenmanager kommen, in dieses Thema.  Umgekehrt werden Nachrichten vom MQTT-Broker im Nachrichtenmanager an diese gesendet, der sie dann innerhalb des Serverprozesses an seine Abonnenten multiplext: <br><br><img src="https://habrastorage.org/webt/zx/ao/ea/zxaoeaqetsr7odlbfsx2xtn35fy.png"><br><br>  Um Nachrichten √ºber den Status des Smart-Home-Controllers zu √ºbertragen, wird der Mechanismus der gespeicherten Nachrichten verwendet, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bei denen Nachrichten des</a> MQTT-Protokolls gespeichert werden.  Auf diese Weise k√∂nnen Sie die Momente der Wiederverbindung bei Stromausfall korrekt √ºberwachen. <br><br>  Der MQTT-Client wurde basierend auf der Implementierung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eclipse Paho-</a> Bibliothek in C ++ entwickelt. <br><br>  H.264 + AAC-Medienstr√∂me werden mithilfe des RTMP-Protokolls an die Cloud gesendet, wobei ein Cluster von Medienservern f√ºr deren Verarbeitung und Speicherung verantwortlich ist.  Um die Last im Cluster optimal zu verteilen und den am wenigsten belasteten Medienserver auszuw√§hlen, sendet der Smart Home-Controller eine vorl√§ufige Anforderung an den Cloud Load Balancer und sendet erst dann den Medienstrom. <br><br><h1>  Fazit </h1><br>  Der Artikel untersuchte eine spezifische Implementierung eines Smart-Home-Controllers auf Basis des Raspberry Pi 3 B + -Mikrocomputers, der mithilfe des Z-Wave-Protokolls Informationen empfangen, verarbeiten und Ger√§te verwalten, mithilfe des ONVIF-Protokolls mit IP-Kameras interagieren sowie Daten und Befehle mit der Cloud austauschen kann MQTT- und RTMP-Protokolldienst.  Basierend auf einem Vergleich von logischen Regeln und Fakten im JSON-Format wurde eine Produktionslogik-Engine entwickelt. <br><br>  Jetzt wird der Smart-Home-Controller in mehreren Einrichtungen in Moskau und der Region Moskau getestet. <br><br>  In der n√§chsten Version des Controllers ist geplant, Ger√§te anderer Typen (RF, Bluetooth, WiFi, Kabel) anzuschlie√üen.  Zur Vereinfachung der Benutzer wird das Verfahren zum Anschlie√üen von Sensoren und IP-Kameras auf die mobile Anwendung √ºbertragen.  Es gibt auch Ideen zur Optimierung des Server-Prozesscodes und zur Portierung der Software auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenWrt-</a> Betriebssystem.  Dies spart auf einem separaten Controller und √ºbertr√§gt die Funktionalit√§t eines Smart Homes auf einen normalen Haushaltsrouter. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467219/">https://habr.com/ru/post/de467219/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467203/index.html">Nur Teilung oder wie man eine mathematische Theorie erstellt und 400.000 Dollar damit verdient. Serie zwei, vorletzte</a></li>
<li><a href="../de467205/index.html">Wir entwickeln eine Anwendung, die Daten an andere Anwendungen sendet (√ñkosystemanwendung)</a></li>
<li><a href="../de467207/index.html">F√ºnf vielversprechende Programmiersprachen mit einer gl√§nzenden Zukunft (3 Jahre sp√§ter)</a></li>
<li><a href="../de467209/index.html">"Autonome Agenten" oder Code in der offenen Kryptoplattform Obyte ausf√ºhren</a></li>
<li><a href="../de467215/index.html">22 Computermuseen: Ein Leitfaden f√ºr Ingenieure, die in Europa reisen</a></li>
<li><a href="../de467223/index.html">Willkommen beim JavaScript Meetup SuperJob am 10. Oktober</a></li>
<li><a href="../de467227/index.html">So √∂ffnen Sie ein npm-Paket mit einer normalen Bereitstellung, CI und Demo (ohne Verlust der Lebensfreude)</a></li>
<li><a href="../de467231/index.html">Einf√ºhrung Melden Sie sich mit Apple in Ihrer iOS-App an</a></li>
<li><a href="../de467237/index.html">Erh√∂hen Sie Ihren DNS-over-HTTPS-Server</a></li>
<li><a href="../de467239/index.html">Der Unterschied zwischen Data Scientist und einem Teenager in einem Sportwagen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>