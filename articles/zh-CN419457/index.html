<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‼️ 👵🏾 🤞🏻 RabbitMQ-SQL Server 👩🏽‍🤝‍👩🏻 👒 👨🏿‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="一两个星期前，我在RabbitMQ用户论坛上看到一条消息 ，内容涉及如何设置从SQL Server向RabbitMQ发送消息。 由于我们与Derivco紧密合作， 因此我在此留下了一些建议，并说我正在撰写有关如何执行此操作的博客。 我的部分信息并不完全正确-至少到那时为止（对不起，兄弟，他很忙）。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ-SQL Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419457/"> 一两个星期前，我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RabbitMQ用户</a>论坛上看到一条<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">消息</a> ，内容涉及如何设置从SQL Server向RabbitMQ发送消息。 由于我们与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Derivco</a>紧密合作， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">因此</a>我在此留下了一些建议，并说我正在撰写有关如何执行此操作的博客。 我的部分信息并不完全正确-至少到那时为止（对不起，兄弟，他很忙）。 <br><br> 太棒了，这是您的<b>SQL Server</b> 。 使用它很容易将信息放入数据库中。 使用查询从数据库检索数据同样容易。 但是获取刚刚更新或粘贴的数据已经有点困难了。 考虑一下实时事件； 进行了购买-发生这种情况时，必须立即通知有人。 也许有人会说这样的数据不应该从数据库中弹出，而应该从其他地方弹出。 当然是这种情况，但是很多时候我们根本别无选择。 <br><a name="habracut"></a><br> 我们有一个任务：从数据库外部发送事件以进行进一步处理，问题是-如何做到这一点？ <br><br><h3>  SQL Server与外部通讯 </h3><br> 在存在SQL Server的过程中，曾进行过几次尝试来组织数据库外部的通信。  <b>SQL Server通知服务</b> （NS），出现在SQL Server 2000中，以及更高版本，出现在SQL Server 2005中，出现了<b>SQL Server Service Broker</b> （SSB）。 我与Bob Boshemen和Dan Sullivan一起在我的《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">面向开发人员的SQL Server 2005初看</a> 》 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一</a>书中对它们进行了描述。 正如我所说，NS出现在SQL Server 2000中，并在SQL Server 2005的Beta版中进行了重新设计。但是，NS已<s>完全</s>排除在SQL Server 2005的现成（RTM）版本中。 <br><blockquote>  <b>注意：</b>如果您阅读本书，将会发现RTM版本中没有的许多功能。 </blockquote>  SSB幸存下来，Microsoft在其SQL Server 2008 Feature Pack中引入了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Service Broker外部激活器</a> （EA）。 通过SSB，可以在本地数据库之外进行交互。 从理论上讲，这听起来不错，但实际上-它既麻烦又令人困惑。 我们进行了一些测试，很快意识到它没有满足我们的要求。 此外，SSB并没有为我们提供所需的性能，因此我们不得不发明其他东西。 <br><br><h3>  SQLCLR </h3><br> 结果，我们得出的结论是基于SQLCLR技术的。  SQLCLR是内置在SQL Server核心中的.NET平台，可用于在内核内部执行.NET代码。 由于我们执行.NET代码，因此我们能够像常规.NET应用程序一样执行几乎所有操作。 <br><blockquote>  <b>注意：</b>我在上面写了“几乎”，因为实际上有一些限制。 在这种情况下，这些限制几乎不会影响我们要做的事情。 <br></blockquote>  SQLCLR的操作原理如下：将代码编译到dll库中，然后使用SQL Server工具注册该库： <br><br> 构建装配 <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASSEMBLY</span></span> [RabbitMQ.SqlServer] AUTHORIZATION rmq <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">'F:\some_path\RabbitMQSqlClr4.dll'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> PERMISSION_SET = <span class="hljs-keyword"><span class="hljs-keyword">UNSAFE</span></span>; GO</code> </pre> <br>  <b>代码段1：</b>沿绝对路径创建程序集 <br><br> 该代码执行以下操作： <br><br><ul><li>  <code>CREATE ASSEMBLY</code>创建具有给定名称的程序集（无论其名称如何）。 </li><li>  <code>AUTHORIZATION</code> -指示程序集的所有者。 在这种情况下，rmq是预定义的SQL Server角色。 </li><li>  <code>FROM</code>确定原始装配体的位置。 在<code>FROM</code> ，您还可以以二进制或UNC格式指定路径。 该项目的安装文件使用二进制表示形式。 </li><li>  <code>WITH PERMISSION_SET</code>设置权限。 在这种情况下， <code>UNSAFE</code>要求最严格。 </li></ul><br><blockquote>  <b>注意：</b>无论在<code>AUTHORIZATION</code>子句中使用什么角色或登录名，都必须使用与将程序集加载到域中时相同的名称来创建appdomain类。 建议使用不同的appdomain类名称来分隔程序集，以便在一个程序集失败时，其余程序集不会掉线。 但是，如果程序集相互依赖，则不能将它们划分为不同的类。 <br></blockquote> 创建程序集后，我们在其中封装.NET方法： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> rmq.pr_clr_PostRabbitMsg @EndpointID <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, @Message <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">max</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> [RabbitMQ.SqlServer].[RabbitMQSqlClr.RabbitMQSqlServer].[pr_clr_PostRabbitMsg]; GO</code> </pre><br>  <b>代码段2：</b> .NET方法包装器 <br><br> 该代码执行以下操作： <br><br><ul><li> 创建一个名为<code>rmq.pr_clr_PostRabbitMsg</code>的T-SQL存储过程，该存储过程具有两个参数。  <code>@EndpointID</code>和<code>@Message</code> 。 </li><li> 代替该过程的主体，而是使用一个外部源，该外部源包括： <br><ul><li> 一个名为<code>RabbitMQ.SqlServer</code>的程序集，即我们在上面的<b>代码片段1中</b>创建的集合。 </li><li> 完整类型（命名空间和类）： <code>RabbitMQSqlClr.RabbitMQSqlServer</code> </li><li> 上面的名称空间和类中的方法是： <code>pr_clr_PostRabbitMsg</code> 。 </li></ul></li></ul><br>  <code>rmq.pr_clr_PostRabbitMsg</code> <code>pr_clr_PostRabbitMsg</code>将调用<code>pr_clr_PostRabbitMsg</code>方法。 <br><blockquote>  <b>注意：</b>创建过程时，程序集名称不区分大小写，这与类型和方法的全名不同。 创建的过程的名称不必与方法的名称匹配。 但是，参数的最终数据类型必须匹配。 </blockquote> 就像我之前说的，我们在Derivco需要将数据发送到SQL Server之外，因此我们使用SQLCLR和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RabbitMQ</a> （RMQ）。 <br><br><h3>  Rabbitmq </h3><br>  RMQ是一个开源消息代理，它实现高级消息队列协议（AMQP）并用Erlang编写。 <br><br> 由于RMQ是消息代理，因此需要AMQP客户端库才能连接到它。 该应用程序引用客户端库，并在其帮助下打开连接并发送消息-例如，通过ADO.NET调用SQL Server。 但是与ADO.NET不同的是，每次访问数据库时，该连接很可能会打开，而在整个应用程序期间，该连接仍保持打开状态。 <br><br> 因此，为了能够与RabbitMQ从数据库进行交互，我们需要RabbitMQ的应用程序和.NET客户端库。 <br><blockquote>  <b>注意：</b>在本文的下一部分中，将找到RabbitMQ代码片段，但没有详细说明它们的作用。 如果您不熟悉RabbitMQ，那么建议您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">阅读</a>各种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RabbitMQ教程，</a>以了解代码的用途。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hello World</a> C＃教程是一个好的开始。 教科书和代码示例之间的区别之一是示例中未声明交换器。 它们应该是预定义的。 </blockquote><h3>  RabbitMQ.SqlServer </h3><br>  <b>RabbitMQ.SqlServer</b>是使用.NET客户端库用于RabbitMQ的程序集，并提供了将消息从数据库发送到一个或多个RabbitMQ端点（VHost和交换器）的功能。 可以从我在GitHub上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RabbitMQ-SqlServer</a>存储库下载/分叉代码。 它包含程序集源代码和安装文件（即，您不必自己编译它们）。 <br><blockquote>  <b>注意：</b>这只是一个示例，显示SQL Server如何与RabbitMQ进行交互。 这不是成品，甚至不是一部分。 如果此代码使您不知所措-不要怪我，因为这只是一个例子。 <br></blockquote><h3> 功能性 </h3><br> 当程序集被加载时，或其显式调用被初始化时，或在包装程序被调用时被间接调用时，该程序集将连接字符串加载到其安装所在的本地数据库中，以及与其连接的RabbitMQ端点： <br><br> 连接方式 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InternalConnect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { connFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConnectionFactory(); connFactory.Uri = connString; connFactory.AutomaticRecoveryEnabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; connFactory.TopologyRecoveryEnabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; RabbitConn = connFactory.CreateConnection(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; channels; x++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ch = RabbitConn.CreateModel(); rabbitChannels.Push(ch); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception ex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  <b>代码段3：</b>连接到端点 <br><br> 同时，到端点的部分连接也会在该连接上创建IModel，并在发送（添加到队列）消息时使用它们： <br><br> 讯息发送 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> exchange, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] msg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topic</span></span></span><span class="hljs-function">)</span></span> { IModel <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> channelTryCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((!rabbitChannels.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) &amp;&amp; channelTryCount &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) { channelTryCount += <span class="hljs-number"><span class="hljs-number">1</span></span>; Thread.Sleep(<span class="hljs-number"><span class="hljs-number">50</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (channelTryCount == <span class="hljs-number"><span class="hljs-number">100</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> errMsg = <span class="hljs-string"><span class="hljs-string">$"Channel pool blocked when trying to post message to Exchange: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{exchange}</span></span></span><span class="hljs-string">."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationException(errMsg); } <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.BasicPublish(exchange, topic, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, msg); rabbitChannels.Push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _rabbitChannels.Push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre> <br>  <code>Post</code>方法是从<code>pr_clr_PostRabbitMsg(int endPointId, string msgToPost)</code>方法<code>pr_clr_PostRabbitMsg(int endPointId, string msgToPost)</code>调用的，该方法是使用代码片段2中的<code>CREATE PROCEDURE</code>子句作为过程呈现的： <br><br> 邮寄方式 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pr_clr_PostRabbitMsg</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endPointId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msgToPost</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(endPointId == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationException(<span class="hljs-string"><span class="hljs-string">"EndpointId cannot be 0"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isInitialised) { pr_clr_InitialiseRabbitMq(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> msg = Encoding.UTF8.GetBytes(msgToPost); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endPointId == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rep <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> remoteEndpoints) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exch = rep.Value.Exchange; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> topic = rep.Value.RoutingKey; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pub <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rabbitPublishers.Values) { pub.Post(exch, msg, topic); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { RabbitPublisher pub; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rabbitPublishers.TryGetValue(endPointId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> pub)) { pub.Post(remoteEndpoints[endPointId].Exchange, msg, remoteEndpoints[endPointId].RoutingKey); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationException(<span class="hljs-string"><span class="hljs-string">$"EndpointId: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{endPointId}</span></span></span><span class="hljs-string">, does not exist"</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre> <br>  <b>代码段5：</b>将方法表示为过程 <br><br> 当执行该方法时，假定调用方发送了必须将消息发送到的端点的标识符，实际上是消息本身。 如果将值-1作为端点的标识符传递，则我们遍历所有点，并向每个点发送一条消息。 消息以字符串的形式出现，我们可以使用<code>Encoding.UTF8.GetBytes</code>从中获取字节。 在生产环境中，应将<code>Encoding.UTF8.GetBytes</code>调用替换为序列化。 <br><br><h3> 安装方式 </h3><br> 要安装和运行该示例，您需要<code>src\SQL</code>文件夹中的所有文件。 要安装，请按照下列步骤操作： <br><br><ul><li> 运行脚本<code>01.create_database_and_role.sql</code> 。 他将创建： <br><ul><li>  <code>RabbitMQTest</code>测试数据库，将在其中创建程序集。 </li><li>  <code>rmq</code>角色被分配为程序集所有者 </li><li> 方案，也称为<code>rmq</code> 。 在此图中，创建了各种数据库对象。 <br></li></ul><br></li><li> 运行<code>02.create_database_objects.sql</code>文件。 他将创建： <br><br><ul><li>  <code>rmq.tb_RabbitSetting</code>表，该表会将连接字符串存储到本地数据库。 </li><li>  <code>rmq.tb_RabbitEndpoint</code>表，将在其中存储一个或多个<code>RabbitMQ</code>端点。 </li></ul><br></li><li> 在<code>03.create_localhost_connstring.sql</code>文件中<code>03.create_localhost_connstring.sql</code>将<code>@connString</code>变量的值更改为步骤1中创建的<code>RabbitMQTest</code>数据库的正确连接字符串，然后运行脚本。 <br></li></ul><br> 在继续之前，您必须具有RabbitMQ代理和VHost的运行实例（默认情况下，VHost表示为/）。 通常，我们有几个用于隔离的VHost。 该主机还需要一个交换器，在示例中，我们使用<code>amq.topic</code> 。 准备好RabbitMQ代理后，编辑<code>rmq.pr_UpsertRabbitEndpoint</code>过程<code>rmq.pr_UpsertRabbitEndpoint</code> ，该<code>rmq.pr_UpsertRabbitEndpoint</code>位于<code>04.upsert_rabbit_endpoint.sql</code>文件中： <br><br> 端点RabbitMQ <br><br><pre> <code class="cs hljs">EXEC rmq.pr_UpsertRabbitEndpoint @Alias = <span class="hljs-string"><span class="hljs-string">'rabbitEp1'</span></span>, @ServerName = <span class="hljs-string"><span class="hljs-string">'RabbitServer'</span></span>, @Port = <span class="hljs-number"><span class="hljs-number">5672</span></span>, @VHost = <span class="hljs-string"><span class="hljs-string">'testHost'</span></span>, @LoginName = <span class="hljs-string"><span class="hljs-string">'rabbitAdmin'</span></span>, @LoginPassword = <span class="hljs-string"><span class="hljs-string">'some_secret_password'</span></span>, @Exchange = <span class="hljs-string"><span class="hljs-string">'amq.topic'</span></span>, @RoutingKey = <span class="hljs-string"><span class="hljs-string">'#'</span></span>, @ConnectionChannels = <span class="hljs-number"><span class="hljs-number">5</span></span>, @IsEnabled = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  <b>代码段6：</b>在RabbitMQ中创建端点 <br><br> 此时，该部署程序集了。 对于SQL Server 2014之前的版本（2005、2008、2008R2、2012）和2014及更高版本，SQL Server的部署选项有所不同。 区别在于受支持的CLR版本。 在SQL Server 2014之前，.NET平台在CLR版本2中运行，在SQL Server 2014及更高版本中，使用版本4。 <br><br><h3>  SQL Server 2005年-2012年 </h3><br> 让我们从运行在CLR 2上的SQL Server版本开始，因为它们具有自己的特征。 我们需要部署创建的程序集，同时部署RabbitMQ客户端.NET库（ <code>RabbitMQ.Client</code> ）。 从我们的程序集中，我们将引用RabbitMQ客户端库。 因为 由于我们计划使用CLR 2，因此我们的程序集和<code>RabbitMQ.Client</code>应该基于.NET 3.5进行编译。 有问题。 <br><br>  <code>RabbitMQ.Client</code>库的所有最新版本都是为CLR 4环境编译的，因此不能在我们的程序集中使用。  .NET 3.4.3上编译了CLR 2客户端库的最新版本。 但是，即使我们尝试部署此程序集，也会收到错误消息： <br><br><img src="https://habrastorage.org/webt/db/yo/uj/dbyouj4az0fzhnwpkvtdkgj6i-q.png"><br>  <i><b>图1：</b>缺少System.ServiceModel程序集</i> <br><br> 此版本的<code>RabbitMQ.Client</code>引用的组件不属于SQL Server CLR。 这是WCF程序集，这是我上面提到的SQLCLR的局限性之一：此特定程序集用于不允许在SQL Server中执行的任务类型。  <code>RabbitMQ.Client</code>最新版本不具有这些依赖关系，因此可以使用它们，而CLR 4的烦人要求除外。我该怎么办？ <br><br> 如您所知，RabbitMQ是开源的，但是我们是开发人员，对吗？  ;）让我们重新编译！ 在<code>RabbitMQ.Client</code>的最新发行版（即版本&lt;3.5.0）之前的版本中<code>RabbitMQ.Client</code>我删除了指向<code>System.ServiceModel</code>的链接并重新编译。 我必须使用<code>System.ServiceModel</code>功能更改几行代码，但这只是次要更改。 <br><br> 在此示例中，我没有使用客户端版本3.4.3，而是使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">稳定的版本3.6.6，</a>并使用.NET 3.5（CLR 2）重新编译。 它几乎可以正常工作:)，只是<code>RabbitMQ.Client</code>更高版本使用<code>Task</code> '并且最初不是.NET 3.5的一部分。 <br><br> 幸运的是，.NET 3.5有一个包含<code>Task</code>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>System.Threading.dll</code></a>版本。 我下载了它，设置了链接，一切顺利！ 这里的主要技巧是应将<code>System.Threading.dll</code>与程序集一起安装。 <br><blockquote>  <b>注意：</b> <code>RabbitMQ.Client</code> <b>的</b>源代码（我从中编译了.NET 3.5的版本）位于GitHub <a href="">RabbitMQ Client 3.6.6 .NET 3.5</a>上的存储库中。  .NET 3.5的dll二进制文件以及<code>System.Threading.dll</code>也位于存储库<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">（RabbitMQ-SqlServer）</a>的<code>lib\NET3.5</code> 。 <br></blockquote> 要安装必要的程序集（ <code>System.Threading</code> ， <code>RabbitMQ.Client</code>和<code>RabbitMQ.SqlServer</code> ），请按以下顺序从<code>src\sql</code>目录运行安装脚本： <br><br><ol><li>  <code>05.51.System.Threading.sql2k5-12.sql</code> -System.Threading </li><li>  <code>05.52.RabbitMQ.Client.sql2k5-12.sql</code> -RabbitMQ.Client </li><li>  <code>05.53.RabbitMQ.SqlServer.sql2k5-12.sql</code> -RabbitMQ.SqlServer </li></ol><br><h3>  SQL Server 2014以上版本 </h3><br> 在SQL Server 2014及更高版本中，程序集在.NET 4.XX下编译（我的示例在4.5.2上），并且您可以引用<code>RabbitMQ.Client</code>任何最新版本，可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NuGet</a>获得该版本。 在我的示例中，我使用的是4.1.1。  <code>RabbitMQ.Client</code> ，它也位于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存储库（RabbitMQ-SqlServer）</a>的<code>lib\NET4</code> 。 <br><br> 要安装，请按以下顺序从<code>src\sql</code>目录运行脚本： <br><br><ol><li>  <code>05.141.RabbitMQ.Client.sql2k14+.sql</code> -RabbitMQ.Client </li><li>  <code>05.142.RabbitMQ.SqlServer.sql2k14+.sql</code> -RabbitMQ.SqlServer </li></ol><br><h3>  SQL方法包装 </h3><br> 要创建将在我们的程序<code>06.create_sqlclr_procedures.sql</code>使用的过程（3.5或4），请运行脚本<code>06.create_sqlclr_procedures.sql</code> 。 他将为三种.NET方法创建T-SQL过程： <br><br><ul><li>  <code>rmq.pr_clr_InitialiseRabbitMq</code>调用<code>pr_clr_InitialiseRabbitMq</code> 。 用于加载和初始化RabbitMQ.SqlServer程序集。 </li><li>  <code>rmq.pr_clr_ReloadRabbitEndpoints</code>调用<code>pr_clr_ReloadRabbitEndpoints</code> 。 加载各种RabbitMQ端点。 </li><li>  <code>rmq.pr_clr_PostRabbitMsg</code>调用<code>pr_clr_PostRabbitMsg</code> 。 用于向RabbitMQ发送消息。 </li></ul><br> 该脚本还创建了一个简单的T-SQL过程<code>rmq.pr_PostRabbitMsg</code> ，该过程适用于<code>rmq.pr_clr_PostRabbitMsg</code> 。 这是一个包装程序，它知道如何处理数据，处理异常等。 在生产环境中，我们有几种类似的过程可处理各种类型的消息。 在下面阅读有关此内容的更多信息。 <br><br><h3> 使用方法 </h3><br> 从以上所有内容可以明显看出，要将消息发送到RabbitMQ，我们调用<code>rmq.pr_PostRabbitMsg</code>或<code>rmq.pr_clr_PostRabbitMsg</code> ，并以<code>rmq.pr_clr_PostRabbitMsg</code>传递参数端点的标识符和消息本身。 当然，所有这些都很酷，但是我想看看它如何在现实中发挥作用。 <br><br> 在生产环境中，我们要做的是在存储过程中处理应该发送到RabbitMQ的数据，我们收集要发送的数据，并在连接块中调用<code>rmq.pr_PostRabbitMsg</code>类的过程。 以下是此过程的非常简化的示例： <br><br> 数据处理程序 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> dbo.pr_SomeProcessingStuff @<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> NOCOUNT <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY <span class="hljs-comment"><span class="hljs-comment">--     DECLARE @endPointId int; --    DECLARE @msg nvarchar(max) = '{' --        SET @msg = @msg + '"Id":' + CAST(@id AS varchar(10)) + ',' --  -  SET @msg = @msg + '"FName":"Hello",'; SET @msg = @msg + '"LName":"World"'; SET @msg = @msg + '}'; -- -  --     -,  -  SELECT @endPointId = 1; --    --     EXEC rmq.pr_PostRabbitMsg @Message = @msg, @EndpointID = @endPointId; END TRY BEGIN CATCH DECLARE @errMsg nvarchar(max); DECLARE @errLine int; SELECT @errMsg = ERROR_MESSAGE(), @errLine = ERROR_LINE(); RAISERROR('Error: %s at line: %d', 16, -1, @errMsg, @errLine); END CATCH END</span></span></code> </pre> <br> 在<b>代码片段7中，</b>我们看到了如何在过程中捕获和处理必要的数据并在处理后发送它们。 要使用此过程，请从<code>src\SQL</code>目录运行<code>07.create_processing_procedure.sql</code>脚本。 <br><br><h3> 让我们全部运行 </h3><br> 此时，您应该准备发送一些消息。 在测试之前，请确保<code>rmq.tb_RabbitEndpoint</code>的端点交换器上的RabbitMQ中有队列。 <br><br> 因此，要开始，您需要执行以下操作： <br> 打开<code>99.test_send_message.sql</code>文件。 <br> 跑 <br><br><pre> <code class="sql hljs">EXEC rmq.pr_clr_InitialiseRabbitMq;</code> </pre> <br> 初始化程序集并加载RabbitMQ端点。 这不是必需的，但是建议您在创建或修改装配后预加载装配。 <br><br> 跑 <br><br><pre> <code class="sql hljs">EXEC dbo.pr_SomeProcessingStuff @id = 101</code> </pre> <br>  （您可以使用任何其他喜欢的标识符）。 <br><br> 如果一切正常而没有错误，那么RabbitMQ队列中将出现一条消息！ 因此，您使用了SQLCLR将消息发送到RabbitMQ。 <br><br> 恭喜你！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN419457/">https://habr.com/ru/post/zh-CN419457/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN419441/index.html">SpaceX今天首次重新使用Falcon 9 Block 5火箭</a></li>
<li><a href="../zh-CN419443/index.html">美国宇航局将再次飞往月球，使飞机的所有元素</a></li>
<li><a href="../zh-CN419449/index.html">Redux与React Context API</a></li>
<li><a href="../zh-CN419451/index.html">逐步为Symfony 4创建捆绑包</a></li>
<li><a href="../zh-CN419453/index.html">求解非线性方程组的数值方法</a></li>
<li><a href="../zh-CN419459/index.html">铅酸电池：脉冲充电字母</a></li>
<li><a href="../zh-CN419461/index.html">洗手间通风</a></li>
<li><a href="../zh-CN419467/index.html">从灯泡到吸尘器和无人驾驶飞机-我们如何教爱丽丝管理数百种设备</a></li>
<li><a href="../zh-CN419469/index.html">UE4 | 昼夜周期| 修改SkySphere</a></li>
<li><a href="../zh-CN419471/index.html">从jQuery到纯JavaScript的迁移选项</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>