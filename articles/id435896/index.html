<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻 🕵️ 👳🏿 Menggunakan DiagnosticSource dalam .NET Core: Theory 🌊 🚉 🧑🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="DiagnosticSource adalah serangkaian API yang sederhana namun sangat berguna (tersedia dalam Sistem paket NuGet. Diagnostics. DiagnosticSource), yang, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan DiagnosticSource dalam .NET Core: Theory</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ozontech/blog/435896/"><p>  DiagnosticSource adalah serangkaian API yang sederhana namun sangat berguna (tersedia dalam Sistem paket NuGet. Diagnostics. DiagnosticSource), yang, di satu sisi, memungkinkan berbagai perpustakaan untuk mengirim peristiwa yang disebutkan tentang pekerjaan mereka, dan di sisi lain, memungkinkan aplikasi untuk berlangganan acara dan proses ini mereka. </p><br><p>  Setiap peristiwa tersebut mengandung informasi tambahan (payload), dan karena peristiwa diproses dalam proses yang sama dengan pengiriman, informasi ini dapat berisi hampir semua objek tanpa perlu serialisasi / deserialisasi. </p><br><p> DiagnosticSource sudah digunakan di AspNetCore, EntityFrameworkCore, HttpClient dan SqlClient, yang benar-benar memberikan pengembang kemampuan untuk mencegat permintaan http masuk, keluar, permintaan basis data, objek akses seperti <code>HttpContext</code> , <code>DbConnection</code> , <code>DbCommand</code> , <code>HttpRequestMessage</code> dan banyak lainnya. benda jika perlu. </p><br><p>  Saya memutuskan untuk membagi cerita saya tentang DiagnosticSource menjadi dua artikel.  Dalam artikel ini, kami akan menganalisis prinsip operasi mekanisme dengan contoh sederhana, dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berikutnya</a> saya akan berbicara tentang peristiwa yang ada di .NET yang dapat diproses menggunakannya dan menunjukkan beberapa contoh penggunaannya di OZON.ru. </p><a name="habracut"></a><br><h2 id="primer">  Contoh </h2><br><p>  Untuk lebih memahami bagaimana DiagnosticSource bekerja, pertimbangkan contoh kecil mencegat kueri basis data.  Bayangkan kita memiliki aplikasi konsol sederhana yang membuat permintaan ke database dan menampilkan hasilnya di konsol. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ConnectionString = <span class="hljs-string"><span class="hljs-string">@"Data Source=localhost;Initial Catalog=master;User ID=sa;Password=Password12!;"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> answer = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> GetAnswerAsync(); Console.WriteLine(answer); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnswerAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlConnection(ConnectionString)) { <span class="hljs-comment"><span class="hljs-comment">// using Dapper return await connection.QuerySingleAsync&lt;int&gt;("SELECT 42;"); } } }</span></span></code> </pre> <br><p>  Untuk kesederhanaan, saya mengangkat SQL Server dalam wadah buruh pelabuhan. </p><br><div class="spoiler">  <b class="spoiler_title">buruh pelabuhan lari</b> <div class="spoiler_text"><pre> <code class="bash hljs">docker run --rm --detach --name mssql-server \ --publish 1433:1433 \ --env ACCEPT_EULA=Y \ --env SA_PASSWORD=Password12! \ mcr.microsoft.com/mssql/server:2017-latest</code> </pre> </div></div><br><p>  Sekarang bayangkan bahwa kita memiliki tugas: kita perlu mengukur waktu eksekusi semua pertanyaan ke database menggunakan <code>Stopwatch</code> dan menampilkan pasangan "Permintaan" - "Runtime" di konsol. </p><br><p>  Tentu saja, Anda bisa membungkus panggilan <code>QuerySingleAsync</code> kode yang membuat dan memulai instance <code>Stopwatch</code> , menghentikannya setelah kueri dieksekusi dan menampilkan hasilnya, tetapi ada beberapa kesulitan sekaligus: </p><br><ul><li>  Bagaimana jika aplikasi memiliki lebih dari satu permintaan? </li><li>  Bagaimana jika kode yang mengeksekusi permintaan sudah dikompilasi, terhubung ke aplikasi sebagai paket NuGet, dan kami tidak punya cara untuk mengubahnya? </li><li>  Bagaimana jika kueri ke basis data tidak dilakukan melalui Dapper, tetapi melalui EntityFramework, misalnya, dan kami tidak memiliki akses ke objek <code>DbCommand</code> atau ke teks kueri yang dihasilkan yang sebenarnya akan dieksekusi? </li></ul><br><p>  Mari kita coba selesaikan masalah ini menggunakan DiagnosticSource. </p><br><h3 id="ispolzovanie-nuget-paketa-systemdiagnosticsdiagnosticsource">  Menggunakan Paket NuGet System.Diagnostics.DiagnosticSource </h3><br><p>  Hal pertama yang harus dilakukan setelah menghubungkan paket NuGet dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">System.Diagnostics.DiagnosticSource</a> adalah membuat kelas yang akan menangani acara yang menarik bagi kita: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleDiagnosticObserver</span></span> { }</code> </pre> <br><p>  Untuk mulai memproses peristiwa, Anda harus membuat turunan dari kelas ini dan mendaftarkannya sebagai pengamat di objek statis <code>DiagnosticListener.AllListeners</code> (terletak di namespace <code>System.Diagnostics</code> System).  Kami melakukan ini di awal fungsi <code>Main</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> observer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExampleDiagnosticObserver(); IDisposable subscription = DiagnosticListener.AllListeners.Subscribe(observer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> answer = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> GetAnswerAsync(); Console.WriteLine(answer); }</code> </pre> <br><p>  Dalam kasus ini, kompiler akan memberi tahu kami dengan benar bahwa kelas <code>ExampleDiagnosticObserver</code> harus mengimplementasikan <code>IObserver&lt;DiagnosticListener&gt;</code> .  Mari kita implementasikan: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleDiagnosticObserver</span></span> : <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">DiagnosticListener</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnNext(DiagnosticListener diagnosticListener) { Console.WriteLine(diagnosticListener.Name); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnError(Exception error) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnCompleted() { } }</code> </pre> <br><p>  Jika kita menjalankan kode ini sekarang, kita akan melihat bahwa yang berikut ini akan ditampilkan di konsol: </p><br><pre> <code class="plaintext hljs">SqlClientDiagnosticListener SqlClientDiagnosticListener 42</code> </pre> <br><p>  Ini berarti bahwa di suatu tempat di. NET dua objek dari tipe <code>DiagnosticListener</code> terdaftar dengan nama <code>"SqlClientDiagnosticListener"</code> yang berfungsi ketika kode ini dieksekusi. </p><br><div class="spoiler">  <b class="spoiler_title">Di sini mereka ada di github.com</b> <div class="spoiler_text"><p>  Sebenarnya ada tiga, tetapi karena kami tidak menggunakan <code>SqlTransaction</code> , hanya dua yang berfungsi: </p><br><ul><li>  <a href="">https://github.com/dotnet/corefx/blob/v2.2.1/src/System.Data.SqlClient/src/System/Data/SqlClient/SqlConnection.cs#L50</a> </li><li>  <a href="">https://github.com/dotnet/corefx/blob/v2.2.1/src/System.Data.SqlClient/src/System/Data/SqlClient/SqlCommand.cs#L31</a> </li><li>  <a href="">https://github.com/dotnet/corefx/blob/v2.2.1/src/System.Data.SqlClient/src/System/Data/SqlClient/SqlTransaction.cs#L16</a> </li></ul></div></div><br><p>  <code>IObserver&lt;DiagnosticListener&gt;.OnNext</code> akan dipanggil <strong>sekali pada penggunaan pertama</strong> untuk setiap instance dari <code>DiagnosticListener</code> yang dibuat dalam aplikasi (biasanya mereka dibuat sebagai properti statis).  Sekarang kami baru saja menampilkan nama instance <code>DiagnosticListener</code> di konsol, tetapi dalam praktiknya metode ini perlu memeriksa nama ini dan, jika kami tertarik untuk memproses peristiwa dari instance ini, berlangganan dengan menggunakan metode <code>Subscribe</code> . </p><br><p>  Saya juga ingin mencatat bahwa ketika kita memanggil <code>DiagnosticListener.AllListeners.Subscribe</code> . <code>IDisposable</code> . <code>subscription</code> <code>DiagnosticListener.AllListeners.Subscribe</code> kita akan mendapatkan objek <code>subscription</code> sebagai hasilnya, yang mengimplementasikan antarmuka <code>IDisposable</code> .  Memanggil metode <code>Dispose</code> pada objek ini akan menyebabkan berhenti berlangganan, yang harus diimplementasikan dalam <code>IObserver&lt;DiagnosticListener&gt;.OnCompleted</code> . </p><br><p>  Mari kita implementasikan lagi <code>IObserver&lt;DiagnosticListener&gt;</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleDiagnosticObserver</span></span> : <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">DiagnosticListener</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;IDisposable&gt; _subscriptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;IDisposable&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnNext(DiagnosticListener diagnosticListener) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diagnosticListener.Name == <span class="hljs-string"><span class="hljs-string">"SqlClientDiagnosticListener"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscription = diagnosticListener.Subscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); _subscriptions.Add(subscription); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnError(Exception error) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnCompleted() { _subscriptions.ForEach(x =&gt; x.Dispose()); _subscriptions.Clear(); } }</code> </pre> <br><p>  Sekarang kompiler akan memberi tahu kita bahwa kelas <code>ExampleDiagnosticObserver</code> kita juga harus mengimplementasikan <code>IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;</code> interface.  Di sini kita perlu mengimplementasikan <code>IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;.OnNext</code> , yang sebagai parameter menerima <code>KeyValuePair&lt;string, object&gt;</code> , di mana kuncinya adalah nama acara, dan nilainya adalah objek anonim (biasanya) dengan parameter acak yang dapat kita gunakan atas kebijakannya sendiri.  Mari tambahkan implementasi antarmuka ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleDiagnosticObserver</span></span> : <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">DiagnosticListener</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">KeyValuePair</span></span>&lt;<span class="hljs-title"><span class="hljs-title">string</span></span>, <span class="hljs-title"><span class="hljs-title">object</span></span>&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">// IObserver&lt;DiagnosticListener&gt; implementation // ... void IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;.OnNext(KeyValuePair&lt;string, object&gt; pair) { Write(pair.Key, pair.Value); } void IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;.OnError(Exception error) { } void IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;.OnCompleted() { } private void Write(string name, object value) { Console.WriteLine(name); Console.WriteLine(value); Console.WriteLine(); } }</span></span></code> </pre> <br><p>  Jika sekarang kita menjalankan kode yang dihasilkan, maka yang berikut akan ditampilkan di konsol: </p><br><pre> <code class="plaintext hljs">System.Data.SqlClient.WriteConnectionOpenBefore { OperationId = 3da1b5d4-9ce1-4f28-b1ff-6a5bfc9d64b8, Operation = OpenAsync, Connection = System.Data.SqlClient.SqlConnection, Timestamp = 26978341062 } System.Data.SqlClient.WriteConnectionOpenAfter { OperationId = 3da1b5d4-9ce1-4f28-b1ff-6a5bfc9d64b8, Operation = OpenAsync, ConnectionId = 84bd0095-9831-456b-8ebc-cb9dc2017368, Connection = System.Data.SqlClient.SqlConnection, Statistics = System.Data.SqlClient.SqlStatistics+StatisticsDictionary, Timestamp = 26978631500 } System.Data.SqlClient.WriteCommandBefore { OperationId = 5c6d300c-bc49-4f80-9211-693fa1e2497c, Operation = ExecuteReaderAsync, ConnectionId = 84bd0095-9831-456b-8ebc-cb9dc2017368, Command = System.Data.SqlClient.SqlComman d } System.Data.SqlClient.WriteCommandAfter { OperationId = 5c6d300c-bc49-4f80-9211-693fa1e2497c, Operation = ExecuteReaderAsync, ConnectionId = 84bd0095-9831-456b-8ebc-cb9dc2017368, Command = System.Data.SqlClient.SqlComman d, Statistics = System.Data.SqlClient.SqlStatistics+StatisticsDictionary, Timestamp = 26978709490 } System.Data.SqlClient.WriteConnectionCloseBefore { OperationId = 3f6bfd8f-e5f6-48b7-82c7-41aeab881142, Operation = Close, ConnectionId = 84bd0095-9831-456b-8ebc-cb9dc2017368, Connection = System.Data.SqlClient.SqlConnection, Stat istics = System.Data.SqlClient.SqlStatistics+StatisticsDictionary, Timestamp = 26978760625 } System.Data.SqlClient.WriteConnectionCloseAfter { OperationId = 3f6bfd8f-e5f6-48b7-82c7-41aeab881142, Operation = Close, ConnectionId = 84bd0095-9831-456b-8ebc-cb9dc2017368, Connection = System.Data.SqlClient.SqlConnection, Stat istics = System.Data.SqlClient.SqlStatistics+StatisticsDictionary, Timestamp = 26978772888 } 42</code> </pre> <br><p>  Secara total, kita akan melihat enam acara.  Dua di antaranya dieksekusi sebelum dan sesudah membuka koneksi ke database, dua - sebelum dan sesudah perintah dieksekusi, dan dua lagi - sebelum dan sesudah menutup koneksi ke database. </p><br><p>  Setiap peristiwa berisi sekumpulan parameter, seperti <code>OperationId</code> , <code>ConnectionId</code> , <code>Connection</code> , <code>Command</code> , yang biasanya dilewatkan sebagai properti dari objek anonim.  Anda bisa mendapatkan nilai yang diketik untuk properti ini, misalnya, menggunakan refleksi.  (Dalam praktiknya, menggunakan refleksi mungkin tidak terlalu diinginkan. Kami menggunakan DynamicMethod untuk mendapatkan parameter acara.) </p><br><p>  Sekarang kita siap untuk menyelesaikan masalah awal - untuk mengukur waktu eksekusi semua permintaan ke database dan menampilkannya di konsol bersama dengan permintaan asli. </p><br><p>  Ubah implementasi metode <code>Write</code> sebagai berikut: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleDiagnosticObserver</span></span> : <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">DiagnosticListener</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">KeyValuePair</span></span>&lt;<span class="hljs-title"><span class="hljs-title">string</span></span>, <span class="hljs-title"><span class="hljs-title">object</span></span>&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">// IObserver&lt;DiagnosticListener&gt; implementation // ... // IObserver&lt;KeyValuePair&lt;string, object&gt;&gt; implementation // ... private readonly AsyncLocal&lt;Stopwatch&gt; _stopwatch = new AsyncLocal&lt;Stopwatch&gt;(); private void Write(string name, object value) { switch (name) { case "System.Data.SqlClient.WriteCommandBefore": { //           _stopwatch.Value = Stopwatch.StartNew(); break; } case "System.Data.SqlClient.WriteCommandAfter": { //           var stopwatch = _stopwatch.Value; stopwatch.Stop(); var command = GetProperty&lt;SqlCommand&gt;(value, "Command"); Console.WriteLine($"CommandText: {command.CommandText}"); Console.WriteLine($"Elapsed: {stopwatch.Elapsed}"); Console.WriteLine(); break; } } } private static T GetProperty&lt;T&gt;(object value, string name) { return (T) value.GetType() .GetProperty(name) .GetValue(value); } }</span></span></code> </pre> <br><p>  Di sini kami mencegat awal dan akhir acara permintaan ke database.  Sebelum menjalankan permintaan, kami membuat dan memulai stopwatch, menyimpannya dalam variabel tipe <code>AsyncLocal&lt;Stopwatch&gt;</code> , untuk mendapatkannya kembali nanti.  Setelah mengeksekusi permintaan, kita mendapatkan stopwatch yang diluncurkan sebelumnya, menghentikannya, mendapatkan perintah yang dieksekusi dari parameter <code>value</code> melalui refleksi dan mencetak hasilnya ke konsol. </p><br><p>  Jika sekarang kita menjalankan kode yang dihasilkan, maka yang berikut akan ditampilkan di konsol: </p><br><pre> <code class="plaintext hljs">CommandText: SELECT 42; Elapsed: 00:00:00.0341357 42</code> </pre> <br><p>  Tampaknya kita telah menyelesaikan masalah kita, tetapi satu detail kecil tetap ada.  Faktanya adalah bahwa ketika kita berlangganan acara <code>DiagnosticListener</code> , kita mulai menerima darinya bahkan peristiwa yang tidak menarik bagi kita, dan karena setiap peristiwa dikirim objek anonim dengan parameter dibuat, ini dapat membuat beban tambahan pada GC. </p><br><p>  Untuk menghindari situasi ini dan memberi tahu Anda acara mana dari <code>DiagnosticListener</code> yang akan kami proses, kami dapat menentukan delegasi khusus dari tipe <code>Predicate&lt;string&gt;</code> saat berlangganan, yang menggunakan nama acara sebagai parameter dan mengembalikan <code>true</code> jika acara ini harus diproses. </p><br><p>  <code>IObserver&lt;DiagnosticListener&gt;.OnNext</code> di kelas kami: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnNext(DiagnosticListener diagnosticListener) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diagnosticListener.Name == <span class="hljs-string"><span class="hljs-string">"SqlClientDiagnosticListener"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscription = diagnosticListener.Subscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, IsEnabled); _subscriptions.Add(subscription); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsEnabled</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == <span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient.WriteCommandBefore"</span></span> || name == <span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient.WriteCommandAfter"</span></span>; }</code> </pre> <br><p>  Sekarang metode <code>Write</code> kita akan dipanggil hanya untuk peristiwa <code>"System.Data.SqlClient.WriteCommandBefore"</code> dan <code>"System.Data.SqlClient.WriteCommandAfter"</code> . </p><br><h3 id="ispolzovanie-nuget-paketa-microsoftextensionsdiagnosticadapter">  Menggunakan Microsoft's Paket NuGet. Ekstensi. Diagnosis Diagnosis </h3><br><p>  Karena parameter peristiwa yang kami terima dari <code>DiagnosticListener</code> biasanya dilewatkan sebagai objek anonim, mengambilnya melalui refleksi bisa jadi terlalu mahal.  Untungnya, ada paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microsoft.Extensions.DiagnosticAdapter</a> NuGet yang dapat melakukan ini untuk kita, menggunakan generasi kode runtime dari <code>System.Reflection.Emit</code> . </p><br><p>  Untuk menggunakan paket ini saat berlangganan acara dari instance <code>DiagnosticListener</code> alih-alih metode <code>Subscribe</code> , Anda harus menggunakan metode ekstensi <code>SubscribeWithAdapter</code> .  Menerapkan <code>IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;</code> dalam kasus ini tidak lagi diperlukan.  Sebaliknya, untuk setiap peristiwa yang ingin kami tangani, kita perlu mendeklarasikan metode terpisah, menandainya dengan atribut <code>DiagnosticNameAttribute</code> (dari <code>Microsoft.Extensions.DiagnosticAdapter</code> namespace).  Parameter metode ini akan menjadi parameter acara yang sedang diproses. </p><br><p>  Jika kami menulis ulang kelas <code>ExampleDiagnosticObserver</code> kami menggunakan paket NuGet ini, kami mendapatkan kode berikut: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleDiagnosticObserver</span></span> : <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">DiagnosticListener</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;IDisposable&gt; _subscriptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;IDisposable&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnNext(DiagnosticListener diagnosticListener) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diagnosticListener.Name == <span class="hljs-string"><span class="hljs-string">"SqlClientDiagnosticListener"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscription = diagnosticListener.SubscribeWithAdapter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); _subscriptions.Add(subscription); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnError(Exception error) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnCompleted() { _subscriptions.ForEach(x =&gt; x.Dispose()); _subscriptions.Clear(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> AsyncLocal&lt;Stopwatch&gt; _stopwatch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncLocal&lt;Stopwatch&gt;(); [DiagnosticName(<span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient.WriteCommandBefore"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCommandBefore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _stopwatch.Value = Stopwatch.StartNew(); } [DiagnosticName(<span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient.WriteCommandAfter"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCommandAfter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DbCommand command</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stopwatch = _stopwatch.Value; stopwatch.Stop(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"CommandText: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{command.CommandText}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Elapsed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{stopwatch.Elapsed}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(); } }</code> </pre> <br><p>  Dengan demikian, kita sekarang dapat mengukur waktu pelaksanaan semua pertanyaan ke database dari aplikasi kita, praktis tanpa mengubah kode aplikasi itu sendiri. </p><br><h2 id="sozdanie-sobstvennyh-ekzemplyarov-diagnosticlistener">  Membuat Instance DiagnosticListener Anda Sendiri </h2><br><p>  Saat menggunakan DiagnosticSource dalam praktiknya, dalam kebanyakan kasus Anda akan berlangganan acara yang ada.  Anda kemungkinan besar tidak perlu membuat instance sendiri dari <code>DiagnosticListener</code> dan mengirim acara Anda sendiri (hanya jika Anda tidak mengembangkan perpustakaan apa pun), jadi saya tidak akan berkutat pada bagian ini untuk waktu yang lama. </p><br><p>  Untuk membuat instance Anda sendiri dari <code>DiagnosticListener</code> Anda harus mendeklarasikannya sebagai variabel statis di suatu tempat dalam kode: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> DiagnosticSource _myDiagnosticSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagnosticListener(<span class="hljs-string"><span class="hljs-string">"MyLibraty"</span></span>);</code> </pre> <br><p>  Setelah itu, untuk mengirim acara, Anda dapat menggunakan desain formulir </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_myDiagnosticSource.IsEnabled(<span class="hljs-string"><span class="hljs-string">"MyEvent"</span></span>)) _myDiagnosticSource.Write(<span class="hljs-string"><span class="hljs-string">"MyEvent"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* parameters */</span></span> });</code> </pre> <br><p>  Untuk informasi lebih lanjut tentang cara membuat instance <code>DiagnosticListener</code> Anda sendiri, lihat <a href="">Panduan Pengguna DiagnosticSource</a> , yang merinci Praktik Terbaik untuk menggunakan DiagnosticSource. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Contoh yang kami teliti tentu sangat abstrak dan tidak mungkin berguna dalam proyek nyata.  Tetapi ini dengan sempurna menunjukkan bagaimana mekanisme ini dapat digunakan untuk memantau dan mendiagnosis aplikasi Anda. </p><br><p>  Pada artikel selanjutnya, saya akan memberikan daftar peristiwa yang saya ketahui yang dapat diproses melalui DiagnosticSource, dan menunjukkan beberapa contoh praktis penggunaannya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435896/">https://habr.com/ru/post/id435896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435884/index.html">Pencarian logam dan ... jaringan saraf</a></li>
<li><a href="../id435886/index.html">SpaceX menunjukkan prototipe Starship dan akan mengurangi 10% staf</a></li>
<li><a href="../id435890/index.html">Sisi gelap orang yang aktif</a></li>
<li><a href="../id435892/index.html">Intisari materi menarik untuk pengembang seluler # 281 (pada 7 - 13 Januari)</a></li>
<li><a href="../id435894/index.html">Kelas privat. Bersembunyi di php</a></li>
<li><a href="../id435898/index.html">Apa yang harus dipikirkan pada wawancara NALSD</a></li>
<li><a href="../id435900/index.html">Enkapsulasi itu</a></li>
<li><a href="../id435902/index.html">Anda tidak bisa hanya mengambil dan menulis PILIH jika vendor tidak mengizinkannya ... tetapi kami akan menulis</a></li>
<li><a href="../id435904/index.html">AI menerjemahkan aktivitas otak ke dalam ucapan</a></li>
<li><a href="../id435906/index.html">Penyimpanan Cluster Pacemaker + DRBD (Dual primer) + ctdb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>