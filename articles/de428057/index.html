<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏽 🤳 👨🏽‍🚒 Ein neuer Blick auf die Dokumentation der API und des SDK in Yandex. Vortrag über Hyperbaton 🔄 🙎🏿 👩🏼‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Name ist Andrey Polyakov, ich bin der Leiter der API- und SDK-Dokumentationsgruppe bei Yandex. Heute möchte ich Ihnen einen Bericht mitteilen, de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein neuer Blick auf die Dokumentation der API und des SDK in Yandex. Vortrag über Hyperbaton</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/428057/">  Mein Name ist Andrey Polyakov, ich bin der Leiter der API- und SDK-Dokumentationsgruppe bei Yandex.  Heute möchte ich Ihnen einen Bericht mitteilen, den ich und meine Kollegin, die leitende Dokumentationsentwicklerin Julia Pivovarova, vor einigen Wochen beim sechsten Hyperbaton gelesen haben. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4xvNMJQL6ec" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Svetlana Kayushina, Leiterin der Abteilung Dokumentation und Lokalisierung: <br>  - Das Volumen des Programmcodes in der Welt ist in den letzten Jahren erheblich gewachsen und wächst weiter. Dies wirkt sich auf die Arbeit von technischen Redakteuren aus, die mit immer mehr Aufgaben bei der Entwicklung der Programmdokumentation und der Dokumentation von Code konfrontiert sind.  Wir konnten dieses Thema nicht ignorieren, wir haben ihm einen ganzen Abschnitt gewidmet.  Dies sind drei verwandte Berichte zur Vereinheitlichung der Softwareentwicklung.  Ich lade unsere Spezialisten für die Dokumentation von Softwareschnittstellen und Bibliotheken zu Andrei Polyakov und Julia Pivovarova ein.  Ich gebe ihnen das Wort. <a name="habracut"></a><br><br>  - Hallo allerseits!  Heute werden Julia und ich Ihnen erzählen, wie wir in Yandex einen neuen Blick auf die Dokumentation der API und des SDK bekommen haben.  Der Bericht wird aus vier Teilen bestehen, der Überwachungsbericht, wir werden diskutieren, wir werden reden. <br><br>  Lassen Sie uns über die Vereinheitlichung der API und des SDK sprechen, wie wir dazu gekommen sind, was wir dort gemacht haben.  Wir werden die Erfahrungen mit der Verwendung eines Universalgenerators, eines für alle Sprachen, teilen und Ihnen erklären, warum er nicht zu uns passte, was die Fallstricke waren und warum wir auf die Erstellung von Dokumentationen durch native Generatoren umgestellt haben. <br><br>  Am Ende werden wir beschreiben, wie unsere Prozesse aufgebaut wurden. <br><br>  Beginnen wir mit der Vereinigung.  Jeder denkt an die Vereinigung, wenn mehr als zwei Personen in einem Team sind: Jeder schreibt anders, jeder hat seine eigenen Ansätze, und das ist logisch.  Es ist besser, alle Regeln am Strand zu besprechen, bevor Sie mit dem Schreiben von Dokumentationen beginnen, aber nicht jeder kann dies tun. <br><br>  Wir haben eine Expertengruppe zusammengestellt, um unsere Dokumentation zu analysieren.  Wir haben dies getan, um unsere Ansätze zu systematisieren.  Jeder schreibt auf unterschiedliche Weise, und wir stimmen zu, im gleichen Stil zu schreiben.  Dies ist der zweite Punkt, für den wir versuchen wollten, die Dokumentation einheitlich zu gestalten, damit der Benutzer eine Benutzererfahrung in der gesamten Yandex-Dokumentation hatte, nämlich in der technischen. <br><br>  Die Arbeit war in drei Phasen unterteilt.  Wir haben eine Beschreibung der Technologien zusammengestellt, die wir in Yandex verwenden. Wir haben versucht, diejenigen herauszustellen, die wir irgendwie vereinheitlichen können.  Und bildete auch die allgemeine Struktur von Standarddokumenten und -vorlagen. <br><br><img src="https://habrastorage.org/webt/xx/xk/j1/xxxkj1tgym6dmi6hh42rmxrjiao.jpeg"><br><br>  Kommen wir zur Beschreibung der Technologien.  Wir begannen zu untersuchen, welche Technologien in Yandex verwendet werden.  Es gibt so viele von ihnen, dass wir es satt haben, sie in eine Art Notizbuch zu schreiben, und deshalb haben wir nur die grundlegendsten ausgewählt, die am häufigsten verwendet werden und denen technische Redakteure am häufigsten begegnen, und begonnen, sie zu beschreiben. <br><br>  Was versteht man unter Technologiebeschreibung?  Wir haben die Hauptpunkte und das Wesen jeder Technologie identifiziert.  Wenn wir über Programmiersprachen sprechen, dann ist dies eine Beschreibung von Entitäten wie einer Klasse, einer Eigenschaft, Schnittstellen usw. Wenn wir über Protokolle sprechen, dann beschreiben wir HTTP-Methoden, wir sprechen über das Format des Fehlercodes, des Antwortcodes usw., die wir erstellt haben ein Glossar, das folgende Dinge enthält: Begriffe auf Russisch, Begriffe auf Englisch, Nuancen der Verwendung.  Zum Beispiel sprechen wir nicht über eine SDK-Methode, mit der Sie etwas tun können.  Er tut etwas, wenn der Programmierer einen Stift zieht, gibt es eine Antwort. <br><br>  Zusätzlich zu den Nuancen enthielt die Beschreibung auch Standardstrukturen, Standard-Sprachumdrehungen, die wir in der Dokumentation verwenden, damit der technische Redakteur einen bestimmten Wortlaut übernehmen und weiter verwenden kann. <br><br>  Darüber hinaus schreiben technische Redakteure häufig Code, Snippets und Beispiele. Dazu haben wir auch unseren Styleguide für jede Technologie beschrieben.  Wir haben uns an die Entwicklerhandbücher in Yandex gewandt.  Wir haben auf den Designcode, die Beschreibung der Kommentare, die Einrückung und all das geachtet.  Wir tun dies so, dass, wenn ein technischer Redakteur einem Programmierer einen Code oder ein schriftliches Beispiel vorlegt, der Programmierer das Wesentliche und nicht das Design betrachtet, was die Zeit verkürzt.  Und wenn ein technischer Redakteur über Yandex-Styleguides schreiben kann, ist das sehr cool. Vielleicht möchte er später Programmierer werden.  Der vorherige Bericht befasste sich mit verschiedenen Untersuchungen.  Sie können beispielsweise in Programmierer wechseln. <br><br>  Wir haben auch einen schnellen Einstieg für Tech-Autoren entwickelt: Wie man eine Entwicklungsumgebung einrichtet, wenn er mit neuen Technologien vertraut wird.  Wenn der SDK des technischen Redakteurs beispielsweise in C # geschrieben ist, kommt er, richtet die Entwicklungsumgebung ein, liest Handbücher und macht sich mit der Terminologie vertraut.  Wir haben auch Links zu offiziellen Dokumentationen und RFC hinterlassen, falls vorhanden.  Wir haben einen Einstiegspunkt für technische Redakteure geschaffen, und es sieht ungefähr so ​​aus. <br><br><img src="https://habrastorage.org/webt/xq/iy/_g/xqiy_gelsrmitsrt4tewahgalio.jpeg"><br><br>  Wenn ein technischer Redakteur eintrifft, lernt er eine neue Technologie und beginnt, sie zu dokumentieren. <br><br>  Nachdem wir die Technologien beschrieben hatten, beschrieben wir die Struktur der HTTP-API. <br><br>  Wir haben viele verschiedene HTTP-APIs, und alle werden unterschiedlich beschrieben.  Lassen Sie uns eine Vereinbarung treffen und dasselbe tun! <br><br>  Wir haben die Hauptabschnitte identifiziert, die in jeder HTTP-API enthalten sein werden: <br><br><img src="https://habrastorage.org/webt/jj/dc/cg/jjdccgfttivati4qg7ix7dibmyu.jpeg"><br><br>  "Übersicht" oder "Einführung": Warum wird diese API benötigt, was können Sie damit tun, auf welchen Host zugegriffen werden muss, um eine Antwort zu erhalten. <br><br>  "Schnellstart", wenn eine Person einige Schritte durchläuft und am Ende ein erfolgreiches Ergebnis erhält, um zu verstehen, wie diese API funktioniert. <br><br>  "Verbindung / Autorisierung".  Viele APIs erfordern ein Autorisierungstoken oder einen API-Schlüssel.  Dies ist ein wichtiger Punkt, daher haben wir beschlossen, dass dies ein obligatorischer Bestandteil aller APIs ist. <br><br>  "Einschränkungen / Limits", wenn wir über Limits für die Anzahl der Anfragen oder für die Größe des Anfragetexts usw. sprechen. <br><br>  "Referenz", Referenz.  Ein sehr großer Teil, der alle HTTP-Handles enthält, die der Benutzer abrufen und ein Ergebnis erzielen kann. <br><br><img src="https://habrastorage.org/webt/2d/do/k3/2ddok3raoojdsqkfiv2f5k0-j-u.jpeg"><br><br>  Infolgedessen hatten wir viele verschiedene APIs, die unterschiedlich beschrieben wurden. Jetzt versuchen wir, alles auf die gleiche Weise zu schreiben.  Ein solcher Gewinn. <br><br>  Als wir tief in die Verzeichnisse gingen, stellten wir fest, dass das HTTP-Handle fast immer dasselbe ist.  Sie ziehen es, das heißt, Sie stellen eine Anfrage, der Server gibt eine Antwort zurück - voila.  Versuchen wir es zu vereinheitlichen.  Wir haben eine Vorlage geschrieben, die versucht, alle Fälle abzudecken.  Der technische Redakteur nimmt die Vorlage und belässt die erforderlichen Teile in der Vorlage, wenn er eine PUT-Anfrage hat.  Wenn er eine GET-Anfrage hat, verwendet er nur die Teile, die für die GET-Anfrage benötigt werden.  Eine gemeinsame Vorlage für alle Anforderungen, die wiederverwendet werden können.  Jetzt müssen Sie keine Dokumentstruktur von Grund auf neu erstellen, sondern können einfach eine vorgefertigte Vorlage erstellen. <br><br><img src="https://habrastorage.org/webt/nl/c3/yi/nlc3yi4lg7v8p9e3k7rijcy00ho.jpeg"><br><br>  Jeder Stift beschreibt, wofür er ist, was er tut.  Es gibt einen Abschnitt „Anforderungsformat“, der Pfadparameter, Abfrageparameter und alles enthält, was im Anforderungshauptteil enthalten ist, wenn es gesendet wird.  Wir haben auch den Abschnitt „Antwortformat“ hervorgehoben: Wir schreiben ihn, wenn es einen Antworttext gibt.  In einem separaten Abschnitt haben wir „Antwortcodes“ hervorgehoben, da die Antwort vom Server unabhängig vom Hauptteil erfolgt.  Und verließ den Abschnitt "Beispiel".  Wenn wir eine Art SDK mit dieser API bereitstellen, sagen wir, dass Sie dieses SDK wie folgt verwenden, ein solches Handle ziehen und eine solche Methode aufrufen.  Normalerweise hinterlassen wir eine Art cURL-Beispiel, in dem der Benutzer einfach sein Token einfügt.  Und wenn wir einen Prüfstand haben, nimmt er einfach die Anfrage und führt sie aus.  Und bekommt eine Art Ergebnis. <br><br><img src="https://habrastorage.org/webt/9o/he/zu/9ohezukh5yfxqwcz2k_xjchuaa4.jpeg"><br><br>  Es stellt sich heraus, dass es viele Stifte gab, die auf unterschiedliche Weise beschrieben wurden, und jetzt wollen wir alles in eine einzige Form bringen. <br><br>  Nachdem wir mit der HTTP-API fertig waren, gingen wir zum mobilen SDK über. <br><br>  Es gibt eine allgemeine Dokumentstruktur, die ungefähr gleich ist: <br><br>  - "Einführung", wo wir sagen, dass dieses SDK hier für solche Zwecke verwendet wird, integrieren Sie es für solche Zwecke für sich selbst, es ist für solche Betriebssysteme geeignet, wir haben solche und solche Versionen usw. <br><br>  - "Verbindung".  Im Gegensatz zur HTTP-API geht es nicht nur darum, wie Sie den Schlüssel für die Verwendung des SDK erhalten, sondern bei Bedarf auch darum, wie Sie die Bibliothek in unser Projekt integrieren können. <br><br>  - "Anwendungsbeispiele."  Der größte Volumenabschnitt.  Meistens möchten Entwickler zur Dokumentation kommen und nicht viele Informationen lesen. Sie möchten ein Stück kopieren, es in sich selbst einfügen und alles wird für sie funktionieren.  Daher haben wir diesen Teil als sehr wichtig erachtet und ihn dem obligatorischen Abschnitt zugeordnet. <br><br><img src="https://habrastorage.org/webt/ii/3l/pb/ii3lpbn0sozlo7aafmhq8ng6meo.jpeg"><br><br>  - "Verzeichnis", Referenz, aber im Gegensatz zur HTTP-API-Referenz können wir hier nicht alles vereinheitlichen, da wir hauptsächlich Verzeichnisse generieren und später im Bericht darüber sprechen werden. <br><br>  - "Releases" oder Änderungsverlauf, Änderungsprotokoll.  Mobile SDKs haben normalerweise einen kurzen Veröffentlichungszyklus. Alle zwei Wochen wird eine neue Version veröffentlicht.  Und es wäre besser für den Benutzer, darüber zu sprechen, was sich geändert hat, ob es sich lohnt, es zu aktualisieren oder nicht. <br><br>  Gleichzeitig enthält die API sowohl die erforderlichen Abschnitte, die wir sehen, als auch die Abschnitte, die wir empfehlen.  Wenn die API häufig aktualisiert wird, geben Sie an, dass Sie auch den Änderungsverlauf einfügen, der sich in der API geändert hat.  Und oft werden unsere APIs selten aktualisiert, und es ist sinnlos, dies als erforderlichen Abschnitt anzugeben. <br><br><img src="https://habrastorage.org/webt/rz/pd/ts/rzpdtsmv7fdo--rxa2akag9uc_y.jpeg"><br><br>  Wir hatten also viele SDKs, die auf unterschiedliche Weise beschrieben wurden. Wir haben versucht, sie in ungefähr den gleichen Stil umzuwandeln.  Natürlich gibt es zusätzliche Unterschiede, die nur diesem SDK oder dieser HTTP-API eigen sind.  Hier haben wir die Wahlfreiheit.  Wir sagen nicht, dass außer diesen Abschnitten niemand getan werden kann.  Natürlich ist es möglich, dass wir einfach versuchen, die überall aufgeführten Abschnitte zu erstellen, damit klar ist, dass der Benutzer, wenn er in der Dokumentation zu einem anderen SDK wechselt, weiß, was im Abschnitt "Verbindung" beschrieben wird. <br><br>  Also haben wir uns Vorlagen ausgedacht, Anleitungen zusammengestellt. Was ist unser Aktionsplan jetzt?  Wir haben beschlossen, dass wir, wenn wir die API skalieren, die Stifte oder das SDK ändern, neue Vorlagen verwenden, eine neue Struktur erstellen und mit der Arbeit beginnen. <br><br>  Wenn wir die Dokumentation von Grund auf neu schreiben, nehmen wir natürlich wieder eine neue Struktur, nehmen neue Vorlagen und arbeiten daran. <br><br>  Und wenn die API veraltet ist, selten aktualisiert wird oder niemand sie unterstützt, aber vorhanden ist, wiederholen Sie sie ein wenig ressourcenintensiv.  Wir haben nur beschlossen, es zu belassen, bis es so war, aber wenn die Ressourcen erscheinen, werden wir definitiv zu ihnen zurückkehren, wir werden das alles gut und schön machen. <br><br>  Was sind die Vorteile der Vereinigung?  Sie sollten für alle offensichtlich sein: <br><br>  "UX", wir denken darüber nach, dass sich der Benutzer in unserer Dokumentation wie zu Hause fühlt.  Er kam und weiß, was in den Abschnitten beschrieben ist, in denen er Berechtigungen, Anwendungsbeispiele und Beschreibungen des Stifts finden kann.  Es ist toll. <br><br>  Für Tech-Autoren ermöglicht die Beschreibung der Technologie, einen bestimmten Einstiegspunkt zu bestimmen, an den er kommt, und beginnt, sich mit dieser Technologie vertraut zu machen. Wenn er sie nicht kennt, beginnt er, die Terminologie zu verstehen und sich darauf einzulassen. <br><br>  Der nächste Punkt ist die Austauschbarkeit.  Wenn der technische Redakteur in den Urlaub gefahren ist oder einfach aufgehört hat zu schreiben, weiß ein anderer technischer Redakteur beim Eingeben des Dokuments, wie es im Inneren funktioniert.  Es ist sofort klar, was in der Verbindung beschrieben wird, wo nach Informationen zur SDK-Integration gesucht werden kann.  Das Verstehen und Vornehmen einer kleinen Überarbeitung eines Dokuments wird einfacher.  Es ist klar, dass jedes Projekt seine eigenen Besonderheiten hat. Sie können nicht einfach ein Projekt dokumentieren, ohne es vollständig zu kennen.  Gleichzeitig ist die Struktur, dh die Dateinavigation, ungefähr gleich. <br><br>  Und natürlich die allgemeine Terminologie.  Diese Terminologie, die wir für Sprachen zusammengestellt haben, haben wir mit den Entwicklern und Übersetzern vereinbart.  Wir sagen, dass wir C # haben, es gibt einen solchen Begriff, wir verwenden ihn so.  Wir haben die Entwickler gefragt, welche Terminologie sie verwendet haben, und wollten an dieser Stelle eine Synchronisation erreichen.  Wir haben Vereinbarungen getroffen, und wenn wir das nächste Mal mit der Dokumentation kommen, wissen die Entwickler, dass wir mit ihnen Bedingungen und Richtlinien vereinbart haben. Wir verwenden diese Vorlagen und berücksichtigen die Nuancen ihrer Verwendung.  Und die Übersetzer wissen wiederum, dass wir das SDK in C # oder Objective-C beschreiben, sodass diese Terminologie der Beschreibung im Handbuch entspricht. <br><br>  Die Handbücher wurden in Wiki-Seiten geschrieben. Wenn also Sprachen, Technologien und Protokolle aktualisiert werden, kann dies problemlos zu einem vorhandenen Dokument hinzugefügt werden.  Idylle. <br><br>  Je früher Sie beginnen, sich zu vereinen und zuzustimmen, desto besser.  Es ist besser, als dass es kein Vermächtnis an Dokumentation gibt, das in einem anderen Stil geschrieben ist und den Fluss des Benutzers in der Dokumentation unterbricht.  Mach alles lieber früher. <br><br>  Entwickler anziehen.  Dies sind die Personen, für die Sie Unterlagen schreiben.  Wenn Sie selbst eine Art Leitfaden geschrieben haben, wird es ihnen vielleicht nicht gefallen.  Es ist besser, ihnen zuzustimmen, damit Sie ein gemeinsames Verständnis der Terminologie haben: Was Sie in die Dokumentation schreiben, wie Sie es schreiben. <br><br>  Und auch mit Übersetzern verhandeln, alle müssen es übersetzen.  Wenn sie anders übersetzen als die Entwickler es gewohnt sind, kommt es erneut zu Konflikten.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein Link</a> zu einem Videofragment mit Fragen und Antworten - ca. Ed.) Wir fahren fort. <br><br>  Julia: <br>  - Hallo, mein Name ist Julia, ich arbeite seit fünf Jahren in Yandex und dokumentiere die API und das SDK in Andreys Gruppe.  Normalerweise spricht jeder über eine gute Erfahrung, wie großartig sie ist.  Ich werde Ihnen sagen, wie wir eine nicht ganz erfolgreiche Strategie gewählt haben.  Zu dieser Zeit schien es erfolgreich zu sein, aber dann kam eine harte Realität und wir hatten ein wenig Pech. <br><br>  Wir hatten anfangs mehrere mobile SDKs, die hauptsächlich in zwei Sprachen geschrieben wurden: Objective-C und Java.  Wir haben ihnen manuell Dokumentation geschrieben.  Im Laufe der Zeit wuchsen Klassen, Protokolle und Schnittstellen.  Es gab immer mehr von ihnen, und wir erkannten, dass wir dieses Geschäft automatisieren mussten. Wir haben uns angesehen, was Technologien sind. <br><br><img src="https://habrastorage.org/webt/x7/-d/-h/x7-d-hzhlvxamk2fhvqd35n7jhe.jpeg"><br><br>  Zu dieser Zeit mochten wir Doxygen, es entsprach unseren Bedürfnissen, wie es uns schien, und wir wählten es als einen einzigen Generator.  Und wir haben ein solches Schema gezeichnet, das wir erwartet hatten, wir wollten irgendwie daran arbeiten. <br><br>  Was hatten wir?  Der technische Redakteur kam zur Arbeit, erhielt den Quellcode vom Entwickler, begann seine Kommentare zu schreiben, Änderungen vorzunehmen, nachdem die Dokumentation an unseren Devserver gesendet werden musste, dort haben wir Doxygen ausgeführt, das XML-Format erhalten, aber es entsprach nicht unserem DITA-XML-Standard.  Wir wussten davon vorher, schrieben einen bestimmten Konverter. <br><br>  Nachdem wir die Ausgabe von Doxygen erhalten hatten, haben wir alles durch den Konverter geleitet und bereits unser Format erhalten.  Dann wurde der Dokumentationssammler verbunden und wir haben dies alles auf einer externen Domain veröffentlicht.  Wir hatten sogar ein paar Iterationen Glück, alles hat für uns geklappt, wir waren begeistert.  Aber dann ging etwas schief.  Der technische Redakteur machte sich ebenfalls an die Arbeit, erhielt Aufgaben und Quellcodes vom Entwickler und nahm dort seine Korrekturen vor.  Danach ging er zum Entwickler, startete Doxygen und es gab ein Feuer. <br><br>  Wir beschlossen herauszufinden, was los war.  Dann haben wir festgestellt, dass Doxygen nicht für alle Sprachen geeignet ist.  Wir mussten den Code analysieren, über den er stolperte. Wir fanden Konstrukte, die Doxygen nicht unterstützte und die er nicht unterstützen wollte. <br><br>  Wir haben beschlossen, da wir an diesem Schema arbeiten, ein Vorverarbeitungsskript zu schreiben und diese Konstrukte irgendwie durch das zu ersetzen, was Doxygen akzeptiert, oder sie irgendwie zu ignorieren. <br><br><img src="https://habrastorage.org/webt/31/nj/bv/31njbvjvalsbxkeheuec9_exp8y.jpeg"><br><br>  Unser Zyklus begann so auszusehen.  Wir haben die Quellen erhalten, sie in den Devserver aufgenommen, dann das Vorverarbeitungsskript verbunden, den gesamten Überschuss aus dem Code herausgeschnitten, dann Doxygen in das Geschäft aufgenommen, das Doxygen-Ausgabeformat erhalten, auch den Konverter gestartet, unsere endgültigen DITA-XML-Dateien erhalten, dann den Dokumentationssammler verbunden und Wir haben unsere Dokumentation auf einer externen Domain veröffentlicht.  Es scheint, dass alles gut aussieht.  Ein Skript hinzugefügt, was ist da oben?  Anfangs gab es nichts.  Das Skript enthielt drei Zeilen, dann fünf, zehn Zeilen, und alles wuchs auf Hunderte von Zeilen an.  Wir haben festgestellt, dass wir anfangen, die meiste Zeit nicht damit zu verbringen, Dokumentation zu schreiben, sondern den Code zu analysieren, nach dem zu suchen, was nicht wohin kriecht, und das Skript einfach endlosen Stammgästen hinzuzufügen, vor Wahnsinn zu sitzen und darüber nachzudenken, was los ist. <br><br>  Wir erkannten, dass wir etwas ändern mussten, irgendwie aufhören mussten, bevor es zu spät war und bis unser Veröffentlichungszyklus bis zum Ende durchlief. <br><br>  Zum Beispiel sah das Vorverarbeitungsskript zunächst so aus und war harmlos. <br><br><img src="https://habrastorage.org/webt/wy/jb/3c/wyjb3caziotq1lpb6m7ifpmmywa.jpeg"><br><br>  Warum haben wir diesen Weg ursprünglich gewählt?  Warum schien er gut zu sein? <br><br><img src="https://habrastorage.org/webt/l2/ov/xz/l2ovxzkj5sxh7yvfads-gt-jmre.jpeg"><br><br>  Ein Generator ist großartig, hat ihn genommen, einmal angeschlossen, eingerichtet und funktioniert.  Es schien ein guter Ansatz zu sein.  Darüber hinaus können Sie eine einzige Kommentarsyntax für alle Sprachen gleichzeitig verwenden.  Sie haben eine Art Leitfaden geschrieben, ihn einmal verwendet, alle diese Konstruktionen sofort in den Code eingefügt und Ihre Arbeit erledigt, Kommentare geschrieben und sich nicht irgendwie auf die Syntax festgelegt. <br><br><img src="https://habrastorage.org/webt/oc/ye/p2/ocyep2kyrgtllrqgkkn7s5fk_bu.jpeg"><br><br>  Dies stellte sich jedoch als einer der großen Nachteile heraus.  Die Entwickler haben unsere gemeinsame Syntax nicht unterstützt, sie sind es gewohnt, ihre IDEs zu verwenden, es gibt bereits native Generatoren und ihre Syntax stimmte nicht mit unserer überein.  Dies war ein Stolperstein. <br><br>  Doxygen unterstützte auch neue Funktionen in Sprachen schlecht.  Er hat einen selektiven Ansatz, da er selbst in C ++ geschrieben ist, unterstützt er hauptsächlich C-ähnliche Sprachen und der Rest nach dem Restprinzip.  Und die Sprachen werden verbessert, Doxygen hält nicht ganz mit und es ist für uns ziemlich unpraktisch geworden. <br><br>  Dann passierte ein ziemliches Unglück.  Ein neues Team kam zu uns und sagte, dass wir über Swift schreiben und Doxygen überhaupt nicht mit ihm befreundet ist.  Wir haben erkannt, dass alles Zeit ist, anzuhalten und sich etwas Neues auszudenken.  Dann kamen noch ein paar Teams und wir stellten fest, dass unser Schema überhaupt nicht skalierbar ist.  Und wir fügen ständig etwas hinzu, wir haben mehrere dieser Skripte, sie leben in verschiedenen Zweigen und das wars.  Wir haben erkannt, dass wir akzeptieren müssen, was wir Pech hatten, neue Ansätze und Lösungen ausprobieren müssen, um sie zu finden.  Andrey wird dir davon erzählen. <br><br>  „Wir haben festgestellt, dass in unserem Fall irgendwo ein Universalgenerator auftauchte, aber als wir anfingen, alles zu skalieren, funktionierte der Plan größtenteils nicht.  Sie kamen kühl hoch und stimmten allen zu, die es tun, aber es hat nicht geklappt. <br><br>  Infolgedessen haben wir begonnen, ein neues Schema zu entwickeln.  Sie war mit einheimischen Generatoren zusammen.  Was haben wir jetzt in der Schaltung?      (     ,     ),   ,       Objective-C  Java,   ,    . <br><br><img src="https://habrastorage.org/webt/eu/zz/n3/euzzn3byjd1gj_r1aqixu22xy00.jpeg"><br><br>   ,            DITA XML,     ,  ,     ,    XML.           HTML,     .        — JavaDoc, AppleDoc, Jazzy.        HTML,      .     HTML,      ,   .          ,   HTML  .    ,    ,  ,    HTML,   .   XML ,       .     . <br><br>        . <br><br>   —     .  Doxygen     ,      ,   .  Objective-C,     ,  Java   . .       ,        ,         IDE   ,   IntelliSense,    ,    ,      ,   SDK,        ,    . . <br><br>          ,       ,  SDK , ,  ,      ,       HTML,   .      ,   ,      ,  ,   ,    . <br><br>        .     ,  -   ,       .  XML  ,  XML      . Doxygen ,    XML   .    HTML,  XML    .       .    —      . <br><br>   ,   ,  .       1500  ,      :    HTML,  CSS,     . <br><br>  ,       ,    . <br><br>     . ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>        — . .) <br><br>  ,     ,    . <br><br> —          .      ,     . -,        .               ,      .       ?    . <br><br>     ? -,    ,        ,        ,    . <br><br>      -   ,  -    , .           . <br><br>    ? -,  ,        ,    ,      . <br><br>          .       ,  ,  ,    ,     ,    ,      ,      . <br><br>      ,      .    ,         ,       ,  ,       ,       ,   . <br><br>     ?   —   ,      ,       , , ,    .    .        Bitbucket,     - . ,  . <br><br><img src="https://habrastorage.org/webt/tj/oe/bd/tjoebdjbu0vw3_0x4b1d1s5yowq.jpeg"><br><br>        ,         .     .    -   ,  - ,      ,     ,   ,  ,     ,    .     , ,   , , . <br><br><img src="https://habrastorage.org/webt/93/-f/er/93-feraw4qa0wapislbwtpqp0_g.jpeg"><br><br>   ,    ,     . <br><br>   ,     SDK , - ,       ,       .          -,        ,     ,    ,        . <br><br>     ,       .   .  — ,   ,         . <br><br>  ,             .        .     . <br><br>    ,  ,    ,     ,    ,  ,      . <br><br><img src="https://habrastorage.org/webt/pl/hz/zp/plhzzpdlpbx25kq--y9ob_sjqns.jpeg"><br><br>       ,         . <br><br>       .  -   ,      .       . <br><br><img src="https://habrastorage.org/webt/at/kb/6i/atkb6iazo-dxr0argrryvyxb5nm.jpeg"><br><br>  ,     ,     ,    ,       .      .     ,         ,     ,   -     .          ,      .      ,   ,    . <br><br>    ,      . <br><br>      .    ,      .      ,        ,    . <br><br>     ,        ,      ,   —  .     ,      ,    ,      . <br><br><img src="https://habrastorage.org/webt/_e/wc/ni/_ewcnixe3eef5qt_gv5bsg2p7xw.jpeg"><br><br>  dev  ,      (fork-dev)   ,     .       ,  doc-dev-en,   .    ,   ,   - ,        ,    . <br><br>     (fork-dev)     (doc-dev-ru)     .    ,      - .  .  ,      ,       doc-dev-ru,   .    , ,  -       ,      . <br><br>    ,      .         (doc-dev-en).     ,   ,        (doc-dev-en),   ,    .       ,        (fork-dev).    ,  ,     ,       ,     .    , ,    .       ,    dev  .   ,  ,  ,    . <br><br>        (fork-dev),      ,     .        (fork-dev),    ,     (doc-dev-en),  .        ,         ,          ,        .      ,       . <br><br><img src="https://habrastorage.org/webt/an/7i/cc/an7icc226xqwigkzswoglktczgo.jpeg"><br><br>   ,     ,  .  dev,   (fork-dev)  ,  (doc-dev-ru)   (doc-dev-en) .           (doc-dev-en),   (doc-dev-ru)   .      ,   . <br><br><img src="https://habrastorage.org/webt/sm/jm/xn/smjmxnw_fusyqrdequgjoy3wz0o.jpeg"><br><br>          .     dev  ,      ,   (branch-dev).         (branch-dev-ru),         (branch-dev).     ,      .     ,  .    — ,   —    - , ,    ,    ,    . <br><br>       ,    ,   .  ,   ,        (branch-dev)    .     ,      ,        . <br><br>           dev.   ,  ,   ,    ,   .        . <br><br>          (branch-dev-ru),          ,      (branch-dev-ru),    .   . <br><br>       .      (branch-dev),          .   , ,      ,   ,   ,  ,   ,  ,          .      ,   ,    .   ,      ,       . <br><br><img src="https://habrastorage.org/webt/tw/zz/xq/twzzxqq1kdd6dulttth__87guru.jpeg"><br><br>   ,      ,   ,          ,   .     . <br><br>  ,        ?   ,    , .        .    .      ,   -   ,       .        .        ,    . <br><br>    ,     ,    ,      ,        ,       . <br><br>     ,       .      .       .         .        ,     ,     . <br><br> —   —  .    —  . <br><br>       . .    ,  . ,    ,    ,     ,         ,   ,         . . <br><br>   ,     .    .       .       .    ,              .   ,     . -    , .       — .    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prozesse sollten für alle gleich bequem sein. </font><font style="vertical-align: inherit;">Deshalb haben wir keine Diktatur, wir kommen zu den Entwicklern und sagen: Lass uns den Brunch durcharbeiten. </font><font style="vertical-align: inherit;">Und sie sagen, dass sie durch Gabeln arbeiten. </font><font style="vertical-align: inherit;">Wir sagen: Nun, aber wir sind uns einig, dass wir auch Gabeln durcharbeiten. </font><font style="vertical-align: inherit;">Es muss vereinbart werden, dass alle an diesem Prozess Beteiligten - bei der Lokalisierung, dem Schreiben des Codes und der Dokumentation im Code - eine vereinbarte Position haben. </font><font style="vertical-align: inherit;">Es ist praktisch, wenn jeder seinen Verantwortungsbereich versteht - und nicht, wenn der technische Redakteur mit geschlossenen Augen arbeitet und den Code nicht sieht oder keinen Zugriff auf das Repository hat. </font><font style="vertical-align: inherit;">Das ist alles</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428057/">https://habr.com/ru/post/de428057/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428045/index.html">PHP Digest Nr. 142 (15. - 29. Oktober 2018)</a></li>
<li><a href="../de428047/index.html">Leistungsanalyse von WSGI-Servern: Setzen Sie uWSGI wieder ein</a></li>
<li><a href="../de428051/index.html">Wie man noch mehr ungültige Zustände noch unaussprechlicher macht</a></li>
<li><a href="../de428053/index.html">So erstellen Sie eine Teststrategie: Version von echten Ingenieuren</a></li>
<li><a href="../de428055/index.html">Rückblick auf Technologie-Startups. Z3 - der erste Relaiscomputer</a></li>
<li><a href="../de428059/index.html">Verbinden Sie den Multipath-LUN-Speicher mit VMware ESXi und Debian GNU / Linux</a></li>
<li><a href="../de428061/index.html">Projektkosten mit Earned Value Management verwalten</a></li>
<li><a href="../de428063/index.html">Browser verweigern die Unterstützung für TLS 1.0 und 1.1</a></li>
<li><a href="../de428065/index.html">Weniger bedeutet nicht schlimmer: Skyrmionen und Domänenwände in Ferromagneten</a></li>
<li><a href="../de428067/index.html">AntiFuzzing: Sicherheit durch Dunkelheit !?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>