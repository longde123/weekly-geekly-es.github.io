<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📖 😡 🕠 使用hashget将备份减少99.5％ ♥️ 👉🏾 🎩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="hashget是一个免费的，基于歌剧的重复数据删除器 -与存档程序类似的实用程序，它可以显着减少备份的大小，并组织增量和差异备份方案等等。 


 这是一篇介绍功能的评论文章。 在项目的README和Wiki文档中描述了hashget本身的使用（非常简单）。 
 比较方式 


 根据流派定律，我将...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用hashget将备份减少99.5％</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454826/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">hashget</a>是一个免费的，基于歌剧的<em>重复数据删除器</em> -与存档程序类似的实用程序，它可以显着减少备份的大小，并组织增量和差异备份方案等等。 </p><br><p> 这是一篇介绍功能的评论文章。 在项目的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">README</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wiki文档中</a>描述了hashget本身的使用（非常简单）。 </p><br><h1 id="sravnenie"> 比较方式 </h1><br><p> 根据流派定律，我将立即着手阴谋-比较结果： </p><br><div class="scrollable-table"><table><thead><tr><th> 数据样本 </th><th> 开箱尺寸 </th><th>  .tar.gz </th><th>  hashget .tar.gz </th></tr></thead><tbody><tr><td> 的WordPress的5.1.1 </td><td>  43兆位 </td><td>  11 Mb（26％） </td><td>  155 Kb（ <strong>0.3％</strong> ） </td></tr><tr><td>  Linux内核5.0.4 </td><td>  934 Mb </td><td>  161 Mb（20％） </td><td>  4.7 Mb（ <strong>0.5％</strong> ） </td></tr><tr><td>  Debian 9（LAMP）LXC虚拟机 </td><td>  724 Mb </td><td>  165 Mb（23％） </td><td>  4.1 Mb（ <strong>0.5％</strong> ） </td></tr></tbody></table></div><br><h1 id="predystoriya-kakim-dolzhen-byt-idealnyy-i-effektivnyy-bekap"> 理想和有效备份应该是什么的背景 </h1><br><p> 每次备份新创建的虚拟机时，都会感到自己做错了事。 为什么我要从一个我的无价无尽的创造力是单行index.html并带有文本“ Hello world”的系统中获取一份重要的备份？ </p><a name="habracut"></a><br><p> 为什么备份中有16 MB / usr / sbin / mysqld？ 我真的有幸能够存储这个重要文件吗？如果我做不到，它将对人类丢失？ 很有可能不会。 它存储在高度可靠的Debian服务器上（其可靠性和连续性无法与我提供的服务器相比），以及其他管理员的备份副本（数百万个）中。 为了增加可靠性，我们真的需要创建10,000,000 +此重要文件的第一个副本吗？ </p><br><p>通常， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">hashget</a>可以解决此问题。 打包时-它会创建一个非常小的备份。 拆包时-完全拆包的系统，类似于<code>tar -c</code> / <code>tar -x</code> 。  （换句话说，这是无损包装） </p><br><h1 id="kak-rabotaet-hashget"> 哈希如何工作 </h1><br><p>  Hashget具有Package和HashPackage的概念，借助它们的帮助，它可以执行重复数据删除。 </p><br><p>  <em>包装方式</em> 可以从网络上可靠下载的文件（通常是.deb或.tar.gz存档），可以从中获取一个或多个文件。 </p><br><p>  <em>HashPackage</em>是一个小的JSON文件，表示软件包，包括软件包URL和来自其中的文件的哈希总和（sha256）。 例如，对于大小为5兆字节的mariadb-server-core程序包，哈希程序包大小仅为6 KB。 小大约一千倍。 </p><br><p>  <em>重复数据删除</em> -创建一个没有重复文件的存档（如果重复数据删除器知道可以从何处下载原始软件包，它将减少存档中的重复数据）。 </p><br><h2 id="zapakovka"> 包装方式 </h2><br><p> 打包时，将查看打包目录中的所有文件，并考虑其哈希总和，如果在已知的HashPackage之一中找到了总和，则文件元数据（名称，哈希，权限等）将保存在特殊文件.hashget-restore.json中，也将包含在存档中。 </p><br><p> 在最简单的情况下，包装本身看起来并不比tar复杂： </p><br><pre> <code class="plaintext hljs">hashget -zf /tmp/mybackup.tar.gz --pack /path/to/data</code> </pre> <br><h2 id="raspakovka"> 开箱 </h2><br><p> 开箱分两个阶段。 首先，通常打开焦油包装： </p><br><pre> <code class="plaintext hljs">tar -xf mybackup.tar.gz -C /path/to/data</code> </pre> <br><p> 然后从网络还原： </p><br><pre> <code class="plaintext hljs">hashget -u /path/to/data</code> </pre> <br><p> 在恢复过程中，hashget读取.hashget-restore.json文件，下载必要的程序包，将其解压缩，然后提取必要的文件，并在必要的所有者/组/权限的正确路径中进行设置。 </p><br><h1 id="bolee-slozhnye-veschi"> 更复杂的事情 </h1><br><p> 对于那些“想像tar但将我的Debian打包成4兆字节”的人来说，上面描述的内容已经足够了。 此外，我们将研究更困难的事情。 </p><br><h2 id="indeksirovanie"> 索引编制 </h2><br><p> 如果一个hashget根本没有一个HashPackage，那么它根本就无法重复数据删除。 </p><br><p> 您也可以手动创建HashPackage（简单地： <code>hashget --submit https://wordpress.org/wordpress-5.1.1.zip -p my</code> ），但是有一种更方便的方法。 </p><br><p> 为了获得所需的哈希包，有一个<em>索引</em>步骤（在使用<code>--pack</code>命令时自动执行）和<em>启发式</em> 。 编制索引时，hashget将每个找到的文件“馈送”到它感兴趣的所有现有试探法中。 然后，启发式方法可以索引任何Package来创建HashPackage。 </p><br><p> 例如，Debian启发式喜欢文件/ var / lib / dpkg / status，并检测已安装的debian软件包，如果未对它们进行索引（尚未为其创建HashPackage），则下载并对其进行索引。 结果是非常令人愉悦的效果-hashget将始终有效地对Debian OS进行重复数据删除，即使它们具有最新的软件包。 </p><br><h2 id="fayly-podskazki-hinty"> 提示文件 </h2><br><p> 如果您的网络使用了某种哈希包启发式方法中未包含的专有包或公共包，则可以向其添加一个简单的hashget-hint.json提示文件，如下所示： </p><br><pre> <code class="plaintext hljs">{ "project": "wordpress.org", "url": "https://ru.wordpress.org/wordpress-5.1.1-ru_RU.zip" }</code> </pre> <br><p> 此外，每次创建存档时，都将对包建立索引（如果以前没有索引），并且包文件将从存档中删除重复数据。 无需编程，一切都可以通过vim完成并保存在每个备份中。 请注意，由于采用了哈希方法，如果在本地更改了软件包中的某些文件（例如，更改了配置文件），则更改后的文件将“按原样”保存在归档中，并且不会减少。 </p><br><p> 如果您自己的某些软件包会定期更新，但是更改不是很大，则只能提示主要版本。 例如，在1.0版中，他们提出了一个提示，指示mypackage-1.0.tar.gz，它将完全进行重复数据删除，然后他们发布了版本1.1（略有不同），但并未更新该提示。 不用担心。 仅对与1.0版匹配（可以还原）的文件进行重复数据删除。 </p><br><p> 处理提示文件的启发式方法是理解启发式方法内部机制的一个很好的例子。 它仅处理hashget-hint.json文件（或带点的.hashget-hint.json文件），并忽略其他所有文件。 使用此文件，它确定应为哪个程序包URL编制索引，并通过hashget对其进行索引（如果之前未完成此操作） </p><br><h2 id="hashserver"> 散列 </h2><br><p> 在创建备份时完全执行索引将非常耗时。 为此，您需要下载每个程序包，解压缩，索引。 因此，hashget使用带有HashServer的方案。 如果安装了debian软件包（如果在本地HashPackage中找不到该软件包），则首先尝试简单地从哈希服务器下载HashPackage。 并且只有在这种方法无法解决的情况下-hashget才会下载并哈希该程序包（并上传到hashserver，以便hashserver稍后提供）。 </p><br><p>  HashServer-方案的可选元素，不是关键，仅用于加速和减少存储库上的负载。 它很容易断开连接（使用不带参数的<code>--hashserver</code>选项）。 此外，您可以轻松<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建自己的hashserver</a> 。 </p><br><h2 id="inkrementalnye-i-differencialnye-bekapy-zaplanirovannoe-ustarevanie"> 增量和差异备份，计划过时 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">hashget</a>使创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">增量备份和差异备份</a>变得非常简单。 为什么我们不索引备份本身（包含所有唯一文件）？ 一个团队- <code>--submit</code> ，您就完成了！  hashget将创建的下一个备份将不包含该存档中的文件。 </p><br><p> 但这不是一个很好的方法，因为可能会发现，在恢复过程中，我们将不得不提取整个历史记录的所有哈希备份（如果每个备份至少具有一个唯一文件）。 为此，有一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计划的备份过时</a>机制。 编制索引时，您可以指定HashPackage <code>--expires 2019-06-01</code>的到期日期，并且在该日期之后（从00:00开始），它将不再使用。 在此日期之后无法删除存档本身（尽管hashget可以方便地显示我们在当前或任何日期腐烂/腐烂的所有备份的URL）。 </p><br><p> 例如，如果您在第一天进行了完整备份，并在月末之前使用了生命周期进行索引，那么我们将获得差异备份方案。 </p><br><p> 如果我们还索引新的备份，将有一个增量备份的方案。 </p><br><p> 与传统方案不同，hashget允许您使用几种基本资源。 由于先前备份中的文件减少（如果有），并且由于公共文件（可以下载的内容），因此备份将减少。 </p><br><p> 如果由于某种原因我们不信任Debian资源的可靠性（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://snapshot.debian.org/</a> ）或使用其他发行版，我们可以对所有软件包进行一次完整备份，然后再依赖它（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">禁用启发式）</a> ） 现在，如果我们发现发行版中的所有服务器都无法访问（在纪念品Internet或僵尸启示录中），但我们的备份是有条理的-我们可以从仅依赖于先前备份的任何短差异备份中恢复。 </p><br><blockquote>  Hashget只能自行决定依赖可靠的恢复来源。 您认为可靠的-将使用那些。 </blockquote><br><h2 id="filepool-i-glacier">  FilePool和冰川 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FilePool</a>机制使您不必不断访问外部服务器来下载软件包，而可以使用本地目录或公司服务器中的软件包，例如： </p><br><pre> <code class="plaintext hljs">$ hashget -u . --pool /tmp/pool</code> </pre> <br><p> 或 </p><br><pre> <code class="plaintext hljs">$ hashget -u . --pool http://myhashdb.example.com/</code> </pre> <br><p> 要在本地目录中创建池-只需创建一个目录并上传文件到该目录中，hashget本身就会通过哈希找到所需的内容。 为了使池可以通过HTTP访问，您需要以一种特殊的方式创建符号链接，这是通过一个命令来完成的（ <code>hashget-admin --build /var/www/html/hashdb/ --pool /tmp/pool</code> ）。  HTTP FilePool本身是一个静态文件，因此任何简单的Web服务器都可以为它提供服务，服务器上的负载几乎为零。 </p><br><p> 多亏了FilePool，不仅http资源可以用作基本资源，而且Amazon Glacier也可以用作基本资源。 </p><br><p> 备份上传到冰川后，我们获取其上传ID并将其用作URL。 例如： </p><br><pre> <code class="plaintext hljs">hashget --submit Glacier_Upload_ID --file /tmp/my-glacier-backup.tar.gz --project glacier --hashserver --expires 2019-09-01</code> </pre> <br><p> 现在，新的（差异）备份将依赖于此备份，并且将更短。  tar解压缩diffback后，我们可以看到它依赖哪些资源： </p><br><pre> <code class="plaintext hljs">hashget --info /tmp/unpacked/ list</code> </pre> <br><p> 只需使用shell脚本将所有这些文件从冰川下载到池中，然后运行通常的恢复操作即可：hashget -u / tmp / unpacked --pool / tmp / pool </p><br><h3 id="stoit-li-ovchinka-vydelki"> 游戏值得蜡烛吗 </h3><br><p> 在最简单的情况下，您只需为备份支付较少的费用（如果您将它们存储在云中某个地方以赚钱）。 也许-少得多。 </p><br><p> 但这不是唯一的一个。 数量变成质量。 您可以使用它来获得高质量的备份方案升级。 例如，由于我们的备份现在更短-您不能每月备份，而每天备份。 保持它们不像以前那样保存六个月，而是保存五年。 以前，它们存储在缓慢但便宜的“冷”存储器（冰川）中，现在您可以热存储，从那里总是可以快速下载备份并在几分钟之内恢复，而不是一天之内。 </p><br><p> 您可以提高备份存储的可靠性。 如果现在将它们存储在一个存储中，则可以减少备份量-我们可以将其存储在2-3个存储中，如果其中一个损坏，则可以安全地生存。 </p><br><h3 id="kak-poprobovat-i-nachat-polzovatsya"> 如何尝试并开始使用？ </h3><br><p> 我们转到gitlab页面<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://gitlab.com/yaroslaff/hashget</a> ，使用一个命令（ <code>pip3 install hashget[plugins]</code> ）安装它，然后阅读并执行快速<code>pip3 install hashget[plugins]</code> 。 我认为所有简单的事情都需要-需要10-15分钟。 然后，您可以尝试摇动您的虚拟机，创建必要的提示文件，进行更严格的挤压，使用池，本地哈希数据库和哈希服务器（如果有意思的话），然后第二天看看昨天的增量备份的大小。 </p><br><h3 id="restic--hashget">  Restic + HashGet </h3><br><p>  <em>（本章稍后添加。感谢评论员的批评和动力。）</em> </p><br><p> 有一个很好的方便备份工具– <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Restic</a> 。 它也可以执行重复数据删除，但只能在存储库中执行，而外部<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">哈希</a>删除则<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">很容易</a> ，而<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">hashget很容易</a>做到这一点。 但是结合<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">restic + hashget</a> ，我们设法利用两种方法的优势！ </p><br><p> 准备（解压wordpress并将其编入索引）： </p><br><pre> <code class="plaintext hljs"># wget -q https://wordpress.org/wordpress-5.2.2.tar.gz # hashget --submit https://wordpress.org/wordpress-5.2.2.tar.gz -p my --file wordpress-5.2.2.tar.gz --hashserver # tar -xf wordpress-5.2.2.tar.gz # du -sh wordpress 46M wordpress</code> </pre> <br><p> 通过添加快照到restic </p><br><pre> <code class="plaintext hljs"># hashget -X exclude-list --prepack wordpress --hashserver Saved: 1468 files, 1 pkgs, size: 40.5M. Download: 10.7M # restic --exclude-file exclude-list backup wordpress password is correct scan [/tmp/wp/wordpress] scanned 193 directories, 367 files in 0:02 [0:04] 100.00% 700.829 KiB / 700.829 KiB 560 / 560 items 0 errors ETA 0:00 duration: 0:04 snapshot 76b54230 saved # du -sh /tmp/restic-repo/ 2,1M /tmp/restic-repo/</code> </pre> <br><p> 在此阶段，我们添加了目录快照（40+ Mb），存储库大小仅增加了1 Mb。 </p><br><p> 恢复通过两个命令完成： </p><br><pre> <code class="plaintext hljs"># restic restore 76b54230 -t unpacked password is correct restoring &lt;Snapshot 76b54230 of [/tmp/wp/wordpress] at 2019-06-19 04:30:55.760618336 +0700 +07 by root@braconnier&gt; to unpacked # hashget -u unpacked/wordpress/ --hashserver Recovered 1468/1468 files 40.5M bytes (0 downloaded, 0 from pool, 10.7M cached) in 1.56s</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN454826/">https://habr.com/ru/post/zh-CN454826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN454810/index.html">火星上的新鲜空气：弯曲二氧化碳分子并吸收氧气</a></li>
<li><a href="../zh-CN454816/index.html">在WSL下配置php-fpm + nginx捆绑包</a></li>
<li><a href="../zh-CN454818/index.html">Rekko Challenge-如何在推荐系统的创建中获得第二名</a></li>
<li><a href="../zh-CN454820/index.html">Azure搜索</a></li>
<li><a href="../zh-CN454824/index.html">离散元件上最简单的运算放大器</a></li>
<li><a href="../zh-CN454828/index.html">创建马赛克图片</a></li>
<li><a href="../zh-CN454830/index.html">成功的产品经理的三项关键素质：亚历山大·别利亚耶夫（Alexander Belyaev）</a></li>
<li><a href="../zh-CN454832/index.html">为什么每周工作四天是一个坏故事</a></li>
<li><a href="../zh-CN454834/index.html">低动力的触摸打字研究的真正术语</a></li>
<li><a href="../zh-CN454840/index.html">带着妻子和抵押贷款小心地搬到荷兰。 第2部分：准备文件和移动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>