<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😕 🧑🏾 🚅 API JSON - kami bekerja sesuai dengan spesifikasi 🧓🏼 👊🏽 🌄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, pengembangan web telah dibagi. Sekarang kita tidak semua pemrogram stack penuh - kita adalah front-end dan back-end. Dan hal yang palin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API JSON - kami bekerja sesuai dengan spesifikasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433322/">  Baru-baru ini, pengembangan web telah dibagi.  Sekarang kita tidak semua pemrogram stack penuh - kita adalah front-end dan back-end.  Dan hal yang paling sulit tentang ini, seperti halnya di tempat lain, adalah masalah interaksi dan integrasi. <br><br>  Frontend dengan backend berinteraksi melalui API.  Dan seluruh hasil pengembangan tergantung pada apa API itu, seberapa baik atau buruk backend dan frontend telah sepakat di antara mereka sendiri.  Jika kita semua mulai berdiskusi bersama bagaimana melakukan upgrade, dan menghabiskan sepanjang hari untuk mengerjakannya, kita mungkin tidak mendapatkan tugas bisnis. <br><br>  Agar tidak tergelincir dan berkembang biak tentang nama-nama variabel, Anda memerlukan spesifikasi yang baik.  Mari kita bicara tentang bagaimana rasanya membuat hidup lebih mudah bagi semua orang.  Pada saat yang sama, kami akan menjadi ahli dalam gudang sepeda. <br><br><img src="https://habrastorage.org/webt/o4/me/1u/o4me1uwmahvlwsnvqxyf_rzwa1i.jpeg"><br><a name="habracut"></a><br>  Mari kita mulai dari jauh - dengan masalah yang sedang kita pecahkan. <br><br>  Dahulu kala, pada tahun 1959, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cyril Parkinson</a> (jangan bingung dengan penyakitnya, dia adalah seorang penulis dan tokoh ekonomi) muncul dengan beberapa undang-undang yang menarik.  Misalnya, bahwa pengeluaran tumbuh dengan pendapatan, dll.  Salah satunya disebut Hukum Triviality: <br><br><blockquote>  Waktu yang dihabiskan untuk mendiskusikan item berbanding terbalik dengan jumlah yang dipertimbangkan. <br></blockquote><br>  Parkinson adalah seorang ekonom, jadi dia menjelaskan hukumnya dalam istilah ekonomi, kira-kira seperti ini.  Jika Anda datang ke dewan direksi dan mengatakan bahwa Anda membutuhkan $ 10 juta untuk membangun pembangkit listrik tenaga nuklir, kemungkinan besar masalah ini akan dibahas jauh lebih sedikit daripada alokasi 100 pound untuk gudang sepeda untuk karyawan.  Karena semua orang tahu cara membangun gudang sepeda, setiap orang memiliki pendapatnya sendiri, semua orang merasa penting dan ingin berpartisipasi, dan pembangkit listrik tenaga nuklir adalah sesuatu yang abstrak dan jauh, 10 juta juga belum pernah terlihat - ada sedikit pertanyaan. <br><br>  Pada tahun 1999, hukum sepele Parkinson muncul dalam pemrograman, yang kemudian dikembangkan secara aktif.  Dalam pemrograman, hukum ini ditemukan terutama dalam literatur berbahasa Inggris dan terdengar seperti metafora.  Itu disebut <strong>efek Bikeshed</strong> (efek dari gudang sepeda), tetapi esensinya sama - kami siap untuk gudang sepeda dan ingin membahas lebih lama daripada pembangunan pembangkit listrik. <br><br>  Istilah ini diciptakan oleh pengembang Denmark Poul-Henning Kamp, yang terlibat dalam pembuatan FreeBSD.  Selama proses desain, tim menghabiskan waktu yang sangat lama untuk mendiskusikan bagaimana fungsi tidur seharusnya bekerja.  Ini adalah kutipan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">surat dari</a> Poul-Henning Kamp (pengembangan kemudian dilakukan dalam korespondensi email): <br><br><blockquote>  Itu adalah proposal untuk membuat tidur (1) DTRT Jika diberi argumen non-integer yang membuat ini mematikan rumput saya tidak akan mengatakan lebih banyak tentang itu, karena itu adalah barang yang jauh lebih kecil daripada yang akan harapkan dari panjang utasnya, dan sudah mendapat perhatian lebih dari beberapa * masalah * yang kita miliki di sini. <br></blockquote><br>  Dalam surat ini, dia mengatakan bahwa ada banyak masalah yang jauh lebih penting yang belum terselesaikan: "Jangan berurusan dengan gudang sepeda, kita akan melakukan sesuatu dengan ini dan melanjutkan!" <br><br>  Jadi Poul-Henning Kamp pada tahun 1999 memperkenalkan istilah efek bikeshed ke dalam literatur berbahasa Inggris, yang dapat diulangi menjadi: <br><br><blockquote>  Jumlah noise yang diciptakan oleh perubahan kode berbanding terbalik dengan kompleksitas perubahan. <br></blockquote><br>  Semakin sederhana penambahan atau perubahan yang kita buat, semakin banyak pendapat yang perlu kita dengar tentang hal itu.  Saya pikir banyak yang bertemu ini.  Jika kita memecahkan pertanyaan sederhana, misalnya, bagaimana memberi nama variabel, itu tidak masalah untuk mesin - pertanyaan ini akan menyebabkan sejumlah besar holivar.  Tetapi serius, sangat penting untuk masalah bisnis yang tidak dibahas dan pergi di latar belakang. <br><br>  Menurut Anda apa yang lebih penting: bagaimana kita berkomunikasi antara backend dan frontend, atau tugas bisnis yang kita lakukan?  Semua orang berpikir berbeda, tetapi pelanggan mana pun, orang yang mengharapkan Anda membawakannya uang, akan mengatakan: "Kerjakan tugas bisnis kami kepada saya!"  Dia benar-benar tidak peduli bagaimana Anda mentransfer data antara backend dan frontend.  Mungkin dia bahkan tidak tahu apa itu backend dan frontend. <br><br>  Untuk meringkas pendahuluan, saya ingin mengatakan: <strong>API adalah gudang sepeda.</strong> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1cJVwn44iSc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan</a></em> <em>presentasi</em> <br><br>  <strong>Tentang pembicara:</strong> Alexey Avdeev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Avdeev</a> ) bekerja untuk perusahaan Neuron.Digital, yang menangani neuron dan membuat tampilan keren untuk mereka.  Alex juga memperhatikan OpenSource, dan menyarankan semua orang.  Dia telah terlibat dalam pengembangan untuk waktu yang lama - sejak 2002, dia menemukan Internet kuno, ketika komputer besar, internet kecil, dan kurangnya JS tidak mengganggu siapa pun dan semua orang membuat situs di atas meja. <br><br><h2>  Bagaimana cara menangani gudang sepeda? <br></h2><br>  Setelah Cyril Parkinson yang terhormat menyimpulkan hukum kesederhanaan, ia banyak dibahas.  Ternyata efek dari gudang sepeda di sini dapat dengan mudah dihindari: <br><br><ol><li>  <strong>Jangan dengarkan saran.</strong>  Saya pikir idenya begitu - jika Anda tidak mendengarkan kiatnya, Anda dapat melakukan hal seperti itu, terutama dalam pemrograman, dan terutama jika Anda adalah pengembang pemula. <br></li><li>  <strong>Lakukan seperti yang kamu inginkan.</strong>  "Aku seorang seniman, begitu!"  - tidak ada efek bikeshed, semua yang Anda butuhkan sudah selesai, tetapi hal-hal yang sangat aneh muncul pada output.  Ini sering ditemukan dalam freelance.  Tentunya Anda menemukan tugas yang harus Anda selesaikan untuk pengembang lain dan implementasi yang menyebabkan Anda kebingungan. <br></li><li>  <strong>Apakah penting untuk bertanya pada diri sendiri?</strong>  Jika tidak, Anda bisa saja tidak membahasnya, tetapi itu adalah masalah kesadaran pribadi. <br></li><li>  <strong>Gunakan kriteria objektif.</strong>  Saya akan berbicara tentang hal ini dalam laporan ini.  Untuk menghindari efek dari gudang sepeda, Anda dapat menggunakan kriteria yang secara objektif mengatakan mana yang lebih baik.  Mereka ada. <br></li><li>  <strong>Jangan bicara tentang apa yang tidak ingin Anda dengarkan.</strong>  Di perusahaan kami, pengembang backend awal adalah introvert, sehingga mereka melakukan sesuatu yang tidak mereka katakan kepada orang lain.  Akibatnya, kami menemukan kejutan.  Metode ini berfungsi, tetapi dalam pemrograman itu bukan pilihan terbaik. <br></li><li>  Jika Anda tidak peduli dengan masalah tersebut, Anda bisa <strong>membiarkannya pergi atau memilih salah satu opsi</strong> yang <strong>diusulkan</strong> yang muncul dalam proses holivarov. <br></li></ol><br><h2>  Alat anti-bikeshedding <br></h2><br>  Saya ingin berbicara tentang <strong>alat obyektif</strong> untuk menyelesaikan masalah gudang sepeda.  Untuk mendemonstrasikan apa alat anti-bikeshedding, saya akan menceritakan sedikit kisah. <br><br>  Bayangkan kita memiliki pengembang backend pemula.  Dia baru-baru ini datang ke perusahaan, dan dia diperintahkan untuk merancang layanan kecil, misalnya, sebuah blog, di mana Anda perlu menulis protokol REST. <br><br><img src="https://habrastorage.org/webt/zn/9m/uk/zn9muk80uvsd_yuragws16ms70c.png">  <em>Roy Fielding, penulis REST</em> <br><br>  Dalam foto tersebut, Roy Fielding, yang pada tahun 2000 membela tesisnya "Gaya arsitektur dan desain arsitektur perangkat lunak jaringan" dan dengan demikian memperkenalkan istilah REST.  Selain itu, ia menemukan HTTP dan, pada kenyataannya, adalah salah satu pendiri Internet. <br><br>  REST adalah seperangkat prinsip arsitektur yang mengatakan bagaimana merancang protokol REST, API REST, layanan RESTful.  Ini adalah prinsip arsitektur yang cukup abstrak dan kompleks.  Saya yakin tidak ada di antara Anda yang pernah melihat API yang dibuat sepenuhnya sesuai dengan semua prinsip RESTful. <br><br><h2>  Persyaratan Arsitektur REST <br></h2><br>  Saya akan memberikan beberapa persyaratan untuk protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">REST</a> , yang kemudian akan saya rujuk dan andalkan.  Ada cukup banyak dari mereka, Anda dapat membacanya lebih lanjut di Wikipedia. <br><br>  1. <strong>Model client-server.</strong> <br>  Prinsip REST yang paling penting, yaitu interaksi kita dengan backend.  Menurut REST, backend adalah server, front-end adalah klien, dan kami berkomunikasi dalam format client-server.  Perangkat seluler juga merupakan klien.  Pengembang untuk jam tangan, untuk lemari es, layanan lain - juga mengembangkan bagian klien.  API RESTful adalah server yang diakses klien. <br><br>  2. <strong>Kurangnya kondisi.</strong> <br>  Tidak boleh ada keadaan di server, yaitu, semua yang diperlukan untuk jawaban datang dalam permintaan.  Ketika sebuah sesi disimpan di server, dan tergantung pada sesi ini jawaban yang berbeda datang, ini merupakan pelanggaran prinsip REST. <br><br>  3. <strong>Keseragaman antarmuka.</strong> <br>  Ini adalah salah satu prinsip dasar yang mendasari di mana REST API harus dibangun.  Ini termasuk yang berikut: <br><br><ul><li>  Identifikasi sumber daya adalah bagaimana kita harus membangun URL.  Pada REST, kami beralih ke server untuk beberapa jenis sumber daya. </li><li>  Manipulasi sumber daya melalui presentasi.  Server mengembalikan kita pandangan yang berbeda dari apa yang ada di database.  Tidak masalah jika Anda menyimpan informasi dalam MySQL atau PostgreSQL - kami memiliki pandangan. </li><li>  Pesan yang menggambarkan diri sendiri - yaitu, pesan berisi id, tautan tempat Anda bisa mendapatkan pesan ini lagi - semua yang diperlukan untuk bekerja dengan sumber daya ini lagi. </li><li>  Hypermedia adalah tautan ke tindakan berikut dengan sumber daya.  Menurut saya tidak ada REST API yang melakukannya, tetapi dijelaskan oleh Roy Fielding. </li></ul><br>  Ada 3 prinsip lagi yang tidak saya kutip karena tidak penting untuk cerita saya. <br><br><h2>  Blog yang tenang <br></h2><br>  Kembali ke pengembang backend awal, yang diminta untuk membuat layanan untuk blog di RESTful.  Di bawah ini adalah contoh prototipe. <br><br><img src="https://habrastorage.org/webt/op/wi/6l/opwi6l_tbihj0tvef8tu4feyoo4.png"><br><br>  Ini adalah situs di mana ada artikel, Anda dapat mengomentarinya, artikel dan komentar memiliki penulis - cerita standar.  Pengembang backend pemula kami akan melakukan RESTful API untuk blog ini. <br><br>  Kami bekerja dengan semua data blog berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRUD</a> . <br><img src="https://habrastorage.org/webt/4i/rk/hm/4irkhm7dcicexgmqomprfdraisu.png"><br>  Seharusnya dimungkinkan untuk membuat, membaca, memperbarui, dan menghapus sumber daya apa pun.  Mari kita coba meminta pengembang backend kami untuk membangun AP yang tenang berdasarkan prinsip CRUD.  Artinya, tulis metode untuk membuat artikel, dapatkan daftar artikel atau satu artikel, perbarui dan hapus. <br><br>  Mari kita lihat bagaimana dia bisa melakukannya. <br><img src="https://habrastorage.org/webt/m2/i2/ua/m2i2uadak8sdzbge_pvqlnpu55s.png"><br><br>  <strong>Semuanya salah dengan semua prinsip REST</strong> .  Hal yang paling menarik adalah ia bekerja.  Saya benar-benar mendapatkan API yang terlihat seperti ini.  Bagi pelanggan, ini adalah gudang sepeda, bagi pengembang itu adalah kesempatan untuk bersantai dan berdebat, dan bagi pengembang pemula, ini hanyalah dunia baru yang besar dan berani tempat ia tersandung setiap kali, jatuh, menghancurkan kepalanya.  Dia harus mengulanginya lagi dan lagi. <br><img src="https://habrastorage.org/webt/k1/nj/lm/k1njlm8egbrcguim8am6juym76s.png"><br><br>  Ini adalah opsi REST.  Berdasarkan prinsip-prinsip mengidentifikasi sumber daya, kami bekerja dengan sumber daya - dengan artikel dan menggunakan metode HTTP yang diusulkan oleh Roy Fielding.  Dia tidak bisa tidak menggunakan pekerjaan sebelumnya dalam pekerjaan berikutnya. <br><br>  Untuk memperbarui artikel, banyak yang menggunakan metode PUT, yang memiliki semantik yang sedikit berbeda.  Metode PATCH memperbarui bidang yang disahkan, dan PUT hanya mengganti satu artikel dengan yang lain.  Secara semantik, PATCH digabung, dan PUT diganti. <br><br>  Pengembang backend pemula kami jatuh, mereka mengambilnya dan berkata: "Semuanya beres, lakukan seperti itu," dan dia dengan jujur ​​mengubahnya.  Tapi kemudian dia akan menemukan jalan panjang yang sangat jauh melalui duri. <br><br>  <strong>Kenapa begitu benar?</strong> <br><br><ul><li>  karena Roy Fielding berkata demikian; </li><li>  karena itu ISTIRAHAT; </li><li>  karena ini adalah prinsip arsitektur yang menjadi dasar profesi kita sekarang. </li></ul><br>  Namun, ini adalah "gudang sepeda", dan metode sebelumnya akan berhasil.  Komputer dikomunikasikan sebelum REST, dan semuanya berfungsi.  Tapi sekarang standar telah muncul di industri. <br><br><h2>  Hapus artikel <br></h2><br>  Pertimbangkan contoh menghapus artikel.  Misalkan ada normal, metode sumber daya HAPUS / artikel, yang menghapus artikel dengan id.  HTTP berisi tajuk.  Header Terima menerima jenis data yang ingin diterima klien sebagai respons.  Junior kami menulis sebuah server yang mengembalikan 200 OK, Content-Type: application / json, dan mengirimkan tubuh kosong: <br><br> <code>01. <b><font color="#c6e90e">DELETE /articles/</font></b> 1 /1.1 <br> 02. Accept: <b><font color="#c6e90e">application/json</font></b></code> <br> <br> <code>01. HTTP/1.1 200 OK <br> 02. Content-Type: <b><font color="#c6e90e">application/json</font></b> <br> 03. null <br></code> <br>  Kesalahan yang sangat <strong>umum telah dibuat di sini - tubuh kosong</strong> .  Semuanya tampaknya logis - artikel telah dihapus, 200 OK, header aplikasi / json hadir, tetapi kemungkinan besar klien akan jatuh.  Ini akan melempar kesalahan karena benda kosong tidak valid.  Jika Anda pernah mencoba untuk mengurai string kosong, maka Anda dihadapkan dengan fakta bahwa setiap parser json tersandung dan jatuh pada ini. <br><br>  Bagaimana cara memperbaiki situasi ini?  Mungkin pilihan terbaik adalah lulus json.  Jika kami menyatakan: "Terima, beri kami json", server mengatakan: "Jenis-Konten, saya beri Anda json", beri json.  Objek kosong, array kosong - letakkan sesuatu di sana - ini akan menjadi solusi, dan itu akan berhasil. <br><br>  Masih ada solusinya.  Selain 200 OK, ada kode respons 204 - tidak ada konten.  Dengannya, Anda tidak bisa mentransmisikan tubuh.  Tidak semua orang tahu tentang ini. <br><br>  Jadi saya mengarahkan ke jenis media. <br><br><h3>  Jenis pantomim <br></h3><br>  Jenis media seperti ekstensi file, hanya di web.  Ketika kami mengirimkan data, kami harus menginformasikan atau meminta jenis apa yang ingin kami terima sebagai tanggapan. <br><br><ul><li>  Secara default, ini teks / polos - hanya teks. </li><li>  Jika tidak ada yang ditentukan, maka browser kemungkinan besar akan berarti aplikasi / octet-stream - hanya sedikit aliran. </li></ul><br>  Anda dapat menentukan jenis tertentu saja: <br><br><ul><li>  aplikasi / pdf; </li><li>  gambar / png; </li><li>  aplikasi / json; </li><li>  aplikasi / xml; </li><li>  application / vnd.ms-excel. </li></ul><br>  Header-Jenis Konten dan Terima adalah dan penting. <br><br><blockquote>  API dan klien harus lulus header Tipe-Konten dan Terima. <br></blockquote><br>  Jika API Anda dibangun di JSON, selalu sampaikan Accept: application / json dan Content-Type application / json. <br><br>  Jenis file contoh. <br><img src="https://habrastorage.org/webt/jd/v_/aa/jdv_aarpo9qnevtro5ddqbgw5ic.png"><br><br>  Jenis media mirip dengan jenis file ini, hanya di Internet. <br><br><h3>  Kode Jawaban <br></h3><br>  Contoh berikutnya dari petualangan pengembang junior kami adalah kode respons. <br><br><img src="https://habrastorage.org/webt/o4/tc/ci/o4tcci6wnmokubjjdecsy5vwclm.png"><br><br>  Tingkat respons terlucu adalah 200 OK.  Semua orang mencintainya - itu berarti semuanya berjalan dengan baik.  Saya bahkan punya kasing - Saya menerima <strong>kesalahan 200 OK</strong> .  Sesuatu benar-benar jatuh pada server, sebagai respons terhadap respons, muncul halaman HTML di mana kesalahan HTML telah dikompilasi.  Saya meminta aplikasi json dengan kode 200 OK, dan berpikir bagaimana cara mengatasinya?  Anda pergi dengan tanggapan, mencari kata "kesalahan", Anda berpikir bahwa ini adalah kesalahan. <br><br>  Ini berfungsi, bagaimanapun, dalam HTTP ada banyak kode lain yang dapat Anda gunakan, dan REST merekomendasikan agar Anda menggunakannya pada REST.  Misalnya, pembuatan entitas (artikel) dapat dijawab: <br><br><ul><li>  <strong>201 Created</strong> adalah kode yang berhasil.  Artikel ini dibuat, sebagai tanggapan Anda perlu mengembalikan artikel yang dibuat. </li><li>  <strong>202 Diterima</strong> artinya permintaan telah diterima, tetapi hasilnya nanti.  Ini adalah operasi jangka panjang.  Pada Diterima, tidak ada badan yang dapat dikembalikan.  Artinya, jika Anda tidak memberikan Tipe-Konten dalam respons, maka tubuh mungkin juga tidak.  Atau Teks / Pesawat Jenis Konten - itu saja, tidak ada pertanyaan.  String kosong adalah teks / bidang yang valid. </li><li>  <strong>204 Tidak Ada Konten</strong> - tubuh mungkin sama sekali tidak ada. </li><li>  <strong>403 Forbidden</strong> - Anda tidak diizinkan membuat artikel ini. </li><li>  <strong>404 Tidak Ditemukan</strong> - Anda naik di tempat yang salah, tidak ada cara seperti itu, misalnya. </li><li>  <strong>409 Konflik</strong> adalah kasus ekstrem yang digunakan beberapa orang.  Terkadang diperlukan jika Anda membuat id pada klien, dan bukan pada backend, dan pada saat itu seseorang sudah berhasil membuat artikel ini.  Konflik adalah jawaban yang tepat dalam kasus ini. </li></ul><br><h3>  Penciptaan Entitas <br></h3><br>  Contoh berikut: kita membuat entitas, misalnya Content-Type: application / json, dan meneruskan aplikasi ini / json.  Ini membuat klien - frontend kami.  Mari kita buat artikel ini: <br><br> <code>01. POST /articles /1.1 <br> 02. Content-Type: application/json <br> 03. { "id": 1, "title": " JSON API"}</code> <br> <br>  Kode mungkin datang sebagai respons: <br><br><ul><li>  422 Entitas yang tidak dapat diproses - Entitas yang tidak diproses.  Semuanya tampak hebat - semantik, ada kode; </li><li>  403 Dilarang </li><li>  500 Galat Server Internal. </li></ul><br>  Tetapi benar-benar tidak dapat dipahami apa yang sebenarnya terjadi: entitas apa yang tidak diproses, mengapa saya tidak pergi ke sana, dan apa yang akhirnya terjadi pada server? <br><br><h3>  Kembalikan kesalahan <br></h3><br>  Pastikan (dan junior tidak tahu tentang ini) sebagai respons, kembalikan kesalahan.  Ini semantik dan benar.  Ngomong-ngomong, Fielding tidak menulis tentang ini, yaitu, ia diciptakan kemudian dan dibangun di atas REST. <br><br>  Backend dapat mengembalikan array dengan kesalahan sebagai respons, mungkin ada beberapa. <br><br> <code>01. HTTP/1.1 422 Unprocessable Entity <br> 02. Content-Type: application/json <br> 03. <br> 04. { "errors": [{ <br> 05.   "status": "422", <br> 06. <b><font color="#c6e90e">"title": "Title already exist",</font></b> <br> 07. }]}</code> <br> <br>  Setiap kesalahan dapat memiliki status dan judulnya sendiri.  Ini hebat, tetapi sudah berjalan di tingkat konvensi di atas REST.  Ini bisa menjadi alat anti-bikeshedding kami untuk segera berhenti berdebat dan membuat API yang bagus dan langsung. <br><br><h2>  Tambahkan Pagination <br></h2><br>  Contoh berikut: desainer datang ke pengembang backend awal kami dan berkata: “Kami memiliki banyak artikel, kami membutuhkan pagination.  Kami menggambar yang ini. " <br><img src="https://habrastorage.org/webt/fn/6l/9t/fn6l9tjzotvgzehwpbezkd0vcf4.png"><br><br>  Mari kita pertimbangkan lebih terinci.  Pertama-tama, 336 halaman sangat mencolok.  Ketika saya melihat ini, saya berpikir tentang cara mendapatkan angka ini.  Di mana mendapatkan 336, karena ketika saya meminta daftar artikel saya mendapatkan daftar artikel.  Misalnya, ada 10 ribu di antaranya, yaitu, saya harus mengunduh semua artikel, membaginya dengan jumlah halaman dan mencari tahu nomor ini.  Untuk waktu yang sangat lama saya akan memuat artikel ini, saya perlu cara untuk mendapatkan jumlah entri dengan cepat.  Tetapi jika API kami mengembalikan daftar, lalu ke mana harus menempatkan jumlah catatan ini secara umum, karena serangkaian artikel datang sebagai tanggapan.  Ternyata karena jumlah catatan tidak diletakkan di mana pun, maka harus ditambahkan ke setiap artikel sehingga setiap artikel mengatakan: "Dan ada begitu banyak dari kita semua!" <br><br>  Namun, ada konvensi di atas API REST yang menyelesaikan masalah ini. <br><br><h3>  Daftar permintaan <br></h3><br>  Untuk membuat API dapat diperpanjang, Anda dapat segera menggunakan parameter GET untuk pagination: ukuran halaman saat ini dan nomornya, sehingga potongan halaman yang kami minta dikembalikan kepada kami.  Ini nyaman.  Sebagai tanggapan, Anda tidak bisa langsung memberikan array, tetapi menambahkan nesting tambahan.  Misalnya, kunci data akan berisi larik, data yang kami minta, dan kunci meta, yang sebelumnya tidak ada, akan berisi total. <br><br> <code>01. GET /articles? <b><font color="#c6e90e">page[size]=30&amp;page[number]=2</font></b> <br> 02. Content-Type: application/json <br></code> <br> <code>01. HTTP/1.1 200 OK <br> 02. { <br> 03.   "data": [{ "id": 1, "title": "JSONAPI"}, ...], <br> 04.   "meta": { <b><font color="#c6e90e">"count": 10080</font></b> } <br> 05. } <br></code> <br>  Dengan cara ini, API dapat mengembalikan informasi tambahan.  Selain menghitung, mungkin ada beberapa informasi lain - itu dapat diperluas.  Sekarang, jika junior tidak segera melakukannya, dan hanya setelah dia diminta melakukan piyamaisasi, maka dia <strong>membuat perubahan mundur yang tidak kompatibel</strong> , memecahkan API, dan semua klien harus mengulangnya - biasanya sangat menyakitkan. <br><br>  Piyamaisasi berbeda.  Saya menawarkan beberapa peretas yang dapat Anda gunakan. <br><br><h4>  [offset] ... [batas] <br></h4><br> <code>01. GET /articles? <b><font color="#c6e90e">page[offset]=30&amp;page[limit]=30</font></b> <br> 02. Content-Type: application/json <br></code> <br> <code>01. HTTP/1.1 200 OK <br> 02. { <br> 03.   "data": [{ "id": 1, "title": "JSONAPI"}, ...], <br> 04.   "meta": { "count": 10080 } <br> 05. } <br></code> <br>  Mereka yang bekerja dengan database mungkin sudah memiliki subkorteks [offset] ... [limit].  Menggunakannya alih-alih halaman [ukuran] ... halaman [angka] akan lebih mudah.  Ini adalah pendekatan yang sedikit berbeda. <br><br><h4>  Penempatan kursor <br></h4><br> <code>01. GET /articles? <b><font color="#c6e90e">page[published_at]=1538332156</font></b> <br> 02. Content-Type: application/json</code> <br> <br> <code>01. HTTP/1.1 200 OK <br> 02. { <br> 03.    "data": [{ "id": 1, "title": "JSONAPI"}, ...], <br> 04.    "meta": { "count": 10080 } <br> 05. }</code> <br> <br>  Lokasi kursor menggunakan pointer ke entitas yang akan mulai memuat catatan.  Misalnya, sangat nyaman ketika Anda menggunakan pagination atau memuat daftar yang sering berubah.  Katakanlah artikel baru terus ditulis di blog kami.  Halaman ketiga sekarang bukan halaman ketiga yang sama dalam satu menit, tetapi jika kita pergi ke halaman keempat, kita akan mendapatkan beberapa catatan dari halaman ketiga di atasnya, karena seluruh daftar akan bergerak. <br><br>  Masalah ini diselesaikan dengan pagination kursor.  Kami mengatakan: "Muat artikel yang datang setelah artikel yang diterbitkan pada waktu itu" - tidak ada lagi pergeseran teknologi, dan ini keren. <br><br><h2>  Masalah N +1 <br></h2><br>  Masalah berikutnya yang pasti akan dihadapi oleh pengembang junior kami adalah masalah N +1 (pendukung akan mengerti).  Misalkan Anda ingin daftar 10 artikel.  Kami mengunggah daftar artikel, setiap artikel memiliki penulis, dan untuk setiap Anda perlu mengunduh penulis.  Kami mengirim: <br><br><ul><li>  1 permintaan untuk daftar artikel; </li><li>  10 permintaan untuk penulis setiap artikel. </li></ul><br>  Total: 11 pertanyaan untuk menampilkan daftar kecil. <br><br><h3>  Tambahkan tautan <br></h3><br>  Di backend, masalah ini diselesaikan di semua ORM - Anda hanya perlu ingat untuk menambahkan koneksi ini.  Koneksi ini juga dapat digunakan di ujung depan.  Ini dilakukan sebagai berikut: <br><br> <code>01. GET /articles? <b><font color="#c6e90e">include =author</font></b> <br> 02. Content-Type: application/json <br></code> <br>  Anda dapat menggunakan parameter GET khusus, sebut itu termasuk (seperti pada backend), mengatakan tautan apa yang perlu kita muat bersama dengan artikel.  Misalkan kita mengunggah artikel, dan kami ingin segera mendapatkan penulis bersama dengan artikel.  Jawabannya terlihat seperti ini: <br><br> <code>01. /1.1 200  <br> 02. { "data": [{ <br> 03.  { attributes: { "id": 1, "title": "JSON API" }, <br> 04.  { relationships: { <br> 05. <b><font color="#c6e90e">"author": { "id": 1, "name": "Avdeev" } }</font></b> <br> 06.  }, ... <br> 07. }]}</code> <br> <br>  Atribut artikel sendiri ditransfer ke data dan hubungan kunci ditambahkan.  Kami menempatkan semua koneksi dalam kunci ini.  Dengan demikian, dengan satu permintaan, kami menerima semua data yang sebelumnya menerima 11 permintaan.  Ini adalah hack kehidupan keren yang memecahkan masalah dengan N +1 di front end dengan baik. <br><br><h2>  Masalah duplikasi data <br></h2><br>  Misalkan Anda ingin menampilkan 10 artikel yang menunjukkan penulis, semua artikel memiliki satu penulis, tetapi objek dengan penulisnya sangat besar (misalnya, nama belakang yang sangat panjang, yang membutuhkan satu megabyte).  Satu penulis dimasukkan dalam jawaban 10 kali, dan 10 inklusi dari penulis yang sama dalam jawaban akan memakan waktu 10 MB. <br><br>  Karena semua objek adalah sama, masalah yang satu penulis dimasukkan 10 kali (10 MB) diselesaikan dengan bantuan normalisasi, yang digunakan dalam database.  Di ujung depan, Anda juga dapat menggunakan normalisasi dalam bekerja dengan API - ini sangat keren. <br><br> <code>01. /1.1 200  <br> 02. { "data": [{ <br> 03. "id": "1″, <b><font color="#c6e90e">"type": "article",</font></b> <br> 04. "attributes": { "title": "JSON API" }, <br> 05. "relationships": { ... } <br> 06.  "author": { "id": 1, <b><font color="#c6e90e">"type": "people"</font></b> } } <br> 07. }, ... ] <br> 08. }</code> <br> <br>  Kami menandai semua entitas dengan beberapa tipe (ini adalah tipe representasi, tipe sumber daya).  Roy Fielding memperkenalkan konsep sumber daya, yaitu, mereka meminta artikel - menerima “artikel”.  Dalam hubungan, kami menempatkan tautan ke tipe orang, yaitu, kami masih memiliki sumber daya orang di tempat lain.  Dan sumber daya itu sendiri kami ambil dalam kunci yang terpisah, yang terletak pada tingkat yang sama dengan data. <br><br> <code>01. /1.1 200  <br> 02. { <br> 03. "data": [ ... ], <br> 04. <b><font color="#c6e90e">"included":</font></b> [{ <br> 05.  "id": 1, "type": "people", <br> 06.  "attributes": { "name": "Avdeev" } <br> 07. }] <br> 08. }</code> <br> <br>  Dengan demikian, semua entitas terkait dalam satu kejadian termasuk dalam kunci khusus yang disertakan.  Kami hanya menyimpan tautan, dan entitas itu sendiri disertakan. <br><br>  Ukuran permintaan berkurang.  Ini adalah hack kehidupan yang tidak diketahui oleh back-end awal.  Dia akan mencari tahu nanti ketika dia perlu memecahkan API. <br><br><h3>  Tidak semua bidang sumber daya diperlukan <br></h3><br>  Peretasan kehidupan berikut dapat diterapkan ketika tidak semua bidang sumber daya diperlukan.  Ini dilakukan dengan menggunakan parameter GET khusus, yang mencantumkan atribut yang akan dikembalikan, dipisahkan oleh koma.  Misalnya, artikelnya besar, dan mungkin ada megabita di bidang konten, dan kami hanya perlu menampilkan daftar tajuk - kami tidak memerlukan konten dalam respons. <br><br> <code>GET /articles <b><font color="#c6e90e">?fields[article]=title /1.1</font></b></code> <br> <br> <code>01. /1.1 200 OK <br> 02. { "data": [{ <br> 03.  "id": "1″, "type": "article", <br> 04.  "attributes": { <b><font color="#c6e90e">"title": " JSON API"</font></b> }, <br> 05.  }, ... ] <br> 06. }</code> <br> <br>  Jika Anda perlu, misalnya, juga tanggal publikasi, Anda dapat menulis “tanggal publikasi” yang dipisahkan koma.  Sebagai tanggapan, dua bidang akan datang dalam atribut.  Ini adalah konvensi yang dapat digunakan sebagai alat anti-bikeshedding. <br><br><h3>  Cari berdasarkan artikel <br></h3><br>  Seringkali kita membutuhkan pencarian dan filter.  Ada konvensi untuk ini - filter khusus GET parameter: <br><br>  ● <code>GET /articles <b><font color="#c6e90e">?filters[search]=api</font></b> HTTP/1.1</code> - pencarian; <br>  ● <code>GET /articles <b><font color="#c6e90e">?fiIters[from_date]=1538332156</font></b> HTTP/1.1</code> - unduh artikel dari tanggal tertentu; <br>  ● <code>GET /articles <b><font color="#c6e90e">?filters[is_published]=true</font></b> HTTP/1.1</code> - unduh artikel yang baru saja diterbitkan; <br>  ● <code>GET /articles <b><font color="#c6e90e">?fiIters[author]=1</font></b> HTTP/1.1</code> - unduh artikel dengan penulis pertama. <br><br><h3>  Menyortir Artikel <br></h3><br>  ● <code>GET /articles <b><font color="#c6e90e">?sort=title</font></b> /1.1</code> - menurut judul; <br>  ● <code>GET /articles <b><font color="#c6e90e">?sort=published_at</font></b> HTTP/1.1</code> - berdasarkan tanggal publikasi; <br>  ● <code>GET /articles <b><font color="#c6e90e">?sort=-published_at</font></b> HTTP/1.1</code> - menurut tanggal publikasi di arah yang berlawanan; <br>  ● <code>GET /articles <b><font color="#c6e90e">?sort=author,-publisbed_at</font></b> HTTP/1.1</code> - pertama oleh penulis, kemudian menurut tanggal publikasi dalam arah yang berlawanan, jika artikel berasal dari penulis yang sama. <br><br><h2>  Perlu mengubah URL <br></h2><br>  Solusi: hypermedia, yang sudah saya sebutkan, bisa dilakukan sebagai berikut.  Jika kita ingin objek (sumber daya) mendeskripsikan diri, klien dapat memahami melalui hypermedia apa yang dapat dilakukan dengannya, dan server dapat berkembang secara independen dari klien, maka kita dapat menambahkan tautan ke daftar artikel, ke artikel itu sendiri menggunakan kunci tautan khusus : <br><br> <code><code>01. GET /articles /1.1 <br> 02. { <br> 03. "data": [{ <br> 04.  ... <br> 05. <b><font color="#c6e90e">"links": { "self": "http://localhost/articles/1"</font></b></code> }, <br> 06.  "relationships": { ... } <br> 07. }], <br> 08. <b><font color="#c6e90e">"links": { "self": " <code>http://localhost/articles</code> " }</font></b> <br> 09. } <br></code> <br>  Atau yang terkait, jika kami ingin memberi tahu klien cara mengunggah komentar pada artikel ini: <br><br> <code><code>01. ... <br> 02. "relationships": { <br> 03. "comments": { <br> 04.  "links": { <br> 05. <b><font color="#c6e90e">"self": "http://localhost/articles/l/relationships/comments</font></b></code> ", <br> 06. <b><font color="#c6e90e">"related": " <code>http://localhost/articles/l/comments</code> "</font></b> <br> 07.  } <br> 08. } <br> 09. }</code> <br>  Klien melihat ada tautan, mengikutinya, memuat komentar.  Jika tidak ada tautan, maka tidak ada komentar.  Ini nyaman, tetapi sangat sedikit yang melakukannya.  Fielding datang dengan prinsip-prinsip REST, tetapi tidak semuanya memasuki industri kami.  Kami terutama menggunakan dua atau tiga. <br><br>  Pada 2013, semua peretasan yang saya ceritakan, Steve Klabnik digabungkan ke dalam spesifikasi API JSON dan terdaftar sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jenis media baru di atas JSON</a> .  Jadi pengembang backend junior kami, secara bertahap berkembang, datang ke API JSON. <br><br><h2>  API JSON <br></h2><br>  Semuanya dijelaskan secara rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://jsonapi.org/implementations/</a> : bahkan ada daftar 170 implementasi spesifikasi yang berbeda untuk 32 bahasa pemrograman - dan ini hanya ditambahkan ke katalog.  Perpustakaan, parser, serializers, dll. Sudah ditulis. <br><br>  Karena spesifikasi ini adalah open source, semua orang berinvestasi di dalamnya.  Saya, antara lain, menulis sesuatu sendiri.  Saya yakin ada banyak orang seperti itu.  Anda dapat bergabung dengan proyek ini sendiri. <br><br><h4>  API JSON Pro <br></h4><br>  Spesifikasi JSON API memecahkan sejumlah masalah - <strong>kesepakatan bersama untuk semua orang</strong> .  Karena ada kesepakatan umum, kami <strong>tidak berdebat di dalam tim</strong> - gudang sepeda didokumentasikan.  Kami memiliki kesepakatan tentang bahan apa yang membuat gudang sepeda dan cara melukisnya. <br><br>  Sekarang, ketika pengembang melakukan sesuatu yang salah dan saya melihatnya, saya tidak memulai diskusi, tetapi saya mengatakan: "Tidak oleh JSON API!"  dan tunjukkan di tempat dalam spesifikasi.  Mereka membenci saya di perusahaan, tetapi lambat laun menjadi terbiasa, dan semua orang mulai menyukai API JSON.  Kami membuat layanan standar baru sesuai dengan spesifikasi ini.  Kami memiliki kunci tanggal, kami siap untuk menambahkan meta, termasuk kunci.  Ada filter parameter GET dicadangkan untuk filter.  Kami tidak memperdebatkan apa yang disebut filter - kami menggunakan spesifikasi ini.  Ini menjelaskan cara membuat URL. <br><br>  Karena kami tidak berdebat, tetapi melakukan tugas bisnis, <strong>pengembangan produktivitas lebih tinggi</strong> .  Kami memiliki spesifikasi yang dijelaskan, pengembang membaca backend, membuat API, kami mengacaukannya - pelanggan senang. <br><br>  <strong>Masalah populer telah diselesaikan</strong> , misalnya, dengan pagination.  Ada banyak petunjuk dalam spec. <br><br>  Karena ini JSON (terima kasih kepada Douglas Crockford untuk format ini), ini lebih ringkas daripada XML, sangat <strong>mudah dibaca dan dimengerti</strong> . <br><br>  Fakta bahwa ini adalah <strong>Open Source</strong> dapat menjadi plus dan minus, tapi saya suka Open Source. <br><br><h4>  Kontra JSON API <br></h4><br>  Objek telah berkembang (tanggal, atribut, termasuk, dll.) - <strong>frontend perlu mengurai jawaban:</strong> dapat beralih ke array, berjalan di sekitar objek dan tahu bagaimana mengurangi bekerja.  Tidak semua pengembang pemula mengetahui hal-hal rumit ini.  Ada perpustakaan serializers / deserializers, Anda dapat menggunakannya.  Secara umum, ini hanya bekerja dengan data, tetapi objeknya besar. <br><br>  Dan <strong>backend memiliki</strong> rasa sakit: <br><br><ul><li>  Kontrol sarang - termasuk dapat dinaiki sangat jauh; </li><li>  Kompleksitas permintaan basis data - mereka terkadang dibangun secara otomatis, dan ternyata sangat sulit; </li><li>  Keamanan - Anda dapat naik ke hutan, terutama jika Anda menghubungkan semacam perpustakaan; </li><li>  Spesifikasi sulit dibaca.  Dia berbahasa Inggris, dan itu membuat takut beberapa orang, tetapi lambat laun semua orang terbiasa dengan itu; </li><li>  Tidak semua perpustakaan mengimplementasikan spesifikasi dengan baik - ini adalah masalah Open Source. </li></ul><br><h4>  Jebakan API JSON <br></h4><br>  Sedikit hardcore. <br><br>  <strong>Jumlah hubungan dalam masalah ini tidak terbatas.</strong>  Jika kami menyertakan, meminta artikel, menambahkan komentar, maka sebagai tanggapan kami akan menerima semua komentar dari artikel ini.  Ada 10.000 komentar - dapatkan 10.000 komentar: <br><br> <code>GET /articles/1?include=comments /1.1</code> <br> <br> <code>01. ... <br> 02. "relationships": { <br> 03. "comments": { <br> 04.  "data": <b><font color="#c6e90e">[0 ... ∞]</font></b> <br> 05. } <br> 06. }</code> <br> <br>  Dengan demikian, sebenarnya 5 MB datang ke permintaan kami sebagai tanggapan: “Ada tertulis dalam spesifikasi - perlu memformulasikan ulang permintaan dengan benar: <br><br> <code>GET /comments? <b><font color="#c6e90e">filters[article]=1&amp;</font></b> page[size]=30 HTTP/1.1</code> <br> <br> <code>01. { <br> 02. "data": <b><font color="#c6e90e">[0 ... 29]</font></b> <br> 03. }</code> <br> <br>  Kami meminta komentar dengan filter berdasarkan artikel, katakan: "30 buah, tolong" dan dapatkan 30 komentar.  Ini adalah ambiguitas. <br><br>  <strong>Hal-hal yang sama dapat dirumuskan secara ambigu</strong> : <br><br>  ● <code>GET /articles/1 <b><font color="#c6e90e">?include=comments</font></b> HTTP/1.1</code> - minta artikel dengan komentar; <br>  ● <code>GET /articles/1/comments HTTP/1.1</code> - minta komentar pada artikel; <br>  ● <code>GET /comments <b><font color="#c6e90e">?filters[article]=1</font></b> HTTP/1.1</code> - minta komentar dengan filter berdasarkan artikel. <br><br>  Ini adalah satu dan sama - data yang sama, yang diperoleh dengan cara yang berbeda, ada beberapa ambiguitas.  Perangkap ini tidak segera terlihat. <br><br>  <strong>Hubungan polimorfik satu-ke-banyak</strong> masuk ke REST dengan sangat cepat. <br><br> <code>01. GET /comments?include=commentable /1.1 <br> 02. <br> 03. ... <br> 04. "relationships": { <br> 05. <b><font color="#c6e90e">"commentable"</font></b> : { <br> 06.  "data": { "type": "article", "id": "1″ } <br> 07. } <br> 08. }</code> <br> <br>  Ada koneksi polimorfik yang dapat dikomentari di backend - itu merangkak keluar ke REST.  Jadi itu harus terjadi, tetapi bisa disamarkan.  Anda tidak dapat menyamarkannya di API JSON - itu akan keluar. <br><br>  <strong>Hubungan banyak-ke-banyak yang kompleks dengan opsi tingkat lanjut</strong> .  Juga, semua tabel penghubung keluar: <br><br> <code>01. GET /users?include <b><font color="#c6e90e">=users_comments</font></b> /1.1 <br> 02. <br> 03. ... <br> 04. "relationships": { <br> 05. "users_comments": { <br> 06.  "data": [{ "type": "users_comments", "id": "1″ }, ...] <br> 07. }, <br> 08. }</code> <br> <br><h2>  Kesombongan <br></h2><br>  Swagger adalah alat penulisan dokumentasi online. <br><br>  Katakanlah pengembang backend kami diminta untuk menulis dokumentasi untuk API-nya, dan ia menulisnya.  Ini mudah jika APInya sederhana.  Jika ini adalah JSON API, Swagger tidak dapat ditulis dengan mudah. <br><br>  <strong>Contoh:</strong> Toko hewan peliharaan kesombongan.  Setiap metode dapat dibuka, lihat respons dan contoh. <br><br><img src="https://habrastorage.org/webt/ul/lj/yk/ulljykpo7bhyw85r9ru69k2nuxe.png"><br><br>  Ini adalah contoh dari model Pet.  Ini adalah antarmuka yang keren, semuanya mudah dibaca. <br><br><img src="https://habrastorage.org/webt/i9/rg/ir/i9rgirjcdxgm16ogmtopu6dnjrq.png"><br><br>  Dan ini adalah bagaimana penciptaan model API JSON terlihat seperti: <br><br><img src="https://habrastorage.org/webt/ty/14/kn/ty14knt_laxzsr2ozusbo0xkk0c.png"><br><br>  Ini tidak terlalu bagus.  Kami membutuhkan data, dalam data sesuatu dengan hubungan, termasuk berisi 5 jenis model, dll.  Anda dapat menulis Swagger, Open API adalah hal yang kuat, tetapi rumit. <br><br><h2>  Alternatif <br></h2><br>  Ada spesifikasi OData, yang muncul sedikit lebih lambat - pada tahun 2015.  Ini adalah "Cara terbaik untuk REST", seperti yang dijamin situs web resmi.  Ini terlihat seperti ini: <br><br>  <code>01. GET http://services.odata.org/v4/TripRW/People HTTP/1.1</code> - DAPATKAN permintaan; <br>  <code>02. OData-Version: 4.0</code> - header khusus dengan versi; <br>  <code>03. OData-MaxVersion: 4.0</code> - Header Versi Khusus Kedua <br><br>  Jawabannya terlihat seperti ini: <br><br> <code>01. HTTP/1.1 200 OK <br> 02. Content-Type: application/json; odata.metadata=minimal <br> 03. OData-Version: 4.0 <br> 04. { <br> 05. '@odata.context': 'http://services.odata.org/V4/ <br> 06. '@odata.nextLink' : 'http://services.odata.org/V4/ <br> 07. 'value': [{ <br> 08.  '@odata.etag': 1W/108D1D5BD423E51581′, <br> 09.  'UserName': 'russellwhyte', <br> 10.  ... <br></code> <br>  Berikut ini adalah aplikasi / json dan objek yang diperluas. <br><br>  Kami tidak menggunakan OData, pertama, karena sama dengan API JSON, tetapi tidak ringkas.  Ada benda besar dan menurut saya semuanya jauh lebih buruk dibaca.  OData juga keluar di Open Source, tetapi lebih rumit. <br><br><h2>  Bagaimana dengan GraphQL? <br></h2><br>  Tentu saja, ketika kami mencari format API baru, kami mengalami hype ini. <br><br>  ● <strong>Ambang entri tinggi.</strong> <br><br>  Dari sudut pandang frontend, semuanya terlihat keren, tetapi Anda tidak bisa membuat pengembang baru menulis GraphQL, karena Anda harus mempelajarinya terlebih dahulu.  Ini seperti SQL - Anda tidak dapat langsung menulis SQL, setidaknya Anda harus membaca apa itu, melalui tutorial, yaitu, ambang entri meningkat. <br><br>  ● <strong>Efek dari big bang.</strong> <br><br>  Jika tidak ada API dalam proyek ini, dan kami mulai menggunakan GraphQL, setelah sebulan kami menyadari bahwa itu tidak cocok untuk kami, itu akan terlambat.  Harus menulis kruk.  Anda dapat berevolusi dengan API JSON atau OData - RESTful paling sederhana, semakin meningkat, berubah menjadi API JSON. <br><br>  ● <strong>Neraka di backend.</strong> <br><br>  GraphQL memanggil neraka di backend - satu lawan satu, sama seperti API JSON yang diimplementasikan sepenuhnya, karena GraphQL mendapatkan kendali penuh atas kueri, dan ini adalah perpustakaan, dan Anda perlu menyelesaikan banyak pertanyaan: <br><br><ul><li>  kontrol bersarang; </li><li>  rekursi </li><li>  pembatasan frekuensi; </li><li>  kontrol akses. </li></ul><br><h2>  Alih-alih kesimpulan <br></h2><br>  Saya sarankan berhenti berdebat tentang gudang sepeda, dan gunakan alat anti-bikeshedding sebagai spesifikasi dan buat API dengan spesifikasi yang bagus. <br><br>  Untuk menemukan standar Anda dalam memecahkan masalah gudang sepeda, Anda dapat melihat tautan ini: <br><br>  ● <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://jsonapi.org</a> <br>  ● <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.odata.org</a> <br>  ● <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://graphgl.org</a> <br> ● <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://xmlrpc.scripting.com</a> <br> ● <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.jsonrpc.org</a> <br><br> <strong>   :</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alexey-avdeev.com</a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> . <br><br><blockquote> ,  <strong>  </strong>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf</a> ,   27  28    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">++</a> .     ,        . <br><br> <strong>   ?</strong>      ?        ?    ,        ? <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ! <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,  ,   ,    ,      . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433322/">https://habr.com/ru/post/id433322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433306/index.html">Visual studio 2019</a></li>
<li><a href="../id433308/index.html">Mentransfer konfigurasi PBX ke layanan 3CX PBX Express</a></li>
<li><a href="../id433316/index.html">Intisari desain: orientasi, umpan balik, cari ide dan pengambilan keputusan</a></li>
<li><a href="../id433318/index.html">garbage.collect ()</a></li>
<li><a href="../id433320/index.html">Layout Grid sebagai dasar dari layout modern</a></li>
<li><a href="../id433324/index.html">Mengumpulkan bundel impian dengan Webpack</a></li>
<li><a href="../id433326/index.html">Kualitas kode</a></li>
<li><a href="../id433328/index.html">Lebih baik kehilangan sehari</a></li>
<li><a href="../id433330/index.html">Pecahkan teka-teki silang Jepang dengan SAT Solver</a></li>
<li><a href="../id433332/index.html">Dukungan Python di Fungsi Azure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>