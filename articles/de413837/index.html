<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍⚕️ 🐺 👼🏾 Tower Defense zu einem Einheitsspiel machen - Teil 1 🧑‍🤝‍🧑 🛅 🚭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tower Defense-Spiele werden immer beliebter, und das ist nicht verwunderlich - wenig kann mit dem Vergnügen verglichen werden, eigene Verteidigungslin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tower Defense zu einem Einheitsspiel machen - Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413837/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png" alt="Bild"></div><br>  Tower Defense-Spiele werden immer beliebter, und das ist nicht verwunderlich - wenig kann mit dem Vergnügen verglichen werden, eigene Verteidigungslinien zu beobachten, die böse Feinde zerstören!  In diesem zweiteiligen Tutorial erstellen wir ein Tower Defense-Spiel auf der <em>Unity-</em> Engine! <br><br>  Sie lernen, wie Sie Folgendes tun: <br><br><ul><li>  Erschaffe Wellen von Feinden </li><li>  Lassen Sie sie Routenpunkten folgen </li><li>  Baue und verbessere Türme und lehre sie, wie man Feinde in kleine Pixel zerlegt </li></ul><br>  Am Ende bekommen wir den Rahmen des Spiels, der weiterentwickelt werden kann! <br><a name="habracut"></a><br><blockquote>  <em>Hinweis</em> : Sie benötigen grundlegende Unity-Kenntnisse (z. B. müssen Sie wissen, wie Assets und Komponenten hinzugefügt werden, welche Fertighäuser vorhanden sind) und die Grundlagen von <em>C #</em> .  Um all dies zu lernen, empfehle ich Ihnen, die Tutorials zu Unity von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sean Duffy</a> oder die Reihe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beginning C # with Unity</a> von Brian Mockley durchzugehen. </blockquote><br>  Ich werde in Unity für OS X arbeiten, aber dieses Tutorial ist auch für Windows geeignet. <br><br><h2>  Durch die Fenster des Elfenbeinturms </h2><br>  In diesem Tutorial erstellen wir ein Tower Defense-Spiel, in dem Feinde (kleine Bugs) zu einem Cookie kriechen, der Ihnen und Ihren Schergen gehört (natürlich sind dies Monster!).  Der Spieler kann Monster an strategischen Punkten platzieren und sie für Gold verbessern. <br><br>  Der Spieler muss alle Bugs töten, bis sie zum Cookie gelangen.  Jede neue Welle von Feinden wird immer schwieriger zu besiegen.  Das Spiel endet, wenn Sie alle Wellen überleben (Sieg!) Oder wenn fünf Feinde zu den Keksen kriechen (Verlust!). <br><br>  Hier ist ein Screenshot des fertigen Spiels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/782/a94/fef/782a94fefd675365aba52fbfc4008ab6.png"></div><br>  <i>Monster, vereinigt euch!</i>  <i>Schützen Sie den Cookie!</i> <br><br><h2>  An die Arbeit gehen </h2><br>  Laden Sie dieses <a href="">Projekt leer</a> herunter, entpacken Sie es und öffnen Sie das <em>TowerDefense-Part1-Starter-</em> Projekt in Unity. <br><br>  Der Projektentwurf enthält zahlreiche Grafiken und Sounds, vorgefertigte Animationen und mehrere nützliche Skripte.  Die Skripte stehen nicht in direktem Zusammenhang mit Tower Defense-Spielen, daher werde ich hier nicht darauf eingehen.  Wenn Sie jedoch mehr über das Erstellen von 2D-Animationen in Unity erfahren möchten, lesen Sie dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Unity 2D-Tutorial">Unity 2D-Lernprogramm</a> . <br><br>  Das Projekt enthält auch Fertighäuser, die wir später hinzufügen werden, um Charaktere zu erstellen.  Schließlich gibt es im Projekt eine Szene mit einem Hintergrund und einer benutzerdefinierten Benutzeroberfläche. <br><br>  Öffnen Sie die <em>GameScene</em> im Ordner " <em>Szenen</em> " und stellen Sie den <em>Spielemodus</em> auf ein Seitenverhältnis von <em>4: 3 ein,</em> damit alle Beschriftungen korrekt zum Hintergrund passen.  Im Spielemodus sehen Sie Folgendes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb7/050/bda/fb7050bda1d91c148f65e70a7c217083.png"></div><br>  <em>Autorschaft:</em> <br><br><ul><li>  Die Grafiken für das Projekt stammen aus dem kostenlosen Wiki Wenderlich Pack!  Weitere grafische Arbeiten finden Sie auf ihrer Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="gameartguppy">gameartguppy</a> . </li><li>  Großartige Musik von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Benound">BenSound</a> , die andere großartige Soundtracks enthält! </li><li>  Ich danke auch Michael Jesper für die sehr nützliche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Kamera schütteln">Kameraverwacklungsfunktion.</a> </li></ul>  . <br><h2>  Der Ort ist mit einem Kreuz markiert: der Ort der Monster </h2><br>  Monster können nur auf Punkte gelegt werden, die mit einem <em>x</em> markiert sind. <br><br>  Um sie der Szene hinzuzufügen, ziehen Sie <em>Images \ Objects \ Openspot</em> aus dem <em>Projektbrowser</em> in das <em>Szenenfenster</em> .  Während die Position für uns nicht wichtig ist. <br><br>  Nachdem Sie in der Hierarchie <em>Openspot</em> ausgewählt haben, klicken <em>Sie</em> im <em><em>Inspektor</em></em> auf <em>Komponente</em> <em>hinzufügen</em> und wählen Sie <em>Box Collider 2D</em> .  Im Szenenfenster zeigt Unity einen rechteckigen Collider mit einer grünen Linie an.  Wir werden diesen Collider verwenden, um Mausklicks an dieser Stelle zu erkennen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/6a9/3da/2716a93da69de6b5cf73a7edfc794210.png"></div><br>  Fügen Sie die Komponente <em>Audio \ Audio Source</em> auf <em>die</em> gleiche Weise zu <em>Openspot hinzu</em> .  <em>Wählen Sie</em> für den <em>AudioClip-</em> Parameter der Audio Source-Komponente die Datei <em>tunnel_place aus</em> , die sich im <em>Audio-</em> Ordner befindet, und deaktivieren Sie <em>Play On Awake</em> . <br><br>  Wir müssen 11 weitere Punkte schaffen.  Obwohl die Versuchung besteht, all diese Schritte zu wiederholen, hat Unity eine bessere Lösung: <em>Fertighaus</em> ! <br><br>  Ziehen Sie <em>Openspot</em> aus der <em>Hierarchie</em> in den Ordner <em>Prefabs</em> im <em>Projektbrowser</em> .  Sein Name wird in der Hierarchie blau, was bedeutet, dass er an das Fertighaus angehängt ist.  Ungefähr so: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad3/cb2/6a0/ad3cb26a0d51c893dd040e8f4f5dfea6.gif"></div><br>  Nachdem wir das vorgefertigte Leerzeichen haben, können wir so viele Kopien erstellen, wie wir möchten.  Ziehen Sie <em>Openspot</em> einfach per Drag &amp; Drop aus dem <em>Prefabs-</em> Ordner im <em>Projektbrowser</em> in das <em>Szenenfenster</em> .  Wiederholen Sie dies 11 Mal und 12 Openspot-Objekte werden in der Szene angezeigt. <br><br>  Verwenden Sie nun den <em>Inspektor</em> , um diese 12 Openspot-Objekte mit den folgenden Koordinaten festzulegen: <br><br><ul><li>  (X: -5,2, Y: 3,5, Z: 0) </li><li>  (X: -2,2, Y: 3,5, Z: 0) </li><li>  (X: 0,8, Y: 3,5, Z: 0) </li><li>  (X: 3,8, Y: 3,5, Z: 0) </li><li>  (X: -3,8, Y: 0,4, Z: 0) </li><li>  (X: -0,8, Y: 0,4, Z: 0) </li><li>  (X: 2,2, Y: 0,4, Z: 0) </li><li>  (X: 5,2, Y: 0,4, Z: 0) </li><li>  (X: -5,2, Y: -3,0, Z: 0) </li><li>  (X: -2,2, Y: -3,0, Z: 0) </li><li>  (X: 0,8, Y: -3,0, Z: 0) </li><li>  (X: 3,8, Y: -3,0, Z: 0) </li></ul><br>  Wenn Sie dies tun, sieht die Szene folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/248/fb2/69e248fb213cfee35ce43f5f9c14baeb.png"></div><br><h2>  Wir platzieren Monster </h2><br>  Um die Platzierung zu vereinfachen, befindet sich im <em>Prefab-</em> Ordner des Projekts ein <em>Monster-</em> Fertighaus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c65/908/80a/c6590880acbdbac94bd15ec023311235.png"></div><br>  <i>Monster Prefab Gebrauchsfertig</i> <br><br>  Im Moment besteht es aus einem leeren Spielobjekt mit drei verschiedenen Sprites und Schießanimationen als Kinder. <br><br>  Jedes Sprite ist ein Monster mit unterschiedlichen Stärken.  Das Fertighaus enthält auch die <em>Audio Source-</em> Komponente, die gestartet wird, um Sound abzuspielen, wenn ein Monster einen Laser abfeuert. <br><br>  Jetzt werden wir ein Skript erstellen, das <em>Monster</em> auf <em>Openspot hostet</em> . <br><br>  <em>Wählen</em> Sie im <em>Projektbrowser</em> das <em>Openspot-</em> Objekt im Ordner <em>Prefabs aus</em> .  Klicken <em>Sie</em> im <em>Inspektor</em> auf <em>Komponente</em> <em>hinzufügen</em> , wählen Sie <em>Neues Skript aus</em> und benennen Sie das Skript <em>PlaceMonster</em> .  Wählen Sie <em>C Sharp</em> als Sprache und klicken Sie auf <em>Erstellen und Hinzufügen</em> .  Da wir das Skript zum <i>Openspot-</i> Prefab <i>hinzugefügt</i> haben, haben alle Openspot-Objekte in der Szene jetzt dieses Skript.  Großartig! <br><br>  Doppelklicken Sie auf das Skript, um es in der IDE zu öffnen.  Fügen Sie dann zwei Variablen hinzu: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject monsterPrefab; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject monster;</code> </pre> <br>  Wir werden eine Instanz des in <code>monsterPrefab</code> gespeicherten <code>monsterPrefab</code> erstellen, um das Monster zu erstellen, und es in <code>monster</code> speichern, damit es während des Spiels manipuliert werden kann. <br><br><h3>  Ein Monster pro Punkt </h3><br>  Fügen Sie die folgende Methode hinzu, damit nur ein Monster auf einen Punkt gesetzt werden kann: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanPlaceMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  In <code>CanPlaceMonster()</code> wir überprüfen, ob die <code>monster</code> noch <code>null</code> .  Wenn ja, dann gibt es kein Monster an der Stelle, und wir können es platzieren. <br><br>  Füge nun den folgenden Code hinzu, um das Monster zu platzieren, wenn der Spieler auf dieses GameObject klickt: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 void OnMouseUp() { //2 if (CanPlaceMonster()) { //3 monster = (GameObject) Instantiate(monsterPrefab, transform.position, Quaternion.identity); //4 AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br>  Dieser Code findet das Monster, wenn Sie mit der Maus klicken oder den Bildschirm berühren.  Wie arbeitet er? <br><br><ol><li>  Unity ruft <code>OnMouseUp</code> automatisch <code>OnMouseUp</code> wenn ein Spieler den physischen Collider GameObject berührt. </li><li>  Beim Aufruf setzt diese Methode ein Monster, wenn <code>CanPlaceMonster()</code> <code>true</code> zurückgibt. </li><li>  Wir erstellen ein Monster mit der <code>Instantiate</code> Methode, die eine Instanz des angegebenen Fertighauses mit der angegebenen Position und Drehung erstellt.  In diesem Fall kopieren wir <code>monsterPrefab</code> , geben ihm die aktuelle GameObject-Position und keine Drehung, übertragen das Ergebnis auf <code>GameObject</code> und speichern es in <code>monster</code> </li><li>  Am Ende rufen wir <code>PlayOneShot</code> auf, um den Soundeffekt <code>PlayOneShot</code> , der an die <code>AudioSource</code> Komponente des Objekts angehängt ist. </li></ol><br>  Jetzt kann unser <code>PlaceMonster</code> Skript ein neues Monster haben, aber wir müssen noch ein Fertighaus angeben. <br><br><h3>  Verwenden des richtigen Fertighauses </h3><br>  Speichern Sie die Datei und kehren Sie zu Unity zurück. <br><br>  Um die Variable <em>monsterPrefab festzulegen</em> , wählen <em>Sie</em> zuerst das <em>Openspot-</em> Objekt aus dem Ordner <em>Prefabs</em> im Browser des Projekts aus. <br><br>  Klicken Sie im <em><em>Inspektor</em></em> auf den Kreis rechts neben dem Feld <em>Monster Prefab</em> der <em>PlaceMonster (Script)</em> -Komponente und wählen Sie im angezeigten Dialogfeld <em>Monster aus</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/8bc/9c7/b878bc9c77c6e7c63a54f4a87d2a7c42.gif"></div><br>  Das ist alles.  Starte die Szene und erstelle Monster an verschiedenen Orten, indem du mit der Maus klickst oder den Bildschirm berührst. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/f08/01d/095f0801ddbbc91ce0eca144a22d4f7b.png"></div><br>  Großartig!  Jetzt können wir Monster erschaffen.  Sie sehen jedoch wie ein seltsames Durcheinander aus, da alle Kindergeister des Monsters gezeichnet sind.  Jetzt werden wir es beheben. <br><br><h2>  Erhöhe das Level der Monster </h2><br>  Die folgende Abbildung zeigt, dass Monster mit zunehmendem Level immer furchterregender aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a92/23d/480/a9223d480dda51f941c3b0b82f9f0dd6.png"></div><br>  <i>Was für eine Süße!</i>  <i>Aber wenn Sie versuchen, seine Kekse zu stehlen, wird dieses Monster zum Mörder.</i> <br><br>  Das Skript wird als Grundlage für die Implementierung des Systems der Monsterlevel verwendet.  Es verfolgt die Macht des Monsters in jedem Level und natürlich das aktuelle Level des Monsters. <br><br>  Fügen Sie dieses Skript hinzu. <br><br>  Wählen Sie das <em>Prefabs / Monster</em> Prefab im <em>Projektbrowser</em> .  Fügen Sie ein neues <em>C #</em> -Skript namens <em>MonsterData hinzu</em> .  Öffnen Sie das Skript in der IDE und fügen Sie den folgenden Code <i>über</i> der <code>MonsterData</code> Klasse hinzu. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MonsterLevel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject visualization; }</code> </pre> <br>  Also erstellen wir <code>MonsterLevel</code> .  Es gruppiert den Preis (in Gold, den wir unten unterstützen werden) und eine visuelle Darstellung des Levels des Monsters. <br><br>  Wir fügen zusätzlich zu <code>[System.Serializable]</code> damit Klasseninstanzen im Inspektor geändert werden können.  Dadurch können wir schnell alle Werte der Level-Klasse ändern, auch wenn das Spiel läuft.  Dies ist unglaublich nützlich, um das Spiel auszugleichen. <br><br><h3>  Monster Level einstellen </h3><br>  In unserem Fall speichern wir das angegebene <code>MonsterLevel</code> in <code>List&lt;T&gt;</code> . <br><br>  Warum nicht einfach <code>MonsterLevel[]</code> ?  Wir benötigen den Index eines bestimmten <code>MonsterLevel</code> Objekts mehrmals.  Obwohl es einfach ist, Code dafür zu schreiben, müssen wir dennoch <code>IndexOf()</code> , das die <code>Lists</code> Funktionalität implementiert.  Es macht keinen Sinn, das Rad neu zu erfinden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aae/85f/785/aae85f7854f44c8f418c5fde22153a53.jpg"></div><br>  <i>Das Fahrrad neu zu erfinden ist normalerweise eine schlechte Idee.</i> <br><br>  <em>Fügen Sie</em> oben in <em>MonsterData.cs</em> <code>using</code> Konstrukts Folgendes hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic;</code> </pre> <br>  Es gibt uns Zugriff auf verallgemeinerte Datenstrukturen, sodass wir die <code>List&lt;T&gt;</code> -Klasse im Skript verwenden können. <br><br><blockquote>  <em>Hinweis</em> : Verallgemeinerungen sind ein leistungsfähiges C # -Konzept.  Mit ihnen können Sie typsichere Datenstrukturen angeben, ohne den Typ einhalten zu müssen.  Dies ist nützlich für Containerklassen wie Listen und Mengen.  Weitere Informationen zu generischen Strukturen finden Sie im Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Einführung in C # Generics">Einführung in C # Generics</a> . </blockquote><br>  <code>MonsterLevel</code> nun <code>MonsterData</code> die folgende Variable hinzu, um die <code>MonsterLevel</code> Liste zu <code>MonsterLevel</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;MonsterLevel&gt; levels;</code> </pre> <br>  Dank Verallgemeinerungen können wir garantieren, dass die <code>List</code> von <code>level</code> nur <code>MonsterLevel</code> Objekte enthält. <br><br>  Speichern Sie die Datei und wechseln Sie zu Unity, um die einzelnen Ebenen zu konfigurieren. <br><br>  Wählen Sie <em>Prefabs / Monster</em> im <em>Projektbrowser</em> .  Der <em><em>Inspektor</em></em> zeigt jetzt das Feld <em>Ebenen</em> der <em>MonsterData (Script)</em> -Komponente an.  Stellen Sie die <em>Größe</em> auf <em>3 ein</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/660/dda/a18/660ddaa185b824721453ca1c892eedff.png"></div><br>  Als nächstes legen Sie die <em>Kosten</em> für jede Ebene fest: <br><br><ul><li>  <em>Element 0</em> : <em>200</em> </li><li>  <em>Element 1</em> : <em>110</em> </li><li>  <em>Element 2</em> : <em>120</em> </li></ul><br>  Jetzt weisen wir die Werte der visuellen Anzeigefelder zu. <br><br>  Erweitern Sie <em>Prefabs / Monster</em> im Projektbrowser, um die <em>untergeordneten</em> Elemente <em>anzuzeigen</em> .  Ziehen Sie das <em>untergeordnete Monster0</em> in das Feld <em>Visualisierungselement</em> <em>0</em> . <br><br>  Als nächstes setzen Sie <em>Element 1</em> auf <em>Monster1</em> und <em>Element 2</em> auf <em>Monster2</em> .  Das GIF zeigt diesen Prozess: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/662/404/e30/662404e30bd808e1cf9a9d34b47d4d61.gif"></div><br>  Wenn Sie <em>Prefabs / Monster</em> auswählen, sollte das Prefab folgendermaßen aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80b/e4d/17e/80be4d17e9894cf291b7be8a44152044.png"></div><br><h3>  Aktuelle Stufe einstellen </h3><br>  Gehen Sie in der IDE zurück zu <em>MonsterData.cs</em> und fügen Sie <code>MonsterData</code> eine weitere Variable hinzu. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MonsterLevel currentLevel;</code> </pre> <br>  In der privaten Variablen <code>currentLevel</code> speichern wir das aktuelle Level des Monsters. <br><br>  <code>currentLevel</code> Sie nun <code>currentLevel</code> und machen Sie es für andere Skripte sichtbar.  Fügen Sie <code>MonsterData</code> die folgenden Zeilen zusammen mit der Deklaration von Instanzvariablen hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 public MonsterLevel CurrentLevel { //2 get { return currentLevel; } //3 set { currentLevel = value; int currentLevelIndex = levels.IndexOf(currentLevel); GameObject levelVisualization = levels[currentLevelIndex].visualization; for (int i = 0; i &lt; levels.Count; i++) { if (levelVisualization != null) { if (i == currentLevelIndex) { levels[i].visualization.SetActive(true); } else { levels[i].visualization.SetActive(false); } } } } }</span></span></code> </pre> <br>  Ziemlich großer Teil des C # -Codes, oder?  Nehmen wir es in der Reihenfolge: <br><br><ol><li>  <code>currentLevel</code> Sie die <em>Eigenschaft der</em> privaten Variablen <code>currentLevel</code> .  Durch Festlegen der Eigenschaft können wir sie wie jede andere Variable aufrufen: entweder als <code>CurrentLevel</code> (innerhalb der Klasse) oder als <code>monster.CurrentLevel</code> (außerhalb).  Wir können jedes Verhalten in der Getter- oder Setter-Methode einer Eigenschaft definieren, und indem wir nur einen Getter, Setter oder beide erstellen, können wir die Eigenschaften der Eigenschaft steuern: schreibgeschützt, schreibgeschützt und schreiben / lesen. </li><li>  Im Getter geben wir den Wert von <code>currentLevel</code> . </li><li>  Im Setter weisen wir <code>currentLevel</code> neuen Wert zu.  Dann erhalten wir den Index des aktuellen Niveaus.  Schließlich durchlaufen wir alle <em>Ebenen</em> und aktivieren / deaktivieren die visuelle Anzeige abhängig von <code>currentLevelIndex</code> .  Dies ist großartig, da das Sprite automatisch aktualisiert wird, wenn sich <code>currentLevel</code> ändert.  Eigenschaften sind eine sehr bequeme Sache! </li></ol><br>  Fügen Sie die folgende <code>OnEnable</code> Implementierung hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentLevel = levels[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br>  Hier setzen wir <code>CurrentLevel</code> beim Platzieren.  Dadurch wird sichergestellt, dass nur das gewünschte Sprite angezeigt wird. <br><br><blockquote>  <em>Hinweis</em> : Es ist wichtig, die Eigenschaft in <code>OnEnable</code> und nicht in <code>OnStart</code> zu initialisieren, da beim Erstellen vorgefertigter Instanzen die Ordnungsmethoden aufgerufen werden. <br><br>  <code>OnEnable</code> wird sofort aufgerufen, wenn das Fertighaus erstellt wird (wenn das Fertighaus im aktivierten Zustand gespeichert wurde), <code>OnStart</code> erst aufgerufen, wenn das Objekt als Teil der Szene ausgeführt wird. <br><br>  Wir müssen diese Daten überprüfen, bevor wir das Monster platzieren, also initialisieren wir sie auf <code>OnEnable</code> . </blockquote><br>  Speichern Sie die Datei und kehren Sie zu Unity zurück.  Führe das Projekt aus und platziere die Monster.  Sie zeigen jetzt die richtigen Sprites der untersten Ebene an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08e/16e/549/08e16e5498d12f78d106d873d34c8d1b.png"></div><br><h3>  Monster Upgrade </h3><br>  Kehren Sie zur IDE zurück und fügen Sie <code>MonsterData</code> die folgende Methode hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MonsterLevel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNextLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf (currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxLevelIndex = levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; maxLevelIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> levels[currentLevelIndex+<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br>  In <code>GetNextLevel</code> wir den <code>currentLevel</code> Index und den Index der höchsten Ebene.  Wenn das Monster das maximale Level nicht erreicht hat, kehrt das nächste Level zurück.  Andernfalls wird <code>null</code> zurückgegeben. <br><br>  Mit dieser Methode kannst du herausfinden, ob ein Monster-Upgrade möglich ist. <br><br>  Füge die folgende Methode hinzu, um das Level des Monsters zu erhöhen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf(currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>) { CurrentLevel = levels[currentLevelIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>]; } }</code> </pre> <br>  Hier erhalten wir den Index der aktuellen Ebene und stellen dann sicher, dass dies nicht die maximale Ebene ist. Überprüfen Sie, ob diese unter den Ebenen liegt. <code>levels.Count - 1</code> .  Wenn ja, <code>CurrentLevel</code> auf die nächste Stufe. <br><br><h3>  Überprüfen der Upgrade-Funktionalität </h3><br>  Speichern Sie die Datei und kehren <em>Sie</em> in der IDE zu <em>PlaceMonster.cs</em> zurück.  Fügen Sie eine neue Methode hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanUpgradeMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (monster != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { MonsterData monsterData = monster.GetComponent&lt;MonsterData&gt;(); MonsterLevel nextLevel = monsterData.GetNextLevel(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextLevel != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Zuerst prüfen wir, ob es ein Monster gibt, das verbessert werden kann, indem wir die <code>monster</code> mit <code>null</code> .  Wenn dies wahr ist, erhalten wir das aktuelle Monsterlevel aus seinen <code>MonsterData</code> . <br><br>  Dann prüfen wir, ob die nächste Ebene verfügbar ist, <code>GetNextLevel()</code> ob <code>GetNextLevel()</code> nicht <code>null</code> <code>GetNextLevel()</code> .  Wenn eine Pegelerhöhung möglich ist, geben wir <code>true</code> .  Andernfalls wird <code>false</code> . <br><br><h3>  Wir implementieren Verbesserungen für Gold </h3><br>  <code>OnMouseUp</code> zum Aktivieren der Upgrade-Option den Zweig <code>else if</code> zu <code>OnMouseUp</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanPlaceMonster()) { <span class="hljs-comment"><span class="hljs-comment">//      } else if (CanUpgradeMonster()) { monster.GetComponent&lt;MonsterData&gt;().IncreaseLevel(); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   }</span></span></code> </pre> <br>  Wir prüfen die Möglichkeit eines Upgrades mit <code>CanUpgradeMonster()</code> .  Wenn möglich, greifen wir mit <code>GetComponent()</code> auf die <code>MonsterData</code> Komponente zu und rufen <code>IncreaseLevel()</code> , wodurch sich das Level des Monsters erhöht.  Schließlich starten wir die Monster <em>AudioSource</em> . <br><br>  Speichern Sie die Datei und kehren Sie zu Unity zurück.  Führe das Spiel aus, platziere und verbessere eine <i>beliebige Anzahl von</i> Monstern (aber vorerst). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/495/bed/cb7495bed8ebcd3993439de25a08a0e7.png"></div><br><h2>  Gold bezahlen - Game Manager </h2><br>  Wir können zwar sofort Monster bauen und verbessern, aber wird es im Spiel interessant sein? <br><br>  Schauen wir uns das Thema Gold an.  Das Problem beim Verfolgen ist, dass wir Informationen zwischen verschiedenen Spielobjekten übertragen müssen. <br><br>  Die folgende Abbildung zeigt alle Objekte, die daran teilnehmen sollen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e35/8cd/6f4/e358cd6f461c75385f61f1c12862a16b.png"></div><br>  <i>Alle ausgewählten Spielobjekte müssen wissen, wie viel Gold ein Spieler hat.</i> <br><br>  Um diese Daten zu speichern, verwenden wir ein gemeinsames Objekt, auf das andere Objekte zugreifen können. <br><br>  Klicken Sie mit der rechten Maustaste auf die <em>Hierarchie</em> und wählen <em>Sie Leer erstellen</em> .  <em>Benennen Sie</em> das neue <em>GameManager-</em> Objekt. <br><br>  Fügen <em>Sie GameManager</em> ein neues <em>C #</em> <em>-Skript mit dem</em> Namen <em>GameManagerBehavior hinzu</em> und öffnen Sie es in der IDE.  Wir zeigen die Gesamtmenge an Spielergold auf dem Etikett an. Fügen Sie daher oben in der Datei die folgende Zeile hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI;</code> </pre> <br>  Auf diese Weise können wir auf UI-Klassen wie <code>Text</code> zugreifen, die für Beschriftungen verwendet werden.  Fügen Sie nun der Klasse die folgende Variable hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text goldLabel;</code> </pre> <br>  Es wird ein Link zur <code>Text</code> gespeichert, mit der die Goldmenge eines Spielers angezeigt wird. <br><br>  <code>GameManager</code> wir den <code>GameManager</code> über das Etikett <code>GameManager</code> , wie synchronisieren wir die in der Variablen gespeicherte Goldmenge und den auf dem Etikett angezeigten Wert?  Wir werden eine Immobilie erstellen. <br><br>  Fügen Sie <code>GameManagerBehavior</code> den folgenden Code <code>GameManagerBehavior</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gold; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Gold { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gold; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { gold = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; goldLabel.GetComponent&lt;Text&gt;().text = <span class="hljs-string"><span class="hljs-string">"GOLD: "</span></span> + gold; } }</code> </pre> <br>  Kommt er mir bekannt vor?  Der Code ähnelt <code>CurrentLevel</code> , den wir in <code>Monster</code> .  Zuerst erstellen wir eine private Variable <code>gold</code> , um die aktuelle <code>gold</code> zu halten.  Dann setzen wir die <code>Gold</code> Eigenschaft (unerwartet, richtig?) Und implementieren den Getter und Setter. <br><br>  Der Getter gibt einfach den Wert von <code>gold</code> .  Der Setter ist interessanter.  Zusätzlich zum Festlegen des Werts der Variablen wird auch das <code>text</code> für <code>goldLabel</code> , um den neuen Goldwert anzuzeigen. <br><br>  Wie großzügig werden wir sein?  Fügen Sie <code>Start()</code> die folgende Zeile hinzu, um dem Spieler <em>1000</em> Gold oder weniger zu geben, wenn Ihnen das Geld leid tut: <br><br><pre> <code class="cs hljs">Gold = <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br><h3>  Zuweisen eines Beschriftungsobjekts zu einem Skript </h3><br>  Speichern Sie die Datei und kehren Sie zu Unity zurück.  <em>Wählen Sie</em> in der <em>Hierarchie</em> <em>GameManager aus</em> .  Klicken Sie im <em><em>Inspektor</em></em> auf den Kreis rechts neben dem <em>Goldetikett</em> .  <em>Wählen Sie im</em> Dialogfeld <em>Text</em> auswählen die Registerkarte <em>Szene</em> und dann <em>GoldLabel</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05e/82e/956/05e82e95690113e0086020a817e2718c.png"></div><br>  Führen Sie die Szene aus und auf dem Etikett wird <em>Gold: 1000</em> angezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a97/b8f/b45/a97b8fb455f50659176371e484a280e6.png"></div><br><h3>  Überprüfen der "Brieftasche" des Players </h3><br>  Öffnen Sie das Skript <em>PlaceMonster.cs</em> in der IDE und fügen Sie die folgende Instanzvariable hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager;</code> </pre> <br>  Wir werden <code>gameManager</code> um auf die <code>GameManagerBehavior</code> Komponente des <code>GameManagerBehavior</code> Objekts <em>in der</em> Szene <code>GameManagerBehavior</code> .  Fügen Sie <code>Start()</code> Folgendes hinzu, um es anzugeben: <br><br><pre> <code class="cs hljs">gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br>  Mit der Funktion <code>GameObject.Find()</code> wir ein GameObject namens GameManager, das das erste mit diesem Namen gefundene Spielobjekt zurückgibt.  Dann holen wir uns die Komponente <code>GameManagerBehavior</code> und speichern sie für die Zukunft. <br><br><blockquote>  <em>Hinweis</em> : Sie können dies tun, indem Sie im Unity-Editor ein Feld <code>GameManager</code> oder <code>GameManager</code> eine statische Methode <code>GameManager</code> , die eine Instanz des Singletons <code>GameManager</code> , von dem wir <code>GameManagerBehavior</code> . <br><br>  In dem oben gezeigten Codeblock gibt es jedoch ein dunkles Pferd: die <code>Find</code> Methode, die während der Anwendungsausführung langsamer arbeitet;  aber es ist bequem und kann in Maßen verwendet werden. </blockquote><br><h3>  Nimm mein Geld! </h3><br>  Wir haben Gold noch nicht subtrahiert, daher werden wir diese Zeile <em>zweimal</em> zu <code>OnMouseUp()</code> hinzufügen und jeden der Kommentare ersetzen <code>// TODO:  </code> : <br><br><pre> <code class="cs hljs">gameManager.Gold -= monster.GetComponent&lt;MonsterData&gt;().CurrentLevel.cost;</code> </pre> <br>  Speichern Sie die Datei und kehren Sie zu Unity zurück, aktualisieren Sie einige Monster und sehen Sie sich die Aktualisierung des Goldwerts an.  Jetzt ziehen wir Gold ab, aber Spieler können Monster bauen, solange sie genug Platz haben.  Sie leihen sich einfach Geld aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/581/2fe/eaf/5812feeafd4b9d316f8294db56d55789.png"></div><br>  <i>Unendlicher Kredit?</i>  <i>Großartig!</i>  <i>Aber wir können es nicht zulassen.</i>  <i>Der Spieler muss in der Lage sein, Monster zu setzen, solange er genug Gold hat.</i> <br><br><h3>  Goldcheck für Monster </h3><br>  <em>Wechseln Sie</em> in der IDE zu <em>PlaceMonster.cs</em> und ersetzen Sie den Inhalt von <code>CanPlaceMonster()</code> Folgendes: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost = monsterPrefab.GetComponent&lt;MonsterData&gt;().levels[<span class="hljs-number"><span class="hljs-number">0</span></span>].cost; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; gameManager.Gold &gt;= cost;</code> </pre> <br>  Wir <code>MonsterData</code> Monsterplatzierungspreis aus den <code>levels</code> in den <code>MonsterData</code> .  Dann überprüfen wir, dass das <code>monster</code> nicht <code>null</code> ist und dass <code>gameManager.Gold</code> mehr als diesen Preis ist. <br><br>  Die Aufgabe für Sie: <code>CanUpgradeMonster()</code> Sie <code>CanUpgradeMonster()</code> unabhängig <code>CanUpgradeMonster()</code> Überprüfung hinzu, ob der Spieler über genügend Gold verfügt. <br><br><div class="spoiler">  <b class="spoiler_title">Lösung im Inneren</b> <div class="spoiler_text">  Ersetzen Sie die Leitung: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  dazu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gameManager.Gold &gt;= nextLevel.cost;</code> </pre> <br>  Es wird geprüft, ob der Spieler mehr <em>Gold</em> als den Upgrade-Preis hat. </div></div><br>  Speichern Sie die Szene und führen Sie sie in Unity aus.  Versuchen Sie nun, Monster unbegrenzt hinzuzufügen! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24b/f58/b6a/24bf58b6a0a1d4258295902f5d05c6bd.png"></div><br>  <i>Jetzt können wir nur eine begrenzte Anzahl von Monstern bauen.</i> <br><br><h2>  Turmpolitik: Feinde, Wellen und Wegpunkte </h2><br>  Es ist Zeit, unseren Feinden den Weg zu ebnen.  Feinde erscheinen am ersten Punkt der Route, gehen zum nächsten und wiederholen den Vorgang, bis sie den Cookie erreichen. <br><br>  Sie können Feinde so bewegen: <br><br><ol><li>  Stellen Sie die Straße ein, der die Feinde folgen sollen </li><li>  Bewegen Sie den Feind entlang der Straße </li><li>  Drehe den Feind so, dass er nach vorne schaut </li></ol><br><h3>  Erstellen einer Straße aus Wegpunkten </h3><br>  Klicken Sie mit der rechten Maustaste auf die <em>Hierarchie</em> und wählen <em>Sie "Leer</em> erstellen", um ein neues leeres Spielobjekt zu erstellen.  Nennen Sie es <em>Straße</em> und positionieren Sie es bei <em>(0, 0, 0)</em> . <br><br>  Klicken Sie nun mit der rechten Maustaste auf <em>Straße</em> in der <em>Hierarchie</em> und erstellen Sie ein weiteres leeres Spielobjekt als Kind von Straße.  Nennen Sie es <em>Wegpunkt0</em> und platzieren Sie es am Punkt <em>(-12, 2, 0)</em> - von hier aus beginnen die Feinde ihre Bewegung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78a/21a/044/78a21a0443e9b71b4c28064196cd0f8f.png"></div><br>  Erstellen Sie auf ähnliche Weise fünf weitere Routenpunkte mit den folgenden Namen und Positionen: <br><br><ul><li>  Wegpunkt 1: (X: 7, Y: 2, Z: 0) </li><li>  Wegpunkt 2: (X: 7, Y: -1, Z: 0) </li><li>  Wegpunkt 3: (X: -7,3, Y: -1, Z: 0) </li><li>  Wegpunkt 4: (X: -7,3, Y: -4,5, Z: 0) </li><li>  Wegpunkt 5: (X: 7, Y: -4,5, Z: 0) </li></ul><br>  Der Screenshot unten zeigt die Routenpunkte und den resultierenden Pfad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png"></div><br><h2>  Feinde machen </h2><br>  Erstellen Sie nun einige Feinde, damit sie sich entlang der Straße bewegen können.  Im <em>Prefabs-</em> Ordner befindet sich ein <em>Enemy-</em> Fertighaus.  Die Position ist <em>(-20, 0, 0)</em> , sodass neue Instanzen außerhalb des Bildschirms erstellt werden. <br><br>  Im Übrigen ist es fast genauso konfiguriert wie das Monster-Fertighaus, verfügt über <code>AudioSource</code> und ein <code>Sprite</code> Kind, und wir können dieses Sprite in Zukunft drehen, ohne die Gesundheitsleiste zu drehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/5c7/b09/d465c7b0950d7c718abcb8869263753c.png"></div><br><h3>  Wir bewegen Feinde entlang der Straße </h3><br>  Fügen <em>Sie</em> dem <em>Prefabs \ Enemy Prefab</em> ein neues <em>C #</em> <em>-Skript</em> mit dem Namen <em>MoveEnemy</em> <em>hinzu</em> .  Öffnen Sie das Skript in der IDE und fügen Sie die folgenden Variablen hinzu: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">HideInInspector</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentWaypoint = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastWaypointSwitchTime; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>;</code> </pre> <br>  In <code>waypoints</code> wird eine Kopie der Routenpunkte im Array gespeichert, und die <code>[HideIn <em>inspector</em> ]</code> über den <code>waypoints</code> stellt sicher, dass wir dieses Feld im <em><em>Inspector</em></em> nicht versehentlich ändern können, aber weiterhin über andere Skripts darauf zugreifen können. <br><br>  <code>currentWaypoint</code> verfolgt, woher die Route des Feindes zur aktuellen Zeit stammt, und <code>lastWaypointSwitchTime</code> speichert die Zeit, die der Feind durchlaufen hat.  Außerdem speichern wir die <code>speed</code> Feindes. <br><br>  Fügen Sie diese Zeile zu <code>Start()</code> : <br><br><pre> <code class="cs hljs">lastWaypointSwitchTime = Time.time;</code> </pre> <br>  Also initialisieren wir <code>lastWaypointSwitchTime</code> mit dem Wert der aktuellen Zeit. <br><br>  <code>Update()</code> den folgenden Code hinzu, damit sich der Feind entlang der Route bewegen kann: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 Vector3 startPosition = waypoints [currentWaypoint].transform.position; Vector3 endPosition = waypoints [currentWaypoint + 1].transform.position; // 2 float pathLength = Vector3.Distance (startPosition, endPosition); float totalTimeForPath = pathLength / speed; float currentTimeOnPath = Time.time - lastWaypointSwitchTime; gameObject.transform.position = Vector2.Lerp (startPosition, endPosition, currentTimeOnPath / totalTimeForPath); // 3 if (gameObject.transform.position.Equals(endPosition)) { if (currentWaypoint &lt; waypoints.Length - 2) { // 3.a currentWaypoint++; lastWaypointSwitchTime = Time.time; // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">     } else { // 3.b Destroy(gameObject); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); AudioSource.PlayClipAtPoint(audioSource.clip, transform.position); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br>  Lassen Sie uns den Code Schritt für Schritt analysieren: <br><br><ol><li>  Aus dem Array von Routenpunkten erhalten wir die Start- und Endpositionen des aktuellen Routensegments. </li><li>  Wir berechnen die Zeit, die erforderlich ist, um die gesamte Strecke zurückzulegen, anhand der Formel <em>Zeit = Entfernung / Geschwindigkeit</em> und bestimmen dann die aktuelle Zeit auf der Route.  Mit <code>Vector2.Lerp</code> interpolieren wir die aktuelle Position des Feindes zwischen dem exakten Start- und Endsegment. </li><li>  Überprüfen Sie, ob der Feind die <code>endPosition</code> erreicht <code>endPosition</code> .  Wenn ja, verarbeiten wir zwei mögliche Szenarien: <br><ol><li>  Der Feind hat den letzten Punkt der Route noch nicht erreicht. Erhöhen Sie daher den Wert von <code>currentWaypoint</code> und aktualisieren Sie <code>lastWaypointSwitchTime</code> .  Später werden wir einen Code hinzufügen, um den Feind so zu drehen, dass er in die Richtung seiner Bewegung schaut. </li><li>  Der Feind hat den letzten Punkt der Route erreicht, dann zerstören wir ihn und starten den Soundeffekt.  Später werden wir einen Code hinzufügen, der die <code>health</code> des Spielers verringert. </li></ol></li></ol><br>  Speichern Sie die Datei und kehren Sie zu Unity zurück. <br><br><h3>  Wir informieren die Feinde über die Bewegungsrichtung </h3><br>  In ihrem aktuellen Zustand kennen die Feinde die Reihenfolge der Routenpunkte nicht. <br><br>  Wählen Sie <em>Straße</em> in der <em>Hierarchie aus</em> und fügen Sie ein neues <em>C #</em> <em>-Skript mit dem</em> Namen <em>SpawnEnemy hinzu</em> .  Öffnen Sie es in der IDE und fügen Sie die folgende Variable hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints;</code> </pre> <br>  Wir werden <code>waypoints</code> , um Verweise auf den Wegpunkt in der Szene in der gewünschten Reihenfolge zu speichern. <br><br>  Speichern Sie die Datei und kehren Sie zu Unity zurück.  Wählen Sie in der <em>Hierarchie Straße aus</em> und setzen Sie die <em>Größe des</em> <em>Wegpunkt-</em> Arrays auf <em>6</em> . <br><br>  Ziehen Sie jedes der Road-Kinder in die Felder, indem Sie <em>Waypoint0</em> in <em>Element 0</em> , <em>Waypoint1</em> in <em>Element 1</em> usw. <em>einfügen</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95a/1e3/251/95a1e3251247a04f62f8a618b681c052.gif"></div><br>  Jetzt haben wir ein Array, das die Routenpunkte in der richtigen Reihenfolge enthält - wohlgemerkt, die Feinde ziehen sich nie zurück, sie streben beharrlich nach einer süßen Belohnung. <br><br><h3>  Überprüfen Sie, wie alles funktioniert </h3><br>  Öffnen Sie <em>SpawnEnemy</em> in der IDE und fügen Sie die folgende Variable hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject testEnemyPrefab;</code> </pre> <br>  In <code>testEnemyPrefab</code> wird ein Verweis auf das <em>Enemy-</em> <code>testEnemyPrefab</code> . <br><br>  Fügen Sie <code>Start()</code> den folgenden Code hinzu, um beim Ausführen des Skripts einen Feind zu erstellen: <br><br><pre> <code class="cs hljs">Instantiate(testEnemyPrefab).GetComponent&lt;MoveEnemy&gt;().waypoints = waypoints;</code> </pre> <br>  Daher erstellen wir eine neue Kopie des in testEnemy gespeicherten <code>testEnemy</code> und weisen ihm eine Route zu. <br><br>  Speichern Sie die Datei und kehren Sie zu Unity zurück.  Wählen Sie das <em>Road-</em> Objekt in der <em>Hierarchie aus</em> und wählen Sie das Prefab <em>Enemy</em> für den Parameter <em>Test Enemy aus</em> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starten Sie das Projekt und sehen Sie, wie sich der Feind auf der Straße bewegt (in GIF wird die Geschwindigkeit aus Gründen der Übersichtlichkeit um das 20-fache erhöht). </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b6/b10/384/0b6b1038491a74c27d6b42860e44365e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bemerkt, dass er nicht immer hinschaut, wohin er geht? </font><font style="vertical-align: inherit;">Es ist lustig, aber wir versuchen ein professionelles Spiel zu machen. </font><font style="vertical-align: inherit;">Daher werden wir im zweiten Teil des Tutorials den Feinden beibringen, nach vorne zu schauen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wohin als nächstes? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben bereits viel getan und sind schnell dabei, unser eigenes Tower Defense-Spiel zu entwickeln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spieler können eine begrenzte Anzahl von Monstern erschaffen, und der Feind rennt die Straße entlang und geht auf unseren Keks zu. </font><font style="vertical-align: inherit;">Spieler haben Gold und können Monster verbessern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie das fertige Ergebnis </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunter </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zweiten Teil werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir die Entstehung riesiger Wellen von Feinden und deren Zerstörung betrachten. </font><font style="vertical-align: inherit;">Bis dann!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413837/">https://habr.com/ru/post/de413837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413817/index.html">Heterogene wettbewerbsfähige Datenverarbeitung in Echtzeit nur einmal</a></li>
<li><a href="../de413819/index.html">Ehrlich gesagt über den IT-Markt in Russland</a></li>
<li><a href="../de413823/index.html">Der Boom bedeutungsloser Beschäftigung</a></li>
<li><a href="../de413827/index.html">Das Kubernetes-Projekt wird 4 Jahre alt</a></li>
<li><a href="../de413831/index.html">Die neue Version des Tesla Autopilot wird im August erstmals mit „vollständig autonomen Fahrfunktionen“ veröffentlicht.</a></li>
<li><a href="../de413839/index.html">KI, praktischer Kurs. Sammlung und Recherche von Bildern</a></li>
<li><a href="../de413841/index.html">Alternativen zu Google-Produkten</a></li>
<li><a href="../de413843/index.html">Waymo vor den anderen: Die Robomobile des Unternehmens sind 11 Millionen Kilometer gerollt</a></li>
<li><a href="../de413847/index.html">"Lebendiges" Triggerdenkmal</a></li>
<li><a href="../de413849/index.html">Sennheiser Markengeschichte: Freiheit und Vision</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>