<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äç‚öïÔ∏è üê∫ üëºüèæ Tower Defense zu einem Einheitsspiel machen - Teil 1 üßë‚Äçü§ù‚Äçüßë üõÖ üö≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tower Defense-Spiele werden immer beliebter, und das ist nicht verwunderlich - wenig kann mit dem Vergn√ºgen verglichen werden, eigene Verteidigungslin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tower Defense zu einem Einheitsspiel machen - Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413837/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png" alt="Bild"></div><br>  Tower Defense-Spiele werden immer beliebter, und das ist nicht verwunderlich - wenig kann mit dem Vergn√ºgen verglichen werden, eigene Verteidigungslinien zu beobachten, die b√∂se Feinde zerst√∂ren!  In diesem zweiteiligen Tutorial erstellen wir ein Tower Defense-Spiel auf der <em>Unity-</em> Engine! <br><br>  Sie lernen, wie Sie Folgendes tun: <br><br><ul><li>  Erschaffe Wellen von Feinden </li><li>  Lassen Sie sie Routenpunkten folgen </li><li>  Baue und verbessere T√ºrme und lehre sie, wie man Feinde in kleine Pixel zerlegt </li></ul><br>  Am Ende bekommen wir den Rahmen des Spiels, der weiterentwickelt werden kann! <br><a name="habracut"></a><br><blockquote>  <em>Hinweis</em> : Sie ben√∂tigen grundlegende Unity-Kenntnisse (z. B. m√ºssen Sie wissen, wie Assets und Komponenten hinzugef√ºgt werden, welche Fertigh√§user vorhanden sind) und die Grundlagen von <em>C #</em> .  Um all dies zu lernen, empfehle ich Ihnen, die Tutorials zu Unity von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sean Duffy</a> oder die Reihe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beginning C # with Unity</a> von Brian Mockley durchzugehen. </blockquote><br>  Ich werde in Unity f√ºr OS X arbeiten, aber dieses Tutorial ist auch f√ºr Windows geeignet. <br><br><h2>  Durch die Fenster des Elfenbeinturms </h2><br>  In diesem Tutorial erstellen wir ein Tower Defense-Spiel, in dem Feinde (kleine Bugs) zu einem Cookie kriechen, der Ihnen und Ihren Schergen geh√∂rt (nat√ºrlich sind dies Monster!).  Der Spieler kann Monster an strategischen Punkten platzieren und sie f√ºr Gold verbessern. <br><br>  Der Spieler muss alle Bugs t√∂ten, bis sie zum Cookie gelangen.  Jede neue Welle von Feinden wird immer schwieriger zu besiegen.  Das Spiel endet, wenn Sie alle Wellen √ºberleben (Sieg!) Oder wenn f√ºnf Feinde zu den Keksen kriechen (Verlust!). <br><br>  Hier ist ein Screenshot des fertigen Spiels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/782/a94/fef/782a94fefd675365aba52fbfc4008ab6.png"></div><br>  <i>Monster, vereinigt euch!</i>  <i>Sch√ºtzen Sie den Cookie!</i> <br><br><h2>  An die Arbeit gehen </h2><br>  Laden Sie dieses <a href="">Projekt leer</a> herunter, entpacken Sie es und √∂ffnen Sie das <em>TowerDefense-Part1-Starter-</em> Projekt in Unity. <br><br>  Der Projektentwurf enth√§lt zahlreiche Grafiken und Sounds, vorgefertigte Animationen und mehrere n√ºtzliche Skripte.  Die Skripte stehen nicht in direktem Zusammenhang mit Tower Defense-Spielen, daher werde ich hier nicht darauf eingehen.  Wenn Sie jedoch mehr √ºber das Erstellen von 2D-Animationen in Unity erfahren m√∂chten, lesen Sie dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Unity 2D-Tutorial">Unity 2D-Lernprogramm</a> . <br><br>  Das Projekt enth√§lt auch Fertigh√§user, die wir sp√§ter hinzuf√ºgen werden, um Charaktere zu erstellen.  Schlie√ülich gibt es im Projekt eine Szene mit einem Hintergrund und einer benutzerdefinierten Benutzeroberfl√§che. <br><br>  √ñffnen Sie die <em>GameScene</em> im Ordner " <em>Szenen</em> " und stellen Sie den <em>Spielemodus</em> auf ein Seitenverh√§ltnis von <em>4: 3 ein,</em> damit alle Beschriftungen korrekt zum Hintergrund passen.  Im Spielemodus sehen Sie Folgendes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb7/050/bda/fb7050bda1d91c148f65e70a7c217083.png"></div><br>  <em>Autorschaft:</em> <br><br><ul><li>  Die Grafiken f√ºr das Projekt stammen aus dem kostenlosen Wiki Wenderlich Pack!  Weitere grafische Arbeiten finden Sie auf ihrer Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="gameartguppy">gameartguppy</a> . </li><li>  Gro√üartige Musik von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Benound">BenSound</a> , die andere gro√üartige Soundtracks enth√§lt! </li><li>  Ich danke auch Michael Jesper f√ºr die sehr n√ºtzliche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Kamera sch√ºtteln">Kameraverwacklungsfunktion.</a> </li></ul>  . <br><h2>  Der Ort ist mit einem Kreuz markiert: der Ort der Monster </h2><br>  Monster k√∂nnen nur auf Punkte gelegt werden, die mit einem <em>x</em> markiert sind. <br><br>  Um sie der Szene hinzuzuf√ºgen, ziehen Sie <em>Images \ Objects \ Openspot</em> aus dem <em>Projektbrowser</em> in das <em>Szenenfenster</em> .  W√§hrend die Position f√ºr uns nicht wichtig ist. <br><br>  Nachdem Sie in der Hierarchie <em>Openspot</em> ausgew√§hlt haben, klicken <em>Sie</em> im <em><em>Inspektor</em></em> auf <em>Komponente</em> <em>hinzuf√ºgen</em> und w√§hlen Sie <em>Box Collider 2D</em> .  Im Szenenfenster zeigt Unity einen rechteckigen Collider mit einer gr√ºnen Linie an.  Wir werden diesen Collider verwenden, um Mausklicks an dieser Stelle zu erkennen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/6a9/3da/2716a93da69de6b5cf73a7edfc794210.png"></div><br>  F√ºgen Sie die Komponente <em>Audio \ Audio Source</em> auf <em>die</em> gleiche Weise zu <em>Openspot hinzu</em> .  <em>W√§hlen Sie</em> f√ºr den <em>AudioClip-</em> Parameter der Audio Source-Komponente die Datei <em>tunnel_place aus</em> , die sich im <em>Audio-</em> Ordner befindet, und deaktivieren Sie <em>Play On Awake</em> . <br><br>  Wir m√ºssen 11 weitere Punkte schaffen.  Obwohl die Versuchung besteht, all diese Schritte zu wiederholen, hat Unity eine bessere L√∂sung: <em>Fertighaus</em> ! <br><br>  Ziehen Sie <em>Openspot</em> aus der <em>Hierarchie</em> in den Ordner <em>Prefabs</em> im <em>Projektbrowser</em> .  Sein Name wird in der Hierarchie blau, was bedeutet, dass er an das Fertighaus angeh√§ngt ist.  Ungef√§hr so: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad3/cb2/6a0/ad3cb26a0d51c893dd040e8f4f5dfea6.gif"></div><br>  Nachdem wir das vorgefertigte Leerzeichen haben, k√∂nnen wir so viele Kopien erstellen, wie wir m√∂chten.  Ziehen Sie <em>Openspot</em> einfach per Drag &amp; Drop aus dem <em>Prefabs-</em> Ordner im <em>Projektbrowser</em> in das <em>Szenenfenster</em> .  Wiederholen Sie dies 11 Mal und 12 Openspot-Objekte werden in der Szene angezeigt. <br><br>  Verwenden Sie nun den <em>Inspektor</em> , um diese 12 Openspot-Objekte mit den folgenden Koordinaten festzulegen: <br><br><ul><li>  (X: -5,2, Y: 3,5, Z: 0) </li><li>  (X: -2,2, Y: 3,5, Z: 0) </li><li>  (X: 0,8, Y: 3,5, Z: 0) </li><li>  (X: 3,8, Y: 3,5, Z: 0) </li><li>  (X: -3,8, Y: 0,4, Z: 0) </li><li>  (X: -0,8, Y: 0,4, Z: 0) </li><li>  (X: 2,2, Y: 0,4, Z: 0) </li><li>  (X: 5,2, Y: 0,4, Z: 0) </li><li>  (X: -5,2, Y: -3,0, Z: 0) </li><li>  (X: -2,2, Y: -3,0, Z: 0) </li><li>  (X: 0,8, Y: -3,0, Z: 0) </li><li>  (X: 3,8, Y: -3,0, Z: 0) </li></ul><br>  Wenn Sie dies tun, sieht die Szene folgenderma√üen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/248/fb2/69e248fb213cfee35ce43f5f9c14baeb.png"></div><br><h2>  Wir platzieren Monster </h2><br>  Um die Platzierung zu vereinfachen, befindet sich im <em>Prefab-</em> Ordner des Projekts ein <em>Monster-</em> Fertighaus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c65/908/80a/c6590880acbdbac94bd15ec023311235.png"></div><br>  <i>Monster Prefab Gebrauchsfertig</i> <br><br>  Im Moment besteht es aus einem leeren Spielobjekt mit drei verschiedenen Sprites und Schie√üanimationen als Kinder. <br><br>  Jedes Sprite ist ein Monster mit unterschiedlichen St√§rken.  Das Fertighaus enth√§lt auch die <em>Audio Source-</em> Komponente, die gestartet wird, um Sound abzuspielen, wenn ein Monster einen Laser abfeuert. <br><br>  Jetzt werden wir ein Skript erstellen, das <em>Monster</em> auf <em>Openspot hostet</em> . <br><br>  <em>W√§hlen</em> Sie im <em>Projektbrowser</em> das <em>Openspot-</em> Objekt im Ordner <em>Prefabs aus</em> .  Klicken <em>Sie</em> im <em>Inspektor</em> auf <em>Komponente</em> <em>hinzuf√ºgen</em> , w√§hlen Sie <em>Neues Skript aus</em> und benennen Sie das Skript <em>PlaceMonster</em> .  W√§hlen Sie <em>C Sharp</em> als Sprache und klicken Sie auf <em>Erstellen und Hinzuf√ºgen</em> .  Da wir das Skript zum <i>Openspot-</i> Prefab <i>hinzugef√ºgt</i> haben, haben alle Openspot-Objekte in der Szene jetzt dieses Skript.  Gro√üartig! <br><br>  Doppelklicken Sie auf das Skript, um es in der IDE zu √∂ffnen.  F√ºgen Sie dann zwei Variablen hinzu: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject monsterPrefab; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject monster;</code> </pre> <br>  Wir werden eine Instanz des in <code>monsterPrefab</code> gespeicherten <code>monsterPrefab</code> erstellen, um das Monster zu erstellen, und es in <code>monster</code> speichern, damit es w√§hrend des Spiels manipuliert werden kann. <br><br><h3>  Ein Monster pro Punkt </h3><br>  F√ºgen Sie die folgende Methode hinzu, damit nur ein Monster auf einen Punkt gesetzt werden kann: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanPlaceMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  In <code>CanPlaceMonster()</code> wir √ºberpr√ºfen, ob die <code>monster</code> noch <code>null</code> .  Wenn ja, dann gibt es kein Monster an der Stelle, und wir k√∂nnen es platzieren. <br><br>  F√ºge nun den folgenden Code hinzu, um das Monster zu platzieren, wenn der Spieler auf dieses GameObject klickt: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 void OnMouseUp() { //2 if (CanPlaceMonster()) { //3 monster = (GameObject) Instantiate(monsterPrefab, transform.position, Quaternion.identity); //4 AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br>  Dieser Code findet das Monster, wenn Sie mit der Maus klicken oder den Bildschirm ber√ºhren.  Wie arbeitet er? <br><br><ol><li>  Unity ruft <code>OnMouseUp</code> automatisch <code>OnMouseUp</code> wenn ein Spieler den physischen Collider GameObject ber√ºhrt. </li><li>  Beim Aufruf setzt diese Methode ein Monster, wenn <code>CanPlaceMonster()</code> <code>true</code> zur√ºckgibt. </li><li>  Wir erstellen ein Monster mit der <code>Instantiate</code> Methode, die eine Instanz des angegebenen Fertighauses mit der angegebenen Position und Drehung erstellt.  In diesem Fall kopieren wir <code>monsterPrefab</code> , geben ihm die aktuelle GameObject-Position und keine Drehung, √ºbertragen das Ergebnis auf <code>GameObject</code> und speichern es in <code>monster</code> </li><li>  Am Ende rufen wir <code>PlayOneShot</code> auf, um den Soundeffekt <code>PlayOneShot</code> , der an die <code>AudioSource</code> Komponente des Objekts angeh√§ngt ist. </li></ol><br>  Jetzt kann unser <code>PlaceMonster</code> Skript ein neues Monster haben, aber wir m√ºssen noch ein Fertighaus angeben. <br><br><h3>  Verwenden des richtigen Fertighauses </h3><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck. <br><br>  Um die Variable <em>monsterPrefab festzulegen</em> , w√§hlen <em>Sie</em> zuerst das <em>Openspot-</em> Objekt aus dem Ordner <em>Prefabs</em> im Browser des Projekts aus. <br><br>  Klicken Sie im <em><em>Inspektor</em></em> auf den Kreis rechts neben dem Feld <em>Monster Prefab</em> der <em>PlaceMonster (Script)</em> -Komponente und w√§hlen Sie im angezeigten Dialogfeld <em>Monster aus</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/8bc/9c7/b878bc9c77c6e7c63a54f4a87d2a7c42.gif"></div><br>  Das ist alles.  Starte die Szene und erstelle Monster an verschiedenen Orten, indem du mit der Maus klickst oder den Bildschirm ber√ºhrst. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/f08/01d/095f0801ddbbc91ce0eca144a22d4f7b.png"></div><br>  Gro√üartig!  Jetzt k√∂nnen wir Monster erschaffen.  Sie sehen jedoch wie ein seltsames Durcheinander aus, da alle Kindergeister des Monsters gezeichnet sind.  Jetzt werden wir es beheben. <br><br><h2>  Erh√∂he das Level der Monster </h2><br>  Die folgende Abbildung zeigt, dass Monster mit zunehmendem Level immer furchterregender aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a92/23d/480/a9223d480dda51f941c3b0b82f9f0dd6.png"></div><br>  <i>Was f√ºr eine S√º√üe!</i>  <i>Aber wenn Sie versuchen, seine Kekse zu stehlen, wird dieses Monster zum M√∂rder.</i> <br><br>  Das Skript wird als Grundlage f√ºr die Implementierung des Systems der Monsterlevel verwendet.  Es verfolgt die Macht des Monsters in jedem Level und nat√ºrlich das aktuelle Level des Monsters. <br><br>  F√ºgen Sie dieses Skript hinzu. <br><br>  W√§hlen Sie das <em>Prefabs / Monster</em> Prefab im <em>Projektbrowser</em> .  F√ºgen Sie ein neues <em>C #</em> -Skript namens <em>MonsterData hinzu</em> .  √ñffnen Sie das Skript in der IDE und f√ºgen Sie den folgenden Code <i>√ºber</i> der <code>MonsterData</code> Klasse hinzu. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MonsterLevel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject visualization; }</code> </pre> <br>  Also erstellen wir <code>MonsterLevel</code> .  Es gruppiert den Preis (in Gold, den wir unten unterst√ºtzen werden) und eine visuelle Darstellung des Levels des Monsters. <br><br>  Wir f√ºgen zus√§tzlich zu <code>[System.Serializable]</code> damit Klasseninstanzen im Inspektor ge√§ndert werden k√∂nnen.  Dadurch k√∂nnen wir schnell alle Werte der Level-Klasse √§ndern, auch wenn das Spiel l√§uft.  Dies ist unglaublich n√ºtzlich, um das Spiel auszugleichen. <br><br><h3>  Monster Level einstellen </h3><br>  In unserem Fall speichern wir das angegebene <code>MonsterLevel</code> in <code>List&lt;T&gt;</code> . <br><br>  Warum nicht einfach <code>MonsterLevel[]</code> ?  Wir ben√∂tigen den Index eines bestimmten <code>MonsterLevel</code> Objekts mehrmals.  Obwohl es einfach ist, Code daf√ºr zu schreiben, m√ºssen wir dennoch <code>IndexOf()</code> , das die <code>Lists</code> Funktionalit√§t implementiert.  Es macht keinen Sinn, das Rad neu zu erfinden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aae/85f/785/aae85f7854f44c8f418c5fde22153a53.jpg"></div><br>  <i>Das Fahrrad neu zu erfinden ist normalerweise eine schlechte Idee.</i> <br><br>  <em>F√ºgen Sie</em> oben in <em>MonsterData.cs</em> <code>using</code> Konstrukts Folgendes hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic;</code> </pre> <br>  Es gibt uns Zugriff auf verallgemeinerte Datenstrukturen, sodass wir die <code>List&lt;T&gt;</code> -Klasse im Skript verwenden k√∂nnen. <br><br><blockquote>  <em>Hinweis</em> : Verallgemeinerungen sind ein leistungsf√§higes C # -Konzept.  Mit ihnen k√∂nnen Sie typsichere Datenstrukturen angeben, ohne den Typ einhalten zu m√ºssen.  Dies ist n√ºtzlich f√ºr Containerklassen wie Listen und Mengen.  Weitere Informationen zu generischen Strukturen finden Sie im Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Einf√ºhrung in C # Generics">Einf√ºhrung in C # Generics</a> . </blockquote><br>  <code>MonsterLevel</code> nun <code>MonsterData</code> die folgende Variable hinzu, um die <code>MonsterLevel</code> Liste zu <code>MonsterLevel</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;MonsterLevel&gt; levels;</code> </pre> <br>  Dank Verallgemeinerungen k√∂nnen wir garantieren, dass die <code>List</code> von <code>level</code> nur <code>MonsterLevel</code> Objekte enth√§lt. <br><br>  Speichern Sie die Datei und wechseln Sie zu Unity, um die einzelnen Ebenen zu konfigurieren. <br><br>  W√§hlen Sie <em>Prefabs / Monster</em> im <em>Projektbrowser</em> .  Der <em><em>Inspektor</em></em> zeigt jetzt das Feld <em>Ebenen</em> der <em>MonsterData (Script)</em> -Komponente an.  Stellen Sie die <em>Gr√∂√üe</em> auf <em>3 ein</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/660/dda/a18/660ddaa185b824721453ca1c892eedff.png"></div><br>  Als n√§chstes legen Sie die <em>Kosten</em> f√ºr jede Ebene fest: <br><br><ul><li>  <em>Element 0</em> : <em>200</em> </li><li>  <em>Element 1</em> : <em>110</em> </li><li>  <em>Element 2</em> : <em>120</em> </li></ul><br>  Jetzt weisen wir die Werte der visuellen Anzeigefelder zu. <br><br>  Erweitern Sie <em>Prefabs / Monster</em> im Projektbrowser, um die <em>untergeordneten</em> Elemente <em>anzuzeigen</em> .  Ziehen Sie das <em>untergeordnete Monster0</em> in das Feld <em>Visualisierungselement</em> <em>0</em> . <br><br>  Als n√§chstes setzen Sie <em>Element 1</em> auf <em>Monster1</em> und <em>Element 2</em> auf <em>Monster2</em> .  Das GIF zeigt diesen Prozess: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/662/404/e30/662404e30bd808e1cf9a9d34b47d4d61.gif"></div><br>  Wenn Sie <em>Prefabs / Monster</em> ausw√§hlen, sollte das Prefab folgenderma√üen aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80b/e4d/17e/80be4d17e9894cf291b7be8a44152044.png"></div><br><h3>  Aktuelle Stufe einstellen </h3><br>  Gehen Sie in der IDE zur√ºck zu <em>MonsterData.cs</em> und f√ºgen Sie <code>MonsterData</code> eine weitere Variable hinzu. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MonsterLevel currentLevel;</code> </pre> <br>  In der privaten Variablen <code>currentLevel</code> speichern wir das aktuelle Level des Monsters. <br><br>  <code>currentLevel</code> Sie nun <code>currentLevel</code> und machen Sie es f√ºr andere Skripte sichtbar.  F√ºgen Sie <code>MonsterData</code> die folgenden Zeilen zusammen mit der Deklaration von Instanzvariablen hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 public MonsterLevel CurrentLevel { //2 get { return currentLevel; } //3 set { currentLevel = value; int currentLevelIndex = levels.IndexOf(currentLevel); GameObject levelVisualization = levels[currentLevelIndex].visualization; for (int i = 0; i &lt; levels.Count; i++) { if (levelVisualization != null) { if (i == currentLevelIndex) { levels[i].visualization.SetActive(true); } else { levels[i].visualization.SetActive(false); } } } } }</span></span></code> </pre> <br>  Ziemlich gro√üer Teil des C # -Codes, oder?  Nehmen wir es in der Reihenfolge: <br><br><ol><li>  <code>currentLevel</code> Sie die <em>Eigenschaft der</em> privaten Variablen <code>currentLevel</code> .  Durch Festlegen der Eigenschaft k√∂nnen wir sie wie jede andere Variable aufrufen: entweder als <code>CurrentLevel</code> (innerhalb der Klasse) oder als <code>monster.CurrentLevel</code> (au√üerhalb).  Wir k√∂nnen jedes Verhalten in der Getter- oder Setter-Methode einer Eigenschaft definieren, und indem wir nur einen Getter, Setter oder beide erstellen, k√∂nnen wir die Eigenschaften der Eigenschaft steuern: schreibgesch√ºtzt, schreibgesch√ºtzt und schreiben / lesen. </li><li>  Im Getter geben wir den Wert von <code>currentLevel</code> . </li><li>  Im Setter weisen wir <code>currentLevel</code> neuen Wert zu.  Dann erhalten wir den Index des aktuellen Niveaus.  Schlie√ülich durchlaufen wir alle <em>Ebenen</em> und aktivieren / deaktivieren die visuelle Anzeige abh√§ngig von <code>currentLevelIndex</code> .  Dies ist gro√üartig, da das Sprite automatisch aktualisiert wird, wenn sich <code>currentLevel</code> √§ndert.  Eigenschaften sind eine sehr bequeme Sache! </li></ol><br>  F√ºgen Sie die folgende <code>OnEnable</code> Implementierung hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentLevel = levels[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br>  Hier setzen wir <code>CurrentLevel</code> beim Platzieren.  Dadurch wird sichergestellt, dass nur das gew√ºnschte Sprite angezeigt wird. <br><br><blockquote>  <em>Hinweis</em> : Es ist wichtig, die Eigenschaft in <code>OnEnable</code> und nicht in <code>OnStart</code> zu initialisieren, da beim Erstellen vorgefertigter Instanzen die Ordnungsmethoden aufgerufen werden. <br><br>  <code>OnEnable</code> wird sofort aufgerufen, wenn das Fertighaus erstellt wird (wenn das Fertighaus im aktivierten Zustand gespeichert wurde), <code>OnStart</code> erst aufgerufen, wenn das Objekt als Teil der Szene ausgef√ºhrt wird. <br><br>  Wir m√ºssen diese Daten √ºberpr√ºfen, bevor wir das Monster platzieren, also initialisieren wir sie auf <code>OnEnable</code> . </blockquote><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  F√ºhre das Projekt aus und platziere die Monster.  Sie zeigen jetzt die richtigen Sprites der untersten Ebene an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08e/16e/549/08e16e5498d12f78d106d873d34c8d1b.png"></div><br><h3>  Monster Upgrade </h3><br>  Kehren Sie zur IDE zur√ºck und f√ºgen Sie <code>MonsterData</code> die folgende Methode hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MonsterLevel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNextLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf (currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxLevelIndex = levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; maxLevelIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> levels[currentLevelIndex+<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br>  In <code>GetNextLevel</code> wir den <code>currentLevel</code> Index und den Index der h√∂chsten Ebene.  Wenn das Monster das maximale Level nicht erreicht hat, kehrt das n√§chste Level zur√ºck.  Andernfalls wird <code>null</code> zur√ºckgegeben. <br><br>  Mit dieser Methode kannst du herausfinden, ob ein Monster-Upgrade m√∂glich ist. <br><br>  F√ºge die folgende Methode hinzu, um das Level des Monsters zu erh√∂hen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf(currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>) { CurrentLevel = levels[currentLevelIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>]; } }</code> </pre> <br>  Hier erhalten wir den Index der aktuellen Ebene und stellen dann sicher, dass dies nicht die maximale Ebene ist. √úberpr√ºfen Sie, ob diese unter den Ebenen liegt. <code>levels.Count - 1</code> .  Wenn ja, <code>CurrentLevel</code> auf die n√§chste Stufe. <br><br><h3>  √úberpr√ºfen der Upgrade-Funktionalit√§t </h3><br>  Speichern Sie die Datei und kehren <em>Sie</em> in der IDE zu <em>PlaceMonster.cs</em> zur√ºck.  F√ºgen Sie eine neue Methode hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanUpgradeMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (monster != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { MonsterData monsterData = monster.GetComponent&lt;MonsterData&gt;(); MonsterLevel nextLevel = monsterData.GetNextLevel(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextLevel != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Zuerst pr√ºfen wir, ob es ein Monster gibt, das verbessert werden kann, indem wir die <code>monster</code> mit <code>null</code> .  Wenn dies wahr ist, erhalten wir das aktuelle Monsterlevel aus seinen <code>MonsterData</code> . <br><br>  Dann pr√ºfen wir, ob die n√§chste Ebene verf√ºgbar ist, <code>GetNextLevel()</code> ob <code>GetNextLevel()</code> nicht <code>null</code> <code>GetNextLevel()</code> .  Wenn eine Pegelerh√∂hung m√∂glich ist, geben wir <code>true</code> .  Andernfalls wird <code>false</code> . <br><br><h3>  Wir implementieren Verbesserungen f√ºr Gold </h3><br>  <code>OnMouseUp</code> zum Aktivieren der Upgrade-Option den Zweig <code>else if</code> zu <code>OnMouseUp</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanPlaceMonster()) { <span class="hljs-comment"><span class="hljs-comment">//      } else if (CanUpgradeMonster()) { monster.GetComponent&lt;MonsterData&gt;().IncreaseLevel(); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   }</span></span></code> </pre> <br>  Wir pr√ºfen die M√∂glichkeit eines Upgrades mit <code>CanUpgradeMonster()</code> .  Wenn m√∂glich, greifen wir mit <code>GetComponent()</code> auf die <code>MonsterData</code> Komponente zu und rufen <code>IncreaseLevel()</code> , wodurch sich das Level des Monsters erh√∂ht.  Schlie√ülich starten wir die Monster <em>AudioSource</em> . <br><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  F√ºhre das Spiel aus, platziere und verbessere eine <i>beliebige Anzahl von</i> Monstern (aber vorerst). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/495/bed/cb7495bed8ebcd3993439de25a08a0e7.png"></div><br><h2>  Gold bezahlen - Game Manager </h2><br>  Wir k√∂nnen zwar sofort Monster bauen und verbessern, aber wird es im Spiel interessant sein? <br><br>  Schauen wir uns das Thema Gold an.  Das Problem beim Verfolgen ist, dass wir Informationen zwischen verschiedenen Spielobjekten √ºbertragen m√ºssen. <br><br>  Die folgende Abbildung zeigt alle Objekte, die daran teilnehmen sollen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e35/8cd/6f4/e358cd6f461c75385f61f1c12862a16b.png"></div><br>  <i>Alle ausgew√§hlten Spielobjekte m√ºssen wissen, wie viel Gold ein Spieler hat.</i> <br><br>  Um diese Daten zu speichern, verwenden wir ein gemeinsames Objekt, auf das andere Objekte zugreifen k√∂nnen. <br><br>  Klicken Sie mit der rechten Maustaste auf die <em>Hierarchie</em> und w√§hlen <em>Sie Leer erstellen</em> .  <em>Benennen Sie</em> das neue <em>GameManager-</em> Objekt. <br><br>  F√ºgen <em>Sie GameManager</em> ein neues <em>C #</em> <em>-Skript mit dem</em> Namen <em>GameManagerBehavior hinzu</em> und √∂ffnen Sie es in der IDE.  Wir zeigen die Gesamtmenge an Spielergold auf dem Etikett an. F√ºgen Sie daher oben in der Datei die folgende Zeile hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI;</code> </pre> <br>  Auf diese Weise k√∂nnen wir auf UI-Klassen wie <code>Text</code> zugreifen, die f√ºr Beschriftungen verwendet werden.  F√ºgen Sie nun der Klasse die folgende Variable hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text goldLabel;</code> </pre> <br>  Es wird ein Link zur <code>Text</code> gespeichert, mit der die Goldmenge eines Spielers angezeigt wird. <br><br>  <code>GameManager</code> wir den <code>GameManager</code> √ºber das Etikett <code>GameManager</code> , wie synchronisieren wir die in der Variablen gespeicherte Goldmenge und den auf dem Etikett angezeigten Wert?  Wir werden eine Immobilie erstellen. <br><br>  F√ºgen Sie <code>GameManagerBehavior</code> den folgenden Code <code>GameManagerBehavior</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gold; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Gold { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gold; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { gold = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; goldLabel.GetComponent&lt;Text&gt;().text = <span class="hljs-string"><span class="hljs-string">"GOLD: "</span></span> + gold; } }</code> </pre> <br>  Kommt er mir bekannt vor?  Der Code √§hnelt <code>CurrentLevel</code> , den wir in <code>Monster</code> .  Zuerst erstellen wir eine private Variable <code>gold</code> , um die aktuelle <code>gold</code> zu halten.  Dann setzen wir die <code>Gold</code> Eigenschaft (unerwartet, richtig?) Und implementieren den Getter und Setter. <br><br>  Der Getter gibt einfach den Wert von <code>gold</code> .  Der Setter ist interessanter.  Zus√§tzlich zum Festlegen des Werts der Variablen wird auch das <code>text</code> f√ºr <code>goldLabel</code> , um den neuen Goldwert anzuzeigen. <br><br>  Wie gro√üz√ºgig werden wir sein?  F√ºgen Sie <code>Start()</code> die folgende Zeile hinzu, um dem Spieler <em>1000</em> Gold oder weniger zu geben, wenn Ihnen das Geld leid tut: <br><br><pre> <code class="cs hljs">Gold = <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br><h3>  Zuweisen eines Beschriftungsobjekts zu einem Skript </h3><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  <em>W√§hlen Sie</em> in der <em>Hierarchie</em> <em>GameManager aus</em> .  Klicken Sie im <em><em>Inspektor</em></em> auf den Kreis rechts neben dem <em>Goldetikett</em> .  <em>W√§hlen Sie im</em> Dialogfeld <em>Text</em> ausw√§hlen die Registerkarte <em>Szene</em> und dann <em>GoldLabel</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05e/82e/956/05e82e95690113e0086020a817e2718c.png"></div><br>  F√ºhren Sie die Szene aus und auf dem Etikett wird <em>Gold: 1000</em> angezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a97/b8f/b45/a97b8fb455f50659176371e484a280e6.png"></div><br><h3>  √úberpr√ºfen der "Brieftasche" des Players </h3><br>  √ñffnen Sie das Skript <em>PlaceMonster.cs</em> in der IDE und f√ºgen Sie die folgende Instanzvariable hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager;</code> </pre> <br>  Wir werden <code>gameManager</code> um auf die <code>GameManagerBehavior</code> Komponente des <code>GameManagerBehavior</code> Objekts <em>in der</em> Szene <code>GameManagerBehavior</code> .  F√ºgen Sie <code>Start()</code> Folgendes hinzu, um es anzugeben: <br><br><pre> <code class="cs hljs">gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br>  Mit der Funktion <code>GameObject.Find()</code> wir ein GameObject namens GameManager, das das erste mit diesem Namen gefundene Spielobjekt zur√ºckgibt.  Dann holen wir uns die Komponente <code>GameManagerBehavior</code> und speichern sie f√ºr die Zukunft. <br><br><blockquote>  <em>Hinweis</em> : Sie k√∂nnen dies tun, indem Sie im Unity-Editor ein Feld <code>GameManager</code> oder <code>GameManager</code> eine statische Methode <code>GameManager</code> , die eine Instanz des Singletons <code>GameManager</code> , von dem wir <code>GameManagerBehavior</code> . <br><br>  In dem oben gezeigten Codeblock gibt es jedoch ein dunkles Pferd: die <code>Find</code> Methode, die w√§hrend der Anwendungsausf√ºhrung langsamer arbeitet;  aber es ist bequem und kann in Ma√üen verwendet werden. </blockquote><br><h3>  Nimm mein Geld! </h3><br>  Wir haben Gold noch nicht subtrahiert, daher werden wir diese Zeile <em>zweimal</em> zu <code>OnMouseUp()</code> hinzuf√ºgen und jeden der Kommentare ersetzen <code>// TODO:  </code> : <br><br><pre> <code class="cs hljs">gameManager.Gold -= monster.GetComponent&lt;MonsterData&gt;().CurrentLevel.cost;</code> </pre> <br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck, aktualisieren Sie einige Monster und sehen Sie sich die Aktualisierung des Goldwerts an.  Jetzt ziehen wir Gold ab, aber Spieler k√∂nnen Monster bauen, solange sie genug Platz haben.  Sie leihen sich einfach Geld aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/581/2fe/eaf/5812feeafd4b9d316f8294db56d55789.png"></div><br>  <i>Unendlicher Kredit?</i>  <i>Gro√üartig!</i>  <i>Aber wir k√∂nnen es nicht zulassen.</i>  <i>Der Spieler muss in der Lage sein, Monster zu setzen, solange er genug Gold hat.</i> <br><br><h3>  Goldcheck f√ºr Monster </h3><br>  <em>Wechseln Sie</em> in der IDE zu <em>PlaceMonster.cs</em> und ersetzen Sie den Inhalt von <code>CanPlaceMonster()</code> Folgendes: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost = monsterPrefab.GetComponent&lt;MonsterData&gt;().levels[<span class="hljs-number"><span class="hljs-number">0</span></span>].cost; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; gameManager.Gold &gt;= cost;</code> </pre> <br>  Wir <code>MonsterData</code> Monsterplatzierungspreis aus den <code>levels</code> in den <code>MonsterData</code> .  Dann √ºberpr√ºfen wir, dass das <code>monster</code> nicht <code>null</code> ist und dass <code>gameManager.Gold</code> mehr als diesen Preis ist. <br><br>  Die Aufgabe f√ºr Sie: <code>CanUpgradeMonster()</code> Sie <code>CanUpgradeMonster()</code> unabh√§ngig <code>CanUpgradeMonster()</code> √úberpr√ºfung hinzu, ob der Spieler √ºber gen√ºgend Gold verf√ºgt. <br><br><div class="spoiler">  <b class="spoiler_title">L√∂sung im Inneren</b> <div class="spoiler_text">  Ersetzen Sie die Leitung: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  dazu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gameManager.Gold &gt;= nextLevel.cost;</code> </pre> <br>  Es wird gepr√ºft, ob der Spieler mehr <em>Gold</em> als den Upgrade-Preis hat. </div></div><br>  Speichern Sie die Szene und f√ºhren Sie sie in Unity aus.  Versuchen Sie nun, Monster unbegrenzt hinzuzuf√ºgen! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24b/f58/b6a/24bf58b6a0a1d4258295902f5d05c6bd.png"></div><br>  <i>Jetzt k√∂nnen wir nur eine begrenzte Anzahl von Monstern bauen.</i> <br><br><h2>  Turmpolitik: Feinde, Wellen und Wegpunkte </h2><br>  Es ist Zeit, unseren Feinden den Weg zu ebnen.  Feinde erscheinen am ersten Punkt der Route, gehen zum n√§chsten und wiederholen den Vorgang, bis sie den Cookie erreichen. <br><br>  Sie k√∂nnen Feinde so bewegen: <br><br><ol><li>  Stellen Sie die Stra√üe ein, der die Feinde folgen sollen </li><li>  Bewegen Sie den Feind entlang der Stra√üe </li><li>  Drehe den Feind so, dass er nach vorne schaut </li></ol><br><h3>  Erstellen einer Stra√üe aus Wegpunkten </h3><br>  Klicken Sie mit der rechten Maustaste auf die <em>Hierarchie</em> und w√§hlen <em>Sie "Leer</em> erstellen", um ein neues leeres Spielobjekt zu erstellen.  Nennen Sie es <em>Stra√üe</em> und positionieren Sie es bei <em>(0, 0, 0)</em> . <br><br>  Klicken Sie nun mit der rechten Maustaste auf <em>Stra√üe</em> in der <em>Hierarchie</em> und erstellen Sie ein weiteres leeres Spielobjekt als Kind von Stra√üe.  Nennen Sie es <em>Wegpunkt0</em> und platzieren Sie es am Punkt <em>(-12, 2, 0)</em> - von hier aus beginnen die Feinde ihre Bewegung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78a/21a/044/78a21a0443e9b71b4c28064196cd0f8f.png"></div><br>  Erstellen Sie auf √§hnliche Weise f√ºnf weitere Routenpunkte mit den folgenden Namen und Positionen: <br><br><ul><li>  Wegpunkt 1: (X: 7, Y: 2, Z: 0) </li><li>  Wegpunkt 2: (X: 7, Y: -1, Z: 0) </li><li>  Wegpunkt 3: (X: -7,3, Y: -1, Z: 0) </li><li>  Wegpunkt 4: (X: -7,3, Y: -4,5, Z: 0) </li><li>  Wegpunkt 5: (X: 7, Y: -4,5, Z: 0) </li></ul><br>  Der Screenshot unten zeigt die Routenpunkte und den resultierenden Pfad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png"></div><br><h2>  Feinde machen </h2><br>  Erstellen Sie nun einige Feinde, damit sie sich entlang der Stra√üe bewegen k√∂nnen.  Im <em>Prefabs-</em> Ordner befindet sich ein <em>Enemy-</em> Fertighaus.  Die Position ist <em>(-20, 0, 0)</em> , sodass neue Instanzen au√üerhalb des Bildschirms erstellt werden. <br><br>  Im √úbrigen ist es fast genauso konfiguriert wie das Monster-Fertighaus, verf√ºgt √ºber <code>AudioSource</code> und ein <code>Sprite</code> Kind, und wir k√∂nnen dieses Sprite in Zukunft drehen, ohne die Gesundheitsleiste zu drehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/5c7/b09/d465c7b0950d7c718abcb8869263753c.png"></div><br><h3>  Wir bewegen Feinde entlang der Stra√üe </h3><br>  F√ºgen <em>Sie</em> dem <em>Prefabs \ Enemy Prefab</em> ein neues <em>C #</em> <em>-Skript</em> mit dem Namen <em>MoveEnemy</em> <em>hinzu</em> .  √ñffnen Sie das Skript in der IDE und f√ºgen Sie die folgenden Variablen hinzu: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">HideInInspector</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentWaypoint = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastWaypointSwitchTime; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>;</code> </pre> <br>  In <code>waypoints</code> wird eine Kopie der Routenpunkte im Array gespeichert, und die <code>[HideIn <em>inspector</em> ]</code> √ºber den <code>waypoints</code> stellt sicher, dass wir dieses Feld im <em><em>Inspector</em></em> nicht versehentlich √§ndern k√∂nnen, aber weiterhin √ºber andere Skripts darauf zugreifen k√∂nnen. <br><br>  <code>currentWaypoint</code> verfolgt, woher die Route des Feindes zur aktuellen Zeit stammt, und <code>lastWaypointSwitchTime</code> speichert die Zeit, die der Feind durchlaufen hat.  Au√üerdem speichern wir die <code>speed</code> Feindes. <br><br>  F√ºgen Sie diese Zeile zu <code>Start()</code> : <br><br><pre> <code class="cs hljs">lastWaypointSwitchTime = Time.time;</code> </pre> <br>  Also initialisieren wir <code>lastWaypointSwitchTime</code> mit dem Wert der aktuellen Zeit. <br><br>  <code>Update()</code> den folgenden Code hinzu, damit sich der Feind entlang der Route bewegen kann: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 Vector3 startPosition = waypoints [currentWaypoint].transform.position; Vector3 endPosition = waypoints [currentWaypoint + 1].transform.position; // 2 float pathLength = Vector3.Distance (startPosition, endPosition); float totalTimeForPath = pathLength / speed; float currentTimeOnPath = Time.time - lastWaypointSwitchTime; gameObject.transform.position = Vector2.Lerp (startPosition, endPosition, currentTimeOnPath / totalTimeForPath); // 3 if (gameObject.transform.position.Equals(endPosition)) { if (currentWaypoint &lt; waypoints.Length - 2) { // 3.a currentWaypoint++; lastWaypointSwitchTime = Time.time; // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">     } else { // 3.b Destroy(gameObject); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); AudioSource.PlayClipAtPoint(audioSource.clip, transform.position); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br>  Lassen Sie uns den Code Schritt f√ºr Schritt analysieren: <br><br><ol><li>  Aus dem Array von Routenpunkten erhalten wir die Start- und Endpositionen des aktuellen Routensegments. </li><li>  Wir berechnen die Zeit, die erforderlich ist, um die gesamte Strecke zur√ºckzulegen, anhand der Formel <em>Zeit = Entfernung / Geschwindigkeit</em> und bestimmen dann die aktuelle Zeit auf der Route.  Mit <code>Vector2.Lerp</code> interpolieren wir die aktuelle Position des Feindes zwischen dem exakten Start- und Endsegment. </li><li>  √úberpr√ºfen Sie, ob der Feind die <code>endPosition</code> erreicht <code>endPosition</code> .  Wenn ja, verarbeiten wir zwei m√∂gliche Szenarien: <br><ol><li>  Der Feind hat den letzten Punkt der Route noch nicht erreicht. Erh√∂hen Sie daher den Wert von <code>currentWaypoint</code> und aktualisieren Sie <code>lastWaypointSwitchTime</code> .  Sp√§ter werden wir einen Code hinzuf√ºgen, um den Feind so zu drehen, dass er in die Richtung seiner Bewegung schaut. </li><li>  Der Feind hat den letzten Punkt der Route erreicht, dann zerst√∂ren wir ihn und starten den Soundeffekt.  Sp√§ter werden wir einen Code hinzuf√ºgen, der die <code>health</code> des Spielers verringert. </li></ol></li></ol><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck. <br><br><h3>  Wir informieren die Feinde √ºber die Bewegungsrichtung </h3><br>  In ihrem aktuellen Zustand kennen die Feinde die Reihenfolge der Routenpunkte nicht. <br><br>  W√§hlen Sie <em>Stra√üe</em> in der <em>Hierarchie aus</em> und f√ºgen Sie ein neues <em>C #</em> <em>-Skript mit dem</em> Namen <em>SpawnEnemy hinzu</em> .  √ñffnen Sie es in der IDE und f√ºgen Sie die folgende Variable hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints;</code> </pre> <br>  Wir werden <code>waypoints</code> , um Verweise auf den Wegpunkt in der Szene in der gew√ºnschten Reihenfolge zu speichern. <br><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  W√§hlen Sie in der <em>Hierarchie Stra√üe aus</em> und setzen Sie die <em>Gr√∂√üe des</em> <em>Wegpunkt-</em> Arrays auf <em>6</em> . <br><br>  Ziehen Sie jedes der Road-Kinder in die Felder, indem Sie <em>Waypoint0</em> in <em>Element 0</em> , <em>Waypoint1</em> in <em>Element 1</em> usw. <em>einf√ºgen</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95a/1e3/251/95a1e3251247a04f62f8a618b681c052.gif"></div><br>  Jetzt haben wir ein Array, das die Routenpunkte in der richtigen Reihenfolge enth√§lt - wohlgemerkt, die Feinde ziehen sich nie zur√ºck, sie streben beharrlich nach einer s√º√üen Belohnung. <br><br><h3>  √úberpr√ºfen Sie, wie alles funktioniert </h3><br>  √ñffnen Sie <em>SpawnEnemy</em> in der IDE und f√ºgen Sie die folgende Variable hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject testEnemyPrefab;</code> </pre> <br>  In <code>testEnemyPrefab</code> wird ein Verweis auf das <em>Enemy-</em> <code>testEnemyPrefab</code> . <br><br>  F√ºgen Sie <code>Start()</code> den folgenden Code hinzu, um beim Ausf√ºhren des Skripts einen Feind zu erstellen: <br><br><pre> <code class="cs hljs">Instantiate(testEnemyPrefab).GetComponent&lt;MoveEnemy&gt;().waypoints = waypoints;</code> </pre> <br>  Daher erstellen wir eine neue Kopie des in testEnemy gespeicherten <code>testEnemy</code> und weisen ihm eine Route zu. <br><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  W√§hlen Sie das <em>Road-</em> Objekt in der <em>Hierarchie aus</em> und w√§hlen Sie das Prefab <em>Enemy</em> f√ºr den Parameter <em>Test Enemy aus</em> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starten Sie das Projekt und sehen Sie, wie sich der Feind auf der Stra√üe bewegt (in GIF wird die Geschwindigkeit aus Gr√ºnden der √úbersichtlichkeit um das 20-fache erh√∂ht). </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b6/b10/384/0b6b1038491a74c27d6b42860e44365e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bemerkt, dass er nicht immer hinschaut, wohin er geht? </font><font style="vertical-align: inherit;">Es ist lustig, aber wir versuchen ein professionelles Spiel zu machen. </font><font style="vertical-align: inherit;">Daher werden wir im zweiten Teil des Tutorials den Feinden beibringen, nach vorne zu schauen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wohin als n√§chstes? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben bereits viel getan und sind schnell dabei, unser eigenes Tower Defense-Spiel zu entwickeln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spieler k√∂nnen eine begrenzte Anzahl von Monstern erschaffen, und der Feind rennt die Stra√üe entlang und geht auf unseren Keks zu. </font><font style="vertical-align: inherit;">Spieler haben Gold und k√∂nnen Monster verbessern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie das fertige Ergebnis </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunter </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zweiten Teil werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir die Entstehung riesiger Wellen von Feinden und deren Zerst√∂rung betrachten. </font><font style="vertical-align: inherit;">Bis dann!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413837/">https://habr.com/ru/post/de413837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413817/index.html">Heterogene wettbewerbsf√§hige Datenverarbeitung in Echtzeit nur einmal</a></li>
<li><a href="../de413819/index.html">Ehrlich gesagt √ºber den IT-Markt in Russland</a></li>
<li><a href="../de413823/index.html">Der Boom bedeutungsloser Besch√§ftigung</a></li>
<li><a href="../de413827/index.html">Das Kubernetes-Projekt wird 4 Jahre alt</a></li>
<li><a href="../de413831/index.html">Die neue Version des Tesla Autopilot wird im August erstmals mit ‚Äûvollst√§ndig autonomen Fahrfunktionen‚Äú ver√∂ffentlicht.</a></li>
<li><a href="../de413839/index.html">KI, praktischer Kurs. Sammlung und Recherche von Bildern</a></li>
<li><a href="../de413841/index.html">Alternativen zu Google-Produkten</a></li>
<li><a href="../de413843/index.html">Waymo vor den anderen: Die Robomobile des Unternehmens sind 11 Millionen Kilometer gerollt</a></li>
<li><a href="../de413847/index.html">"Lebendiges" Triggerdenkmal</a></li>
<li><a href="../de413849/index.html">Sennheiser Markengeschichte: Freiheit und Vision</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>