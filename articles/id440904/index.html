<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëßüèª ‚õ≥Ô∏è üë©üèø‚Äçüè´ Perbandingan arsitektur Viper dan MVVM: Bagaimana cara menerapkan keduanya üë©‚Äçüî¨ üÜñ üå´Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat ini, VIPER dan MVVM adalah solusi arsitektur paling populer yang digunakan dalam pengembangan aplikasi besar yang membutuhkan partisipasi dalam p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perbandingan arsitektur Viper dan MVVM: Bagaimana cara menerapkan keduanya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440904/"><img src="https://habrastorage.org/webt/db/bn/4z/dbbn4zxc39qxt6vtlimqyjql5ko.jpeg"><br><br>  Saat ini, VIPER dan MVVM adalah solusi arsitektur paling populer yang digunakan dalam pengembangan aplikasi besar yang membutuhkan partisipasi dalam pengembangan tim besar yang teruji dengan baik, didukung jangka panjang dan terus berkembang.  Pada artikel ini kami akan mencoba menerapkannya pada proyek uji kecil, yang merupakan daftar kontak pengguna dengan kemampuan untuk menambahkan kontak baru.  Artikel ini memiliki lebih banyak praktik daripada analitik, dan ditujukan terutama bagi mereka yang sudah secara teori akrab dengan arsitektur ini dan sekarang ingin memahami bagaimana ini bekerja dengan contoh-contoh spesifik.  Namun, deskripsi dasar arsitektur dan perbandingannya juga ada. <br><a name="habracut"></a><br><br>  Artikel ini adalah terjemahan dari artikel Rafael Sacchi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">‚ÄúMembandingkan arsitektur MVVM dan Viper: Kapan harus menggunakan satu atau yang lain‚Äù</a> .  Sayangnya, pada beberapa titik dalam pembuatan artikel, "publikasi" telah dibuat alih-alih "terjemahan," jadi Anda harus menulis di sini. <br><br>  Arsitektur yang dirancang dengan baik sangat penting untuk memastikan dukungan berkelanjutan untuk proyek Anda.  Pada artikel ini, kita akan melihat arsitektur MVVM dan VIPER sebagai alternatif untuk MVC tradisional. <br><br>  MVC adalah konsep terkenal untuk semua orang yang telah terlibat dalam pengembangan perangkat lunak selama beberapa waktu.  Pola ini membagi proyek menjadi tiga bagian: Model mewakili entitas;  Lihat, yang merupakan antarmuka untuk interaksi pengguna;  dan Controller, bertanggung jawab untuk memastikan interaksi antara View dan Model.  Ini adalah arsitektur yang Apple tawarkan untuk kita gunakan dalam aplikasi kita. <br><br>  Namun, Anda mungkin tahu bahwa proyek datang dengan cukup banyak fungsi yang kompleks: dukungan untuk permintaan jaringan, penguraian, akses ke model data, konversi data untuk output, reaksi terhadap peristiwa antarmuka, dll.  Sebagai hasilnya, Anda mendapatkan pengendali besar yang menyelesaikan tugas-tugas di atas dan banyak kode yang tidak dapat digunakan kembali.  Dengan kata lain, MVC bisa menjadi mimpi buruk bagi pengembang dengan dukungan proyek jangka panjang.  Tetapi bagaimana memastikan modularitas tinggi dan penggunaan kembali dalam proyek iOS? <br><br>  Kita akan melihat dua alternatif yang sangat terkenal untuk arsitektur MVC: MVVM dan VIPER.  Keduanya cukup terkenal di komunitas iOS dan telah membuktikan bahwa mereka bisa menjadi alternatif yang bagus untuk MVC.  Kami akan berbicara tentang struktur mereka, menulis contoh aplikasi dan mempertimbangkan kasus ketika lebih baik menggunakan satu atau lain arsitektur. <br><br>  <b>Contoh</b> <br><br>  Kami akan menulis aplikasi dengan tabel kontak pengguna.  Anda dapat menggunakan kode dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori ini</a> .  Di folder Starter, kerangka dasar proyek terkandung, dan di folder Final adalah aplikasi yang sudah selesai. <br><br>  Aplikasi akan memiliki dua layar: pada yang pertama akan ada daftar kontak yang ditampilkan dalam sebuah tabel, di dalam sel akan ada nama pertama dan terakhir dari kontak, serta gambar dasar bukan gambar pengguna. <br><br><img src="https://habrastorage.org/webt/gn/kc/ww/gnkcwwblrc7b036fyvuz874zfpu.png"><br><br>  Layar kedua adalah layar untuk menambahkan kontak baru, dengan bidang input nama depan dan belakang dan tombol Selesai dan Batalkan. <br><br><img src="https://habrastorage.org/webt/rx/b1/mv/rxb1mvegb0piorji2dovggxdj8q.png"><br><br>  <b>MVVM</b> <br><br>  Cara kerjanya: <br><br>  MVVM adalah singkatan dari <b>Model-View-ViewModel</b> .  Pendekatan ini berbeda dari MVC dalam logika distribusi tanggung jawab antar modul. <br><br><ul><li>  <b>Model</b> : Modul ini tidak berbeda dari yang ada di MVC.  Dia bertanggung jawab untuk membuat model data dan mungkin mengandung logika bisnis.  Anda juga dapat membuat kelas pembantu, misalnya, seperti kelas manajer untuk mengelola objek di Model dan manajer jaringan untuk memproses permintaan dan penguraian jaringan. </li><li>  <b>Lihat</b> : Dan di sini semuanya mulai berubah.  Modul View di MVVM mencakup antarmuka (subclass dari file UIView, .xib dan .storyboard), logika tampilan (animasi, rendering) dan penanganan acara pengguna (penekanan tombol, dll.). View dan Controller bertanggung jawab atas hal ini dalam MVC.  Ini berarti bahwa pandangan Anda akan tetap tidak berubah, sedangkan ViewController akan berisi sebagian kecil dari apa yang ada di dalamnya di MVC dan, karenanya, akan sangat berkurang. </li><li>  <b>ViewModel</b> : Ini sekarang tempat di mana sebagian besar kode yang sebelumnya Anda miliki di ViewController akan ditemukan.  Lapisan ViewModel meminta data dari Model (dapat berupa permintaan ke basis data lokal atau permintaan jaringan) dan mentransfernya kembali ke Lihat, dalam format yang akan digunakan dan ditampilkan di sana.  Tapi ini adalah mekanisme dua arah, tindakan atau data yang dimasukkan oleh pengguna melewati ViewModel dan memperbarui Model.  Karena ViewModel melacak segala sesuatu yang ditampilkan, ada baiknya menggunakan mekanisme penautan antara dua lapisan. </li></ul><br><br>  Dibandingkan dengan MVC, Anda bergerak dari arsitektur yang terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/op/i7/gq/opi7gqlutejiwvehje5zoeey96k.jpeg"><br><br>  Ke arsitektur berikutnya varant: <br><br><img src="https://habrastorage.org/webt/zu/me/cj/zumecj56yf5vgzckbhjdarwx58i.png"><br><br>  Di mana kelas dan subclass dari UIView dan UIViewController digunakan untuk mengimplementasikan View. <br><br>  Nah, sekarang to the point.  Mari kita menulis contoh aplikasi kita menggunakan arsitektur MVVM. <br><br>  <b>Aplikasi Kontak MVVM</b> <br><br>  <b>MODEL</b> <br><br>  Kelas berikut adalah model kontak <b>Kontak</b> : <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CoreData open class Contact: NSManagedObject { @NSManaged var firstName: String? @NSManaged var lastName: String? var fullName: String { get { var name = "" if let firstName = firstName { name += firstName } if let lastName = lastName { name += " \(lastName)" } return name } } }</code> </pre> <br><br>  Kelas kontak memiliki bidang <i>firstName</i> , <i>lastName</i> , serta properti nama lengkap dihitung. <br><br>  <b>LIHAT</b> <br><br>  LIHAT termasuk: storyboard utama, dengan pandangan sudah ditempatkan di atasnya;  ContactsViewController, yang menampilkan daftar kontak dalam sebuah tabel;  dan AddContactViewController dengan sepasang label dan bidang input untuk menambahkan nama dan nama keluarga dari kontak baru.  Mari kita mulai dengan <b>ContactsViewController</b> .  Kodenya akan terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactsViewController: UIViewController { @IBOutlet var tableView: UITableView! let contactViewModelController = ContactViewModelController() override func viewDidLoad() { super.viewDidLoad() tableView.tableFooterView = UIView() contactViewModelController.retrieveContacts({ [unowned self] in self.tableView.reloadData() }, failure: nil) } override func prepare(for segue: UIStoryboardSegue, sender: Any?) { let addContactNavigationController = segue.destination as? UINavigationController let addContactVC = addContactNavigationController?.viewControllers[0] as? AddContactViewController addContactVC?.contactsViewModelController = contactViewModelController addContactVC?.didAddContact = { [unowned self] (contactViewModel, index) in let indexPath = IndexPath(row: index, section: 0) self.tableView.beginUpdates() self.tableView.insertRows(at: [indexPath], with: .left) self.tableView.endUpdates() } } } extension ContactsViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: "ContactCell") as? ContactsTableViewCell guard let contactsCell = cell else { return UITableViewCell() } contactsCell.cellModel = contactViewModelController.viewModel(at: (indexPath as NSIndexPath).row) return contactsCell } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return contactViewModelController.contactsCount } }</code> </pre> <br><br>  Bahkan dengan pandangan sekilas, jelas bahwa kelas ini mengimplementasikan sebagian besar tugas antarmuka.  Ini juga memiliki navigasi dalam metode <i>prepForSegue (: :)</i> - dan inilah saat yang akan berubah dalam VIPER saat menambahkan lapisan Router. <br><br>  Mari kita lihat lebih dekat pada ekstensi kelas yang mengimplementasikan protokol UITableViewDataSource.  Fungsi tidak bekerja secara langsung dengan model kontak pengguna Kontak di lapisan Model - sebagai gantinya, mereka menerima data (diwakili oleh struktur ContactViewModel) dalam bentuk di mana mereka akan ditampilkan, sudah diformat menggunakan ViewModelController. <br><br>  Hal yang sama terjadi di sirkuit, yang dimulai segera setelah membuat kontak.  Satu-satunya tugasnya adalah menambahkan baris ke tabel dan memperbarui antarmuka. <br><br>  Sekarang Anda perlu membangun hubungan antara subkelas dari UITableViewCell dan ViewModel.  Ini akan terlihat seperti kelas sel dari tabel <b>ContactsTableViewCell</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactsTableViewCell: UITableViewCell { var cellModel: ContactViewModel? { didSet { bindViewModel() } } func bindViewModel() { textLabel?.text = cellModel?.fullName } }</code> </pre> <br><br>  Dan begitu juga kelas <b>AddContactViewController</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class AddContactViewController: UIViewController { @IBOutlet var firstNameTextField: UITextField! @IBOutlet var lastNameTextField: UITextField! var contactsViewModelController: ContactViewModelController? var didAddContact: ((ContactViewModel, Int) -&gt; Void)? override func viewDidLoad() { super.viewDidLoad() firstNameTextField.becomeFirstResponder() } @IBAction func didClickOnDoneButton(_ sender: UIBarButtonItem) { guard let firstName = firstNameTextField.text, let lastName = lastNameTextField.text else { return } if firstName.isEmpty || lastName.isEmpty { showEmptyNameAlert() return } dismiss(animated: true) { [unowned self] in self.contactsViewModelController?.createContact(firstName: firstName, lastName: lastName, success: self.didAddContact, failure: nil) } } @IBAction func didClickOnCancelButton(_ sender: UIBarButtonItem) { dismiss(animated: true, completion: nil) } fileprivate func showEmptyNameAlert() { showMessage(title: "Error", message: "A contact must have first and last names") } fileprivate func showMessage(title: String, message: String) { let alertView = UIAlertController(title: title, message: message, preferredStyle: .alert) alertView.addAction(UIAlertAction(title: "Ok", style: .destructive, handler: nil)) present(alertView, animated: true, completion: nil) } }</code> </pre> <br><br>  Dan lagi, terutama bekerja dengan UI sedang terjadi di sini.  Perhatikan bahwa AddContactViewController mendelegasikan fungsionalitas pembuatan kontak ke ViewModelController di fungsi <i>didClickOnDoneButton (:)</i> . <br><br>  <b>LIHAT MODEL</b> <br><br>  Sudah waktunya untuk berbicara tentang lapisan ViewModel yang sama sekali baru bagi kita.  Pertama, buat <b>kelas</b> kontak <b>ContactViewModel</b> yang akan memberikan tampilan yang perlu kita tampilkan, dan fungsi &lt;and&gt; dengan parameter akan ditentukan untuk mengurutkan kontak: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fullName: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &lt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bool</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.fullName.lowercased() &lt; rhs.fullName.lowercased() } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: ContactViewModel, rhs: ContactViewModel)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.fullName.lowercased() &gt; rhs.fullName.lowercased() }</code> </pre> <br><br>  Kode <b>ContactViewModelController</b> akan terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactViewModelController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contactViewModelList: [<span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataManager = <span class="hljs-type"><span class="hljs-type">ContactLocalDataManager</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contactsCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contactViewModelList.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> success: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?, failure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contacts = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> dataManager.retrieveContactList() contactViewModelList = contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() { <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.fullName) } success?() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { failure?() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contactViewModelList[index] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(firstName: String, lastName: String, success: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">(ContactViewModel, Int)</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?, failure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contact = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> dataManager.createContact(firstName: firstName, lastName: lastName) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactViewModel = <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: contact.fullName) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> insertionIndex = contactViewModelList.insertionIndex(of: contactViewModel) { $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; $<span class="hljs-number"><span class="hljs-number">1</span></span> } contactViewModelList.insert(contactViewModel, at: insertionIndex) success?(contactViewModel, insertionIndex) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { failure?() } } }</code> </pre><br><br>  <i><u>Catatan:</u></i> MVVM tidak memberikan definisi yang tepat tentang cara membuat ViewModel.  Ketika saya ingin membuat arsitektur yang lebih berlapis, saya lebih suka membuat ViewModelController yang akan berinteraksi dengan lapisan Model dan akan bertanggung jawab untuk membuat objek ViewModel. <br><br>  Hal utama yang sangat mudah diingat: lapisan ViewModel tidak boleh terlibat dalam bekerja dengan antarmuka pengguna.  Untuk menghindari ini, lebih baik <b>tidak pernah</b> mengimpor UIKit ke file dengan ViewModel. <br><br>  Kelas ContactViewModelController meminta kontak dari penyimpanan lokal dan mencoba untuk tidak mempengaruhi lapisan Model.  Ini mengembalikan data dalam format yang tampilan harus ditampilkan, dan memberitahukan tampilan ketika kontak baru ditambahkan dan data berubah. <br><br>  Dalam kehidupan nyata, ini akan menjadi permintaan jaringan, dan bukan permintaan ke database lokal, tetapi dalam kasus apa pun mereka tidak boleh menjadi bagian dari ViewModel - dan bekerja dengan jaringan dan bekerja dengan database lokal harus disediakan menggunakan manajer mereka sendiri ( manajer). <br><br>  Itu semua tentang MVVM.  Mungkin pendekatan ini menurut Anda lebih dapat diuji, didukung, dan didistribusikan daripada MVC.  Sekarang mari kita bicara tentang VIPER dan lihat perbedaannya dengan MVVM. <br><br>  <b>VIPER</b> <br><br>  Cara kerjanya: <br><br>  VIPER adalah implementasi Arsitektur Bersih untuk proyek iOS.  Strukturnya terdiri dari: View, Interactor, Presenter, Entity, dan Router.  Ini benar-benar arsitektur yang sangat terdistribusi dan modular yang memungkinkan Anda untuk berbagi tanggung jawab, dicakup dengan baik oleh unit test dan membuat kode Anda dapat digunakan kembali. <br><br><ul><li>  <b>Lihat</b> : Lapisan antarmuka yang biasanya menyiratkan file UIKit (termasuk UIViewController).  Dapat dipahami bahwa dalam sistem yang lebih terdistribusi, subclass dari UIViewController harus terkait dengan View.  Dalam VIPER, segalanya hampir sama dengan di MVVM: View bertanggung jawab untuk menampilkan apa yang Presenter berikan dan untuk mentransmisikan informasi atau tindakan yang dimasukkan pengguna ke Presenter. </li><li>  <b>Interactor</b> : Berisi logika bisnis yang diperlukan agar aplikasi dapat berfungsi.  Interactor bertanggung jawab untuk mengambil data dari Model (permintaan jaringan atau lokal) dan implementasinya sama sekali tidak terkait dengan antarmuka pengguna.  Penting untuk diingat bahwa manajer jaringan dan lokal bukan bagian dari VIPER, tetapi diperlakukan sebagai dependensi terpisah. </li><li>  <b>Presenter</b> : Bertanggung jawab untuk memformat data untuk ditampilkan di View.  Dalam MVVM dalam contoh kita, ViewModelController bertanggung jawab untuk ini.  Presenter menerima data dari Interactor, membuat instance ViewModel (kelas yang diformat untuk tampilan yang benar) dan meneruskannya ke View.  Dia juga menanggapi input data pengguna, meminta data tambahan dari database, atau sebaliknya, memberikannya padanya. </li><li>  <b>Entitas</b> : Mengambil bagian dari tanggung jawab lapisan Model, yang digunakan dalam arsitektur lain.  Entity adalah objek data sederhana, tanpa logika bisnis, yang dikelola oleh traktor online dan berbagai manajer data. </li><li>  <b>Router</b> : Semua logika navigasi aplikasi.  Tampaknya ini bukan lapisan yang paling penting, tetapi jika Anda perlu, misalnya, untuk menggunakan kembali tampilan yang sama pada iPhone dan aplikasi untuk iPad, satu-satunya hal yang dapat berubah adalah bagaimana tampilan Anda muncul di layar.  Ini memungkinkan Anda untuk tidak menyentuh lapisan lagi kecuali Router, yang akan bertanggung jawab untuk ini dalam setiap kasus. </li></ul><br><br>  Dibandingkan dengan MVVM, VIPER memiliki beberapa perbedaan utama dalam distribusi tanggung jawab: <br><br>  - dia memiliki Router, layer terpisah yang bertanggung jawab untuk navigasi <br><br>  - Entitas adalah objek data sederhana, mendistribusikan kembali tanggung jawab untuk mengakses data dari Model ke Interactor <br><br>  - Tanggung jawab ViewModelController dibagi antara Interactor dan Presenter <br><br>  Dan sekarang mari kita ulangi aplikasi yang sama, tetapi sudah di VIPER.  Namun untuk memudahkan pemahaman, kami hanya akan membuat pengontrol dengan kontak.  Anda dapat menemukan kode untuk controller untuk menambahkan kontak baru di proyek menggunakan tautan (folder Starter Kontak VIPER dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori ini</a> ). <br><br>  <i><u>Catatan</u></i> : Jika Anda memutuskan untuk membuat proyek Anda pada VIPER, maka Anda sebaiknya tidak mencoba membuat semua file secara manual - Anda dapat menggunakan salah satu generator kode, misalnya, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VIPER Gen</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generamba (proyek Rambler)</a> . <br><br>  <b>Aplikasi Kontak VIPER</b> <br><br>  <b>LIHAT</b> <br><br>  LIHAT diwakili oleh elemen-elemen dari Main.storyboard dan kelas ContactListView.  LIHAT sangat pasif;  satu-satunya tugasnya adalah mentransfer acara antarmuka ke Presenter dan memperbarui kondisinya, setelah pemberitahuan dari Presenter.  Seperti inilah kode <b>ContactListView</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactListView: UIViewController { @IBOutlet var tableView: UITableView! var presenter: ContactListPresenterProtocol? var contactList: [ContactViewModel] = [] override func viewDidLoad() { super.viewDidLoad() presenter?.viewDidLoad() tableView.tableFooterView = UIView() } @IBAction func didClickOnAddButton(_ sender: UIBarButtonItem) { presenter?.addNewContact(from: self) } } extension ContactListView: ContactListViewProtocol { func reloadInterface(with contacts: [ContactViewModel]) { contactList = contacts tableView.reloadData() } func didInsertContact(_ contact: ContactViewModel) { let insertionIndex = contactList.insertionIndex(of: contact) { $0 &lt; $1 } contactList.insert(contact, at: insertionIndex) let indexPath = IndexPath(row: insertionIndex, section: 0) tableView.beginUpdates() tableView.insertRows(at: [indexPath], with: .right) tableView.endUpdates() } } extension ContactListView: UITableViewDataSource { func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { guard let cell = tableView.dequeueReusableCell(withIdentifier: "ContactCell") else { return UITableViewCell() } cell.textLabel?.text = contactList[(indexPath as NSIndexPath).row].fullName return cell } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return contactList.count } }</code> </pre> <br><br>  Lihat mengirimkan <i>viewDidLoad</i> dan peristiwa <i>didClickOnAddButton</i> ke Presenter.  Pada acara pertama, Presenter akan meminta data dari Interactor, dan pada yang kedua, Presenter akan meminta Router untuk beralih ke controller untuk menambahkan kontak baru. <br><br>  Metode protokol ContactListViewProtocol dipanggil dari Presenter baik ketika daftar kontak diminta, atau ketika kontak baru ditambahkan.  Dalam kedua kasus tersebut, data dalam Tampilan hanya berisi informasi yang diperlukan untuk ditampilkan. <br><br>  Juga di Lihat adalah metode yang mengimplementasikan protokol UITableViewDataSource yang mengisi tabel dengan data yang diterima. <br><br>  <b>INTERAKTOR</b> <br><br>  Interactor dalam contoh kita cukup sederhana.  Semua yang dia lakukan adalah meminta data melalui manajer basis data lokal, dan tidak masalah baginya apa yang digunakan manajer ini, CoreData, Realm, atau solusi lainnya.  Kode dalam ContactListInteractor adalah sebagai berikut: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractorInputProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presenter: <span class="hljs-type"><span class="hljs-type">ContactListInteractorOutputProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localDatamanager: <span class="hljs-type"><span class="hljs-type">ContactListLocalDataManagerInputProtocol?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactList = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> localDatamanager?.retrieveContactList() { presenter?.didRetrieveContacts(contactList) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { presenter?.didRetrieveContacts([]) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { presenter?.didRetrieveContacts([]) } } }</code> </pre> <br><br>  Setelah Interactor menerima data yang diminta, ia memberi tahu Presenter.  Selain itu, sebagai opsi, Interactor dapat mengirimkan kesalahan ke Presenter, yang kemudian harus memformat kesalahan menjadi tampilan yang sesuai untuk ditampilkan di Tampilan. <br><br>  <i>Catatan</i> : Seperti yang mungkin Anda perhatikan, setiap lapisan dalam VIPER mengimplementasikan protokol.  Akibatnya, kelas tergantung pada abstraksi, dan bukan pada implementasi tertentu, sehingga memenuhi prinsip inversi ketergantungan (salah satu prinsip SOLID). <br><br>  <b>PRESENTER</b> <br><br>  Elemen terpenting arsitektur.  Semua komunikasi antara View dan seluruh layer (Interactor dan Router) melewati Presenter.  Kode Daftar <b>Kontak</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenterProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> view: <span class="hljs-type"><span class="hljs-type">ContactListViewProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interactor: <span class="hljs-type"><span class="hljs-type">ContactListInteractorInputProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wireFrame: <span class="hljs-type"><span class="hljs-type">ContactListWireFrameProtocol?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { interactor?.retrieveContacts() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNewContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from view: ContactListViewProtocol)</span></span></span></span> { wireFrame?.presentAddContactScreen(from: view) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractorOutputProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didRetrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> contacts: [Contact])</span></span></span></span> { view?.reloadInterface(with: contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.fullName) }) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddModuleDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didAddContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> contact: Contact)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactViewModel = <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: contact.fullName) view?.didInsertContact(contactViewModel) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didCancelAddContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }</code> </pre> <br><br>  Setelah View dimuat, ia memberi tahu Presenter, yang pada gilirannya meminta data melalui Interactor.  Saat pengguna mengklik tombol tambahkan kontak baru, View memberi tahu Presenter, yang mengirimkan permintaan untuk membuka layar tambahkan kontak baru di Router. <br><br>  Presenter juga memformat data dan mengembalikannya ke tampilan setelah menanyakan daftar kontak.  Dia juga bertanggung jawab untuk mengimplementasikan protokol AddModuleDelegate.  Ini berarti Presenter akan menerima notifikasi ketika kontak baru ditambahkan, menyiapkan data kontak untuk ditampilkan dan mentransfer ke View. <br><br>  Seperti yang mungkin telah Anda perhatikan, Presenter memiliki setiap kesempatan untuk menjadi cukup rumit.  Jika ada kemungkinan seperti itu, maka Presenter dapat dibagi menjadi dua bagian: Presenter, yang hanya menerima data, memformatnya untuk ditampilkan, dan meneruskannya ke View;  dan pengendali acara yang akan merespons tindakan pengguna. <br><br>  <b>ENTITY</b> <br><br>  Lapisan ini mirip dengan lapisan Model di MVVM.  Dalam aplikasi kami, ini diwakili oleh kelas Kontak dan fungsi definisi operator &lt;and&gt;.  Konten <b>kontak</b> akan terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CoreData open class Contact: NSManagedObject { var fullName: String { get { var name = "" if let firstName = firstName { name += firstName } if let lastName = lastName { name += " " + lastName } return name } } } public struct ContactViewModel { var fullName = "" } public func &lt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; Bool { return lhs.fullName.lowercased() &lt; rhs.fullName.lowercased() } public func &gt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; Bool { return lhs.fullName.lowercased() &gt; rhs.fullName.lowercased() }</code> </pre> <br><br>  ContactViewModel berisi bidang yang diisi oleh Presenter (format) yang ditampilkan oleh Tampilan.  Kelas Kontak adalah subkelas NSManagedObject yang berisi bidang yang sama seperti pada model CoreData. <br><br>  <b>ROUTER</b> <br><br>  Dan akhirnya, yang terakhir, tetapi tentu saja tidak penting, lapisan.  Semua tanggung jawab untuk navigasi ada pada Presenter dan WireFrame.  Presenter menerima suatu peristiwa dari pengguna dan tahu kapan harus melakukan transisi, dan WireFrame tahu bagaimana dan di mana membuat transisi ini.  Agar Anda tidak bingung, dalam contoh ini layer Router diwakili oleh kelas ContactListWireFrame dan disebut sebagai WireFrame dalam teks.  <b>ContactListWireFrame</b> Code: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactListWireFrame: ContactListWireFrameProtocol { class func createContactListModule() -&gt; UIViewController { let navController = mainStoryboard.instantiateViewController(withIdentifier: "ContactsNavigationController") if let view = navController.childViewControllers.first as? ContactListView { let presenter: ContactListPresenterProtocol &amp; ContactListInteractorOutputProtocol = ContactListPresenter() let interactor: ContactListInteractorInputProtocol = ContactListInteractor() let localDataManager: ContactListLocalDataManagerInputProtocol = ContactListLocalDataManager() let wireFrame: ContactListWireFrameProtocol = ContactListWireFrame() view.presenter = presenter presenter.view = view presenter.wireFrame = wireFrame presenter.interactor = interactor interactor.presenter = presenter interactor.localDatamanager = localDataManager return navController } return UIViewController() } static var mainStoryboard: UIStoryboard { return UIStoryboard(name: "Main", bundle: Bundle.main) } func presentAddContactScreen(from view: ContactListViewProtocol) { guard let delegate = view.presenter as? AddModuleDelegate else { return } let addContactsView = AddContactWireFrame.createAddContactModule(with: delegate) if let sourceView = view as? UIViewController { sourceView.present(addContactsView, animated: true, completion: nil) } } }</code> </pre> <br><br>  Karena WireFrame bertanggung jawab untuk membuat modul, akan lebih mudah untuk mengkonfigurasi semua dependensi di sini.  Saat Anda ingin membuka pengontrol lain, fungsi yang membuka pengontrol baru menerima sebagai argumen objek yang akan membukanya, dan membuat pengontrol baru menggunakan WireFrame-nya.  Juga, ketika membuat controller baru, data yang diperlukan ditransfer ke sana, dalam hal ini hanya delegasi (Presenter controller dengan kontak) untuk menerima kontak yang dibuat. <br><br>  Lapisan Router memberikan peluang bagus untuk menghindari penggunaan segue (transisi) di storyboard dan mengatur semua navigasi kode.  Karena storyboard tidak memberikan solusi ringkas untuk mentransfer data antara pengontrol, implementasi navigasi kami tidak akan menambahkan kode tambahan.  Yang kami dapatkan hanyalah penggunaan ulang terbaik. <br><br><br>  <b>Ringkasan</b> : <br><br>  Anda dapat menemukan kedua proyek di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori ini</a> . <br><br>  Seperti yang Anda lihat, MVVM dan VIPER, meskipun berbeda, tidak unik.  MVVM memberi tahu kita bahwa selain View dan Model, harus ada juga layer ViewModel.  Tetapi tidak ada yang dikatakan tentang bagaimana lapisan ini harus dibuat, atau tentang bagaimana data diminta - tanggung jawab untuk lapisan ini tidak didefinisikan dengan jelas.  Ada banyak cara untuk mengimplementasikannya dan Anda dapat menggunakannya. <br><br>  VIPER, di sisi lain, adalah arsitektur yang agak unik.  Ini terdiri dari banyak lapisan, yang masing-masing memiliki area tanggung jawab yang jelas dan kurang dari MVVM dipengaruhi oleh pengembang. <br><br>  Ketika memilih arsitektur, biasanya tidak ada satu-satunya solusi yang tepat, tetapi saya masih akan mencoba memberikan beberapa tips.  Jika Anda memiliki proyek besar dan panjang, dengan persyaratan yang jelas dan Anda ingin memiliki banyak kesempatan untuk menggunakan kembali komponen, maka VIPER akan menjadi solusi terbaik.  Penggambaran tanggung jawab yang lebih jelas memungkinkan dilakukannya pengujian yang lebih baik dan peningkatan penggunaan kembali. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440904/">https://habr.com/ru/post/id440904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440894/index.html">Merancang Suara untuk Pathfinder: Kingmaker</a></li>
<li><a href="../id440896/index.html">Teknologi Aditif dan Pemindaian 3D dalam Teknik Mesin: 7 Kisah Sukses</a></li>
<li><a href="../id440898/index.html">Pemasaran Konten, Iklan Kontekstual, Peningkatan Konversi: 6 Panduan Promosi Startup yang Berguna</a></li>
<li><a href="../id440900/index.html">REST gairah untuk 200</a></li>
<li><a href="../id440902/index.html">Setengah kerajaan untuk AI: berapa banyak bank yang dihemat untuk pembelajaran mesin, jaringan saraf, dan obrolan bot</a></li>
<li><a href="../id440906/index.html">Webinar "167-–§–ó. Bagaimana bank dapat memenuhi persyaratan Bank Sentral untuk sistem antifraud ‚Äù- 26 Februari 2019, 11:00 waktu Moskow</a></li>
<li><a href="../id440908/index.html">Sajikan semuanya</a></li>
<li><a href="../id440910/index.html">Mengapa bank memonopoli blockchain?</a></li>
<li><a href="../id440912/index.html">Seperti rasa sakit, rasa sakit, infrastruktur sebagai layanan 1: 0</a></li>
<li><a href="../id440914/index.html">Saya kehilangan kepercayaan pada industri, terbakar, tetapi kultus alat menyelamatkan saya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>