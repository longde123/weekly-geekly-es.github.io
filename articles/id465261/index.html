<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽 📀 🎩 Kekuatan sihir makro, atau cara membuat hidup lebih mudah bagi programmer assembler AVR 👌🏾 🏇 🤧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak yang telah ditulis tentang makro di assembler. Dan dalam dokumentasi, dan di berbagai artikel. Tetapi dalam kebanyakan kasus, itu datang ke daf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kekuatan sihir makro, atau cara membuat hidup lebih mudah bagi programmer assembler AVR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465261/"><p>  Banyak yang telah ditulis tentang makro di assembler.  Dan dalam dokumentasi, dan di berbagai artikel.  Tetapi dalam kebanyakan kasus, itu datang ke daftar arahan sederhana dengan deskripsi singkat tentang fungsi mereka, atau ke satu set contoh yang berbeda dari makro siap pakai. <br>  Tujuan artikel ini adalah untuk menggambarkan pendekatan spesifik untuk pemrograman bahasa assembly untuk menghasilkan kode yang paling sederhana dan mudah dibaca menggunakan makro.  Artikel tidak akan menjelaskan sintaksis perintah dan arahan individu.  Deskripsi terperinci telah diberikan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">produsen</a> .  Kami akan fokus pada bagaimana menggunakan peluang ini untuk memecahkan masalah tertentu. </p><a name="habracut"></a><br><p>  Pada suatu waktu, ATMEL mencoba dan mengembangkan garis mikrokontroler delapan-bit dengan arsitektur berkualitas sangat tinggi dan sederhana, tetapi pada saat yang sama sistem komandonya sangat kuat.  Tetapi, seperti yang Anda tahu, tidak ada batasan untuk kesempurnaan, dan beberapa instruksi yang sering digunakan tidak cukup.  Untungnya, assembler makro, ramah dan benar-benar gratis yang disediakan oleh pabrikan, dapat menyederhanakan kode secara signifikan melalui penggunaan arahan.  Sebelum melanjutkan langsung ke makro, kami akan melakukan beberapa langkah awal </p><br><h3 id="opredelenie-konstant">  Definisi konstanta </h3><br><pre><code class="plaintext hljs">.EQU FOSC = 16000000 .EQU CLK8 = 0</code> </pre> <br><p>  Dua definisi ini memungkinkan Anda untuk menyingkirkan "angka ajaib" di makro, di mana nilai register dihitung berdasarkan frekuensi prosesor dan status sekering pembagi periferal.  Definisi pertama adalah frekuensi kristal prosesor di hertz, yang kedua adalah keadaan pembagi frekuensi periferal. </p><br><h3 id="imenovanie-registrov">  Daftar penamaan </h3><br><pre> <code class="plaintext hljs">.DEF TempL = r16 .DEF TempH = r17 .DEF TempQL = r18 .DEF TempQH = r19 .DEF AL = r0 .DEF AH = r1 .DEF AQL = r2 .DEF AQH = r3</code> </pre> <br><p>  Sekilas penamaan register penamaan yang dapat digunakan dalam makro.  Hanya empat register untuk <em>Temp</em> diperlukan jika kita berurusan dengan nilai 32-bit (misalnya, dalam operasi mengalikan dua angka 16-bit).  Jika kami yakin bahwa dua register penyimpanan sementara cukup bagi kami untuk digunakan dalam makro, maka <em>TempQL</em> dan <em>TempQH</em> tidak dapat ditentukan.  Definisi untuk <em>A</em> diperlukan untuk makro yang menggunakan operasi multiplikasi.  <em>AQ</em> tidak lagi diperlukan jika kita tidak menggunakan aritmatika 32-bit dengan makro kita. </p><br><h3 id="makrosy-dlya-realizacii-prostyh-komand">  Macro untuk mengimplementasikan perintah sederhana </h3><br><p>  Sekarang setelah kami mengetahui penamaan register, kami akan mulai mengimplementasikan perintah yang hilang dan mulai dengan mencoba menyederhanakan yang sudah ada.  Assembler AVR memiliki satu fitur aneh.  Untuk input dan output, 64 port pertama menggunakan perintah <em>masuk / keluar</em> , dan untuk <em>lds / sts yang</em> tersisa.  Agar tidak melihat dokumentasi setiap kali mencari perintah yang diperlukan untuk port tertentu, kami akan membuat seperangkat perintah universal yang secara independen akan menggantikan nilai-nilai yang diperlukan. </p><br><pre> <code class="plaintext hljs">.MACRO XOUT .IF @0&lt;64 out @0,@1 .ELSE sts @0,@1 .ENDIF .ENDMACRO .MACRO XIN .IF @1&lt;64 in @0,@1 .ELSE lds @0,@1 .ENDIF .ENDMACRO</code> </pre> <br><p>  Agar substitusi berfungsi dengan benar, kompilasi bersyarat digunakan dalam makro.  Dalam kasus ketika alamat port kurang dari 64, bagian kondisional pertama dijalankan, sebaliknya yang kedua.  Makro kami sepenuhnya mengulangi fungsionalitas perintah standar untuk bekerja dengan port input / output, oleh karena itu, untuk menunjukkan bahwa tim kami memiliki fitur-fitur canggih, kami menambahkan awalan penamaan standar <em>X.</em> <br>  Salah satu perintah yang paling umum yang tidak tersedia di assembler, tetapi selalu diperlukan, adalah perintah untuk menulis konstanta ke register input output.  Implementasi makro untuk perintah ini akan terlihat seperti ini </p><br><pre> <code class="plaintext hljs">.MACRO OUTI ldi TempL,@1 .IF @0&lt;64 out @0, TempL .ELSE sts @0, TempL .ENDIF .ENDMACRO</code> </pre> <br><p>  Dalam hal ini, nama dalam makro, agar tidak melanggar logika penamaan perintah, tambahkan ke nama standar postfix <em>I</em> , yang digunakan oleh pengembang untuk menunjukkan perintah untuk bekerja dengan konstanta.  Dalam makro ini, kami menggunakan register <em>TempL yang</em> didefinisikan sebelumnya untuk <em>operasi</em> . <br>  Dalam beberapa kasus, tidak diperlukan satu register, tetapi seluruh pasangan menyimpan nilai 16-bit.  Buat makro baru untuk menulis nilai 16-bit ke sepasang register I / O </p><br><pre> <code class="plaintext hljs">.MACRO OUTIW ldi TempL,HIGH(@1) .IF @0&lt;64 out @0H, TempL .ELSE sts @0H, TempL .ENDIF ldi TempL,LOW(@1) .IF @0&lt;64 out @0L, TempL .ELSE sts @0L, TempL .ENDIF .ENDMACRO</code> </pre> <br><p>  Dalam makro ini, kami menggunakan fungsi <em>RENDAH</em> dan <em>TINGGI</em> bawaan untuk mengekstrak byte rendah dan tinggi dari nilai 16-bit.  Dalam nama makro, tambahkan postfix <em>I</em> dan <em>W</em> ke perintah untuk menunjukkan bahwa dalam hal ini perintah bekerja dengan nilai 16-bit (kata). <br>  Tidak kurang sering dalam program ada memuat pasangan register, misalnya, untuk mengatur pointer ke memori.  Mari kita buat makro seperti itu </p><br><pre> <code class="plaintext hljs">.MACRO ldiw ldi @0L, LOW(@1) ldi @0H, HIGH(@1) .ENDMACRO</code> </pre> <br><p>  Dalam makro ini, kami menggunakan fakta bahwa penamaan standar register dan port di pabrik menyiratkan postfix <em>L</em> untuk yang lebih rendah dan postfix <em>H</em> untuk bagian atas dari nilai byte ganda.  Jika Anda mengikuti aturan ini saat memberi nama variabel Anda sendiri, maka makro akan bekerja dengan benar, termasuk dengan mereka.  Keindahan makro juga terletak pada kenyataan bahwa mereka menyediakan substitusi sederhana, oleh karena itu, dalam kasus ketika operan kedua adalah angka, dan dalam kasus ketika ini adalah nama label, makro akan bekerja dengan benar. </p><br><h3 id="makrosy-dlya-realizacii-slozhnyh-komand">  Makro untuk mengimplementasikan perintah kompleks. </h3><br><p>  Ketika datang ke operasi yang lebih kompleks, makro umumnya tidak digunakan, lebih memilih rutinitas.  Namun, dalam kasus ini, makro dapat membuat hidup lebih mudah dan membuat kode lebih mudah dibaca.  Dalam hal ini, kompilasi bersyarat datang untuk menyelamatkan.  Pendekatan pemrograman mungkin terlihat seperti ini: <br>  Kami menempatkan semua rutinitas kami di file terpisah, yang akan kami <strong>beri</strong> nama, misalnya, <strong>Library.inc</strong> .  Setiap subrutin dalam file ini akan memiliki formulir berikut </p><br><pre> <code class="plaintext hljs">_sub0: .IFDEF __sub0 ; -----    ----- ret .ENDIF</code> </pre> <br><p>  Dalam hal ini, keberadaan definisi __sub0 berarti bahwa subrutin harus dimasukkan dalam kode yang dihasilkan.  Kalau tidak, itu diabaikan. <br>  Selanjutnya, dalam file terpisah <strong>Macro.inc, kami</strong> mendefinisikan makro formulir </p><br><pre> <code class="plaintext hljs">.MACRO SUB0 .IFNDEF __sub0 .DEF __sub0 .ENDIF ; ---          call _sub0 .ENDMACRO</code> </pre> <br><p>  Saat menggunakan makro ini, kami memeriksa definisi __sub0 dan, jika tidak ada, kami melakukan penentuan.  Akibatnya, menggunakan makro membuka kunci dimasukkannya kode subrutin dalam file output.  Dalam hal menggunakan rutin dalam makro, kode program utama akan mengambil bentuk berikut </p><br><pre> <code class="plaintext hljs">.INCLUDE “Macro.inc” ;----    ---- .INCLUDE “Library.inc”</code> </pre> <br><p>  Sebagai contoh, kami memberikan implementasi makro untuk membagi bilangan bulat 8-bit yang tidak ditandatangani.  Kami menyimpan logika pabrikan dan menempatkan hasilnya di <em>AL (r0)</em> , dan sisanya dari divisi di <em>AH (r1)</em> .  Subrutin akan terlihat sebagai berikut </p><br><pre> <code class="plaintext hljs">_div8u: .IFDEF __ div8u ;AH -  ;AL  ;TempL -  ;TempH -  ;TempQL -  clr AL; clr AH; ldi TempQL,9 d8u_1: rol TempL dec TempQL brne d8u_2 ret d8u_2: rol A sub AH, TempH brcc d8u_3 add AH,TempH clc rjmp d8u_1 d8u_3: sec rjmp d8u_1 .ENDIF</code> </pre> <br><p>  Definisi makro untuk menggunakan rutin ini adalah sebagai berikut </p><br><pre> <code class="plaintext hljs">.MACRO DIV8U .IFNDEF __div8u .DEF __div8u .ENDIF mov TempL, @0 mov TempH, @1 call _div8u .ENDMACRO</code> </pre> <br><p>  Jika diinginkan, Anda dapat menambahkan versi untuk bekerja dengan konstanta </p><br><pre> <code class="plaintext hljs">.MACRO DIV8UI .IFNDEF __div8u .DEF __div8u .ENDIF mov TempL, @0 ldi TempH, @1 call _div8u .ENDMACRO</code> </pre> <br><p>  Akibatnya, menggunakan operasi divisi dalam teks program adalah sepele </p><br><pre> <code class="plaintext hljs">DIV8U r10, r11 ; r0 = r10/r11 r1 = r10 % r11 DIV8UI r10, 35 ; r0 = r10/35 r1 = r10 % 35</code> </pre> <br><p>  Menggunakan kompilasi bersyarat, kami dapat menempatkan semua rutin yang dapat bermanfaat bagi kami di <strong>Library.inc</strong> .  Dalam hal ini, hanya mereka yang dipanggil setidaknya satu kali yang akan muncul dalam kode output.  Perhatikan posisi label entri.  Keluaran label di luar batas kondisi disebabkan oleh kompiler.  Jika Anda menempatkan label di badan blok bersyarat, kompiler dapat membuat kesalahan.  Kehadiran tag yang tidak digunakan dalam kode tidak menakutkan, karena keberadaan sejumlah tag tidak mempengaruhi hasilnya. </p><br><h3 id="makrosy-dlya-raboty-s-periferiey">  Makro perifer </h3><br><p>  Salah satu operasi yang sulit dilakukan tanpa menggunakan dokumentasi pabrikan adalah menginisialisasi perangkat periferal.  Bahkan dengan penggunaan penunjukan mnemonik register dan bit dari kode, bisa sulit untuk memahami di mana mode perangkat dikonfigurasi, terutama karena kadang-kadang mode dikonfigurasi oleh kombinasi nilai bit dari register yang berbeda.  Mari kita lihat bagaimana makro dapat digunakan dengan contoh <em>USART</em> . <br>  Mari kita mulai dengan makro inisialisasi mode asinkron. </p><br><pre> <code class="plaintext hljs">.MACRO USART_INIT ; speed, bytes, parity, stop-bits .IF CLK8 == 0 .SET DIVIDER = FOSC/16/@0-1 .ELSE .SET DIVIDER = FOSC/128/@0-1 .ENDIF ; Set baud rate to UBRR0 outi UBRR0H, HIGH(DIVIDER) outi UBRR0L, LOW(DIVIDER) ; Enable receiver and transmitter .SET UCSR0B_ = (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0) outi UCSR0B, UCSR0B_ .SET UCSR0C_ = 0 .IF @2 == 'E' .SET UCSR0C_ |= (1&lt;&lt;UPM01) .ENDIF .IF @2 == 'O' .SET UCSR0C_ |= (1&lt;&lt;UPM00) .ENDIF .IF @3== 2 .SET UCSR0C_ |= (1&lt;&lt;USBS0) .ENDIF .IF @1== 6 .SET UCSR0C_ |= (1&lt;&lt;UCSZ00) .ENDIF .IF @1== 7 .SET UCSR0C_ |= (1&lt;&lt;UCSZ01) .ENDIF .IF @1== 8 .SET UCSR0C_ = UCSR0C_ |(1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00) .ENDIF .IF @1== 9 .SET UCSR0C_ |= (1&lt;&lt;UCSZ02)|(1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00) .ENDIF ; Set frame format outi UCSR0C,UCSR0C_ .ENDMACRO</code> </pre> <br><p>  Dengan menggunakan makro, kami dapat mengganti inisialisasi register pengaturan <em>USART</em> dengan nilai-nilai yang tidak dapat dipahami tanpa membaca dokumentasi dengan garis yang dapat ditangani bahkan oleh mereka yang pertama kali menemukan pengontrol ini.  Dalam makro ini, juga akhirnya menjadi jelas mengapa kami menentukan frekuensi dan konstanta pembagi.  Yah, harus dicatat bahwa terlepas dari kode makro yang mengesankan itu sendiri, yang dihasilkan akan memiliki penampilan yang sama seperti jika kita menulis inisialisasi dengan cara yang biasa. <br>  Untuk menyelesaikan dengan <em>USART,</em> berikut adalah beberapa makro kecil </p><br><pre> <code class="plaintext hljs"> .MACRO USART_SEND_ASYNC outi UDR0, @0 .ENDMACRO</code> </pre> <br><p>  Hanya ada satu baris, tetapi menggunakan makro ini akan memungkinkan Anda untuk lebih melihat di mana program menampilkan data di <em>USART</em> .  Jika kami menganggap bekerja dalam mode sinkron tanpa menggunakan interupsi, maka alih-alih <em>USART_SEND_ASYNC</em> lebih baik menggunakan makro di bawah ini </p><br><pre> <code class="plaintext hljs"> .MACRO USART_SEND USART_Transmit: xin TempL, UCSR0A sbrs TempL, UDRE0 rjmp USART_Transmit outi UDR0, @0 .ENDMACRO</code> </pre> <br><p>  Dalam hal ini, kami mengaktifkan pemeriksaan okupansi port dan menampilkan data hanya ketika port tersebut gratis.  Jelas, pendekatan ini untuk bekerja dengan perangkat periferal akan bekerja untuk perangkat apa pun, dan tidak hanya untuk <em>USART</em> . </p><br><h3 id="sravnenie-programm-bez-i-s-ispolzovaniem-makrosov">  Perbandingan program tanpa dan menggunakan makro. </h3><br><p>  Mari kita lihat contoh kecil dan bandingkan kode yang ditulis tanpa menggunakan makro dengan kode tempat mereka digunakan.  Misalnya, ambil program yang menampilkan klasik <strong>"Hello world!"</strong>  ke terminal melalui perangkat keras <em>UART</em> . </p><br><pre> <code class="plaintext hljs"> RESET: ldi r16, high(RAMEND) out SPH,r16 ldi r16, low(RAMEND) out SPL,r16 USART_Init: out UBRR0H, r17 out UBRR0L, r16 ldi r16, (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0) out UCSRnB,r16 ldi r16, (1&lt;&lt;USBS0)|(3&lt;&lt;UCSZ00) out UCSR0C,r16 ldi ZL, LOW(STR&lt;&lt;1) ldi ZH, HIGH(STR&lt;&lt;1) LOOP: lpm r16, Z+ or r16,r16 breq END USART_Transmit: in r17, UCSR0A sbrs r17, UDRE0 rjmp USART_Transmit out UDR0,r16 rjmp LOOP END: rjmp END STR: .DB “Hello world!”,0</code> </pre> <br><p>  Dan di sini adalah program yang sama, tetapi ditulis menggunakan macro </p><br><pre> <code class="plaintext hljs">.INCLUDE “macro.inc” .EQU FOSC = 16000000 .EQU CLK8 = 0 RESET: ldiw SP, RAMEND; USART_INIT 19200, 8, "N", 1 ldiw Z, STR&lt;&lt;1 LOOP: lpm TempL, Z+ test TempL breq END USART_SEND TempL rjmp LOOP END: rjmp END STR: .DB “Hello world!”,0</code> </pre> <br><p>  Dalam contoh ini, kami menggunakan makro yang dijelaskan di atas, yang memungkinkan kami untuk menyederhanakan kode program secara signifikan dan membuatnya lebih mudah dipahami.  Kode biner di kedua program akan benar-benar identik. </p><br><h3 id="vyvod">  Kesimpulan </h3><br><p>  Menggunakan makro dapat secara signifikan mengurangi kode assembler program, agar lebih mudah dipahami dan dibaca.  Kompilasi bersyarat memungkinkan Anda membuat perintah universal dan pustaka prosedur tanpa membuat kode output yang berlebihan.  Sebagai kekurangan, seseorang dapat menunjukkan sangat sederhana dengan standar bahasa tingkat tinggi yang mengatur operasi dan pembatasan yang diizinkan ketika menyatakan data "maju".  Pembatasan ini tidak memungkinkan, misalnya, menulis dengan cara makro perintah universal penuh untuk <em>transisi jmp / rjmp</em> dan secara signifikan mengembang kode makro itu sendiri ketika menerapkan logika kompleks. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465261/">https://habr.com/ru/post/id465261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465249/index.html">Kuliah oleh Richard Stallman di Politeknik Moskow. Agustus 2019</a></li>
<li><a href="../id465251/index.html">Musim panas hampir berakhir. Hampir tidak ada data yang bocor</a></li>
<li><a href="../id465255/index.html">Implementasi Pool Connection WCF untuk .Net Core Menggunakan HttpClientFactory</a></li>
<li><a href="../id465257/index.html">"Waspadalah, FAS!": Trik McDonald's, shawarma ilahi, Clooney palsu dan beberapa sihir jalanan</a></li>
<li><a href="../id465259/index.html">ValueTask <TResult> - mengapa, mengapa dan bagaimana?</a></li>
<li><a href="../id465263/index.html">Locks in PostgreSQL: 3. Mengunci objek lain</a></li>
<li><a href="../id465267/index.html">TypeScript Sihir Ekspresi</a></li>
<li><a href="../id465269/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 26. DNS dan DHCP</a></li>
<li><a href="../id465271/index.html">Peretas mencuri dan mencuci uang melalui pengiriman makanan dan layanan pemesanan hotel.</a></li>
<li><a href="../id465273/index.html">Bagaimana Pengembang Perangkat Lunak Microgaming Melindungi Pengguna dari Hacks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>