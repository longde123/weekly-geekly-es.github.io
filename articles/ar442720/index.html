<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛠️ 🌈 🤰 تعميم العلامة السريعة على خريطة WebGL 🤴🏿 👩🏻‍🤝‍👨🏽 👩🏽‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="علامات شيء جيد. مفيدة بكميات معقولة. عندما يكون هناك الكثير منهم ، تختفي الفوائد. ماذا تفعل إذا كنت تريد وضع علامة على نتائج البحث على الخريطة ، والتي...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تعميم العلامة السريعة على خريطة WebGL</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/442720/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/wl/if/9y/wlif9yuvumhoa16egkvqphgdzyo.png" alt="الصورة"></p><br><p style=";text-align:right;direction:rtl">  علامات شيء جيد.  مفيدة بكميات معقولة.  عندما يكون هناك الكثير منهم ، تختفي الفوائد.  ماذا تفعل إذا كنت تريد وضع علامة على نتائج البحث على الخريطة ، والتي بها عشرات الآلاف من الكائنات؟  سأخبرك في المقالة كيف نحل هذه المشكلة على بطاقة WebGL دون المساس بمظهرها وأدائها. </p><a name="habracut"></a><br><h1 id="predystoriya" style=";text-align:right;direction:rtl">  الخلفية </h1><br><p style=";text-align:right;direction:rtl">  في عام 2016 ، أطلقت 2GIS مشروع WebGL الأول ، Floors: 3D floor floor of Buildings. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/dt/90/4v/dt904vhpl-gjcyju0tuf_n-nefc.png" alt="الصورة"><br>  <em>طوابق نوفوسيبيرسك مركز التسوق هالة</em> </p><br><p style=";text-align:right;direction:rtl">  مباشرة بعد إصدار Floors ، بدأ فريقنا في تطوير محرك رسومي ثلاثي الأبعاد كامل على WebGL.  تم تطوير المحرك بالتزامن مع الإصدار الجديد 2gis.ru وهو الآن في حالة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تجريبية عامة</a> . </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/_9/nl/q9/_9nlq9yh87m2vbaznj3_tvji6q8.png" alt="الصورة"><br>  <em>مربع أحمر مرسوم على WebGL.</em>  <em>تم دمج خطط البناء الآن مباشرةً في الخريطة.</em> </p><br><h1 id="zadacha-generalizacii-podpisey" style=";text-align:right;direction:rtl">  مهمة تعميم التوقيع </h1><br><p style=";text-align:right;direction:rtl">  أي شخص يريد أن يكتب محرك الخرائط الخاص به سيواجه عاجلاً أو آجلاً مشكلة وضع التواقيع على الخريطة.  هناك الكثير من الكائنات على الخريطة ، ومن المستحيل توقيع كل منها حتى لا تتداخل التواقيع. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/si/0j/cf/si0jcfdcbaz8tqeazopjba1f1b8.png" alt="الصورة"><br>  <em>ماذا سيحدث إذا وقعت في نوفوسيبيرسك جميع الكائنات دفعة واحدة</em> </p><br><p style=";text-align:right;direction:rtl">  لحل هذه المشكلة ، مطلوب <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تعميم</a> التوقيعات.  التعميم بالمعنى العام هو تحويل بيانات الخريطة بحيث تكون مناسبة للعرض على نطاقات صغيرة.  ويمكن القيام به بطرق مختلفة.  بالنسبة للتوقيعات ، يتم استخدام طريقة التحديد عادة: من العدد الإجمالي ، يتم تحديد مجموعة فرعية من أكثر التواقيع ذات الأولوية التي لا تتداخل. </p><br><p style=";text-align:right;direction:rtl">  يتم تحديد أولوية التوقيع حسب نوعه ، بالإضافة إلى مقياس الخريطة الحالي.  على سبيل المثال ، على نطاق صغير ، هناك حاجة لتوقيع المدن والبلدان ، وعلى نطاق واسع ، أصبحت توقيعات الطرق وأرقام المنازل أكثر أهمية.  غالبًا ما يتم تحديد أولوية اسم المستوطنة حسب حجم سكانها.  كلما زاد حجمها ، كلما كان التوقيع أكثر أهمية. </p><br><p style=";text-align:right;direction:rtl">  التعميم مطلوب ليس فقط للتوقيعات ، ولكن أيضًا للعلامات التي تحدد نتائج البحث على الخريطة.  على سبيل المثال ، عند البحث عن "متجر" في موسكو ، هناك أكثر من 15000 نتيجة.  من الواضح أن وضع علامة عليها جميعًا على الخريطة مرة واحدة فكرة سيئة. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/2a/in/jj/2ainjj57s8zfmdjv4103va5trqm.png" alt="الصورة"><br>  <em>جميع متاجر موسكو على الخريطة.</em>  <em>لا توجد طريقة للقيام دون التعميم</em> </p><br><p style=";text-align:right;direction:rtl"> يؤدي أي تفاعل من جانب المستخدم مع الخريطة (الحركة والتكبير / التصغير والإمالة) إلى حدوث تغيير في موضع العلامات على الشاشة ، لذلك يجب أن تكون قادرًا على إعادة حساب التعميم أثناء التنقل.  لذلك ، يجب أن تكون سريعة. </p><br><p style=";text-align:right;direction:rtl">  في هذه المقالة ، باستخدام مثال تعميم العلامة ، سأعرض طرقًا مختلفة لحل هذه المشكلة ، والتي تم استخدامها في أوقات مختلفة في مشاريعنا. </p><br><h1 id="obschiy-podhod-k-generalizacii" style=";text-align:right;direction:rtl">  النهج العام للتعميم </h1><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  عرض كل علامة على مستوى الشاشة وحسابها ملزمة - المنطقة المستطيلة التي تشغلها على الشاشة. </li><li style=";text-align:right;direction:rtl">  فرز علامات حسب الأولوية. </li><li style=";text-align:right;direction:rtl">  قم بفحص كل علامة بالتتابع ووضعها على الشاشة إذا لم تتقاطع مع العلامات الأخرى الموضوعة أمامها. </li></ol><br><p style=";text-align:right;direction:rtl">  مع النقطة 1 ، كل شيء واضح - إنه مجرد حساب.  فيما يتعلق بالبند 2 ، كنا محظوظين أيضًا: يتم فرز قائمة العلامات التي تأتي إلينا من الخلفية حسب الأولوية حسب خوارزميات البحث.  النتائج الأكثر صلة التي من المرجح أن تكون ذات فائدة للمستخدم هي في الجزء العلوي من النتائج. </p><br><p style=";text-align:right;direction:rtl">  تكمن المشكلة الرئيسية في الفقرة 3: يمكن أن يعتمد وقت حساب التعميم إلى حد كبير على كيفية تنفيذه. </p><br><p style=";text-align:right;direction:rtl">  للبحث عن التقاطعات بين العلامات ، نحتاج إلى بعض بنية البيانات التي: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يخزن حدود العلامات المضافة إلى الشاشة. </li><li style=";text-align:right;direction:rtl"> لديه طريقة <code>insert(marker)</code> لإضافة علامة إلى الشاشة. </li><li style=";text-align:right;direction:rtl">  لديها طريقة <code>collides(marker)</code> للتحقق من علامة التقاطع مع تلك المضافة بالفعل إلى الشاشة. </li></ol><br><p style=";text-align:right;direction:rtl">  النظر في العديد من التطبيقات لهذا الهيكل.  سيتم كتابة جميع الأمثلة الإضافية في TypeScript ، والتي نستخدمها في معظم مشاريعنا.  في جميع الأمثلة ، سيتم تمثيل العلامات بواسطة كائنات من النموذج التالي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">interface Marker { minX: number; maxX: number; minY: number; maxY: number; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  جميع الأساليب التي تم النظر فيها ستكون تطبيقات للواجهة التالية: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">interface CollisionDetector { insert(item: Marker): void; collides(item: Marker): boolean; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  لمقارنة الأداء ، سيتم قياس وقت تنفيذ الكود التالي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> marker <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> markers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!impl.collides(marker)) { impl.insert(marker); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  سوف تحتوي مجموعة <code>markers</code> على 100،000 عنصر 30x50 موضوعة بشكل عشوائي على طائرة بحجم 1920 × 1080. </p><br><p style=";text-align:right;direction:rtl">  سيتم قياس الأداء على جهاز Macbook Air 2012. </p><br><p style=";text-align:right;direction:rtl">  كما يتم نشر الاختبارات وأمثلة التعليمات البرمجية الواردة في المقالة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">على جيثب</a> . </p><br><h1 id="naivnaya-realizaciya" style=";text-align:right;direction:rtl">  تنفيذ ساذج </h1><br><p style=";text-align:right;direction:rtl">  للبدء ، فكر في أبسط الخيارات ، عندما يتم تحديد علامة التقاطع مع الآخرين في دورة بسيطة. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NaiveImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private markers: Marker[]; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers = []; } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers.push(marker); } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (marker <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( candidate.minX &lt;= marker.maxX &amp;&amp; candidate.minY &lt;= marker.maxY &amp;&amp; candidate.maxX &gt;= marker.minX &amp;&amp; candidate.maxY &gt;= marker.minY ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  مدة حساب التعميم لـ 100،000 علامة: <strong>420 مللي ثانية</strong> .  كثير جدا  حتى إذا تم حساب التعميم في أحد العاملين على الويب ولا يحجب الخيط الرئيسي ، فسيكون هذا التأخير ملحوظًا بالعين ، خاصة وأن هذه العملية يجب أن تتم بعد كل حركة بطاقة.  علاوة على ذلك ، على الأجهزة المحمولة التي تحتوي على معالج ضعيف ، يمكن أن يكون التأخير أكبر. </p><br><h1 id="realizaciya-s-primeneniem-r-dereva" style=";text-align:right;direction:rtl">  تنفيذ R- شجرة </h1><br><p style=";text-align:right;direction:rtl">  نظرًا للتطبيق الساذج في كل علامة يتم التحقق من تقاطعها مع جميع العلامات السابقة ، وفي أسوأ الحالات ، يكون تعقيد هذه الخوارزمية من الدرجة الثانية.  يمكنك تحسينه عن طريق تطبيق بنية بيانات R-tree.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كتطبيق</a> لـ R-tree ، خذ مكتبة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">RBush</a> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> rbush <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rbush'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RTreeImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private tree: rbush.RBush&lt;Marker&gt;; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree = rbush(); } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree.insert(marker); } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree.collides(candidate); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  مدة حساب التعميم لـ 100،000 علامة: <strong>173 مللي ثانية</strong> .  أفضل بكثير.  استخدمنا هذا النهج في الطوابق (تم ذكر ذلك في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مقالتي السابقة</a> ). </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/44/mp/v5/44mpv5pc8gwyqr4jfr5mqcibwqu.png" alt="الصورة"><br>  <em>تصور لتخزين النقاط في شجرة R.</em>  <em>يتيح لك التقسيم الهرمي للمستوى إلى مستطيلات تضييق نطاق البحث بسرعة وعدم الفرز بين جميع الكائنات</em> </p><br><h1 id="realizaciya-s-primeneniem-bufera-kolliziy" style=";text-align:right;direction:rtl">  تنفيذ الاصطدام العازلة </h1><br><p style=";text-align:right;direction:rtl">  يعد رسم خريطة مهمة أكثر تعقيدًا من رسم مخطط لمبنى واحد.  هذا يتجلى أيضا في التعميم.  حتى في أكبر مراكز التسوق في العالم ، نادراً ما توجد 1000 مؤسسة في نفس الطابق.  في الوقت نفسه ، يمكن أن يؤدي استعلام بحث بسيط في مدينة كبيرة إلى إرجاع عشرات الآلاف من النتائج. </p><br><p style=";text-align:right;direction:rtl">  عندما بدأنا في تطوير خريطة WebGL ، بدأنا في التفكير: هل لا يزال من الممكن تسريع التعميم.  لقد قدّم لنا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link">stellarator</a> فكرة مثيرة للاهتمام: بدلاً من شجرة R ، استخدم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link">مخزنًا مؤقتًا</a> لتخزين حالة كل بكسل من الشاشة (مشغول أو غير مشغول).  عند إدخال علامة على الشاشة ، "املأ" المكان المقابل في المخزن المؤقت ، وعند التحقق من إمكانية اللصق ، تحقق من قيم البيكسل في المنطقة المطلوبة. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionBufferByteImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private buffer: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; private height: number; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(width: number, height: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(width * height); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = minX; i &lt; maxX; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { buffer[i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height + j] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = candidate; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = minX; i &lt; maxX; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height + j]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  مدة حساب التعميم لـ 100،000 علامة: <strong>46 مللي ثانية</strong> . </p><br><p style=";text-align:right;direction:rtl">  لماذا سريع جدا؟  يبدو هذا النهج ساذجًا للوهلة الأولى ، كما أن الحلقات المتداخلة في كلا الطريقتين لا تشبه الكود السريع.  ومع ذلك ، إذا ألقيت نظرة فاحصة على الكود ، فستلاحظ أن وقت تنفيذ كلا الطريقتين لا يعتمد على العدد الإجمالي للعلامات.  وبالتالي ، للحصول على حجم ثابت من علامات WxH ، نحصل على التعقيد O (W * H * n) ، أي خطي! </p><br><h1 id="optimizaciya-podhoda-s-buferom-kolliziy" style=";text-align:right;direction:rtl">  الأمثل نهج الاصطدام العازلة </h1><br><p style=";text-align:right;direction:rtl">  يمكنك تحسين النهج السابق سواء في السرعة أو في الذاكرة المشغولة ، إذا تأكدت من تمثيل بكسل واحد في الذاكرة ليس بواسطة بايت واحد ، ولكن بت واحد.  ومع ذلك ، فإن الكود بعد هذا التحسين معقد بشكل ملحوظ وينمو مع قليل من السحر: </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">شفرة المصدر</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionBufferBitImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private width: number; private height: number; private buffer: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(width: number, height: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.ceil(width / <span class="hljs-number"><span class="hljs-number">8</span></span>) * <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height / <span class="hljs-number"><span class="hljs-number">8</span></span>); } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { width, buffer } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = j * width + minX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = j * width + maxX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start === end) { buffer[start] = buffer[start] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { buffer[start] = buffer[start] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { buffer[i] = <span class="hljs-number"><span class="hljs-number">255</span></span>; } buffer[end] = buffer[end] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } } } collides(marker: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { width, buffer } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = j * width + minX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = j * width + maxX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start === end) { sum = buffer[start] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sum = buffer[start] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { sum = buffer[i] | sum; } sum = buffer[end] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))) | sum; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> </div></div><br><p style=";text-align:right;direction:rtl">  مدة حساب التعميم لـ 100،000 علامة: <strong>16 مللي ثانية</strong> .  كما ترون ، فإن تعقيد المنطق يبرر نفسه ويسمح لنا بتسريع حساب التعميم بمقدار ثلاث مرات تقريبًا. </p><br><h1 id="ogranicheniya-bufera-kolliziy" style=";text-align:right;direction:rtl">  حدود الاصطدام العازلة </h1><br><p style=";text-align:right;direction:rtl">  من المهم أن نفهم أن المخزن المؤقت للتصادم ليس بديلاً كاملاً لشجرة R.  لديها ميزات أقل بكثير والمزيد من القيود: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لا يمكنك فهم ما تتقاطع به العلامة بالضبط.  المخزن المؤقت فقط بتخزين البيانات حول أي بكسل مشغولة والتي ليست كذلك.  لذلك ، من المستحيل تنفيذ عملية تقوم بإرجاع قائمة العلامات التي تتقاطع مع المحدد. </li><li style=";text-align:right;direction:rtl">  لا يمكن حذف العلامة المضافة سابقًا.  لا يقوم المخزن المؤقت بتخزين البيانات على عدد العلامات بالبكسل المحدد.  لذلك ، من المستحيل تطبيق عملية إزالة علامة من المخزن المؤقت بشكل صحيح. </li><li style=";text-align:right;direction:rtl">  حساسية عالية لحجم العناصر.  إذا حاولت إضافة علامات تشغل الشاشة بأكملها إلى المخزن المؤقت للتصادم ، فإن الأداء سينخفض ​​بشكل كبير. </li><li style=";text-align:right;direction:rtl">  يعمل في منطقة محدودة.  يتم تعيين حجم المخزن المؤقت عند إنشائه ، ومن المستحيل وضع علامة فيه تتجاوز هذا الحجم.  لذلك ، عند استخدام هذا الأسلوب ، من الضروري تصفية العلامات التي لا تظهر على الشاشة يدويًا. </li></ol><br><p style=";text-align:right;direction:rtl">  كل هذه القيود لم تتداخل مع حل مشكلة تعميم العلامة.  الآن يتم استخدام هذه الطريقة بنجاح للعلامات في الإصدار التجريبي من 2gis.ru. </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، لتعميم التوقيعات الرئيسية على الخريطة ، فإن المتطلبات أكثر تعقيدًا.  على سبيل المثال ، بالنسبة لهم ، من الضروري التأكد من أن أيقونة POI لا يمكنها "قتل" توقيعها الخاص.  نظرًا لأن المخزن المؤقت للتصادم لا يميز بالضبط ما حدث مع التقاطع ، فإنه لا يسمح بتنفيذ هذا المنطق.  لذلك ، كان عليهم ترك حل مع RBush. </p><br><h1 id="vyvod" style=";text-align:right;direction:rtl">  استنتاج </h1><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/cl/ey/uq/cleyuqjc1utr1xm4elsi2g_uxxs.png" alt="الصورة"><br>  توضح المقالة المسار الذي سلكناه من أبسط الحلول إلى الحل المستخدم الآن. </p><br><p style=";text-align:right;direction:rtl">  كان استخدام R-tree أول خطوة مهمة سمحت لنا بتسريع التنفيذ الساذج مرات عديدة.  إنه يعمل بشكل رائع في الطوابق ، لكن في الواقع لا نستخدم سوى جزء صغير من قدرات بنية البيانات هذه. </p><br><p style=";text-align:right;direction:rtl">  بعد التخلي عن R-tree واستبدالها بمصفوفة ثنائية الأبعاد بسيطة ، والتي تفعل ما نحتاجه بالضبط ، ولا شيء غير ذلك ، حصلنا على زيادة أكبر في الإنتاجية. </p><br><p style=";text-align:right;direction:rtl">  يوضح لنا هذا المثال مدى أهمية اختيار حل لمشكلة ما من خلال عدة خيارات لفهم وإدراك حدود كل منها.  القيود مهمة ومفيدة ، ويجب ألا تخاف منها: إن قصر نفسك بمهارة على شيء غير ذي أهمية ، يمكنك الحصول على فوائد ضخمة في مقابل ما تحتاج إليه فعلاً.  على سبيل المثال ، لتبسيط حل مشكلة ما ، أو لحماية نفسك من مجموعة كاملة من المشاكل ، أو ، كما هو الحال في حالتنا ، لتحسين الإنتاجية عدة مرات. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar442720/">https://habr.com/ru/post/ar442720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar442708/index.html">ما الذي يحدد إيرادات عمال المناجم؟</a></li>
<li><a href="../ar442710/index.html">مراجعة Google IoT Platform</a></li>
<li><a href="../ar442714/index.html">مثل العيوب</a></li>
<li><a href="../ar442716/index.html">موطئ قدم</a></li>
<li><a href="../ar442718/index.html">وجد موظفو Google أن العمل على إصدار محرك البحث الخاص بالصين مستمر</a></li>
<li><a href="../ar442722/index.html">التوقف عن تنزيل وتخزين الأصفار</a></li>
<li><a href="../ar442724/index.html">فيلم "مساحة المكتب" يبلغ من العمر 20 عامًا: كيف غيّر وظائفنا</a></li>
<li><a href="../ar442726/index.html">يمكن للروبوت الفهد معهد ماساتشوستس للتكنولوجيا القيام تقلب الظهر وتشغيل سريع</a></li>
<li><a href="../ar442730/index.html">مايكروسوفت: روسيا تتقدم على الولايات المتحدة وأوروبا في تطبيق الذكاء الاصطناعي</a></li>
<li><a href="../ar442732/index.html">بلدي قليلا التبديلات: الثلاثي Brainfuck ، أو ما هو الجنون</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>