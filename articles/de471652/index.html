<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧🏿 🔰 👍🏻 Mein Leben mit Boost Graph Library 👿 🐙 🚆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Artikel, dessen erster Teil hier vorgestellt wird, enthält verschiedene Überlegungen des Autors, die während der langen Entwicklung eines speziell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mein Leben mit Boost Graph Library</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471652/">  Der Artikel, dessen erster Teil hier vorgestellt wird, enthält verschiedene Überlegungen des Autors, die während der langen Entwicklung eines speziellen Systems zur Suche nach sozialen Verbindungen auf der Grundlage der Boost Graph Library (BGL) gesammelt wurden.  Dieser (technische) Abschnitt fasst die Eindrücke des Autors von der Arbeit mit dieser Bibliothek zusammen, wirft Probleme bei der Instrumentierung beim Erstellen von Diagrammanwendungen auf und geht auf einige praktische Probleme der Metaprogrammierung in C ++ ein. <br><a name="habracut"></a><br><h3>  BGL und womit es gegessen wird </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die BGL-Vorlagenbibliothek ist</a> wahrscheinlich jedem Entwickler bekannt, der auf Diagrammaufgaben gestoßen ist.  Als sie im Jahr 2000 in Boost 1.18.1 auftrat, erhielt sie sofort die Zustimmung von Klassikern des Genres wie Alexander Stepanov.  Der von Jeremy Sik, Lai-Kwan Lee und Andrew Lamsdane zusammengestellte Bibliotheksführer wurde 2006 von Peter in russischer Sprache veröffentlicht (Original - Jeremy G. Siek, Lie-Quan Lee und Andrew Lumsdaine, „The Boost Graph Library“, 2001 , Addison-Wesley).  Die Bibliothek wurde fast bis Ende 2013 intensiv aktualisiert und weiterentwickelt (Boost 1.55.0).  Insbesondere im Jahr 2005 erschien die Ankündigung der Distributed Version (PBGL), die seit Version 1.40 im Jahr 2009 in Boost enthalten ist und bis heute eine Art De-facto-Standard für die Grafikberechnung auf Hochleistungsclustern ist. in der akademischen Welt.  Soweit die Geschichte der Commits beurteilt werden kann, war bis 2005 der Hauptentwickler der Bibliothek Jeremy Sik, nach 2005 - Douglas Gregor, und im Allgemeinen arbeiteten zu verschiedenen Zeiten eine beträchtliche Anzahl verschiedener Personen an der Bibliothek.  Die dazugehörigen Veröffentlichungen sind wiederholt auf habr.com erschienen: Zunächst ist eine Reihe von Artikeln von Vadim Androsov zu beachten: [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> ].  Grundsätzlich ist der Bibliothek also gute und vielfältige Literatur gewidmet, aber ihre eigene Dokumentation, die im Allgemeinen auch recht umfangreich ist, leidet etwas unter der Tatsache, dass: <br><br><ol><li>  Das Inhaltsverzeichnis und die Stammabschnitte, die eine vollständige Liste der wichtigsten Entitäten enthalten sollen, haben sich seit 2001 nicht geändert.  Zum Beispiel der Autor dieser Zeilen, der naiv glaubte, dass: <blockquote>  Die BGL bietet derzeit zwei Diagrammklassen und einen Kantenlistenadapter: <br><br>  adjacency_list <br>  adjacency_matrix <br>  edge_list </blockquote>  Nach einiger Zeit war ich überrascht, die 2005 implementierte Darstellung von compress_sparse_row_graph (Sparse Matrix) zu finden.  Eine ähnliche Geschichte fand mit dem Bron-Kerbosch-Algorithmus statt.  Glauben Sie dem Inhaltsverzeichnis nicht, verwenden Sie eine direkte Suche in den Header-Dateien; <br></li><li>  Es ist keine einzige kommentierte Liste der internen Kategorien der Bibliothek (container_category, parallel_edge_traits, iterator_stability usw. usw.) erforderlich, um Ihre eigenen Ansichten zu implementieren.  Probleme mit dem Verständnis des Geschehens überholen anscheinend alle Benutzer der Bibliothek, die tiefer graben möchten, was zum Auftreten einer „Art von Arbeitscode“ führt, der viel Zeit und Mühe erfordert, um ihn in einen vollständigen Zustand zu bringen: siehe zum Beispiel eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">typische Diskussion</a> . </li></ol><br>  Die Anzahl der Kategorien und verschiedener Selektoren, einschließlich derjenigen, die verwirrend ähnlich sind, ist so groß, dass die Autoren selbst manchmal verwirrt sind.  In den Konstruktoren des oben bereits erwähnten komprimierten_sparse_row_graph tritt beispielsweise in der aktuellen Version ein systematischer Fehler auf, der zu Abstürzen führt, wenn versucht wird, eine ungerichtete Adjazenzliste zu kopieren: <br><br><img src="https://habrastorage.org/webt/5r/1e/se/5r1esesty1oui-pwco4b2pkfxei.jpeg"><br><br>  Es kann hier gelegentlich angemerkt werden, dass das vollständige Testen eines solchen flexiblen Mechanismus ein separates Problem darstellt, da es mit einer kombinatorischen Explosion der Anzahl möglicher Substitutionen einhergeht. <br><br>  Mit Bedauern ist anzumerken, dass die Hauptentwickler derzeit offenbar das Interesse an weiteren Arbeiten an der Bibliothek verloren haben und sie in den letzten sechs Jahren keineswegs ihr Entwicklungspotential ausgeschöpft und sich nicht einmal vollständig von internen Inkonsistenzen und direkten Fehlern befreit hat.  Die in der Region 2011 geäußerten Pläne, das Methodenspektrum erheblich zu erweitern und neue Bereiche der Graphentheorie abzudecken (einschließlich des Hinzufügens interner Unterstützung für die Graphpartitionierung zur Fähigkeit, das METIS-Format zu lesen), blieben unerfüllt.  Es scheint auch, dass die Bibliothek (zumindest in Bezug auf die Lesbarkeit) viel von der weit verbreiteten Verwendung neuer Produkte profitieren könnte, die nach 2011 zum Standard wurden. <br><br>  Daher sind die Probleme bei der Auswahl einer Referenzbibliothek für Diagrammanwendungen ab 2019 nicht so klar, wie wir es uns wünschen, und in den letzten 5 Jahren hat die Unsicherheit eher zugenommen als abgenommen. <br><br>  Diese Situation ist etwas traurig, da die Schaffung eines universellen Mechanismus, der BGL an sich ähnlich ist, eine Art intellektuelle Leistung ist, sowohl in Bezug auf die Kraft des Ansatzes als auch auf den Reichtum des Arsenals implementierter universeller Methoden (gut anderthalbhundert Single-Threaded und ein paar Dutzend verteilt). Die Bibliothek ist, soweit der Autor dieser Zeilen bekannt ist, immer noch nicht gleich. <br><br>  Derzeit erlaubt nur diese Bibliothek grundsätzlich, ohne Leistungseinbußen, strenge Vereinbarungen über die Darstellung von Daten und den Verlust der Kontrolle über die internen Mechanismen der Bibliothek selbst zu treffen, um Graphalgorithmen und Graphendarstellungen vollständig zu trennen, wobei letztere zusätzlich völlig unabhängig von der Darstellung von Metadaten sind, die mit Kanten und Eckpunkten verbunden sind ( Dies ist im Prinzip offensichtlich die korrekteste Vorgehensweise. <br><br>  Das Wort "grundlegend" wird hier aus einem bestimmten Grund verwendet.  In Anbetracht einer bestimmten Situation am Beispiel der bereits oben erwähnten langlebigen Klasse compress_sparse_row_graph können wir beispielsweise die folgenden Abweichungen von hohen Standards feststellen: <br><br><ol><li>  Der Operator [] für die Adjazenzliste und die Sparse-Matrix behandeln die internen und externen Eigenschaften von Kanten unterschiedlich (interne und gebündelte Eigenschaften): Die erste gibt nur externe Eigenschaften zurück (auf die nur mit property_map zugegriffen werden kann), die zweite gibt eine Rahmenstruktur-Eigenschaft zurück, die eine gemeinsame Liste von Eigenschaften enthält. </li><li>  Die Funktion get zum Abrufen des Kantenindex mithilfe von boost :: property_map &lt;compress_sparse_row_graph, boost :: edge_index_t&gt; :: type wurde in boost :: detail ausgeführt und nicht wie in allen anderen Fällen zum Boosten. </li></ol><br>  Schließlich blieb in der Vorlage compress_sparse_row_graph die Spezialisierung für das ungerichtete Diagramm (boost :: undirectedS) unerfüllt. <br><br>  In dieser Hinsicht ergeben sich bei Verwendung der Eigenschaft edge_index (Kanten-Seriennummer) zusätzliche Schwierigkeiten, da diese Eigenschaft für die Adjazenzliste explizit als intern festgelegt werden muss und als solche willkürlich geändert werden kann, für einen ungerichteten Graphen jedoch ihr Wert nicht von der Richtung abhängt wo die Rippe geht.  Bei einer dünn besetzten Matrix (immer gerichtet) handelt es sich um eine integrierte Konstante property_map einer speziellen Form (berechnet als Index in einem Array von Kanten).  Dementsprechend können sich die Werte für entgegenkommende Kanten (die einen ungerichteten Graphen darstellen) nicht ändern und sind immer unterschiedlich. <br><br>  All diese Diskrepanzen führen dazu, dass es unmöglich ist, beim Aufrufen algorithmischer Funktionen "einfach die Graphendarstellung durch eine äquivalente zu ersetzen", was den Hauptvorteil der Bibliothek erheblich untergräbt.  In der Praxis ist in solchen Fällen entweder eine übermäßige Codespezialisierung erforderlich oder deren Verarbeitung, um Elemente mit unterschiedlichem Verhalten auszuschließen, oder eine solche Anpassung von Diagrammvorlagen, damit sie sich mit unterschiedlichen Attributdefinitionen „identisch“ verhalten, oder schließlich das Entfernen einzelner Dateien aus der Bibliothek und die Erstellung "Persönliche Boost-Version." <br><br>  Zusätzlich können die folgenden, nicht so bedeutenden Unannehmlichkeiten festgestellt werden: <br><br><ul><li>  Die Abmessungen der internen Deskriptoren von Diagrammdarstellungen haben einen erheblichen Einfluss auf den Speicherverbrauch, der zum Speichern des Diagramms erforderlich ist, und wirken sich manchmal auf die Leistung der Algorithmen aus. <br><br>  In einigen Ansichten (der gleiche komprimierte_sparse_row_graph) können Sie diese Dimensionen steuern.  Andere (adjacency_list) haben keine solchen Parameter und verwenden immer 64-Bit-Ganzzahlen (normalerweise redundant), die nicht ersetzt werden können, ohne den Code zu ändern. <br></li><li>  Trotz der Tatsache, dass die Autoren der Bibliothek sehr, sehr viel vorsahen, wurden einige offensichtlich notwendige Grundelemente nicht in die Bibliothek aufgenommen.  Zum Beispiel gibt es keine Funktion wie reverse_edge, die eine Kanteninversion durchführt. <br><br>  Die Implementierung solcher Funktionen hängt natürlich von der Diagrammdarstellung ab: In diesem Fall kann sie durch einen trivialen Austausch von Elementen eines Paares, eine mehr oder weniger effiziente Suche nach Containern oder überhaupt nicht implementiert werden.  Für den Endbenutzer ist es schwierig, all diese Vielfalt von Optionen zu verstehen, zumal gemäß der Ideologie der Bibliothek die internen Mitglieder der Deskriptoren für ihn nicht von Interesse sein sollten. <br></li><li>  Ebenso fielen einige alles andere als wertlose Skripte aus der Bibliothek.  Sie können beispielsweise Kantenprädikate definieren, die filtered_graph verwenden, um ein ungerichtetes Diagramm in ein gerichtetes Diagramm umzuwandeln. Es gibt jedoch keine Möglichkeit, die Bibliothek auf diese Transformation aufmerksam zu machen.  Dementsprechend werden reguläre Algorithmen für gerichtete Graphen nicht mit einem solchen Objekt kompiliert, und Algorithmen für ungerichtete Graphen funktionieren nicht korrekt damit. <br><br>  Irgendwo in der Nachbarschaft gibt es das Thema der Unterstützung für technisch ungerichtete Diagramme, die an den Rändern eine Servicerichtungsmarkierung aufweisen.  Eine erhöhte Aufmerksamkeit für diese Ansicht kann jedoch auf die besondere Art der Aufgaben zurückzuführen sein, die der Autor löst, und das weit verbreitete Interesse an der Unterstützung solcher Objekte ist nicht offensichtlich. <br></li><li>  Was die reverse_edge-Funktion betrifft, die oben als Beispiel genommen wurde, gibt es überhaupt keine unglaubliche Option, dass die gewünschte Funktion irgendwo im Darm der Bibliothek vorhanden ist, aber aus irgendeinem Grund einen nicht offensichtlichen Namen erhalten hat.  Dies führt zu folgendem Problem, das auf den ersten Blick nicht schwerwiegend ist, aber die Arbeit mit komplexen Vorlagenbibliotheken erheblich verlangsamt (nicht nur BGL, obwohl es nach diesem Kriterium eindeutig zu den führenden gehört): Arbeiten mit umfangreichen Systemen implizit verwandter Funktionen ohne explizite Parametertypisierung und mit Die nicht offensichtliche Semantik der Verwendung (oft weniger transparent als durchdacht) ist physikalisch schwierig, und vorhandene Entwicklungsumgebungen bieten dem Entwickler keine Unterstützung dafür: <br><br> <abbr title="Danke, du hast sehr geholfen."><img src="https://habrastorage.org/webt/bn/ad/fq/bnadfqng3f4ryjrc8qkwaxtf78e.png"></abbr> <br><br>  In der Tat, automatische Assistenten: <br><br><ol><li>  In erster Linie für die OOP-Unterstützung konzipiert, wenn eine Reihe von Funktionen entsprechend ihrem Typ an das Objekt auf der rechten Seite gebunden ist.  Mit globalen Funktionen, die sich links von einem Typ befinden können (geschweige denn eine Reihe von Typen), helfen sie viel schlimmer, selbst wenn alle Typen bekannt sind. </li><li>  Sie sind lächerlich nicht einmal in der Lage, mit einfachen Vorlagen zu arbeiten.  Die vom Autor verwendete Version des visuellen Assistenten, der die Definition einer Vorlagenklasse mit Standardparametern vor sich hat, bietet die Möglichkeit, eine „Testsubstitution“ anzugeben, um einen Hinweis für die Klasse generieren zu können.  Wenn Sie sie treffen, passiert absolut nichts. </li><li>  Darüber hinaus sind sie weniger in der Lage, Metaprogramm-Qualifizierer zu verstehen, selbst die einfachsten wie enable_if. </li><li>  Über ein typisches Szenario: „Wir befinden uns in einer Vorlagenfunktion, die aus einer unbestimmten Anzahl unbestimmter Kettenlängen anderer Funktionen, einschließlich Vorlagenfunktionen, aufgerufen wird.“ Es ist unmöglich, ohne Tränen zu sprechen.  In diesem Fall bleibt vim wirklich der beste Freund des Programmierers. </li></ol><br>  Ein weiterer Aspekt derselben Situation kann anhand der ersten Zeile des in der vorherigen Abbildung gezeigten Codefragments veranschaulicht werden.  Der Leser wird gebeten, die Abfragen "Aktuelle Zeit erhöhen" und "Aktuelle Zeit CRT" zu beantworten und die Ergebnisse zu vergleichen.  Ja, boost :: date_time (jetzt teilweise auf std verschoben) ermöglicht es, viele komplexe Dinge korrekt auszuführen, während CRT es Ihnen ermöglicht, mehrere triviale Operationen falsch auszuführen, aber in alltäglichen Haushaltssituationen ist CRT unter allen Gesichtspunkten und polynomischen Gesichtspunkten bequemer Konstruktionen der Form posix_time :: second_clock :: local_time (ein sanftes Beispiel) neigen dazu, sich in Hieroglyphen zu verwandeln, die im Programm wandern.  Wenn Sie dem Entwickler den Zugriff auf die persönliche Bibliothek solcher Hieroglyphen entziehen, wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklungsgeschwindigkeit auf Null gesetzt</a> . <br><br>  Boost :: string_algo macht es möglich, alles mit Strings zu tun, aber ehrlich gesagt wird jede nicht ganz triviale Operation von einer Sitzung zum erneuten Lesen der Dokumentation begleitet, um die allgemeine Logik der Bibliothek, die Namen der Prädikate sowie eine separate Übung zum Herausfinden der Kompatibilität von Parametern zu aktualisieren.  Eine ähnliche Situation tritt bei Tokenisierungsoperationen in boost :: regexp auf, deren interne Logik fehlerfrei ist. <br><br>  Wenn eine solche Situation bei den am häufigsten verwendeten Bibliotheken auftritt, ist es nicht überraschend, dass BGL als spezialisiertere Bibliothek, in der beispielsweise make_property_map_function- und make_function_property_map-Funktionen vorhanden sind, die nicht miteinander in Beziehung stehen, sowie eine sakramentale Get-Funktion, die auf eine beliebige Funktion neu geladen wird Die Anzahl der Argumente jeglicher Art führt zu denselben Problemen, jedoch in hypertrophierter Form.  Ja, jede Aufgabe kann durch die get-Aufrufkette gelöst werden, aber leider löst nicht jede get-Kette dieses Problem. <br><br>  Das Lesen eines solchen Codes kann einfach und angenehm sein, es kann sogar wie eine Zusammenfassung eines formal geschriebenen Algorithmus in einer natürlichen Sprache aussehen, aber beim Schreiben ist die Unmöglichkeit, Wörter durch Synonyme usw. zu ersetzen, für eine echte untypisch. <br></li><li>  Im Allgemeinen kann man die banale, aber nicht weniger zutreffende Beobachtung nicht verfehlen, dass die Metaprogrammierung in C ++ immer noch buchstäblich auf Nebenwirkungen von Sprachwerkzeugen basiert, deren ursprünglicher Zweck anders war, und sogar auf den einfachsten Ideen auf der Grundlage von Infolgedessen ist die Metasprache schwer auszudrücken und zu lesen, und die Verknüpfung des Vorlagencodes mit dem archaischen System der enthaltenen Dateien erleichtert dem Entwickler das Leben nicht und verringert nicht die vom Compiler verarbeitete Codemenge. <br><br>  (Auf der anderen Seite bringen regelmäßige Updates für Boost und Standard viele nicht ganz triviale und oft äußerst nützliche Konstrukte und unerwartete Lösungen mit sich, die es wirklich ermöglichen, klareren und kompakteren Code zu geringeren Kosten zu schreiben. Der Strom neuer Produkte ist jedoch so breit, ungleich und schlecht strukturiert, dass der wichtigste Ergänzungen zur Standardbibliothek, auch solche offensichtlichen wie die Optionen / apply_visitor oder die unten genannten, wenn die konzeptionellen Vorteile ihrer Anwendung im Kontext eines bestimmten Projekts nicht relevant sind  Selbstverständlich können sie ohne die Hilfe eines glücklichen Ereignisses für lange Zeit unscharf werden, wenn Sie nicht einen erheblichen Teil der Arbeitszeit damit verbringen, neue Produkte direkt und nachdenklich zu verfolgen, nicht triviale Beispiele für ihre Verwendung zu studieren und mentale Versuche zu unternehmen, sie auf einen vorhandenen Code anzuwenden. um dieses Problem zu bewältigen - für jeweils fünf praktizierende C ++ - Programmierer ein C ++ - einen Theoretiker, der sich nur mit Fragen der Priorität neuer Produkte, ihrer Implementierung, beschäftigt  gen im Projekt und die selektive Bildung Praktiker.  Fazit: <s>Starten Sie keine C ++ - Projekte mit weniger Entwicklern</s> . <br></li><li>  Schließlich objektiv das schwerwiegendste Problem, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das bei der Arbeit mit BGL-Boilerplate-Code auftritt</a> .  Angenommen, wir verwenden einen Vorlagenalgorithmus, der eine Passage durch ein Diagramm erstellt und eine Darstellung von Diagramm G als Argument verwendet.  In einem typischen Fall hängt diese Darstellung von den Filtern ab, die den Eckpunkten und Kanten überlagert sind <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>F</mi><mi>v</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.524ex" height="2.419ex" viewBox="0 -780.1 1086.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgDQwdHG7COgc2elPui7Ibqrxt-gQ#MJMATHI-46" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgDQwdHG7COgc2elPui7Ibqrxt-gQ#MJMATHI-76" x="910" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>F</mi><mi>v</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-1"> F_v </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>F</mi><mi>e</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.493ex" height="2.419ex" viewBox="0 -780.1 1073.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgDQwdHG7COgc2elPui7Ibqrxt-gQ#MJMATHI-46" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgDQwdHG7COgc2elPui7Ibqrxt-gQ#MJMATHI-65" x="910" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>F</mi><mi>e</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-2"> F_e </script>  und Gewichtsschema <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.435ex" height="2.057ex" viewBox="0 -780.1 1048.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgDQwdHG7COgc2elPui7Ibqrxt-gQ#MJMATHI-57" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>W</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> W </script>  .  Um mit gefilterten Diagrammen arbeiten zu können, bietet BGL die oben erwähnte Vorlagenklasse filter_graph an. Die Art und Weise, wie das Gewichtsschema daran angehängt wird, liegt im Ermessen des Benutzers.  Funktoren vertreten <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>F</mi><mi>v</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.524ex" height="2.419ex" viewBox="0 -780.1 1086.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgDQwdHG7COgc2elPui7Ibqrxt-gQ#MJMATHI-46" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgDQwdHG7COgc2elPui7Ibqrxt-gQ#MJMATHI-76" x="910" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>F</mi><mi>v</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-4"> F_v </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>F</mi><mi>e</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.493ex" height="2.419ex" viewBox="0 -780.1 1073.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgDQwdHG7COgc2elPui7Ibqrxt-gQ#MJMATHI-46" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgDQwdHG7COgc2elPui7Ibqrxt-gQ#MJMATHI-65" x="910" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>F</mi><mi>e</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-5"> F_e </script>  und <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.435ex" height="2.057ex" viewBox="0 -780.1 1048.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgDQwdHG7COgc2elPui7Ibqrxt-gQ#MJMATHI-57" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>W</mi></math></span></span><script type="math/tex" id="MathJax-Element-6"> W </script>  kann mindestens die folgenden Ansichten enthalten: <br><br><ul><li>  Direkt ein Wrapper für eine Funktion, die ein Gewichtungsschema darstellt, und Prädikate, die Filter darstellen (langsam, ohne Initialisierungsverlust); </li><li>  Caches über diese Wrapper, Zuordnen von Kanten- / Knoten-Deskriptoren zu Kanten- / Knoten-Indizes, Adressieren einer Bitmap und eines Array von Werten (ohne Initialisierungsverlust, mit einer allmählichen Erhöhung der Geschwindigkeit, wie verwendet); </li><li>  Direkte Zuordnung von Knoten- / Kantendeskriptoren zu Arrays mit gefüllten Werten (erfordert eine Initialisierung, kann jedoch auf der Grundlage der vorherigen Darstellung erstellt werden; die Geschwindigkeit erreicht ihr Maximum). </li></ul><br>  Wenn dieser Algorithmus in einem traditionellen Stil geschrieben würde, würden drei Selektoren mit jeweils mindestens drei Zweigen in seinem Körper erscheinen (und die Notwendigkeit, den Körper anzupassen, wenn neue Darstellungen erscheinen).  Da jede Verzweigung im Hauptteil des Algorithmus, die beim Durchlaufen des Diagramms sehr oft ausgeführt wird, zu einem spürbaren Zeitverlust führt, kann der Wunsch, diese Verluste zu vermeiden und gleichzeitig den Code des gleichen traditionellen Stils beizubehalten, zu mehr als 27 Implementierungen des Algorithmus für verschiedene Kombinationen von Darstellungen führen. <br><br>  Der Metaprogrammstil sollte Sie vor diesen Problemen bewahren und es Ihnen ermöglichen, eine Metafunktion zu unterstützen, die den Algorithmus beschreibt, der implizit alle erforderlichen Implementierungen generiert (und möglicherweise auch einige und möglicherweise eine beträchtliche Menge an unnötigen Implementierungen, wenn die Laufzeitcodestrukturen de facto einige Typkombinationen nicht generieren). <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">      </a> ),        . <br><br>   ,  ,          inline-    ,           –O2.           -      (              1:3  1:5,           – <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  ,  ,  </a> ). <br><br>           ,    .               . ,    ( )     ,      «»  «»  .   ,       .       :    «»      «»  ,                 «» ,                 «» . <br><br>    ,         :    ,   100%         ,       ,   «»  . ( ,    ,     - ,   ,    , ,      ,  ). <br></li><li>         ,   ,     ,     .     C++   , -,  ,          . <br><br>   ,   ,    : <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_selector_fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type_a a, type_b b, ...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition_1(a, b, ...)) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> arg = get_type_1_obj(a, b, ...); run_calc(arg, a, b, ...); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition_1(a, b, ...)) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> arg = get_type_2_obj(a, b, ...); run_calc(arg, a, b, ...); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... }</code> </pre> <br>  Es kann mit der Variante &lt;...&gt; in etwa folgender Form etwas kompakter umgeschrieben werden: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_selector_fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type_a a, type_b b, ...)</span></span></span><span class="hljs-function"> </span></span>{ variant&lt;type_1, type_2, ...&gt; arg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition_1(a, b, ...)) { arg = get_type_1_obj(a, b, ...); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ... ... apply_visitor([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> arg_){run_calc(arg_, a, b, ...); }, arg); }</code> </pre><br>  Der Nachteil dieser Schreibweise ist die Notwendigkeit einer expliziten Aufzählung der Typen Typ_1, Typ_2, ... in der Variantendeklaration.  Diese Typen können umständlich sein, die Aufzeichnung mit declval / result_of_t kann nicht weniger umständlich sein. <br><br>  Wenn Sie any verwenden, müssen Sie keine Typen auflisten, aber es gibt keine Möglichkeit, einen analogen apply_visitor zu erhalten. <br><br>  Die Verwendung einer Vorlagenfunktion make_variant, mit der Sie Code des folgenden Typs schreiben können, bietet sich an: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> arg = make_variant ( bind(condition_1, a, b, ...), bind(get_type_1_obj, a, b, ...), bind(condition_2, a, b, ...), bind(get_type_2_obj, a, b, ...), ... );</code> </pre><br>  Aber die Heilung sieht nicht besser aus als die Krankheit. <br><br>  Im Allgemeinen gibt es eine typische Situation für die Metaprogrammierung in C ++, wenn Sie zum Ausdrücken einer sehr einfachen Idee ein ganzes Arsenal von Hilfswerkzeugen verwenden müssen, deren Ergebnis hinsichtlich Lesbarkeit und einfacher Aufzeichnung nicht sehr zufriedenstellend ist.  Im Wesentlichen möchte ich in der Lage sein, Folgendes zu schreiben: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   variant&lt;...&gt;      //  ,   : type_1, type_2 etc. variant&lt;auto...&gt; get_type_obj(typa_a a, type_b b, ...) { if (condition_1(a, b, ...)) { return get_type_1_obj(a, b, ...); } else if (condition_2(a, b, ...)) { return get_type_2_obj(a, b, ...); } else ... }</span></span></code> </pre><br>  oder sogar: <br><br><pre> <code class="cpp hljs"> select_value_type(arg) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition_1(a, b, ...)) { arg = get_type_1_obj(a, b, ...); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... ... } run_calc(arg, a, b, …);</code> </pre><br>  Die letztere Option sieht am praktischsten aus, obwohl sie vollständig aus dem C ++ - Stil entfernt wurde, da es mehr als eine Argumentvariable geben kann, für die der Typ ausgewählt ist, und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es keinen Grund gibt, die Logik ihrer Konstruktion vorwegzunehmen</a> . <br></li><li>  Die Kehrseite derselben Situation ist die Verwendung von Hilfsstrukturen (z. B. Caching), die ein Skript implementieren, das den Namen einer "Vorlagenvariablen" verdient, sich jedoch von der gleichnamigen C ++ 14-Standarderweiterung unterscheidet. <br><br>  Der entsprechende Code könnte ungefähr so ​​aussehen: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheHolder</span></span></span><span class="hljs-class"> {</span></span> boost::variant&lt; container&lt;T1&gt;, container&lt;T2&gt;, <span class="hljs-comment"><span class="hljs-comment">// ... container&lt;TN&gt;&gt; ct; template&lt;typename T&gt; struct result_type_selector { typedef typename if_c&lt;is_compatible&lt;T, T1&gt;::value, T1, if_c&lt;is_compatible&lt;T, T2&gt;::value, T2, // ... if_c&lt;is_compatible&lt;T, TN&gt;::value, TN, std::decay_t&lt;T&gt;&gt;&gt;&gt;::type type; }; template&lt;typename T&gt; auto get() const -&gt; const container&lt;typename result_type_selector&lt;T&gt;::type&gt;&amp; { return boost::get&lt;container&lt;typename result_type_selector&lt;T&gt;::type&gt;&gt;(ct); } };</span></span></code> </pre><br>  Wie oben drücken lange Konstruktionen die einfache Idee aus, auf eine Variable zuzugreifen, die den Cache unter einem bestimmten Namen darstellt, unabhängig von der Dimension des zwischengespeicherten Werts (transparenter Durchlauf des aufrufenden Codes). <br><br>  Der Kürze halber wird der Code für den Fall angegeben, dass nur ein Typ aktiv sein kann. In der Praxis ist die Situation jedoch häufiger, wenn mehrere Container gleichzeitig vorhanden sein können (er kann einfach mit Tupel und optional im selben Stil implementiert werden). <br><br>  Bei der Implementierung der Funktion get &lt;...&gt; wird davon ausgegangen, dass der aufrufende Code eine Vorstellung davon hat, auf welche Art von zwischengespeicherten Werten er zugreifen möchte (z. B. Ganzzahl oder Gleitkomma). <br><br>  Nicht weniger häufig ist die Situation, in der der genaue Typwert für den Anrufer nicht wichtig ist.  In diesem Fall wird das Skript select_value_type / apply_visitor aus dem vorherigen Absatz reproduziert (angepasst an die mögliche Vielzahl von Werten, was bedeutet, dass Typen in absteigender Reihenfolge der Priorität angezeigt werden). <br></li><li>  Bisher wurde PBGL in diesem Text praktisch nicht erwähnt.  Dies erklärt sich aus der verschwindend geringen Erfahrung des Autors mit der Arbeit mit diesem Teil der Bibliothek (in Verbindung damit bezieht sich der Autor selbst mit einer gewissen Skepsis auf alles, was unten in diesem Absatz geschrieben steht, und ruft andere dazu auf).  Tatsächlich läuft ein solches Experiment auf mehrere Experimente mit derselben Art von Suchproblemen hinaus, bei denen gezeigt wurde, dass praktische Daten eine verteilte Version 3-5 Mal im Speicher und 15-20 Mal in der Gesamtleistung an eine lokale Lösung verloren haben (der Ursprung dieser erschreckenden Zahl wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier erklärt</a> und in den folgenden Absätzen zusätzlich kommentiert). .  Angesichts der größeren Komplexität der Arbeit mit verteilten Strukturen war die Wahl der lokalen Version in einer solchen Situation selbstverständlich. <br><br>  Lassen Sie uns die Mechanik des PBGL-Betriebs anhand eines typischen Beispiels des Delta-Walking-Algorithmus erklären.  In dieser parallelen Version des Dijkstra-Algorithmus wird die Prioritätswarteschlange durch ein Array von "Buckets" ersetzt.  Elemente, die in einen "Bucket" fallen, werden parallel verarbeitet.  In seiner ursprünglichen Form ist die Delta-Stimulation ein typischer Algorithmus für Shared-Memory-Systeme. <br><br>  In der verteilten Version geschieht Folgendes: In PBGL wird der Graph beim Laden auf die Prozesse verteilt, und jeder Prozess verfügt über einen kontinuierlichen Bereich von Scheitelpunktnummern.  Anhand der globalen Scheitelpunktnummer ist es daher leicht zu erkennen, zu welchem ​​Prozess sie gehört.  Dementsprechend speichert jeder Prozess bei jeder Umdrehung des Algorithmus einen Teil des "Buckets", der die zu diesem Prozess gehörenden Eckpunkte enthält.  Alle Prozesse wählen gleichzeitig die Scheitelpunkte aus ihren Teilen der "Buckets" nacheinander aus und verarbeiten sie, während sie Nachrichten über die Notwendigkeit senden, die folgenden "Buckets" an Prozesse zu aktualisieren, die benachbarte Scheitelpunkte besitzen.  Es ist leicht zu erkennen, dass ceteris paribus eine Zunahme der Anzahl der Prozesse zu einer Zunahme der Anzahl der von ihnen gesendeten Nachrichten führt.  Infolgedessen kann die Ausführungszeit des Algorithmus nicht nur nicht verringert, sondern sogar erhöht werden.  Insbesondere der Start mehrerer MPI-Prozesse zur Lösung dieses Problems auf einer physischen Maschine mit einer bestimmten Wahrscheinlichkeit führt nur zu einer Erhöhung der Gesamtprozessorlast ohne Zeitgewinn. <br><br>  Es ist zu beachten, dass die Delta-Stimulation der am schnellsten verteilte Suchalgorithmus ist (von drei von der Bibliothek unterstützten). <br><br>  Wenn das Diagramm zuvor nicht erstellt wurde, sollte es in Blöcke maximaler Größe unterteilt werden, einen Block pro physischer Maschine.  Mit vorläufiger Vorbereitung meinen wir hier die Umnummerierung der Eckpunkte des Graphen, so dass die von PBGL verwendeten kontinuierlichen Zahlenbereiche, wenn möglich, lose verbundenen Untergraphen entsprechen.  Für diese Zwecke werden Pakete wie METIS, paraMETIS und Zoltan verwendet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Arbeiten mit dynamischen Diagrammen in diesem Modus ist schwierig.</a> <br><br>  Nach den Ergebnissen der beschriebenen Experimente hatte der Autor im Allgemeinen den Eindruck, dass ein normaler Betrieb des PBGL-Clusters nur mit speziellen Kommunikationsgeräten möglich ist, und es ist sinnvoll, Maschinen mit einer minimalen Anzahl von Kernen und maximaler Thread-Leistung als Knoten eines solchen Clusters zu verwenden.  Die Autoren von <a href="">Trinity</a> argumentieren in ihrem Artikel, dass ihr verteilter Speicher viel effizienter arbeitet - der Autor findet es schwierig, diese Aussage zu kommentieren, aber unter den oben genannten Umständen ist dies durchaus möglich: Die PBGL-Architektur trägt ein deutliches Siegel der Zeit, in der Mehrkernmaschinen noch keine breite Verbreitung erhalten haben. <br><br>  PBGL teilt auch die Probleme der Single-Threaded-Version: einige Codesynchronisierungen, Dokumentationen und Beispiele, die durch die größere Komplexität des Systems und weniger Benutzer, die bereit sind, nützliche Erfahrungen auszutauschen, noch verstärkt werden. <br></li></ul><br><h3>  BGL und andere Tiere </h3><br>  Angesichts einer ziemlich langen Liste spezifischer Beschwerden ist es nicht unangemessen zu fragen: Kann der Autor BGL für neue Projekte im Jahr 2019 empfehlen?  Die Antwort lautet: Der Autor glaubt, dass Bibliotheken dieses Stils und darauf basierende Anwendungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Zukunft haben müssen</a> .  Bei der Auswahl einer Referenzbibliothek für ein bestimmtes Projekt sollten wir die Instrumentierung ernsthaft in Betracht ziehen und die oben aufgeführten Probleme nicht aus den Augen verlieren.  Die Antwort hängt natürlich von vielen Umständen ab, einschließlich, aber nicht beschränkt auf die in den folgenden Absätzen aufgeführten: <br><br><ul><li>  Ob die Arbeit mit Diagrammen in einem Projekt die Grundlage für die Funktionalität oder eine optionale Aufgabe ist; </li><li>  Kann ein Projekt durch die Verwendung mehrerer Darstellungen einen Vorteil erzielen oder reicht die Arbeit mit hart typisierten Algorithmen völlig aus? </li><li>  Die vorteilhafteste Art der Parallelität für das Projekt; </li><li>  Organisatorische Nuancen: der Wunsch nach Metaprogrammierung in C ++ bei Mitarbeitern (insbesondere Mathematikprogrammierern) usw. </li></ul><br>  Wahrscheinlich, ceteris paribus, kann die Verwendung von BGL entweder im Fall einer sehr kleinen einmaligen Verwendung (zum Extrudieren oder Kopieren eines funktionierenden Codes und zum Vergessen) oder für ein großes System gerechtfertigt sein, für das eine erhöhte Flexibilität für hohe Eintritts- und andere Kosten im Laufe der Zeit bezahlt.  In anderen Fällen ist es sinnvoll, andere Optionen sorgfältig zu prüfen. <br><br>  Die Liste der möglichen Alternativen enthält mindestens die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">folgenden Elemente</a> : <br><div class="scrollable-table"><table><tbody><tr><td>  Titel </td><td>  Zitrone </td></tr><tr><td>  Art der Bibliothek </td><td>  C ++ - Vorlagenkopf </td></tr><tr><td>  URL </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">itrone.cs.elte.hu</a> </td></tr><tr><td>  Verteilt </td><td>  Nein </td></tr><tr><td>  Multithreaded </td><td>  Nein </td></tr><tr><td>  Betriebssystem </td><td>  beliebig </td></tr><tr><td>  Neueste Version </td><td>  2014 <br>  Vom Archiv verteilt </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stackoverflow erwähnt</a> </td><td>  ~ 100 (36 im Abschnitt [Zitronen-Graph-Bibliothek]) </td></tr><tr><td>  Kommentar </td><td>  Berichten zufolge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">übersteigt der Single-Threaded-Modus die Geschwindigkeit von BGL erheblich</a> . <br>  Die Einstellung der Autoren zum Multithreading <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geht aus dem folgenden Dialog hervor</a> .  In Anbetracht des Vorstehenden im Abschnitt über PBGL ist diese Position zweifelhaft. </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><td>  Titel </td><td>  SNAP </td></tr><tr><td>  Art der Bibliothek </td><td>  C ++ </td></tr><tr><td>  URL </td><td>  <a href="">github.com/snap-stanford/snap.git</a> </td></tr><tr><td>  Verteilt </td><td>  Nein </td></tr><tr><td>  Multithreaded </td><td>  ja (Teil der Methoden) </td></tr><tr><td>  Betriebssystem </td><td>  Linux, Mac, Cygwin </td></tr><tr><td>  Neueste Version </td><td>  2018 <br>  Das Repository wird aktiv aktualisiert. </td></tr><tr><td>  Stackoverflow erwähnt </td><td>  &lt;50 </td></tr><tr><td>  Kommentar </td><td>  Eine der größten (über 10 MB Code) Netzwerkanalysebibliotheken (Network Ananlysis), die seit vielen Jahren aktiv entwickelt wird.  Auf seltsame Weise wird es von der öffentlichen Aufmerksamkeit vergleichsweise ignoriert. <br>  Siehe die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschreibung der Ideologie des Systems</a> .  Die auf Seite 12 zum Ausdruck gebrachte Einstellung zur Implementierung paralleler Methoden kommt dem Autor dieses Artikels nahe.  Unter den Betriebsbedingungen eines typischen modernen Maschinenparks ist es das natürlichste.  Der Paradigmenwechsel fand im bedingten Jahr 2011 statt, auf das sich die obige LEMON-Erklärung bezieht. </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><td>  Titel </td><td>  MTGL </td></tr><tr><td>  Art der Bibliothek </td><td>  C ++ - Vorlagenkopf </td></tr><tr><td>  URL </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">software.sandia.gov/svn/public/mtgl/trunk</a> </td></tr><tr><td>  Verteilt </td><td>  ? </td></tr><tr><td>  Multithreaded </td><td>  ja </td></tr><tr><td>  Betriebssystem </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beliebig</a> </td></tr><tr><td>  Neueste Version </td><td>  ? </td></tr><tr><td>  Stackoverflow erwähnt </td><td>  3 </td></tr><tr><td>  Kommentar </td><td>  Geheimnisvolles Mitglied des Treffens.  Die Bibliothek wurde zwischen 2005 und 2012 aktiv weiterentwickelt.  Quellen wurden 2017 hochgeladen.  Status unklar, Erwähnung des Projekts von der Sandia-Website entfernt.  Ideologisch inspiriert von derselben BGL, aber der Code ist völlig unabhängig.  Die Gesamtmenge des Quellcodes (einschließlich zahlreicher Tests und Beispiele) erreicht 17 MB.  Der Code sieht gut aus.  Siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschreibung</a> . </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><td>  Titel </td><td>  igraph </td></tr><tr><td>  Art der Bibliothek </td><td>  C. </td></tr><tr><td>  URL </td><td>  <a href="">github.com/igraph/igraph.git</a> </td></tr><tr><td>  Verteilt </td><td>  Nein </td></tr><tr><td>  Multithreaded </td><td>  Nein </td></tr><tr><td>  Betriebssystem </td><td>  irgendwelche? </td></tr><tr><td>  Neueste Version </td><td>  2014 <br>  Das Repository wird aktiv aktualisiert. <br></td></tr><tr><td>  Stackoverflow erwähnt </td><td>  Ungefähr 100 in den Abschnitten [igraph] [c ++] und [igraph] [c] und insgesamt mehr als 500 (für alle Sprachen) <br></td></tr><tr><td>  Kommentar </td><td>  Eine andere Bibliothek der Netzwerkanalyse ist anscheinend sehr beliebt (hauptsächlich bei Pythonisten usw.).  Beschreibung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><td>  Titel </td><td>  Grafik-Tool </td></tr><tr><td>  Art der Bibliothek </td><td>  C ++ Python Lib </td></tr><tr><td>  URL </td><td>  <a href="">git.skewed.de/count0/graph-tool.git</a> </td></tr><tr><td>  Verteilt </td><td>  Nein </td></tr><tr><td>  Multithreaded </td><td>  ja </td></tr><tr><td>  Betriebssystem </td><td>  Nach der Verwendung von autoconf - * nix zu urteilen, ist jedoch eine einfache Anpassung an andere Systeme wahrscheinlich </td></tr><tr><td>  Neueste Version </td><td>  2019 </td></tr><tr><td>  Stackoverflow erwähnt </td><td>  &lt;20 </td></tr><tr><td>  Kommentar </td><td>  Eine weitere sich aktiv entwickelnde Netzwerkanalysebibliothek mit einer langen Geschichte von Commits, die direkt BGL verwendet (in der lokalen gepatchten Version). <br>  Siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistungsvergleichstabelle.</a> </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><td>  Titel </td><td>  LEDA </td></tr><tr><td>  Art der Bibliothek </td><td>  C ++ </td></tr><tr><td>  URL </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.algorithmic-solutions.com/index.php/products/leda-for-c</a> </td></tr><tr><td>  Verteilt </td><td>  Nein </td></tr><tr><td>  Multithreaded </td><td>  ? </td></tr><tr><td>  Betriebssystem </td><td>  beliebig </td></tr><tr><td>  Neueste Version </td><td>  ? </td></tr><tr><td>  Stackoverflow erwähnt </td><td>  ~ 10 </td></tr><tr><td>  Kommentar </td><td>  Kommerzielle Lizenz.  Eine große (und man könnte sagen alte) Bibliothek für wissenschaftliches und technologisches Rechnen, einschließlich eines Grafikabschnitts.  Anscheinend stützt es sich auf seine eigene Infrastruktur und nicht auf stl / boost und ist in diesem Sinne archaisch. </td></tr></tbody></table></div><br>  Von besonderem allgemeinem Interesse ist die Frage der Klassifizierung verschiedener Softwareprodukte, die auf die Arbeit mit Grafiken ausgerichtet sind.  Ihre Vielfalt, ganz zu schweigen von der Anzahl, ist sehr groß.  Ohne vorzugeben, die Klassifizierung vollständig (und sogar formal korrekt) zu sein, können wir jedoch versuchen, die folgenden wichtigen Bereiche bei der Entwicklung von Diagrammanwendungen hervorzuheben: <br><ol><li>  Graph DBMS (neo4j usw.). <br><br>  Systeme dieser Art konzentrieren sich auf die Durchführung von Transaktionsoperationen an großen (verteilten Platten-) Graphen.  Obwohl die API eines solchen Systems hoch entwickelt sein kann, ist die Geschwindigkeit der Ausführung der Graphalgorithmen selbst, soweit man beurteilen kann, nicht die erste Priorität.  Das System versucht möglicherweise nicht einmal, das gesamte Diagramm in den Speicher zu laden.  Für die Änderung und Durchquerung von Graphen werden deklarative Sprachen (SPARQL, Cypher, Gremlin) unterstützt.  Der Gewährleistung der Kontinuität mit herkömmlichen SQL-Systemen wird große Bedeutung beigemessen. </li><li>  Grafikerweiterungen von Big-Data-Verarbeitungssystemen, die im Map / Reduce-Paradigma (GraphX ​​in Spark, Pegasus und Giraph für Hadoop) und unabhängigen Clustersystemen ( <a href="">MS Trinity / MS Graph Engine</a> , GraphLab) arbeiten.  Die ersten, die Operationen an der Grafik ausführen, implementieren das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Pregel-</a> Modell (aber nicht nur es) und können für die Verwendung einschließlich massiver paralleler Rechenknoten konfiguriert werden.  Sowohl diese als auch andere können unter anderem als Grundlage für Unternehmenssoftwareprojekte verwendet werden. <br><br>  Obwohl die API solcher Systeme durchaus entwickelt werden kann (unter anderem unterstützt GraphX ​​SPARQL und Cypher), liegt der Schwerpunkt bei der Arbeit mit ihnen auf der Lösung von Infrastrukturproblemen.  GraphX ​​zeichnet sich durch Datenveränderlichkeit und eine Verzerrung im Pipelining aller Operationen aus.  MS Trinity enthält derzeit keine übergeordneten Methoden und bietet nur eine Reihe von Grundelementen für die Arbeit mit Knoten und Kanten.  Systeme, die auf Hadoop laufen, sind im Prinzip wenig nützlich, um beliebige Graphprobleme zu lösen. <br></li><li>  Tatsächlich universelle Werkzeugbibliotheken, die mehr oder weniger breite Methodensätze (BGL / PBGL, LEMON usw.) implementieren, einschließlich massiv paralleler (nvGraph, Gunrock). <br><br>  Darauf aufbauend können Anwendungssysteme erstellt werden, die Graphalgorithmen an bestimmte Themenbereiche anpassen. </li><li>  Systeme und Bibliotheken, die sich auf besonders komplexe Probleme von universeller Bedeutung spezialisiert haben (METIS, paraMETIS, Zoltran: Graphpartitionierung, GraphViz, Gephi: Visualisierung, GraphBLAS: algebraische Algorithmen für die Arbeit mit Graphen usw.). <br><br>  Viele unabhängige Grafikanwendungen können dieser Kategorie unter bestimmten Bedingungen zugeordnet werden, deren detaillierte Analyse zu viel Zeit in Anspruch nehmen würde.  Letzteres enthält Anwendungen aller denkbaren Arten: akademische und kommerzielle, Einzel- und Mehrbenutzeranwendungen, die vor kurzem erschienen sind und seit mehr als einem Jahrzehnt existieren usw. </li></ol><br>  Ein dunkler, aber bedeutender Teil der Grafikanwendungen konzentriert sich auf die Aufgaben der Netzwerkanalyse und bereits der Analyse sozialer Netzwerke (Community Detection).  Seltsamerweise sind Link-Analyse-Systeme (die in der Regel von verschiedenen "Verbrechensbekämpfern" verwendet werden), die einige Ähnlichkeiten mit dem von uns entwickelten System aufweisen, viel seltener.  In allen Fällen ist es ohne eine spezielle Prüfung schwierig, die Art der von verschiedenen Systemen verwendeten Datenmodelle und die damit verbundenen Leistungsbeschränkungen, unterstützten Volumes, Betriebsgruppen usw. zu bestimmen. <br><br><h3>  Anmerkungen </h3><br><ol><li><a name="P1"></a>  BGL ist keine reine Header-Bibliothek, aber im Moment muss nur mit GraphViz DOT-Dateien (eher optional) verknüpft werden.  Daher ist in den allermeisten Fällen keine Verknüpfung und automatische Verknüpfung mit der richtigen Version des Libbost-Diagramms erforderlich, um BGL-Header in die Boost-Konfiguration aufzunehmen.  Aus Gründen der Konsistenz mit der libboost-regex-Bibliothek, die von BGL-Funktionen ohne Header verwendet wird, ist es daher zweckmäßig, den Header boost \ regex.hpp einfach aus dem Projektcode einzufügen, auch wenn dieser keine regulären Ausdrücke verwendet. </li><li><a name="P2"></a>  Zusätzliches Chaos entsteht durch die Anwesenheit von Wesenheiten, deren offensichtliche Gleichwertigkeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Suche nach (möglicherweise abwesenden) schwarzen Katzen in dunklen Räumen fördert</a> . </li><li><a name="P3"></a>  Bevor wir mit seiner Beschreibung fortfahren (anhand eines bestimmten Beispiels, in dem es sich besonders stark und unangenehm manifestierte), stellen wir fest, dass der Autor zu den relativ wenigen glücklichen Menschen gehört, die mit einem geladenen Projekt in einem leistungsstarken Windows-Betriebssystem und der von Gott gespeicherten Reihe von MSVC-Compilern arbeiten.  Es ist möglich, dass die unten beschriebenen Probleme Artefakte dieser Compilerreihe sind: Eine Vielzahl besonderer Umstände erschwert die Durchführung eines Vergleichsexperiments mit gcc / clang in einer * nix-Umgebung.  In diesem Fall können Sie nur Benutzern anderer Compiler gratulieren. </li><li><a name="P4"></a>  Um zu mildern, was in einigen Fällen das kürzlich erschienene constexpr if wahrscheinlich helfen wird. </li><li><a name="P5"></a>  In unserem Fall führte dies zu einer besonderen Aufmerksamkeit für die Zustandsersparfunktion, die ein bequemes Debuggen ermöglicht und das System zunächst in einer optimierten Baugruppe in den gewünschten Ausgangszustand versetzt. </li><li><a name="P6"></a>  In meiner Praxis bestand aus verschiedenen Gründen die Notwendigkeit, Laufzeitparameter in Vorlagenargumente umzuwandeln, und ich musste ziemlich oft auf sehr genaue, sehr ausgefeilte Methoden zurückgreifen (inspiriert von den jetzt veralteten Implementierungen von Boost Typeof und Boost Lambda für C ++ 98, die direkt auf die Behandeln Sie die Programmiertechnik in C ++ als eine Lösung für den Rebus, unter der der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stern die Auswahl des Arguments durch Teilen in zwei Hälften</a> beleuchtet. Im Allgemeinen waren die Hauptprobleme bei solchen Operationen jedoch immer mit der Unfähigkeit zum Export verbunden  ausgewählter Typ außerhalb des Anwendungsbereichs, der zu exotischen Mustern führte. </li><li><a name="P6X1"></a>  Der oben angegebene zwanzigfache Geschwindigkeitsverlust (in absoluten Zahlen - etwa 80 Sekunden gegenüber 4 in einem Testrichtungsdiagramm mit 50 Millionen Eckpunkten und 200 Millionen Kanten, die als Adjazenzliste dargestellt sind) wurde in einem unvorbereiteten (zufällig unterbrochenen) Diagramm im Vergleich zur lokalen Version erhalten -   . ,                .    ,  6-8      —   ,        . </li><li><a name="P7"></a>        ,        . (  ,       -  ,      .  ,     ,  ,     ,  ,       , ,        ). </li><li><a name="P8"></a>   ,    ,    –   ,     ,   «»     (--  ..)     .  (  ,   ),    ,   «»    ,     —     (              ).  ,  ,      , -   .  ,    ,   : «»  (   )  ,     «» (   ),         ,     .           .         ,   - ,      «      »,      .        ,   «  »     ? ,        ,         ,   :  –    , ,       ,    ,          . </li><li><a name="P9"></a>    .         ,     ,             . </li><li><a name="P10"></a>    «LIBNAME C++ graph»  ,           stackoverflow.  ,  BGL   500    [boost-graph]. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471652/">https://habr.com/ru/post/de471652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471636/index.html">Unbemanntes Fahrzeug: Animationsalgorithmen. Yandex-Bericht</a></li>
<li><a href="../de471640/index.html">Ein Überblick über anonyme Blockchain-Analysetechniken</a></li>
<li><a href="../de471642/index.html">Zeitkiller von Kindheit an</a></li>
<li><a href="../de471644/index.html">Nochmals zu phpQuery</a></li>
<li><a href="../de471650/index.html">KI-Pizza: Wie wir zwei wiederkehrende neuronale Netze verwendet haben</a></li>
<li><a href="../de471654/index.html">Wie wir ein frostbeständiges Internet-of-Things-Gerät entwickelt haben</a></li>
<li><a href="../de471658/index.html">Telefonbetrüger. Die erste Aktion, bei der mir freundlicherweise von anderen Betrügern erzählt wird</a></li>
<li><a href="../de471660/index.html">Vorlesung über Spielerpsychologie</a></li>
<li><a href="../de471662/index.html">Web - Javascript - Authentifizierung, Verschleierung und nativer Code. Problemlösung mit r0ot-mi Web - Client. Teil 1</a></li>
<li><a href="../de471664/index.html">Praktikum bei ABBYY: ein Unternehmen, mit dem Sie „Sie“ sein können</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>