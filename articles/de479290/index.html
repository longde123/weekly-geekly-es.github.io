<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏿 👩🏽‍🏫 💅 Algorithmen zum Suchen des Volumens und des Massenschwerpunkts eines Polyeders 💝 🔃 👶🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wahrscheinlich kennt jeder diesen Algorithmus, aber "die Behörden haben sich vor mir versteckt". Ich fand seine verbale Beschreibung auf der dritten S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithmen zum Suchen des Volumens und des Massenschwerpunkts eines Polyeders</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479290/">  Wahrscheinlich kennt jeder diesen Algorithmus, aber "die Behörden haben sich vor mir versteckt".  Ich fand seine verbale Beschreibung auf der dritten Seite der Suchmaschine im Archiv der automatischen Übersetzungen des englischsprachigen Forums.  Es scheint mir, dass seine detaillierte Beschreibung (und mit dem Code) Habrosta verdient. <br><br>  So müssen Sie zum Beispiel Mobs für ein Spielzeug generieren und irgendwo im Prozess diejenigen ausmerzen, die nicht auf den Beinen stehen.  Um dies zu tun, müssen Sie den Massenschwerpunkt des Pöbels finden (und dies ist fast dasselbe wie das Volumen) und sicherstellen, dass er sich irgendwo über den Beinen des Pöbels befindet. <br><br><img src="https://habrastorage.org/webt/mg/o0/1j/mgo01jfkte64gkwjovk8xisnzsm.jpeg"><br><a name="habracut"></a><br>  Ein Mob ist ein Polyeder. Der Einfachheit halber glauben wir, dass ein Polyeder nur aus Dreiecken besteht (der Algorithmus enthält die <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D1%2583%25D0%25BB%25D0%25B0_%25D0%25BF%25D0%25BB%25D0%25BE%25D1%2589%25D0%25B0%25D0%25B4%25D0%25B8_%25D0%2593%25D0%25B0%25D1%2583%25D1%2581%25D1%2581%25D0%25B0" rel="nofollow">Gaußsche Flächenformel im</a> Inneren, sodass Sie sie für jedes Polyeder erweitern können, aber warum ...).  Darüber hinaus sollte das Polyeder keine Selbstüberschneidungen aufweisen und das geschlossene Volumen begrenzen, wie dies für anständige Polyeder angemessen ist. <br><br><img src="https://habrastorage.org/webt/xt/pl/lu/xtplludmrhnnpocxqv0ughwqilo.png"><br>  <i>(na so)</i> <br><br>  Ein kleines UPD, das erklärt, warum auf dem KDPV der rechte Mob nicht OK ist, aber der linke OK: <br>  Das richtige Bild ist nicht in Ordnung, weil der Mob nach vorne fallen wird, weil  Sein Massenschwerpunkt erstreckt sich über den Stützbereich hinaus.  Die Auflagefläche eines auf der Oberfläche stehenden Polygons ist definiert als das minimale Polygon, innerhalb dessen sich alle Punkte auf der Oberfläche befinden.  Im linken Fall ist der Bereich der Stütze zum Massenmittelpunkt und mehr verschoben (weil die Dinosaurierpfoten größer sind), und im rechten Bild ist der Bereich selbst kleiner und näher am Schwanz. <br>  Das Verhältnis der Referenzfläche zum Massenmittelpunkt ist ungefähr so: <br><img src="https://habrastorage.org/webt/gs/fz/x8/gsfzx8ju0ggexquycogdnpp-jwk.jpeg"><br><br>  Ich beginne sofort mit dem Volume-Suchcode (Python, Eingabe - eine Liste von Punkten und eine Übergangsmatrix): <br><br><div class="spoiler">  <b class="spoiler_title">etwas Code</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RecSetDirsTriangles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(para, Connects, TR)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ,           """</span></span> <span class="hljs-comment"><span class="hljs-comment">#1.   , ,     for i in range(0,len(Connects)): if i != para[0] and i != para[1] and Connects[i][para[0]] and Connects[i][para[1]]: #  ! fl = 1 for T in TR: if i in T and para[1] in T and para[0] in T: fl = 0 #    break if fl: # ! TR += [(para[1],para[0],i)] Recc((para[0], i) , Connects, TR) Recc((i, para[1]) , Connects, TR) def FindV(dots, Connects): """ .   - dots     [x, y, z], Connects -  , Connects[i][j]=1      i, j,  =0 """ #1.      TR = [] for i in range(1,len(Connects)):#        - if Connects[i][0]: for j in range(i+1, len(Connects)): if Connects[0][j] and Connects[i][j]: TR += [(0,i,j)] break RecSetDirsTriangles((0,i),Connects, TR) break print(" : ", len(TR)) #2.        V = 0 for T in TR: ''' : x1y2 x2y3 x3y1 x2y1 x3y2 x1y3''' S = 0.5 * (dots[T[0]][0]*dots[T[1]][1] + dots[T[1]][0]*dots[T[2]][1] + dots[T[2]][0]*dots[T[0]][1] - dots[T[1]][0]*dots[T[0]][1] - dots[T[2]][0]*dots[T[1]][1] - dots[T[0]][0]*dots[T[2]][1]) #S   +  -    ,    V += S*(dots[T[0]][2] + dots[T[1]][2] + dots[T[2]][2])/3 #    ... return math.fabs(V)</span></span></code> </pre> <br></div></div><br>  Die Essenz des Algorithmus besteht darin, die Volumen der Figuren zu betrachten, die die Flächen des Polyeders bilden, die auf die xy-Ebene "fallen".  Dazu müssen Sie die Projektionsfläche des Dreiecks und das Zeichen kennen, mit dem Sie das Volumen der Figur addieren (abgeschnittenes Prisma).  Wenn Dreiecke im Voraus bestellt werden, werden Volumen und Vorzeichen auf eine einzige Berechnung reduziert. <br><br>  Das erste, woraus eine rekursive Funktion Dreiecke sammelt, ist die Eingabe.  Wird so zusammengebaut, dass die Dreiecksrichtungen beim Blick nach außen auf ein Polyeder gleich sind (idealerweise gegen den Uhrzeigersinn; wenn Sie die Richtungen im Uhrzeigersinn nehmen, ist das Ergebnis korrekt, aber negativ - daher wird der Volumenmodul für den Rücklauf angegeben). <br><br>  Dies ist sehr einfach zu erreichen - nehmen Sie ein Dreieck (Punkte a1, a2, a3), suchen Sie nach seinen Nachbarn und listen Sie zwei übereinstimmende Eckpunkte in umgekehrter Reihenfolge auf (zum Beispiel so: a2, a1, b1). <br>  Es stellt sich so etwas heraus: <br><br><img src="https://habrastorage.org/webt/ar/-k/zv/ar-kzv2kd0qceid5m47na1xyvmi.png"><br><br>  Wenn wir nun ein solches Dreieck auf die xy-Ebene projizieren, stimmt die Traversalreihenfolge für die Projektion des „oberen“ Dreiecks mit der ursprünglich ausgewählten überein, und die Traversalreihenfolge für die Projektion des „unteren“ Dreiecks ändert seine Richtung.  Infolgedessen ändert sich das Vorzeichen und die Fläche dieses Dreiecks, berechnet nach der Gauß-Formel.  Das „untere“ Dreieck - ein bedingtes Konzept - bedeutet hier, dass das unmittelbar darunter liegende Volumen nicht im Volumen des Polyeders enthalten ist.  Das "untere" Dreieck eines nicht konvexen Polyeders kann höher sein als das "obere". <br><br>  Nach diesen vorbereitenden Schritten müssen Sie zur Berechnung des Gesamtvolumens des Polyeders (unter Berücksichtigung des Vorzeichens, das "von selbst" erhalten wird) nur alle Volumina der auf den Flächen und Projektionen dieser Flächen in der xy-Ebene gesammelten abgestumpften Prismen addieren.  Und die Volumina der Prismen werden als Produkt der Fläche (Gaußsch, mit Vorzeichen) und des arithmetischen Mittels der Z-Koordinaten der Eckpunkte des Dreiecks betrachtet. <br><br>  Wenn das Polyeder die xy-Ebene schneidet, heben sich bei der Berechnung des Volumens alle Vorzeichen auf und das Ergebnis bleibt korrekt (Sie müssen nur die Prismenhöhen ohne Modul angeben). <br><br><img src="https://habrastorage.org/webt/ll/lt/qk/llltqkv7v0i-r-i_50mzu0jqage.jpeg"><br>  <i>(irgendwie sieht das "obere" abgeschnittene Prisma so aus)</i> <br><br>  Bei der Suche nach dem Schwerpunkt ist alles in etwa gleich.  In ähnlicher Weise müssen wir die Massenschwerpunkte für jedes abgestumpfte Prisma finden und koordinativ zusammenfassen und mit dem Volumen des Prismas multiplizieren (es wird angenommen, dass die Masse gleichmäßig über das Volumen verteilt ist und eines durch ein anderes ersetzt werden kann).  Um den Massenschwerpunkt eines abgestumpften Prismas zu ermitteln, müssen die Massenschwerpunkte von zwei Tetraedern (+1 Funktion) und einem gewöhnlichen Prisma berechnet werden.  Der Algorithmus "verschlechtert sich auch nicht", wenn das Polyeder die xy-Ebene kreuzt (und hier könnte es sich um eine Reproduktion von Magritte handeln). <br><br><img src="https://habrastorage.org/webt/tm/cz/fm/tmczfmf_yneom5ureeng0eny85a.jpeg"><br>  <i>(Diese beiden rot und rot markierten Tetraeder bilden zusammen mit einem dreieckigen Prisma (unterhalb des roten Tetraeders) das gewünschte abgeschnittene Prisma. Wir müssen die Massen- und Volumenschwerpunkte aller drei Figuren finden. Die Bezeichnungen entsprechen in etwa den Bezeichnungen im Code.)</i> <br><br>  Code, der dies und das zählt: <br><br><div class="spoiler">  <b class="spoiler_title">ein bisschen mehr Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RecSetDirsTriangles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(para, Connects, TR)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#1.   , ,     for i in range(0,len(Connects)): if i != para[0] and i != para[1] and Connects[i][para[0]] and Connects[i][para[1]]: #  ! fl = 1 for T in TR: if i in T and para[1] in T and para[0] in T: fl = 0 break if fl: # ! TR += [(para[1],para[0],i)] Recc((para[0], i) , Connects, TR) Recc((i, para[1]) , Connects, TR) def TetrV(mas):#dot1, dot2, dot3, dot4): """   """ M = np.zeros((3,3),float) for i in range(1,4): for j in range(0,3): M[i-1][j] = mas[i][j] - mas[0][j] #print(M) return math.fabs(np.linalg.det(M)/6) def FindVandCM(dots, Connects): """     """ #1.      TR = [] for i in range(1,len(Connects)): #        - if Connects[i][0]: for j in range(i+1, len(Connects)): if Connects[0][j] and Connects[i][j]: TR += [(0,i,j)] break RecSetDirsTriangles((0,i),Connects, TR) break print(" : ", len(TR)) #2.   ,          V = 0 CM = [0, 0, 0] for T in TR: ''' : x1y2 x2y3 x3y1 x2y1 x3y2 x1y3''' S = 0.5 * (dots[T[0]][0]*dots[T[1]][1] + dots[T[1]][0]*dots[T[2]][1] + dots[T[2]][0]*dots[T[0]][1] - dots[T[1]][0]*dots[T[0]][1] - dots[T[2]][0]*dots[T[1]][1] - dots[T[0]][0]*dots[T[2]][1]) #S   +  -    ,    V += S*(dots[T[0]][2] + dots[T[1]][2] + dots[T[2]][2])/3 #    ... #c        c1 = ((dots[T[0]][0] + dots[T[1]][0] + dots[T[2]][0])/3, (dots[T[0]][1]+ dots[T[1]][1]+ dots[T[2]][1])/3) #    hm = min([dots[T[0]][2] , dots[T[1]][2] , dots[T[2]][2]]) hM = max([dots[T[0]][2] , dots[T[1]][2] , dots[T[2]][2]]) indM = [dots[T[0]][2] , dots[T[1]][2] , dots[T[2]][2]].index(hM) indm = [dots[T[0]][2] , dots[T[1]][2] , dots[T[2]][2]].index(hm) V3 = S * hm if indM == indm: # ! CM[0] += V3*c1[0] CM[1] += V3*c1[1] CM[2] += V3*hm/2 continue L = [0,1,2] L.remove(indM) L.remove(indm) indmidle = L[0] dots1 = [dots[T[0]], dots[T[1]], dots[T[2]], (dots[T[indM]][0], dots[T[indM]][1] , hm)] #  V1 = TetrV(dots1) if S &lt; 0: V1 = -V1 V2 = S * ( dots[T[indmidle]][2] - hm)/3 #V3 = S * hm CM[0] += V1*((dots[T[0]][0] + dots[T[1]][0] + dots[T[2]][0] + dots[T[indM]][0])/4) + V2*((dots[T[0]][0] + dots[T[1]][0] + dots[T[2]][0] + dots[T[indmidle]][0])/4) + V3*c1[0] CM[1] += V1*((dots[T[0]][1] + dots[T[1]][1] + dots[T[2]][1] + dots[T[indM]][1])/4) + V2*((dots[T[0]][1] + dots[T[1]][1] + dots[T[2]][1] + dots[T[indmidle]][1])/4) + V3*c1[1] CM[2] += V1*((dots[T[0]][2] + dots[T[1]][2] + dots[T[2]][2] + hm)/4) + V2*((dots[T[0]][2] + dots[T[1]][2] + dots[T[2]][2] + hm)/4) + V3*hm/2 CM[0] = CM[0]/V CM[1] = CM[1]/V CM[2] = CM[2]/V return (math.fabs(V), CM)</span></span></code> </pre><br></div></div><br>  Ein Teil des Algorithmus, bei dem die Richtungen der Dreiecke berücksichtigt und zum Verstehen des externen und internen Volumens verwendet werden, ist ein sehr wichtiger Schritt. Er kann häufig verwendet werden, wenn Sie mit Polyedern arbeiten.  Wenn Sie zum Beispiel die Richtung der Normalen "aus" berechnen müssen, ist es ausreichend, die Richtung "gegen den Uhrzeigersinn" für ein Gesicht zu kennen - und voila! <br><br><img src="https://habrastorage.org/webt/hz/rh/3y/hzrh3yrdahhv8ei7gvmxsutzprc.jpeg"><br>  <i>(Errate den Film!)</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479290/">https://habr.com/ru/post/de479290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479278/index.html">Einhundert bis fünfhundert Ziffern der Zahl pi auf dem Knie</a></li>
<li><a href="../de479282/index.html">Wenn die Daten nicht in den Speicher passen. Einfachste Methoden</a></li>
<li><a href="../de479284/index.html">Das Haus, das der Roboter gebaut hat</a></li>
<li><a href="../de479286/index.html">Schreiben einer einfachen Webanwendung mit Spring MVC, Spring Data JPA und Hibernate</a></li>
<li><a href="../de479288/index.html">Warum Service Desk implementieren und wie Sie eine Lösung für Ihr Unternehmen auswählen</a></li>
<li><a href="../de479292/index.html">Wie man ein neuronales Netzwerk lehrt, um die Spielphysik zu reproduzieren</a></li>
<li><a href="../de479294/index.html">GitLab 12.5 wurde mit der Erstellung von EKS-Clustern und dem Environment Panel veröffentlicht</a></li>
<li><a href="../de479296/index.html">Wie ich aufhörte zu hassen und mich in die Entwicklung verliebte</a></li>
<li><a href="../de479298/index.html">PostgreSQL-Antimuster: CTE x CTE</a></li>
<li><a href="../de479300/index.html">Ökologie und Rechenzentren. Wie in Russland und im Ausland "grüne Daten"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>