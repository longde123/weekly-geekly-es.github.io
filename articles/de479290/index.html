<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèø üë©üèΩ‚Äçüè´ üíÖ Algorithmen zum Suchen des Volumens und des Massenschwerpunkts eines Polyeders üíù üîÉ üë∂üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wahrscheinlich kennt jeder diesen Algorithmus, aber "die Beh√∂rden haben sich vor mir versteckt". Ich fand seine verbale Beschreibung auf der dritten S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithmen zum Suchen des Volumens und des Massenschwerpunkts eines Polyeders</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479290/">  Wahrscheinlich kennt jeder diesen Algorithmus, aber "die Beh√∂rden haben sich vor mir versteckt".  Ich fand seine verbale Beschreibung auf der dritten Seite der Suchmaschine im Archiv der automatischen √úbersetzungen des englischsprachigen Forums.  Es scheint mir, dass seine detaillierte Beschreibung (und mit dem Code) Habrosta verdient. <br><br>  So m√ºssen Sie zum Beispiel Mobs f√ºr ein Spielzeug generieren und irgendwo im Prozess diejenigen ausmerzen, die nicht auf den Beinen stehen.  Um dies zu tun, m√ºssen Sie den Massenschwerpunkt des P√∂bels finden (und dies ist fast dasselbe wie das Volumen) und sicherstellen, dass er sich irgendwo √ºber den Beinen des P√∂bels befindet. <br><br><img src="https://habrastorage.org/webt/mg/o0/1j/mgo01jfkte64gkwjovk8xisnzsm.jpeg"><br><a name="habracut"></a><br>  Ein Mob ist ein Polyeder. Der Einfachheit halber glauben wir, dass ein Polyeder nur aus Dreiecken besteht (der Algorithmus enth√§lt die <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D1%2583%25D0%25BB%25D0%25B0_%25D0%25BF%25D0%25BB%25D0%25BE%25D1%2589%25D0%25B0%25D0%25B4%25D0%25B8_%25D0%2593%25D0%25B0%25D1%2583%25D1%2581%25D1%2581%25D0%25B0" rel="nofollow">Gau√üsche Fl√§chenformel im</a> Inneren, sodass Sie sie f√ºr jedes Polyeder erweitern k√∂nnen, aber warum ...).  Dar√ºber hinaus sollte das Polyeder keine Selbst√ºberschneidungen aufweisen und das geschlossene Volumen begrenzen, wie dies f√ºr anst√§ndige Polyeder angemessen ist. <br><br><img src="https://habrastorage.org/webt/xt/pl/lu/xtplludmrhnnpocxqv0ughwqilo.png"><br>  <i>(na so)</i> <br><br>  Ein kleines UPD, das erkl√§rt, warum auf dem KDPV der rechte Mob nicht OK ist, aber der linke OK: <br>  Das richtige Bild ist nicht in Ordnung, weil der Mob nach vorne fallen wird, weil  Sein Massenschwerpunkt erstreckt sich √ºber den St√ºtzbereich hinaus.  Die Auflagefl√§che eines auf der Oberfl√§che stehenden Polygons ist definiert als das minimale Polygon, innerhalb dessen sich alle Punkte auf der Oberfl√§che befinden.  Im linken Fall ist der Bereich der St√ºtze zum Massenmittelpunkt und mehr verschoben (weil die Dinosaurierpfoten gr√∂√üer sind), und im rechten Bild ist der Bereich selbst kleiner und n√§her am Schwanz. <br>  Das Verh√§ltnis der Referenzfl√§che zum Massenmittelpunkt ist ungef√§hr so: <br><img src="https://habrastorage.org/webt/gs/fz/x8/gsfzx8ju0ggexquycogdnpp-jwk.jpeg"><br><br>  Ich beginne sofort mit dem Volume-Suchcode (Python, Eingabe - eine Liste von Punkten und eine √úbergangsmatrix): <br><br><div class="spoiler">  <b class="spoiler_title">etwas Code</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RecSetDirsTriangles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(para, Connects, TR)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ,           """</span></span> <span class="hljs-comment"><span class="hljs-comment">#1.   , ,     for i in range(0,len(Connects)): if i != para[0] and i != para[1] and Connects[i][para[0]] and Connects[i][para[1]]: #  ! fl = 1 for T in TR: if i in T and para[1] in T and para[0] in T: fl = 0 #    break if fl: # ! TR += [(para[1],para[0],i)] Recc((para[0], i) , Connects, TR) Recc((i, para[1]) , Connects, TR) def FindV(dots, Connects): """ .   - dots     [x, y, z], Connects -  , Connects[i][j]=1      i, j,  =0 """ #1.      TR = [] for i in range(1,len(Connects)):#        - if Connects[i][0]: for j in range(i+1, len(Connects)): if Connects[0][j] and Connects[i][j]: TR += [(0,i,j)] break RecSetDirsTriangles((0,i),Connects, TR) break print(" : ", len(TR)) #2.        V = 0 for T in TR: ''' : x1y2 x2y3 x3y1 x2y1 x3y2 x1y3''' S = 0.5 * (dots[T[0]][0]*dots[T[1]][1] + dots[T[1]][0]*dots[T[2]][1] + dots[T[2]][0]*dots[T[0]][1] - dots[T[1]][0]*dots[T[0]][1] - dots[T[2]][0]*dots[T[1]][1] - dots[T[0]][0]*dots[T[2]][1]) #S   +  -    ,    V += S*(dots[T[0]][2] + dots[T[1]][2] + dots[T[2]][2])/3 #    ... return math.fabs(V)</span></span></code> </pre> <br></div></div><br>  Die Essenz des Algorithmus besteht darin, die Volumen der Figuren zu betrachten, die die Fl√§chen des Polyeders bilden, die auf die xy-Ebene "fallen".  Dazu m√ºssen Sie die Projektionsfl√§che des Dreiecks und das Zeichen kennen, mit dem Sie das Volumen der Figur addieren (abgeschnittenes Prisma).  Wenn Dreiecke im Voraus bestellt werden, werden Volumen und Vorzeichen auf eine einzige Berechnung reduziert. <br><br>  Das erste, woraus eine rekursive Funktion Dreiecke sammelt, ist die Eingabe.  Wird so zusammengebaut, dass die Dreiecksrichtungen beim Blick nach au√üen auf ein Polyeder gleich sind (idealerweise gegen den Uhrzeigersinn; wenn Sie die Richtungen im Uhrzeigersinn nehmen, ist das Ergebnis korrekt, aber negativ - daher wird der Volumenmodul f√ºr den R√ºcklauf angegeben). <br><br>  Dies ist sehr einfach zu erreichen - nehmen Sie ein Dreieck (Punkte a1, a2, a3), suchen Sie nach seinen Nachbarn und listen Sie zwei √ºbereinstimmende Eckpunkte in umgekehrter Reihenfolge auf (zum Beispiel so: a2, a1, b1). <br>  Es stellt sich so etwas heraus: <br><br><img src="https://habrastorage.org/webt/ar/-k/zv/ar-kzv2kd0qceid5m47na1xyvmi.png"><br><br>  Wenn wir nun ein solches Dreieck auf die xy-Ebene projizieren, stimmt die Traversalreihenfolge f√ºr die Projektion des ‚Äûoberen‚Äú Dreiecks mit der urspr√ºnglich ausgew√§hlten √ºberein, und die Traversalreihenfolge f√ºr die Projektion des ‚Äûunteren‚Äú Dreiecks √§ndert seine Richtung.  Infolgedessen √§ndert sich das Vorzeichen und die Fl√§che dieses Dreiecks, berechnet nach der Gau√ü-Formel.  Das ‚Äûuntere‚Äú Dreieck - ein bedingtes Konzept - bedeutet hier, dass das unmittelbar darunter liegende Volumen nicht im Volumen des Polyeders enthalten ist.  Das "untere" Dreieck eines nicht konvexen Polyeders kann h√∂her sein als das "obere". <br><br>  Nach diesen vorbereitenden Schritten m√ºssen Sie zur Berechnung des Gesamtvolumens des Polyeders (unter Ber√ºcksichtigung des Vorzeichens, das "von selbst" erhalten wird) nur alle Volumina der auf den Fl√§chen und Projektionen dieser Fl√§chen in der xy-Ebene gesammelten abgestumpften Prismen addieren.  Und die Volumina der Prismen werden als Produkt der Fl√§che (Gau√üsch, mit Vorzeichen) und des arithmetischen Mittels der Z-Koordinaten der Eckpunkte des Dreiecks betrachtet. <br><br>  Wenn das Polyeder die xy-Ebene schneidet, heben sich bei der Berechnung des Volumens alle Vorzeichen auf und das Ergebnis bleibt korrekt (Sie m√ºssen nur die Prismenh√∂hen ohne Modul angeben). <br><br><img src="https://habrastorage.org/webt/ll/lt/qk/llltqkv7v0i-r-i_50mzu0jqage.jpeg"><br>  <i>(irgendwie sieht das "obere" abgeschnittene Prisma so aus)</i> <br><br>  Bei der Suche nach dem Schwerpunkt ist alles in etwa gleich.  In √§hnlicher Weise m√ºssen wir die Massenschwerpunkte f√ºr jedes abgestumpfte Prisma finden und koordinativ zusammenfassen und mit dem Volumen des Prismas multiplizieren (es wird angenommen, dass die Masse gleichm√§√üig √ºber das Volumen verteilt ist und eines durch ein anderes ersetzt werden kann).  Um den Massenschwerpunkt eines abgestumpften Prismas zu ermitteln, m√ºssen die Massenschwerpunkte von zwei Tetraedern (+1 Funktion) und einem gew√∂hnlichen Prisma berechnet werden.  Der Algorithmus "verschlechtert sich auch nicht", wenn das Polyeder die xy-Ebene kreuzt (und hier k√∂nnte es sich um eine Reproduktion von Magritte handeln). <br><br><img src="https://habrastorage.org/webt/tm/cz/fm/tmczfmf_yneom5ureeng0eny85a.jpeg"><br>  <i>(Diese beiden rot und rot markierten Tetraeder bilden zusammen mit einem dreieckigen Prisma (unterhalb des roten Tetraeders) das gew√ºnschte abgeschnittene Prisma. Wir m√ºssen die Massen- und Volumenschwerpunkte aller drei Figuren finden. Die Bezeichnungen entsprechen in etwa den Bezeichnungen im Code.)</i> <br><br>  Code, der dies und das z√§hlt: <br><br><div class="spoiler">  <b class="spoiler_title">ein bisschen mehr Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RecSetDirsTriangles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(para, Connects, TR)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#1.   , ,     for i in range(0,len(Connects)): if i != para[0] and i != para[1] and Connects[i][para[0]] and Connects[i][para[1]]: #  ! fl = 1 for T in TR: if i in T and para[1] in T and para[0] in T: fl = 0 break if fl: # ! TR += [(para[1],para[0],i)] Recc((para[0], i) , Connects, TR) Recc((i, para[1]) , Connects, TR) def TetrV(mas):#dot1, dot2, dot3, dot4): """   """ M = np.zeros((3,3),float) for i in range(1,4): for j in range(0,3): M[i-1][j] = mas[i][j] - mas[0][j] #print(M) return math.fabs(np.linalg.det(M)/6) def FindVandCM(dots, Connects): """     """ #1.      TR = [] for i in range(1,len(Connects)): #        - if Connects[i][0]: for j in range(i+1, len(Connects)): if Connects[0][j] and Connects[i][j]: TR += [(0,i,j)] break RecSetDirsTriangles((0,i),Connects, TR) break print(" : ", len(TR)) #2.   ,          V = 0 CM = [0, 0, 0] for T in TR: ''' : x1y2 x2y3 x3y1 x2y1 x3y2 x1y3''' S = 0.5 * (dots[T[0]][0]*dots[T[1]][1] + dots[T[1]][0]*dots[T[2]][1] + dots[T[2]][0]*dots[T[0]][1] - dots[T[1]][0]*dots[T[0]][1] - dots[T[2]][0]*dots[T[1]][1] - dots[T[0]][0]*dots[T[2]][1]) #S   +  -    ,    V += S*(dots[T[0]][2] + dots[T[1]][2] + dots[T[2]][2])/3 #    ... #c        c1 = ((dots[T[0]][0] + dots[T[1]][0] + dots[T[2]][0])/3, (dots[T[0]][1]+ dots[T[1]][1]+ dots[T[2]][1])/3) #    hm = min([dots[T[0]][2] , dots[T[1]][2] , dots[T[2]][2]]) hM = max([dots[T[0]][2] , dots[T[1]][2] , dots[T[2]][2]]) indM = [dots[T[0]][2] , dots[T[1]][2] , dots[T[2]][2]].index(hM) indm = [dots[T[0]][2] , dots[T[1]][2] , dots[T[2]][2]].index(hm) V3 = S * hm if indM == indm: # ! CM[0] += V3*c1[0] CM[1] += V3*c1[1] CM[2] += V3*hm/2 continue L = [0,1,2] L.remove(indM) L.remove(indm) indmidle = L[0] dots1 = [dots[T[0]], dots[T[1]], dots[T[2]], (dots[T[indM]][0], dots[T[indM]][1] , hm)] #  V1 = TetrV(dots1) if S &lt; 0: V1 = -V1 V2 = S * ( dots[T[indmidle]][2] - hm)/3 #V3 = S * hm CM[0] += V1*((dots[T[0]][0] + dots[T[1]][0] + dots[T[2]][0] + dots[T[indM]][0])/4) + V2*((dots[T[0]][0] + dots[T[1]][0] + dots[T[2]][0] + dots[T[indmidle]][0])/4) + V3*c1[0] CM[1] += V1*((dots[T[0]][1] + dots[T[1]][1] + dots[T[2]][1] + dots[T[indM]][1])/4) + V2*((dots[T[0]][1] + dots[T[1]][1] + dots[T[2]][1] + dots[T[indmidle]][1])/4) + V3*c1[1] CM[2] += V1*((dots[T[0]][2] + dots[T[1]][2] + dots[T[2]][2] + hm)/4) + V2*((dots[T[0]][2] + dots[T[1]][2] + dots[T[2]][2] + hm)/4) + V3*hm/2 CM[0] = CM[0]/V CM[1] = CM[1]/V CM[2] = CM[2]/V return (math.fabs(V), CM)</span></span></code> </pre><br></div></div><br>  Ein Teil des Algorithmus, bei dem die Richtungen der Dreiecke ber√ºcksichtigt und zum Verstehen des externen und internen Volumens verwendet werden, ist ein sehr wichtiger Schritt. Er kann h√§ufig verwendet werden, wenn Sie mit Polyedern arbeiten.  Wenn Sie zum Beispiel die Richtung der Normalen "aus" berechnen m√ºssen, ist es ausreichend, die Richtung "gegen den Uhrzeigersinn" f√ºr ein Gesicht zu kennen - und voila! <br><br><img src="https://habrastorage.org/webt/hz/rh/3y/hzrh3yrdahhv8ei7gvmxsutzprc.jpeg"><br>  <i>(Errate den Film!)</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479290/">https://habr.com/ru/post/de479290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479278/index.html">Einhundert bis f√ºnfhundert Ziffern der Zahl pi auf dem Knie</a></li>
<li><a href="../de479282/index.html">Wenn die Daten nicht in den Speicher passen. Einfachste Methoden</a></li>
<li><a href="../de479284/index.html">Das Haus, das der Roboter gebaut hat</a></li>
<li><a href="../de479286/index.html">Schreiben einer einfachen Webanwendung mit Spring MVC, Spring Data JPA und Hibernate</a></li>
<li><a href="../de479288/index.html">Warum Service Desk implementieren und wie Sie eine L√∂sung f√ºr Ihr Unternehmen ausw√§hlen</a></li>
<li><a href="../de479292/index.html">Wie man ein neuronales Netzwerk lehrt, um die Spielphysik zu reproduzieren</a></li>
<li><a href="../de479294/index.html">GitLab 12.5 wurde mit der Erstellung von EKS-Clustern und dem Environment Panel ver√∂ffentlicht</a></li>
<li><a href="../de479296/index.html">Wie ich aufh√∂rte zu hassen und mich in die Entwicklung verliebte</a></li>
<li><a href="../de479298/index.html">PostgreSQL-Antimuster: CTE x CTE</a></li>
<li><a href="../de479300/index.html">√ñkologie und Rechenzentren. Wie in Russland und im Ausland "gr√ºne Daten"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>