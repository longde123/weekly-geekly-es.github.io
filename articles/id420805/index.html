<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•§ ğŸ¤·ğŸ¼ ğŸ‘­ [Terjemahan] Kapan harus menggunakan aliran paralel ğŸ‘¨ğŸ¿â€ğŸ”¬ ğŸ§œğŸ» â†©ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sumber 
 Penulis: Doug Lea bersama Brian Goetz, Paul Sandoz, Alexei Shipilev, Heinz Kabutz, Joe Bowbeer, ... 

 Kerangka java.util.streams berisi oper...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[Terjemahan] Kapan harus menggunakan aliran paralel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420805/"><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> <br>  Penulis: Doug Lea bersama Brian Goetz, Paul Sandoz, Alexei Shipilev, Heinz Kabutz, Joe Bowbeer, ... </blockquote><p> Kerangka <code>java.util.streams</code> berisi operasi berbasis data pada koleksi dan sumber data lainnya.  Sebagian besar metode streaming melakukan operasi yang sama pada setiap elemen.  Menggunakan metode pengumpulan <code>parallelStream()</code> , jika Anda memiliki banyak inti, Anda dapat mengubah <em>data-driven</em> menjadi <em>data-paralel</em> .  Tetapi kapan itu layak dilakukan? </p><a name="habracut"></a><br><p>  Pertimbangkan untuk menggunakan <code>S.parallelStream().operation(F)</code> alih-alih <code>S.stream().operation(F)</code> , dengan ketentuan bahwa operasi tersebut independen satu sama lain dan mahal secara komputasi atau diterapkan pada sejumlah besar elemen yang secara efektif dipecah (splittable) struktur data, atau keduanya.  Lebih tepatnya: </p><br><ul><li>  <code>F</code> : fungsi untuk bekerja dengan satu elemen, biasanya lambda, independen, mis.  operasi pada salah satu elemen bersifat independen dan tidak mempengaruhi operasi pada elemen lain (untuk rekomendasi tentang penggunaan fungsi stateless yang tidak mengganggu, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi untuk paket <em>stream</em></a> ). </li><li>  <code>S</code> : Koleksi asli dibagi secara efektif.  Selain koleksi, ada yang lain yang cocok untuk paralelisasi, streaming sumber data, misalnya, <code>java.util.SplittableRandom</code> (untuk paralelisasi yang Anda dapat menggunakan metode <code>stream.parallel()</code> ).  Tetapi sebagian besar sumber dengan I / O pada intinya dirancang terutama untuk operasi berurutan. </li><li>  Total run time dalam mode berurutan melebihi batas minimum yang diijinkan.  Hari ini, untuk sebagian besar platform, batasnya kira-kira sama (dalam x10) hingga 100 mikrodetik.  Pengukuran yang akurat, dalam hal ini, tidak diperlukan.  Untuk tujuan praktis, cukup dengan mengalikan <code>N</code> (jumlah elemen) dengan <code>Q</code> (waktu operasi satu <code>F</code> ), dan <code>Q</code> dapat diperkirakan kira-kira dengan jumlah operasi atau jumlah baris kode.  Setelah itu, Anda perlu memeriksa bahwa <code>N * Q</code> setidaknya kurang dari <code>10000</code> (jika Anda malu, tambahkan satu atau beberapa nol).  Jadi, jika <code>F</code> adalah fungsi kecil seperti <code>x -&gt; x + 1</code> , maka eksekusi paralel akan masuk akal ketika <code>N &gt;= 10000</code> .  Sebaliknya, jika <code>F</code> adalah perhitungan yang berbobot, mirip dengan menemukan langkah terbaik berikutnya dalam permainan catur, maka nilai <code>Q</code> begitu besar sehingga <code>N</code> dapat diabaikan, tetapi sampai koleksinya benar-benar terpecah. </li></ul><br><p>  Kerangka pemrosesan streaming tidak akan (dan tidak bisa) bersikeras pada salah satu di atas.  Jika perhitungannya saling tergantung, maka eksekusi paralelnya tidak masuk akal, atau akan berbahaya sama sekali dan menyebabkan kesalahan.  Kriteria lain yang berasal dari masalah teknik dan pengorbanan di atas termasuk: </p><br><ul><li>  <em>Start-up</em> <br>  Munculnya core tambahan dalam prosesor, dalam banyak kasus, disertai dengan penambahan mekanisme manajemen daya, yang dapat menyebabkan perlambatan dalam peluncuran kernel, kadang-kadang dengan tambahan overlay dari JVM, sistem operasi dan hypervisor.  Dalam hal ini, batas di mana mode paralel masuk akal kira-kira sesuai dengan waktu yang diperlukan untuk mulai memproses subtugas dengan jumlah inti yang cukup.  Setelah itu, komputasi paralel dapat lebih hemat energi daripada berurutan (tergantung pada detail prosesor dan sistem. Sebagai contoh, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ). </li><li>  <em>Detailing (Granularity)</em> <br>  Jarang sekali untuk memisahkan perhitungan kecil.  Kerangka kerja biasanya membagi tugas sehingga masing-masing bagian dapat bekerja pada semua inti sistem yang tersedia.  Jika, setelah awal, praktis tidak ada pekerjaan untuk setiap inti, maka upaya (biasanya berurutan) untuk mengatur komputasi paralel akan sia-sia.  Mengingat bahwa dalam praktiknya jumlah core berkisar dari 2 hingga 256 ambang batas, itu juga mencegah efek yang tidak diinginkan dari pembagian tugas yang berlebihan. </li><li>  <em>Dapat dibagi</em> <br>  Koleksi terbagi paling efisien termasuk <code>ArrayList</code> dan <code>{Concurrent}HashMap</code> , serta array reguler ( <code>T[]</code> , yang dibagi menjadi beberapa bagian menggunakan metode <code>java.util.Arrays</code> statis).  Pemisah yang paling tidak efisien adalah <code>LinkedList</code> , <code>BlockingQueue</code> dan sebagian besar sumber dengan berbasis I / O.  Sisanya berada di suatu tempat di tengah (struktur data yang mendukung akses acak dan / atau pencarian efisien biasanya dibagi secara efisien).  Jika pemisahan data lebih lama dari pemrosesan, maka upaya itu sia-sia.  Jika <code>Q</code> cukup besar, maka Anda bisa mendapatkan peningkatan karena paralelisasi bahkan untuk <code>LinkedList</code> , tetapi ini adalah kasus yang agak jarang.  Selain itu, beberapa sumber tidak dapat dipecah menjadi satu elemen tunggal, dan dengan demikian, mungkin ada batasan pada tingkat penguraian masalah. </li></ul><br><p>  Mendapatkan karakteristik yang tepat dari efek-efek ini bisa sulit (walaupun, jika Anda mencoba, itu dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dilakukan</a> dengan menggunakan alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JMH</a> ).  Tetapi efek kumulatifnya cukup mudah dilihat.  Untuk merasakannya sendiri - lakukan percobaan.  Misalnya, pada mesin uji 32-core, ketika Anda menjalankan fungsi kecil, seperti <code>max()</code> atau <code>sum()</code> , di atas <code>ArrayList</code> titik impas adalah sekitar 10.000.  Untuk elemen lainnya, akselerasi hingga 20 kali dicatat.  Jam buka untuk koleksi dengan kurang dari 10.000 item tidak kurang dari untuk 10.000, dan karenanya lebih lambat dari pemrosesan berurutan.  Hasil terburuk terjadi dengan kurang dari 100 elemen - dalam hal ini, utas yang terlibat berhenti tanpa melakukan sesuatu yang bermanfaat, karena  perhitungan selesai sebelum mereka mulai.  Di sisi lain, ketika operasi pada elemen memakan waktu, ketika menggunakan koleksi yang efisien dan sepenuhnya dapat dipecah, seperti <code>ArrayList</code> , manfaatnya segera terlihat. </p><br><p>  Untuk memparafrasekan semua hal di atas, penggunaan <code>parallel()</code> dalam kasus jumlah komputasi yang tidak masuk akal dapat menghabiskan biaya sekitar <code>100</code> mikrodetik, dan penggunaan sebaliknya akan menghemat setidaknya saat ini sendiri (atau mungkin berjam-jam untuk tugas yang sangat besar).  Biaya dan manfaat spesifik akan bervariasi dari waktu ke waktu untuk platform yang berbeda, dan juga, tergantung pada konteksnya.  Misalnya, menjalankan perhitungan kecil secara paralel dalam siklus berurutan meningkatkan efek pasang surut (kinerja microtest di mana hal ini terjadi mungkin tidak mencerminkan situasi sebenarnya). </p><br><h2 id="voprosy-i-otvety">  Tanya Jawab </h2><br><ul><li>  Mengapa JVM tidak bisa mengerti kapan harus menjalankan operasi secara paralel? </li></ul><br><p>  Dia mungkin mencoba, tetapi terlalu sering keputusannya salah.  Pencarian untuk paralelisme multi-core yang sepenuhnya otomatis tidak menghasilkan solusi universal selama tiga puluh tahun terakhir, dan oleh karena itu, kerangka kerja ini menggunakan pendekatan yang lebih andal, yang mengharuskan pengguna hanya untuk memilih antara <em>ya atau tidak</em> .  Pilihan ini didasarkan pada masalah teknik yang terus-menerus ditemui dalam pemrograman berurutan, yang tidak mungkin hilang sama sekali.  Misalnya, Anda mungkin mengalami pelambatan seratus kali lipat ketika mencari nilai maksimum dalam koleksi yang mengandung elemen tunggal dibandingkan dengan menggunakan nilai ini secara langsung (tanpa koleksi).  Terkadang JVM dapat mengoptimalkan kasus seperti itu untuk Anda.  Tapi ini jarang terjadi dalam kasus berurutan, dan tidak pernah dalam kasus mode paralel.  Di sisi lain, kita dapat berharap bahwa, ketika mereka berkembang, alat akan membantu pengguna membuat keputusan yang lebih baik. </p><br><ul><li>  Bagaimana jika untuk membuat keputusan yang baik saya tidak memiliki pengetahuan yang cukup tentang parameter ( <code>F</code> , <code>N</code> , <code>Q</code> , <code>S</code> )? </li></ul><br><p>  Ini juga mirip dengan masalah yang dihadapi dalam pemrograman berurutan.  Misalnya, metode <code>S.contains(x)</code> dari kelas <code>Collection</code> biasanya berjalan cepat jika <code>S</code> adalah <code>HashSet</code> , lambat jika <code>LinkedList</code> , dan rata-rata dalam kasus lain.  Biasanya, untuk pembuat komponen yang menggunakan koleksi, jalan keluar terbaik dari situasi ini adalah merangkumnya dan hanya mempublikasikan operasi spesifik di dalamnya.  Maka pengguna akan terisolasi dari kebutuhan untuk memilih.  Hal yang sama berlaku untuk operasi paralel.  Misalnya, komponen dengan pengumpulan <em>harga</em> internal dapat menentukan metode yang memeriksa ukurannya hingga batasnya, yang akan masuk akal sampai komputasi bitwise terlalu mahal.  Contoh: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMaxPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> priceStream().max(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Stream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">priceStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (prices.size() &lt; MIN_PAR) ? prices.stream() : prices.parallelStream(); }</code> </pre> <br><p>  Gagasan ini dapat diperluas ke pertimbangan lain tentang kapan dan bagaimana menggunakan konkurensi. </p><br><ul><li>  Bagaimana jika fungsi saya mungkin melakukan operasi I / O atau tersinkronisasi? </li></ul><br><p>  Pada satu ekstrem adalah fungsi yang tidak memenuhi kriteria independensi, termasuk operasi I / O berurutan, akses ke sumber daya penguncian yang disinkronkan, dan kasus di mana kesalahan dalam satu sub-tugas paralel yang melakukan I / O memengaruhi yang lain.  Paralelasinya tidak masuk akal.  Di sisi lain, ada perhitungan yang kadang-kadang melakukan sinkronisasi I / O atau jarang diblokir (misalnya, sebagian besar kasus logging, dan penggunaan koleksi kompetitif seperti <code>ConcurrentHashMap</code> ).  Mereka tidak berbahaya.  Apa yang ada di antara mereka membutuhkan penelitian lebih lanjut.  Jika setiap subtugas dapat diblokir untuk waktu yang cukup lama menunggu I / O atau akses, sumber daya CPU akan menganggur tanpa kemungkinan penggunaannya oleh program atau JVM.  Dari ini buruk untuk semua orang.  Dalam kasus ini, pemrosesan streaming paralel tidak selalu merupakan pilihan yang tepat.  Tetapi ada alternatif yang baik - misalnya, asynchronous I / O dan pendekatan <code>CompletableFuture</code> . </p><br><ul><li>  Bagaimana jika sumber saya didasarkan pada I / O? </li></ul><br><p>  Saat ini, menggunakan generator JDK <code>Stream</code> / I / O (misalnya, <code>BufferedReader.lines()</code> ), mereka terutama diadaptasi untuk digunakan dalam mode berurutan, memproses elemen satu per satu saat tersedia.  Dukungan untuk pemrosesan massal berkinerja tinggi dari buffer I / O dimungkinkan, tetapi, pada saat ini, ini memerlukan pengembangan generator khusus <code>Stream</code> s, <code>Spliterator</code> dan <code>Collector</code> s.  Dukungan untuk beberapa kasus umum dapat ditambahkan dalam rilis JDK mendatang. </p><br><ul><li>  Bagaimana jika program saya berjalan di komputer yang sibuk dan semua kernel sibuk? </li></ul><br><p>  Mesin biasanya memiliki jumlah inti yang tetap, dan tidak dapat secara ajaib membuat yang baru ketika melakukan operasi paralel.  Namun, selama kriteria untuk memilih mode paralel jelas <em>digunakan</em> , tidak ada yang perlu diragukan.  Tugas paralel Anda akan bersaing untuk CPU dengan orang lain dan Anda akan melihat lebih sedikit akselerasi.  Dalam kebanyakan kasus, ini masih lebih efektif daripada alternatif lain.  Mekanisme yang mendasarinya dirancang sedemikian rupa sehingga jika tidak ada kernel yang tersedia, Anda hanya akan melihat sedikit perlambatan dibandingkan versi sekuensial, kecuali ketika sistem kelebihan beban sehingga menghabiskan semua waktu untuk mengubah konteks alih-alih melakukan pekerjaan nyata, atau dikonfigurasi dengan harapan bahwa semua pemrosesan dilakukan secara berurutan.  Jika Anda memiliki sistem seperti itu, maka mungkin administrator telah menonaktifkan penggunaan multithreading / nuklir dalam pengaturan JVM.  Dan jika Anda adalah administrator sistem, masuk akal untuk melakukan ini. </p><br><ul><li>  Apakah semua operasi diparalelkan saat menggunakan mode paralel? </li></ul><br><p>  Ya  Setidaknya sampai batas tertentu.  Tetapi perlu mempertimbangkan bahwa kerangka-aliran memperhitungkan keterbatasan sumber dan metode saat memilih cara melakukan ini.  Secara umum, semakin sedikit pembatasan, semakin besar potensi paralelisme.  Di sisi lain, tidak ada jaminan bahwa kerangka kerja akan mengidentifikasi dan menerapkan semua peluang yang tersedia untuk konkurensi.  Dalam beberapa kasus, jika Anda memiliki waktu dan kompetensi, solusi Anda sendiri dapat memanfaatkan kemungkinan konkurensi dengan lebih baik. </p><br><ul><li>  Akselerasi apa yang akan saya dapatkan dari concurrency? </li></ul><br><p>  Jika Anda mengikuti tips ini, maka, biasanya, cukup masuk akal.  Prediktabilitas bukanlah titik kuat dari perangkat keras dan sistem modern, dan oleh karena itu tidak ada jawaban universal.  Lokalitas cache, karakteristik GC, kompilasi JIT, konflik akses memori, lokasi data, kebijakan penjadwalan OS, dan keberadaan hypervisor adalah beberapa faktor yang memiliki dampak signifikan.  Kinerja mode sekuensial juga tunduk pada pengaruhnya, yang, ketika menggunakan paralelisme, sering diperkuat: masalah yang menyebabkan perbedaan 10 persen dalam kasus eksekusi sekuensial dapat menyebabkan perbedaan 10 kali lipat dalam pemrosesan paralel. </p><br><p>  Kerangka aliran mencakup beberapa fitur yang membantu meningkatkan kemungkinan akselerasi.  Misalnya, menggunakan spesialisasi untuk primitif, seperti <code>IntStream</code> , biasanya memiliki efek yang lebih besar untuk mode paralel daripada untuk mode berurutan.  Alasannya adalah bahwa dalam kasus ini, tidak hanya konsumsi sumber daya (dan memori) menurun, tetapi lokasi cache juga meningkat.  Menggunakan <code>ConcurrentHashMap</code> alih-alih <code>HashMap</code> , dalam kasus operasi paralel dari operasi <code>collect</code> , mengurangi biaya internal.  Kiat dan trik baru akan muncul sebagai pengalaman yang diperoleh dengan kerangka kerja. </p><br><ul><li>  Semua ini terlalu menakutkan!  Tidak bisakah kita membuat aturan untuk menggunakan properti JVM untuk mematikan konkurensi? </li></ul><br><p>  Kami tidak ingin memberi tahu Anda apa yang harus dilakukan.  Munculnya cara baru bagi programmer untuk melakukan sesuatu yang salah bisa menakutkan.  Kesalahan dalam kode, arsitektur, dan evaluasi pasti akan terjadi.  Beberapa dekade yang lalu, beberapa orang meramalkan bahwa konkurensi pada tingkat aplikasi akan menyebabkan bencana besar.  Tapi itu tidak pernah menjadi kenyataan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420805/">https://habr.com/ru/post/id420805/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420793/index.html">Debugging sebagai suatu proses</a></li>
<li><a href="../id420795/index.html">Kesalahpahaman analis</a></li>
<li><a href="../id420797/index.html">Belajar tidak bisa ditunda</a></li>
<li><a href="../id420799/index.html">MPS 2018.2: Tes Generator, Plugin GitHub, Aspek VCS, Pemberitahuan Migrasi, dan Lainnya</a></li>
<li><a href="../id420803/index.html">Pelajaran pencetakan 3D. Menghemat plastik saat mencetak model non-fungsional dari 3Dtool</a></li>
<li><a href="../id420809/index.html">Minggu Keamanan 31: Lima Puluh Nuansa Ketidakamanan di Android</a></li>
<li><a href="../id420811/index.html">Generasi baru desentralisasi messenger dan jaringan telepon</a></li>
<li><a href="../id420813/index.html">Backstage Networks di Kubernetes</a></li>
<li><a href="../id420815/index.html">Bagaimana "decoding the digital world" meledakkan aula: 10 laporan teratas DotNext 2018 Piter</a></li>
<li><a href="../id420819/index.html">10 alat Python teratas untuk pembelajaran mesin dan ilmu data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>