<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÑ üÜô üêì Die Datenstrukturen des Zustands der Plasma Cash Blockchain ‚¨õÔ∏è üôèüèæ ü§¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, liebe Habr-User! In diesem Artikel geht es um Web 3.0 - das dezentrale Internet. Web 3.0 f√ºhrt das Konzept der Dezentralisierung als Grundlage ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Datenstrukturen des Zustands der Plasma Cash Blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455988/"><img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br><br>  Hallo, liebe Habr-User!  In diesem Artikel geht es um Web 3.0 - das dezentrale Internet.  Web 3.0 f√ºhrt das Konzept der Dezentralisierung als Grundlage des modernen Internets ein.  Viele Computersysteme und Netzwerke ben√∂tigen Sicherheits- und Dezentralisierungsfunktionen, um ihre Anforderungen zu erf√ºllen.  Eine verteilte Registrierung mit Blockchain-Technologie bietet effiziente L√∂sungen f√ºr die Dezentralisierung. <br><a name="habracut"></a><br>  Blockchain ist eine verteilte Registrierung.  Sie k√∂nnen sich das als eine riesige Datenbank vorstellen, die f√ºr immer lebt und sich im Laufe der Zeit nie √§ndert.  Die Blockchain bildet die Basis f√ºr dezentrale Webanwendungen und -dienste. <br><br>  Die Blockchain ist jedoch mehr als nur eine Datenbank.  Es dient dazu, die Sicherheit und das Vertrauen zwischen Netzwerkmitgliedern zu erh√∂hen und Online-Gesch√§ftstransaktionen zu verbessern. <br><br>  Der byzantinische Konsens erh√∂ht die Netzwerkzuverl√§ssigkeit und l√∂st das Problem der Konsistenz. <br><br>  Die von DLT bereitgestellte Skalierbarkeit √§ndert vorhandene Gesch√§ftsnetzwerke. <br><br>  Blockchain bietet neue, sehr wichtige Vorteile: <br><br><ol><li>  Verhindert kostspielige Fehler. </li><li>  Gew√§hrleistet transparente Transaktionen. </li><li>  Digitalisiert echte Waren. </li><li>  Erzwingt intelligente Vertr√§ge. </li><li>  Erh√∂ht die Geschwindigkeit und Sicherheit von Zahlungen. </li></ol><br>  Wir haben ein spezielles PoE entwickelt, um kryptografische Protokolle zu untersuchen und vorhandene DLT- und Blockchain-L√∂sungen zu verbessern. <br><br>  Den meisten √∂ffentlichen Registrierungssystemen fehlt die Eigenschaft der Skalierbarkeit, wodurch ihr Durchsatz eher gering ist.  Zum Beispiel verarbeitet Ethereum nur ~ 20 tx / s. <br><br>  Viele L√∂sungen wurden entwickelt, um die Skalierbarkeit zu erh√∂hen und gleichzeitig die Dezentralisierung aufrechtzuerhalten.  Es k√∂nnen jedoch nur zwei von drei Vorteilen - Skalierbarkeit, Sicherheit und Dezentralisierung - gleichzeitig erzielt werden. <br><br>  Die Verwendung von Seitenketten bietet eine der effektivsten L√∂sungen. <br><br><h2>  Das Plasmakonzept </h2><br>  Das Plasma-Konzept l√§uft auf die Idee hinaus, dass eine Wurzelkette eine kleine Anzahl von Commits von untergeordneten Ketten verarbeitet und somit als sicherste und letzte Schicht zum Speichern aller Zwischenzust√§nde fungiert.  Jede untergeordnete Kette arbeitet als eigene Blockchain mit einem eigenen Konsensalgorithmus, es gibt jedoch einige wichtige Einschr√§nkungen. <br><br><ul><li>  Intelligente Vertr√§ge werden in einer Stammkette erstellt und dienen als Pr√ºfpunkte f√ºr untergeordnete Ketten innerhalb der Stammkette. </li><li>  Eine untergeordnete Kette wird erstellt und fungiert als eigene Blockchain mit eigenem Konsens.  Alle Staaten in der Kinderkette sind durch Betrugsnachweise gesch√ºtzt, die sicherstellen, dass alle √úberg√§nge zwischen Staaten g√ºltig sind und ein Widerrufsprotokoll anwenden. </li><li>  Intelligente Vertr√§ge, die f√ºr DApp oder die Anwendungslogik der untergeordneten Kette spezifisch sind, k√∂nnen in der untergeordneten Kette bereitgestellt werden. </li><li>  Geldmittel k√∂nnen von der Wurzelkette auf die untergeordnete Kette √ºbertragen werden. </li></ul><br>  Validatoren erhalten wirtschaftliche Anreize, ehrlich zu handeln und Verpflichtungen an die Wurzelkette zu senden - die letzte Transaktionsabwicklungsschicht. <br><br>  Daher m√ºssen DApp-Benutzer, die in der untergeordneten Kette arbeiten, √ºberhaupt nicht mit der Stammkette interagieren.  Au√üerdem k√∂nnen sie ihr Geld jederzeit in die Wurzelkette legen, selbst wenn die Kinderkette gehackt wird.  Diese Ausg√§nge aus der Kinderkette erm√∂glichen es Benutzern, ihre Gelder mit Merkle-Beweisen sicher zu speichern, was den Besitz eines bestimmten Geldbetrags best√§tigt. <br><br>  Die Hauptvorteile von Plasma h√§ngen mit seiner F√§higkeit zusammen, Berechnungen, die die Hauptkette √ºberlasten, erheblich zu vereinfachen.  Dar√ºber hinaus kann die Ethereum-Blockchain umfangreichere und parallelere Datens√§tze verarbeiten.  Die aus der Wurzelkette entfernte Zeit wird auch auf Ethereum-Knoten √ºbertragen, die geringere Verarbeitungs- und Speicheranforderungen haben. <br><br>  <b>Plasma Cash</b> weist Online-Token eindeutige Seriennummern zu.  Zu den Vorteilen dieses Schemas geh√∂ren keine Notwendigkeit f√ºr Best√§tigungen, eine einfachere Unterst√ºtzung f√ºr alle Arten von Token (einschlie√ülich nicht fungibler Token) und eine Abschw√§chung gegen Massenausg√§nge aus einer Kinderkette. <br><br>  Das Konzept der ‚ÄûMassenausg√§nge‚Äú aus einer Kinderkette ist ein Problem, mit dem Plasma konfrontiert ist.  In diesem Szenario k√∂nnen koordinierte gleichzeitige Abhebungen aus einer untergeordneten Kette m√∂glicherweise zu einer unzureichenden Rechenleistung f√ºhren, um alle Mittel abzuheben.  Infolgedessen k√∂nnen Benutzer Geld verlieren. <br><br><h2>  Optionen zur Implementierung von Plasma </h2><br><img src="https://habrastorage.org/webt/vq/qg/hr/vqqghr_ucnoum3q8o1b215zgcic.png"><br><br>  Basic Plasma bietet viele Implementierungsoptionen. <br><br>  Die Hauptunterschiede beziehen sich auf: <br><br><ul><li>  Archivierung von Informationen zu staatlichen Speicher- und Pr√§sentationsmethoden; </li><li>  Token-Typen (teilbar, unteilbar); </li><li>  Transaktionssicherheit; </li><li>  Konsensalgorithmus-Typ. </li></ul><br>  Die Hauptvarianten von Plasma umfassen: <br><br><ul><li>  UTXO-basiertes Plasma - Jede Transaktion besteht aus Ein- und Ausg√§ngen.  Eine Transaktion kann durchgef√ºhrt und ausgegeben werden.  Die Liste der nicht ausgegebenen Transaktionen ist der Status einer untergeordneten Kette. </li><li>  Kontobasiertes Plasma - Diese Struktur enth√§lt die Reflexion und den Kontostand jedes Kontos.  Es wird in Ethereum verwendet, da es zwei Arten von Konten geben kann: ein Benutzerkonto und ein Smart-Vertragskonto.  Einfachheit ist ein wichtiger Vorteil von kontobasiertem Plasma.  Gleichzeitig ist die mangelnde Skalierbarkeit ein Nachteil.  Eine spezielle Eigenschaft, "nonce", wird verwendet, um die zweimalige Ausf√ºhrung einer Transaktion zu verhindern. </li></ul><br>  Um die in der Plasma Cash-Blockchain verwendeten Datenstrukturen und die Funktionsweise von Verpflichtungen zu verstehen, muss das Konzept von Merkle Tree gekl√§rt werden. <br><br><h2>  Merkle Trees und ihre Verwendung im Plasma </h2><br>  Merkle Tree ist eine √§u√üerst wichtige Datenstruktur in der Blockchain-Welt.  Es erm√∂glicht uns, einen bestimmten Datensatz zu erfassen und die Daten auszublenden, jedoch zu beweisen, dass einige Informationen im Satz enthalten waren.  Wenn wir beispielsweise zehn Zahlen haben, k√∂nnen wir einen Beweis f√ºr diese Zahlen erstellen und dann beweisen, dass eine bestimmte Zahl in diesem Satz enthalten ist.  Dieser Beweis h√§tte eine kleine konstante Gr√∂√üe, was die Ver√∂ffentlichung in Ethereum kosteng√ºnstig macht. <br><br>  Sie k√∂nnen dieses Prinzip f√ºr eine Reihe von Transaktionen verwenden und nachweisen, dass sich eine bestimmte Transaktion in dieser Reihe befindet.  Genau das macht ein Bediener.  Jeder Block besteht aus einem Transaktionssatz, der sich in einen Merkle-Baum verwandelt.  Die Wurzel dieses Baumes ist ein Beweis, der zusammen mit jedem Plasmablock in Ethereum ver√∂ffentlicht wird. <br><br>  Benutzer sollten in der Lage sein, ihr Geld aus der Plasmakette abzuheben.  Zu diesem Zweck senden sie eine "Exit" -Transaktion an Ethereum. <br><br>  Plasma Cash verwendet einen speziellen Merkle-Baum, der die Validierung eines ganzen Blocks √ºberfl√ºssig macht.  Es reicht aus, nur die Zweige zu validieren, die dem Token des Benutzers entsprechen. <br><br>  Um ein Token zu √ºbertragen, m√ºssen Sie seinen Verlauf analysieren und nur die Token scannen, die ein bestimmter Benutzer ben√∂tigt.  Bei der √úbertragung eines Tokens sendet der Benutzer einfach den gesamten Verlauf an einen anderen Benutzer, der dann den gesamten Verlauf authentifizieren und vor allem sehr schnell ausf√ºhren kann. <br><br><img src="https://habrastorage.org/webt/l7/tg/iw/l7tgiwwibxyks4m-tv6lmw3cs_a.png"><br><br><h2>  Plasma Cash-Datenstrukturen f√ºr die Speicherung von Status und Verlauf </h2><br>  Es ist ratsam, nur ausgew√§hlte Merkle-B√§ume zu verwenden, da f√ºr eine Transaktion in einem Block Einschluss- und Nichteinschlussnachweise erforderlich sind.  Zum Beispiel: <br><br><ul><li>  Sp√§rlicher Merkle-Baum </li><li>  Patricia Baum </li></ul><br>  Wir haben f√ºr unseren Kunden eigene Sparse Merkle Tree- und Patricia Tree-Implementierungen entwickelt. <br><br>  Ein sp√§rlicher Merkle-Baum √§hnelt einem Standard-Merkle-Baum, au√üer dass seine Daten indiziert werden und jeder Datenpunkt auf einem Blatt platziert wird, das dem Index dieses Datenpunkts entspricht. <br><br>  Angenommen, wir haben einen vierbl√§ttrigen Merkle-Baum.  F√ºllen wir diesen Baum zur Demonstration mit den Buchstaben A und D.  Der Buchstabe A ist der erste Buchstabe des Alphabets, daher platzieren wir ihn auf dem ersten Blatt.  In √§hnlicher Weise werden wir D auf das vierte Blatt setzen. <br><br>  Was passiert also beim zweiten und dritten Blatt?  Sie sollten leer gelassen werden.  Genauer gesagt wird anstelle eines Buchstabens ein spezieller Wert (z. B. Null) verwendet. <br><br>  Der Baum sieht schlie√ülich so aus: <br><br><img src="https://habrastorage.org/webt/5g/9g/18/5g9g18uvkq5oizxi81z8pbeij48.png"><br><br>  Der Einschlussnachweis funktioniert genauso wie bei einem normalen Merkle-Baum.  Was passiert, wenn wir beweisen wollen, dass C nicht Teil dieses Merkle-Baums ist?  Grundstufe!  Wir wissen, dass wenn C ein Teil eines Baumes ist, es sich auf dem dritten Blatt befindet.  Wenn C kein Teil des Baumes ist, sollte das dritte Blatt Null sein. <br><br>  Alles, was ben√∂tigt wird, ist ein Standard-Merkle-Einschlussnachweis, der zeigt, dass das dritte Blatt Null ist. <br><br>  Das Beste an einem Sparse Merkle Tree ist, dass er Repositories f√ºr Schl√ºsselwerte im Merkle Tree bereitstellt! <br><br>  Ein Teil des PoE-Protokollcodes erstellt einen Sparse Merkle Tree: <br><br><pre><code class="plaintext hljs">class SparseTree { //... buildTree() { if (Object.keys(this.leaves).length &gt; 0) { this.levels = [] this.levels.unshift(this.leaves) for (let level = 0; level &lt; this.depth; level++) { let currentLevel = this.levels[0] let nextLevel = {} Object.keys(currentLevel).forEach((leafKey) =&gt; { let leafHash = currentLevel[leafKey] let isEvenLeaf = this.isEvenLeaf(leafKey) let parentLeafKey = leafKey.slice(0, -1) let neighborLeafKey = parentLeafKey + (isEvenLeaf ? '1' : '0') let neighborLeafHash = currentLevel[neighborLeafKey] if (!neighborLeafHash) { neighborLeafHash = this.defaultHashes[level] } if (!nextLevel[parentLeafKey]) { let parentLeafHash = isEvenLeaf ? ethUtil.sha3(Buffer.concat([leafHash, neighborLeafHash])) : ethUtil.sha3(Buffer.concat([neighborLeafHash, leafHash])) if (level == this.depth - 1) { nextLevel['merkleRoot'] = parentLeafHash } else { nextLevel[parentLeafKey] = parentLeafHash } } }) this.levels.unshift(nextLevel) } } } }</code> </pre> <br>  Dieser Code ist ziemlich trivial.  Wir haben ein Schl√ºsselwert-Repository mit einem Einschluss- / Nichteinschlussnachweis. <br><br>  In jeder Iteration wird eine bestimmte Ebene eines endg√ºltigen Baums gef√ºllt, beginnend mit der letzten.  Abh√§ngig davon, ob der Schl√ºssel des aktuellen Blattes gerade oder ungerade ist, nehmen wir zwei benachbarte Bl√§tter und z√§hlen den Hash des aktuellen Levels.  Wenn wir das Ende erreichen, w√ºrden wir einen einzelnen merkleRoot aufschreiben - einen gemeinsamen Hash. <br><br>  Sie m√ºssen verstehen, dass dieser Baum mit anf√§nglich leeren Werten gef√ºllt ist.  Wenn wir eine gro√üe Menge an Token-IDs speichern w√ºrden, h√§tten wir eine gro√üe Baumgr√∂√üe und es w√§re lang! <br><br>  Es gibt viele Abhilfema√ünahmen f√ºr diese Nichtoptimierung, aber wir haben beschlossen, diesen Baum in einen Patricia-Baum zu √§ndern. <br><br>  Ein Patricia Tree ist eine Kombination aus Radix Tree und Merkle Tree. <br><br>  Ein Radix Tree-Datenschl√ºssel speichert den Pfad zu den Daten selbst, wodurch wir eine optimierte Datenstruktur f√ºr den Speicher erstellen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/ox/cz/gc/oxczgcwvxvl2jas44sbtbqophda.png"><br><br>  Hier ist eine Implementierung, die f√ºr unseren Kunden entwickelt wurde: <br><br><pre> <code class="plaintext hljs">buildNode(childNodes, key = '', level = 0) { let node = {key} this.iterations++ if (childNodes.length == 1) { let nodeKey = level == 0 ? childNodes[0].key : childNodes[0].key.slice(level - 1) node.key = nodeKey let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(nodeKey)), childNodes[0].hash]) node.hash = ethUtil.sha3(nodeHashes) return node } let leftChilds = [] let rightChilds = [] childNodes.forEach((node) =&gt; { if (node.key[level] == '1') { rightChilds.push(node) } else { leftChilds.push(node) } }) if (leftChilds.length &amp;&amp; rightChilds.length) { node.leftChild = this.buildNode(leftChilds, '0', level + 1) node.rightChild = this.buildNode(rightChilds, '1', level + 1) let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(node.key)), node.leftChild.hash, node.rightChild.hash]) node.hash = ethUtil.sha3(nodeHashes) } else if (leftChilds.length &amp;&amp; !rightChilds.length) { node = this.buildNode(leftChilds, key + '0', level + 1) } else if (!leftChilds.length &amp;&amp; rightChilds.length) { node = this.buildNode(rightChilds, key + '1', level + 1) } else if (!leftChilds.length &amp;&amp; !rightChilds.length) { throw new Error('invalid tree') } return node }</code> </pre> <br>  Wir sind rekursiv umgezogen und haben die separaten linken und rechten Teilb√§ume erstellt.  In diesem Baum wurde ein Schl√ºssel als Pfad erstellt. <br><br>  Diese L√∂sung ist noch trivialer.  Es ist gut optimiert und arbeitet schneller.  Tats√§chlich kann ein Patricia Tree noch weiter optimiert werden, indem neue Knotentypen eingef√ºhrt werden - Erweiterungsknoten, Verzweigungsknoten usw., wie im Ethereum-Protokoll.  Die aktuelle Implementierung erf√ºllt jedoch alle unsere Anforderungen - wir haben eine schnelle und speicheroptimierte Datenstruktur. <br><br>  Durch die Implementierung dieser Datenstrukturen im Projekt unseres Kunden haben wir die Skalierung von Plasma Cash erm√∂glicht.  Auf diese Weise k√∂nnen wir den Verlauf eines Tokens und das Einschlie√üen / Nichteinschlie√üen des Tokens in einen Baum √ºberpr√ºfen, wodurch die Validierung von Bl√∂cken und der untergeordneten Plasmakette erheblich beschleunigt wird. <br><br><h3>  Links: </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wei√übuchplasma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Git Hub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungsf√§lle und Architekturbeschreibung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lightning-Netzwerkpapier</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455988/">https://habr.com/ru/post/de455988/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455978/index.html">Lambdas: von C ++ 11 bis C ++ 20. Teil 2</a></li>
<li><a href="../de455980/index.html">iOS Digest Nr. 7 (31. Mai - 13. Juni)</a></li>
<li><a href="../de455982/index.html">Es ist Zeit, GIF durch AV1-Video zu ersetzen</a></li>
<li><a href="../de455984/index.html">So verstehen Sie, dass Links funktionieren: Metriken und Aufbau von KPI-Links</a></li>
<li><a href="../de455986/index.html">Warum sollte ein IT-Techniker ein Gehirn herausnehmen?</a></li>
<li><a href="../de455990/index.html">CTT in Serverl√∂sungen - wie sieht es aus?</a></li>
<li><a href="../de455994/index.html">Die Entwicklung des beliebtesten Tools eines Entwicklers (in Visual Studio)</a></li>
<li><a href="../de455996/index.html">Digitale Transformation von Werbung im Netzwerkeinzelhandel. Auf den Spuren von Video Analytics im Einzelhandel</a></li>
<li><a href="../de456000/index.html">Erstellen eines Tic-Tac-Toe-Spiels mit TypeScript, React und Mocha</a></li>
<li><a href="../de456002/index.html">Spezielles Herdged√§chtnis und OOM Killer-Intervention</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>