<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💄 🆙 🐓 Die Datenstrukturen des Zustands der Plasma Cash Blockchain ⬛️ 🙏🏾 🤦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, liebe Habr-User! In diesem Artikel geht es um Web 3.0 - das dezentrale Internet. Web 3.0 führt das Konzept der Dezentralisierung als Grundlage ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Datenstrukturen des Zustands der Plasma Cash Blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455988/"><img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br><br>  Hallo, liebe Habr-User!  In diesem Artikel geht es um Web 3.0 - das dezentrale Internet.  Web 3.0 führt das Konzept der Dezentralisierung als Grundlage des modernen Internets ein.  Viele Computersysteme und Netzwerke benötigen Sicherheits- und Dezentralisierungsfunktionen, um ihre Anforderungen zu erfüllen.  Eine verteilte Registrierung mit Blockchain-Technologie bietet effiziente Lösungen für die Dezentralisierung. <br><a name="habracut"></a><br>  Blockchain ist eine verteilte Registrierung.  Sie können sich das als eine riesige Datenbank vorstellen, die für immer lebt und sich im Laufe der Zeit nie ändert.  Die Blockchain bildet die Basis für dezentrale Webanwendungen und -dienste. <br><br>  Die Blockchain ist jedoch mehr als nur eine Datenbank.  Es dient dazu, die Sicherheit und das Vertrauen zwischen Netzwerkmitgliedern zu erhöhen und Online-Geschäftstransaktionen zu verbessern. <br><br>  Der byzantinische Konsens erhöht die Netzwerkzuverlässigkeit und löst das Problem der Konsistenz. <br><br>  Die von DLT bereitgestellte Skalierbarkeit ändert vorhandene Geschäftsnetzwerke. <br><br>  Blockchain bietet neue, sehr wichtige Vorteile: <br><br><ol><li>  Verhindert kostspielige Fehler. </li><li>  Gewährleistet transparente Transaktionen. </li><li>  Digitalisiert echte Waren. </li><li>  Erzwingt intelligente Verträge. </li><li>  Erhöht die Geschwindigkeit und Sicherheit von Zahlungen. </li></ol><br>  Wir haben ein spezielles PoE entwickelt, um kryptografische Protokolle zu untersuchen und vorhandene DLT- und Blockchain-Lösungen zu verbessern. <br><br>  Den meisten öffentlichen Registrierungssystemen fehlt die Eigenschaft der Skalierbarkeit, wodurch ihr Durchsatz eher gering ist.  Zum Beispiel verarbeitet Ethereum nur ~ 20 tx / s. <br><br>  Viele Lösungen wurden entwickelt, um die Skalierbarkeit zu erhöhen und gleichzeitig die Dezentralisierung aufrechtzuerhalten.  Es können jedoch nur zwei von drei Vorteilen - Skalierbarkeit, Sicherheit und Dezentralisierung - gleichzeitig erzielt werden. <br><br>  Die Verwendung von Seitenketten bietet eine der effektivsten Lösungen. <br><br><h2>  Das Plasmakonzept </h2><br>  Das Plasma-Konzept läuft auf die Idee hinaus, dass eine Wurzelkette eine kleine Anzahl von Commits von untergeordneten Ketten verarbeitet und somit als sicherste und letzte Schicht zum Speichern aller Zwischenzustände fungiert.  Jede untergeordnete Kette arbeitet als eigene Blockchain mit einem eigenen Konsensalgorithmus, es gibt jedoch einige wichtige Einschränkungen. <br><br><ul><li>  Intelligente Verträge werden in einer Stammkette erstellt und dienen als Prüfpunkte für untergeordnete Ketten innerhalb der Stammkette. </li><li>  Eine untergeordnete Kette wird erstellt und fungiert als eigene Blockchain mit eigenem Konsens.  Alle Staaten in der Kinderkette sind durch Betrugsnachweise geschützt, die sicherstellen, dass alle Übergänge zwischen Staaten gültig sind und ein Widerrufsprotokoll anwenden. </li><li>  Intelligente Verträge, die für DApp oder die Anwendungslogik der untergeordneten Kette spezifisch sind, können in der untergeordneten Kette bereitgestellt werden. </li><li>  Geldmittel können von der Wurzelkette auf die untergeordnete Kette übertragen werden. </li></ul><br>  Validatoren erhalten wirtschaftliche Anreize, ehrlich zu handeln und Verpflichtungen an die Wurzelkette zu senden - die letzte Transaktionsabwicklungsschicht. <br><br>  Daher müssen DApp-Benutzer, die in der untergeordneten Kette arbeiten, überhaupt nicht mit der Stammkette interagieren.  Außerdem können sie ihr Geld jederzeit in die Wurzelkette legen, selbst wenn die Kinderkette gehackt wird.  Diese Ausgänge aus der Kinderkette ermöglichen es Benutzern, ihre Gelder mit Merkle-Beweisen sicher zu speichern, was den Besitz eines bestimmten Geldbetrags bestätigt. <br><br>  Die Hauptvorteile von Plasma hängen mit seiner Fähigkeit zusammen, Berechnungen, die die Hauptkette überlasten, erheblich zu vereinfachen.  Darüber hinaus kann die Ethereum-Blockchain umfangreichere und parallelere Datensätze verarbeiten.  Die aus der Wurzelkette entfernte Zeit wird auch auf Ethereum-Knoten übertragen, die geringere Verarbeitungs- und Speicheranforderungen haben. <br><br>  <b>Plasma Cash</b> weist Online-Token eindeutige Seriennummern zu.  Zu den Vorteilen dieses Schemas gehören keine Notwendigkeit für Bestätigungen, eine einfachere Unterstützung für alle Arten von Token (einschließlich nicht fungibler Token) und eine Abschwächung gegen Massenausgänge aus einer Kinderkette. <br><br>  Das Konzept der „Massenausgänge“ aus einer Kinderkette ist ein Problem, mit dem Plasma konfrontiert ist.  In diesem Szenario können koordinierte gleichzeitige Abhebungen aus einer untergeordneten Kette möglicherweise zu einer unzureichenden Rechenleistung führen, um alle Mittel abzuheben.  Infolgedessen können Benutzer Geld verlieren. <br><br><h2>  Optionen zur Implementierung von Plasma </h2><br><img src="https://habrastorage.org/webt/vq/qg/hr/vqqghr_ucnoum3q8o1b215zgcic.png"><br><br>  Basic Plasma bietet viele Implementierungsoptionen. <br><br>  Die Hauptunterschiede beziehen sich auf: <br><br><ul><li>  Archivierung von Informationen zu staatlichen Speicher- und Präsentationsmethoden; </li><li>  Token-Typen (teilbar, unteilbar); </li><li>  Transaktionssicherheit; </li><li>  Konsensalgorithmus-Typ. </li></ul><br>  Die Hauptvarianten von Plasma umfassen: <br><br><ul><li>  UTXO-basiertes Plasma - Jede Transaktion besteht aus Ein- und Ausgängen.  Eine Transaktion kann durchgeführt und ausgegeben werden.  Die Liste der nicht ausgegebenen Transaktionen ist der Status einer untergeordneten Kette. </li><li>  Kontobasiertes Plasma - Diese Struktur enthält die Reflexion und den Kontostand jedes Kontos.  Es wird in Ethereum verwendet, da es zwei Arten von Konten geben kann: ein Benutzerkonto und ein Smart-Vertragskonto.  Einfachheit ist ein wichtiger Vorteil von kontobasiertem Plasma.  Gleichzeitig ist die mangelnde Skalierbarkeit ein Nachteil.  Eine spezielle Eigenschaft, "nonce", wird verwendet, um die zweimalige Ausführung einer Transaktion zu verhindern. </li></ul><br>  Um die in der Plasma Cash-Blockchain verwendeten Datenstrukturen und die Funktionsweise von Verpflichtungen zu verstehen, muss das Konzept von Merkle Tree geklärt werden. <br><br><h2>  Merkle Trees und ihre Verwendung im Plasma </h2><br>  Merkle Tree ist eine äußerst wichtige Datenstruktur in der Blockchain-Welt.  Es ermöglicht uns, einen bestimmten Datensatz zu erfassen und die Daten auszublenden, jedoch zu beweisen, dass einige Informationen im Satz enthalten waren.  Wenn wir beispielsweise zehn Zahlen haben, können wir einen Beweis für diese Zahlen erstellen und dann beweisen, dass eine bestimmte Zahl in diesem Satz enthalten ist.  Dieser Beweis hätte eine kleine konstante Größe, was die Veröffentlichung in Ethereum kostengünstig macht. <br><br>  Sie können dieses Prinzip für eine Reihe von Transaktionen verwenden und nachweisen, dass sich eine bestimmte Transaktion in dieser Reihe befindet.  Genau das macht ein Bediener.  Jeder Block besteht aus einem Transaktionssatz, der sich in einen Merkle-Baum verwandelt.  Die Wurzel dieses Baumes ist ein Beweis, der zusammen mit jedem Plasmablock in Ethereum veröffentlicht wird. <br><br>  Benutzer sollten in der Lage sein, ihr Geld aus der Plasmakette abzuheben.  Zu diesem Zweck senden sie eine "Exit" -Transaktion an Ethereum. <br><br>  Plasma Cash verwendet einen speziellen Merkle-Baum, der die Validierung eines ganzen Blocks überflüssig macht.  Es reicht aus, nur die Zweige zu validieren, die dem Token des Benutzers entsprechen. <br><br>  Um ein Token zu übertragen, müssen Sie seinen Verlauf analysieren und nur die Token scannen, die ein bestimmter Benutzer benötigt.  Bei der Übertragung eines Tokens sendet der Benutzer einfach den gesamten Verlauf an einen anderen Benutzer, der dann den gesamten Verlauf authentifizieren und vor allem sehr schnell ausführen kann. <br><br><img src="https://habrastorage.org/webt/l7/tg/iw/l7tgiwwibxyks4m-tv6lmw3cs_a.png"><br><br><h2>  Plasma Cash-Datenstrukturen für die Speicherung von Status und Verlauf </h2><br>  Es ist ratsam, nur ausgewählte Merkle-Bäume zu verwenden, da für eine Transaktion in einem Block Einschluss- und Nichteinschlussnachweise erforderlich sind.  Zum Beispiel: <br><br><ul><li>  Spärlicher Merkle-Baum </li><li>  Patricia Baum </li></ul><br>  Wir haben für unseren Kunden eigene Sparse Merkle Tree- und Patricia Tree-Implementierungen entwickelt. <br><br>  Ein spärlicher Merkle-Baum ähnelt einem Standard-Merkle-Baum, außer dass seine Daten indiziert werden und jeder Datenpunkt auf einem Blatt platziert wird, das dem Index dieses Datenpunkts entspricht. <br><br>  Angenommen, wir haben einen vierblättrigen Merkle-Baum.  Füllen wir diesen Baum zur Demonstration mit den Buchstaben A und D.  Der Buchstabe A ist der erste Buchstabe des Alphabets, daher platzieren wir ihn auf dem ersten Blatt.  In ähnlicher Weise werden wir D auf das vierte Blatt setzen. <br><br>  Was passiert also beim zweiten und dritten Blatt?  Sie sollten leer gelassen werden.  Genauer gesagt wird anstelle eines Buchstabens ein spezieller Wert (z. B. Null) verwendet. <br><br>  Der Baum sieht schließlich so aus: <br><br><img src="https://habrastorage.org/webt/5g/9g/18/5g9g18uvkq5oizxi81z8pbeij48.png"><br><br>  Der Einschlussnachweis funktioniert genauso wie bei einem normalen Merkle-Baum.  Was passiert, wenn wir beweisen wollen, dass C nicht Teil dieses Merkle-Baums ist?  Grundstufe!  Wir wissen, dass wenn C ein Teil eines Baumes ist, es sich auf dem dritten Blatt befindet.  Wenn C kein Teil des Baumes ist, sollte das dritte Blatt Null sein. <br><br>  Alles, was benötigt wird, ist ein Standard-Merkle-Einschlussnachweis, der zeigt, dass das dritte Blatt Null ist. <br><br>  Das Beste an einem Sparse Merkle Tree ist, dass er Repositories für Schlüsselwerte im Merkle Tree bereitstellt! <br><br>  Ein Teil des PoE-Protokollcodes erstellt einen Sparse Merkle Tree: <br><br><pre><code class="plaintext hljs">class SparseTree { //... buildTree() { if (Object.keys(this.leaves).length &gt; 0) { this.levels = [] this.levels.unshift(this.leaves) for (let level = 0; level &lt; this.depth; level++) { let currentLevel = this.levels[0] let nextLevel = {} Object.keys(currentLevel).forEach((leafKey) =&gt; { let leafHash = currentLevel[leafKey] let isEvenLeaf = this.isEvenLeaf(leafKey) let parentLeafKey = leafKey.slice(0, -1) let neighborLeafKey = parentLeafKey + (isEvenLeaf ? '1' : '0') let neighborLeafHash = currentLevel[neighborLeafKey] if (!neighborLeafHash) { neighborLeafHash = this.defaultHashes[level] } if (!nextLevel[parentLeafKey]) { let parentLeafHash = isEvenLeaf ? ethUtil.sha3(Buffer.concat([leafHash, neighborLeafHash])) : ethUtil.sha3(Buffer.concat([neighborLeafHash, leafHash])) if (level == this.depth - 1) { nextLevel['merkleRoot'] = parentLeafHash } else { nextLevel[parentLeafKey] = parentLeafHash } } }) this.levels.unshift(nextLevel) } } } }</code> </pre> <br>  Dieser Code ist ziemlich trivial.  Wir haben ein Schlüsselwert-Repository mit einem Einschluss- / Nichteinschlussnachweis. <br><br>  In jeder Iteration wird eine bestimmte Ebene eines endgültigen Baums gefüllt, beginnend mit der letzten.  Abhängig davon, ob der Schlüssel des aktuellen Blattes gerade oder ungerade ist, nehmen wir zwei benachbarte Blätter und zählen den Hash des aktuellen Levels.  Wenn wir das Ende erreichen, würden wir einen einzelnen merkleRoot aufschreiben - einen gemeinsamen Hash. <br><br>  Sie müssen verstehen, dass dieser Baum mit anfänglich leeren Werten gefüllt ist.  Wenn wir eine große Menge an Token-IDs speichern würden, hätten wir eine große Baumgröße und es wäre lang! <br><br>  Es gibt viele Abhilfemaßnahmen für diese Nichtoptimierung, aber wir haben beschlossen, diesen Baum in einen Patricia-Baum zu ändern. <br><br>  Ein Patricia Tree ist eine Kombination aus Radix Tree und Merkle Tree. <br><br>  Ein Radix Tree-Datenschlüssel speichert den Pfad zu den Daten selbst, wodurch wir eine optimierte Datenstruktur für den Speicher erstellen können. <br><br><img src="https://habrastorage.org/webt/ox/cz/gc/oxczgcwvxvl2jas44sbtbqophda.png"><br><br>  Hier ist eine Implementierung, die für unseren Kunden entwickelt wurde: <br><br><pre> <code class="plaintext hljs">buildNode(childNodes, key = '', level = 0) { let node = {key} this.iterations++ if (childNodes.length == 1) { let nodeKey = level == 0 ? childNodes[0].key : childNodes[0].key.slice(level - 1) node.key = nodeKey let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(nodeKey)), childNodes[0].hash]) node.hash = ethUtil.sha3(nodeHashes) return node } let leftChilds = [] let rightChilds = [] childNodes.forEach((node) =&gt; { if (node.key[level] == '1') { rightChilds.push(node) } else { leftChilds.push(node) } }) if (leftChilds.length &amp;&amp; rightChilds.length) { node.leftChild = this.buildNode(leftChilds, '0', level + 1) node.rightChild = this.buildNode(rightChilds, '1', level + 1) let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(node.key)), node.leftChild.hash, node.rightChild.hash]) node.hash = ethUtil.sha3(nodeHashes) } else if (leftChilds.length &amp;&amp; !rightChilds.length) { node = this.buildNode(leftChilds, key + '0', level + 1) } else if (!leftChilds.length &amp;&amp; rightChilds.length) { node = this.buildNode(rightChilds, key + '1', level + 1) } else if (!leftChilds.length &amp;&amp; !rightChilds.length) { throw new Error('invalid tree') } return node }</code> </pre> <br>  Wir sind rekursiv umgezogen und haben die separaten linken und rechten Teilbäume erstellt.  In diesem Baum wurde ein Schlüssel als Pfad erstellt. <br><br>  Diese Lösung ist noch trivialer.  Es ist gut optimiert und arbeitet schneller.  Tatsächlich kann ein Patricia Tree noch weiter optimiert werden, indem neue Knotentypen eingeführt werden - Erweiterungsknoten, Verzweigungsknoten usw., wie im Ethereum-Protokoll.  Die aktuelle Implementierung erfüllt jedoch alle unsere Anforderungen - wir haben eine schnelle und speicheroptimierte Datenstruktur. <br><br>  Durch die Implementierung dieser Datenstrukturen im Projekt unseres Kunden haben wir die Skalierung von Plasma Cash ermöglicht.  Auf diese Weise können wir den Verlauf eines Tokens und das Einschließen / Nichteinschließen des Tokens in einen Baum überprüfen, wodurch die Validierung von Blöcken und der untergeordneten Plasmakette erheblich beschleunigt wird. <br><br><h3>  Links: </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weißbuchplasma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Git Hub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungsfälle und Architekturbeschreibung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lightning-Netzwerkpapier</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455988/">https://habr.com/ru/post/de455988/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455978/index.html">Lambdas: von C ++ 11 bis C ++ 20. Teil 2</a></li>
<li><a href="../de455980/index.html">iOS Digest Nr. 7 (31. Mai - 13. Juni)</a></li>
<li><a href="../de455982/index.html">Es ist Zeit, GIF durch AV1-Video zu ersetzen</a></li>
<li><a href="../de455984/index.html">So verstehen Sie, dass Links funktionieren: Metriken und Aufbau von KPI-Links</a></li>
<li><a href="../de455986/index.html">Warum sollte ein IT-Techniker ein Gehirn herausnehmen?</a></li>
<li><a href="../de455990/index.html">CTT in Serverlösungen - wie sieht es aus?</a></li>
<li><a href="../de455994/index.html">Die Entwicklung des beliebtesten Tools eines Entwicklers (in Visual Studio)</a></li>
<li><a href="../de455996/index.html">Digitale Transformation von Werbung im Netzwerkeinzelhandel. Auf den Spuren von Video Analytics im Einzelhandel</a></li>
<li><a href="../de456000/index.html">Erstellen eines Tic-Tac-Toe-Spiels mit TypeScript, React und Mocha</a></li>
<li><a href="../de456002/index.html">Spezielles Herdgedächtnis und OOM Killer-Intervention</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>