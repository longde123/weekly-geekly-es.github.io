<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¨ ğŸ¯ ğŸ’ Metode kuasi-Newtonian, atau ketika ada terlalu banyak turunan kedua untuk Athos â›ï¸ ğŸš¸ ğŸ¦‚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada kenalan pertama dengan metode kuasi-Newtonian orang mungkin terkejut dua kali. Pertama, setelah melihat sekilas formula, muncul keraguan bahwa in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metode kuasi-Newtonian, atau ketika ada terlalu banyak turunan kedua untuk Athos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470638/">  Pada kenalan pertama dengan metode kuasi-Newtonian orang mungkin terkejut dua kali.  Pertama, setelah melihat sekilas formula, muncul keraguan bahwa ini bisa bekerja sama sekali.  Namun, mereka berhasil.  Lebih lanjut, tampaknya diragukan bahwa mereka akan bekerja dengan baik.  Dan itu jauh lebih mengejutkan untuk melihat seberapa cepat mereka daripada berbagai variasi gradient descent, bukan pada tugas yang dibangun secara khusus, tetapi pada tugas nyata yang diambil dari latihan.  Dan jika setelah ini masih ada keraguan dicampur dengan bunga, maka Anda perlu memahami mengapa ini bekerja sama sekali. <br><a name="habracut"></a><br>  Asal dan ide dasar yang menggerakkan metode gradien, termasuk metode Newton, telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dipertimbangkan</a> .  Yaitu, kami mengandalkan informasi tentang perilaku fungsi di sekitar posisi saat ini, yang memberi kami analisis matematika sederhana.  Minimal, diasumsikan bahwa informasi tentang turunan pertama tersedia untuk kami.  Bagaimana jika ini semua yang tersedia bagi kita?  Apakah gradient descent kalimat kita?  Tentu saja, ya, kecuali jika Anda tiba-tiba ingat bahwa kita sedang berhadapan dengan suatu <i>proses</i> di mana fungsi objektif diproses dengan benar.  Dan jika demikian, mengapa kita tidak menggunakan informasi yang terakumulasi tentang perilaku fungsi untuk membuat jalan kita di permukaannya sedikit kurang buta? <br><br>  Gagasan untuk menggunakan informasi tentang jalan yang dicakup terletak di jantung sebagian besar cara untuk mempercepat metode keturunan.  Artikel ini membahas salah satu cara akuntansi yang paling efektif, meskipun bukan yang termurah, untuk informasi semacam ini, yang mengarah ke ide metode kuasi-Newtonian. <br><br>  Untuk memahami di mana kaki metode kuasi-Newtonian tumbuh dan dari mana nama itu berasal, kita kembali harus kembali ke metode minimalisasi berdasarkan solusi langsung dari persamaan titik stasioner <img src="https://habrastorage.org/getpro/habr/post_images/c43/946/5f9/c439465f905d9f366a2f4b3296306290.gif" title="&quot;\ bigtriangledown f = 0&quot;">  .  Sama seperti pertimbangan metode Newton yang diterapkan pada solusi persamaan ini membawa kita ke metode optimisasi dengan nama yang sama (yang, tidak seperti nenek moyangnya, memiliki wilayah konvergensi global), kita dapat berharap bahwa pertimbangan metode lain untuk menyelesaikan sistem persamaan nonlinear akan bermanfaat dalam rencanakan ide untuk membangun metode optimasi lainnya. <br><br><h2>  Metode garis potong </h2><br>  Biarkan saya mengingatkan Anda bahwa metode Newton untuk memecahkan sistem persamaan <img src="https://habrastorage.org/getpro/habr/post_images/0a0/ec7/804/0a0ec780406efe57ca6444290ccfde09.gif" title="&quot;F (x) = 0&quot;">  , didasarkan pada penggantian di lingkungan beberapa titik dekat dengan solusi <img src="https://habrastorage.org/getpro/habr/post_images/779/0dd/0ef/7790dd0efb4a03a4c876741804d9b559.gif" title="x">  fungsi <img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="&quot;F&quot;">  pendekatan liniernya <img src="https://habrastorage.org/getpro/habr/post_images/d15/479/f23/d15479f235f0d60ce8837c9043a0d2cc.gif" title="&quot;L (p) = F (x) + J (x) p&quot;">  dimana <img src="https://habrastorage.org/getpro/habr/post_images/206/f34/999/206f349991c0724c2fdce788124abe1c.gif" title="&quot;J&quot;">  Adalah operator linier, yang, kapan <img src="https://habrastorage.org/getpro/habr/post_images/779/0dd/0ef/7790dd0efb4a03a4c876741804d9b559.gif" title="x">  adalah vektor dan <img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="&quot;F&quot;">  memiliki turunan parsial sehubungan dengan masing-masing variabel, bertepatan dengan matriks Jacobi <img src="https://habrastorage.org/getpro/habr/post_images/4d2/826/ff6/4d2826ff6ba22f9f67cab70bfbe17a16.gif" title="&quot;J_ {ij} = \ dfrac {\ partial F_ {i}} {\ partial x_ {j}}&quot;">  .  Selanjutnya, persamaan diselesaikan <img src="https://habrastorage.org/getpro/habr/post_images/c9d/8be/3f2/c9d8be3f2d70054db890ea34e3409544.gif" title="&quot;L (p) = 0&quot;">  dan titik <img src="https://habrastorage.org/getpro/habr/post_images/2c4/a7b/e55/2c4a7be5582848bfbcdd9ee141e7d764.gif" title="&amp; quot; x '= x + p &amp; quot;">  diambil sebagai pendekatan baru ke solusi yang diinginkan.  Sederhana dan berhasil. <br><br>  Tetapi bagaimana jika kita karena suatu alasan tidak dapat menghitung matriks Jacobi?  Hal pertama yang terlintas dalam pikiran dalam kasus ini adalah bahwa jika kita tidak dapat menghitung turunan parsial secara analitis, maka kita bisa mendapatkan perkiraan numerik untuknya.  Opsi paling sederhana (meskipun bukan satu-satunya) untuk perkiraan seperti itu bisa menjadi rumus perbedaan terbatas yang tepat: <img src="https://habrastorage.org/getpro/habr/post_images/149/708/f5b/149708f5b8bab4374023295557622e82.gif" title="&quot;\ dfrac {\ partial F_ {i}} {\ partial x_ {j}} \ approx \ dfrac {F_ {i} (x + h_ {j} e_ {j}) - F_ {i} (x)} { h_ {j}} &quot;">  dimana <img src="https://habrastorage.org/getpro/habr/post_images/459/e61/aa0/459e61aa08f7fe807167a596e7ebd8a9.gif" title="&quot;e_ {j}&quot;">  Apakah vektor basis jth.  Matriks yang terdiri dari perkiraan tersebut akan dilambangkan dengan <img src="https://habrastorage.org/getpro/habr/post_images/a51/533/990/a5153399048e881eb8661304792b8c81.gif" title="&quot;\ bar {J}&quot;">  .  Analisis berapa banyak penggantian <img src="https://habrastorage.org/getpro/habr/post_images/206/f34/999/206f349991c0724c2fdce788124abe1c.gif" title="&quot;J&quot;">  pada <img src="https://habrastorage.org/getpro/habr/post_images/a51/533/990/a5153399048e881eb8661304792b8c81.gif" title="&quot;\ bar {J}&quot;">  dalam metode Newton, konvergensinya memengaruhi, sejumlah besar karya dikhususkan, tetapi dalam hal ini kami tertarik pada aspek lain.  Yaitu, perkiraan seperti itu membutuhkan perhitungan fungsi pada N poin tambahan, dan, di samping itu, fungsi <img src="https://habrastorage.org/getpro/habr/post_images/6c4/afd/100/6c4afd1002ddcfa43d07afbc9f103a9d.gif" title="&quot;\ bar {L} (p) = F (x) + \ bar {J} p&quot;">  pada titik-titik ini <i>interpolasi</i> fungsi <img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="&quot;F&quot;">  , yaitu <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c56/5c9/4b4/c565c94b4a37b9cd5f42fc1be92b2e15.gif" title="&quot;\ bar {L (} h_ {j} e_ {j}) = F (x) + h_ {j} \ dfrac {F (x + h_ {j} e_ {j}) - F (x)} {h_ {j}} = F (x) + F (x + h_ {j} e_ {j}) - F (x) = F (x + h_ {j} e_ {j}). &quot;"><br><br>  Tidak setiap perkiraan dari matriks Jacobi memiliki properti ini, tetapi setiap matriks dari fungsi affine yang memiliki properti ini adalah perkiraan dari matriks Jacobi.  Memang kalau <img src="https://habrastorage.org/getpro/habr/post_images/88f/5c8/dd7/88f5c8dd7e9876a2d0e0980882f261da.gif" title="&quot;F (x + p_ {j}) = F (x) + J (x) p_ {j} + o \ kiri (\ kiri \ Vert p_ {j} \ kanan \ Vert ^ {2} \ kanan)&quot;">  dan <img src="https://habrastorage.org/getpro/habr/post_images/5ad/e1e/ad2/5ade1ead2804a3bfaa8ffdf9122a179a.gif" title="&quot;\ bar {J} p_ {j} = F (x + p_ {j}) - F (x)&quot;">  lalu pada <img src="https://habrastorage.org/getpro/habr/post_images/803/ca4/351/803ca4351b87edf1a13a2a2947772fa7.gif" title="&quot;\ left \ Vert p_ {j} \ kanan \ Vert \ rightarrow0 \ quad \ bar {J} (x) p_ {j} \ rightarrow J (x) p_ {j}&quot;">  .  Properti ini, yaitu, properti interpolasi, memberi kita cara konstruktif untuk menggeneralisasi metode Newton. <br><br>  Biarkan <img src="https://habrastorage.org/getpro/habr/post_images/194/ad1/d42/194ad1d42aa4320679b9498748ceb78d.gif" title="&quot;\ bar {L} (p) = a + Ap&quot;">  - fungsi memenuhi persyaratan <img src="https://habrastorage.org/getpro/habr/post_images/06e/34e/3a7/06e34e3a7a0d0058ef351da74258a637.gif" title="&quot;\ bar {L} (p_ {i}) = F (x + p_ {i})&quot;">  untuk beberapa sistem vektor bebas linear <img src="https://habrastorage.org/getpro/habr/post_images/cf2/deb/64e/cf2deb64e8b0e4d34902a32a5fd93b7b.gif" title="&quot;p_ {i}&quot;">  .  Kemudian fungsi seperti itu disebut fungsi <i>garis potong</i> <img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="&quot;F&quot;">  , dan persamaan yang mendefinisikannya adalah <i>persamaan garis potong</i> .  Jika sistem vektor <img src="https://habrastorage.org/getpro/habr/post_images/cf2/deb/64e/cf2deb64e8b0e4d34902a32a5fd93b7b.gif" title="&quot;p_ {i}&quot;">  selesai (yaitu, ada persis N dari mereka dan mereka masih bebas linear), dan, di samping itu, sistem vektor <img src="https://habrastorage.org/getpro/habr/post_images/94f/cf5/579/94fcf55798902795ffb670e35359d2af.gif" title="&quot;\ left \ {F (x + p_ {i}), i = 1 \ dots N \ right \}&quot;">  kemudian bebas linear <img src="https://habrastorage.org/getpro/habr/post_images/77f/eec/dd2/77feecdd2ae9a4795d2f81f3eec18b1b.gif" title="&quot;\ bar {L}&quot;">  didefinisikan secara unik. <br><br>  Metode apa pun berdasarkan perubahan persamaan lokal <img src="https://habrastorage.org/getpro/habr/post_images/0a0/ec7/804/0a0ec780406efe57ca6444290ccfde09.gif" title="&quot;F (x) = 0&quot;">  persamaan bentuk <img src="https://habrastorage.org/getpro/habr/post_images/ccb/557/80f/ccb55780f0c8e65187b0f4c9126be81c.gif" title="&quot;\ bar {L} (p) = 0&quot;">  dimana <img src="https://habrastorage.org/getpro/habr/post_images/77f/eec/dd2/77feecdd2ae9a4795d2f81f3eec18b1b.gif" title="&quot;\ bar {L}&quot;">  memenuhi <i>persamaan garis potong</i> , yang disebut <i>metode garis potong</i> . <br><br>  Sebuah pertanyaan yang wajar muncul tentang bagaimana membangun garis potong untuk fungsi dengan cara yang paling rasional. <img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="&quot;F&quot;">  .  Garis penalaran berikut nampak jelas: biarkan model affine dibangun pada titik x yang menginterpolasi fungsi yang diberikan pada titik <img src="https://habrastorage.org/getpro/habr/post_images/462/bcf/f32/462bcff32469c0ec5f8ccfc80534c05c.gif" title="&quot;x-x_ {1}, x-x_ {2}, \ dots, x-x_ {N}&quot;">  .  Solusi persamaan <img src="https://habrastorage.org/getpro/habr/post_images/ccb/557/80f/ccb55780f0c8e65187b0f4c9126be81c.gif" title="&quot;\ bar {L} (p) = 0&quot;">  memberi kami poin baru <img src="https://habrastorage.org/getpro/habr/post_images/2c4/a7b/e55/2c4a7be5582848bfbcdd9ee141e7d764.gif" title="&amp; quot; x '= x + p &amp; quot;">  .  Kemudian untuk membangun model affine pada suatu titik <img src="https://habrastorage.org/getpro/habr/post_images/787/cf7/c3a/787cf7c3a3d374114b3a07305b7fa446.gif" title="&amp; quot; x '&amp; quot;">  paling masuk akal untuk memilih titik interpolasi sehingga nilainya <img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="&quot;F&quot;">  sudah diketahui - yaitu, ambil dari set <img src="https://habrastorage.org/getpro/habr/post_images/333/297/225/33329722533f0b608b0994d2a5ba83fa.gif" title="&amp; quot; \ kiri \ {x'-x, x'-x_ {1}, x'-x_ {2}, \ dots, x'-x_ {N} \ kanan \} &amp; quot;">  .  Ada beberapa opsi untuk memilih poin dari yang sebelumnya banyak digunakan.  Misalnya, Anda dapat mengambil titik interpolasi yang ada di dalamnya <img src="https://habrastorage.org/getpro/habr/post_images/bb3/e3a/cd5/bb3e3acd5043b859fe89006d4cabe5a0.gif" title="&quot;\ kiri \ Vert F \ kanan \ Vert&quot;">  paling tidak penting atau hanya yang pertama <img src="https://habrastorage.org/getpro/habr/post_images/055/8e9/3d9/0558e93d918ff32e873b6a71703e9969.gif" title="&quot;N&quot;">  poin.  Dalam hal apapun, tampak jelas itu <img src="https://habrastorage.org/getpro/habr/post_images/95f/756/92b/95f75692ba0aeefcef24ae42714dbc1b.gif" title="&amp; quot; p = x'-x &amp; quot;">  harus dimasukkan dalam banyak titik interpolasi untuk model affine baru.  Begitu seterusnya <img src="https://habrastorage.org/getpro/habr/post_images/f24/8e8/91e/f248e891effc6650d9d31fbefc54cbe4.gif" title="&quot;n&quot;">  langkah-langkah proses iteratif di set kami bisa sampai <img src="https://habrastorage.org/getpro/habr/post_images/f24/8e8/91e/f248e891effc6650d9d31fbefc54cbe4.gif" title="&quot;n&quot;">  perpindahan dibangun di atas titik-titik yang sebelumnya dilewati.  Jika proses dibangun sedemikian rupa sehingga model affine baru tidak lagi digunakan <img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;">  dari nilai sebelumnya, maka proses seperti itu disebut metode garis potong p-point. <br><br>  Sekilas, mungkin tampak bahwa metode garis potong N-point adalah kandidat terbaik untuk peran menggantikan metode Newton, karena metode ini memanfaatkan secara maksimal informasi yang kami peroleh dalam proses penyelesaian, sambil meminimalkan jumlah perhitungan tambahan - kami menggunakan fungsi tersebut N poin terlewati.  Sayangnya, ini tidak benar.  Masalahnya adalah bahwa sistem vektor <img src="https://habrastorage.org/getpro/habr/post_images/ed0/117/8ca/ed01178ca46506fa4588780d16d705a1.gif" title="&quot;F (x_ {0}), F (x_ {1}), \ dots F (x_ {N})&quot;">  keras kepala menolak untuk mandiri secara linear dengan N. cukup besar. Selain itu, bahkan jika kondisi ini ternyata terpenuhi dan model affine yang sesuai masih ada, maka ada kemungkinan bahwa arah <img src="https://habrastorage.org/getpro/habr/post_images/602/ff2/50c/602ff250c473d5b28e08a1453d4175b3.gif" title="&quot;p_ {j} = x_ {j} -x_ {0}&quot;">  juga terbukti independen secara linear, ternyata lebih sedikit.  Dan ini mensyaratkan fakta bahwa model affine, meskipun ada, merosot dan praktis tidak cocok. <br><br>  Secara umum, yang paling stabil adalah metode garis potong 2-point.  Yaitu, metode di mana pada setiap iterasi kita harus menghitung nilai N-1 fungsi tambahan.  Ini jelas tidak cocok untuk tujuan praktis kita. <br><br>  Lalu pertanyaannya adalah - apa semua ini? <br><br><h2>  Metode kuasi-Newtonian untuk memecahkan persamaan </h2><br><br>  Jalan keluarnya sederhana, meski tidak jelas.  Jika kita tidak memiliki kemampuan teknis, berdasarkan nilai yang sudah dihitung, untuk secara unik menentukan model affine yang memenuhi persamaan garis potong, maka itu tidak perlu.  Kami mengambil persamaan garis potong sebagai dasar, tetapi kami akan mengharuskan persamaan hanya terpenuhi untuk beberapa sistem vektor yang tidak lengkap <img src="https://habrastorage.org/getpro/habr/post_images/e5e/f2b/432/e5ef2b43292735aa2a68afffb80bf520.gif" title="&quot;\ kiri \ {p_ {1}, p_ {2}, \ dots, p_ {m} \ kanan \}, m &amp; lt; N&quot;">  .  Dengan kata lain, kami akan mensyaratkan bahwa kondisi interpolasi dipenuhi hanya untuk sejumlah kecil nilai yang diketahui.  Tentu saja, dalam hal ini kita tidak dapat lagi menjamin bahwa matriks yang digunakan dalam model seperti itu akan cenderung ke matriks Jacobi, tetapi kita tidak akan membutuhkan ini.  Menambah ini, model affine harus menginterpolasi fungsi pada titik saat ini, yaitu <img src="https://habrastorage.org/getpro/habr/post_images/3b9/9d1/7fa/3b99d17fa378aeaf36097faef3830bd5.gif" title="&quot;\ bar {L} (0) = F (x)&quot;">  , kami mendapatkan formulasi berikut dari metode garis potong: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/78c/f30/421/78cf304219a4bc90d4f900062bf2d027.gif" title="&quot;\\ \ bar {L} (p_ {i}) = F (x) + Ap_ {i} = F (x + p_ {i}), \ quad i = 1 \ titik m \\ \ bar {L} (p) = 0 \ quad \ Rightarrow p = A ^ {- 1} F (x) &quot;"><br><br>  Bruiden adalah orang pertama yang mempertimbangkan metode semacam ini untuk m = 1, menyebutnya kuasi-Newtonian.  Jelas bahwa kondisi garis potong dalam kasus ini memungkinkan kita untuk mengidentifikasi matriks secara unik <img src="https://habrastorage.org/getpro/habr/post_images/c9d/999/d9a/c9d999d9a4e8bd3d6f8e50519d1dfaa8.gif" title="&quot;A&quot;">  hanya jika kondisi tambahan dikenakan padanya, dan masing-masing kondisi tambahan tersebut menimbulkan metode terpisah.  Bruyden sendiri beralasan sebagai berikut: <br><br>  <i>sebagai gerakan ke arah</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"></i>  <i>dari titik</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/460/82f/7d6/46082f7d6471c3fabb832d8f94075758.gif" title="&quot;x_ {0}&quot;"></i>  <i>to the point</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/1d0/56f/301/1d056f3016bc715aacc23418d8629173.gif" title="&quot;x_ {1}&quot;"></i>  <i>tidak memberi kami informasi tambahan tentang bagaimana fungsi berubah selain</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"></i>  <i>arah, maka efek dari fungsi affine baru pada vektor</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/9fc/c76/a21/9fcc76a21130891ea5d5b10efa979bff.gif" title="q"></i>  <i>harus berbeda dari efek fungsi lama pada vektor yang sama semakin sedikit semakin berbeda</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/9fc/c76/a21/9fcc76a21130891ea5d5b10efa979bff.gif" title="q"></i>  <i>dari</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"></i>  <i>.</i>  <i>Sebagai pilihan terakhir, kapan</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/9fc/c76/a21/9fcc76a21130891ea5d5b10efa979bff.gif" title="q"></i>  <i>ortogonal</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"></i>  <i>, perilaku fungsi baru tidak boleh berbeda dari perilaku yang lama.</i> <i><br></i> <br>  Ide Breiden brilian dalam kesederhanaannya.  Memang, jika kita tidak memiliki informasi baru tentang perilaku fungsi, maka yang terbaik yang bisa kita lakukan adalah berusaha untuk tidak melanggar yang lama.  Kemudian syarat tambahan <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b3/d43/d20/0b3d43d207b144b926274d0c81abccbf.gif" title="&quot;\ bar {L} _ {1} q = \ bar {L} _ {0} q&quot;">  untuk semua <img src="https://habrastorage.org/getpro/habr/post_images/9fc/c76/a21/9fcc76a21130891ea5d5b10efa979bff.gif" title="q">  sedemikian rupa <img src="https://habrastorage.org/getpro/habr/post_images/c16/9f6/315/c169f6315171249a34b50b26a2975c6e.gif" title="&quot;q ^ {T} p = 0&quot;"><br><br>  memungkinkan Anda untuk secara unik menentukan matriks dari transformasi baru - ini diperoleh dengan menambahkan koreksi peringkat 1 ke matriks lama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/522/f36/1f9/522f361f94a7b5a2e9da68094983b21d.gif" title="&quot;\\ A_ {1} = A_ {0} + \ dfrac {(y-A_ {0} p) p ^ {T}} {p ^ {T} p} \\ y = F (x_ {0}) -F (x_ {1}) &quot;"><br><br>  Namun, terlepas dari kesederhanaan dan konsistensi kesimpulan yang dibuat oleh Bruiden, mereka tidak memberikan titik tumpu yang dapat berfungsi sebagai dasar untuk membangun metode serupa lainnya.  Untungnya, ada ungkapan yang lebih formal dari idenya.  Yaitu, matriks dibangun dengan cara ini <img src="https://habrastorage.org/getpro/habr/post_images/147/7e7/ca0/1477e7ca06155c3e43fd4a640e0f7f98.gif" title="&quot;A_ {1}&quot;">  Ternyata menjadi solusi untuk masalah berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/028/96f/3fa/02896f3facb898d70f26abad02fe90a9.gif" title="&quot;\\ \ left \ Vert A_ {1} -A_ {0} \ right \ Vert _ {F} \ rightarrow \ min \\ F (x_ {1}) - Ap = F (x_ {0})&quot;"><br><br>  Kendala tugas tidak lain adalah persamaan garis potong, dan kondisi minimalisasi mencerminkan keinginan kami untuk menyimpan informasi sebanyak mungkin dalam matriks <img src="https://habrastorage.org/getpro/habr/post_images/107/a45/803/107a45803b226180325815eaa7be8706.gif" title="&quot;A_ {0}&quot;">  .  Ukuran perbedaan antara matriks dalam kasus ini adalah norma Frobenius, di mana masalah yang ditimbulkan memiliki solusi yang tidak ambigu.  Formulasi ini dapat berfungsi sebagai titik awal untuk membangun metode lain.  Yaitu, kita dapat mengubah <i>ukuran</i> yang digunakan untuk mengevaluasi perubahan yang diperkenalkan dan memperketat <i>kondisi yang</i> dikenakan pada matriks.  Secara umum, seseorang sudah dapat bekerja dengan rumusan metode seperti itu. <br><br><h2>  Metode Optimasi Kuasi-Newton </h2><br><br>  Setelah memahami ide utama, kami akhirnya dapat kembali ke masalah optimisasi dan memperhatikan bahwa menerapkan rumus Bruyden untuk menghitung ulang model affine tidak sesuai dengan tugas kami dengan baik.  Bahkan, turunan pertama dari fungsi gradien <img src="https://habrastorage.org/getpro/habr/post_images/6b8/82e/be7/6b882ebe727121dcb5fc21b091044b5a.gif" title="&quot;\ bigtriangledown f&quot;">  tidak ada yang lain selain matriks Hessian, yang dengan konstruksi simetris.  Pada saat yang sama, memperbarui menurut aturan Bruyden mengarah ke matriks asimetris <img src="https://habrastorage.org/getpro/habr/post_images/147/7e7/ca0/1477e7ca06155c3e43fd4a640e0f7f98.gif" title="&quot;A_ {1}&quot;">  bahkan jika <img src="https://habrastorage.org/getpro/habr/post_images/107/a45/803/107a45803b226180325815eaa7be8706.gif" title="&quot;A_ {0}&quot;">  simetris.  Ini tidak berarti bahwa metode Bruden tidak dapat diterapkan untuk menyelesaikan persamaan titik stasioner, tetapi berdasarkan pada aturan pembaruan seperti itu, kita tidak mungkin dapat membangun metode optimasi yang baik.  Secara umum, cukup jelas bahwa metode quasi-Newton harus bekerja lebih baik, lebih akurat sistem kondisi masalah menggambarkan spesifikasi matriks Jacobi tertentu. <br><br>  Untuk memperbaiki kekurangan ini, kami menambahkan kendala tambahan untuk masalah minimisasi Bruden, secara eksplisit mensyaratkan bahwa matriks baru simetris bersama dengan yang lama: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/03e/167/aa2/03e167aa25e0f4aa6b8df8546552e79a.gif" title="&quot;\\ \ left \ Vert A_ {1} -A_ {0} \ right \ Vert _ {F} \ rightarrow \ min \\ \ bigtriangledown f (x_ {1}) - Ap = \ bigtriangledown f (x_ {0}} ) \\ A_ {1} ^ {T} = A_ {1} &quot;"><br><br>  Solusi untuk masalah ini adalah <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df8/356/74b/df835674b94bab190bca3c18efed98ce.gif" title="&quot;A_ {1} = A_ {0} + \ dfrac {(y-A_ {0} p) p ^ {T} + p (y-A_ {0} p) ^ {T}} {p ^ {T} p} - \ dfrac {(y-A_ {0} p) ^ {T} p} {\ kiri (p ^ {T} p \ kanan) ^ {2}} pp ^ {T} &quot;"><br><br>  Di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/89c/f84/f29/89cf84f292ed72d1b20755677688a054.gif" title="y = \ bigtriangledown f (x_ {1}) - \ bigtriangledown f (x_ {0})"></a>  , dan rumus perhitungan ulang matriks dinamai penciptanya - Powell, Shanno dan Bruyden (PSB).  Matriks yang dihasilkan simetris, tetapi jelas tidak positif pasti, jika hanya tiba-tiba <img src="https://habrastorage.org/getpro/habr/post_images/6c7/040/47d/6c704047d3148fd7a8b563aaf79dd7f4.gif" title="&quot;y&quot;">  tidak akan menjadi linier <img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;">  .  Dan kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melihat</a> bahwa kepastian positif sangat diinginkan dalam metode optimasi. <br><br>  Sekali lagi, kita akan memperbaiki kondisi masalah, menggunakan kali ini norma Frobenius yang diskalakan sebagai ukuran divergensi matriks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f37/eb1/0f4/f37eb10f4eb10d0c54acc9adab962f10.gif" title="&quot;\\ \ kiri \ Vert T ^ {- T} \ kiri (A_ {1} -A_ {0} \ kanan) T ^ {- 1} \ right \ Vert _ {F} \ rightarrow \ min \\ \ bigtriangledown f (x_ {1}) - Ap = \ bigtriangledown f (x_ {0}) \\ A_ {1} ^ {T} = A_ {1} &quot;"><br><br>  Asal usul pernyataan pertanyaan semacam itu adalah topik besar yang terpisah, tetapi menarik bahwa jika matriks T adalah seperti itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/673/872/131/673872131fa6cb0f44e6839be0e448e7.gif" title="T ^ {T} T = G, Gp = y"></a>  (yaitu, G juga merupakan matriks transformasi affine yang memenuhi persamaan garis potong untuk arah p), maka solusi untuk masalah ini ternyata tidak tergantung pada pilihan T dan mengarah ke rumus pembaruan <br><br><img src="https://habrastorage.org/getpro/habr/post_images/135/ea6/c14/135ea6c14ea8f63f961e83576f1be5d5.gif" title="&quot;A_ {1} = A_ {0} + \ dfrac {(y-A_ {0} p) y ^ {T} + y (y-A_ {0} p) ^ {T}} {y ^ {T} p} - \ dfrac {\ kiri (y-A_ {0} p \ kanan) ^ {T} p} {\ kiri (y ^ {T} p \ kanan) ^ {2}} yy ^ {T} &quot;"><br><br>  dikenal sebagai rumus Davidon-Fletcher-Powell.  Metode pembaruan ini telah terbukti dalam praktiknya, karena memiliki properti berikut: <br><br>  <i>jika</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/e3e/c44/1c1/e3ec441c17e1b43df108a7d8e15d3dd6.gif" title="&quot;y ^ {T} p &amp; gt; 0&quot;"></i>  <i>dan</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/107/a45/803/107a45803b226180325815eaa7be8706.gif" title="&quot;A_ {0}&quot;"></i>  <i>pasti positif</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/147/7e7/ca0/1477e7ca06155c3e43fd4a640e0f7f98.gif" title="&quot;A_ {1}&quot;"></i>  <i>juga diidentifikasi secara positif.</i> <br><br>  Saya perhatikan setelah itu jika kondisi pertama tidak terpenuhi, maka tidak ada fungsi affine dengan matriks pasti positif yang memenuhi persamaan garis potong. <br><br>  Jika dalam masalah yang mengarah ke metode DFP, kami mengambil, sebagai ukuran dari perbedaan model affine, jarak bukan antara matriks itu sendiri, tetapi antara matriks yang terbalik dengan mereka, kami mendapatkan masalah <br><br><img src="https://habrastorage.org/getpro/habr/post_images/337/0b0/af2/3370b0af216ab9695789eeb586cf3604.gif" title="&quot;\\ \ kiri \ Vert T ^ {- T} \ kiri (A_ {1} ^ {- 1} -A_ {0} ^ {- 1} \ kanan) T ^ {- 1} \ kanan \ Vert _ { F} \ rightarrow \ min \\ \ bigtriangledown f (x_ {1}) - Ap = \ bigtriangledown f (x_ {0}) \\ A_ {1} ^ {T} = A_ {1} &quot;&quot;"><br><br>  Solusinya adalah formula terkenal, ditemukan hampir bersamaan oleh Breiden, Fletcher, Goldfarb dan Shanno (BFGS). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3fa/840/c7b/3fa840c7b6ec3de81eb02bb0e9240722.gif" title="&quot;A_ {1} = A_ {0} + \ dfrac {yy ^ {T}} {y ^ {T} p} - \ dfrac {A_ {0} pp ^ {T} A_ {0}} {p ^ { T} A_ {0} p} &quot;"><br><br>  Sampai saat ini, diyakini bahwa perhitungan ulang menurut rumus ini adalah yang paling efisien dari sudut pandang komputasi dan pada saat yang sama kurang rentan terhadap degenerasi matriks dengan sejumlah besar iterasi.  Di bawah kondisi yang sama seperti DFP, rumus ini menjaga properti definiteness positif. <br><br>  Semua metode yang dijelaskan untuk memperbarui matriks memerlukan koreksi peringkat 2. Ini membuatnya mudah dan mudah untuk membalikkan matriks <img src="https://habrastorage.org/getpro/habr/post_images/147/7e7/ca0/1477e7ca06155c3e43fd4a640e0f7f98.gif" title="&quot;A_ {1}&quot;">  menggunakan rumus Sherman-Morrison dan nilainya <img src="https://habrastorage.org/getpro/habr/post_images/5f6/3ac/2d9/5f63ac2d91f47a730fee01b5db38f3bd.gif" title="&quot;A_ {0} ^ {- 1}&quot;">  . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed0/9f8/002/ed09f80027e56f58a3502cc943758509.gif" title="&quot;B_ {1} = B_ {0} + uv ^ {T} \ Rightarrow B_ {1} ^ {- 1} = B_ {0} ^ {- 1} + \ dfrac {B_ {0} ^ {- 1} uv ^ {T} B_ {0} ^ {- 1}} {1 + v ^ {T} B_ {0} ^ {- 1} u} &quot;"><br><br>  asalkan penyebut formula tidak nol.  Saya tidak akan memberikan formula khusus untuk memperbarui matriks terbalik dari metode yang terdaftar, karena mudah ditemukan atau diturunkan secara independen.  Satu-satunya hal yang harus dicatat dalam kasus ini adalah bahwa varian metode dengan memperbarui matriks terbalik biasanya jauh lebih tidak stabil (yaitu, mereka menderita lebih dari kesalahan pembulatan) daripada yang menyarankan memperbarui matriks asli.  Paling efektif untuk memperbarui bukan matriks itu sendiri, tetapi dekomposisi Cholesky (kecuali, tentu saja, dekomposisi seperti itu terjadi), karena opsi implementasi seperti itu lebih stabil secara numerik dan, di samping itu, meminimalkan biaya penyelesaian persamaan yang menentukan arah gerak. <br><br>  Masih mempertimbangkan pertanyaan tentang bagaimana matriks pertama harus terlihat dalam proses kuasi-Newtonian.  Semuanya jelas di sini - semakin dekat ke matriks Hessian atau ke versi yang dikoreksi, jika Hessian tiba-tiba tidak berubah menjadi positif pasti, semakin baik dari sudut pandang konvergensi.  Namun, pada prinsipnya, setiap matriks pasti positif dapat cocok untuk kita.  Versi paling sederhana dari matriks semacam itu adalah satu, dan kemudian iterasi pertama bertepatan dengan iterasi penurunan gradien.  Fletcher dan Powell menunjukkan (secara alami, untuk metode DFP) bahwa jika fungsi kuadrat diminimalkan, terlepas dari matriks mana (positif pasti) yang digunakan sebagai iterasi DFP awal, mereka akan mengarah ke solusi dalam iterasi N persis, di mana N adalah dimensi masalah, dan matriks kuasi-Newtonian bertepatan dengan matriks Hessian pada titik minimum.  Dalam kasus kebahagiaan seperti itu, kita tentu saja tidak akan menunggu, tetapi ini setidaknya memberi alasan untuk tidak terlalu khawatir tentang pilihan yang buruk dari matriks awal. <br><br><h2>  Kesimpulan </h2><br><br>  Pendekatan yang dijelaskan untuk pembangunan metode kuasi-Newtonian bukan satu-satunya yang mungkin.  Paling tidak, para penemu dari metode kuasi-Newtonian yang dijelaskan dan banyak peneliti berikutnya sampai pada formula yang sama berdasarkan pertimbangan yang sangat berbeda.  Namun, menarik bahwa segera setelah metode kuasi-Newtonian tertentu muncul, maka terlepas dari metode memperolehnya, setelah waktu yang agak singkat menjadi jelas bahwa itu adalah solusi untuk beberapa masalah optimasi yang sangat mudah ditafsirkan.    ,           ,       ,      .  ,   ,     , ,         ,    â€”   . <br><br>   ,    ,    ,      ,    ,      ,    .      ,              ,          â€” ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> -</a> . ,           ,        .         ,       .      ,         â€” . <br><br>  ,                  .      ,         ( ,   ,       N ,    ,     ).           (  ,     ,     ),      .   ,   ,             â€” .      â€”    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470638/">https://habr.com/ru/post/id470638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470620/index.html">Infrastruktur sebagai Kode: Cara Mengatasi Masalah dengan XP</a></li>
<li><a href="../id470622/index.html">Tinjauan Umum Metode Pemilihan Fitur</a></li>
<li><a href="../id470628/index.html">Pembuatan kapal simulator ruang angkasa</a></li>
<li><a href="../id470632/index.html">Arend - bahasa tipe dependen berbasis HoTT (bagian 2)</a></li>
<li><a href="../id470634/index.html">Identifikasi lintas komunitas di Instagram untuk mengidentifikasi minat pengguna</a></li>
<li><a href="../id470640/index.html">Sizing Elasticsearch</a></li>
<li><a href="../id470642/index.html">Temui Yandex.Station Mini. Kisah besar perangkat kecil</a></li>
<li><a href="../id470644/index.html">Mengapa blog korporat terkadang suram: beberapa pengamatan dan tips</a></li>
<li><a href="../id470646/index.html">Matematika untuk Ilmu Data. Kursus baru dari OTUS</a></li>
<li><a href="../id470648/index.html">IBM LTO-8 - Cara Mudah untuk Menyimpan Data Dingin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>