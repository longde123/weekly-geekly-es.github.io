<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöè ‚ÅâÔ∏è üöò Tempat kerja pertama atau cara mulai mengembangkan API di Node.js ü•á ü§π ‚õ±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Dalam artikel ini saya ingin berbagi emosi dan keterampilan yang saya peroleh dalam mengembangkan REST API pertama di Node.js menggunaka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tempat kerja pertama atau cara mulai mengembangkan API di Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466745/"><h3>  Pendahuluan </h3><br>  Dalam artikel ini saya ingin berbagi emosi dan keterampilan yang saya peroleh dalam mengembangkan REST API pertama di Node.js menggunakan TypeScript, seperti yang mereka katakan, dari awal.  Ceritanya cukup dangkal: <i>‚ÄúSaya lulus dari universitas, menerima diploma.</i>  <i>Ke mana harus pergi bekerja? "</i>  Seperti yang mungkin Anda tebak, masalahnya tidak terhindar, meskipun saya tidak perlu berpikir terlalu banyak.  Pengembang (lulusan dari spesialisasi yang sama) meminta magang.  Saya percaya bahwa ini adalah praktik yang cukup umum dan ada banyak kisah serupa.  Tanpa berpikir dua kali, saya memutuskan untuk mencoba tangan saya dan pergi ... <br><br><img src="https://habrastorage.org/webt/m5/rl/yq/m5rlyqzlhotg2fxugcj6jr1vozu.png" alt="gambar"><br><br><h3>  Hari pertama  Memperkenalkan Node.js </h3><br>  Saya datang ke pengembangan back-end.  Perusahaan IT ini menggunakan platform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Node.js</a> , yang sama sekali tidak saya kenal.  Saya berlari sedikit ke depan, lupa memberi tahu pembaca bahwa saya belum pernah mengembangkan apa pun dalam JavaScript (kecuali untuk beberapa skrip dengan kode salin).  Saya memahami algoritma pekerjaan dan arsitektur aplikasi web secara keseluruhan, karena saya mengembangkan CRUD di Java, Python dan Clojure, tetapi ini tidak cukup.  Oleh karena itu, hari pertama saya benar-benar mengabdikan diri untuk mempelajari Node.js, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">screencast</a> ini sangat membantu. <br><br>  Saat mempelajari kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Express</a> , manajer paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npm</a> , serta file seperti package.json dan tsconfig.json, kepala saya hanya melihat-lihat jumlah informasi.  Pelajaran lain adalah bahwa menguasai semua materi pada saat yang sama dekat dengan tugas yang mustahil.  Pada akhirnya, saya masih dapat mengkonfigurasi lingkungan dan dapat menjalankan server web ekspres!  Tetapi masih terlalu dini untuk bersukacita, karena dia pulang dengan penuh kesalahpahaman.  Perasaan bahwa saya tenggelam di dunia JS yang luas tidak meninggalkan saya selama satu menit, jadi saya perlu reboot. <br><br><a name="habracut"></a><h3>  Hari kedua  Memperkenalkan TypeScript </h3><br>  Reboot yang sama diikuti pada hari itu juga.  Pada titik ini, saya sepenuhnya menyadari masalah saya, kami akan beralih sedikit lebih rendah.  Mengetahui bahwa itu tidak perlu untuk menulis dalam JavaScipt murni, pelatihan dari Node.js mengalir dengan lancar ke bahasa TypeScript, yaitu, fitur dan sintaksisnya.  Di sini saya melihat tipe yang lama ditunggu-tunggu, yang tanpanya pemrograman secara harfiah 2 hari yang lalu, <b>tidak</b> dalam bahasa pemrograman fungsional.  Ini adalah kesalahpahaman terbesar saya, yang mencegah saya untuk memahami dan mempelajari kode yang ditulis dalam JavaScript pada hari pertama. <br><br>  Dia sebelumnya menulis sebagian besar dalam bahasa pemrograman berorientasi objek seperti Java, C ++, C #.  Menyadari kemungkinan-kemungkinan dari TypeScript, saya merasa nyaman.  Bahasa pemrograman ini benar-benar memberi saya kehidupan di lingkungan yang kompleks ini, seperti yang tampak bagi saya pada waktu itu.  Menjelang akhir hari saya benar-benar mengatur lingkungan, meluncurkan server (sudah ada di TypeScript), menghubungkan perpustakaan yang diperlukan, yang akan saya bahas di bawah ini.  Intinya: siap untuk mengembangkan API.  Kami lolos langsung ke pengembangan ... <br><br><h3>  Pengembangan API </h3><br>  Penjelasan tentang prinsip kerja dan penjelasan lain tentang apa REST API itu, akan kami tinggalkan, karena forum memiliki banyak artikel tentang ini dengan contoh dan pengembangan dalam berbagai bahasa pemrograman. <br><img src="https://habrastorage.org/webt/jv/0k/fz/jv0kfzdektfwbeiyw6ib5cp5pxi.png" alt="gambar"><br><br>  <b>Tugasnya adalah sebagai berikut:</b> <br><br>  Buat layanan dengan REST API.  Otorisasi oleh token pembawa (/ info, / latency, / logout).  CORS yang dikonfigurasi untuk akses dari domain apa pun.  DB - MongoDB.  Buat token di setiap panggilan. <br><br>  <b>Deskripsi API:</b> <br><br><ol><li>  / masuk [POST] - meminta token bearer dengan id dan kata sandi // menerima data dalam json </li><li>  / daftar [POST] - pendaftaran pengguna baru: // menerima data dalam json </li><li>  / info [GET] - mengembalikan id pengguna dan jenis id, memerlukan token yang dikeluarkan oleh pembawa dalam otentikasi </li><li>  / latency [GET] - mengembalikan penundaan (ping), membutuhkan token yang dikeluarkan oleh pembawa dalam otentikasi </li><li>  / logout [GET] - dengan parameter all: true - menghapus semua token pembawa pengguna atau false - hanya menghapus token pembawa saat ini </li></ol><br>  Saya perhatikan segera, tugasnya terlihat sangat sederhana untuk pengembang aplikasi web.  Tetapi tugas itu harus diimplementasikan dalam bahasa pemrograman, yang 3 hari lalu tidak tahu apa-apa!  Bahkan bagi saya, itu terlihat sangat transparan di atas kertas dan dalam Python implementasi membutuhkan waktu sedikit, tetapi saya tidak punya opsi seperti itu.  Tumpukan pengembangan menyebabkan masalah. <br><br><h4>  Sarana implementasi </h4><br>  Jadi, saya menyebutkan bahwa pada hari kedua saya sudah mempelajari beberapa perpustakaan (kerangka kerja), kita akan mulai dari ini.  Untuk perutean, saya memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perute-pengontrol</a> , dipandu oleh banyak kesamaan dengan dekorator dari Spring Framework (Java).  Sebagai ORM, saya memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">typeorm</a> , meskipun bekerja dengan MongoDB dalam mode eksperimental, itu cukup untuk tugas seperti itu.  Saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uuid</a> untuk menghasilkan token, variabel dimuat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.npmjs.com/package/dotenv">dotenv</a> . <br><br><h4>  Startup server web </h4><br>  Biasanya, express digunakan dalam bentuk murni, tetapi saya menyebutkan kerangka Pengendali Routing, yang memungkinkan kita untuk membuat server express sebagai berikut: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Express const app = createExpressServer({ // routePrefix: process.env.SERVER_PREFIX, //  defaults: { nullResultCode: Number(process.env.ERROR_NULL_RESULT_CODE), undefinedResultCode: Number(process.env.ERROR_NULL_UNDEFINED_RESULT_CODE), paramOptions: { required: true } }, //   authorizationChecker: authorizationChecker, // controllers: [UserController] }); //  app.listen(process.env.SERVER_PORT, () =&gt; { console.log(process.env.SERVER_MASSAGE); });</span></span></code> </pre> <br><br>  Seperti yang Anda lihat, tidak ada yang rumit.  Bahkan, kerangka kerja memiliki lebih banyak fitur, tetapi tidak perlu untuk mereka. <br><ul><li>  routePrefix hanyalah awalan di url Anda setelah alamat server, misalnya: <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">localhost</a> : 3000 / awalan</i> </li><li>  default - tidak ada yang menarik, hanya menginisialisasi kode kesalahan </li><li>  otorisasiChecker - peluang bagus untuk kerangka kerja untuk memeriksa otorisasi pengguna, maka kami akan mempertimbangkan secara lebih rinci </li><li>  pengendali adalah salah satu bidang utama tempat kami menentukan pengontrol yang digunakan dalam aplikasi kami </li></ul><br><br><h4>  Koneksi DB </h4><br>  Sebelumnya, kami telah meluncurkan server web, jadi kami akan terus terhubung ke database MongoDB, setelah sebelumnya menyebarkannya di server lokal.  Instalasi dan konfigurasi dijelaskan secara rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> .  Kami akan langsung mempertimbangkan koneksi menggunakan typeorm: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  createConnection({ type: 'mongodb', host: process.env.DB_HOST, database: process.env.DB_NAME_DATABASE, entities: [ User ], synchronize: true, logging: false }).catch(error =&gt; console.log(error));</span></span></code> </pre> <br><br>  Semuanya cukup sederhana, Anda perlu menentukan beberapa parameter: <br><br><ul><li>  ketik - DB </li><li>  host - alamat ip tempat Anda menggunakan basis data </li><li>  database - nama database yang sebelumnya dibuat di mongodb </li><li>  sinkronisasi - sinkronisasi otomatis dengan database <i>(Catatan: sulit untuk menguasai migrasi pada waktu itu)</i> </li><li>  entitas - di sini kami menunjukkan entitas yang melakukan sinkronisasi </li></ul><br><br>  Sekarang kita menghubungkan mulai server dan koneksi ke DB.  Saya perhatikan bahwa impor sumber daya berbeda dari yang klasik yang digunakan di Node.js.  Sebagai hasilnya, kami mendapatkan file yang dapat dieksekusi berikut, dalam kasus saya main.ts: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'reflect-metadata'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dotenv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dotenv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createExpressServer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'routing-controllers'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createConnection } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typeorm'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { authorizationChecker } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./auth/authorizationChecker'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { UserController } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./controllers/UserController'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { User } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./models/User'</span></span>; dotenv.config(); <span class="hljs-comment"><span class="hljs-comment">//  createConnection({ type: 'mongodb', host: process.env.DB_HOST, database: process.env.DB_NAME_DATABASE, entities: [ User ], synchronize: true, logging: false }).catch(error =&gt; console.log(error)); //  Express const app = createExpressServer({ // routePrefix: process.env.SERVER_PREFIX, //  defaults: { nullResultCode: Number(process.env.ERROR_NULL_RESULT_CODE), undefinedResultCode: Number(process.env.ERROR_NULL_UNDEFINED_RESULT_CODE), paramOptions: { required: true } }, //   authorizationChecker: authorizationChecker, // controllers: [UserController] }); //  app.listen(process.env.SERVER_PORT, () =&gt; { console.log(process.env.SERVER_MASSAGE); });</span></span></code> </pre> <br><h4>  Entitas </h4><br>  Biarkan saya mengingatkan Anda bahwa tugasnya adalah untuk mengotentikasi dan mengotorisasi pengguna, masing-masing, kami membutuhkan entitas: Pengguna.  Tapi itu tidak semua, karena setiap pengguna memiliki token dan bukan satu!  Oleh karena itu, perlu untuk membuat entitas Token. <br><br>  <b>Pengguna</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ObjectID } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bson'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { IsEmail, MinLength } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'class-validator'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Column, Entity, ObjectIdColumn } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typeorm'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Token } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Token'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  @Entity() export class User { //  @ObjectIdColumn() id: ObjectID; //Email    @Column() @IsEmail() email: string; //  @Column({ length: 100 }) @MinLength(2) password: string; //  @Column() token: Token; }</span></span></code> </pre> <br>  Di tabel Pengguna, kami membuat bidang - array token yang sangat untuk pengguna.  Kami juga <i>mengaktifkan validator calss</i> , karena pengguna harus masuk melalui email. <br><br>  <b>Token</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Column, Entity } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typeorm'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   @Entity() export class Token { @Column() accessToken: string; @Column() refreshToken: string; @Column() timeKill: number; }</span></span></code> </pre> <br>  Basis adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/ev/xl/pu/evxlpuuo4bajkn8c0ly1klljere.png" alt="gambar"><br><br><h4>  Otorisasi Pengguna </h4><br>  Untuk otorisasi, kami menggunakan <i>otorisasiChecker</i> (salah satu parameter saat membuat server, lihat di atas), untuk kenyamanan, kami meletakkannya di file terpisah: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Action, UnauthorizedError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'routing-controllers'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { getMongoRepository } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typeorm'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { User } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/User'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authorizationChecker</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action: Action</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boolean</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> token: string; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action.request.headers.authorization) { <span class="hljs-comment"><span class="hljs-comment">//   token = action.request.headers.authorization.split(" ", 2); const repository = getMongoRepository(User); const allUsers = await repository.find(); for (let i = 0; i &lt; allUsers.length; i++) { if (allUsers[i].token.accessToken.toString() === token[1]) { return true; } } } else { throw new UnauthorizedError('This user has not token.'); } return false; }</span></span></code> </pre> <br>  Setelah otentikasi, setiap pengguna memiliki token sendiri, sehingga kami dapat memperoleh token yang diperlukan dari header respons, terlihat seperti ini: <i>Bearer 046a5f60-c55e-11e9-af71-c75526de439e</i> .  Sekarang kita dapat memeriksa apakah token ini ada, setelah fungsi mengembalikan informasi otorisasi: true - pengguna diotorisasi, salah - pengguna tidak diotorisasi.  Dalam aplikasi ini, kita dapat menggunakan dekorator yang sangat nyaman di controller: @Authorized ().  Pada titik ini, fungsi otorisasiChecker akan dipanggil, yang akan mengembalikan respons. <br><br><h4>  Logika </h4><br>  Untuk mulai dengan, saya ingin menjelaskan logika bisnis, karena controller adalah satu baris pemanggilan metode di bawah kelas yang disajikan.  Juga, di controller kami akan menerima semua data, dalam kasus kami itu akan menjadi JSON dan Query.  Kami akan mempertimbangkan metode untuk tugas-tugas individual, dan pada akhirnya kami akan membentuk file terakhir, yang disebut UserService.ts.  Saya perhatikan bahwa pada saat itu tidak ada cukup pengetahuan untuk menghilangkan ketergantungan.  Jika Anda belum memenuhi istilah dependensi injeksi, saya sangat merekomendasikan untuk membacanya.  Saat ini saya menggunakan kerangka kerja DI, yaitu, saya menggunakan wadah, yaitu injeksi melalui konstruktor.  Di sini, saya pikir, adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://">artikel yang</a> bagus untuk ditinjau.  Kami kembali ke tugas. <br><br><ul><li>  <b>/ signin [POST]</b> - otentikasi dari pengguna terdaftar.  Semuanya sangat sederhana dan transparan.  Kami hanya perlu menemukan pengguna ini di database dan mengeluarkan token baru.  Untuk membaca dan menulis, MongoRepository digunakan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> userSignin(user: User): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;string&gt; { <span class="hljs-comment"><span class="hljs-comment">// Mongo repository const repo = getMongoRepository(User); //       let userEmail = await repo.findOne({ email: user.email, password: user.password }); if (userEmail) { //  userEmail = await this.setToken(userEmail); //    repo.save(userEmail); return userEmail.token.accessToken; } return process.env.USER_SERVICE_RESPONSE; }</span></span></code> </pre> </li><li>  <b>/ daftar [POST]</b> - daftarkan pengguna baru.  Metode yang sangat mirip, karena pada awalnya kami juga mencari pengguna sehingga kami tidak memiliki pengguna terdaftar dengan satu email.  Selanjutnya, kami menulis pengguna baru ke database, setelah mengeluarkan token. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> userSignup(newUser: User): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;string&gt; { <span class="hljs-comment"><span class="hljs-comment">// Mongo repository const repo = getMongoRepository(User); //   email (   2    email) const userRepeat = await repo.findOne({ email: newUser.email }); if (!userRepeat) { //  newUser = await this.setToken(newUser); //   const addUser = getMongoManager(); await addUser.save(newUser); return newUser.token.accessToken; } else { return process.env.USER_SERVICE_RESPONSE; } }</span></span></code> </pre> </li><li>  <b>/ info [GET]</b> - mengembalikan id pengguna dan jenis id, memerlukan token yang dikeluarkan oleh pembawa dalam otentikasi.  Gambar juga transparan: pertama kita mendapatkan token pengguna saat ini dari header permintaan, kemudian mencarinya di database dan menentukan kepada siapa itu terletak, dan mengembalikan pengguna yang ditemukan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getUserInfo(req: express.Request): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;User&gt; { <span class="hljs-comment"><span class="hljs-comment">// Mongo repository const repository = getMongoRepository(User); //    const user = await this.findUser(req, repository); return user; } private async findUser(req: express.Request, repository: MongoRepository&lt;User&gt;): Promise&lt;User&gt; { if (req.get(process.env.HEADER_AUTH)) { //  const token = req.get(process.env.HEADER_AUTH).split(' ', 2); //    const usersAll = await repository.find(); //  for (let i = 0; i &lt; usersAll.length; i++) { if (usersAll[i].token.accessToken.toString() === token[1]) { return usersAll[i]; } } } }</span></span></code> </pre> <br></li><li>  <b>/ latency [GET]</b> - mengembalikan penundaan (ping), membutuhkan token yang dikeluarkan oleh pembawa dalam otentikasi.  Paragraf artikel yang sama sekali tidak menarik.  Di sini saya hanya menggunakan perpustakaan yang sudah jadi untuk memeriksa penundaan tcp-ping. <br><br><pre> <code class="javascript hljs">getLatency(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;IPingResult&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">progress: number, total: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(progress, <span class="hljs-string"><span class="hljs-string">'/'</span></span>, total); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latency = ping({ <span class="hljs-attr"><span class="hljs-attr">address</span></span>: process.env.PING_ADRESS, <span class="hljs-attr"><span class="hljs-attr">attempts</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(process.env.PING_ATTEMPTS), <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(process.env.PING_PORT), <span class="hljs-attr"><span class="hljs-attr">timeout</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(process.env.PING_TIMEOUT) }, update).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'ping result:'</span></span>, result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> latency; }</code> </pre></li><li>  <b>/ logout [GET]</b> - dengan parameter all: true - menghapus semua token pembawa pengguna atau false - hanya menghapus token pembawa saat ini.  Kami hanya perlu menemukan pengguna, memeriksa parameter kueri dan menghapus token.  Saya pikir semuanya harus jelas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> userLogout(all: boolean, <span class="hljs-attr"><span class="hljs-attr">req</span></span>: express.Request): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// Mongo repository const repository = getMongoRepository(User); //    const user = await this.findUser(req, repository); if (all) { // true    user.token.accessToken = process.env.GET_LOGOUT_TOKEN; user.token.refreshToken = process.env.GET_LOGOUT_TOKEN; //  repository.save(user); } else { // false    user.token.accessToken = process.env.GET_LOGOUT_TOKEN; //  repository.save(user); } }</span></span></code> </pre> </li></ul><br><br><h4>  Pengendali </h4><br>  Banyak yang tidak perlu menjelaskan apa yang dibutuhkan dan bagaimana controller digunakan dalam pola MVC, tapi saya masih akan mengatakan dua kata.  Singkatnya, pengontrol adalah tautan antara pengguna dan aplikasi yang mengalihkan data di antara mereka.  Logikanya sepenuhnya dijelaskan di atas, metode yang dipanggil sesuai dengan rute, terdiri dari URI dan server ip <i>(contoh: localhost: 3000 / masuk)</i> .  Saya sebutkan sebelumnya tentang dekorator di controller: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Dapatkan</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">POST</a> , @Authorized dan yang paling penting adalah @JsonController.  Fitur lain yang sangat penting dari kerangka kerja ini adalah bahwa jika kita ingin mengirim dan menerima JSON, maka kita menggunakan dekorator ini daripada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Pengontrol</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> express <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Authorized, Body, Get, Header, JsonController, NotFoundError, Post, QueryParam, Req, UnauthorizedError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'routing-controllers'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { IPingResult } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@network-utils/tcp-ping'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { User } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/User'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { UserService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../services/UserService'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    JSON @JsonController() export class UserController { userService: UserService //  constructor() { this.userService = new UserService(); } //  @Post('/signin') async login(@Body() user: User): Promise&lt;string&gt; { const responseSignin = await this.userService.userSignin(user); if (responseSignin !== process.env.USER_SERVICE_RESPONSE) { return responseSignin; } else { throw new NotFoundError(process.env.POST_SIGNIN_MASSAGE); } } //  @Post('/signup') async registrateUser(@Body() newUser: User): Promise&lt;string&gt; { const responseSignup = await this.userService.userSignup(newUser); if (responseSignup !== process.env.USER_SERVICE_RESPONSE) { return responseSignup; } else { throw new UnauthorizedError(process.env.POST_SIGNUP_MASSAGE); } } //   @Get('/info') @Authorized() async getId(@Req() req: express.Request): Promise&lt;User&gt; { return this.userService.getUserInfo(req); } //   @Authorized() @Get('/latency') getPing(): Promise&lt;IPingResult&gt; { return this.userService.getLatency(); } @Get('/logout') async deleteToken(@QueryParam("all") all: boolean, @Req() req: express.Request): Promise&lt;void&gt; { this.userService.userLogout(all, req); } }</span></span></code> </pre> <br><h4>  Kesimpulan </h4><br>  Dalam artikel ini, saya ingin mencerminkan tidak lagi komponen teknis dari kode yang benar atau sesuatu seperti itu, tetapi hanya untuk berbagi fakta bahwa seseorang dapat membangun aplikasi web menggunakan database dan mengandung setidaknya beberapa logika dari nol absolut dalam <b>lima</b> hari.  Coba pikirkan, tidak ada instrumen yang familier, ingat diri Anda atau letakkan saja di tempat saya.  Dalam kasus ini tidak ada kasus yang mengatakan: "Saya yang terbaik, Anda tidak akan pernah bisa melakukan itu."  Sebaliknya, ini adalah seruan dari jiwa seseorang yang saat ini benar-benar senang dengan dunia Node.js dan berbagi ini dengan Anda.  Dan kenyataan bahwa tidak ada yang mustahil, Anda hanya perlu mengambil dan melakukan! <br><br>  Tentu saja, tidak dapat dipungkiri bahwa penulis tidak tahu apa-apa dan duduk untuk menulis kode untuk pertama kalinya.  Tidak, pengetahuan tentang OOP, prinsip-prinsip API REST, ORM, dan basis data ada dalam jumlah yang cukup.  Dan ini hanya bisa mengatakan bahwa cara untuk mencapai hasil sama sekali tidak memainkan peran apa pun dan berkata dalam gaya: "Saya tidak akan pergi ke pekerjaan ini, ada bahasa pemrograman yang saya tidak pelajari", bagi saya sekarang itu hanya manifestasi seseorang bukan dari kelemahan, melainkan perlindungan dari lingkungan eksternal yang tidak dikenal.  Tapi apa yang ada untuk disembunyikan, rasa takut itu hadir dengan saya. <br><br>  Untuk meringkas.  Saya ingin menasihati siswa dan orang-orang yang belum memulai karir mereka di bidang TI, tidak perlu takut akan alat pengembangan dan teknologi yang tidak dikenal.  Kawan-kawan senior pasti akan membantu Anda (jika Anda beruntung juga saya), mereka akan menjelaskan secara terperinci dan menjawab pertanyaan, karena masing-masing dari mereka ada di posisi ini.  Tetapi jangan lupa bahwa keinginan Anda adalah aspek yang paling penting! <br><br>  Tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466745/">https://habr.com/ru/post/id466745/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466733/index.html">Selamat datang di DINS Java EVENING 18 September</a></li>
<li><a href="../id466735/index.html">Cara mudah untuk membuat peringatan suara di sistem Home Automation ("Smart Home")</a></li>
<li><a href="../id466737/index.html">Mengapa jaringan sosial Google+ gagal</a></li>
<li><a href="../id466739/index.html">Yang terbaik adalah musuh dari yang baik</a></li>
<li><a href="../id466741/index.html">Yang terbaik adalah musuh dari yang baik</a></li>
<li><a href="../id466747/index.html">Mitap pengembang iOS di Redmadrobot</a></li>
<li><a href="../id466753/index.html">Administrasi Jaringan Cepat dan Efisien - Jaringan MACMonitor</a></li>
<li><a href="../id466755/index.html">Komputer akan membuat Anda enak</a></li>
<li><a href="../id466757/index.html">Mitap Flutter pertama di St. Petersburg - 26 September</a></li>
<li><a href="../id466759/index.html">Tentang hosting program afiliasi perusahaan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>