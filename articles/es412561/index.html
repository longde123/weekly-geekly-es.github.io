<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜò üêà ‚ñ´Ô∏è Ingenier√≠a inversa del firmware del dispositivo utilizando el ejemplo de un "rinoceronte" intermitente. Parte 2 üëÜüèæ üêØ üå´Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Presentamos a su atenci√≥n la segunda parte del art√≠culo sobre ingenier√≠a inversa del firmware del dispositivo Flashing Rhino basado en un taller en la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ingenier√≠a inversa del firmware del dispositivo utilizando el ejemplo de un "rinoceronte" intermitente. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/inforion/blog/412561/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/yo/jz/nyyojzktr_-hcfv4j7ygq_eaiuu.png"></div><br>  Presentamos a su atenci√≥n la segunda parte del art√≠culo sobre ingenier√≠a inversa del firmware del dispositivo Flashing Rhino basado en un taller en la conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SMARTRHINO-2018</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">En la primera parte del</a> art√≠culo, el firmware del dispositivo se carg√≥ en el desensamblador IDA y se realiz√≥ un an√°lisis inicial de los comandos de protocolo del dispositivo.  Los comandos individuales se probaron en un dispositivo que funciona. <br><br>  En la segunda parte, se realizar√° un an√°lisis de las tareas de firmware restantes. <br><br>  Perm√≠tame recordarle que, despu√©s de analizar la tarea de Bluetooth en t√©rminos de control de LED, se decidi√≥ cambiar a la tarea de LED, ya que la tarea inicial era crear una aplicaci√≥n para controlar los LED, y para esto es necesaria una comprensi√≥n detallada de la operaci√≥n del firmware. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El archivo de firmware</a> est√° disponible para estudio independiente. <br><br>  <i>Toda la informaci√≥n se proporciona solo con fines educativos.</i> <br><br>  Debajo del gato hay muchos rinocerontes intermitentes. <br><a name="habracut"></a><br><h2>  Tarea LED </h2><br>  <i>Brevemente: un an√°lisis completo de la tarea responsable de cambiar los LED.</i>  <i>An√°lisis de tipos de datos y variables globales.</i> <br><br>  La tarea de LED est√° representada por la funci√≥n <b>x_leds_task</b> , ubicada en <code>0x08005A08</code> . <br><br>  Adem√°s de las l√≠neas extra√±as "Tengo una superpotencia ..." en la funci√≥n principal de la tarea de LED, puede prestar atenci√≥n a la l√≠nea <b>"hue&gt; max: change shine \ r \ n"</b> . <br><br><img src="https://habrastorage.org/webt/6j/7u/qv/6j7uqvcupizmfsbqca81as5dwlw.png"><br><br>  Al mismo tiempo, vemos una situaci√≥n familiar: (PALABRA *) (v26 + 4).  En el men√∫ contextual de la variable v26, seleccione el elemento "Convertir a estructura *", luego indique la estructura creada anteriormente: <br><br><img src="https://habrastorage.org/webt/6a/2i/jv/6a2ijvqm631yl3ce5z6uom02znw.png"><br><br>  Dado que <code>v5 = v26</code> , repetimos la operaci√≥n <i>"Convertir a estructura *"</i> para la variable v5. <br><br>  Continuamos estructurando el c√≥digo y los datos.  Establecer la representaci√≥n hexadecimal en todas partes.  Renombrar: <br><br><ul><li>  v5 - <b>led</b> ; </li><li>  v6 - <b>idx</b> ; </li><li>  v8 - <b>hue_1</b> ; </li><li>  v9 - <b>hue_2</b> ; </li><li>  v26 - <b>_led</b> ; </li></ul><br>  El c√≥digo est√° mejorando.  Pero algunas variables todav√≠a duelen la vista, por ejemplo, la variable v23: <br><br><img src="https://habrastorage.org/webt/pz/cp/ch/pzcpchfjgrlwgwwtbun85x6weve.png"><br><br><img src="https://habrastorage.org/webt/k1/4k/fi/k14kfil99uzjgtwdpimtjcrl-ye.png"><br><br><div class="spoiler">  <b class="spoiler_title">Aparentemente, v23 es una matriz de 4 bytes.</b> <div class="spoiler_text">  idx es el √≠ndice del LED;  este √≠ndice se agrega a la direcci√≥n base;  de esta manera, se hace acceso a elementos en los mismos desplazamientos; as√≠ es como se comportan las matrices. <br></div></div><br>  Asignamos el tipo <code>char v23[4]</code> y le <b>cambiamos el</b> nombre a <b>leds_smth</b> , el c√≥digo se vuelve m√°s bonito: <br><br><img src="https://habrastorage.org/webt/3a/zp/vv/3azpvvasy-8oabd8be6tshcy6z8.png"><br><br>  Tambi√©n puede observar que el resultado de la funci√≥n x_queue_recv se devuelve a la variable v25: <br><br><pre> <code class="cpp hljs">x_queue_recv(&amp;v25, leds_queue, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Pero puede que no est√© claro c√≥mo est√°n los datos que necesita en la estructura <i>_led</i> .  El hecho es que las variables v25 y _led <b><i>est√°n ubicadas cerca de la pila</i></b> ; esto se puede entender por el hecho de que en el descompilado se escriben en l√≠neas adyacentes.  La ubicaci√≥n de las variables en la pila se puede ver en una ventana separada si hace doble clic en la variable: <br><br><img src="https://habrastorage.org/webt/gm/1z/qs/gm1zqsoxvvppvneguj76arsppdu.png"><br><br>  Probablemente son una estructura, o el compilador ha realizado alguna optimizaci√≥n.  Por lo tanto, se puede argumentar que los datos de la tarea Bluetooth se transmiten a la tarea LED.  Para averiguarlo con mayor precisi√≥n, comprobar√© el dispositivo; para el LED cero a trav√©s de Bluetooth, enviar√© los valores <b>0x208</b> , <b>0x2D0</b> , <b>0x398</b> , <b>0x3E9</b> , que podr√≠an observarse en el c√≥digo: <br><br><img src="https://habrastorage.org/webt/f-/1k/ds/f-1kdsphlzdbhuc4q6dwtfk6zge.png"><br><br>  Los resultados de verificar el valor de tono en el dispositivo: <br><br><ul><li>  0x208: los LED dejaron de cambiar sin problemas y se configuraron en los colores: rojo, verde, azul, p√∫rpura; </li><li>  0x2D0: los LED comenzaron a cambiar nuevamente; </li><li>  0x398: nada ha cambiado; </li><li>  0x3E9: nada ha cambiado. </li></ul><br>  Si vuelve a mirar el c√≥digo, puede ver que el valor 0x398 se puede asociar l√≥gicamente con un valor menor que 0x167 (se establecen valores diferentes para el elemento de matriz <i>leds_smth</i> ).  Por lo tanto, realizar√© esta verificaci√≥n: primero, establecer√© el primer LED en verde (tono = 0x78, <code>LED 010078FF20</code> ), mientras que los otros tres LED contin√∫an <code>LED 010078FF20</code> sus colores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5h/mp/dc/5hmpdckwscpkhlgvth05w1xvmuy.gif"></div><br>  Ahora <code>LED 010398FFFF</code> protocolo Bluetooth <code>LED 010398FFFF</code> - despu√©s de esto, el primer LED ha cambiado al modo de cambio de color general. <br><br>  Por lo tanto, el valor de tono de 0x398 restablece el valor de color est√°tico, lo que significa que la matriz leds_smth contiene banderas (0 o 1) para que los LED est√©n ocupados: <br><br><ul><li>  0: el LED no est√° ocupado, participa en un cambio de color suave ( <b>tono = 0x398</b> ); </li><li>  1 - el LED est√° ocupado, el usuario establece un color est√°tico ( <b>tono &lt;= 0x167</b> ). </li></ul><br>  Cambie el nombre de leds_smth a <b>leds_busy</b> . <br><br>  Ahora el prop√≥sito del siguiente bloque de c√≥digo deber√≠a quedar claro: <br><br><img src="https://habrastorage.org/webt/sb/x8/mf/sbx8mfnnah6gziclrsqmgdcmpu0.png"><br><br>  El ciclo en las l√≠neas 83-101 realiza un mosaico de color suave con un paso de cambio de color de 5: <code>v12 += 5</code> .  Si el LED tiene un color est√°tico encendido, entonces este LED no participa en el mosaico.  Despu√©s del ciclo hay l√≠neas de inclusi√≥n a corto plazo de todos los LED. <br><br>  Renombrar: <br><br><ul><li>  sub_800678A - <b>x_led_set_hsv</b> ; </li><li>  v12 - <b>hue_step</b> ; </li><li>  v13, v17, v18, v19 - <b>led0_busy</b> , <b>led1_busy</b> , <b>led2_busy</b> , <b>led3_busy</b> ; </li><li>  v11, v20, v21, v22 - <b>hue0</b> , <b>hue1</b> , <b>hue2</b> , <b>hue3</b> ; </li><li>  dword_200004C4 - <b>led_control</b> . </li></ul><br>  La funci√≥n sub_80039FE presumiblemente realiza un tiempo de espera (de lo contrario, los LED no cambiaron sin problemas, pero al instante), llam√©moslo <b>x_sleep</b> , y la variable v16 es <b>led_timeout</b> . <br><br>  El prop√≥sito de la funci√≥n sub_8006934 a√∫n no es obvio, pero se usa en todas partes despu√©s de configurar el color en los LED; puede llamarlo <b>x_led_fix_color</b> . <br><br>  Despu√©s de estos <b>cambios de</b> nombre, es f√°cil entender la funci√≥n <b>sub_8006944</b> (llamada en la rama hue &lt;= 0x167): <br><br><img src="https://habrastorage.org/webt/nf/8a/j-/nf8aj-jzfsk9livqh_zxpwtojgq.png"><br><br>  Simplemente realiza una verificaci√≥n adicional para determinar el color del LED.  Cambie el nombre de la funci√≥n sub_8006944 a <b>x_led_set_hsv_wrap</b> (sufijo <i>_wrap</i> - una explicaci√≥n de que esto es un "contenedor" sobre otra funci√≥n) y configure el siguiente prototipo para ella: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_led_set_hsv_wrap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_control, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">signed</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span></span></code> </pre> <br>  Volvamos un nivel a la funci√≥n x_leds_task.  Una vez m√°s, mirando el c√≥digo, puede encontrar que la rama "hue&gt; 0x3E8" comenz√≥ a verse as√≠: <br><br><img src="https://habrastorage.org/webt/sh/tm/5j/shtm5jrmecd3quimykrcgognngs.png"><br><br>  Es decir, un valor de tono mayor que 0x3E8 deber√≠a cambiar el tiempo de espera del mosaico coloreado.  Lo comprobar√© enviando algunos valores al dispositivo: <br><br><ul><li>  hue = 0x3E9: los LED comenzaron a cambiar r√°pidamente: <br><br><img src="https://habrastorage.org/webt/1z/an/to/1zantozqcbgf0ho69jmgbvdd8v8.gif"><br></li><li>  hue = 0xFFFF - los LED comenzaron a cambiar muy lentamente: <br><br><img src="https://habrastorage.org/webt/jr/ty/sn/jrtysngekw8_1ise6uwd0kikrhc.gif"><br></li></ul><br>  Al salir del ciclo principal de la tarea LED, se <b>usa la</b> funci√≥n <b>sub_8003C44</b> , que tambi√©n se usa en la funci√≥n sub_8005070: <br><br><img src="https://habrastorage.org/webt/ow/ws/ql/owwsqly9wu0bhmwzhu3r7buky5s.png"><br><br>  Renombrar: <br><br><ul><li>  sub_8005070 - <b>x_freeMsg</b> ; </li><li>  sub_8003C44 - <b>x_free_queue</b> . </li></ul><br>  Adem√°s en la tarea de LED, la siguiente rama no puede dejar de llamar la atenci√≥n: <br><br><img src="https://habrastorage.org/webt/iu/q6/rr/iuq6rrf54hzoupmpslmnp0r8pcu.png"><br><br>  Puede intentar ejecutar el comando <code>LED B816D8D90000FFFF</code> .  Pero si recuerda que solo se toman 2 caracteres como √≠ndice LED, un intento de alcanzar este c√≥digo obviamente no tendr√° √©xito.  Deja este hilo para m√°s tarde.  Cambie el nombre de la funci√≥n sub_8004AE8 a <b>x_mad_blinking</b> , y es hora de arreglar la firma de la funci√≥n <b>x_printf</b> (la √∫ltima vez que escrib√≠ la firma incorrecta): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_printf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *format, ...)</span></span></span></span></code> </pre> <br>  El ciclo principal de la tarea LED se desmonta, pero todav√≠a hay un c√≥digo al comienzo de la tarea. <br><br>  Miremos el c√≥digo: <br><br><img src="https://habrastorage.org/webt/kt/xx/wn/ktxxwnzjvx9eqkkuiydzlro3vz4.png"><br><br>  En la l√≠nea 49, lo m√°s probable es que se verifique la disponibilidad de los LED y, en caso de error, se realice una llamada a la funci√≥n sub_8004BBC, que apaga las interrupciones e inicia un bucle infinito en el que se usa la l√≠nea "../Drivers/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_gpio.c".  Lo m√°s probable es que sea una <b>afirmaci√≥n</b> o funci√≥n similar. <br><br>  Renombrar: <br><br><ul><li>  sub_8004BBC - <b>x_gpio_assert</b> ; </li><li>  sub_800698C - <b>x_check_gpio</b> . </li></ul><br>  El prop√≥sito de la funci√≥n <b>sub_8006968</b> quedar√° claro si observa cuidadosamente el dispositivo cuando est√° encendido: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i8/ap/t4/i8apt4kjg6rrbu73wzya5noyx6m.gif"></div><br>  Los cuatro LED juntos se encienden primero en rojo, luego en verde y luego en azul.  Despu√©s de eso, se establecen por color: 0-rojo, 1-verde, 2-azul, 3-violeta.  Y solo entonces comienzan a cambiar de mosaico. <br><br>  Dado que el mosaico comienza en el ciclo de tareas principal, es l√≥gico que las l√≠neas 58-61 antes del ciclo principal sean responsables de la inclusi√≥n a corto plazo de diferentes colores en los LED, y las l√≠neas 52-56 son responsables de configurar el rojo, el verde y el azul en todos los LED a la vez.  Cambie el nombre de la funci√≥n sub_8006968 a <b>x_led_all_set_rgb</b> (RGB, <b>simplemente</b> en una corazonada, de acuerdo con los argumentos pasados). <br><br><h2>  Rarezas en la tarea de LED </h2><br>  <i>Brevemente: definir la funcionalidad del c√≥digo que contiene l√≠neas extra√±as.</i>  <i>Generando una contrase√±a para el dispositivo.</i> <br><br>  Ahora pasemos al comienzo de la funci√≥n x_leds_task: <br><br><img src="https://habrastorage.org/webt/k1/64/2j/k1642jmvbxu5d0a7vs5lrtd3pru.png"><br><br>  <b>"Eraze"</b> , <b>"gen"</b> , <b>"flash"</b> , <b>"reset"</b> - ¬øpor qu√© es todo esto? <br><br>  Tratemos de resolverlo. <br><br>  Deje que sub_80066BC sea <b>x_leds_task_init</b> . <br><br>  Veamos sub_8006B38: <br><br><img src="https://habrastorage.org/webt/qa/80/ez/qa80ezojcnsyo_vz_q1hru7whz8.png"><br><br>  Memset de agua pura, ¬øde acuerdo? <br><br><img src="https://habrastorage.org/webt/pf/oa/tf/pfoatfwwwasjk338b3lphqiiya4.png"><br><br>  Volver a x_leds_task.  Algo est√° mal con el tipo de variable v24: <br><br><img src="https://habrastorage.org/webt/vg/ag/8u/vgag8ujkoylag2iryzujjvjldfu.png"><br><br>  La IDA cometi√≥ un peque√±o error con el tipo, pero un comentario con una marca de pila nos ayuda.  Entre las variables v24 y v25 hasta 12 bytes (0x44 - 0x38).  Por lo tanto, cambiamos el nombre de v24 a <b>buf</b> y asignamos el tipo <code>unsigned __int8 buf[12]</code> (Ida advertir√° que el nuevo tipo de datos es m√°s grande que el anterior; estamos de acuerdo). <br><br>  Siguiente  Funci√≥n sub_8004CE4: <br><br><img src="https://habrastorage.org/webt/sc/qg/tw/scqgtwrqr1vzlaubtsqstydsqmu.png"><br><br>  Cambie el nombre de <i>a1</i> a <b>buf</b> , <i>v1</i> a <b>_buf</b> . <br><br>  Funci√≥n sub_8006B26: <br><br><img src="https://habrastorage.org/webt/gs/du/ff/gsduffmdls272wqpmmv6_klqxdm.png"><br><br>  ¬øLa reconociste? <br><br><div class="spoiler">  <b class="spoiler_title">¬øY si sin maquillaje?</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/8k/1d/p9/8k1dp9nmxkl0xjktjtsk_cp2vem.png"><br>  Por supuesto <b>memcpy</b> .  Renombrar <br></div></div><br>  Entonces, el prop√≥sito de la funci√≥n sub_8004CE4 es obtener algunos datos en la direcci√≥n <b>0x08007C00</b> .  Por cierto, esta direcci√≥n est√° en el rango de direcciones de la memoria flash del microcontrolador (y el firmware, en particular).  Cambie el nombre de sub_8004CE4 a <b>x_read_data_0x08007C00</b> . <br><br>  X_leds_task Function Line 36: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">65</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0x19</span></span> )</code> </pre> <br>  Cambie la visualizaci√≥n de datos (tecla R en el n√∫mero 65, tecla H en el n√∫mero 0x19): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'A'</span></span> &gt; <span class="hljs-number"><span class="hljs-number">25</span></span> )</code> </pre> <br>  Despu√©s de una peque√±a reflexi√≥n, puede comprender que esta es una prueba del rango del alfabeto latino AZ. <br><br>  A continuaci√≥n, utilizando las indicaciones en forma de cadenas de formato, cambie el nombre de: <br><br><ul><li>  sub_8004C10 - <b>x_erase</b> ; </li><li>  sub_80059C8 - <b>x_gen</b> ; </li><li>  sub_8004C84 - <b>x_flash</b> . </li></ul><br>  La funci√≥n sub_8003C66 no hace nada notable: solo aumenta algunas variables globales: cambie el nombre de sub_8003C66 a <b>x_smth_inc</b> . <br><br>  La funci√≥n <b>x_erase en</b> realidad no acepta ning√∫n argumento; esto se puede verificar en el desensamblador: <br><br><img src="https://habrastorage.org/webt/rv/p3/_i/rvp3_iqmhzsegjqyi3mugvpxnis.png"><br><br>  Dentro de x_erase, se usa la direcci√≥n familiar 0x08007C00 y se accede a tres funciones desconocidas: <br><br><img src="https://habrastorage.org/webt/ys/nb/_b/ysnb_bfgd19htkrnmbyo5hudr0m.png"><br><br>  Un <b>vistazo r√°pido</b> a estas tres funciones, vemos que est√°n accediendo a direcciones en el rango <b>0x40022000 - 0x400223FF</b> .  La documentaci√≥n para el microcontrolador establece claramente que este es el rango de <b>"Interfaz FLASH"</b> .  Es decir, la funci√≥n x_erase borra un trozo de memoria flash, ¬°genial! <br><br>  Aparentemente, la funci√≥n x_flash escribe en la memoria flash, despu√©s de verificar la longitud de la l√≠nea para escribir (por cierto, los argumentos a2 y a3 son superfluos aqu√≠; ayudaremos a Idea): <br><br><img src="https://habrastorage.org/webt/ki/di/zi/kidizigfv5lb6bwg24aspkgvxmw.png"><br><br>  ¬øY todo esto sucede en el "dispositivo de iluminaci√≥n"? <br><br>  Bueno, ¬øqu√© pasa con la funci√≥n <b>x_gen</b> ?  Despu√©s de un vistazo r√°pido y cambiar el nombre de las variables, se ver√° as√≠: <br><br><img src="https://habrastorage.org/webt/v3/js/nb/v3jsnb8jb36wstn3obcln2c3pvk.png"><br><br>  La funci√≥n <b>sub_8006CB4 se</b> ve as√≠: <br><br><img src="https://habrastorage.org/webt/ub/h1/rk/ubh1rki0ikjrygsiqcx9vuwylxc.png"><br><br>  Y <b>sub_8006D10</b> , as√≠: <br><br><img src="https://habrastorage.org/webt/gp/qy/oc/gpqyocts_ubcd4u3ep9koyrcb0o.png"><br><br>  No contenga el deseo de buscar en Internet estas constantes indecentemente bellas: <b>0xABCD</b> , <b>0x1234</b> , <b>0xE66D</b> , <b>0xDEEC</b> , <b>0x4C957F2D</b> y <b>0x5851F42D</b> .  Si Internet a√∫n no est√° completamente prohibido, probablemente encontrar√° estas constantes en la fuente de <b>funciones aleatorias</b> .  No es de extra√±ar que la funci√≥n principal se llame x_gen. <br><br>  Esta tambi√©n es una situaci√≥n muy t√≠pica: llame a srand () antes del ciclo y llame al azar () en el ciclo, as√≠ que c√°mbiele el nombre: <br><br><ul><li>  sub_8006D10 - x_rand; </li><li>  sub_8006CB4 - x_srand. </li></ul><br>  Un lector curioso, al examinar la funci√≥n <b>sub_8005098</b> , puede averiguar de <i>d√≥nde proviene la semilla</i> para la funci√≥n srand. <br><br>  Por lo tanto, la funci√≥n x_gen genera <b>una cadena aleatoria del tama√±o especificado</b> . <br><br>  Despu√©s de que la l√≠nea generada se escribe en la memoria flash, el dispositivo se reinicia: <br><br><img src="https://habrastorage.org/webt/a9/ta/rr/a9tarrhqqc-jj7g-e-dplvr67py.png"><br><br>  Parece una especie de reinicio extra√±o.  Pero si miramos la lista de tareas de este dispositivo, encontraremos "watchdogTask" entre ellas.  Obviamente, si hay una "tarea atascada", el perro guardi√°n se reinicia. <br><br>  La tarea LED, excepto el modo MadBlinking, puede considerarse analizada. <br><br>  Veamos a trav√©s de las l√≠neas qu√© otras tareas hay en el sistema: <br><br><img src="https://habrastorage.org/webt/fz/yj/yk/fzyjykt6djuq8v20hjpuw5l0xow.png"><br><br>  Despu√©s de restaurar los enlaces a las cadenas en el c√≥digo, puede ver esta imagen: <br><br><img src="https://habrastorage.org/webt/ha/bl/ks/hablksetvyb0rskx6veqrxbt_z0.png"><br><br>  Primero, hay un enlace a una cadena con la tarea de nombre, luego un enlace a la funci√≥n de tarea principal.  Y se utilizan en la funci√≥n <b>principal</b> , donde se inician estas tareas: <br><br><img src="https://habrastorage.org/webt/oc/ah/qd/ocahqdn8usagpkr-isbabunuwms.png"><br><br>  Ejecutemos los cambios de nombre que faltan: <br><br><ul><li>  sub_80050FC - <b>x_sensor_task</b> ; </li><li>  sub_8004AAC - <b>x_watchdogTask</b> ; </li><li>  sub_8005440 - <b>x_uartRxTask</b> . </li></ul><br><h2>  Tarea de vigilancia </h2><br>  El watchdog de tareas no hace nada particularmente interesante: <br><br><img src="https://habrastorage.org/webt/m-/65/5w/m-655wpo6oboqmrob1tonwaoska.png"><br><br>  Renombrar: <br><br><ul><li>  dword_200003F8 - <b>wd_variable</b> ; </li><li>  sub_8001050 - <b>x_update_wd_var</b> . </li></ul><br><h2>  Tarea UART </h2><br>  <i>Brevemente: busque datos y funciones que tengan enlaces desde diferentes funciones.</i>  <i>Determinaci√≥n de su finalidad.</i> <br><br>  Un vistazo r√°pido a la tarea UART le permite detectar el env√≠o de datos a una cola desconocida definida por la variable <b>unk_200003EC</b> : <br><br><img src="https://habrastorage.org/webt/8j/ei/zz/8jeizzxpvgu5opijgopamebser0.png"><br><br>  Una vez restaurados los enlaces a esta variable a trav√©s de la b√∫squeda binaria, veremos que adem√°s de x_uartRxTask se usa en main (all√≠, la cola se crea, aparentemente) y en la funci√≥n desconocida hasta ahora <b>sub_80051EC</b> : <br><br><img src="https://habrastorage.org/webt/g2/md/sg/g2mdsgx9wwhzpklgcacelye8rb8.png"><br><br>  Renombrar: <br><br><ul><li>  sub_80051EC - <b>x_recvMsg_uart_queue</b> ; </li><li>  unk_200003EC - <b>uart_queue</b> . </li></ul><br>  Ver referencias cruzadas a x_recvMsg_uart_queue: <br><br><ul><li>  sub_8005250; </li><li>  x_bluetooth_task. </li></ul><br>  Primero, vea la funci√≥n <b>sub_8005250</b> : <br><br><img src="https://habrastorage.org/webt/z1/8z/yj/z18zyj09grly6nwhuycpftjbrcu.png"><br><br>  Despu√©s de pensar, renombra: <br><br><ul><li>  unk_2000034C - <b>cmd_count</b> ; </li><li>  a1 - <b>cmd</b> ; </li><li>  v4 - <b>_cmd</b> ; </li><li>  v6 es <b>rsp</b> ; </li><li>  sub_8005250 - <b>x_bluetooth_cmd</b> . </li></ul><br>  Veamos ahora d√≥nde todav√≠a se usa x_bluetooth_cmd.  Todos los enlaces adicionales solo de la tarea Bluetooth, es hora de volver a ella. <br><br><h2>  Volver a la tarea de bluetooth </h2><br>  <i>Brevemente: el an√°lisis final de la tarea de Bluetooth.</i>  <i>Buscar autorizaci√≥n sin contrase√±a.</i> <br><br><img src="https://habrastorage.org/webt/mb/2b/-e/mb2b-eatekfev7dil5vfk3_s-es.png"><br><br>  Si observa los lugares donde se <b>utiliza</b> la funci√≥n <b>sub_8006A84</b> , y no es demasiado vago y mira sus entra√±as, no habr√° duda: esto es <b>calloc</b> .  Es l√≥gico: para recibir datos en el b√∫fer, primero debe crear este b√∫fer. <br><br>  Ahora <b>sub_8006DBC</b> .  Ve√°moslo (las variables ya han sido renombradas): <br><br><img src="https://habrastorage.org/webt/kt/hw/31/kthw31aeqzwyae4jvnoqf5u6yl4.png"><br><br>  Recordando las funciones de la biblioteca est√°ndar de C para trabajar con cadenas, veremos aqu√≠ <b>strstr</b> (buscar una subcadena) y ren√≥mbrala audazmente. <br><br>  Repasemos el c√≥digo de la funci√≥n x_bluetooth_task; <i>tal vez algo ha cambiado aqu√≠ desde la √∫ltima visita</i> .  En el proceso, nombramos las variables: <br><br><ul><li>  v2 - <b>_state</b> ; </li><li>  v3 - <b>data_len</b> . </li></ul><br>  Hay una funci√≥n <b>sub_80052E2 justo al</b> lado.  Por analog√≠a con funciones que extraen n√∫meros de un comando de Bluetooth, extrae una cadena de una longitud especificada, llam√©mosla <b>x_get_str</b> . <br><br>  Continuamos: <br><br><ul><li>  v26 - <b>isEcho</b> ; </li><li>  v6 - <b>meow_str</b> ; </li><li>  v10 - <b>uart_cmd_byte</b> ; </li><li>  v11 - <b>uart_cmd_str</b> ; </li><li>  v12 - <b>str_0</b> ; </li><li>  v13 - <b>str_1</b> ; </li><li>  v14 - <b>format_str</b> ; </li><li>  sub_8000F5C - <b>x_blink_small_led</b> . </li></ul><br>  Termine con un cambio de nombre r√°pido: <br><br><ul><li>  v19 - <b>contrase√±a</b> ;  (ya que hay l√≠neas sobre autorizaci√≥n y contrase√±a al lado) </li><li>  sub_8004CC0 - <b>x_check_password</b> ; </li><li>  sub_8006AF4 - <b>x_free</b> (dado que la contrase√±a, cmd y bt_args son punteros a objetos din√°micos (¬°verifique esto!), la memoria debe liberarse despu√©s de usarlos); </li><li>  sub_8006DAC - <b>x_strcpy</b> (¬°compru√©balo!). </li></ul><br>  Ahora explore las ramas <b>READ</b> , <b>WRIT</b> , <b>AUTP</b> , <b>SETP</b> . <br><br>  Como mostr√≥ una prueba en un dispositivo en ejecuci√≥n, se requiere autorizaci√≥n para los comandos READ, WRIT, SETP.  Un intento de autorizaci√≥n con el comando AUTP nos lleva a la funci√≥n <b>x_check_password</b> para verificar la contrase√±a: <br><br><img src="https://habrastorage.org/webt/vt/pw/6b/vtpw6b3h64bivcvzdlalldoo45k.png"><br><br>  Resulta que la longitud de la contrase√±a debe ser de 8 caracteres y la contrase√±a se compara (en la funci√≥n sub_8006B08) con bytes en la direcci√≥n <b>0x08007C00</b> , donde se almacena la cadena generada de caracteres aleatorios AZ. <br><br>  Resulta que, sin conocer la contrase√±a, no podemos iniciar sesi√≥n en el dispositivo.  Bueno, o casi no puedo ... <br><br>  Presta atenci√≥n a d√≥nde se <b>usa la</b> variable <b>auth_flag</b> : <br><br><img src="https://habrastorage.org/webt/8h/ng/l0/8hngl0dqritcx8yzk1jbvkqpq34.png"><br><br>  Resulta que se usa no solo en tareas Bluetooth.  Y aqu√≠ todav√≠a no buscamos en la tarea Sensor.  Vamos alli <br><br><h2>  Tarea del sensor </h2><br>  <i>Brevemente: ¬øqu√© hace el bot√≥n t√°ctil?</i> <br><br>  De acuerdo con las mejores pr√°cticas de programaci√≥n, toda la tarea del Sensor cabe en una pantalla IDA.  Y esto no puede sino alegrarse: <br><br><img src="https://habrastorage.org/webt/mq/13/3v/mq133vs_uxqmyldfhmicajpxiak.png"><br><br>  L√≠nea a l√≠nea ... <br><br><ul><li>  "TSC% d \ r \ n": esta l√≠nea deber√≠a hacerle pensar en el controlador de detecci√≥n t√°ctil para microcontroladores STM32; </li><li>  "AUTH BTN \ r \ n" - bot√≥n de autorizaci√≥n ??? </li><li>  "SET AUTH% d \ r \ n": ¬øestablecer el indicador de autorizaci√≥n? </li></ul><br>  Veamos c√≥mo se comportar√° el dispositivo si presiona el bot√≥n t√°ctil (¬øse dio cuenta de que el rinoceronte en la pata tiene un bot√≥n t√°ctil?): <br><br><img src="https://habrastorage.org/webt/0p/ig/bp/0pigbpj4pj5gdrn1onololc_zfk.gif"><br><br>  Cuando se presiona brevemente, se enciende el peque√±o LED rojo.  Con una pulsaci√≥n larga, este LED se enciende durante mucho tiempo. <br><br>  Si correlacionamos esto con el c√≥digo, podemos suponer que la funci√≥n <b>sub_8000708</b> es una funci√≥n para obtener la hora actual.  Luego, si la diferencia entre la hora actual y el comienzo de tocar el sensor es superior a 1000 (1 segundo), el LED se enciende durante <b>0xEA60</b> milisegundos (1 minuto).  Pero la variable auth_flag es de gran inter√©s, que se establece en 1 con una pulsaci√≥n larga del bot√≥n t√°ctil, lo que le da al <s>atacante el</s> acceso al administrador del acceso de "dispositivo de iluminaci√≥n" a funciones privilegiadas. <br><br>  Por lo tanto, despu√©s de la autorizaci√≥n "por bot√≥n", puede leer la contrase√±a almacenada en el dispositivo (comando READ), escribir en la RAM (funci√≥n WRIT) o establecer una nueva contrase√±a (SETP). <br><br><h2>  Parpadeo loco </h2><br>  <i>Brevemente: ¬øse puede ejecutar una extra√±a rama de c√≥digo de Parpadeo loco?</i> <br><br>  Volvamos a la tarea de Bluetooth y renuevemos un poco m√°s. <br><br><ul><li>  v21 - <b>vip_smth</b> (a√∫n no est√° claro qu√© hay all√≠); </li><li>  v22 - <b>vip_str</b> (cadena de tama√±o desconocido, extra√≠da de los argumentos); </li><li>  v23 - <b>mad_led</b> - asigne "Convertir a struct *" y especifique <i>struct_LED</i> . </li></ul><br>  Y aqu√≠ vemos el n√∫mero <b>0xB816D8D9</b> (se encontr√≥ en la primera parte del art√≠culo en la tarea de Bluetooth) como el √≠ndice del LED.  Este c√≥digo se ejecutar√° si se realiza la verificaci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( sub_8005520(vip_str, vip_smth) == <span class="hljs-number"><span class="hljs-number">0x46F70674</span></span> )</code> </pre> <br>  Cambie el nombre de sub_8005520 a <b>x_vip_check</b> y <b>√©chele</b> un vistazo: <br><br><img src="https://habrastorage.org/webt/dl/h9/tx/dlh9txqyu5n1t4orgprpptbk8oc.png"><br><br>  Dado que el primer argumento es una cadena (al menos la cadena se pasa a esta funci√≥n), este c√≥digo muestra que el segundo argumento es la longitud de esta cadena (o la longitud que debe procesarse).  Renombrar: <br><br><ul><li>  a1 - <b>str</b> ; </li><li>  a2 - <b>len</b> . </li></ul><br>  Veamos la funci√≥n <b>sub_8000254</b> : <br><br><img src="https://habrastorage.org/webt/y-/ql/js/y-qljsey4clq4lowsdbrblnkyf8.png"><br><br>  Ahora mire <b>sub_8000148</b> .  Aqu√≠ est√° su comienzo: <br><br><img src="https://habrastorage.org/webt/l7/xz/cr/l7xzcrdgjq0n5a82enkalsukqse.png"><br><br>  Esto es solo un tercio de la funci√≥n ... Mmmm ... ¬°Qu√© rico!  Un cavador experimentado ver√° f√°cilmente aqu√≠ ... <br><br><div class="spoiler">  <b class="spoiler_title">Que?</b> <div class="spoiler_text">  operaci√≥n de divisi√≥n entera. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo se puede desenterrar?</b> <div class="spoiler_text">  Si hace un esfuerzo, desde la funci√≥n <b>sub_8000254</b> puede acceder a <b>x_printf</b> (a trav√©s de varias otras funciones).  Un punto importante a destacar en este punto es que generalmente todas <i>las funciones est√°ndar son bastante est√°ndar</i> .  Esto significa que puede intentar encontrar en el dominio p√∫blico al menos alg√∫n c√≥digo fuente de la funci√≥n que se est√° investigando, para que el estudio sea m√°s productivo. <br><br>  Entonces, tomamos la fuente de printf, luego miramos <b>vfprintf</b> , compar√°ndolo con el c√≥digo del firmware estudiado.  <b>Usando el</b> c√≥digo fuente, salimos a la funci√≥n <b>itoa</b> y concluimos que la funci√≥n <b>sub_8000254</b> es el operador <b>operador%</b> (tomando el resto de la divisi√≥n), y esta terrible funci√≥n larga no es m√°s que tomar la parte entera de la divisi√≥n (operaci√≥n div). <br></div></div><br>  Puede surgir una pregunta leg√≠tima: ¬øpor qu√©?  El hecho es que no puede haber operaciones DIV, MOD en un microcontrolador particular, por lo tanto, el compilador sustituye la llamada de funciones individuales en lugar de estos operadores.  Por cierto, aqu√≠ hay algunas otras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones matem√°ticas</a> . <br><br>  No olvide cambiar el nombre mientras excava. <br><br>  Por lo tanto, la funci√≥n <b>x_vip_check</b> , calcula ... Y esta ser√° su <b><i>tarea</i></b> . <br><br>  Por cierto, si ejecuta el comando <b>VIP</b> correcto, obtenemos un "rinoceronte en la discoteca": <br><br><img src="https://habrastorage.org/webt/ah/ty/sc/ahtyscents-3j77aqcxfa0_hrtq.gif"><br><br><h2>  Breve informe sobre firmware </h2><br>  El firmware del dispositivo se basa en el sistema operativo en tiempo real FreeRTOS.  El sistema tiene las siguientes tareas: <br><br><ol><li>  <b>Tarea de Bluetooth</b> .  Procesa comandos que vienen en forma de texto a trav√©s de Bluetooth. </li><li>  <b>Tarea LED</b> .  Controla los LED de color seg√∫n los comandos de Bluetooth. </li><li>  <b>Tarea del sensor</b> .  Enciende el LED rojo, permite la autorizaci√≥n a corto plazo sin una contrase√±a en el dispositivo. </li><li>  <b>Tarea UART</b> .  Le permite interactuar con el m√≥dulo Bluetooth a trav√©s del puerto UART interno (utilizado para inicializar Bluetooth). </li><li>  <b>Tarea de vigilancia</b> .  Realiza un seguimiento de las heladas. </li></ol><br>  El estudio no tuvo en cuenta la capacidad de leer datos del puerto UART (contactos Tx / GND). <br><br><h2>  Resumen </h2><br>  Durante la clase magistral en la conferencia, solo se desmont√≥ la funcionalidad principal de control de LED.  Los participantes m√°s activos recibieron sus "rinocerontes" experimentales. <br><br>  En mi opini√≥n, el "rinoceronte" produjo un dise√±o decente para un curso de capacitaci√≥n en ingenier√≠a inversa y b√∫squeda de vulnerabilidades.  Una caracter√≠stica del dise√±o puede ser la capacidad de cambiar el firmware tantas veces como desee, cada curso tiene su propio firmware.  A diferencia del an√°lisis de un archivo ejecutable, el firmware inverso le permite comprender mejor: <br><br><ul><li>  c√≥mo trabajar con IDA; </li><li>  principios de interacci√≥n entre el firmware y el dispositivo; </li><li>  Principios operativos RTOS. </li></ul><br>  ¬°Muchas gracias a todos los que leyeron hasta el final! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es412561/">https://habr.com/ru/post/es412561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es412551/index.html">Copie texto del portapapeles a dispositivos Android a trav√©s de ADB</a></li>
<li><a href="../es412553/index.html">El resumen de eventos para profesionales de recursos humanos en el campo de TI para junio de 2018</a></li>
<li><a href="../es412555/index.html">Engranaje magn√©tico para motor sin escobillas</a></li>
<li><a href="../es412557/index.html">C√≥mo crear tu propio bot sin habilidades de programaci√≥n y conectarlo a Yandex.</a></li>
<li><a href="../es412559/index.html">Contrato inteligente como amenaza de seguridad para el inicio de blockchain</a></li>
<li><a href="../es412565/index.html">C√≥mics sobre administradores de sistemas: toda la vida pas√≥ ante mis ojos</a></li>
<li><a href="../es412571/index.html">Kubernetes historias de √©xito en producci√≥n. Parte 9: grupos de CERN y 210 K8</a></li>
<li><a href="../es412573/index.html">Lo que est√° mal con Geektimes regresa a Habr</a></li>
<li><a href="../es412575/index.html">Cada a√±o, la m√∫sica pop se vuelve cada vez m√°s mon√≥tona, porque la misma gente la compone.</a></li>
<li><a href="../es412579/index.html">Marvel: Infinity War o C√≥mo recopilar datos para su proyecto en un par de minutos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>