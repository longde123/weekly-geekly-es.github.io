<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äç‚úàÔ∏è üîà üêö Bloqueos en PostgreSQL: 4. Bloqueos en la memoria üßôüèΩ üöà üóìÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perm√≠tame recordarle que ya hablamos sobre bloqueos de relaci√≥n , bloqueos de nivel de fila , sobre bloqueos de otros objetos (incluidos los predicado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bloqueos en PostgreSQL: 4. Bloqueos en la memoria</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/466199/">  Perm√≠tame recordarle que ya hablamos sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bloqueos de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">relaci√≥n</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">, bloqueos de nivel de fila</a> , sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bloqueos de otros objetos</a> (incluidos los predicados) y sobre la relaci√≥n entre diferentes tipos de bloqueos. <br><br>  Hoy termino esta serie con un art√≠culo sobre <strong>bloqueos de memoria</strong> .  Hablaremos sobre spinlocks, bloqueos livianos y bloqueo de b√∫fer, as√≠ como herramientas de monitoreo y muestreo de expectativas. <br><br><img src="https://habrastorage.org/webt/2y/vt/2g/2yvt2gpimbdqmnibpzaiuf8qu0q.png"><br><a name="habracut"></a><br><h1>  Bloqueo de giro </h1><br>  A diferencia de las cerraduras "pesadas" comunes, las cerraduras m√°s ligeras y m√°s baratas (en t√©rminos de gastos generales) se utilizan para proteger las estructuras en la RAM compartida. <br><br>  El m√°s simple de ellos son <em>cerraduras giratorias</em> o <em>cerraduras giratorias</em> .  Est√°n dise√±ados para capturar durante muy poco tiempo (varias instrucciones de procesador) y proteger secciones individuales de memoria de cambios simult√°neos. <br><br>  Los bloqueos de giro se implementan en base a instrucciones at√≥micas del procesador, como comparar e intercambiar.  Soportan un solo modo exclusivo.  Si el bloqueo est√° ocupado, el proceso de espera realiza una espera activa: el comando se repite ("gira" en el bucle, de ah√≠ el nombre) hasta que se ejecuta con √©xito.  Esto tiene sentido, ya que los bloqueos de giro se utilizan cuando se estima que la probabilidad de conflicto es muy baja. <br><br>  Los bloqueos de giro no proporcionan detecci√≥n de puntos muertos (los desarrolladores de PostgreSQL est√°n monitoreando esto) y no proporcionan ninguna herramienta de monitoreo.  En general, lo √∫nico que podemos hacer con las cerraduras giratorias es saber acerca de su existencia. <br><br><h1>  Cerraduras de luz </h1><br>  Luego vienen las llamadas <em>cerraduras</em> ligeras (cerraduras livianas, lwlocks). <br><br>  Se capturan por el corto tiempo que lleva trabajar con la estructura de datos (por ejemplo, una tabla hash o una lista de punteros).  Como regla general, un bloqueo de luz no se mantiene por mucho tiempo, pero en algunos casos, un bloqueo de luz protege las operaciones de E / S, por lo que, en principio, el tiempo puede llegar a ser significativo. <br><br>  Se admiten dos modos: exclusivo (para cambiar datos) y compartido (solo lectura).  Como tal, no hay cola de espera: si varios procesos est√°n esperando que se libere el bloqueo, uno de ellos obtendr√° acceso m√°s o menos al azar.  En sistemas con un alto grado de paralelismo y carga pesada, esto puede conducir a efectos desagradables (ver, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discusi√≥n</a> ). <br><br>  No se proporciona un mecanismo para verificar puntos muertos, esto permanece en la conciencia de los desarrolladores del kernel.  Sin embargo, las cerraduras ligeras tienen herramientas de monitoreo, por lo tanto, a diferencia de las cerraduras giratorias, se pueden "ver" (un poco m√°s adelante mostrar√© c√≥mo). <br><br><h1>  Clip buffer </h1><br>  Otro tipo de bloqueo que ya hemos discutido en el art√≠culo sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">memoria cach√©</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫fer</a> es <em>la fijaci√≥n del b√∫fer</em> . <br><br>  Con un b√∫fer fijo, puede realizar varias acciones, incluido el cambio de datos, pero con la condici√≥n de que estos cambios no sean visibles para otros procesos debido a las versiones m√∫ltiples.  Es decir, puede agregar una nueva l√≠nea a la p√°gina, pero no puede reemplazar la p√°gina en el b√∫fer por otra. <br><br>  Si el proceso se ve obstaculizado por el enlace, generalmente solo omite dicho b√∫fer y selecciona otro.  Pero en algunos casos, cuando se requiere este b√∫fer en particular, el proceso se pone en cola y se queda dormido: el sistema lo activar√° cuando se elimine la fijaci√≥n. <br><br>  Las expectativas de consolidaci√≥n est√°n disponibles para el monitoreo. <br><br><h1>  Ejemplo: cach√© de b√∫fer </h1><br><img src="https://habrastorage.org/webt/gt/z8/gy/gtz8gylhroqbvj7jmwemqbd4jys.png"><br><br>  Ahora, para obtener informaci√≥n (¬°incompleta!) Sobre c√≥mo y d√≥nde se usan los bloqueos, considere un ejemplo de cach√© de b√∫fer. <br><br>  Para acceder a una tabla hash que contiene referencias a buffers, el proceso debe capturar un bloqueo de asignaci√≥n de buffer ligero en modo compartido, y si la tabla necesita ser cambiada, entonces en modo excepcional.  Para reducir la granularidad, esta cerradura est√° dispuesta como un <em>tramo</em> , que consta de 128 cerraduras separadas, cada una de las cuales protege su propia parte de la tabla hash. <br><br>  El proceso obtiene acceso al encabezado del b√∫fer utilizando spin-lock.  Las operaciones individuales (como incrementar el contador) tambi√©n se pueden realizar sin bloqueos expl√≠citos utilizando instrucciones at√≥micas del procesador. <br><br>  Para leer el contenido de un b√∫fer, se requiere un bloqueo del contenido del b√∫fer.  Por lo general, se captura solo durante el tiempo necesario para leer los punteros a la versi√≥n de las l√≠neas, y luego la protecci√≥n proporcionada por el clip de b√∫fer es suficiente.  Para modificar el contenido del b√∫fer, este bloqueo debe capturarse en modo excepcional. <br><br>  Al leer un b√∫fer del disco (o escribir en el disco), tambi√©n se captura el bloqueo de E / S en progreso, lo que indica a otros procesos que la p√°gina se est√° leyendo (o escribiendo); pueden hacer cola si tambi√©n necesitan hacer algo con esta p√°gina. <br><br>  Los punteros para liberar buffers y para la siguiente v√≠ctima est√°n protegidos por un √∫nico bloqueo de estrategia de bloqueo de spin. <br><br><h1>  Ejemplo: buffers de registro </h1><br><img src="https://habrastorage.org/webt/_f/mu/ub/_fmuubhon3hualbtorx4rmjgur4.png"><br>  Otro ejemplo: b√∫feres de registro. <br><br>  Para el cach√© del diario, tambi√©n se usa una tabla hash que contiene la asignaci√≥n de p√°ginas a buffers.  A diferencia de la memoria cach√© del b√∫fer, esta tabla hash est√° protegida por el √∫nico bloqueo ligero de WALBufMappingLock, ya que el tama√±o de la memoria cach√© del diario es menor (generalmente 1/32 de la memoria cach√© del b√∫fer) y el acceso a los b√∫feres est√° m√°s optimizado. <br><br>  La escritura de p√°ginas en el disco est√° protegida por un ligero bloqueo WALWriteLock para que solo un proceso pueda realizar esta operaci√≥n a la vez. <br><br>  Para crear una entrada de diario, el proceso primero debe reservar un espacio en la p√°gina WAL.  Para hacer esto, captura el bloqueo de posici√≥n de inserci√≥n de bloqueo de giro.  Despu√©s de reservar un lugar, el proceso copia el contenido de su registro en el lugar designado.  La copia puede ser realizada por varios procesos al mismo tiempo, para lo cual el registro est√° protegido por un tramo de 8 bloqueos de inserci√≥n de bloqueo f√°cil (el proceso debe capturar <em>cualquiera</em> de ellos). <br><br>  La figura no muestra todos los bloqueos relacionados con el registro de pregrabaci√≥n, pero este y el ejemplo anterior deber√≠an dar alguna idea sobre el uso de bloqueos en la RAM. <br><br><h1>  Monitoreo de expectativas </h1><br>  Comenzando con PostgreSQL 9.6, las herramientas de monitoreo de espera est√°n integradas en la vista pg_stat_activity.  Cuando un proceso (sistema o mantenimiento) no puede hacer su trabajo y est√° esperando algo, esta expectativa se puede ver en la vista: la columna wait_event_type indica el tipo de expectativa, y la columna wait_event indica el nombre de una expectativa espec√≠fica. <br><br>  Tenga en cuenta que una vista muestra solo aquellas expectativas que se manejan adecuadamente en el c√≥digo fuente.  Si la vista no muestra la expectativa, esto generalmente no significa con una probabilidad del 100 por ciento de que el proceso realmente no espera nada. <br><br>  Desafortunadamente, la √∫nica informaci√≥n disponible sobre las expectativas es <em>la</em> informaci√≥n <em>actual</em> .  No se mantienen estad√≠sticas.  La √∫nica forma de obtener una imagen de las expectativas a lo largo del tiempo es <em>muestreando el</em> estado de la vista en un intervalo espec√≠fico.  No hay medios integrados para esto, pero puede usar extensiones, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_wait_sampling</a> . <br><br>  Es necesario tener en cuenta la naturaleza probabil√≠stica del muestreo.  Para obtener una imagen m√°s o menos confiable, el n√∫mero de mediciones debe ser lo suficientemente grande.  El muestreo a baja frecuencia puede no proporcionar una imagen confiable, y aumentar la frecuencia conducir√° a un aumento de la sobrecarga.  Por la misma raz√≥n, el muestreo es in√∫til para analizar sesiones de corta duraci√≥n. <br><br>  Todas las expectativas se pueden dividir en varios tipos. <br><br>  Las expectativas de las cerraduras consideradas constituyen una gran categor√≠a: <br><br><ul><li>  esperando bloqueos de objetos (valor de bloqueo en la columna wait_event_type); </li><li>  esperando cerraduras de luz (LWLock); </li><li>  esperando un b√∫fer anclado (BufferPin). </li></ul><br>  Pero los procesos pueden esperar otros eventos: <br><br><ul><li>  Las expectativas de E / S (IO) ocurren cuando un proceso necesita escribir o leer datos; </li><li>  el proceso puede esperar los datos necesarios para el trabajo del cliente (Cliente) o de otro proceso (IPC); </li><li>  Las extensiones pueden registrar sus expectativas espec√≠ficas (Extensi√≥n). </li></ul><br>  Hay situaciones en las que un proceso simplemente no hace un trabajo √∫til.  Esta categor√≠a incluye: <br><br><ul><li>  esperando procesos en segundo plano en su bucle principal (Actividad); </li><li>  esperando un temporizador (Tiempo de espera). </li></ul><br>  Como regla, tales expectativas son "normales" y no hablan de ning√∫n problema. <br><br>  El tipo de expectativa es seguido por el nombre de la expectativa particular.  La tabla completa se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la documentaci√≥n</a> . <br><br>  Si no se especifica ning√∫n nombre de espera, el proceso no est√° en estado de espera.  Se debe considerar que ese momento no se tiene en cuenta, ya que de hecho no se sabe qu√© est√° sucediendo exactamente en este momento. <br><br>  Sin embargo, es hora de mirar. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, backend_type, wait_event_type, wait_event <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity;</code> </pre> <pre> <code class="plaintext hljs"> pid | backend_type | wait_event_type | wait_event -------+------------------------------+-----------------+--------------------- 28739 | logical replication launcher | Activity | LogicalLauncherMain 28736 | autovacuum launcher | Activity | AutoVacuumMain 28963 | client backend | | 28734 | background writer | Activity | BgWriterMain 28733 | checkpointer | Activity | CheckpointerMain 28735 | walwriter | Activity | WalWriterMain (6 rows)</code> </pre><br>  Se puede ver que todos los procesos de servicio en segundo plano est√°n "jugando". Los valores vac√≠os en wait_event_type y wait_event indican que el proceso no espera nada; en nuestro caso, el proceso de publicaci√≥n est√° ocupado ejecutando la solicitud. <br><br><h2>  Muestreo </h2><br>  Para obtener una imagen m√°s o menos completa de las expectativas utilizando el muestreo, utilizamos la extensi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_wait_sampling</a> .  Debe compilarse a partir del c√≥digo fuente;  Omitir√© esta parte.  Luego registramos la biblioteca en el par√°metro <em>shared_preload_libraries</em> y reiniciamos el servidor. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pg_wait_sampling'</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Ahora instale la extensi√≥n en la base de datos. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_wait_sampling;</code> </pre><br>  La extensi√≥n le permite ver el historial de expectativas, que se almacena en un b√∫fer circular.  Pero lo m√°s interesante es ver el perfil de las expectativas: las estad√≠sticas acumuladas para todo el tiempo de trabajo. <br><br>  Esto es lo que veremos en unos segundos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile;</code> </pre><pre> <code class="plaintext hljs"> pid | event_type | event | queryid | count -------+------------+---------------------+---------+------- 29074 | Activity | LogicalLauncherMain | 0 | 220 29070 | Activity | WalWriterMain | 0 | 220 29071 | Activity | AutoVacuumMain | 0 | 219 29069 | Activity | BgWriterMain | 0 | 220 29111 | Client | ClientRead | 0 | 3 29068 | Activity | CheckpointerMain | 0 | 220 (6 rows)</code> </pre><br>  Como no ha sucedido nada desde que se inici√≥ el servidor, las principales expectativas son del tipo Actividad (los procesos de servicio esperan hasta que aparezca el trabajo) y Cliente (psql espera a que el usuario env√≠e una solicitud). <br><br>  Con la configuraci√≥n predeterminada (par√°metro <em>pg_wait_sampling.profile_period</em> ), el per√≠odo de muestreo es de 10 milisegundos, es decir, los valores se guardan 100 veces por segundo.  Por lo tanto, para estimar la duraci√≥n de la espera en segundos, el valor del recuento debe dividirse por 100. <br><br>  Para comprender a qu√© pertenecen las expectativas del proceso, agregamos la vista pg_stat_activity a la solicitud: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+------------------------------+------+------------+----------------------+------- 29068 | checkpointer | | Activity | CheckpointerMain | 222 29069 | background writer | | Activity | BgWriterMain | 222 29070 | walwriter | | Activity | WalWriterMain | 222 29071 | autovacuum launcher | | Activity | AutoVacuumMain | 221 29074 | logical replication launcher | | Activity | LogicalLauncherMain | 222 29111 | client backend | psql | Client | ClientRead | 4 29111 | client backend | psql | IPC | MessageQueueInternal | 1 (7 rows)</code> </pre><br>  Carguemos con pgbench y veamos c√≥mo cambia la imagen. <br><br><pre> <code class="plaintext hljs">student$ pgbench -i test</code> </pre><br>  Restablecemos el perfil recopilado a cero y ejecutamos la prueba durante 30 segundos en un proceso separado. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_wait_sampling_reset_profile();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><br>  La solicitud debe completarse antes de que se complete el proceso pgbench: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.application_name = <span class="hljs-string"><span class="hljs-string">'pgbench'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+---------+------------+------------+------- 29148 | client backend | pgbench | IO | WALWrite | 8 29148 | client backend | pgbench | Client | ClientRead | 1 (2 rows)</code> </pre><br>  Por supuesto, las expectativas del proceso pgbench resultar√°n ligeramente diferentes dependiendo del sistema espec√≠fico.  En nuestro caso, es muy probable que se presente la espera de una entrada de registro (IO / WALWrite), pero la mayor√≠a de las veces el proceso no se detuvo, pero hizo algo presumiblemente √∫til. <br><br><h2>  Cerraduras de luz </h2><br>  Siempre debe recordar que la ausencia de expectativas cuando se realiza el muestreo no significa que no haya expectativas.  Si fue m√°s corto que el per√≠odo de muestreo (la cent√©sima de segundo en nuestro ejemplo), entonces simplemente no podr√≠a caer en la muestra. <br><br>  Por lo tanto, los bloqueos de luz no aparecieron en el perfil, pero aparecer√°n si recopila datos durante mucho tiempo.  Para garantizar un vistazo, puede ralentizar artificialmente el sistema de archivos, por ejemplo, utilice el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">slowfs</a> integrado en el sistema de archivos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FUSE</a> . <br><br>  Esto es lo que podemos ver en la misma prueba si cualquier operaci√≥n de E / S tarda 1/10 de segundo. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_wait_sampling_reset_profile();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.application_name = <span class="hljs-string"><span class="hljs-string">'pgbench'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+---------+------------+----------------+------- 29240 | client backend | pgbench | IO | WALWrite | 1445 29240 | client backend | pgbench | LWLock | WALWriteLock | 803 29240 | client backend | pgbench | IO | DataFileExtend | 20 (3 rows)</code> </pre><br>  Ahora, la expectativa principal del proceso pgbench est√° relacionada con E / S, o m√°s bien, una entrada de registro que se ejecuta en modo s√≠ncrono con cada confirmaci√≥n.  Dado que (como se muestra en el ejemplo anterior), escribir un registro en el disco est√° protegido por el bloqueo de luz WALWriteLock, este bloqueo tambi√©n est√° presente en el perfil; quer√≠amos verlo. <br><br><h2>  Clip buffer </h2><br>  Para ver la fijaci√≥n del b√∫fer, aprovechamos el hecho de que los cursores abiertos sostienen el pin para que la lectura de la siguiente l√≠nea sea m√°s r√°pida. <br><br>  Comenzamos la transacci√≥n, abrimos el cursor y seleccionamos una fila. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgbench_history; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> tid | bid | aid | delta | mtime | filler -----+-----+-------+-------+----------------------------+-------- 9 | 1 | 35092 | 477 | 2019-09-04 16:16:18.596564 | (1 row)</code> </pre><br>  Compruebe que el b√∫fer est√° anclado (pinning_backends): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> relforknumber = <span class="hljs-number"><span class="hljs-number">0</span></span> \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+------ bufferid | 190 relfilenode | 47050 reltablespace | 1663 reldatabase | 16386 relforknumber | 0 relblocknumber | 0 isdirty | t usagecount | 1 pinning_backends | 1 &lt;--   1 </code> </pre><br>  Ahora <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">limpiaremos la</a> tabla: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 29367 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> pgbench_history;</code> </pre><pre> <code class="plaintext hljs">| INFO: vacuuming "public.pgbench_history" | INFO: "pgbench_history": found 0 removable, 0 nonremovable row versions in 1 out of 1 pages | DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 732651 | There were 0 unused item pointers.</code> </pre><pre> <code class="plaintext hljs">| Skipped 1 page due to buffer pins, 0 frozen pages.</code> </pre><pre> <code class="plaintext hljs">| 0 pages are entirely empty. | CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. | VACUUM</code> </pre><br>  Como podemos ver, la p√°gina se omiti√≥ (se omiti√≥ 1 p√°gina debido a los pines del b√∫fer).  De hecho, la limpieza no puede manejarlo, ya que est√° prohibido eliminar f√≠sicamente las versiones de fila de una p√°gina en un b√∫fer anclado.  Pero la limpieza no esperar√°: la p√°gina se procesar√° la pr√≥xima vez. <br><br>  Y ahora realizaremos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">limpieza con congelaci√≥n</a> : <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FREEZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> pgbench_history;</code> </pre><br>  Con una congelaci√≥n claramente solicitada, no puede omitir una sola p√°gina que no est√© marcada en el mapa de congelaci√≥n; de lo contrario, es imposible reducir la antig√ºedad m√°xima de las transacciones no congeladas en pg_class.relfrozenxid.  Por lo tanto, la limpieza se bloquea hasta que se cierra el cursor. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> age ----- 27 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--   </span></span></code> </pre><br><pre> <code class="plaintext hljs">| INFO: aggressively vacuuming "public.pgbench_history" | INFO: "pgbench_history": found 0 removable, 26 nonremovable row versions in 1 out of 1 pages | DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 732651 | There were 0 unused item pointers.</code> </pre><pre> <code class="plaintext hljs">| Skipped 0 pages due to buffer pins, 0 frozen pages.</code> </pre><pre> <code class="plaintext hljs">| 0 pages are entirely empty. | CPU: user: 0.00 s, system: 0.00 s, elapsed: 3.01 s. | VACUUM</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> age ----- 0 (1 row)</code> </pre><br>  Bueno, veamos el perfil de expectativas de la segunda sesi√≥n psql en la que se ejecutaron los comandos VACUUM: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> p.pid = <span class="hljs-number"><span class="hljs-number">29367</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+------+------------+------------+------- 29367 | client backend | psql | BufferPin | BufferPin | 294 29367 | client backend | psql | Client | ClientRead | 10 (2 rows)</code> </pre><br>  El tipo de espera BufferPin indica que el vaciado estaba esperando que se liberara el b√∫fer. <br><br>  En esto asumiremos que hemos completado las cerraduras.  ¬°Gracias a todos por su atenci√≥n y comentarios! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466199/">https://habr.com/ru/post/466199/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466187/index.html">Editor de l√≥gica visual para Unity3d. Parte 2</a></li>
<li><a href="../466191/index.html">Lo principal de la batalla por la neutralidad de la red en los Estados Unidos es la cronolog√≠a de los eventos y el estado actual de las cosas.</a></li>
<li><a href="../466193/index.html">Alimentaci√≥n autom√°tica de MailChimp personalizada desde RSS</a></li>
<li><a href="../466195/index.html">PVS-Studio 7.04</a></li>
<li><a href="../466197/index.html">PVS-Studio 7.04</a></li>
<li><a href="../466201/index.html">C√≥mo dejar la ciencia en TI y convertirse en un probador: la historia de una carrera</a></li>
<li><a href="../466203/index.html">D√≠a de Techdir en San Petersburgo. Cerveza, pizza, dos micr√≥fonos</a></li>
<li><a href="../466211/index.html">Proyecto Mainline en Android 10</a></li>
<li><a href="../466213/index.html">4 pasos para crear un perfil de candidato</a></li>
<li><a href="../466215/index.html">Dise√±o orientado a modelos. Creaci√≥n de un modelo confiable, utilizando el ejemplo de un intercambiador de calor de aviaci√≥n.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>