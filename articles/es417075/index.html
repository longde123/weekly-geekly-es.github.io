<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äç‚öñÔ∏è üå™Ô∏è ü§™ API de pintura CSS ü§ü ‚õ∑Ô∏è üèñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seg√∫n el autor del material, cuya traducci√≥n publicamos hoy, la API de pintura CSS es una tecnolog√≠a incre√≠blemente interesante. Adem√°s, estamos habla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API de pintura CSS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/417075/">  Seg√∫n el autor del material, cuya traducci√≥n publicamos hoy, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la API de pintura CSS</a> es una tecnolog√≠a incre√≠blemente interesante.  Adem√°s, estamos hablando no solo de sus capacidades actuales, sino tambi√©n de los fen√≥menos que se le presentan, y de que su apariencia marca el comienzo de cambios muy notables en el mundo CSS.  Aqu√≠ hablaremos sobre la API de CSS Paint y las razones de su aparici√≥n, y hablaremos sobre c√≥mo usarla. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/6c/1q/yu/6c1qyuo29pmcjmojwwou8qb034g.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">¬øQu√© es la API de pintura CSS?</font> </h2><br>  La API en cuesti√≥n es solo una peque√±a parte del nuevo conjunto de especificaciones que se est√°n desarrollando como parte del proyecto CSS Houdini.  Al describir brevemente este proyecto, su esencia se reduce al hecho de que brinda a los desarrolladores acceso de bajo nivel a los mecanismos internos de CSS. <br><br>  La API de pintura CSS le permite llamar a la funci√≥n <code>paint()</code> en situaciones en las que, en condiciones normales, el trabajo se realizar√≠a, por ejemplo, con un cierto valor que describe alg√∫n tipo de imagen.  Un ejemplo com√∫n de esto es la propiedad de <code>background-image</code> , cuando trabaja con la que puede usar la funci√≥n <code>url()</code> para pasarle al sistema un enlace al archivo de imagen: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">area</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(<span class="hljs-string"><span class="hljs-string">'assets/myimage.jpg'</span></span>); }</code> </pre> <br>  La API de pintura CSS le permite llamar, en lugar de una funci√≥n similar, a la funci√≥n <code>paint()</code> y pasarle el llamado worklet, descrito por JavaScript.  Un vorklet puede ser percibido como una pieza de c√≥digo que le permite a un desarrollador dibujar program√°ticamente casi cualquier cosa que quiera.  Y, como estamos hablando de JavaScript, la imagen se puede dinamizar.  Por s√≠ sola, esta API es muy similar a la API HTML5 Canvas, y ahora hablaremos sobre c√≥mo funciona todo. <br><br><h2>  <font color="#3AC1EF">Caracter√≠sticas de API de pintura CSS</font> </h2><br>  Si ahora tiene la sensaci√≥n de que todo esto suena bien, pero parece complicado, y cree que se siente bastante c√≥modo usando im√°genes ordinarias, tenga en cuenta que las im√°genes ordinarias no pierden su relevancia con el advenimiento de la nueva tecnolog√≠a.  Usarlos, como siempre lo hac√≠an, es perfectamente normal.  El hecho de que algo nuevo haya aparecido en el horizonte, y probablemente sea prometedor, no significa que todos de inmediato necesiten usarlo para resolver todos los problemas existentes.  Sin embargo, las im√°genes ordinarias son est√°ticas.  La nueva API atrae con la idea de crear im√°genes din√°micas. <br><br>  Pensemos en la funci√≥n CSS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de gradiente lineal</a> .  La cosa es muy poderosa.  Echa un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esto,</a> por ejemplo.  Pero, ¬øte imaginas lo f√°cil que ser√≠a lograr el mismo efecto formado por la superposici√≥n de capas si no tuvieras que usar muchas im√°genes de fondo?  Sin embargo, este no es el √∫nico punto.  Si profundiza en la API de CSS Paint, puede comprender c√≥mo se crean esas im√°genes durante la ejecuci√≥n del programa, y ‚Äã‚Äãesto puede ser muy √∫til (de hecho, esto es lo que planeamos hacer aqu√≠). <br><br>  ¬øQu√© pasa con la funci√≥n CSS de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gradiente c√≥nico</a> ?  Se puede decir que todav√≠a no es compatible con navegadores sin polyfill.  El uso de la nueva API le permite crear gradientes c√≥nicos, ajustar sus par√°metros, que no son particularmente diferentes de lo que est√° en la especificaci√≥n.  Todo esto significa que, en la pr√°ctica, utilizando la nueva API, puede crear su propio polyfill nativo.  Y esto es simplemente maravilloso. <br><br>  Tenga en cuenta que todo esto forma parte de un grupo m√°s grande de caracter√≠sticas conocido como CSS Houdini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Esto es</a> lo que dice la documentaci√≥n del proyecto al respecto: "El objetivo de CSS-TAG Houdini Task Force (CSS Houdini) es desarrollar conjuntamente mecanismos que rompan el misterio de la tecnolog√≠a de dise√±ar p√°ginas web y construir sus dise√±os". <br><br>  Suena bien, ¬øverdad?  Y, de hecho, estos nuevos mecanismos est√°n destinados a permitir que los desarrolladores ampl√≠en la funcionalidad del CSS en s√≠, d√°ndoles mejores herramientas de estilo, compatibilidad entre navegadores y la capacidad de crear polyfills. <br><br>  El proceso de estandarizaci√≥n de nuevas tecnolog√≠as puede llevar alg√∫n tiempo.  Primero, se hace una propuesta para una nueva caracter√≠stica CSS.  A continuaci√≥n, se escribe una especificaci√≥n, se producen otros procesos.  Como resultado, los fabricantes de navegadores est√°n implementando nuevas especificaciones.  Y, dado que los desarrolladores a menudo no pueden esperar para comenzar a usar las nuevas funciones lo antes posible, deben tener en cuenta el hecho de que los navegadores antiguos pueden no ser compatibles con las innovaciones, y que si alguna especificaci√≥n a√∫n no est√° completamente implementada, puede que, en el transcurso de su desarrollo, seriamente cambio.  Quiz√°s no haya nada que hablar sobre los matices t√≠picos de la implementaci√≥n de diferentes tecnolog√≠as en diferentes navegadores.  El proyecto Houdini puede llegar bastante lejos para mitigar estos problemas, permiti√©ndonos desarrollar la funcionalidad del navegador por nuestra cuenta, usarlo y esperar con calma a que los fabricantes de navegadores implementen ciertas funciones.  Aqu√≠ hay un par de materiales sobre este tema.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El primero est√°</a> dedicado a las fortalezas de Houdini, y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segundo</a> es usar las capacidades de este proyecto para crear animaciones complejas. <br><br><h2>  <font color="#3AC1EF">Soporte para CSS Paint API por parte de los navegadores</font> </h2><br>  ¬øPuedo usar la API de CSS Paint hoy?  Podemos dar una respuesta positiva a esta pregunta, aunque debe tenerse en cuenta que, lejos de todos los navegadores, admiten esta tecnolog√≠a.  Para obtener informaci√≥n de soporte para esta API, puede usar el recurso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">caniuse.com</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55a/42a/4ea/55a42a4ea1ccc056652c9a7b463f8097.png"></div><br>  <i><font color="#999999">Soporte para la API de CSS Paint por varios navegadores (julio de 2018)</font></i> <br><br>  Como puede ver, esta API solo es compatible con Chrome hasta ahora.  Pero sea como sea, hablemos sobre c√≥mo usarlo.  Cubriremos las construcciones de software necesarias para que la nueva API funcione.  Esto incluye nuevas funciones de CSS y algunos mecanismos de JavaScript bastante recientes.  Nuestro ejemplo se dividir√° en tres pasos. <br><br><h2>  <font color="#3AC1EF">Paso # 1: CSS</font> </h2><br>  Recuerde que para crear una imagen usando la API CSS Paint, los widgets son fragmentos de c√≥digo JS.  Por lo tanto, para empezar, debemos darle un nombre al worklet y llamarlo en CSS.  <code>awesomePattern</code> .  Como resultado, el CSS se ver√° as√≠: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">section</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(<span class="hljs-string"><span class="hljs-string">'fallback.png'</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">paint</span></span>(awesomePattern); };</code> </pre> <br>  Se han completado los preparativos preliminares, pero hasta que el resto de nuestro ejemplo est√© listo, todo esto no funcionar√°. <br><br><h2>  <font color="#3AC1EF">Paso # 2: JavaScript</font> </h2><br>  Ahora necesitamos describir el worklet usando JS.  Aqu√≠ se muestra c√≥mo, en el script principal, se carga otro script que implementa la funcionalidad que necesitamos. <br><br><pre> <code class="hljs cs">CSS.paintWorklet.addModule(<span class="hljs-string"><span class="hljs-string">'patternWorklet.js'</span></span>);</code> </pre> <br>  En esta etapa, nuevamente, no pasa nada, ya que lo m√°s interesante est√° oculto en el archivo <code>patternWorklet.js</code> . <br><br>  En el archivo <code>patternWorklet.js</code> necesitamos registrar la clase del vorklet: <br><br><pre> <code class="hljs lisp">registerPaint('awesomePattern', Shape)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Aqu√≠ llamamos a la funci√≥n <code>registerPaint()</code> y le pasamos lo que consideramos un worklet, en este caso <code>awesomePattern</code> .  Adem√°s, le pasamos a esta funci√≥n un enlace a la clase que escribiremos, en este caso, <code>Shape</code> .  Este comando debe agregarse despu√©s de la declaraci√≥n de la clase correspondiente.  Al declarar y usar clases, no puede confiar en algo como un mecanismo para generar declaraciones de funciones.  Antes de poder usar una clase, debe declararla. <br><br>  A continuaci√≥n, vamos a utilizar la sintaxis para declarar las clases de ECMAScript 2015 y escribir una clase que dibuje la imagen de fondo.  Dado que esta clase ahora est√° registrada como una clase de clase trabajadora, podemos usar algunos mecanismos especiales que estar√°n disponibles autom√°ticamente en ella. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> { paint(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geom</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">properties</span></span></span><span class="hljs-class">) {   ctx.strokeStyle = 'white';   ctx.lineWidth = 4;   ctx.beginPath();   ctx.arc( 200, 200, 50, 0, 2*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Math</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PI</span></span></span><span class="hljs-class">);   ctx.stroke();   ctx.closePath(); } }</span></span></code> </pre> <br>  La devoluci√≥n de llamada <code>paint()</code> tiene los par√°metros <code>ctx</code> , <code>geom</code> y <code>properties</code> .  El par√°metro <code>ctx</code> es el mismo que el contexto de representaci√≥n 2D que se puede obtener del <code>&lt;canvas&gt;</code> .  Bueno, es casi lo mismo.  El hecho es que el <code>&lt;canvas&gt;</code> permite leer datos de p√≠xeles, pero la API de CSS Paint no lo permite.  A pesar de las diferencias, usando <code>ctx</code> , podemos usar los mismos m√©todos de salida gr√°fica que se usan cuando se trabaja con el <code>&lt;canvas&gt;</code> .  En este ejemplo, usando la funci√≥n <code>arc()</code> , dibujamos un c√≠rculo. <br><br>  Los primeros dos valores pasados ‚Äã‚Äãa la funci√≥n <code>arc()</code> son las coordenadas X e Y del centro del c√≠rculo, en p√≠xeles, en relaci√≥n con el origen ubicado en la esquina superior izquierda del elemento.  Sin embargo, quiero que el c√≠rculo est√© en el centro del elemento.  Para resolver este problema, el par√°metro <code>geom</code> es √∫til para nosotros.  Da acceso al objeto <code>PaintSize</code> , que es una descripci√≥n de la configuraci√≥n de la imagen.  En particular, al referirnos a √©l, podemos leer los par√°metros de <code>width</code> y <code>height</code> , y esto es exactamente lo que necesitamos para centrar el c√≠rculo. <br><br>  Como resultado, llegamos a este c√≥digo: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> { paint(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geom</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">properties</span></span></span><span class="hljs-class">) {     let x = geom.width/2;   let y = geom.height/2;   ctx.strokeStyle = 'white';   ctx.lineWidth = 4;   ctx.beginPath();   ctx.arc(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">, 50, 0, 2*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Math</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PI</span></span></span><span class="hljs-class">);   ctx.stroke();   ctx.closePath();   } } registerPaint('</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">awesomePattern'</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br>  Puede ver la versi√≥n funcional del ejemplo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CodePen</a> .  Estrictamente hablando, esto es lo que genera este c√≥digo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f2/18e/992/0f218e9927aa75625eb0ae0ae0ec8e4e.png"></div><br>  <i><font color="#999999">C√≠rculo creado con las API de CSS Paint</font></i> <br><br>  Todo esto es bueno, pero nuestro ejemplo es muy simple.  En lugar del c√≠rculo habitual, dibujemos algo m√°s interesante.  Por ejemplo, como un asterisco, el logotipo del sitio web css-tricks.com. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/26e/5a7/a1f26e5a7d56b1d3d98717c890deabbf.png"></div><br>  <i><font color="#999999">Asterisco creado con API de pintura CSS</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠ hay</a> un proyecto CodePen que le permite hacer esto. <br><br>  Cuando observe el c√≥digo JS para este proyecto, preste atenci√≥n al m√©todo <code>drawStar()</code> y a las muchas funciones que se utilizan al trabajar con el <code>&lt;canvas&gt;</code> . <br><br><h2>  <font color="#3AC1EF">Paso # 3: Propiedades CSS personalizadas</font> </h2><br>  Usando nueva tecnolog√≠a, podemos ir mucho m√°s all√° de dibujar c√≠rculos y estrellas.  Podemos observar las potentes funciones de las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propiedades</a> (variables) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">personalizadas de CSS</a> .  Ellos, por cierto, incluso por s√≠ mismos, son muy interesantes.  En nuestro caso, resultan ser especialmente √∫tiles. <br><br>  Supongamos que queremos poder cambiar el tama√±o o el color de un logotipo creado previamente.  Estos par√°metros se pueden colocar en el c√≥digo CSS en forma de propiedades personalizadas, y luego usarlos en el programa a trav√©s del tercer par√°metro, que se pasa a la devoluci√≥n de llamada <code>paint()</code> .  Se trata del par√°metro de <code>properties</code> . <br><br>  <code>--star-scale</code> propiedad <code>--star-scale</code> a nuestro c√≥digo CSS, que est√° dirigido a controlar el cambio de tama√±o de la imagen, y la propiedad <code>--star-color</code> , que se usa para organizar el cambio de color del logotipo directamente en CSS.  Esto es lo que tenemos: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">section</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">--star-scale</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">--star-color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">hsla</span></span>(200, 50%, 50%, 1); <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">paint</span></span>(awesomePattern) };</code> </pre> <br>  Ahora de vuelta a la clase de tela de trabajo.  Aqu√≠ necesitamos interactuar con las propiedades del usuario descritas anteriormente.  Esto se hace utilizando el m√©todo <code>inputProperties</code> , que nos da acceso a todas las propiedades CSS y sus valores asignados. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inputProperties</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'--star-scale'</span></span>,<span class="hljs-string"><span class="hljs-string">'--star-color'</span></span>]; }</code> </pre> <br>  Ahora puedes trabajar con ellos en el m√©todo <code>paint()</code> : <br><br><pre> <code class="hljs lisp">const size = parseInt(<span class="hljs-name"><span class="hljs-name">properties</span></span>.get('--shape-size').toString())<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Naturalmente, los valores obtenidos se pueden usar en el c√≥digo responsable de la formaci√≥n de la imagen.  Esto lleva al hecho de que si, en el c√≥digo CSS, cambiamos el valor de la <code>--star-scale</code> o <code>--start-color</code> , esto afectar√° inmediatamente el aspecto de la imagen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d2/7a0/676/7d27a06764d4888bcb66dc2a6d8d17b3.gif" alt="imagen"></div><br>  <i><font color="#999999">La influencia de las propiedades CSS personalizadas en la imagen terminada</font></i> <br><br>  Esta funcionalidad se implementa en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el mismo</a> proyecto CodePen que mencionamos anteriormente. <br><br>  Por cierto, vale la pena se√±alar que cuando se usa la nueva API, todas las propiedades CSS habituales relacionadas con la configuraci√≥n del fondo de elementos, como <code>background-size</code> y <code>background-repeat</code> , funcionar√°n de la misma manera que antes.  No han perdido relevancia. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  El CSS Paint API es una tecnolog√≠a muy poderosa cuyas capacidades no se limitan a la creaci√≥n de im√°genes de fondo. <br><br>  Imagine que el elemento debe tener un borde especial, por ejemplo, uno que no sea completamente visible o doble.  Quiz√°s para lograr tales efectos, usualmente usas los pseudoelementos <code>::before</code> o <code>::after</code> , o tal vez un <code>box-shadow</code> especialmente configurado.  Los bordes (y mucho m√°s) se pueden implementar utilizando la API de pintura CSS y la propiedad de <code>border-image</code> . <br><br>  La API de CSS Paint re√∫ne muchas caracter√≠sticas excelentes, como widgets, clases ECMAScript 2015 y las caracter√≠sticas del <code>&lt;canvas&gt;</code> .  Adem√°s, proporciona al desarrollador un software de gesti√≥n de im√°genes basado en JavaScript.  Por ejemplo, utilizando el mecanismo de eventos, puede organizar la actualizaci√≥n de propiedades personalizadas, lo que significa la imagen en s√≠, como, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , donde el evento <code>click</code> inicia el proceso de actualizaci√≥n de propiedades en la funci√≥n <code>requestAnimationFrame</code> , que le permite crear una animaci√≥n cada vez que el usuario hace clic en el bot√≥n.  Adem√°s, incluso las coordenadas del cursor del mouse cuando hace clic se tienen en cuenta. <br><br>  A primera vista, todo esto puede parecer un poco confuso, pero echemos un vistazo a algunas otras partes del proyecto Houdini con las que podemos encontrarnos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La API de dise√±o CSS</a> permite al desarrollador hacer algo como <code>display: layout('myCustomLayout')</code> .  Un ejemplo t√≠pico es la creaci√≥n de sus propios dise√±os de estilo de mamposter√≠a, pero el rango de uso de esta funci√≥n es mucho m√°s amplio. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La API de propiedades y valores de CSS le</a> permite establecer tipos de propiedades personalizadas. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La API CSS Animation Worklet empuja</a> las operaciones de procesamiento de animaci√≥n m√°s all√° de la transmisi√≥n principal, lo que deber√≠a traducirse en animaciones perfectamente fluidas. </li></ul><br>  Como resultado, podemos decir que, literalmente ante nuestros ojos, est√° surgiendo tecnolog√≠as que abren muchas nuevas oportunidades para los desarrolladores web.  Los procesos de estandarizaci√≥n e implementaci√≥n en los navegadores no son tan r√°pidos, pero posiblemente tendr√°n un tremendo impacto en todo lo relacionado con el dise√±o de las p√°ginas web. <br><br>  <b>Estimados lectores!</b>  ¬øQu√© √°reas de la aplicaci√≥n API de CSS Paint le parecen m√°s interesantes? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/cp/zf/te/cpzfteyh2kzlthzniyap-5t1h6c.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417075/">https://habr.com/ru/post/es417075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417063/index.html">Redes neuronales para los m√°s peque√±os.</a></li>
<li><a href="../es417065/index.html">Splunk How-to, o C√≥mo y d√≥nde aprender Splunk</a></li>
<li><a href="../es417069/index.html">Una vez m√°s sobre OpenSSL</a></li>
<li><a href="../es417071/index.html">Viernes PHP: seminarios web gratuitos de Skillbox</a></li>
<li><a href="../es417073/index.html">D√≠a del desarrollador m√≥vil de Uber</a></li>
<li><a href="../es417079/index.html">Administrador de paquetes para Kubernetes - Helm: pasado, presente, futuro</a></li>
<li><a href="../es417081/index.html">Norte, voluntad, esperanza, pa√≠s sin fronteras o c√≥mo se hacen los proyectos en condiciones severas de Siberia</a></li>
<li><a href="../es417083/index.html">Grandes cargas de la Copa Mundial 2018</a></li>
<li><a href="../es417085/index.html">Los navegadores silencian el sonido en su aplicaci√≥n WebRTC. ¬øDetener qu√©?</a></li>
<li><a href="../es417087/index.html">HPE Digitize 2018: evento y transmisi√≥n en vivo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>