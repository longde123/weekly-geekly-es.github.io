<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ðŸ˜† ðŸŽ± ðŸ”§ Bagaimana STACKLEAK Meningkatkan Keamanan Kernel Linux #âƒ£ ðŸŽ¿ ðŸ¤¤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="STACKLEAK adalah fitur keamanan kernel Linux yang awalnya dikembangkan oleh pencipta Grsecurity / PaX. Saya memutuskan untuk membawa STACKLEAK ke vani...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana STACKLEAK Meningkatkan Keamanan Kernel Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/424633/">  STACKLEAK adalah fitur keamanan kernel Linux yang awalnya dikembangkan oleh pencipta Grsecurity / PaX.  Saya memutuskan untuk membawa STACKLEAK ke vanilla kernel resmi (Linux kernel mainline).  Artikel ini akan berbicara tentang struktur internal, sifat-sifat fungsi keamanan ini dan jalurnya yang sangat sulit di jalur utama. <br><br><img src="https://habrastorage.org/webt/px/95/j_/px95j_edhs60awthgfeytj9uz84.png"><br><br><a name="habracut"></a><br><br>  STACKLEAK melindungi terhadap beberapa kelas kerentanan di kernel Linux, yaitu: <br><br><ul><li>  mengurangi informasi yang berguna bagi penyerang, yang dapat bocor dari tumpukan nuklir ke ruang pengguna; </li><li>  memblokir beberapa serangan terhadap variabel yang tidak diinisialisasi dalam tumpukan kernel; </li><li>  menyediakan alat deteksi overflow tumpukan dinamis. </li></ul><br>  Fitur keamanan ini sangat cocok dengan konsep Proyek Perlindungan Diri Kernel (KSPP): keamanan lebih dari sekadar memperbaiki bug.  Tentu saja semua kesalahan dalam kode tidak dapat diperbaiki, dan oleh karena itu kernel Linux harus bekerja dengan aman dalam situasi kesalahan, termasuk ketika mencoba untuk mengeksploitasi kerentanan.  Rincian lebih lanjut tentang KSPP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia di wiki proyek</a> . <br><br>  STACKLEAK hadir sebagai PAX_MEMORY_STACKLEAK di patch grsecurity / PaX.  Namun, patch grsecurity / PaX telah berhenti didistribusikan secara bebas sejak April 2017.  Oleh karena itu, penampilan STACKLEAK di kernel vanilla akan sangat berharga bagi pengguna Linux dengan peningkatan persyaratan keamanan informasi. <br><br>  Perintah kerja: <br><br><ul><li>  pilih STACKLEAK dari grsecurity / patch PaX, </li><li>  mempelajari kode dengan hati-hati dan membentuk tambalan, </li><li>  kirim ke LKML, dapatkan umpan balik, perbaiki, ulangi lagi sebelum diterima di jalur utama. </li></ul><br>  Pada saat penulisan (25 September 2018), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi 15 dari serangkaian tambalan</a> dikirim.  Ini berisi bagian dan kode arsitektur independen untuk x86_64 dan x86_32.  Dukungan STACKLEAK untuk arm64, yang dikembangkan oleh Laura Abbott dari Red Hat, telah berhasil masuk ke kernel vanilla 4.19. <cut></cut><br><br><h2>  STACKLEAK: fitur keamanan </h2><br><h3>  Menghapus informasi residual di tumpukan kernel </h3><br>  Ukuran ini mengurangi informasi yang berguna yang mungkin dihasilkan oleh beberapa kebocoran dari tumpukan nuklir ke ruang pengguna. <br><br>  Contoh kebocoran informasi dari tumpukan kernel disajikan pada Gambar 1. <br><br><img src="https://habrastorage.org/webt/kt/d2/6v/ktd26vqpdxlk4vk8lobb7ixrybc.png"><br><br>  <i>Skema 1.</i> <br><br>  Namun, kebocoran tipe ini menjadi tidak berguna jika, pada akhir panggilan sistem, bagian yang digunakan dari tumpukan kernel diisi dengan nilai tetap (Gambar 2). <br><br><img src="https://habrastorage.org/webt/fy/rr/w4/fyrrw4y-hyyms3pqjlumc_4k01w.png"><br><br>  Skema 2. <br><br>  Sebagai hasilnya, STACKLEAK memblokir beberapa serangan terhadap variabel yang tidak diinisialisasi dalam tumpukan kernel.  Contoh kerentanan tersebut: CVE-2017-17712, CVE-2010-2963.  Kita dapat menemukan deskripsi metodologi eksploitasi untuk kerentanan CVE-2010-2963 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam sebuah artikel oleh</a> Kees Cook. <br><br>  Inti serangan pada variabel yang tidak diinisialisasi dalam tumpukan kernel ditunjukkan pada Gambar 3. <br><br><img src="https://habrastorage.org/webt/8j/0p/po/8j0pposbamjhyq2jlsmuxpoqhfq.png"><br><br>  <i>Skema 3.</i> <br><br>  STACKLEAK memblokir serangan jenis ini, karena nilai yang mengisi tumpukan nuklir pada akhir panggilan sistem menunjukkan area yang tidak digunakan dalam ruang alamat virtual (Gambar 4). <br><br><img src="https://habrastorage.org/webt/-t/zp/ok/-tzpokwwsamgqqe0ij7tafszzps.png"><br><br>  <i>Skema 4.</i> <br><br>  Keterbatasan penting adalah bahwa STACKLEAK tidak melindungi terhadap serangan serupa yang dilakukan dalam satu panggilan sistem. <br><br><h3>  Deteksi overflow inti inti stack </h3><br>  Dalam kernel vanilla (Linux kernel mainline) STACKLEAK efektif terhadap overflow kedalaman tumpukan kernel hanya dalam hubungannya dengan CONFIG_THREAD_INFO_IN_TASK dan CONFIG_VMAP_STACK.  Kedua langkah ini diterapkan oleh Andy Lutomirski. <br><br>  Versi paling sederhana untuk mengeksploitasi jenis kerentanan ini ditunjukkan pada Gambar 5. <br><br><img src="https://habrastorage.org/webt/1a/vd/ft/1avdft3jdwd9utgtpletdnv_nuu.png"><br><br>  <i>Skema 5.</i> <br><br>  Menimpa bidang-bidang tertentu dalam struktur thread_info di bagian bawah tumpukan nuklir dapat meningkatkan hak istimewa proses.  Namun, ketika opsi CONFIG_THREAD_INFO_IN_TASK diaktifkan, struktur ini dihapus dari tumpukan nuklir, yang menghilangkan metode yang dijelaskan dalam mengeksploitasi kerentanan. <br><br>  Versi yang lebih maju dari serangan ini adalah menimpa data di wilayah memori tetangga dengan keluar dari batas tumpukan.  Lebih lanjut tentang pendekatan ini: <br><br><ul><li>  dalam presentasi " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Stack is Back</a> " oleh John Oberheide, </li><li>  dalam artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memanfaatkan Rekursi di Kernel Linux</a> " oleh Jann Horn. </li></ul><br>  Jenis serangan ini tercermin pada Gambar 6. <br><br><img src="https://habrastorage.org/webt/un/zy/3s/unzy3s_w29yrpp020kyj8bokvtw.png"><br><br>  <i>Skema 6.</i> <br><br>  Perlindungan dalam hal ini adalah CONFIG_VMAP_STACK.  Ketika opsi ini diaktifkan, halaman memori khusus (halaman penjaga) ditempatkan di sebelah tumpukan nuklir, akses yang mengarah ke pengecualian (Gambar 7). <br><br><img src="https://habrastorage.org/webt/9w/4b/ht/9w4bht4brf9z7zu6t8udygbr48q.png"><br><br>  <i>Skema 7.</i> <br><br>  Akhirnya, opsi paling menarik dari meluap tumpukan secara mendalam adalah serangan seperti Stack Clash.  Gagasan ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diajukan oleh</a> Gael Delalleau pada 2005. <br><br>  Pada 2017, peneliti dari perusahaan Qualys memikirkannya kembali, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyebut</a> teknik ini Stack Clash.  Faktanya adalah bahwa ada cara untuk melompati halaman penjaga dan menimpa data dari wilayah memori tetangga (Gambar 8).  Ini dilakukan dengan menggunakan array panjang variabel (VLA), yang ukurannya dikendalikan oleh penyerang. <br><br><img src="https://habrastorage.org/webt/vs/si/z2/vssiz2shuuuswmz96rmjongjjbs.png"><br><br>  <i>Skema 8.</i> <br><br>  Untuk informasi lebih lanjut tentang STACKLEAK dan Stack Clash, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat blog grsecurity</a> . <br><br>  Bagaimana STACKLEAK melindungi terhadap Stack Clash di tumpukan nuklir?  Sebelum setiap panggilan untuk mengalokasikan (), pemeriksaan dilakukan untuk stack overflow secara mendalam.  Berikut adalah kode yang sesuai dari versi 14 dari seri patch: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-function">used </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stackleak_check_alloca</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sp = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)&amp;sp; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack_info</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack_info</span></span></span><span class="hljs-class"> = {</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> visit_mask = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> stack_left; BUG_ON(get_stack_info(&amp;sp, current, &amp;stack_info, &amp;visit_mask)); stack_left = sp - (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)stack_info.begin; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt;= stack_left) { <span class="hljs-comment"><span class="hljs-comment">/* * Kernel stack depth overflow is detected, let's report that. * If CONFIG_VMAP_STACK is enabled, we can safely use BUG(). * If CONFIG_VMAP_STACK is disabled, BUG() handling can corrupt * the neighbour memory. CONFIG_SCHED_STACK_END_CHECK calls * panic() in a similar situation, so let's do the same if that * option is on. Otherwise just use BUG() and hope for the best. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined(CONFIG_VMAP_STACK) &amp;&amp; defined(CONFIG_SCHED_STACK_END_CHECK) panic(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"alloca() over the kernel stack boundary\n"</span></span></span><span class="hljs-meta">); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> BUG(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } }</span></span></code> </pre> <br>  Namun, fungsi ini dikecualikan dari versi 15.  Ini terutama karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">larangan</a> kontroversial Linus Torvalds <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk</a> menggunakan BUG_ON () di patch keamanan kernel Linux. <br><br>  Selain itu, versi ke-9 dari seri patch menyebabkan diskusi, sehingga diputuskan untuk menghilangkan semua array variabel dari kernel garis utama.  Sekitar 15 pengembang terlibat dalam pekerjaan ini, dan akan segera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">selesai</a> . <br><br><h2>  STACKLEAK Dampak Kinerja </h2><br>  Saya memberikan hasil pengujian kinerja pada x86_64.  Peralatan: Intel Core i7-4770, 16 GB RAM. <br><br>  Tes # 1, menarik: membangun kernel Linux pada inti prosesor tunggal <br><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment"># time make   4.18: real 12m14.124s user 11m17.565s sys 1m6.943s   4.18+stackleak: real 12m20.335s (+0.85%) user 11m23.283s sys 1m8.221s</span></span></code> </pre> <br>  Tes No. 2, tidak menarik: <br><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment"># hackbench -s 4096 -l 2000 -g 15 -f 25 -P    4.18: 9.08     4.18+stackleak: 9.47  (+4.3%)</span></span></code> </pre><br>  Oleh karena itu, efek dari STACKLEAK pada kinerja sistem tergantung pada jenis beban.  Secara khusus, sejumlah besar panggilan sistem pendek meningkatkan overhead.  T.O.  Kinerja STACKLEAK harus dievaluasi untuk beban yang direncanakan sebelum produksi. <br><br><h2>  Perangkat internal STACKLEAK </h2><br>  STACKLEAK terdiri dari: <br><br><ul><li>  Kode yang membersihkan tumpukan kernel pada akhir panggilan sistem (aslinya ditulis dalam assembler), </li><li>  Plugin GCC untuk kompilasi instrumental dari kode kernel. </li></ul><br>  Mengosongkan tumpukan kernel dilakukan dalam fungsi stackleak_erase ().  Fungsi ini memenuhi sebelum kembali ke ruang pengguna setelah panggilan sistem.  STACKLEAK_POISON (-0xBEEF) ditulis ke bagian tumpukan tumpukan yang digunakan.  Variabel terendah_stack, terus diperbarui di stackleak_track_stack (), menunjuk ke titik awal pembersihan. <br><br>  Tahapan stackleak_erase () tercermin dalam skema 9 dan 10. <br><br><img src="https://habrastorage.org/webt/o0/qu/ar/o0quaropj1l3lcpm_wkucohbrwq.png"><br><br>  <i>Skema 9.</i> <br><br><img src="https://habrastorage.org/webt/vb/qg/2v/vbqg2vqqzsqrstwaqew21svaids.png"><br><br>  <i>Skema 10.</i> <br><br>  T.O.  stackleak_erase () hanya membersihkan bagian yang digunakan dari tumpukan nuklir.  Itu sebabnya STACKLEAK sangat cepat.  Dan jika Anda menghapus semua 16 kB tumpukan kernel pada x86_64 pada akhir setiap panggilan sistem, hackbench menunjukkan penurunan kinerja 40%. <br><br>  Instrumentasi kode kernel pada tahap kompilasi dilakukan dalam plugin STACKLEAK GCC. <br><br>  Plugin GCC adalah modul yang dapat diunduh khusus proyek untuk kompiler GCC.  Mereka mendaftarkan pass baru dengan GCC Pass Manager, memberikan callback untuk pass ini. <br><br>  Jadi, untuk operasi STACKLEAK yang lengkap, panggilan ke stackleak_track_stack () dimasukkan ke dalam kode fungsi dengan bingkai tumpukan besar.  Juga, sebelum setiap alokasi (), panggilan ke stackleak_check_alloca () yang telah disebutkan dimasukkan, dan setelah itu, panggilan ke stackleak_track_stack () dimasukkan. <br><br>  Seperti yang telah disebutkan, pada versi 15 dari seri patch, penyisipan panggilan ke stackleak_check_alloca () dikecualikan dari plugin GCC. <br><br><h2>  Path di jalur utama kernel Linux </h2><br>  Jalur STACKLEAK di jalur utama sangat panjang dan sulit (Gambar 11). <br><br><img src="https://habrastorage.org/webt/px/95/j_/px95j_edhs60awthgfeytj9uz84.png"><br><br>  <i>Skema 11. Kemajuan implementasi STACKLEAK di jalur utama kernel Linux.</i> <br><br>  Pada bulan April 2017, pencipta grsecurity menutup tambalan mereka untuk komunitas, mulai mendistribusikannya hanya secara komersial.  Pada bulan Mei 2017, saya memutuskan untuk mengambil tugas memperkenalkan STACKLEAK ke dalam inti vanila.  Maka dimulailah perjalanan yang lebih lama dari satu tahun.  Perusahaan Positive Technologies, tempat saya bekerja, memberi saya kesempatan untuk menangani tugas ini selama beberapa waktu kerja saya.  Tetapi pada dasarnya, saya menghabiskan waktu "bebas" untuk itu. <br><br>  Sejak Mei lalu, seri tambalan saya telah mengalami beberapa ulasan, telah mengalami perubahan signifikan, telah dua kali dikritik oleh Linus Torvalds.  Saya ingin meninggalkan semua ini berkali-kali.  Tetapi pada saat tertentu ada keinginan kuat untuk mencapai akhir.  Pada saat penulisan (25 September 2018), versi ke-15 dari seri patch ada di cabang linux-next, memenuhi semua persyaratan yang disebutkan dari Linus dan siap untuk jendela gabungan dari kernel 4.20 / 5.0. <br><br>  Sebulan yang lalu, saya memberi ceramah tentang pekerjaan ini di Linux Security Summit.  Saya memberikan tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">slide</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> : <br><iframe width="560" height="315" src="https://www.youtube.com/embed/5wIniiWSgUc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Kesimpulan </h2><br>  STACKLEAK adalah fitur keamanan kernel Linux yang sangat berguna yang memblokir eksploitasi beberapa jenis kerentanan sekaligus.  Selain itu, penulis asli Tim PaX mampu membuatnya cepat dan cantik dalam rekayasa.  Oleh karena itu, penampilan STACKLEAK di kernel vanilla akan sangat berharga bagi pengguna Linux dengan peningkatan persyaratan keamanan informasi.  Selain itu, bekerja dalam arah ini menarik perhatian komunitas pengembang Linux untuk alat pertahanan diri kernel. <br><br><h2>  PS </h2><br>  STACKLEAK akhirnya diadopsi oleh kernel Linux 4.20: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=2d6bb6adb714b133db92ccd4bfc9c20f75f71f3f</a> <br><br>  Arsitektur yang didukung adalah x86_64, x86_32, dan arm64. <br><br>  Selain itu, pekerjaan telah selesai untuk menghilangkan array panjang variabel dari kode kernel Linux.  Peringatan kompiler Gcc "-Wvla" termasuk dalam versi kernel 4.20: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lkml.org/lkml/2018/10/28/189</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424633/">https://habr.com/ru/post/id424633/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424621/index.html">Superhero non-film. Siapa dan bagaimana melindungi situs konstruksi Lakhta Center dari kebakaran?</a></li>
<li><a href="../id424623/index.html">Mari kita proses suara di Go</a></li>
<li><a href="../id424625/index.html">Kode Sumber Layanan Web Aeroflot Kebocoran</a></li>
<li><a href="../id424627/index.html">Perubahan register kas. Bagian 1</a></li>
<li><a href="../id424629/index.html">Bagaimana para pemula meningkatkan peluang mereka untuk berinvestasi ketika berkomunikasi dengan seorang investor?</a></li>
<li><a href="../id424635/index.html">Selamat Datang di Sberbank Data Science Journey 2018 - Mesin Algoritma Pembelajaran Mesin</a></li>
<li><a href="../id424637/index.html">Barcode ajaib</a></li>
<li><a href="../id424639/index.html">Google berusia 20 tahun</a></li>
<li><a href="../id424641/index.html">Rebranding: hack seumur hidup bagaimana tidak menjadi subjek ejekan</a></li>
<li><a href="../id424645/index.html">Seperti yang kami lakukan survei internal paling masif di bank</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>