<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚪️ 👩🏿‍🔬 🤙🏽 Python Memory Management: Ein wenig über Speicherfragmentierung 🤜🏾 🌫️ 🤙🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einige Gedanken zu diesem Artikel . 

 Kürzlich interessierte mich, wie Python Memory Management in CPython für Python3 für 64-Bit-Ubuntu funktioniert...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python Memory Management: Ein wenig über Speicherfragmentierung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479744/">  <s>Einige Gedanken zu diesem <a href="https://rushter.com/blog/python-memory-managment/">Artikel</a> .</s> <br><br>  Kürzlich interessierte mich, wie Python Memory Management in CPython für Python3 <s>für 64-Bit-Ubuntu</s> funktioniert. <br><br><h2>  Ein bisschen Theorie </h2><br>  Die glibc-Systembibliothek verfügt über einen Malloc-Allokator.  Jeder Prozess verfügt über einen Speicherbereich, der als Heap bezeichnet wird.  Durch die dynamische Zuweisung von Speicher durch Aufrufen der malloc-Funktion erhalten wir einen Teil aus dem Haufen dieses Prozesses.  Wenn die Größe des angeforderten Speichers klein ist (nicht mehr als 128 KB), kann der Speicher aus den Listen der freien Blöcke entnommen werden.  Ist dies nicht möglich, wird der Speicher mit dem <s>Systemaufruf</s> mmap <s>(sbrk, brk) zugewiesen</s> .  Der Systemaufruf mmap ordnet den virtuellen Speicher dem physischen Speicher zu.  Der Speicher wird in 4-KB-Seiten angezeigt.  Große Chunks (über 128 KB) werden immer über den mmap-Systemaufruf zugewiesen.  Wenn beim Freigeben von Speicher ein freier kleiner Block an einen Bereich mit nicht eingefrorenem Speicher angrenzt, wird möglicherweise ein Teil des Speichers an das Betriebssystem zurückgegeben.  Große Chunks kehren sofort zum Betriebssystem zurück. <br><a name="habracut"></a><br>  Informationen aus einem <a href="https://acm.bsu.by/w/index.php%3Ftitle%3DC2017/%25D0%2590%25D0%25BB%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%25D1%258B">Vortrag über Allokatoren in C.</a> <br><br>  CPython hat einen eigenen Allokator (PyMalloc) für den "privaten Heap" und Allokatoren für jeden Objekttyp, der "über" dem ersten arbeitet.  PyMalloc fordert 256-KB-Speicherabschnitte über malloc in der Betriebssystembibliothek namens Arenas an.  Sie sind wiederum durch 4 KB in Pools unterteilt.  Jeder Pool ist in Blöcke fester Größe unterteilt, und jeder kann in Blöcke einer von 64 Größen unterteilt werden. <br><br>  Allokatoren für jeden Typ verwenden die bereits zugewiesenen Chunks, falls vorhanden.  Wenn keine vorhanden sind, gibt PyMalloc einen neuen Pool aus der ersten Arena aus, in dem ein Platz für einen neuen Pool vorhanden ist (Arenen werden in absteigender Reihenfolge der Belegung „sortiert“).  Wenn dies nicht funktioniert, fragt PyMalloc das Betriebssystem nach einer neuen Arena.  Außer wenn die angeforderte Speichergröße mehr als 512B beträgt, wird der Speicher direkt über malloc aus der Systembibliothek zugewiesen. <br><br>  Wenn ein Objekt gelöscht wird, wird der Speicher nicht an das Betriebssystem zurückgegeben, sondern die Chunks kehren einfach zu den entsprechenden Pools und die Pools zu den Arenen zurück.  Die Arena kehrt zum Betriebssystem zurück, wenn alle Chunks davon befreit sind.  Wie sich herausstellt, wird der gesamte Speicher in der Arena von PVM verwendet, wenn eine relativ kleine Anzahl von Chunks in der Arena verwendet wird.  Da Chunks über 128 KB über mmap zugewiesen werden, kehrt die kostenlose Arena sofort zum Betriebssystem zurück. <br><br>  Ich möchte mich auf zwei Punkte konzentrieren: <br><br><ol><li>  Es stellt sich heraus, dass PyMalloc beim Erstellen einer neuen Arena 256 KB <b>physischen</b> Speicher zuweist. </li><li>  Es werden nur freie Arenen an das Betriebssystem zurückgegeben. </li></ol><br><h2>  Beispiel </h2><br>  Betrachten Sie das folgende Beispiel: <br><br><pre><code class="python hljs">iterations = <span class="hljs-number"><span class="hljs-number">2000000</span></span> l = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(iterations): l.append(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(iterations): l[i] = {} s = [] <span class="hljs-comment"><span class="hljs-comment"># [1] # s = l[::2] # [2] # s = l[2000000 // 2::] # [3] # s = l[::100] # [4] for i in range(iterations): l[i] = None for i in range(iterations): l[i] = {}</span></span></code> </pre> <br>  Im Beispiel wird eine Liste mit 2 Millionen Elementen erstellt, die alle auf ein Objekt mit dem Namen None verweisen.  Im nächsten Zyklus wird für jedes Element ein Objekt erstellt - ein leeres Wörterbuch.  Dann wird eine zweite Liste erstellt, deren Elemente auf einige Objekte verweisen, auf die von einigen Elementen der ersten Liste verwiesen wird.  Nach dem nächsten Crawl beginnen die Elemente aus der Liste l wieder auf das Objekt None zu zeigen.  Und im letzten Zyklus werden wieder Wörterbücher für jedes Element aus der ersten Liste erstellt. <br><br>  Optionen der S-Liste: <br><br><ol><li><pre> <code class="plaintext hljs">s = []</code> </pre> </li><li><pre> <code class="plaintext hljs">s = l[::2]</code> </pre> </li><li><pre> <code class="plaintext hljs">s = l[200000 // 2::]</code> </pre> </li><li><pre> <code class="plaintext hljs">s = l[::100]</code> </pre> </li></ol><br>  Wir sind jeweils am Speicherverbrauch interessiert. <br><br>  Wir werden dieses Skript mit aktivierter PyMalloc-Protokollierung ausführen: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PYTHONMALLOCSTATS=<span class="hljs-string"><span class="hljs-string">"True"</span></span> &amp;&amp; python3 source.py 2&gt;result.txt</code> </pre><br><h2>  Erläuterung der Ergebnisse </h2><br>  In den Bildern sehen Sie jeweils den Speicherverbrauch.  <i>Auf der Abszissenachse gibt es keine Korrelation von Werten mit dem Zeitpunkt, zu dem ein solcher Verbrauch stattfand. Nur jeder Wert in den Protokollen ist mit seiner Seriennummer verknüpft.</i> <br><br><img src="https://habrastorage.org/webt/e0/tk/ak/e0tkakp6umcmmx5xopaqno1phyc.png" alt="Bild"><br><br><h4>  "Ohne Elemente" </h4><br>  Im ersten Fall ist die Liste leer.  Nach dem Erstellen der Objekte im zweiten Zyklus werden ca. 500 MB Speicher verbraucht.  Alle diese Objekte werden im dritten Zyklus gelöscht, und der verwendete Speicher wird an das Betriebssystem zurückgegeben.  Im letzten Zyklus wird erneut Speicher für Objekte zugewiesen, was zu einem Verbrauch von 500 MB führt. <br><br><h4>  "Jede Sekunde" </h4><br>  In dem Fall, dass wir mit jedem zweiten Element der Liste 1 eine Liste erstellen, können wir feststellen, dass der Speicher nicht an das Betriebssystem zurückgegeben wird.  Das heißt, in diesem Fall stellen wir eine Situation fest, in der Wörterbücher mit ungefähr 250 MB gelöscht werden, in jedem Pool jedoch Chunks vorhanden sind, die nicht gelöscht werden, wodurch die entsprechenden Arenen nicht freigegeben werden.  Wenn wir die Wörterbücher jedoch zum zweiten Mal erstellen, werden die freien Chunks aus diesen Pools wiederverwendet, weshalb nur etwa 250 MB neuer Speicher zugewiesen werden. <br><br><h4>  "Die zweite Hälfte" </h4><br>  In dem Fall, dass wir eine Liste aus der zweiten Hälfte der Elemente der Liste 1 erstellen, befindet sich die erste Hälfte in separaten Arenen, wodurch ungefähr 250 MB Speicher an das Betriebssystem zurückgegeben werden.  Danach werden ca. 500 MB neuen Wörterbüchern zugewiesen, weshalb der Gesamtverbrauch in der Region von 750 MB liegt. <br><br>  In diesem Fall wird der Speicher, anders als im zweiten Fall, teilweise an das Betriebssystem zurückgegeben.  Was einerseits anderen Prozessen ermöglicht, diesen Speicher zu nutzen, erfordert andererseits Systemaufrufe, um ihn freizugeben und neu zuzuweisen. <br><br><h4>  "Jeder Hundertste" </h4><br>  Der letzte Fall scheint der interessanteste zu sein.  Dort erstellen wir aus jedem hundertsten Element der ersten Liste eine zweite Liste, die ungefähr 5 MB benötigt.  Aufgrund der Tatsache, dass eine bestimmte Anzahl von belegten Chunks in jeder Arena verbleibt, wird dieser Speicher nicht freigegeben und der Verbrauch bleibt auf dem Niveau von 500 MB.  Wenn Sie Wörterbücher zum zweiten Mal erstellen, wird fast kein neuer Speicher zugewiesen, und die Chunks, die zum ersten Mal zugewiesen wurden, werden wiederverwendet. <br><br>  In dieser Situation verbrauchen wir aufgrund der Speicherfragmentierung 100-mal mehr, als wir benötigen.  Wenn dieser Speicher jedoch wiederholt benötigt wird, müssen wir keine Systemaufrufe durchführen, um ihn zuzuweisen. <br><br><h2>  Zusammenfassung </h2><br>  Es ist anzumerken, dass eine Speicherfragmentierung möglich ist, wenn viele Allokatoren verwendet werden.  Trotzdem müssen Sie einige Datenstrukturen, z. B. solche mit Baumstruktur, wie Suchbäume, sorgfältig verwenden.  Weil willkürliche Operationen des Hinzufügens und Löschens zu der oben beschriebenen Situation führen können, weshalb die Zweckmäßigkeit der Verwendung dieser Strukturen hinsichtlich des Speicherverbrauchs zweifelhaft sein wird. <br><br><div class="spoiler">  <b class="spoiler_title">Code zum Rendern von Bildern</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename)</span></span></span><span class="hljs-function">:</span></span> ms = [] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename, <span class="hljs-string"><span class="hljs-string">"r"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> line.startswith(<span class="hljs-string"><span class="hljs-string">"Total"</span></span>): m = float(line.split()[<span class="hljs-number"><span class="hljs-number">-1</span></span>].replace(<span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>)) / <span class="hljs-number"><span class="hljs-number">1024</span></span> / <span class="hljs-number"><span class="hljs-number">1024</span></span> ms.append(m) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ms ms_1 = parse_result(<span class="hljs-string"><span class="hljs-string">"_1.txt"</span></span>) ms_2 = parse_result(<span class="hljs-string"><span class="hljs-string">"_2.txt"</span></span>) ms_3 = parse_result(<span class="hljs-string"><span class="hljs-string">"_3.txt"</span></span>) ms_4 = parse_result(<span class="hljs-string"><span class="hljs-string">"_4.txt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>)) fontdict = { <span class="hljs-string"><span class="hljs-string">"fontsize"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-string"><span class="hljs-string">"fontweight"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, } plt.subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) plt.title(<span class="hljs-string"><span class="hljs-string">" "</span></span>, fontdict=fontdict, loc=<span class="hljs-string"><span class="hljs-string">"left"</span></span>) plt.plot(ms_1) plt.grid(b=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>, color=<span class="hljs-string"><span class="hljs-string">'#666666'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">'-.'</span></span>) plt.minorticks_on() plt.grid(b=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, which=<span class="hljs-string"><span class="hljs-string">'minor'</span></span>, color=<span class="hljs-string"><span class="hljs-string">'#999999'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">'-'</span></span>, alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>) plt.tick_params(axis=<span class="hljs-string"><span class="hljs-string">'both'</span></span>, which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>, labelsize=<span class="hljs-number"><span class="hljs-number">15</span></span>, labelbottom=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">"MB"</span></span>, fontsize=<span class="hljs-number"><span class="hljs-number">15</span></span>) plt.subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) plt.title(<span class="hljs-string"><span class="hljs-string">" "</span></span>, fontdict=fontdict, loc=<span class="hljs-string"><span class="hljs-string">"left"</span></span>) plt.plot(ms_2) plt.grid(b=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>, color=<span class="hljs-string"><span class="hljs-string">'#666666'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">'-.'</span></span>) plt.minorticks_on() plt.grid(b=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, which=<span class="hljs-string"><span class="hljs-string">'minor'</span></span>, color=<span class="hljs-string"><span class="hljs-string">'#999999'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">'-'</span></span>, alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>) plt.tick_params(axis=<span class="hljs-string"><span class="hljs-string">'both'</span></span>, which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>, labelsize=<span class="hljs-number"><span class="hljs-number">15</span></span>, labelbottom=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">"MB"</span></span>, fontsize=<span class="hljs-number"><span class="hljs-number">15</span></span>) plt.subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) plt.title(<span class="hljs-string"><span class="hljs-string">" "</span></span>, fontdict=fontdict, loc=<span class="hljs-string"><span class="hljs-string">"left"</span></span>) plt.plot(ms_3) plt.grid(b=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>, color=<span class="hljs-string"><span class="hljs-string">'#666666'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">'-.'</span></span>) plt.minorticks_on() plt.grid(b=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, which=<span class="hljs-string"><span class="hljs-string">'minor'</span></span>, color=<span class="hljs-string"><span class="hljs-string">'#999999'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">'-'</span></span>, alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>) plt.tick_params(axis=<span class="hljs-string"><span class="hljs-string">'both'</span></span>, which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>, labelsize=<span class="hljs-number"><span class="hljs-number">15</span></span>, labelbottom=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">"MB"</span></span>, fontsize=<span class="hljs-number"><span class="hljs-number">15</span></span>) plt.subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) plt.title(<span class="hljs-string"><span class="hljs-string">" "</span></span>, fontdict=fontdict, loc=<span class="hljs-string"><span class="hljs-string">"left"</span></span>) plt.plot(ms_4) plt.grid(b=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>, color=<span class="hljs-string"><span class="hljs-string">'#666666'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">'-.'</span></span>) plt.minorticks_on() plt.grid(b=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, which=<span class="hljs-string"><span class="hljs-string">'minor'</span></span>, color=<span class="hljs-string"><span class="hljs-string">'#999999'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">'-'</span></span>, alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>) plt.tick_params(axis=<span class="hljs-string"><span class="hljs-string">'both'</span></span>, which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>, labelsize=<span class="hljs-number"><span class="hljs-number">15</span></span>, labelbottom=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">"MB"</span></span>, fontsize=<span class="hljs-number"><span class="hljs-number">15</span></span>)</code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479744/">https://habr.com/ru/post/de479744/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479728/index.html">Wie organisiere ich einen erfolgreichen Start?</a></li>
<li><a href="../de479732/index.html">Stellen Sie die Ausgabe von etwas anderem als Speicherverlust ein</a></li>
<li><a href="../de479736/index.html">Kameras oder Laser</a></li>
<li><a href="../de479738/index.html">Wie Youtube und Instagram: Internationalisierung und Lokalisierung einer Python-Anwendung</a></li>
<li><a href="../de479742/index.html">Backyards - ein automatisiertes Service-Mesh auf einer Multi-Cloud- und Hybrid-Infrastruktur</a></li>
<li><a href="../de479746/index.html">Unternehmenssoftware macht Ihre Mitarbeiter kühler. Brauchst du es</a></li>
<li><a href="../de479748/index.html">GoLand 2019.3 mit verbesserter Leistung, verbesserter Unterstützung für Go-Module und mehr</a></li>
<li><a href="../de479750/index.html">2. Fortinet Erste Schritte v 6.0. Lösungsarchitektur</a></li>
<li><a href="../de479756/index.html">Daten öffnen. Roscosmos. Holen Sie sich mit Amerika</a></li>
<li><a href="../de479758/index.html">Pentest. Die Praxis des Penetrationstests oder des „ethischen Hackings“. Neuer Kurs von OTUS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>