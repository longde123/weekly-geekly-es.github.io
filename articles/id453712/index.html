<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚰️ 🤳 👃🏿 Bagaimana eBay melakukan pemindai barcode di WebAssembly ☝🏼 👸🏼 ✌🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sejak diumumkan, teknologi WebAssembly telah segera menarik perhatian pengembang front-end. Komunitas web dengan antusias menerima gagasan menjalankan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana eBay melakukan pemindai barcode di WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453712/"> Sejak diumumkan, teknologi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebAssembly</a> telah segera menarik perhatian pengembang front-end.  Komunitas web dengan antusias menerima gagasan menjalankan kode dalam peramban yang ditulis dalam bahasa selain JavaScript.  Yang utama adalah WebAssembly menjamin kecepatan jauh lebih tinggi dari JavaScript. <br><br>  Teknisi kami mengikuti perkembangan standar dengan cermat.  Segera setelah dukungan WebAssembly 1.0 diimplementasikan di semua browser utama, para pengembang segera ingin mencobanya. <br><br>  Tapi ada masalah.  Meskipun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak aplikasi</a> mendapat manfaat dari WebAssembly, ruang lingkup teknologi dalam e-commerce masih primitif.  Kami tidak dapat segera menemukan versi penggunaan yang benar.  Ada beberapa saran, tetapi JavaScript lebih baik di semua variasi.  Ketika kami mengevaluasi teknologi baru di eBay, pertanyaan pertama adalah: "Apa manfaat potensial bagi pelanggan kami?"  Jika tidak ada kejelasan di sini, kami tidak akan melanjutkan ke langkah berikutnya.  Sangat mudah untuk terbawa oleh teknologi baru yang modis, bahkan jika itu tidak masalah bagi pelanggan dan hanya mempersulit alur kerja yang ada.  Pengalaman pengguna selalu lebih penting daripada pengalaman pengembang.  Tetapi dengan WebAssembly berbeda.  Teknologi ini memiliki potensi yang sangat besar, kami tidak dapat menemukan use case yang tepat.  Namun, pada akhirnya mereka tetap menemukannya. <br><a name="habracut"></a><br><h2>  Pemindai kode batang </h2><br>  Di aplikasi eBay asli di iOS dan Android, ada fitur pemindaian barcode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UPC</a> untuk secara otomatis masuk ke dalam formulir.  Ini hanya berfungsi dalam aplikasi dan membutuhkan pemrosesan intensif gambar pada perangkat untuk mengenali digit barcode dalam aliran gambar dari kamera.  Kode yang dihasilkan kemudian dikirim ke layanan server, yang, pada gilirannya, mengisi formulir.  Ini berarti bahwa logika pemrosesan gambar pada perangkat harus sangat efisien.  Untuk aplikasi asli, kami mengkompilasi pustaka C ++ kami sendiri ke dalam kode asli untuk iOS dan Android.  Ia mengenali barcode dengan sangat baik.  Kami secara bertahap pindah ke API asli di iOS dan Android, tetapi pustaka C ++ kami masih dapat diandalkan. <br><br>  Pemindai barcode adalah fungsi intuitif untuk penjual, ini secara signifikan menyederhanakan pengisian formulir.  Sayangnya, fungsi ini tidak berfungsi pada versi seluler situs tersebut, dan penjual harus secara manual memasuki UPC, yang tidak nyaman. <br><br><h2>  Pemindai Kode Batang Web </h2><br>  Kami dulu mencari opsi untuk memindai barcode di web.  Dua tahun lalu, mereka bahkan merilis prototipe berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka</a> sumber terbuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BarcodeReader</a> JavaScript.  Masalahnya adalah bahwa itu bekerja dengan baik hanya dalam 20% kasus.  Sisa 80% dari waktu pemindai bekerja sangat lambat atau tidak berfungsi sama sekali.  Dalam kebanyakan kasus, itu adalah batas waktu.  Sangat diharapkan: JavaScript dapat dibandingkan dalam kecepatan dengan kode asli hanya jika berada di "jalur panas", yaitu sangat dioptimalkan oleh kompiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JIT</a> .  Kuncinya adalah bahwa mesin JavaScript menggunakan banyak heuristik untuk menentukan apakah jalurnya "panas" tanpa menjamin hasil.  Perbedaan ini jelas menyebabkan frustrasi pengguna, dan kami harus menonaktifkan fitur ini.  Tapi sekarang semuanya berbeda.  Dengan pesatnya perkembangan platform web, muncul pertanyaan: "Apakah mungkin untuk menerapkan pemindai barcode yang dapat diandalkan di web?" <br><br>  Salah satu opsi adalah menunggu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Deteksi Bentuk</a> keluar dengan fitur deteksi gambar bawaannya, termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">barcode</a> .  Tetapi antarmuka ini masih pada tahap awal pengembangan dan jauh dari kompatibilitas lintas-browser.  Dan bahkan dalam hal ini, bekerja di semua platform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak dijamin</a> .  Karena itu, Anda harus mempertimbangkan opsi lain. <br><br>  Di sinilah WebAssembly ikut bermain.  Jika pemindai kode batang diterapkan pada WebAssembly, maka dijamin akan berfungsi.  Struktur pengetikan dan bytecode yang kuat dari WebAssembly memungkinkan Anda untuk selalu menjaga "jalur panas" eksekusi.  Selain itu, kami sudah memiliki pustaka C ++ untuk aplikasi asli.  Pustaka C ++ adalah kandidat ideal untuk kompilasi di WebAssembly.  Kami pikir masalahnya sudah teratasi.  Ternyata, tidak juga. <br><br><h2>  Arsitektur </h2><br>  Arsitektur prototipe yang berfungsi untuk pemindai barcode di WebAssembly cukup sederhana. <br><br><ul><li>  Kompilasi pustaka C ++ dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Emscripten</a> .  Ini akan menghasilkan middleware dan file .wasm. <br></li><li>  Pilih utas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pekerja</a> dari utas utama.  Kode JavaScript untuk pekerja mengimpor kode tautan JavaScript yang dihasilkan, yang pada gilirannya menciptakan file .wasm. <br></li><li>  Streaming utama mengirimkan snapshot dari stream dari kamera ke stream pekerja, dan itu akan memanggil API WASM yang sesuai melalui kode penghubung.  Respons API diteruskan ke utas utama.  Respons dapat berupa string UPC (yang diteruskan ke backend) atau string kosong jika tidak ada barcode yang terdeteksi. <br></li><li>  Untuk jawaban kosong, langkah di atas diulangi sampai barcode terdeteksi.  Siklus ini berjalan untuk interval waktu yang ditentukan dalam detik.  Setelah ambang tercapai, kami akan menampilkan pesan peringatan <i>“Kode produk tidak valid.</i>  <i>Coba cari barcode atau teks lain</i> . <i>"</i>  Entah pengguna tidak memfokuskan kamera pada barcode asli, atau pemindai tidak cukup efektif.  Kami melacak statistik batas waktu sebagai indikator kualitas pemindai. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/08c/b99/50e08cb9985f38e32a51caefe0a0356d.png"></div><br>  <i><font color="gray">Web Alur Kerja Perakitan</font></i> <br><br><h4>  Kompilasi </h4><br>  Langkah pertama dalam setiap proyek WebAssembly adalah menentukan pipa kompilasi yang jelas.  Emscripten telah menjadi standar de facto untuk mengkompilasi WebAssembly, tetapi penting untuk memiliki lingkungan yang konsisten yang menghasilkan hasil deterministik.  Frontend kami didasarkan pada Node.js, jadi kami perlu mencari solusi yang kompatibel dengan alur kerja npm.  Untungnya, sekitar waktu itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Surma Das</a> menerbitkan sebuah artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berjudul "Emscripten and npm"</a> .  Pendekatan berbasis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker</a> untuk mengkompilasi WebAssembly masuk akal karena menghilangkan satu ton overhead.  Seperti yang direkomendasikan dalam artikel, kami mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gambar</a> buruh pelabuhan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Emscripten</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">trzeci</a> .  Untuk mengaktifkan kompilasi di WebAssembly, pustaka C ++ asli harus di-tweak sedikit.  Pada dasarnya, kami bertindak secara acak, coba-coba.  Pada akhirnya, saya berhasil mengompilasinya, dan juga mengatur alur kerja WebAssembly yang rapi dalam pipa perakitan yang ada. <br><br><h4>  Ini bekerja cepat, tetapi ... </h4><br>  Kinerja pemindai diukur dengan jumlah frame yang diproses oleh Wasm API per detik.  API Wasm mengambil bingkai dari aliran video kamera, melakukan perhitungan, dan mengembalikan respons.  Ini dilakukan secara berkelanjutan hingga barcode terdeteksi.  Kinerja diukur dalam FPS. <br><br>  Implementasi pengujian kami atas WebAssembly menunjukkan kecepatan luar biasa 50 FPS.  Namun, itu hanya bekerja di 60% kasus, dan sisanya jatuh karena batas waktu.  Bahkan dengan FPS setinggi itu, mereka tidak dapat dengan cepat mendeteksi kode batang untuk sisa 40% pindaian, memberikan pesan peringatan di bagian akhir.  Sebagai perbandingan, implementasi JavaScript sebelumnya biasanya berjalan pada 1 FPS.  Ya, WebAssembly jauh lebih cepat (50 kali), tetapi untuk beberapa alasan itu tidak bekerja di hampir setengah kasus.  Perlu juga dicatat bahwa dalam beberapa situasi, JavaScript bekerja dengan sangat baik dan segera menemukan kode batang.  Salah satu opsi yang jelas adalah untuk meningkatkan batas waktu, tetapi ini hanya akan meningkatkan frustrasi pengguna, sehingga kami tidak memecahkan masalah sebenarnya.  Karena itu, kami meninggalkan ide ini. <br><br>  Pada awalnya, kami tidak dapat memahami mengapa pustaka C ++ asli, yang bekerja dengan sempurna dalam aplikasi asli, tidak menunjukkan hasil yang sama di web.  Setelah pengujian dan debugging yang panjang, kami menemukan bahwa kecepatan pengenalan tergantung pada sudut fokus objek dan bayangan latar belakang.  Tetapi bagaimana kemudian semuanya bekerja di aplikasi asli?  Faktanya adalah bahwa dalam aplikasi asli kami menggunakan API bawaan untuk fokus otomatis dan memberi pengguna kesempatan untuk fokus secara manual dengan mengarahkan jari ke barcode.  Oleh karena itu, aplikasi asli selalu menyediakan perpustakaan dengan gambar yang jelas berkualitas tinggi. <br><br>  Menyadari esensi dari apa yang terjadi, kami memutuskan untuk mencoba perpustakaan asli lain: pemindai kode batang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ZBar</a> sumber terbuka yang cukup populer dan stabil.  Lebih penting lagi, ini bekerja dengan baik dengan gambar buram dan kasar.  Mengapa tidak mencobanya?  Karena kami sudah memiliki alur kerja WebAssembly, kompilasi dan penyebaran ZBar di WebAssembly berjalan dengan lancar.  Kinerja ternyata lumayan, sekitar 15 FPS, meskipun tidak sebagus perpustakaan C ++ kami sendiri.  Tetapi tingkat keberhasilannya mendekati 80% untuk batas waktu yang sama.  Peningkatan yang jelas atas pustaka C ++ kami, tetapi masih belum 100%. <br><br>  Hasilnya belum memuaskan kami, tetapi kami melihat sesuatu yang tidak terduga.  Di mana Zbar crash, pustaka C ++ kami sendiri melakukan pekerjaan dengan sangat cepat.  Itu adalah kejutan yang menyenangkan.  Tampaknya perpustakaan memproses gambar dengan kualitas berbeda dengan cara yang berbeda.  Ini membawa kami ke ide. <br><br><h4>  Multithreading dan balap cepat </h4><br>  Anda mungkin sudah mengerti.  Mengapa tidak membuat dua utas pekerja: satu untuk Zbar dan satu untuk pustaka C ++ kami, dan tidak menjalankannya secara paralel.  Siapa pun yang menang (siapa pun yang terlebih dahulu mengirim barcode yang valid) mengirimkan hasilnya ke aliran utama, dan kedua pekerja berhenti.  Kami menerapkan skenario seperti itu dan mulai menguji diri kami, mencoba mensimulasikan sebanyak mungkin skenario.  Pengaturan ini menunjukkan 95% dari pemindaian yang berhasil.  Jauh lebih baik dari hasil sebelumnya, tetapi masih belum 100%. <br><br>  Salah satu saran aneh adalah menambahkan perpustakaan JavaScipt asli ke kompetisi.  Itu akan menjadi tiga aliran.  Kami jujur ​​tidak berpikir bahwa ini akan mengubah apa pun.  Namun pengujian semacam itu tidak memerlukan upaya apa pun, karena kami menstandarisasi antarmuka yang berfungsi.  Yang mengejutkan kami, dengan tiga aliran, tingkat keberhasilannya benar-benar mendekati 100%.  Sekali lagi ini benar-benar tidak terduga.  Seperti yang disebutkan sebelumnya, JavaScript bekerja sangat baik dalam beberapa situasi.  Rupanya, dia menutup celah itu.  Jadi kearifan populer dari hukum adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"JavaScript selalu menang</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a>  Jika tanpa lelucon, ilustrasi berikut ini memberikan gambaran arsitektur final yang telah kami terapkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/f91/050/422f9105014e7571197453c7d2c9f6ec.png"></div><br>  <i><font color="gray">Pemindai kode batang arsitektur web</font></i> <br><br>  Gambar berikut menunjukkan diagram fungsional tingkat tinggi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a74/005/4a6a740059f1599e759d9641a3251233.png"></div><br>  <i><font color="gray">Diagram fungsional pemindai barcode</font></i> <br><br><h4>  Catatan Pemuatan Sumber Daya </h4><br>  Sumber daya yang diperlukan agar pemindai berfungsi sudah dimuat sebelumnya setelah merender halaman utama.  Dengan cara ini, halaman arahan memuat dengan cepat dan siap untuk interaksi.  Sumber daya WebAssembly (file wasm dan skrip middleware) dan pustaka pemindai JavaScript dimuat sebelumnya dan di-cache menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XMLHttpRequest</a> setelah memuat halaman utama.  Penting di sini bahwa mereka tidak dieksekusi segera untuk membiarkan utas utama gratis untuk interaksi pengguna dengan halaman.  Eksekusi hanya terjadi ketika pengguna mengklik ikon barcode.  Jika pengguna mengklik ikon sebelum memuat sumber daya, mereka akan dimuat sesuai permintaan dan segera dieksekusi.  Penangan kejadian pemindai barcode dan pengontrol pekerja dimuat dengan halaman, tetapi mereka sangat kecil. <br><br><h2>  Hasil </h2><br>  Setelah pengujian yang ketat dan penggunaan internal oleh karyawan, kami meluncurkan pengujian A / B pada pengguna.  Ikon pemindai (tangkapan layar di bawah) ditunjukkan ke grup uji, tetapi tidak ke grup kontrol. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb5/a30/074/bb5a300749c27008137e8f45c9bdced9.png"></div><br>  <i><font color="gray">Produk akhir</font></i> <br><br>  Untuk mengukur keberhasilan, kami memperkenalkan metrik Draft Completion Rate.  Ini adalah waktu antara mulai mengedit draf dan mengirimkan formulir.  Metrik harus menunjukkan bagaimana pemindai barcode membantu orang mengisi formulir.  Tes berlangsung beberapa minggu, dan hasilnya sangat menyenangkan.  Mereka sepenuhnya konsisten dengan hipotesis asli kami.  <b>Waktu penyelesaian konsep berkurang 30% untuk streaming dengan pemindai barcode.</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7f/f62/177/c7ff62177f92bc9f19059c569f2531ed.png"></div><br>  <i><font color="gray">Hasil Tes A / B</font></i> <br><br>  Kami juga menambahkan profiling untuk mengevaluasi efektivitas semua jenis pemindai.  Seperti yang diharapkan, kontribusi terbesar dibuat oleh Zbar (53% dari pemindaian yang berhasil), kemudian pustaka C ++ kami (34%) dan, akhirnya, pustaka JavaScript dengan 13%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/359/c5c/a31359c5c4211bf10548d8162370da89.png"></div><br><br><h2>  Kesimpulan </h2><br>  Pengalaman menerapkan WebAssembly telah menjadi sangat informatif bagi kami.  Insinyur sangat senang dengan kemunculan teknologi baru dan segera ingin mencobanya.  Jika teknologi ini juga berguna bagi pelanggan, maka ini adalah kesenangan ganda.  Mari kita ulangi pemikiran yang diungkapkan di awal artikel.  Teknologi berkembang dengan sangat cepat.  Setiap hari sesuatu yang baru muncul.  Tetapi hanya beberapa teknologi yang penting bagi pelanggan, dan WebAssembly adalah salah satunya.  Kesimpulan terbesar kami dari latihan ini adalah mengatakan "tidak" dalam 99 situasi dan "ya" dalam satu-satunya kasus ketika itu benar-benar penting bagi klien. <br><br>  Di masa depan, kami berencana untuk memperluas penggunaan pemindai barcode dan memperkenalkannya di sisi pembeli, sehingga mereka dapat memindai kode produk secara offline untuk pencarian dan pembelian di eBay.  Kami juga akan mempertimbangkan untuk memperluas fungsi menggunakan Shape Detection API dan fungsi lainnya di browser.  Tetapi kami senang telah menemukan kasus penggunaan yang tepat untuk WebAssembly di eBay dan berhasil menerapkan teknologi dalam e-commerce. <br><br>  Terima kasih khusus kepada Surma Das dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lin Clark</a> untuk banyak artikel di WebAssembly.  Mereka benar-benar membantu kami memecahkan kebuntuan beberapa kali. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453712/">https://habr.com/ru/post/id453712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453698/index.html">Informasi kuantum dalam kesadaran kuantum</a></li>
<li><a href="../id453700/index.html">Pelajaran tentang SDL 2: Pelajaran 1 - Halo, SDL 2</a></li>
<li><a href="../id453706/index.html">Bagaimana Saya Lulus dari Ujian Sertifikasi Insinyur Data Google Cloud Professional</a></li>
<li><a href="../id453708/index.html">OS real-time AQUA RTOS untuk MK AVR di lingkungan BASCOM AVR</a></li>
<li><a href="../id453710/index.html">Praktik pengembangan dalam proyek-proyek besar: mitp SberPractice iOS # 1</a></li>
<li><a href="../id453714/index.html">Klien uji TON (Telegram Open Network) dan bahasa Fift baru untuk kontrak pintar</a></li>
<li><a href="../id453716/index.html">Rekan kerja negara untuk keluarga orang IT - adakah orang?</a></li>
<li><a href="../id453720/index.html">Subtleties dari Ekspresi Lambda di C #</a></li>
<li><a href="../id453722/index.html">Tentang penelitian proses non-stasioner</a></li>
<li><a href="../id453728/index.html">Pertempuran Hyperstars</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>