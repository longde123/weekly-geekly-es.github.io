<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏽 🚗 🛳️ Qu'est-ce qu'une table de table virtuelle? 🎷 🥓 🏓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une fois chez Slack, je suis tombé sur un nouvel acronyme pour mon glossaire d'acronymes C ++ : «VTT». Godbolt : 



test.o: In function `MyClass': te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qu'est-ce qu'une table de table virtuelle?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474318/">  Une fois chez Slack, je suis tombé sur un nouvel acronyme pour mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">glossaire d'acronymes C ++</a> : «VTT».  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Godbolt</a> : <br><br><pre><code class="plaintext hljs">test.o: In function `MyClass': test.cc:3: undefined reference to `VTT for MyClass'</code> </pre> <br>  «VTT» dans ce contexte signifie «table de table virtuelle».  Il s'agit d'une structure de données auxiliaire utilisée (dans Itanium C ++ ABI) lors de la création de certaines classes de base héritées elles-mêmes des classes de base virtuelles.  Les VTT suivent les mêmes règles de disposition que les tables virtuelles (vtable) et les informations de type (typeinfo), donc si vous obtenez l'erreur ci-dessus, vous pouvez simplement remplacer mentalement «vtable» par «VTT» et commencer le débogage.  (Très probablement, vous avez laissé la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction clé de la</a> classe non définie).  Pour voir pourquoi le VTT, ou une structure similaire, est nécessaire, commençons par les bases. <br><a name="habracut"></a><br><h3>  Ordre de conception pour l'héritage non virtuel </h3><br>  Lorsque nous avons une hiérarchie d'héritage, les classes de base sont construites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">à partir des plus basiques</a> .  Pour construire Charlie, nous devons d'abord construire ses classes parent MrsBucket et MrBucket, récursivement, pour construire MrBucket, nous devons d'abord construire ses classes parents GrandmaJosephine et GrandpaJoe. <br><br>  Comme ça: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> C {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> B, D {}; <span class="hljs-comment"><span class="hljs-comment">//     // ABCDE</span></span></code> </pre> <br><h3>  Ordre de conception pour les classes de base virtuelles </h3><br>  Mais l'héritage virtuel confond toutes les cartes!  Avec l'héritage virtuel, nous pouvons avoir une hiérarchie en forme de losange dans laquelle deux classes parentales différentes peuvent partager un ancêtre commun. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">G</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> G {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> G {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> M, F {}; <span class="hljs-comment"><span class="hljs-comment">//     // GMFE</span></span></code> </pre> <br>  Dans la dernière section, chaque constructeur était responsable d'appeler le constructeur de sa classe de base.  Mais maintenant, nous avons l'héritage virtuel, et les constructeurs M et F doivent en quelque sorte savoir qu'il n'est pas nécessaire de construire G, car c'est commun.  Si M et F étaient responsables de la construction des objets de base dans ce cas, l'objet de base commun serait construit deux fois, ce qui n'est pas très bon. <br><br>  Pour travailler avec des sous-objets d'héritage virtuel, Itanium C ++ ABI divise chaque constructeur en deux parties: le constructeur d'objet de base et le constructeur d'objet complet.  Le constructeur de l'objet de base est responsable de la construction de tous les sous-objets d'héritage non virtuels (et de leurs sous-objets, et de l'installation de leur vptr sur leur vtable, et de l'exécution du code entre accolades dans le code C ++).  Le constructeur de l'objet complet, qui est appelé chaque fois que vous créez l'objet C ++ complet, est responsable de la construction de tous les sous-objets de l'héritage virtuel de l'objet dérivé, puis fait le reste. <br><br>  Considérez la différence entre notre exemple ABCDE de la section précédente et l'exemple suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> C {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> B, D {}; <span class="hljs-comment"><span class="hljs-comment">//     // ACBDE</span></span></code> </pre> <br>  Le constructeur de l'objet complet E appelle d'abord les constructeurs de l'objet de base des sous-objets virtuels A et C;  alors les constructeurs de l'objet d'héritage non virtuel de base B et D. sont appelés. B et D ne sont plus responsables de la construction de A et C, respectivement. <br><br><h3>  Conception de tables vtables </h3><br>  Supposons que nous ayons une classe avec quelques méthodes virtuelles, par exemple, telles ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Godbolt</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> {</span></span> Cat() { poke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"meow"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> :</span></span> Cat { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> roar = <span class="hljs-string"><span class="hljs-string">"roar"</span></span>; Lion() { poke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ roar += <span class="hljs-string"><span class="hljs-string">'!'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(roar.c_str()); } };</code> </pre> <br>  Lorsque nous construisons Lion, nous commençons par construire le sous-objet Cat de base.  Le constructeur de Cat appelle poke ().  À ce stade, nous n'avons qu'un seul objet Cat - nous n'avons pas encore initialisé les données de membre nécessaires pour créer l'objet Lion.  Si le constructeur Cat appelle Lion :: poke (), il peut essayer de changer le membre non initialisé de std :: string rugissement et nous obtenons UB.  Ainsi, le standard C ++ nous oblige à le faire dans le constructeur Cat, un appel à la méthode virtuelle poke () devrait appeler Cat :: poke (), pas Lion :: poke ()! <br><br>  Il n'y a aucun problème.  Le compilateur fait simplement démarrer Cat :: Cat () (à la fois la version de l'objet de base et la version de l'objet complet) en définissant le vptr de l'objet sur la vtable de l'objet Cat.  Lion :: Lion () appellera Cat :: Cat (), puis réinitialisera vptr sur le pointeur de la table vtable pour l'objet Cat dans Lion, avant d'exécuter le code entre parenthèses.  Pas de problème! <br><br><h3>  Décalages d'héritage virtuels </h3><br>  Laissez le chat hériter virtuellement de l'animal.  Ensuite, la table virtuelle pour Cat stocke non seulement les pointeurs de fonction pour les fonctions de membre virtuel Cat, mais également le décalage du sous-objet virtuel Animal à l'intérieur de Cat.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Godbolt</a> .) <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data = <span class="hljs-string"><span class="hljs-string">"hi"</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Animal { Cat() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(data); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nermal</span></span></span><span class="hljs-class"> :</span></span> Cat {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Garfield</span></span></span><span class="hljs-class"> :</span></span> Cat { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> padding; };</code> </pre> <br>  Le constructeur Cat interroge le membre Animal :: data.  Si cet objet Cat est le sous-objet de base de l'objet Nermal, ses données de membre sont au décalage 8, juste derrière vptr.  Mais si l'objet Cat est le sous-objet sous-jacent de l'objet Garfield, alors les données des membres sont à l'offset 16, derrière vptr et Garfield :: padding.  Pour y faire face, Itanium ABI stocke les décalages des objets de base virtuels dans la table de l'objet Cat.  La table pour Cat-in-Nermal préserve le fait que Animal, le sous-objet Cat sous-jacent, est stocké à l'offset 8;  La table virtuelle pour Cat-in-Garfield conserve le fait que Animal, le sous-objet Cat sous-jacent, est stocké à l'offset 16. <br><br>  Maintenant, combinez cela avec la section précédente.  Le compilateur doit s'assurer que Cat :: Cat () (à la fois la version d'objet de base et la version d'objet complet) démarre en installant vptr sur la vtable pour Cat-in-Nermal ou sur la vtable pour Cat-in-Garfield, selon le type facilité la plus dérivée!  Mais comment ça marche? <br><br>  Le constructeur de l'objet complet pour l'objet le plus dérivé doit pré-calculer la table vtable à laquelle il souhaite que le vptr du sous-objet de base fasse référence pendant la construction de l'objet, puis le constructeur de l'objet complet pour l'objet le plus dérivé doit transmettre ces informations au constructeur de l'objet de base du sous-objet de base comme paramètre caché!  Regardons le code généré pour Cat :: Cat () ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Godbolt</a> ): <br><br><pre> <code class="cpp hljs">_ZN3CatC1Ev: #    Cat movq $_ZTV3Cat+<span class="hljs-number"><span class="hljs-number">24</span></span>, (%rdi) <span class="hljs-meta"><span class="hljs-meta"># this-&gt;vptr = &amp;vtable-for-Cat; retq _ZN3CatC2Ev: #     Cat movq (%rsi), %rax # fetch a value from rsi movq %rax, (%rdi) # this-&gt;vptr = *rsi; retq</span></span></code> </pre> <br>  Le constructeur de l'objet de base accepte non seulement ce paramètre caché dans% rdi, mais aussi le paramètre VTT caché dans% rsi!  Le constructeur de l'objet de base charge l'adresse à partir de (% rsi) et stocke l'adresse dans la table virtuelle de l'objet Cat. <br><br>  Celui qui appelle le constructeur de l'objet Cat de base est responsable de prédire quelle adresse Cat :: Cat () doit être écrite dans vptr et de définir le pointeur dans (% rsi) sur cette adresse. <br><br><h3>  Pourquoi avons-nous besoin d'un autre niveau d'identité? </h3><br>  Considérez le constructeur d'un objet Nermal complet. <br><br><pre> <code class="cpp hljs">_ZN3CatC2Ev: #    <span class="hljs-function"><span class="hljs-function">Cat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movq</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function">, %rax #    rsi movq %rax, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function"> </span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-meta"># this-&gt;vptr = *rsi; retq _ZN6NermalC1Ev: #    Nermal pushq %rbx movq %rdi, %rbx movl $_ZTT6Nermal+8, %esi # %rsi = &amp;VTT-for-Nermal callq _ZN3CatC2Ev #     Cat movq $_ZTV6Nermal+24, (%rbx) # this-&gt;vptr = &amp;vtable-for-Nermal popq %rbx retq _ZTT6Nermal: .quad _ZTV6Nermal+24 # vtable-for-Nermal .quad _ZTC6Nermal0_3Cat+24 # construction-vtable-for-Cat-in-Nermal</span></span></span></span></code> </pre> <br>  Pourquoi _ZTC6Nermal0_3Cat + 24 se trouve-t-il dans la section des données et son adresse est transmise à% rsi, au lieu de simplement passer _ZTC6Nermal0_3Cat + 24 directement? <br><br><pre> <code class="cpp hljs">#   ? _ZN3CatC2Ev: #     Cat movq %rsi, (%rdi) <span class="hljs-meta"><span class="hljs-meta"># this-&gt;vptr = rsi; retq _ZN6NermalC1Ev: #     Nermal pushq %rbx movq %rdi, %rbx movl $_ZTC6Nermal0_3Cat+24, %esi # %rsi = &amp;construction-vtable-for-Cat-in-Nermal callq _ZN3CatC2Ev #     Cat movq $_ZTV6Nermal+24, (%rbx) # this-&gt;vptr = &amp;vtable-for-Nermal popq %rbx retq</span></span></code> </pre> <br>  En effet, nous pouvons avoir plusieurs niveaux d'héritage!  À chaque niveau d'héritage, le constructeur de l'objet de base doit définir vptr puis, éventuellement, passer le contrôle plus loin dans la chaîne au constructeur de base suivant, qui peut définir vptrs à une autre valeur.  Cela implique une liste ou un tableau de pointeurs vers vtable. <br><br>  Voici un exemple concret ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Godbolt</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VB</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> member_of_vb = <span class="hljs-number"><span class="hljs-number">42</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Grandparent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> VB { Grandparent() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> :</span></span> Grandparent { Parent() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gretel</span></span></span><span class="hljs-class"> :</span></span> Parent { Gretel() : VB{<span class="hljs-number"><span class="hljs-number">1000</span></span>} {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hansel</span></span></span><span class="hljs-class"> :</span></span> Parent { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> padding; Hansel() : VB{<span class="hljs-number"><span class="hljs-number">2000</span></span>} {} };</code> </pre> <br>  L'objet constructeur de base Grandparent doit définir son vptr sur Grandparent - autre chose, qui est la classe la plus dérivée.  Le constructeur de l'objet de base Parent doit d'abord appeler Grandparent :: Grandparent () avec le% rsi approprié, puis définir vptr sur Parent - autre chose, qui est la classe la plus dérivée.  Une façon de mettre cela en œuvre pour Gretel: <br><br><pre> <code class="cpp hljs">Gretel::Gretel() [  ]: pushq %rbx movq %rdi, %rbx movl $<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) <span class="hljs-meta"><span class="hljs-meta"># imm = 0x3E8 movl $VTT for Gretel+8, %esi callq Parent::Parent() [  ] movq $vtable for Gretel+24, (%rbx) popq %rbx retq VTT for Gretel: .quad vtable for Gretel+24 .quad construction vtable for Parent-in-Gretel+24 .quad construction vtable for Grandparent-in-Gretel+24</span></span></code> </pre> <br>  Vous pouvez voir dans Godbolt que le constructeur de l'objet de base de la classe Parent appelle d'abord Grandparent :: Grandparent () avec% rsi + 8, puis définit son propre vptr sur (% rsi).  Donc, ici, nous utilisons le fait que Gretel, pour ainsi dire, a soigneusement tracé un chemin de chapelure le long duquel toutes ses classes de base ont suivi pendant la construction. <br><br>  Le même VTT est utilisé dans le destructeur ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Godbolt</a> ).  Pour autant que je sache, la ligne nulle de la table VTT n'est jamais utilisée.  Le constructeur Gretel charge la vtable pour Gretel + 24 dans vptr, mais il sait que cette adresse est statique, elle n'a jamais besoin d'être chargée depuis VTT.  Je pense que la ligne zéro du tableau a été conservée simplement pour des raisons historiques.  (Et bien sûr, le compilateur ne peut pas simplement le jeter, car ce sera une violation d'Itanium ABI et il sera impossible de lier à l'ancien code qui adhère à Itanium-ABI). <br><br>  C'est tout, nous avons regardé une table de tables virtuelles, ou VTT. <br><br><h3>  Plus d'informations </h3><br>  Vous pouvez trouver des informations VTT dans ces endroits: <br><br>  StackOverflow: « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce que le VTT pour une classe?</a>  " <br>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://web.archive.org/web/20190930143149/">Notes VTable sur l'héritage multiple dans le compilateur GCC C ++ v4.0.1</a> » (Morgan Deters, 2005) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le Itanium C ++ ABI</a> , rubrique «Commande VTT» <br><br>  Enfin, je dois répéter que le VTT est une fonctionnalité de Itanium C ++ ABI, et est utilisé sur Linux, OSX, etc.  L'ABI MSVC utilisé sous Windows n'a pas de VTT et utilise un mécanisme complètement différent pour l'héritage virtuel.  Jusqu'à présent, je ne sais presque rien de MSVC ABI, mais peut-être qu'un jour je trouverai tout et j'écrirai un article à ce sujet! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474318/">https://habr.com/ru/post/fr474318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474306/index.html">Rendre les styles de pointage, de mise au point et d'état actif différents</a></li>
<li><a href="../fr474308/index.html">Types pour les API HTTP écrites en Python: expérience Instagram</a></li>
<li><a href="../fr474310/index.html">Y a-t-il des nombres aléatoires dans CSS?</a></li>
<li><a href="../fr474312/index.html">Installation de l'interface graphique sur Windows Server Core</a></li>
<li><a href="../fr474316/index.html">Voiture électrique faite maison - partie 1. Comment tout a commencé et comment j'ai marqué 1000000 vues sur youtube</a></li>
<li><a href="../fr474320/index.html">DDD Community Crisis</a></li>
<li><a href="../fr474322/index.html">ScalaConf 2019 - John Preacher, Holy Graal et Professor Haskell</a></li>
<li><a href="../fr474324/index.html">Pourquoi le soleil tourne-t-il autour de la terre</a></li>
<li><a href="../fr474326/index.html">Comprendre la différence entre CI et CD: «si quelque chose cause de la douleur, faites-le plus souvent»</a></li>
<li><a href="../fr474330/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 320 (28 octobre - 3 novembre)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>