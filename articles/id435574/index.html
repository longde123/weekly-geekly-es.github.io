<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏽 🚊 🐬 Bagaimana cara kerja zig? 🌪️ 🤔 🌜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari penerjemah: Posting ini diterbitkan di blog penulis pada 15 Maret 2018. Seiring berkembangnya bahasa, sintaksisnya mungkin berbeda saat ini. Sega...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara kerja zig?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435574/">  <i>Dari penerjemah: Posting ini diterbitkan di blog penulis pada 15 Maret 2018.</i>  <i>Seiring berkembangnya bahasa, sintaksisnya mungkin berbeda saat ini.</i>  <i>Segala sesuatu yang dijelaskan berhubungan dengan Zig 0.2.0, versi bahasa saat ini adalah Zig 0.3.0.</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saya menghubungi penulis posting, dan dia dengan ramah memberikan tautan ke repositori dengan versi terkini dari sumber proyek pada Zig 0.3.0</a></i> <i><br></i> <br>  Halo  Mari kita menulis penerjemah Brainfuck!  "Kenapa?"  "Anda mungkin bertanya, tetapi Anda tidak akan menemukan jawabannya di sini." <br><br>  Saya akan melakukannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zig</a> . <br><img src="https://habrastorage.org/webt/p2/l1/zs/p2l1zsmnlu7j_yqwm6fczu4ycay.jpeg"><br><h3>  Zig adalah ... </h3><br>  ... bahasa pemrograman baru.  Masih dalam versi beta dan sedang berkembang pesat.  Jika Anda pernah melihat kode Zig sebelumnya, kode dalam posting ini mungkin tampak sedikit berbeda dengan Anda.  Dia benar-benar berbeda!  Zig 0.2.0 baru saja dirilis, bertepatan dengan rilis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LLVM 6</a> beberapa minggu yang lalu, dan mencakup banyak perubahan sintaks dan peningkatan bahasa secara umum.  Sebagian besar, banyak "mantra" telah digantikan oleh kata kunci.  Lihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> untuk penjelasan lebih lanjut tentang semua perubahan! <br><br>  Zig dirancang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">agar dapat dibaca</a> , dan relatif intuitif bagi mereka yang terbiasa dengan bahasa yang dikompilasi dan diketik seperti C, C ++, dan, di beberapa titik, Rust. <br><br>  Kode ini dikompilasi dan diuji dengan Zig 0.2.0, yang tersedia sekarang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melalui berbagai saluran</a> , termasuk homebrew, jika Anda menggunakan OSX: brew install zig. <br><a name="habracut"></a><br><h3>  Mari kita mulai </h3><br>  Untuk mempelajari cara Brainfuck bekerja, lihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Hampir tidak ada yang bisa dipelajari di sana, tetapi bahasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Turing-lengkap</a> , yang berarti Anda dapat menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa pun</a> di sana. <br><br>  Saya memposting kode di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , jika Anda ingin melihat produk akhir atau komitmen awal. <br><br>  Zig adalah bahasa yang dikompilasi.  Ketika Anda mengkompilasi program, biner yang dihasilkan (jika Anda mengkompilasi biner yang dapat dieksekusi, bukan perpustakaan) harus memiliki fungsi utama yang menandai titik masuk. <br><br>  Jadi ... <br><br><pre><code class="plaintext hljs">// main.zig fn main() void { }</code> </pre> <br>  ... dan mulai ... <br><br><pre> <code class="bash hljs">$ zig build-exe main.zig</code> </pre> <br>  ... membagikan ... <br><br><pre> <code class="bash hljs">/zig/std/special/bootstrap.zig:70:33: error: <span class="hljs-string"><span class="hljs-string">'main'</span></span> is private /zigfuck/main.zig:2:1: note: declared here</code> </pre> <br>  utama harus dideklarasikan sebagai publik agar dapat terlihat di luar modul ... <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { }</code> </pre> <br>  Biarkan program brainfuck menggunakan array 30.000 byte sebagai memori, saya akan membuat array seperti itu. <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8; }</code> </pre> <br>  Saya dapat mendeklarasikan konstanta (const) atau variabel (var).  Di sini, saya menyatakan mem sebagai array dari 30.000 byte (u) byte (8 bit) yang tidak ditandatangani. <br><br>  Ini tidak dikompilasi. <br><br><pre> <code class="bash hljs">/main.zig:3:5: error: variables must be initialized</code> </pre> <br>  Program C yang setara akan dikompilasi secara normal: Saya dapat mendeklarasikan variabel tanpa inisialisasi, tetapi Zig memaksa saya untuk membuat keputusan sekarang, pada saat variabel tersebut dideklarasikan.  Saya mungkin tidak peduli apa yang akan ditulis di dalamnya, tetapi saya harus secara eksplisit menunjukkan ini.  Saya akan melakukan ini dengan menginisialisasi variabel dengan nilai yang tidak ditentukan (undefined). <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8 = undefined; }</code> </pre> <br>  Inisialisasi variabel dengan nilai yang tidak ditentukan tidak memberikan jaminan tentang nilai variabel dalam memori.  Ini sama dengan deklarasi variabel yang tidak diinisialisasi dalam C kecuali bahwa Anda perlu secara eksplisit menunjukkan ini. <br><br>  Tapi mungkin saya tidak peduli bagaimana menginisialisasi memori ini.  Mungkin saya ingin memiliki jaminan bahwa nol atau nilai sewenang-wenang ditulis di sana.  Dalam hal ini, saya juga harus secara eksplisit menyatakan ini: <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem = []u8{0} ** 30000; }</code> </pre> <br>  Mungkin terlihat aneh, tetapi ** adalah operator yang digunakan untuk memperluas array.  Saya mendeklarasikan array 0 byte, dan kemudian memperluasnya menjadi 30.000, dan mendapatkan nilai inisialisasi akhir sebesar 30.000 byte nol.  Operasi ini terjadi sekali, <i>pada waktu kompilasi</i> .  comptime adalah salah satu ide hebat Zig, dan saya akan kembali padanya di salah satu posting berikut. <br><br>  Sekarang mari kita menulis sebuah program di brainfuck yang tidak menambah slot memori pertama lima kali! <br><br><pre> <code class="plaintext hljs">pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; }</code> </pre> <br>  Di Zig, string adalah byte array.  Saya seharusnya tidak mendeklarasikan src sebagai byte array, karena kompiler menyiratkan ini.  Ini opsional, tetapi jika Anda mau, itu mungkin: <br><br><pre> <code class="plaintext hljs">const src: [5]u8 = "+++++";</code> </pre> <br>  Ini akan dikompilasi dengan baik.  Namun, ini: <br><br><pre> <code class="plaintext hljs">const src: [6]u8= "+++++";</code> </pre> <br>  tidak akan. <br><br><pre> <code class="bash hljs">main.zig:5:22: error: expected <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'[6]u8'</span></span>, found <span class="hljs-string"><span class="hljs-string">'[5]u8'</span></span></code> </pre> <br>  Satu lagi catatan: karena string hanya array, mereka tidak berakhir dengan nol.  Namun, Anda dapat mendeklarasikan string diakhiri-nol C. Sebagai literal, itu akan terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">c"Hello I am a null terminated string";</code> </pre> <br><h3>  Demi kebaikan bersama ... </h3><br>  Saya ingin melakukan <i>sesuatu</i> dengan setiap karakter dalam sebuah string.  Saya bisa melakukannya!  Di awal main.zig, saya mengimpor beberapa fungsi dari pustaka standar: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">impor</a> , seperti hampir semua yang dimulai dengan tanda @, adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi kompiler bawaan</a> .  Fitur seperti itu selalu tersedia secara global.  Impor di sini berfungsi mirip dengan javascript - Anda dapat mengimpor apa pun dengan menggali namespace dan mengekstraknya dari fungsi atau variabel apa pun yang tersedia untuk umum.  Dalam contoh di atas, saya secara langsung mengimpor fungsi warn dan menetapkannya, secara tiba-tiba, ke konstanta peringatan.  Sekarang dia bisa dipanggil.  Ini adalah pola umum: kami mengimpor langsung dari namespace std dan kemudian memanggil std.debug.warn () atau menetapkannya ke variabel warn.  Ini terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">const std = @import("std"); const warn = std.debug.warn;</code> </pre> <br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; // main.zig pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { warn("{}", c); } }</code> </pre> <br>  Selama debugging dan pengembangan serta pengujian awal, saya hanya ingin mencetak sesuatu di layar.  Zig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rawan kesalahan</a> , dan stdout juga rawan kesalahan.  Saya tidak ingin melakukan ini sekarang, dan saya dapat mencetak langsung ke stderr menggunakan warn, yang kami impor dari perpustakaan standar. <br><br>  warnai mengambil string yang diformat, seperti printf di C!  Kode di atas akan dicetak: <br><br><pre> <code class="plaintext hljs">4343434343</code> </pre> <br>  43 adalah kode karakter ascii +.  Saya juga bisa menulis: <br><br><pre> <code class="plaintext hljs">warn("{c}", c);</code> </pre> <br>  dan dapatkan: <br><br><pre> <code class="plaintext hljs">+++++</code> </pre> <br>  Jadi, kami menginisialisasi ruang memori, dan menulis programnya.  Sekarang kami menyadari bahasa itu sendiri.  Saya akan mulai dengan +, dan mengganti tubuh for for dengan switch: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1 } }</code> </pre> <br>  Saya mendapatkan dua kesalahan: <br><br><pre> <code class="plaintext hljs">/main.zig:10:7: error: switch must handle all possibilities switch(c) { ^ /main.zig:11:25: error: cannot assign to constant '+' =&gt; mem[0] += 1 ^</code> </pre> <br>  Tentu saja, saya tidak bisa menetapkan nilai baru ke variabel, yang merupakan konstanta!  mem perlu dibuat variabel ... <br><br><pre> <code class="plaintext hljs">var mem = []u8{0} ** 30000;</code> </pre> <br>  seperti kesalahan lainnya, konstruksiku harus tahu apa yang harus dilakukan jika karakternya bukan +, bahkan jika tidak ada yang perlu dilakukan.  Dalam kasus saya, inilah yang saya inginkan.  Saya mengisi kasing ini dengan balok kosong: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } }</code> </pre> <br>  Sekarang saya bisa mengkompilasi program.  Panggil peringatan di akhir dan jalankan: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } } warn("{}", mem[0]); }</code> </pre> <br>  Saya mendapatkan nomor 5 dicetak di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stderr</a> , seperti yang saya harapkan. <br><br><h3>  Mari kita lanjutkan ... </h3><br>  Demikian pula, kami mendukung. <br><br><pre> <code class="plaintext hljs">switch(c) { '+' =&gt; mem[0] += 1, '-' =&gt; mem[0] -= 1, else =&gt; {} }</code> </pre> <br>  Untuk menggunakan&gt; dan &lt;, Anda perlu menggunakan variabel tambahan, yang berfungsi sebagai "penunjuk" dalam memori yang saya alokasikan untuk program brainfuck pengguna. <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0;</code> </pre> <br>  Karena 16-bit yang tidak ditandatangani dapat maksimum 65535, itu lebih dari cukup untuk mengindeks 30.000 byte ruang alamat. <br><br><blockquote>  <i>pada kenyataannya, 15 bit akan cukup bagi kita, yang memungkinkan kita untuk mengatasi 32.767 byte.</i>  <i>Zig memungkinkan jenis dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebar yang berbeda</a> , tetapi belum u15.</i> <i><br><br></i>  <i>Anda benar-benar dapat melakukan u15 dengan cara ini:</i> <i><br><br></i> <pre> <code class="plaintext hljs">const u15 = @IntType(false, 15):</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Diusulkan</a> agar semua tipe [iu] \ d + valid sebagai tipe integer. </blockquote><br>  Sekarang alih-alih menggunakan mem [0], saya bisa menggunakan variabel ini. <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1,</code> </pre> <br>  &lt;and&gt; cukup tambahkan dan kurangi pointer ini. <br><br><pre> <code class="plaintext hljs">'&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1,</code> </pre> <br>  Bagus  Kita dapat menulis program nyata sekarang! <br><br><h3>  Periksa 1,2,3 </h3><br>  Zig memiliki mesin uji bawaan.  Di mana saja dalam file apa pun saya dapat menulis blok uji: <br><br><pre> <code class="plaintext hljs">test "Name of Test" { // test code }</code> </pre> <br>  dan jalankan tes dari baris perintah: zig test $ FILENAME.  Sisa blok uji sama dengan kode biasa. <br><br>  Mari kita lihat ini: <br><br><pre> <code class="plaintext hljs">// test.zig test "testing tests" {} zig test test.zig Test 1/1 testing tests...OK</code> </pre> <br>  Tentu saja, tes kosong tidak berguna.  Saya dapat menggunakan menegaskan untuk benar-benar mengkonfirmasi pelaksanaan tes. <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "test true" { assert(true); } test "test false" { assert(false); }</code> </pre> <br><pre> <code class="bash hljs">zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test.zig <span class="hljs-string"><span class="hljs-string">"thing.zig"</span></span> 10L, 127C written :!zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> thing.zig Test 1/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> true...OK Test 2/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> false...assertion failure [37;1m_panic.7 [0m: [2m0x0000000105260f34 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_panic [0m: [2m0x0000000105260d6b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_assert [0m: [2m0x0000000105260619 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_test <span class="hljs-literal"><span class="hljs-literal">false</span></span> [0m: [2m0x0000000105260cfb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main.0 [0m: [2m0x00000001052695ea <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMain [0m: [2m0x0000000105269379 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMainWithArgs [0m: [2m0x00000001052692f9 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main [0m: [2m0x0000000105269184 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x00007fff5c75c115 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x0000000000000001 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m</code> </pre> <br>  Tes jatuh.  Gunakan perintah berikut untuk mereproduksi kesalahan: <br><br><pre> <code class="plaintext hljs">./zig-cache/test</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jejak tumpukan pada poppy masih dalam pengembangan.</a> <br><br>  Untuk mengujinya dengan efisien, saya perlu memecahnya menjadi beberapa bagian.  Mari kita mulai dengan ini: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: [30000]u8) void { var memptr: u16 = 0; for (src) |c| { switch(c) { '+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, else =&gt; {} } } } pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; bf(src, mem); }</code> </pre> <br>  Seharusnya itu berfungsi, bukan? <br><br>  Tapi ... <br><br><pre> <code class="plaintext hljs">/main.zig:1:29: error: type '[30000]u8' is not copyable; cannot pass by value</code> </pre> <br><blockquote>  ini dijelaskan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/zig-lang/zig/issues/733</a> . </blockquote><br>  Zig sangat tegas soal ini.  Jenis yang kompleks, dan semua objek yang dapat diubah ukurannya, tidak bisa dilewati oleh nilai.  Ini membuat alokasi tumpukan dapat diprediksi dan logis, dan menghindari penyalinan yang tidak perlu.  Jika Anda ingin menggunakan semantik transfer berdasarkan nilai dalam program Anda, Anda dapat menerapkannya sendiri menggunakan strategi alokasi Anda, tetapi bahasa itu sendiri tidak mendukung hal ini dalam keadaan biasa. <br><br>  Cara alami untuk mengatasi batasan ini adalah dengan melewatkan pointer daripada nilai (pass by reference).  Zig menggunakan strategi yang berbeda, irisan.  Sepotong adalah pointer dengan panjang yang melekat padanya dan dengan cek untuk jatuh ke perbatasan.  Sintaks dalam tanda tangan fungsi terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: []u8) void { ... }</code> </pre> <br>  dan ketika memanggil fungsi itu terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..mem.len]);</code> </pre> <br>  Perhatikan bahwa saya mendefinisikan batas atas hanya dengan merujuk pada panjang array.  Ada bentuk notasi singkat untuk kasus-kasus seperti: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..]);</code> </pre> <br>  Sekarang saya dapat mulai menulis tes yang menguji fungsi bf () secara langsung.  Saya akan menambahkan fungsi tes ke akhir file untuk saat ini ... <br><br><pre> <code class="plaintext hljs">test "+" { var mem = []u8{0}; const src = "+++"; bf(src, mem[0..]); assert(mem[0] == 3); }</code> </pre> <br>  Saya mengambil array mem dari satu byte dan kemudian memeriksa apa yang harus terjadi (byte bertambah tiga kali).  Itu berhasil! <br><br><pre> <code class="plaintext hljs">Test 1/1 +...OK</code> </pre> <br>  "-" dicentang dengan cara yang sama: <br><br><pre> <code class="plaintext hljs">test "-" { var mem = []u8{0}; const src = "---"; bf(src, mem[0..]); assert(mem[0] == 253); }</code> </pre> <br>  Tidak bekerja!  Ketika saya mencoba mengurangi 1 dari 0, saya mendapatkan ... <br><br><pre> <code class="bash hljs">Test 2/2 -...<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> overflow</code> </pre> <br>  mem adalah array byte yang tidak ditandatangani, dan mengurangi 1 dari 0 menyebabkan overflow.  Sekali lagi, Zig membuat saya menyatakan apa yang saya inginkan secara eksplisit.  Dalam hal ini, saya tidak perlu khawatir meluap, pada kenyataannya, saya ingin itu terjadi, karena kita berhadapan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aritmatika modular</a> , sesuai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi brainfuck</a> .  Ini berarti bahwa pengurangan sel dengan angka 0 akan memberi saya 255, dan kenaikan 255 akan memberi saya 0. <br><br>  Zig memiliki beberapa operasi aritmatika tambahan yang menawarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">semantik “pembungkus” yang dijamin</a> . <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] +%= 1, '-' =&gt; mem[memptr] -%= 1,</code> </pre> <br>  Ini menyelesaikan seluruh masalah overflow dan melakukan apa yang saya harapkan. <br><br>  Untuk menguji &lt;and&gt;, saya menavigasi melalui array kecil dan memeriksa nilai sel yang bertambah: <br><br><pre> <code class="plaintext hljs">test "&gt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++"; bf(src, mem[0..]); assert(mem[3] == 3); }</code> </pre> <br>  dan ... <br><br><pre> <code class="plaintext hljs">test "&lt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, mem[0..]); assert(mem[3] == 3); assert(mem[2] == 2); assert(mem[1] == 1); }</code> </pre> <br>  Dalam kasus terakhir, saya bisa langsung membandingkan hasilnya dengan array statis menggunakan ... <br><br><pre> <code class="plaintext hljs">const mem = std.mem;</code> </pre> <br>  Ingat bahwa saya sudah mengimpor std.  Dalam contoh di bawah ini, saya menggunakan mem.eql di namespace ini: <br><br><pre> <code class="plaintext hljs">test "&lt;" { var storage = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, storage[0..]); assert(mem.eql(u8, storage, []u8{ 0, 1, 2, 3, 0 })); }</code> </pre> <br>  ... dan ingat, string literal, ini hanya array u8 dalam zig, dan saya dapat menempatkan liter heksadesimal di dalamnya, mis.  Kode berikut akan bekerja dengan cara yang sama! <br><br><pre> <code class="plaintext hljs">assert(mem.eql(u8, storage, "\x00\x01\x02\x03\x00"));</code> </pre> <br>  Tambahkan "."!  Ini hanya mencetak sebagai karakter nilai byte dalam sel yang ditunjuk oleh pointer.  Saya menggunakan memperingatkan sekarang, tetapi nanti saya akan menggantinya dengan stdout.  Ini mudah dilakukan secara konseptual, tetapi agak membingungkan dalam implementasinya.  Saya akan melakukannya nanti! <br><br><pre> <code class="plaintext hljs">'.' =&gt; warn("{c}", storage[memptr]),</code> </pre> <br>  Siklus <br>  [dan] - keajaiban dimulai di sini .... <br><br>  [- jika nilai sel saat ini nol, lewati langkah-langkah ke braket penutup tanpa mengeksekusi kode. <br>  ] - jika nilai sel saat ini tidak nol, kembali ke braket pembuka dan jalankan kode lagi. <br><br>  Kali ini saya akan mulai dengan tes, saya akan mengujinya bersama (jelas, tidak masuk akal untuk mengujinya secara terpisah).  Kasing uji pertama - sel penyimpanan [2] harus kosong, meskipun loop harus menambahnya jika dimulai: <br><br><pre> <code class="plaintext hljs">test "[] skips execution and exits" { var storage = []u8{0} ** 3; const src = "+++++&gt;[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 5); assert(storage[1] == 0); assert(storage[2] == 0); }</code> </pre> <br>  dan saya akan membuat blank untuk statement switch: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { }, ']' =&gt; if (storage[memptr] == 0) { },</code> </pre> <br>  Apa yang harus dilakukan sekarang?  Anda dapat menggunakan pendekatan naif.  Saya hanya menambah pointer src sampai saya menemukannya].  Tapi saya tidak bisa menggunakan for for loop in zig untuk ini, itu dibuat hanya untuk iterasi melalui koleksi, tanpa kehilangan elemen mereka.  Konstruk yang sesuai di sini adalah sementara: <br><br>  adalah: <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; for (src) |c| { switch(c) { ... } }</code> </pre> <br>  menjadi ... <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { ... } srcptr += 1; }</code> </pre> <br>  Sekarang saya dapat menetapkan kembali pointer srcptr di tengah blok, saya akan melakukan ini: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { while (src[srcptr] != ']') srcptr += 1; },</code> </pre> <br>  Ini memenuhi tes "[] melewatkan eksekusi kode dan keluar" <br>  Ini memuaskan tes “[] melompati eksekusi dan keluar”, meskipun tidak sepenuhnya dapat diandalkan, seperti yang akan kita lihat. <br><br>  Bagaimana dengan menutup kurung?  Saya percaya ini dapat ditulis hanya dengan analogi: <br><br><pre> <code class="plaintext hljs">test "[] executes and exits" { var storage = []u8{0} ** 2; const src = "+++++[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 25); } ']' =&gt; if (storage[memptr] != 0) { while (src[srcptr] != '[') srcptr -= 1; },</code> </pre> <br>  Anda dapat melihat apa yang terjadi ... Solusi naif dengan dua tanda kurung memiliki cacat fatal dan benar-benar terputus pada loop bersarang.  Pertimbangkan yang berikut ini: <br><br><pre> <code class="plaintext hljs">++&gt;[&gt;++[-]++&lt;-]</code> </pre> <br>  Hasilnya harus {2, 0}, tetapi braket terbuka pertama dengan bodohnya bergerak ke braket penutup pertama, dan semuanya menjadi berantakan.  Anda harus melompat ke braket penutup berikutnya di tingkat yang sama dari sarang.  Sangat mudah untuk menambahkan penghitung kedalaman dan melacaknya saat Anda bergerak maju sepanjang garis.  Kami melakukannya di kedua arah: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { var depth:u16 = 1; srcptr += 1; while (depth &gt; 0) { srcptr += 1; switch(src[srcptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } }, ']' =&gt; if (storage[memptr] != 0) { var depth:u16 = 1; srcptr -= 1; while (depth &gt; 0) { srcptr -= 1; switch(src[srcptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } },</code> </pre> <br>  dan tes terkait: perhatikan bahwa src di kedua tes termasuk loop dalam. <br><br><pre> <code class="plaintext hljs">test "[] skips execution with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++&gt;[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 2); assert(storage[1] == 0); } test "[] executes with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 2); }</code> </pre> <br><blockquote>  Secara terpisah, perhatikan [-] - idiom dari brainfuck, yang berarti "nol sel ini."  Anda dapat melihat bahwa tidak masalah apa nilai sel di awal, itu akan dikurangi hingga mencapai 0, dan kemudian eksekusi akan berlanjut. </blockquote><br><h3>  Jalan sial </h3><br>  Saya tidak mengandalkan kemungkinan bahwa program pada bf akan rusak.  Apa yang terjadi jika saya mengirimkan program input yang salah ke juru bahasa saya?  Misalnya, cukup [tanpa braket penutup, atau &lt;, yang segera melampaui array memori?  (Saya dapat membungkus penunjuk memori, tetapi lebih baik untuk menganggap ini sebagai kesalahan). <br><br>  Saya akan melihat sedikit ke depan dan menjelaskan semua perbedaan dalam kode.  Saya akan meletakkan fungsi juru bahasa ke dalam file terpisah dan juga menempatkan fungsi seekBack dan seekForward ke dalam fungsi kecil saya sendiri. <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; const sub = @import("std").math.sub; fn seekBack(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr = sub(u16, ptr, 1) catch return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } return ptr; } fn seekForward(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr += 1; if (ptr &gt;= src.len) return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } return ptr; } pub fn bf(src: []const u8, storage: []u8) !void { var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { '+' =&gt; storage[memptr] +%= 1, '-' =&gt; storage[memptr] -%= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, '[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr), '.' =&gt; warn("{c}", storage[memptr]), else =&gt; {} } srcptr += 1; } }</code> </pre> <br>  Ini membuat peralihan jauh lebih mudah dibaca, menurut saya, seekForward dan seekBack bekerja dan terlihat sangat mirip, dan saya tergoda untuk mengubah mereka menjadi sesuatu yang lebih pintar dan lebih kompak, tetapi pada akhirnya mereka melakukan hal yang berbeda dan menangani kesalahan. juga dengan cara yang berbeda.  Lebih mudah untuk menyalin dan menyesuaikan, sehingga akan lebih jelas.  Saya juga akan menyesuaikan seekForward nanti, di beberapa titik, mungkin di posting selanjutnya. <br><br>  Saya menambahkan beberapa hal penting!  Perhatikan bahwa ketiga fungsi sekarang mengembalikan tipe! .. Ini adalah sintaks baru untuk tipe% T (kesalahan gabungan).  Ini berarti bahwa fungsi tersebut dapat mengembalikan beberapa jenis tertentu atau kesalahan.  Ketika saya mencoba memanggil fungsi seperti itu, saya harus menggunakan coba sebelum memanggil fungsi, yang melempar kesalahan ke tumpukan panggilan jika kesalahan terjadi, atau menggunakan catch: <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch {}</code> </pre> <br>  Di mana saya menangani kesalahan di blok tangkap.  Seperti yang tertulis, catch dapat menelan kesalahan.  Ini adalah praktik yang buruk, tetapi di sini Zig membuat kami melakukannya secara eksplisit.  Jika saya menemukan kesalahan di blok kosong, saya menyatakan bahwa saya tidak berpikir bahwa kesalahan dapat terjadi, atau saya tidak perlu menanganinya.  Dalam praktiknya, ini bisa seperti TODO, dan sebenarnya sangat mudah membuatnya juga eksplisit! <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch { @panic("TODO") }</code> </pre> <br>  Ingatlah bahwa kasus seperti itu tidak akan pernah terjadi dalam kode produksi.  Saya memberi tahu kompilator bahwa saya tahu apa yang saya lakukan.  Jika kesalahan dapat terjadi, saya harus menambahkan penanganan kesalahan. <br><br>  Jadi kesalahan apa yang harus saya kembalikan dari seekBack atau seekForward? <br><br>  Di seekBack: <br><br><pre> <code class="plaintext hljs">ptr = sub(u16, ptr, 1) catch return error.OutOfBounds;</code> </pre> <br>  Saya mengganti pointer decrement untuk menggunakan fungsi sub std lib, yang melempar kesalahan overflow jika terjadi overflow.  Saya ingin menangkap kesalahan ini dan mengembalikan kesalahan OutOfBounds, yang saya buat di sini hanya dengan menggunakannya. <br><br><blockquote>  <i>Kesalahan Zig pada dasarnya adalah larik kode kesalahan yang dihasilkan oleh kompiler saat Anda menggunakan kesalahan.</i>  <i>Mereka dijamin unik dan dapat digunakan sebagai nilai dalam blok switch.</i> </blockquote><br>  Saya ingin menggunakan OutOfBounds di sini karena, secara semantik, jika penunjuk memori menjadi kurang dari nol, saya meminta runtime untuk melampaui ruang memori yang saya alokasikan. <br><br>  sama dalam fungsi seekForward: <br><br><pre> <code class="plaintext hljs">if (ptr &gt;= src.len) return error.OutOfBounds;</code> </pre> <br>  Dalam hal ini, jika pointer lebih besar dari src.len, saya menangkap kesalahan di sini dan mengembalikan kesalahan yang sama. <br><br>  saat menelepon: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr),</code> </pre> <br>  Saya mencoba memanggil fungsi-fungsi ini.  Jika mereka dipanggil dengan sukses, mereka dieksekusi dengan benar, dan coba kembalikan srcptr.  Jika tidak berhasil, coba akhiri fungsi dan kembalikan kesalahan ke tempat panggilan ke seluruh fungsi bf. <br><br>  Panggilannya mungkin dari utama! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; // yes, hello const hello_world = "++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;."; pub fn main() void { storage = []u8{0} ** 30000; bf(hello_world, storage[0..]) catch {}; }</code> </pre> <br>  Saya menelan kesalahan ini di sini, dan itu tidak boleh dilakukan, tetapi kami akan mencatat poin penting tentang betapa mudahnya zig dapat melewatkan kesalahan pada tumpukan panggilan.  Ini bukan tanggung jawab fungsi panggilan untuk memeriksa setiap kasus kesalahan, tetapi kompiler memaksa panggilan setiap fungsi yang dapat gagal dengan percobaan.  Ini harus selalu dilakukan, bahkan jika kesalahan diabaikan! <br><br><blockquote>  <i>Sintaks coba / tangkapan baru menghilangkan banyak mantra seperti %% dan% yang sangat tidak disukai orang.</i> </blockquote><br>  Sekarang saya telah mengimplementasikan 7 dari 8 karakter brainfuck, dan ini cukup untuk menjalankan program yang "bermakna". <br><br><h3>  Program yang bermakna </h3><br>  Inilah programnya: <br><br><pre> <code class="plaintext hljs">//   ,   const fib = "++++++++++++++++++++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++++++&gt;++++++++++++++++&gt;&gt;+&lt;&lt;[&gt;&gt;&gt;&gt;++++++++++&lt;&lt;[-&gt;+&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;&lt;]&gt;[&lt;+&gt;-]&gt;[-]&gt;&gt;&gt;++++++++++&lt;[-&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;]&gt;[-]&gt;&gt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;&lt;&lt;++++++++++++++++++++++++++++++++++++++++++++++++.[-]&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&gt;.&gt;&gt;[&gt;&gt;+&lt;&lt;-]&gt;[&gt;+&lt;&lt;+&gt;-]&gt;[&lt;+&gt;-]&lt;&lt;&lt;-]&lt;&lt;++...";</code> </pre> <br>  Ayo lari ... <br><br><pre> <code class="plaintext hljs">pub fn main() void { storage = []u8{0} ** 30000; bf(fib, storage[0..]) catch {}; }</code> </pre> <br>  voila! <br><br><pre> <code class="plaintext hljs">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 121, 98, 219,</code> </pre> <br><blockquote>  <i>Satu ingatan kembali kepada saya setiap kali saya memikirkan seri Fibonacci ... Saya mengetahuinya dari program PBS (Public Broadcasting Service, layanan penyiaran televisi non-komersial Amerika) di tahun 80-an, dan saya selalu ingat itu.</i>  <i>Saya pikir itu akan dilupakan, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Youtube adalah hal yang hebat</a> .</i> </blockquote><br><h3>  Bagaimana saya bisa meningkatkan ini? </h3><br>  Saya sudah mengisyaratkan beberapa TODO.  Seharusnya saya tidak menggunakan stderr untuk output.  Saya ingin menggunakan stdout. <br><br>  Setiap kali saya membuka juru bahasa, saya membuka aliran di stdout dan mencetak ke dalamnya: <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br>  Apa yang sedang terjadi di sini?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya memanggil io.getStdOut (), yang dapat menghasilkan kesalahan (dan sekali lagi, saya secara eksplisit menelan kemungkinan kesalahan dengan catch unreachable - jika fungsi ini mengembalikan kesalahan, program akan macet!). Saya menginisialisasi aliran, mengambil pointer ke sana, dan menginisialisasi sebagai aliran keluaran yang saya dapat menulis dengan memanggil print. print menerima string yang diformat, seperti halnya peringatan, maka penggantian langsung. cetak juga dapat menghasilkan kesalahan, dan saya menelan kesalahan ini juga. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam program yang ditulis dengan benar, saya harus memperhitungkan potensi kesalahan membuka stdout, serta kemungkinan kesalahan saat mencoba menulis ke stdout. Zig membuatnya sangat mudah untuk mengabaikan kesalahan-kesalahan ini selama Anda tahu bahwa Anda mengabaikannya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang terjadi jika saya memutuskan bahwa saya ingin mengubah prototipe saya menjadi rilis? </font><font style="vertical-align: inherit;">Akankah saya duduk dengan secangkir kopi dan melakukan pekerjaan yang tidak tahu berterima kasih dalam menangani kesalahan, mengandalkan pengalaman dan pengetahuan selama puluhan tahun untuk membuat daftar setiap kasus kesalahan yang mungkin terjadi, dan bagaimana saya bisa mengatasinya? </font><font style="vertical-align: inherit;">Tetapi bagaimana jika saya tidak memiliki pengalaman dan pengetahuan selama puluhan tahun? </font><font style="vertical-align: inherit;">Tidak apa-apa, Zig akan melakukannya! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya ingin menunjukkan hal yang kuat, output kesalahan!</font></font><br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch unreachable; }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tahu bahwa bf dapat menghasilkan kesalahan karena ia kembali! Batal. </font><font style="vertical-align: inherit;">Saya menelan kesalahan ini di sisi panggilan, di fungsi utama. </font><font style="vertical-align: inherit;">Ketika saya siap menerima nasib saya dan melakukan hal yang benar, saya dapat menangkap kemungkinan kesalahan seperti ini:</font></font><br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kompiler sekarang adalah temanku! </font></font><br><br><pre> <code class="bash hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> switch shell returned 1</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesalahan ini seharusnya sudah tidak asing lagi bagi Anda, karena itu muncul dari fungsi bf dan tambahan! </font><font style="vertical-align: inherit;">Tapi mari kita bayangkan bahwa saya melihat kesalahan yang dihasilkan oleh stdout yang saya telan dalam bf. </font><font style="vertical-align: inherit;">Alih-alih menelan mereka, saya harus mendorong mereka ke atas menggunakan percobaan. </font><font style="vertical-align: inherit;">Ingatlah bahwa menggunakan panggilan ke fungsi yang menghasilkan kesalahan tanpa tangkapan, kami menggunakan coba, yang mengakhiri fungsi ketika terjadi kesalahan, menyediakan fungsi panggilan dengan penanganan potensi kesalahan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, alih-alih:</font></font><br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami lakukan: </font></font><br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(try io.getStdOut())).stream); ... '.' =&gt; try stdout.print("{c}", storage[memptr]), ...</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami mengkompilasi: </font></font><br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan dapatkan daftar semua kemungkinan kesalahan yang bisa saya dapatkan dengan memanggil fungsi! </font></font><br><br><pre> <code class="plaintext hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.SystemResources not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OperationAborted not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.IoPending not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.BrokenPipe not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.Unexpected not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.WouldBlock not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileClosed not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DestinationAddressRequired not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DiskQuota not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileTooBig not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.InputOutput not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoSpaceLeft not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.AccessDenied not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoStdHandles not handled in switch shell returned 1</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zig memberi saya kesempatan untuk menangani kesalahan ini dengan hati-hati jika saya mau atau bisa melakukannya! </font><font style="vertical-align: inherit;">Saya membuat switch berdasarkan nilai kesalahan, menangani kasus jika saya mau, dan melewatkan jika saya ingin melewatkannya.</font></font><br><br><pre> <code class="plaintext hljs">pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { error.OutOfBounds =&gt; @panic("Out Of Bounds!"), else =&gt; @panic("IO error") }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini masih belum benar penanganan kesalahan, tetapi saya hanya ingin menunjukkan seberapa pintar Zig dengan melaporkan semua jenis kasus kesalahan ke fungsi panggilan! </font><font style="vertical-align: inherit;">Dan ketika kesalahan terjadi, Anda mendapatkan </font><font style="vertical-align: inherit;">jejak </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kesalahan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alih-alih jejak tumpukan! </font><font style="vertical-align: inherit;">Hal yang keren!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada banyak peningkatan berbeda yang dapat Anda lakukan dengan penerjemah! Anda harus benar-benar menangani semua kesalahan dengan benar, jelas, dan Anda perlu mengimplementasikan operator ",", yang dalam brainfuck bertindak sebagai fungsi getc, memungkinkan Anda memasukkan data ke dalam program saat dijalankan. Anda juga harus memungkinkan untuk membaca file sumber ke buffer dan menafsirkannya, daripada menggunakan kode sumber bf hardcoded. Ada juga beberapa perbaikan yang tidak sepenuhnya diperlukan, tetapi dapat menggambarkan beberapa fitur Zig. Alih-alih membuang semuanya di akhir posting, saya akan membaginya menjadi beberapa bagian dan mempublikasikannya di posting mendatang, yang akan lebih kecil dan lebih mudah dicerna.</font></font><br><br><h3>  Kesimpulan </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya harap proyek miniatur yang setengah jadi ini memberi Anda wawasan tentang seperti apa kode Zig dan apa yang bisa digunakan untuk itu. Zig bukan pisau Swiss, itu bukan alat yang sempurna untuk semuanya, itu berfokus pada hal-hal tertentu, menjadi bahasa sistem pragmatis yang dapat digunakan bersama-sama atau bukan C dan C ++. Ini membuat saya dengan hati-hati mendekati penggunaan memori, manajemen memori, dan penanganan kesalahan. Dalam lingkungan dengan sumber daya terbatas, ini adalah fitur yang berguna, bukan bug. Zig bersifat deterministik, tidak memiliki ambiguitas, dan mencoba memfasilitasi penulisan kode yang andal dalam lingkungan yang secara tradisional sulit dilakukan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menjelaskan hanya sebagian kecil dari sintaks dan fitur Zig, ada banyak perubahan menarik yang datang ke bahasa dalam versi 0.2.0 dan lebih tinggi! Semua kode yang saya tulis dikompilasi dalam mode debug, yang optimal untuk pemeriksaan keamanan dan mengurangi waktu kompilasi untuk membuat iterasi lebih cepat! Ada mode --release-fast dan --release-safe, dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan ada lebih banyak</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di masa depan </font><font style="vertical-align: inherit;">. Anda dapat membaca lebih lanjut tentang perbedaan mereka dan penjelasan tentang mode ini di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya selalu kagum dengan kecepatan dan arah pengembangan Zig. Banyak yang masih bergerak, dan akan tetap demikian hingga rilis versi 1.0.0, dan jika Anda memutuskan untuk mencoba Zig, ingat saja, ada banyak ide bagus, dan saya berharap dapat mengimplementasikannya!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cobalah dan bergabunglah dengan #zig di freenode kapan saja jika Anda memiliki pertanyaan. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435574/">https://habr.com/ru/post/id435574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435560/index.html">Komputer Quantum Komersial Pertama - IBM</a></li>
<li><a href="../id435562/index.html">Jalan seorang perokok: bagaimana memasuki profesi seorang programmer, jika Anda seorang humanis</a></li>
<li><a href="../id435564/index.html">Menggunakan GtkApplication. Fitur rendering Librsvg</a></li>
<li><a href="../id435568/index.html">Router OpenSource VyOS</a></li>
<li><a href="../id435572/index.html">Anycubic i3 Mega: pembuatan ulang kualitas Prusa i3</a></li>
<li><a href="../id435576/index.html">1C, tidak sakit</a></li>
<li><a href="../id435578/index.html">Spacewalk untuk Natal</a></li>
<li><a href="../id435580/index.html">Layanan Java, Spring, Kurento dan Media</a></li>
<li><a href="../id435582/index.html">Bagaimana cara menambahkan indeks pada sistem yang dimuat 24/7 tanpa downtime?</a></li>
<li><a href="../id435584/index.html">Slush 2018. Hari Pertama, Hari Kedua</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>