<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔏 🍊 🧕🏽 Java Script！= JavaScript。 一堂课有五个Java。 我们编写脚本以便我们永远记住 😠 🍢 👩🏼‍🤝‍👨🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JUG.ru集团可能会在本周发布公告。 直到我说什么。 参与秘密项目可以激发创造力，因此这是另一个有关Java的夜间视频。 

 令人难以置信的消息：现在已经不是一个半小时，而是大约20分钟，甚至还有一些值得关注的地方。 它由一个截屏视频组成，略少于全部。 那些无法忍受此视频垃圾并喜欢使用文本解密的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java Script！= JavaScript。 一堂课有五个Java。 我们编写脚本以便我们永远记住</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/429670/"><iframe width="560" height="315" src="https://www.youtube.com/embed/7SCwk02RPA0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  JUG.ru集团可能会在本周发布公告。 直到我说什么。 参与秘密项目可以激发创造力，因此这是另一个有关Java的夜间视频。 <br><br> 令人难以置信的消息：现在已经不是一个半小时，而是大约20分钟，甚至还有一些值得关注的地方。 它由一个截屏视频组成，略少于全部。 那些无法忍受此视频垃圾并喜欢使用文本解密的人，在剪切后不得不剪切很多文本。  Welkam，也许Java与您同在。 <br><a name="habracut"></a><br> 即将发布12种Java，许多人仍然坐在Semerochka上，他们相信在升级的情况下，他们不会看到任何特别新颖或有趣的东西。 在本期超短篇文章中，我们将学习如何在脚本化Java的帮助下将同事的生活变成地狱，并且在几个地方，我将介绍一些新工具。 好吧，蒙昧主义者当然不会从进步中幸免。 <br><br> 告诉我，您为什么要更新您的想法？ 新功能不断出现，一些新的快捷方式，使开发人员的工作效率提高了十倍。 但是你不知道他们。 你真的在读这个新闻吗？ 如果您是普通用户，则可能不是。 原则上，您在大多数情况下都不会对您造成伤害。 您之所以更新想法，仅仅是因为……可以。 因为皮肤很漂亮，所以是深色主题，是MacBook上的触摸栏。 但是，这种解释在当局面前并没有作为“为什么要买这个主意”的答案。 <br><br> 取而代之的是，可以说是10月29日，即最近，JetBrains在Beta版的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Idea中</a>固定了对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始行的</a>支持。 这个想法是在beta中，行在预览中，但这对任何人都不再重要。 如果您如此固执，以至于只放了12个Java，那么您将遇到更严重的问题。 我自己知道。 <br><br> 让我们看看它在实际中的外观。 为此，请尝试解决某种示范问题。 经常有脚本编写问题。 例如，在计算机游戏中，这些是任务，在詹金斯中，这些是构建脚本，依此类推。 通常，为此使用Python或Groove，让我们开始使用裸Java！ 为什么，为什么？ 因为我们可以做到三行，甚至没有黑客。 听起来是个好主意:-) <br><br><h1> 在哪里看 </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一切都在github上</a> 。 <br><br><h1> 适用范围 </h1><br> 假设我们有一个这样的文件： <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> io.javawatch; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloHabrPrototype</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello Habr!"</span></span>; } };</code> </pre> <br> 我们希望它不是在编译整个应用程序时执行，而是在启动后作为字符串执行。 就像脚本一样。 <br><br><h1> 手动地 </h1><br> 首先，您需要将所有内容都放入字符串中。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String SOURCE = <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" package io.javawatch;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" public class HelloHabr {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" public String get() {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" return \"Hello Habr!\";\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" }\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" };"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CNAME = <span class="hljs-string"><span class="hljs-string">"io.javawatch.HelloHabr"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String CODE_CACHE_DIR = <span class="hljs-string"><span class="hljs-string">"C:/temp/codeCache"</span></span>;</code> </pre><br> 所有这些“ \ n”加号和缩进看起来非常惨。 <br><br> 以前，我们所能做的就是将代码放在文件中并读取。 这可能是一个很好的解决方案，但并不总是适用。 例如，您是会议的发言人，并演示幻灯片中的代码。 即使是上面的构造，也比仅是未经证实的参考要好得多，因为您的代码在某处可以执行某些操作。 切换幻灯片会浪费时间和观众的注意力。 等等。 简而言之，当您需要完全内联的代码时，就可以提出。 <br><br> 现在我们有机会使用原始字符串摆脱垃圾。 我们将光标放在代码上，然后按Alt + Enter（或在Idea中的OS Quck Fix上运行的任何命令）。 选择“转换为原始字符串文字”并获得以下nyashka： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String SOURCE = ` <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> io.javawatch; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloHabr</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello Habr!"</span></span>; } };`; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CNAME = <span class="hljs-string"><span class="hljs-string">"io.javawatch.HelloHabr"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String CODE_CACHE_DIR = <span class="hljs-string"><span class="hljs-string">"C:/temp/codeCache"</span></span>;</code> </pre><br> 我认为，就此功能而言，已经值得运行JDK 12。 <br><br> 顺便说一句，为了使该功能正常运行，您需要做几件事： <br><br><ul><li> 下载JDK 12并注册项目设置 </li><li> 在全局javac设置中，设置<code>--release</code>标志，字节码版本12，其他标志<code>--enable-preview</code> <code>-Xlint:preview</code> </li><li> 现在，在任何运行/调试配置中，您需要添加VM标志<code>--enable-preview</code> </li></ul><br> 如果您不明白它的完成方式，请从帖子标题中查看我的截屏视频，那里的一切都非常清楚。 <br><br> 现在，开始，您需要执行三个简单的步骤：将字符串转换为源的便捷内部表示形式，对其进行编译并运行： <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* 1 */</span></span> RuntimeSource file = RuntimeSource.create(); <span class="hljs-comment"><span class="hljs-comment">//SimpleJavaFileObject /* 2 */ compile(Collections.singletonList(file)); /* 3 */ String result = run(); /* 4 */ /* ??? */ /* 5 */ /* PROFIT! */ System.out.println(result); }</span></span></code> </pre><br> 有一个用于“便捷表示”的<code>SimpleJavaFileObject</code>类，但是它具有一个有趣的功能。 它是非常抽象的。 也就是说，其已编译源应返回的键方法始终引发执行，以希望我们将其子类化： <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * This implementation always throws {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@linkplain</span></span></span><span class="hljs-comment"> * UnsupportedOperationException}. Subclasses can change this * behavior as long as the contract of {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> FileObject} is * obeyed. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CharSequence </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCharContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ignoreEncodingErrors)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnsupportedOperationException(); }</code> </pre><br> 因此，您必须写一些继承人。 请注意，原始的<code>SimpleJavaFileObject</code>构造函数需要已编译类的URI，但是我们从哪里得到呢？ 因此，我建议以最明显的方式粘贴它，例如<code>buildURI</code>函数中的<code>buildURI</code> ： <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuntimeSource</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleJavaFileObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String contents = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CharSequence </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCharContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ignoreEncodingErrors)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contents; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> RuntimeSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeSource(CNAME, SOURCE); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RuntimeSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String className, String contents)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(buildURI(className), Kind.SOURCE); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.contents = contents; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> URI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildURI</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String className)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// io.javawatch.HelloHabr -&gt; // string:///io/javawatch/HelloHabr.java URI uri = URI.create("string:///" + className.replace('.', '/') + Kind.SOURCE.extension); System.out.println(uri); return uri; }</span></span></code> </pre><br> 现在让我们继续编译： <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;RuntimeSource&gt; files)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ File ccDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(CODE_CACHE_DIR); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ccDir.exists()) { FileUtils.deleteDirectory(ccDir); FileUtils.forceMkdir(ccDir); } JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); Logger c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Logger(); StandardJavaFileManager fileManager = compiler.getStandardFileManager(c, Locale.ENGLISH, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); Iterable options = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"-d"</span></span>, CODE_CACHE_DIR, <span class="hljs-string"><span class="hljs-string">"--release=12"</span></span>, <span class="hljs-string"><span class="hljs-string">"--enable-preview"</span></span>, <span class="hljs-string"><span class="hljs-string">"-Xlint:preview"</span></span>); JavaCompiler.CompilationTask task = compiler.getTask(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, fileManager, c, options, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, files); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task.call()) { System.out.println(<span class="hljs-string"><span class="hljs-string">"compilation ok"</span></span>); } }</code> </pre><br> 请注意：我们传递了四个组装标志，其中三个标志负责在Idea的javac设置中指定与使用鼠标所做的完全相同的选项。 <br><br> 最后，运行我们的临时课程： <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, MalformedURLException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   File ccDir = new File(CODE_CACHE_DIR); ClassLoader loader = new URLClassLoader(new URL[]{ccDir.toURL()}); var clss = loader.loadClass("io.javawatch.HelloHabr"); // Java 10 //    Object instance = clss.getConstructor().newInstance(); // Java 9 // Object instance = clss.newInstance(); Method thisMethod = clss.getDeclaredMethod("get"); Object result = thisMethod.invoke(instance); return (String) result; }</span></span></code> </pre><br> 请注意， <code>var clss = loader.loadClass</code>比<code>Class&lt;?&gt; clss = loader.loadClass</code> <code>var clss = loader.loadClass</code>编写，并且不会引入任何新的变化。  <code>var</code>关键字出现在前十名中。 <br><br> 另请注意，建议从9开始削减<code>clss.newInstance()</code> 。 他吞下异常，这很糟糕。 九人建议首先调用<code>getConstructor</code> ，该方法已参数化并抛出正确的异常。 <br><br> 还请注意，我将变量称为<code>class</code> ，但是Java却没有誓言。 作业：您可以通过多种方式来完成作业，您需要了解哪种方式最有趣以及为什么。 <br><br> 好吧，总的来说，仅此而已。 可以用 <br><br><h1> 自动化技术 </h1><br> 评论家会在这里惊叹，这里的所有内容都是黑色的，因为Java世界中有一些库可以一站式为您编译所有内容。 <br><br> 好，让我们看一下。 这是位于Google顶部的JOOR库中的代码： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> io.javawatch; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.joor.Reflect; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Supplier; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Automatic</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Supplier&lt;String&gt; supplier = Reflect.compile( <span class="hljs-string"><span class="hljs-string">"io.javawatch.HelloHabr"</span></span>, ` <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> io.javawatch; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloHabr</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">util</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Supplier</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello Habr!"</span></span>; } };` ).create().get(); System.out.println(supplier.get()); } }</code> </pre><br> 好像一切都很好。 的确，除了我不得不拖动saplayer之外，一行都可以。 <br><br> 但是有细微差别。 尝试返回“ Hello Habr！” 像原始字符串文字一样： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ``Hello Habr!``; }</code> </pre><br> 一切都会立即崩溃，并显示错误“（使用--able-preview启用原始字符串文字）”。 但是我们已经打开了吗？ 是的，两个地狱。 我们将其包含在Idea中，然后JOOR使用系统编译器进行构建！ 让我们看看里面是什么： <br><br><pre> <code class="java hljs">JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); ompiler.getTask(out, fileManager, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, files).call();</code> </pre><br> 当我们自己调用相同的JavaCompiler时，我们呢？ <br><br><pre> <code class="java hljs"> Iterable options = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"-d"</span></span>, CODE_CACHE_DIR, <span class="hljs-string"><span class="hljs-string">"--release=12"</span></span>, <span class="hljs-string"><span class="hljs-string">"--enable-preview"</span></span>, <span class="hljs-string"><span class="hljs-string">"-Xlint:preview"</span></span>); JavaCompiler.CompilationTask task = compiler.getTask(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, fileManager, c, options, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, files);</code> </pre><br> 而在JOOR中，仅有一个空null而不是选项。 他们甚至无法通过里面！ <br><br> 在JOOR中向Github发送这样的拉取请求可能是一个好主意。 如果我自己不想做，那就去吧？ <br><br> 而且道德很简单，不要怕开源礼物。 有时候，写下一小段文字会比较容易，但是可以控制它。 <br><br><h1> 最简单的方法 </h1><br> 有一种方法不写文字墙，也不使用可疑库。 从Java 9开始，我们有一个交互式外壳程序（类似于Python，Ruby和其他脚本语言的外壳程序），可以执行Java命令。 当然，它是用Java本身编写的，并且可以作为Java类使用。 您可以创建它的实例，然后直接直接执行必要的分配： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jShell = JShell.create(); <span class="hljs-comment"><span class="hljs-comment">//Java 9 jShell.eval("String result;"); jShell.eval(`result = "Hello Habr!";`); //Java 12 var result = jShell.variables() //Streams: Java 8, var: Java 10 .filter((@Nullable var v) -&gt; v.name().equals("result")) //var+lambda: Java 11 .findAny() .get(); System.out.println(jShell.varValue(result)); } }</span></span></code> </pre><br>  Streams出现在Java 8中，现在已在各处使用，您甚至不需要自己调用<code>stream()</code> ，其他人会为您调用它。 在这种情况下，调用<code>variables()</code>完全返回流，而不是ArrayList，就像一个困难的七个童年时期的人会做的那样。 流的结果可以立即倒入<code>var</code> 。 <br><br> 请注意，现在您也可以在lambda参数中编写<code>var</code> 。 自Java 11起，此功能就一直存在。 <br><br> 通常，这是非常重要的一类。 它使用了来自不同Java世代的许多功能，所有这些看起来都是整体和谐的。 我确信这样的事情将被所有人和世界各地所使用，因此Java 12中的代码在视觉上将直接不同于Java 7中的代码。 <br><br><h1> 总结一下 </h1><br> 我们研究了一些功能： <br><br><ul><li>  8：溪流（用于坦克中的人） </li><li>  9：JShell和新的不推荐使用的方法 </li><li>  10：var关键字 </li><li>  11：lambda参数的Var开发 </li><li>  12：原始字符串文字及其在IntelliJ IDEA中的支持 </li></ul><br> 对初学者的一点警告。 如果您在没有任何特殊含义的实际应用程序中不断进行此操作，那么您的同事会首先发疯，试图理解您的内容，然后他们可能会非常痛苦地击败您。 而且，我现在不是在谈论新的Java功能，而是在运行时进行编译。 <br><br> 如果您想了解有关Java作为一种语言的更多信息，那么您应该例如查看Tagir Valeev的报告。 您知道他是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">哈尼</a> （Habré）Java集线器顶端的家伙。 在Joker，他谈论了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Amber</a> ，在JPoint，谈论了他著名的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">难题</a> ，等等。 那里，以及有关Java语言和IntelliJ IDEA的所有信息。 所有这些都可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在YouTube上找到</a> 。 实际上，出于对Tagir的嫉妒，他可以说一些关于语言本身的信息，但我没有，这篇文章已经证明了。 也将有新的玩笑者和JPoint，但我们稍后会讨论。 <br><br> 我履行了我的道德义务，这是Java的义务。 从我这边，子弹飞了出来。 在那七个没有第十二个Java的人那里，您一直都很好，心情很好，身体健康。 谢谢啦 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN429670/">https://habr.com/ru/post/zh-CN429670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN429654/index.html">改善项目管理</a></li>
<li><a href="../zh-CN429656/index.html">人工智能也是错误的。 随着Amazon Go在美国为我们提供捷径-将来没有收银员和卖家的商店</a></li>
<li><a href="../zh-CN429658/index.html">SpaceX Starlink卫星互联网-“印刷货币许可证”</a></li>
<li><a href="../zh-CN429662/index.html">我们突破了机器人的保护</a></li>
<li><a href="../zh-CN429668/index.html">Google PageSpeed Insights已进行了彻底的更新，它将发生什么变化？</a></li>
<li><a href="../zh-CN429676/index.html">备份到磁带</a></li>
<li><a href="../zh-CN429678/index.html">我们如何将1000万行C ++代码转换为C ++ 14标准（然后转换为C ++ 17）</a></li>
<li><a href="../zh-CN429680/index.html">麻省理工学院的课程“计算机系统安全”。 讲座17：用户认证，第1部分</a></li>
<li><a href="../zh-CN429682/index.html">麻省理工学院的课程“计算机系统安全”。 讲座17：用户认证，第2部分</a></li>
<li><a href="../zh-CN429684/index.html">Firebase Summit 2018：简要介绍主要内容</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>