<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤓 🚗 😖 Game 3D Shaders untuk Pemula 🐞 👩🏾‍⚖️ 👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ingin mempelajari cara menambahkan tekstur, pencahayaan, bayangan, peta normal, benda bercahaya, oklusi ambien, dan efek lainnya ke permainan 3D Anda?...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Game 3D Shaders untuk Pemula</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453300/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/494/983/ba2494983fe869e14d259f717aa8fc19.gif" alt="gambar"></div><br>  Ingin mempelajari cara menambahkan tekstur, pencahayaan, bayangan, peta normal, benda bercahaya, oklusi ambien, dan efek lainnya ke permainan 3D Anda?  Hebat!  Artikel ini menyajikan serangkaian teknik naungan yang dapat meningkatkan level grafik game Anda ke ketinggian baru.  Saya menjelaskan setiap teknik sedemikian rupa sehingga Anda dapat menerapkan / port informasi ini pada tumpukan alat apa pun, baik itu Godot, Unity atau sesuatu yang lain. <br><br>  Sebagai "perekat" antara shader, saya memutuskan untuk menggunakan mesin game Panda3D dan OpenGL Shading Language (GLSL) yang sangat baik.  Jika Anda menggunakan tumpukan yang sama, Anda akan mendapatkan keuntungan tambahan - Anda akan belajar cara menggunakan teknik naungan khusus di Panda3D dan OpenGL. <br><a name="habracut"></a><br><h2>  Persiapan </h2><br>  Di bawah ini adalah sistem yang saya gunakan untuk mengembangkan dan menguji kode sampel. <br><br><h3>  Rabu </h3><br>  Kode sampel dikembangkan dan diuji dalam lingkungan berikut: <br><br><ul><li>  Linux manjaro 4.9.135-1-MANJARO </li><li>  String penyaji OpenGL: GeForce GTX 970 / PCIe / SSE2 </li><li>  String versi OpenGL: 4.6.0 NVIDIA 410.73 </li><li>  g ++ (GCC) 8.2.1 20180831 </li><li>  Panda3D 1.10.1-1 </li></ul><br><h3>  Material </h3><br>  Setiap bahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Blender</a> yang digunakan untuk membuat <code>mill-scene.egg</code> memiliki dua tekstur. <br><br>  Tekstur pertama adalah peta normal, yang kedua adalah peta difus.  Jika suatu objek menggunakan normals dari verteksnya, maka peta normal “biru polos” digunakan.  Karena kenyataan bahwa semua model memiliki kartu yang sama di posisi yang sama, shader dapat digeneralisasi dan diterapkan pada simpul akar dari grafik adegan. <br><br>  Perhatikan bahwa grafik adegan adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">fitur dari implementasi</a> mesin Panda3D. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/9c0/14f/19f9c014f06aee0e2204aa95f87c6306.png"></div><br>  Berikut ini adalah peta normal satu warna yang hanya berisi warna <code>[red = 128, green = 128, blue = 255]</code> . <br><br>  Warna ini menunjukkan unit normal, menunjukkan ke arah positif dari sumbu z <code>[0, 0, 1]</code> . <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>] = [ round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">255</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br>  Di sini kita melihat satuan normal <code>[0, 0, 1]</code> dikonversi menjadi warna biru polos <code>[128, 128, 255]</code> , dan biru pekat dikonversi menjadi satuan normal. <br><br>  Ini dijelaskan secara lebih rinci di bagian teknik overlay peta normal. <br><br><h3>  Panda3d </h3><br>  Dalam contoh kode ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Panda3D</a> digunakan sebagai "lem" antara shader.  Ini tidak mempengaruhi teknik yang dijelaskan di bawah ini, yaitu, Anda dapat menggunakan informasi yang dipelajari di sini di tumpukan atau mesin permainan yang dipilih.  Panda3D menyediakan fasilitas tertentu.  Dalam artikel yang saya bicarakan, sehingga Anda dapat menemukan mitra mereka di tumpukan Anda, atau membuat ulang sendiri jika mereka tidak di tumpukan. <br><br>  Perlu dipertimbangkan bahwa <code>gl-coordinate-system default</code> , <code>textures-power-2 down</code> dan <code>textures-auto-power-2 1</code> ditambahkan ke <code>config.prc</code> .  Mereka tidak terkandung dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">konfigurasi Panda3D</a> standar. <br><br>  Secara default, Panda3D menggunakan sistem koordinat tangan kanan dengan sumbu z ke atas, sedangkan OpenGL menggunakan sistem koordinat tangan kanan dengan sumbu y ke atas. <br><br>  <code>gl-coordinate-system default</code> memungkinkan Anda untuk menyingkirkan transformasi antara dua sistem koordinat di dalam shader. <br><br>  <code>textures-auto-power-2 1</code> memungkinkan kita untuk menggunakan ukuran tekstur yang bukan kekuatan dua, jika sistem mendukungnya. <br><br>  Ini nyaman saat melakukan SSAO atau menerapkan teknik lain dalam layar / jendela, karena ukuran layar / jendela biasanya bukan kekuatan dua. <br><br>  <code>textures-power-2 down</code> mengurangi ukuran tekstur menjadi kekuatan dua jika sistem hanya mendukung tekstur dengan ukuran yang sama dengan kekuatan dua. <br><br><h2>  Buat Kode Contoh </h2><br>  Jika Anda ingin menjalankan kode sampel, Anda harus membuatnya terlebih dahulu. <br><br>  Panda3D berjalan di Linux, Mac, dan Windows. <br><br><h3>  Linux </h3><br>  Mulailah dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">menginstal</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Panda3D SDK</a> untuk distribusi Anda. <br><br>  Temukan di mana tajuk dan perpustakaan Panda3D berada.  Kemungkinan besar, mereka berada di <code>/usr/include/panda3d/</code> dan di <code>/usr/lib/panda3d/</code> . <br><br>  Kemudian klon repositori ini dan navigasikan ke direktori. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Sekarang kompilasi kode sumber menjadi file output. <br><br> <code>g++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/usr/include/panda3d/</code> <br> <br>  Setelah membuat file output, buat file yang dapat dieksekusi dengan mengaitkan file output dengan dependensinya. <br><br> <code>g++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/usr/lib/panda3d \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">manual Panda3D untuk</a> informasi lebih lanjut. <br><br><h3>  Mac </h3><br>  Mulai dengan menginstal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Panda3D SDK</a> untuk Mac. <br><br>  Temukan di mana tajuk dan perpustakaan Panda3D berada. <br><br>  Kemudian klon repositori dan navigasikan ke direktori. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Sekarang kompilasi kode sumber menjadi file output.  Anda perlu menemukan di mana direktori include berada di Python 2.7 dan Panda3D. <br><br> <code>clang++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -g \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/Developer/Panda3D/include/</code> <br> <br>  Setelah membuat file output, buat file yang dapat dieksekusi dengan mengaitkan file output dengan dependensinya. <br><br>  Anda perlu menemukan di mana perpustakaan Panda3D berada. <br><br> <code>clang++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/Developer/Panda3D/lib \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">manual Panda3D untuk</a> informasi lebih lanjut. <br><br><h3>  Windows </h3><br>  Mulailah dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">menginstal</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Panda3D SDK</a> untuk Windows. <br><br>  Temukan di mana tajuk dan perpustakaan Panda3D berada. <br><br>  Kloning repositori ini dan navigasikan ke direktori. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">manual Panda3D untuk</a> informasi lebih lanjut. <br><br><h2>  Luncurkan demo </h2><br>  Setelah membuat kode sampel, Anda dapat menjalankan file atau demo yang dapat dieksekusi.  Ini adalah cara mereka berjalan di Linux atau Mac. <br><br> <code>./3d-game-shaders-for-beginners</code> <br> <br>  Dan mereka berjalan di Windows: <br><br> <code>3d-game-shaders-for-beginners.exe</code> <br> <br><h3>  Kontrol keyboard </h3><br>  Demo ini memiliki kontrol keyboard yang memungkinkan Anda untuk memindahkan kamera dan mengubah status berbagai efek. <br><br><h3>  Gerakan </h3><br><ul><li>  <code>w</code> - pindah jauh ke tempat kejadian. </li><li>  <code>a</code> - memutar adegan searah jarum jam. </li><li>  <code>s</code> - menjauh dari tempat kejadian. </li><li>  <code>d</code> - memutar adegan berlawanan arah jarum jam. </li></ul><br><h3>  Efek yang bisa diubah </h3><br><ul><li>  <code>y</code> - aktifkan SSAO. </li><li>  <code>Shift</code> + <code>y</code> - nonaktifkan SSAO. </li><li>  <code>u</code> - dimasukkannya sirkuit. </li><li>  <code>Shift</code> + <code>u</code> - nonaktifkan kontur. </li><li>  <code>i</code> - aktifkan mekar. </li><li>  <code>Shift</code> + <code>i</code> - nonaktifkan bloom. </li><li>  <code>o</code> - aktifkan peta normal. </li><li>  <code>Shift</code> + <code>o</code> - nonaktifkan peta normal. </li><li>  <code>p</code> - masuknya kabut. </li><li>  <code>Shift</code> + <code>p</code> - matikan kabut. </li><li>  <code>h</code> - dimasukkannya kedalaman bidang. </li><li>  <code>Shift</code> + <code>h</code> - nonaktifkan kedalaman bidang. </li><li>  <code>j</code> - aktifkan posterisasi. </li><li>  <code>Shift</code> + <code>j</code> - nonaktifkan posterisasi </li><li>  <code>k</code> - aktifkan pixelation. </li><li>  <code>Shift</code> + <code>k</code> - nonaktifkan pixelisasi. </li><li>  <code>l</code> - mengasah. </li><li>  <code>Shift</code> + <code>l</code> - menonaktifkan ketajaman. </li><li>  <code>n</code> dimasukkannya butiran film. </li><li>  <code>Shift</code> + <code>n</code> - nonaktifkan butir film. </li></ul><br><h2>  Sistem referensi </h2><br>  Sebelum Anda mulai menulis shader, Anda harus berkenalan dengan sistem referensi berikut atau mengoordinasikan sistem.  Semuanya datang ke koordinat asal dari referensi saat ini diambil dari <code>(0, 0, 0)</code> .  Segera setelah kami mengetahuinya, kami dapat mengubahnya menggunakan beberapa jenis matriks atau ruang vektor lainnya.  Biasanya, jika output shader tidak terlihat benar, maka penyebabnya adalah sistem koordinat yang membingungkan. <br><br><h3>  Model </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/9ce/863/e069ce863ffc7bd3b94394dc20b25687.gif"></div><br>  Sistem koordinat model atau objek relatif terhadap asal model.  Dalam program pemodelan tiga dimensi, misalnya, dalam Blender, biasanya ditempatkan di tengah-tengah model. <br><br><h3>  Dunia </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/9de/1f7/d0a9de1f741bb90174efd93d174ef1f9.gif"></div><br>  Ruang dunia relatif terhadap asal adegan / level / alam semesta yang Anda buat. <br><br><h3>  Ulasan </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd2/15b/b6e/bd215bb6ee79a6904eba3f6ad4ff56d3.gif"></div><br>  Ruang koordinat tampilan relatif terhadap posisi kamera aktif. <br><br><h3>  Kliping </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/505/a34/d77505a349f37a695f77625400857d58.png"></div><br>  Ruang kliping relatif ke tengah bingkai kamera.  Semua koordinat di dalamnya homogen dan dalam interval <code>(-1, 1)</code> .  X dan y sejajar dengan film kamera, dan koordinat z adalah kedalamannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/0be/d7c/dc70bed7ca78c39cc9f538b127d7176e.gif"></div><br>  Semua simpul yang tidak berada dalam batas piramida visibilitas atau volume visibilitas kamera terpotong atau dibuang.  Kita melihat bagaimana ini terjadi dengan kubus terpotong di belakang oleh pesawat jauh dari kamera, dan dengan kubus yang terletak di samping. <br><br><h3>  Layar </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/47d/336/e5b47d33660b9c1744faa12fec8ef256.png"></div><br>  Ruang layar (biasanya) relatif terhadap sudut kiri bawah layar.  X berubah dari nol ke lebar layar.  Y berubah dari nol ke tinggi layar. <br><br><h2>  GLSL </h2><br>  Alih-alih bekerja dengan pipeline fungsi tetap, kami akan menggunakan pipeline rendering GPU yang dapat diprogram.  Karena dapat diprogram, kita sendiri harus memberikannya kode program dalam bentuk shader.  Shader adalah program (biasanya kecil) yang dibuat dengan sintaks yang menyerupai bahasa C. Pipa rendering GPU yang dapat diprogram terdiri dari berbagai langkah yang dapat diprogram menggunakan shader.  Berbagai jenis shader termasuk shader vertex, shading tessellation, geometris, fragmen, dan shader komputasi.  Untuk menggunakan teknik yang dijelaskan dalam artikel, cukup bagi kita untuk menggunakan vertex dan fragmen <br>  tahapan. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 void main() {}</span></span></code> </pre> <br>  Berikut adalah shader GLSL minimal, yang terdiri dari nomor versi GLSL dan fungsi utama. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec4 p3d_Vertex; void main() { gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Berikut adalah vertex shader terpotong GLSL, yang mengubah input vertex menjadi ruang kliping dan menampilkan posisi baru ini sebagai posisi vertex yang seragam. <br><br>  Prosedur <code>main</code> tidak mengembalikan apa-apa, karena itu <code>void</code> , dan variabel <code>gl_Position</code> adalah inline output. <br><br>  Dua kata kunci yang layak disebutkan adalah: <code>uniform</code> dan <code>in</code> . <br><br>  Kata kunci yang <code>uniform</code> berarti bahwa variabel global ini sama untuk semua simpul.  Panda3D sendiri menetapkan <code>p3d_ModelViewProjectionMatrix</code> dan untuk setiap simpul itu adalah matriks yang sama. <br><br>  Kata kunci <code>in</code> berarti bahwa variabel global ini diteruskan ke shader.  Vertex shader mendapatkan setiap vertex yang terdiri dari geometri, tempat vertex shader terpasang. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 out vec4 fragColor; void main() { fragColor = vec4(0, 1, 0, 1); }</span></span></code> </pre> <br>  Berikut adalah shader fragmen GLSL yang dipangkas, menampilkan hijau buram sebagai warna fragmen. <br><br>  Jangan lupa bahwa fragmen hanya memengaruhi satu piksel layar, tetapi beberapa fragmen dapat memengaruhi satu piksel. <br><br>  Perhatikan kata kunci keluar. <br><br>  Kata kunci <code>out</code> berarti bahwa variabel global ini ditetapkan oleh shader. <br><br>  Nama <code>fragColor</code> opsional, sehingga Anda dapat memilih yang lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b4/276/b2d/8b4276b2d7e735cc05484e80e0c046e8.gif"></div><br>  Ini adalah output dari dua shader yang ditunjukkan di atas. <br><br><h2>  Rendering tekstur </h2><br>  Alih-alih rendering / menggambar langsung di layar, kode sampel menggunakan teknik untuk <br>  nama "render to tekstur" (render to tekstur).  Untuk membuat tekstur, Anda perlu mengonfigurasi frame buffer dan mengikat tekstur ke sana.  Anda dapat mengikat banyak tekstur ke buffer bingkai tunggal. <br><br>  Tekstur yang diikat ke penyangga bingkai menyimpan vektor yang dikembalikan oleh fragmen shader.  Biasanya vektor-vektor ini adalah vektor warna <code>(r, g, b, a)</code> , tetapi dapat berupa posisi atau vektor normal <code>(x, y, z, w)</code> .  Untuk setiap tekstur yang diikat, shader fragmen dapat menampilkan vektor terpisah.  Sebagai contoh, kita dapat menyimpulkan dalam satu posisi posisi dan normal dari titik. <br><br>  Sebagian besar kode contoh yang berfungsi dengan Panda3D terkait dengan pengaturan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">tekstur buffer bingkai</a> .  Untuk mempermudah, setiap fragmen shader dalam kode contoh hanya memiliki satu output.  Namun, untuk memastikan frame rate tinggi (FPS), kita perlu menampilkan informasi sebanyak mungkin di setiap pass rendering. <br><br>  Berikut adalah dua struktur tekstur untuk frame buffer dari kode sampel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac9/d2b/d50/ac9d2bd50cd1c0bc991ffe7569bf5432.gif"></div><br>  Struktur pertama menjadikan adegan watermill menjadi tekstur penyangga bingkai menggunakan berbagai vertex dan shader fragmen.  Struktur ini melewati setiap simpul panggung dengan gilingan dan sepanjang fragmen yang sesuai. <br><br>  Dalam struktur ini, kode contoh berfungsi sebagai berikut. <br><br><ul><li>  Menyimpan data geometri (misalnya, posisi atau titik normal) untuk penggunaan di masa mendatang. </li><li>  Menyimpan data material (mis. Warna difus) untuk penggunaan di masa mendatang. </li><li>  Membuat pengikatan UV untuk berbagai tekstur (difus, peta normal, peta bayangan, dll.). </li><li>  Menghitung pencahayaan ambient, difus, tercermin, dan terpancar. </li><li>  Memberikan kabut. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/554/0c2/7e55540c20fe190246f3180b3f06a731.png"></div><br>  Struktur kedua adalah kamera ortogonal yang ditujukan untuk persegi panjang dalam bentuk layar. <br>  Struktur ini berjalan hanya melalui empat puncak dan fragmen yang sesuai. <br><br>  Dalam struktur kedua, kode sampel melakukan tindakan berikut: <br><br><ul><li>  Memproses output dari tekstur frame buffer lain. </li><li>  Menggabungkan tekstur penyangga bingkai yang berbeda menjadi satu. </li></ul><br>  Dalam contoh kode, kita bisa melihat output dari satu frame buffer tekstur, mengatur frame yang sesuai menjadi true, dan false ke yang lainnya. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... bool showPositionBuffer = false; bool showNormalBuffer = false; bool showSsaoBuffer = false; bool showSsaoBlurBuffer = false; bool showMaterialDiffuseBuffer = false; bool showOutlineBuffer = false; bool showBaseBuffer = false; bool showSharpenBuffer = false; bool showBloomBuffer = false; bool showCombineBuffer = false; bool showCombineBlurBuffer = false; bool showDepthOfFieldBuffer = false; bool showPosterizeBuffer = false; bool showPixelizeBuffer = false; bool showFilmGrainBuffer = true; // ...</span></span></code> </pre> <br><h2>  Tekstur </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/0eb/1c6/d1c0eb1c650b9b05e2372b33259ed8a6.gif"></div><br>  Texturing adalah pengikatan warna atau vektor lain ke sebuah fragmen menggunakan koordinat UV.  Nilai-nilai U dan V bervariasi dari nol hingga satu.  Setiap vertex menerima koordinat UV dan ditampilkan dalam vertex shader. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/487/fee/519487fee2bb16357b225ce32649fb91.png"></div><br>  Shader fragmen mendapat koordinat UV interpolasi.  Interpolasi berarti bahwa koordinat UV untuk fragmen berada di suatu tempat antara koordinat UV dari simpul yang membentuk muka segitiga. <br><br><h3>  Vertex shader </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec2 p3d_MultiTexCoord0; in vec4 p3d_Vertex; out vec2 texCoord; void main() { texCoord = p3d_MultiTexCoord0; gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Di sini kita melihat bahwa shader puncak menghasilkan koordinat tekstur ke shader fragmen.  Perhatikan bahwa ini adalah vektor dua dimensi: satu nilai untuk U dan satu untuk V. <br><br><h3>  Shader fragmen </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D p3d_Texture0; in vec2 texCoord; out vec2 fragColor; void main() { texColor = texture(p3d_Texture0, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Di sini kita melihat bahwa shader fragmen mencari warna dalam koordinat UV-nya dan menampilkannya sebagai warna fragmen. <br><br><h4>  Layar Isi Tekstur </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D screenSizedTexture; out vec2 fragColor; void main() { vec2 texSize = textureSize(texture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; texColor = texture(screenSizedTexture, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Saat rendering ke tekstur, mesh adalah persegi panjang datar dengan rasio aspek yang sama dengan layar.  Karena itu, kita dapat menghitung koordinat UV, hanya mengetahui <br><br>  A) lebar dan tinggi tekstur dengan ukuran layar ditumpangkan pada persegi panjang menggunakan koordinat UV, dan <br>  B) koordinat x dan y dari fragmen. <br><br>  Untuk mengikat x ke U, Anda harus membagi x dengan lebar tekstur yang masuk.  Demikian pula, untuk mengikat y ke V, Anda harus membagi y dengan ketinggian tekstur yang masuk.  Anda akan melihat bahwa teknik ini digunakan dalam kode sampel. <br><br><h2>  Pencahayaan </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/05e/0ca/f9805e0ca9717c961dd9618f49475381.gif"></div><br>  Untuk menentukan pencahayaan, perlu untuk menghitung dan menggabungkan aspek-aspek pencahayaan ambient, difus, tercermin dan dipancarkan.  Kode sampel menggunakan pencahayaan Phong. <br><br><h3>  Vertex shader </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_LightSourceParameters { vec4 color ; vec4 ambient ; vec4 diffuse ; vec4 specular ; vec4 position ; vec3 spotDirection ; float spotExponent ; float spotCutoff ; float spotCosCutoff ; float constantAttenuation ; float linearAttenuation ; float quadraticAttenuation ; vec3 attenuation ; sampler2DShadow shadowMap ; mat4 shadowViewMatrix ; } p3d_LightSource[NUMBER_OF_LIGHTS]; // ...</span></span></code> </pre><br>  Untuk setiap sumber cahaya, dengan pengecualian cahaya sekitar, Panda3D memberi kami struktur nyaman yang tersedia untuk vertex dan fragmen shader.  Yang paling nyaman adalah peta bayangan dan matriks untuk melihat bayangan untuk mengubah simpul menjadi ruang bayangan atau pencahayaan. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vertexPosition = p3d_ModelViewMatrix * p3d_Vertex; // ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { vertexInShadowSpaces[i] = p3d_LightSource[i].shadowViewMatrix * vertexPosition; } // ...</span></span></code> </pre> <br>  Dimulai dengan vertex shader, kita harus mengubah dan menghapus vertex dari ruang pandang menjadi ruang bayangan atau pencahayaan untuk setiap sumber cahaya dalam adegan.  Ini akan berguna di masa depan untuk shader fragmen untuk membuat bayangan.  Ruang bayangan atau pencahayaan adalah ruang di mana setiap koordinat relatif terhadap posisi sumber cahaya (asal adalah sumber cahaya). <br><br><h3>  Shader fragmen </h3><br>  Shader fragmen melakukan sebagian besar perhitungan pencahayaan. <br><br><h4>  Material </h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct { vec4 ambient ; vec4 diffuse ; vec4 emission ; vec3 specular ; float shininess ; } p3d_Material; // ...</span></span></code> </pre> <br>  Panda3D memberi kami materi (dalam bentuk struct) untuk mesh atau model yang saat ini kami render. <br><br><h4>  Berbagai Sumber Penerangan </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuseSpecular = vec4(0.0, 0.0, 0.0, 0.0); // ...</span></span></code> </pre> <br>  Sebelum kita menjelajahi sumber-sumber iluminasi pemandangan, kita akan membuat drive yang akan berisi warna-warna yang tersebar dan dipantulkan. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { // ... } // ...</span></span></code> </pre> <br>  Sekarang kita dapat berkeliling sumber cahaya dalam satu siklus, menghitung warna yang tersebar dan dipantulkan untuk masing-masingnya. <br><br><h4>  Vektor Terkait Pencahayaan </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/307/035/ce7/307035ce7bf5a52b8f25c7aeb862b9d4.gif"></div><br>  Berikut adalah empat vektor dasar yang diperlukan untuk menghitung warna difus dan pantulan yang diperkenalkan oleh setiap sumber cahaya.  Vektor arah pencahayaan adalah panah biru yang menunjuk ke sumber cahaya.  Vektor normal adalah panah hijau yang menunjuk ke atas secara vertikal.  Vektor refleksi adalah panah biru yang mencerminkan vektor arah cahaya.  Vektor mata atau pandangan adalah panah oranye yang menunjuk ke arah kamera. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lightDirection = p3d_LightSource[i].position.xyz - vertexPosition.xyz * p3d_LightSource[i].position.w; // ...</span></span></code> </pre> <br>  Arah pencahayaan adalah vektor dari posisi titik ke posisi sumber cahaya. <br><br>  Jika ini adalah pencahayaan terarah, maka Panda3D menetapkan <code>p3d_LightSource[i].position.w</code> nol.  Pencahayaan terarah tidak memiliki posisi, hanya arah.  Oleh karena itu, jika ini adalah pencahayaan terarah, maka arah iluminasi akan menjadi arah negatif atau berlawanan dengan sumber, karena untuk pencahayaan terarah Panda3D menetapkan <code>p3d_LightSource[i].position.xyz</code> ke <code>p3d_LightSource[i].position.xyz</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... normal = normalize(vertexNormal); // ...</span></span></code> </pre> <br>  Normal ke vertex harus berupa satuan vektor.  Vektor satuan memiliki nilai yang sama dengan satu. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 unitLightDirection = normalize(lightDirection); vec3 eyeDirection = normalize(-vertexPosition.xyz); vec3 reflectedDirection = normalize(-reflect(unitLightDirection, normal)); // ...</span></span></code> </pre> <br>  Selanjutnya, kita membutuhkan tiga vektor lagi. <br><br>  Kita membutuhkan produk skalar dengan partisipasi arah pencahayaan, jadi lebih baik untuk menormalkannya.  Ini memberi kita jarak atau besarnya sama dengan kesatuan (vektor satuan). <br><br>  Arah pandangan berlawanan dengan posisi vertex / fragmen, karena posisi vertex / fragmen relatif terhadap posisi kamera.  Jangan lupa bahwa posisi vertex / fragmen berada di ruang pandang.  Oleh karena itu, alih-alih bergerak dari kamera (mata) ke vertex / fragmen, kami bergerak dari vertex / fragmen ke kamera (eye). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Vektor refleksi</a> adalah refleksi dari arah pencahayaan normal ke permukaan.  Ketika "sinar" cahaya menyentuh permukaan, itu dipantulkan pada sudut yang sama saat jatuh.  Sudut antara vektor arah iluminasi dan normal disebut "sudut timbul."  Sudut antara vektor refleksi dan normal disebut "sudut refleksi". <br><br>  Anda perlu mengubah tanda vektor cahaya yang dipantulkan, karena harus mengarah ke arah yang sama dengan vektor mata.  Jangan lupa bahwa arah mata beralih dari bagian atas / fragmen ke posisi kamera.  Kami akan menggunakan vektor refleksi untuk menghitung kecerahan cahaya yang dipantulkan. <br><br><h4>  Pencahayaan baur </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float diffuseIntensity = max(dot(normal, unitLightDirection), 0.0); if (diffuseIntensity &gt; 0) { // ... } // ...</span></span></code> </pre> <br>  Kecerahan pencahayaan difus adalah produk skalar dari normal ke permukaan dan arah iluminasi vektor tunggal.  Produk skalar dapat berkisar dari minus satu hingga satu.  Jika kedua vektor menunjuk ke arah yang sama, maka kecerahannya adalah satu.  Dalam semua kasus lain, itu akan kurang dari satu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/168/5bc/5e7/1685bc5e759e638b5c2bcc4a6c56bbd3.gif"></div><br>  Jika vektor iluminasi mendekati arah yang sama seperti normal, maka kecerahan iluminasi difus cenderung menyatu. <br><br>  Jika kecerahan pencahayaan difus kurang dari atau sama dengan nol, maka Anda harus pergi ke sumber cahaya berikutnya. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuse = vec4 ( clamp ( diffuseTex.rgb * p3d_LightSource[i].diffuse.rgb * diffuseIntensity , 0 , 1 ) , 1 ); diffuse.r = clamp(diffuse.r, 0, diffuseTex.r); diffuse.g = clamp(diffuse.g, 0, diffuseTex.g); diffuse.b = clamp(diffuse.b, 0, diffuseTex.b); // ...</span></span></code> </pre> <br>  Sekarang kita dapat menghitung warna difus yang diperkenalkan oleh sumber ini.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kecerahan pencahayaan difus sama dengan satu, maka warna difus akan menjadi campuran warna tekstur difus dan warna pencahayaan. </font><font style="vertical-align: inherit;">Pada kecerahan lainnya, warna difus akan lebih gelap. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa saya membatasi warna difus agar tidak lebih terang daripada warna tekstur difus. </font><font style="vertical-align: inherit;">Ini akan mencegah paparan berlebih dari adegan.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cahaya yang dipantulkan </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah pencahayaan difus, pantulan dihitung. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/ade/77c/989ade77c01b7137f437f97fe83ccd17.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 specular = clamp ( vec4(p3d_Material.specular, 1) * p3d_LightSource[i].specular * pow ( max(dot(reflectedDirection, eyeDirection), 0) , p3d_Material.shininess ) , 0 , 1 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kecerahan cahaya yang dipantulkan adalah produk skalar antara vektor mata dan vektor pantulan. </font><font style="vertical-align: inherit;">Seperti dalam kasus kecerahan pencahayaan difus, jika dua vektor menunjuk ke arah yang sama, maka kecerahan pencahayaan yang dipantulkan sama dengan satu. </font><font style="vertical-align: inherit;">Kecerahan lainnya akan mengurangi jumlah warna pantulan yang diperkenalkan oleh sumber cahaya ini.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/046/570/c2e046570e770e1804544d6ae67ae2f8.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kilau material menentukan berapa banyak cahaya yang dipantulkan akan tersebar. </font><font style="vertical-align: inherit;">Biasanya diatur dalam program simulasi, misalnya di Blender. </font><font style="vertical-align: inherit;">Dalam Blender, ini disebut kekerasan specular.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lampu sorot </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float unitLightDirectionDelta = dot ( normalize(p3d_LightSource[i].spotDirection) , -unitLightDirection ); if (unitLightDirectionDelta &gt;= p3d_LightSource[i].spotCosCutoff) { // ... } // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode ini tidak memungkinkan pencahayaan memengaruhi fragmen di luar sorotan lampu sorot atau piramida. </font><font style="vertical-align: inherit;">Untungnya, Panda3D dapat </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menentukan</font></font></a> <code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bekerja dengan lampu terarah dan tempat. </font><font style="vertical-align: inherit;">Lampu sorot memiliki posisi dan arah. </font><font style="vertical-align: inherit;">Namun, pencahayaan terarah hanya memiliki arah, dan sumber titik hanya memiliki posisi. </font><font style="vertical-align: inherit;">Namun, kode ini berfungsi untuk ketiga jenis pencahayaan tanpa perlu membingungkan jika pernyataan.</font></font><br><br><pre> <code class="cpp hljs">spotCosCutoff = cosine(<span class="hljs-number"><span class="hljs-number">0.5</span></span> * spotlightLensFovAngle);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika dalam hal penerangan proyeksi produk skalar dari vektor "sumber fragmen penerangan" dan vektor arah proyektor kurang dari kosinus setengah sudut bidang pandang </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyektor, maka shader tidak memperhitungkan pengaruh sumber ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa Anda harus mengubah tandanya </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beralih dari fragmen ke lampu sorot, dan kita perlu pindah dari lampu sorot ke fragmen, karena ia </font></font><code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">langsung menuju pusat piramida lampu sorot pada jarak tertentu dari posisi lampu sorot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal pencahayaan directional dan spot, Panda3D menetapkan </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai ke -1. Ingat bahwa produk skalar bervariasi dalam kisaran dari -1 hingga 1. Oleh karena itu, tidak masalah apa yang akan terjadi </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena selalu lebih besar dari atau sama dengan -1.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuse *= pow(unitLightDirectionDelta, p3d_LightSource[i].spotExponent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti kode </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">kode </font><font style="vertical-align: inherit;">ini juga berfungsi untuk ketiga jenis sumber cahaya. </font><font style="vertical-align: inherit;">Dalam kasus lampu sorot, itu akan membuat fragmen lebih terang saat mendekati pusat piramida sorotan. </font><font style="vertical-align: inherit;">Untuk sumber cahaya arah dan titik </font></font><code>spotExponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah nol. </font><font style="vertical-align: inherit;">Ingatlah bahwa nilai apa pun untuk kekuatan nol sama dengan kesatuan, sehingga warna difus sama dengan dirinya sendiri, dikalikan dengan satu, yaitu, tidak berubah.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bayangan </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float shadow = textureProj ( p3d_LightSource[i].shadowMap , vertexInShadowSpaces[i] ); diffuse.rgb *= shadow; specular.rgb *= shadow; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panda3D menyederhanakan penggunaan bayangan karena ia menciptakan peta bayangan dan matriks transformasi bayangan untuk setiap sumber cahaya di tempat kejadian. Untuk membuat matriks transformasi sendiri, Anda perlu mengumpulkan matriks yang mengubah koordinat ruang tontonan menjadi ruang pencahayaan (koordinat relatif terhadap posisi sumber cahaya). Untuk membuat bayangan peta sendiri, Anda perlu membuat adegan dari sudut pandang sumber cahaya ke dalam tekstur penyangga bingkai. Tekstur buffer bingkai harus berisi jarak dari sumber cahaya ke fragmen. Ini disebut "peta kedalaman". Akhirnya, Anda perlu mentransfer secara manual ke shader peta kedalaman buatan sendiri </font></font><code>uniform sampler2DShadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan matriks transformasi bayangan </font></font><code>uniform mat4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jadi kami akan menciptakan kembali apa yang Panda3D lakukan secara otomatis untuk kami.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuplikan kode yang ditampilkan digunakan </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang berbeda dari fungsi yang ditunjukkan di atas </font></font><code>texture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membagi pertama </font></font><code>vertexInShadowSpaces[i].xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan </font></font><code>vertexInShadowSpaces[i].w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dia kemudian menggunakannya </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menemukan kedalaman yang tersimpan di peta bayangan. Kemudian dia menggunakan </font></font><code>vertexInShadowSpaces[i].z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk membandingkan kedalaman bagian atas dengan kedalaman peta bayangan </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika perbandingan berhasil, itu </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan satu. Jika tidak, ia mengembalikan nol. Nol berarti bahwa simpul / fragmen ini ada dalam bayangan, dan satu berarti bahwa simpul / fragmen ini tidak ada dalam bayangan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu juga dapat mengembalikan nilai dari nol ke satu, tergantung pada bagaimana peta bayangan dikonfigurasi. Dalam contoh ini</font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melakukan beberapa tes kedalaman berdasarkan kedalaman yang berdekatan dan mengembalikan rata-rata tertimbang. </font><font style="vertical-align: inherit;">Rata-rata tertimbang ini dapat memberikan kehalusan bayangan.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pelemahan </font></font></h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/381/e8d/bfb/381e8dbfb118dac85b139d0c1ec41bad.png"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float lightDistance = length(lightDirection); float attenuation = 1 / ( p3d_LightSource[i].constantAttenuation + p3d_LightSource[i].linearAttenuation * lightDistance + p3d_LightSource[i].quadraticAttenuation * (lightDistance * lightDistance) ); diffuse.rgb *= attenuation; specular.rgb *= attenuation; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jarak ke sumber cahaya hanyalah besarnya atau panjang vektor arah pencahayaan. </font><font style="vertical-align: inherit;">Perhatikan bahwa kita tidak menggunakan arah penerangan yang dinormalisasi, karena jarak seperti itu akan sama dengan persatuan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jarak ke sumber cahaya diperlukan untuk menghitung redaman. </font><font style="vertical-align: inherit;">Atenuasi berarti bahwa efek cahaya dari sumber berkurang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font></font><code>constantAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>quadraticAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat mengatur nilai apa pun. </font><font style="vertical-align: inherit;">Layak dimulai dengan </font></font><code>constantAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>quadraticAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dengan parameter-parameter ini, pada posisi sumber cahaya itu sama dengan kesatuan dan cenderung nol ketika menjauh darinya.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pencahayaan warna terakhir </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuseSpecular += (diffuse + specular); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menghitung warna akhir pencahayaan, Anda perlu menambahkan warna difus dan pantulan. </font><font style="vertical-align: inherit;">Penting untuk menambahkan ini ke drive dalam siklus melewati sumber cahaya di tempat kejadian.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ambient </font></font></h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture1; // ... uniform struct { vec4 ambient ; } p3d_LightModel; // ... in vec2 diffuseCoord; // ... vec4 diffuseTex = texture(p3d_Texture1, diffuseCoord); // ... vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponen pencahayaan ambient dalam model pencahayaan didasarkan pada warna ambien material, warna pencahayaan ambient, dan warna tekstur yang menyebar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seharusnya tidak pernah ada lebih dari satu sumber cahaya sekitar, oleh karena itu perhitungan ini harus dilakukan hanya sekali, berbeda dengan perhitungan warna difus dan pantulan yang terakumulasi untuk setiap sumber cahaya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harap dicatat bahwa warna cahaya sekitar sangat berguna saat melakukan SSAO.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menyatukan semuanya </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 outputColor = ambient + diffuseSpecular + p3d_Material.emission; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warna akhir adalah jumlah dari warna ambient, warna difus, warna pantulan, dan warna yang dipancarkan. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode sumber </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peta Normal </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/6bb/9de/6d16bb9deae1520429083896b7492a3f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan peta normal memungkinkan Anda untuk menambahkan bagian baru ke permukaan tanpa geometri tambahan. </font><font style="vertical-align: inherit;">Biasanya, ketika bekerja dalam program pemodelan 3D, dibuat versi mesh yang tinggi dan rendah. </font><font style="vertical-align: inherit;">Kemudian normals dari simpul dari poly mesh tinggi diambil dan dibakar ke dalam tekstur. </font><font style="vertical-align: inherit;">Tekstur ini adalah peta normal. </font><font style="vertical-align: inherit;">Kemudian di dalam shader fragmen kami mengganti normals dari simpul-simpul dari mesh poli rendah dengan normals dari mesh poli tinggi yang dipanggang ke dalam peta normal. </font><font style="vertical-align: inherit;">Karena ini, ketika menyalakan mesh, akan tampak bahwa ia memiliki lebih banyak poligon daripada yang sebenarnya. </font><font style="vertical-align: inherit;">Ini memungkinkan Anda mempertahankan FPS tinggi, sambil mentransmisikan sebagian besar detail dari versi poli tinggi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/92b/4ae/8e192b4ae48d96a65b92456ba640c7d0.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di sini kita melihat transisi dari model poli tinggi ke model poli rendah, dan kemudian ke model poli rendah dengan peta normal ditumpangkan. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/987/20d/ee1/98720dee1f77246721e1905abf2ebea4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, jangan lupa bahwa overlay peta normal hanyalah ilusi. </font><font style="vertical-align: inherit;">Pada sudut tertentu, permukaan mulai terlihat datar lagi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertex shader </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform mat3 p3d_NormalMatrix; // ... in vec3 p3d_Normal; // ... in vec3 p3d_Binormal; in vec3 p3d_Tangent; // ... vertexNormal = normalize(p3d_NormalMatrix * p3d_Normal); binormal = normalize(p3d_NormalMatrix * p3d_Binormal); tangent = normalize(p3d_NormalMatrix * p3d_Tangent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dimulai dengan vertex shader, kita perlu menampilkan vektor normal, vektor binormal, dan vektor garis singgung ke fragmen shader. </font><font style="vertical-align: inherit;">Vektor ini digunakan dalam shader fragmen untuk mengubah normal dari peta normal dari ruang singgung ke ruang tampilan. </font></font><br><br> <code>p3d_NormalMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengkonversi vektor normal dari vertex, binormal, dan vektor singgung ke ruang tampilan. </font><font style="vertical-align: inherit;">Jangan lupa bahwa dalam ruang tampilan semua koordinat relatif terhadap posisi kamera.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[p3d_NormalMatrix] adalah elemen transpose terbalik 3x3 teratas dari ModelViewMatrix. </font><font style="vertical-align: inherit;">Struktur ini digunakan untuk mengubah vektor normal ke koordinat ruang tontonan.</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Sumber</a> </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... in vec2 p3d_MultiTexCoord0; // ... out vec2 normalCoord; // ... normalCoord = p3d_MultiTexCoord0; // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b40/f21/575/b40f21575482aa633de61643a1c497aa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kita juga perlu menampilkan koordinat UV dari peta normal ke shader fragmen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader fragmen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingat bahwa titik normal digunakan untuk menghitung pencahayaan. </font><font style="vertical-align: inherit;">Namun, untuk menghitung pencahayaan, peta normal memberi kita normals lainnya. </font><font style="vertical-align: inherit;">Dalam shader fragmen, kita perlu mengganti normals dari simpul dengan normals yang terletak di peta normal.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture0; // ... in vec2 normalCoord; // ... /* Find */ vec4 normalTex = texture(p3d_Texture0, normalCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menggunakan koordinat peta normal yang ditransfer oleh vertex shader, kami mengekstrak normal yang sesuai dari peta. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 normal; // ... /* Unpack */ normal = normalize ( normalTex.rgb * 2.0 - 1.0 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di atas, saya menunjukkan bagaimana normals dikonversi ke warna untuk membuat peta normal. </font><font style="vertical-align: inherit;">Sekarang kita perlu membalikkan proses ini sehingga kita bisa mendapatkan normals asli yang dipanggang ke peta.</font></font><br><br><pre> <code class="cpp hljs">[ r, g, b] = [ r * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, g * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, b * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ x, y, z]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beginilah proses pembongkaran normals dari peta normal. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... /* Transform */ normal = normalize ( mat3 ( tangent , binormal , vertexNormal ) * normal ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal yang diperoleh dari peta normal biasanya dalam ruang singgung. </font><font style="vertical-align: inherit;">Namun, mereka bisa berada di ruang lain. </font><font style="vertical-align: inherit;">Misalnya, Blender memungkinkan Anda memanggang normalnya dalam ruang singgung, ruang objek, ruang dunia, dan ruang kamera.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/009/cfc/62c/009cfc62c03b455a1e22b68e8636e735.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mentransfer normal peta normal dari ruang singgung ke ruang tampilan, buat matriks 3x3 berdasarkan vektor singgung, vektor binormal, dan vertex normal. </font><font style="vertical-align: inherit;">Gandakan yang normal dengan matriks ini dan normalkan itu. </font><font style="vertical-align: inherit;">Di sinilah kami berakhir dengan normals. </font><font style="vertical-align: inherit;">Semua perhitungan pencahayaan lainnya masih dilakukan.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode sumber </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453300/">https://habr.com/ru/post/id453300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453290/index.html">Intisari Ilmu Data (Mei 2019)</a></li>
<li><a href="../id453292/index.html">"Sebuah buku kecil tentang lubang hitam"</a></li>
<li><a href="../id453294/index.html">Bereaksi Pemuatan malas</a></li>
<li><a href="../id453296/index.html">Mengelola Asynchrony dalam PHP: From Promises to Coroutines</a></li>
<li><a href="../id453298/index.html">Musim panas: waktu upgrade ... diri Anda sendiri</a></li>
<li><a href="../id453302/index.html">Jam pertama kehidupan bersama Yandex.Module</a></li>
<li><a href="../id453304/index.html">Manfaat Utama dari Zextras PowerStore</a></li>
<li><a href="../id453306/index.html">Kubernetes akan mengambil alih dunia. Kapan dan bagaimana?</a></li>
<li><a href="../id453310/index.html">Pertukaran data antara komponen Bereaksi menggunakan perpustakaan RxJS</a></li>
<li><a href="../id453312/index.html">Generator email bisnis PDF berdasarkan data XML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>