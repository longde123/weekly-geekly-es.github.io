<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèâ ü•í üïì Token kriptografis PKCS # 11: melihat dan mengekspor sertifikat, memeriksa validitasnya üå≤ üßùüèº üîù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam komentar pada artikel "Utilitas lintas platform berbahasa Inggris untuk melihat sertifikat x509 yang memenuhi syarat Rusia" ada keinginan dari p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Token kriptografis PKCS # 11: melihat dan mengekspor sertifikat, memeriksa validitasnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443480/"><img src="https://habrastorage.org/webt/jg/xr/s2/jgxrs2y4nfsgsn6ljt8l0wpevgy.png" align="left" alt="gambar">  Dalam komentar pada artikel "Utilitas lintas platform berbahasa Inggris untuk melihat sertifikat x509 yang memenuhi syarat Rusia" ada keinginan dari pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Pas</a> untuk tidak hanya "penguraian sertifikat", tetapi juga untuk menerima "rantai sertifikat root dan melaksanakan validasi PKI, setidaknya untuk sertifikat dengan token dengan kunci yang dapat diekstraksi. ".  Memperoleh rantai sertifikat dijelaskan dalam salah satu artikel sebelumnya.  Benar, ini tentang sertifikat yang disimpan dalam file, tetapi kami berjanji untuk menambahkan mekanisme untuk bekerja dengan sertifikat yang disimpan di token PKCS # 11.  Dan itulah yang terjadi pada akhirnya. <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/cg/vd/fw/cgvdfwfqdxc1tbvkkpcec_vzye8.png"><br><br>  Utilitas parsing dan melihat ditulis dalam Tcl / Tk, dan untuk menambahkan token / kartu pintar PKCS # 11 ke dalamnya, melihat sertifikat serta memeriksa validitas sertifikat, perlu untuk menyelesaikan beberapa masalah: <br><br><ul><li>  menentukan mekanisme untuk mendapatkan sertifikat dari token / smart card; </li><li>  periksa sertifikat terhadap daftar sertifikat CRL yang dicabut; </li><li>  periksa sertifikat validitas dengan mekanisme OCSP. </li></ul><br><h3>  <font color="#0000ff">Akses ke Token PKCS # 11</font> </h3><br>  Untuk mengakses token dan sertifikat yang tersimpan di dalamnya, kami akan menggunakan paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TclPKCS11</a> .  Paket ini didistribusikan dalam biner dan kode sumber.  Kode sumber akan berguna nanti ketika kita menambahkan dukungan token dengan kriptografi Rusia ke paket.  Ada dua cara untuk mengunduh paket TclPKCS11, atau menggunakan perintah tcl dari formulir: <br><br><pre><code class="plaintext hljs">load &lt; tclpkcs11&gt; Tclpkcs11</code> </pre> <br>  Atau unduh hanya sebagai paket pki :: pkcs11, setelah meletakkan pustaka tclpkcs11 dan file pkgIndex.tcl ke dalam direktori yang nyaman bagi Anda (dalam kasus kami, ini adalah subdirektori pkcs11 dari direktori saat ini) dan menambahkannya ke jalur auto_path: <br><br><pre> <code class="plaintext hljs">#lappend auto_path [file dirname [info scrypt]] lappend auto_path pkcs11 package require pki package require pki::pkcs11</code> </pre> <br>  Karena kami tertarik pada token terutama dengan dukungan untuk kriptografi Rusia, dari paket TclPKCS11 kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi</a> berikut: <br><blockquote><pre> <code class="plaintext hljs">::pki::pkcs11::loadmodule &lt;filename&gt; -&gt; handle ::pki::pkcs11::unloadmodule &lt;handle&gt; -&gt; true/false ::pki::pkcs11::listslots &lt;handle&gt; -&gt; list: slotId label flags ::pki::pkcs11::listcerts &lt;handle&gt; &lt;slotId&gt; -&gt; list: keylist ::pki::pkcs11::login &lt;handle&gt; &lt;slotId&gt; &lt;password&gt; -&gt; true/false ::pki::pkcs11::logout &lt;handle&gt; &lt;slotId&gt; -&gt; true/false</code> </pre> </blockquote>  Segera buat reservasi bahwa fungsi masuk dan keluar tidak akan dipertimbangkan di sini.  Ini disebabkan oleh fakta bahwa dalam artikel ini kita hanya akan berurusan dengan sertifikat, dan mereka adalah objek token publik.  Untuk mengakses objek publik tidak perlu masuk melalui kode PIN pada token. <br><br>  Fungsi pertama :: pki :: pkcs11 :: loadmodule adalah untuk memuat pustaka PKCS # 11, yang mendukung token / kartu pintar tempat sertifikat berada.  Perpustakaan dapat diperoleh dengan membeli token, atau diunduh dari Internet, atau sudah diinstal sebelumnya di komputer.  Bagaimanapun, Anda perlu tahu perpustakaan mana yang mendukung token Anda.  Fungsi loadmodule mengembalikan pegangan ke pustaka yang dimuat: <br><br><pre> <code class="plaintext hljs">set filelib "/usr/local/lib64/librtpkcs11ecp_2.0.so" set handle [::pki::pkcs11::loadmodule $filelib]</code> </pre> <br>  Karenanya, ada fungsi untuk membongkar pustaka yang dimuat: <br><br><pre> <code class="plaintext hljs">::pki::pkcs11::unloadmodule $handle</code> </pre> <br>  Setelah perpustakaan dimuat dan kami memiliki pegangannya, Anda bisa mendapatkan daftar slot yang didukung oleh perpustakaan ini: <br><br><pre> <code class="plaintext hljs">::pki::pkcs11::listslots $handle {0 {ruToken ECP } {TOKEN_PRESENT RNG LOGIN_REQUIRED USER_PIN_INITIALIZED TOKEN_INITIALIZED REMOVABLE_DEVICE HW_SLOT}} {1 { } {REMOVABLE_DEVICE HW_SLOT}} . . . {14 { } {REMOVABLE_D EVICE HW_SLOT}}</code> </pre> <br>  Dalam contoh ini, daftar berisi 15 (lima belas dari 0 hingga 14) elemen.  Itu adalah berapa banyak slot yang dapat didukung oleh keluarga token RuToken.  Pada gilirannya, setiap elemen dari daftar itu sendiri adalah daftar dari tiga elemen: <br><br><pre> <code class="plaintext hljs">{{ } { } {   }}</code> </pre> <br>  Elemen pertama dari daftar adalah nomor slot.  Elemen kedua dari daftar adalah label yang terletak di slot token (32 byte).  Jika slotnya kosong, maka elemen kedua berisi 32 spasi.  Dan yang terakhir, elemen ketiga dari daftar berisi bendera.  Kami tidak akan mempertimbangkan seluruh rangkaian bendera.  Yang menarik bagi kami dalam bendera ini adalah keberadaan bendera TOKEN_PRESENT.  Bendera inilah yang menunjukkan bahwa token ada di slot, dan sertifikat yang menarik bagi kami bisa ada di token.  Bendera adalah hal yang sangat berguna, mereka menggambarkan keadaan token, status kode PIN, dll.  Berdasarkan nilai bendera, token PKCS # 11 dikelola: <br><br><img src="https://habrastorage.org/webt/yq/7x/n1/yq7xn1qbusjtjirrudo1ebhjzhc.png"><br><br>  Sekarang, tidak ada yang mencegah Anda menulis prosedur slots_with_token, yang akan mengembalikan daftar slot dengan label token di dalamnya: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh lappend auto_path pkcs11 package require pki package require pki::pkcs11 #    proc ::slots_with_token {handle} { set slots [pki::pkcs11::listslots $handle] # puts "Slots: $slots" array set listtok [] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set listtok($slotid) $slotlabel } } #     parray listtok return [array get listtok] } set filelib "/usr/local/lib64/librtpkcs11ecp_2.0.so" if {[catch {set handle [::pki::pkcs11::loadmodule $filelib]} res]} { puts "Cannot load library $filelib : $res" exit } #   set listslots {} set listslots [::slots_with_token $handle] #        while {[llength $listslots] == 0} { puts " " after 3000 set listslots [::slots_with_token $handle] } #        foreach {slotid labeltok} $listslots { puts "Number slot: $slotid" puts "Label token: $labeltok" }</code> </pre> <br>  Jika Anda menjalankan skrip ini, setelah menyimpannya di file slots_with_token.tcl, maka sebagai hasilnya kita mendapatkan: <br><br><pre> <code class="bash hljs">$ ./slots_with_token.tcl listtok(0) = ruToken ECP listtok(1) = RuTokenECP20 Number slot: 0 Label token: RuTokenECP20 Number slot: 1 Label token: ruToken ECP $</code> </pre> <br>  Dari 15 slot yang tersedia untuk perpustakaan ini, hanya dua yang terlibat, nol dan yang pertama. <br>  Sekarang tidak ada yang mencegah mendapatkan daftar sertifikat yang terletak di token tertentu: <br><br><pre> <code class="plaintext hljs">set listcerts [::pki::pkcs11::listcerts $handle $slotid]</code> </pre> <br>  Setiap item daftar berisi informasi tentang satu sertifikat.  Untuk mendapatkan informasi dari sertifikat, fungsi :: pki :: pkcs11 :: listcerts menggunakan fungsi :: pki :: x509 :: parse_cert dari paket pki.  Tetapi fungsi :: pki :: pkcs11 :: listcerts melengkapi daftar ini dengan data yang melekat pada protokol PKCS # 11, yaitu: <br><br><ul><li>  pkcs11_ elemen label (dalam terminologi atribut PKCS # 11 CKA_LABEL); </li><li>  elemen pkcs11_id (dalam terminologi atribut PKCS # 11 CKA_ID); </li><li>  elemen pkcs11_handle yang berisi indikasi pustaka PKCS # 11 yang dimuat; </li><li>  elemen pkcs11_slotid yang berisi jumlah slot dengan token tempat sertifikat ini berada; </li><li>  elemen tipe yang berisi nilai pkcs11 untuk sertifikat yang ada di token. </li></ul><br>  Ingat bahwa elemen yang tersisa terutama ditentukan oleh fungsi pki :: parse_cert. <br>  Di bawah ini adalah prosedur untuk memperoleh daftar label (listCert) sertifikat (CKA_LABEL, pkcs11_label) dan array pengidentifikasi yang diurai (:: certs_p11).  Kunci untuk mengakses elemen array sertifikat adalah label sertifikat (CKA_LABEL, pkcs11_label): <br><br><pre> <code class="plaintext hljs">#  proc listcerttok {handle token_slotlabel token_slotid} { #     set listCer {} #   array set ::arrayCer [] set ::certs_p11 [pki::pkcs11::listcerts $handle $token_slotid] if {[llength $::certs_p11] == 0} { puts {Certificates are not on the token:$tokenslotlabel} return $listCer } foreach certinfo_list $::certs_p11 { unset -nocomplain certinfo array set certinfo $certinfo_list set certinfo(pubkeyinfo) [::pki::x509::parse_cert_pubkeyinfo $certinfo(cert)] set ::arrayCer($certinfo(pkcs11_label)) $certinfo(cert) lappend listCer $certinfo(pkcs11_label) } return $listCer }</code> </pre> <br>  Dan sekarang kami telah mem-parsing sertifikat, kami dengan tenang menampilkan daftar label mereka di kotak kombo: <br><br><img src="https://habrastorage.org/webt/wd/7_/si/wd7_siithrzlh1gfwa5tm78rpbg.png"><br><br>  Cara mengurai kunci publik GOST yang kami pertimbangkan di artikel sebelumnya. <br><br>  Dua kata tentang ekspor sertifikat.  Sertifikat diekspor baik dalam encoding PEM dan encoding DER (tombol DER, format PEM).  Paket pki memiliki fungsi yang mudah pki :: _ encode_pem untuk mengkonversi ke format PEM: <br><br><pre> <code class="plaintext hljs">set bufpem [::pki::_encode_pem &lt;der-buffer&gt; &lt;Headline&gt; &lt;Lastline&gt;]</code> </pre> <br>  misalnya: <br><br><pre> <code class="plaintext hljs">set certpem [::pki::encode_pen $cert_der "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"]</code> </pre> <br>  Dengan memilih label sertifikat septik dalam kotak kombo, kami mendapatkan akses ke badan sertifikat: <br><br><pre> <code class="plaintext hljs">#    set nick [.saveCert.labExp.listCert get] #        foreach certinfo_list $::certs_p11 { unset -nocomplain cert_parse array set cert_parse $certinfo_list if {$cert_parse(pkcs11_label) == $nick} { #   set cert_parse(pubkeyinfo) [::pki::x509::parse_cert_pubkeyinfo $cert_parse(cert)] break } } #   file|pkcs11 set ::tekcert "pkcs11"</code> </pre> <br>  Mekanisme lebih lanjut untuk penguraian sertifikat dan menampilkannya sebelumnya dibahas di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  <font color="#0000ff">Validasi Sertifikat</font> </h3><br>  Saat menguraikan sertifikat, variabel :: notbefore dan :: notafter menyimpan tanggal dari mana sertifikat dapat digunakan dalam operasi kriptografi (tanda, enkripsi, dll.), Dan tanggal kedaluwarsa sertifikat.  Prosedur untuk memeriksa masa berlaku sertifikat adalah: <br><br><pre> <code class="plaintext hljs">proc cert_valid_date {} { #       #    set startdate $::notbefore #    set enddate $::notafter #      set now [clock seconds] set isvalid 1 set reason "Certificate is valid" if {$startdate &gt; $now} { set isvalid 0 #      set reason "Certificate is not yet valid" } elseif {$now &gt; $enddate} { set isvalid 0 #    set reason "Certificate has expired" } return [list $isvalid $reason] }</code> </pre> <br>  Daftar yang dikembalikan berisi dua item.  Elemen pertama dapat berisi 0 (nol) atau 1 (satu).  Nilai "1" menunjukkan bahwa sertifikat itu valid, dan 0 menunjukkan bahwa sertifikat itu tidak valid.  Alasan sertifikat tidak valid diungkapkan dalam elemen kedua.  Elemen ini dapat berisi satu dari tiga nilai: <br><br><ul><li>  sertifikat valid (elemen pertama dari daftar adalah 1): </li><li>  sertifikat belum valid (sertifikat belum kedaluwarsa) </li><li>  sertifikat telah kedaluwarsa. </li></ul><br>  Validitas sertifikat ditentukan tidak hanya oleh masa berlakunya.  Sertifikat dapat ditangguhkan atau diberhentikan oleh pusat sertifikasi, baik atas inisiatifnya sendiri dan atas permintaan pemegang sertifikat, misalnya, jika kehilangan media dengan kunci pribadi.  Dalam hal ini, sertifikat tersebut dimasukkan oleh otoritas sertifikasi dalam daftar sertifikat COS / CRL yang dicabut yang didistribusikan oleh CA.  Biasanya, titik distribusi CRL termasuk dalam sertifikat.  Dari daftar sertifikat yang dicabut, validitas sertifikat diperiksa. <br><br><h3>  <font color="#0000ff">Validasi validitas sertifikat oleh SOS / CRL</font> </h3><br>  Langkah pertama adalah mendapatkan SOS, lalu parsing dan periksa sertifikatnya. <br>  Daftar poin penerbitan COC / CRL ada dalam ekstensi sertifikat dengan oid 2.5.29.31 (id-ce-cRLDistributionPoints): <br><br><pre> <code class="plaintext hljs">array set extcert $cert_parse(extensions) set ::crlfile "" if {[info exists extcert(2.5.29.31)]} { set ::crlfile [crlpoints [lindex $extcert(2.5.29.31) 1]] } else { puts "cannot load CRL" }</code> </pre> <br>  Sebenarnya memuat file dengan SOS / CRL adalah sebagai berikut: <br><br><pre> <code class="plaintext hljs">set filecrl "" set pointcrl "" foreach pointcrl $::crlfile { set filecrl [readca $pointcrl $dir] if {$filecrl != ""} { set f [file join $dir [file tail $pointcrl]] set fd [open $fw] chan configure $fd -translation binary puts -nonewline $fd $filecrl close $fd set filecrl $f break } # CRL  .     CRL } if {$filecrl == ""} { puts "Cannot load CRL" }</code> </pre> <br>  Sebenarnya, prosedur readca digunakan untuk memuat COC / CRL: <br><br><pre> <code class="plaintext hljs">proc readca {url dir} { set cer "" #   if { "https://" == [string range $url 0 7]} { #    tls http::register https 443 ::tls::socket } #     if {[catch {set token [http::geturl $url -binary 1] #    set ere [http::status $token] if {$ere == "ok"} { #        set code [http::ncode $token] if {$code == 200} { #      set cer [http::data $token] } elseif {$code == 301 || $code == 302} { #    ,   set newURL [dict get [http::meta $token] Location] #     set cer [readca $newURL $dir] } else { #    set cer "" } } } error]} { #   ,     set cer "" } return $cer }</code> </pre><br>  Variabel dir menyimpan path ke direktori di mana COS / CRL akan disimpan, dan variabel url berisi daftar poin distribusi CRL yang sebelumnya diterima. <br><br>  Ketika menerima SOS / CRL, saya tiba-tiba harus menghadapi kenyataan bahwa untuk beberapa sertifikat daftar ini harus diterima melalui protokol https (tls) dalam mode anonim.  Jujur, ini mengejutkan: daftar CRL adalah dokumen publik dan integritasnya dilindungi oleh tanda tangan elektronik dan saya memiliki akses ke sana melalui https anonim menurut saya.  Tetapi tidak ada yang bisa dilakukan, Anda harus menghubungkan paket tls - paket membutuhkan tls. <br><br>  Jika SOS / CRL tidak dapat diunduh, maka sertifikat tidak dapat diverifikasi jika jalur akses dengan layanan OCSP tidak ditentukan dalam sertifikat.  Tetapi ini akan dibahas dalam salah satu artikel berikut. <br><br>  Jadi, ada sertifikat untuk verifikasi, ada daftar SOS / CRL, masih harus memeriksa sertifikat untuk itu.  Sayangnya, tidak ada fungsi yang sesuai dalam paket pki.  Oleh karena itu, saya harus menulis prosedur untuk memeriksa validitas sertifikat (tidak dicabut) dari daftar sertifikat yang dicabut. <br><br><div class="spoiler">  <b class="spoiler_title">validaty_cert_from_crl:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">proc validaty_cert_from_crl {crl sernum issuer} { array set ret [list] if { [string range $crl 0 9 ] == "-----BEGIN" } { array set parsed_crl [::pki::_parse_pem $crl "-----BEGIN X509 CRL-----" "-----END X509 CRL-----"] set crl $parsed_crl(data) } ::asn::asnGetSequence crl crl_seq ::asn::asnGetSequence crl_seq crl_base ::asn::asnPeekByte crl_base peek_tag if {$peek_tag == 0x02} { #   .CRL ::asn::asnGetInteger crl_base ret(version) incr ret(version) } else { set ret(version) 1 } ::asn::asnGetSequence crl_base crl_full ::asn::asnGetObjectIdentifier crl_full ret(signtype) ::::asn::asnGetSequence crl_base crl_issue set ret(issue) [::pki::x509::_dn_to_string $crl_issue] #     /CRL if {$ret(issue) != $issuer } { #/CRL    set ret(error) "Bad Issuer" return [array get ret] } binary scan $crl_issue H* ret(issue_hex) #  ::asn::asnGetUTCTime crl_base ret(publishDate) #   ::asn::asnGetUTCTime crl_base ret(nextDate) #   ::asn::asnPeekByte crl_base peek_tag if {$peek_tag != 0x30} { #    return [array get ret] } ::asn::asnGetSequence crl_base lcert # binary scan $lcert H* ret(lcert) while {$lcert != ""} { ::asn::asnGetSequence lcert lcerti #    ::asn::asnGetBigInteger lcerti ret(sernumrev) set ret(sernumrev) [::math::bignum::tostr $ret(sernumrev)] #      CRL if {$ret(sernumrev) != $sernum} { continue } # .    ::asn::asnGetUTCTime lcerti ret(revokeDate) if {$lcerti != ""} { #   ::asn::asnGetSequence lcerti lcertir ::asn::asnGetSequence lcertir reasone ::asn::asnGetObjectIdentifier reasone ret(reasone) ::asn::asnGetOctetString reasone reasone2 ::asn::asnGetEnumeration reasone2 ret(reasoneData) } break; } return [array get ret] }</code> </pre></div></div><br>  Parameter untuk fungsi ini adalah daftar pencabutan sertifikat (crl), nomor seri sertifikat yang diverifikasi (sernum), dan penerbitnya (penerbit). <br><br>  Daftar pencabutan sertifikat (crl) dimuat sebagai berikut: <br><br><pre> <code class="plaintext hljs">set f [open $filecrl r] chan configure $f -translation binary set crl [read $f] close $f</code> </pre> <br>  Nomor seri sertifikat terverifikasi (sernum) dan penerbitnya (penerbit) diambil dari sertifikat yang diuraikan dan disimpan dalam variabel :: sncert dan :: issuercert. <br><br>  Semua prosedur dapat ditemukan dalam kode sumber.  Kode sumber utilitas dan distribusinya untuk Linux, OS X (macOS) dan MS Windows dapat ditemukan di sini. <br><br><div class="spoiler">  <b class="spoiler_title">disini</b> <div class="spoiler_text"><ul><li>  <a href="">kode sumber</a> </li><li>  <a href="">Linux32</a> </li><li>  <a href="">Linux64</a> </li><li>  <a href="">OS X</a> </li><li>  <a href="">WIN32</a> </li><li>  <a href="">WIN64</a> </li></ul><br></div></div><br>  Utilitas juga mempertahankan kemampuan untuk melihat dan memverifikasi sertifikat yang disimpan dalam file: <br><br><img src="https://habrastorage.org/webt/ja/tv/nl/jatvnlolqcsggytw3nn8x51zpls.png"><br><br>  Omong-omong, sertifikat yang dilihat dari file juga dapat diekspor, serta yang disimpan di token.  Ini membuatnya mudah untuk mengkonversi file sertifikat dari format DER ke PEM dan sebaliknya. <br><br>  Sekarang kami memiliki satu penampil untuk sertifikat yang disimpan dalam file dan pada token / kartu pintar PKCS # 11. <br><br>  Ya, saya melewatkan intinya: untuk memeriksa validitas sertifikat, klik tombol "Tambahan" dan pilih item menu "Validaty oleh CRL" atau tekan tombol mouse kanan dan ketika kursor berada pada informasi utama bidang dan juga pilih item menu "Validaty oleh CRL": <br><br><img src="https://habrastorage.org/webt/ig/ph/rm/igphrmcbunw9b8jtkdiepfjaqpm.png"><br><br>  Tangkapan layar ini menunjukkan penelusuran dan validasi sertifikat dalam token cloud. <br><br>  Sebagai kesimpulan, kami mencatat hal berikut.  Dalam komentarnya pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tersebut</a> , pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Pas</a> dengan benar mencatat tentang token PKCS # 11 bahwa mereka ‚Äúsendiri dapat menghitung semuanya‚Äù.  Ya, token sebenarnya adalah komputer kriptografis.  Dan dalam artikel berikut kita akan berbicara tidak hanya tentang bagaimana sertifikat diverifikasi menggunakan protokol OCSP, tetapi juga tentang bagaimana menggunakan mekanisme kriptografi (kita berbicara, tentu saja, kriptografi GOST) dari token / kecerdasan untuk menghitung hash (GOST R 34-10- 94/2012), pembentukan dan verifikasi tanda tangan, dll. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443480/">https://habr.com/ru/post/id443480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443468/index.html">Alat pemantauan jaringan apa yang telah menjadi pemimpin dalam versi Gartner</a></li>
<li><a href="../id443470/index.html">Sejarah mengetik pada contoh satu proyek besar</a></li>
<li><a href="../id443472/index.html">Punya masalah untuk pergi ke cloud? 7 tips tentang cara tidak mengacaukan</a></li>
<li><a href="../id443476/index.html">Bagaimana SimCity menginspirasi seluruh generasi perencana kota</a></li>
<li><a href="../id443478/index.html">Data uji sintetis vs nyata: pro, kontra, jebakan</a></li>
<li><a href="../id443482/index.html">AIOps dalam praktiknya - apa yang bisa Huawei FabricInsight</a></li>
<li><a href="../id443484/index.html">6 pria tak terduga dari Julia</a></li>
<li><a href="../id443486/index.html">ReLEx SMILE: Bagaimana tidak membuat kesalahan dalam perkiraan</a></li>
<li><a href="../id443490/index.html">Mengapa saya membatasi pekerjaan saya pada Debian</a></li>
<li><a href="../id443492/index.html">Gim untuk pecinta dan pakar di Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>