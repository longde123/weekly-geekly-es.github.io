<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚≠êÔ∏è üçâ ‚è¨ Funktionales Denken. Teil 4 üëêüèΩ üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® ‚ôäÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nach einem kurzen Exkurs in die Grundtypen k√∂nnen wir wieder zu den Funktionen zur√ºckkehren. Insbesondere zum zuvor erw√§hnten R√§tsel: Wenn eine mathem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionales Denken. Teil 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/430620/"><p>  Nach einem kurzen Exkurs in die Grundtypen k√∂nnen wir wieder zu den Funktionen zur√ºckkehren.  Insbesondere zum zuvor erw√§hnten R√§tsel: Wenn eine mathematische Funktion nur einen Parameter annehmen kann, wie kann es dann eine Funktion in F # geben, die eine gr√∂√üere Anzahl von Parametern akzeptiert?  Weitere Details unter dem Schnitt! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"><a name="habracut"></a></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dritter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vierter Teil</a></strong> </li></ul><br><p>  Die Antwort ist ganz einfach: Eine Funktion mit mehreren Parametern wird als eine Reihe neuer Funktionen umgeschrieben, von denen jede nur einen Parameter akzeptiert.  Der Compiler f√ºhrt diese Operation automatisch aus und wird zu Ehren von Haskell Curry, einem Mathematiker, der die Entwicklung der funktionalen Programmierung ma√ügeblich beeinflusst hat, als " <strong>Currying</strong> " bezeichnet. </p><br><p>  Um zu sehen, wie das Currying in der Praxis funktioniert, verwenden wir ein einfaches Codebeispiel, das zwei Zahlen druckt: </p><br><pre><code class="plaintext hljs">//   let printTwoParameters xy = printfn "x=%iy=%i" xy</code> </pre> <br><p>  Tats√§chlich schreibt der Compiler es in ungef√§hr der folgenden Form neu: </p><br><pre> <code class="plaintext hljs">//    let printTwoParameters x = //    let subFunction y = printfn "x=%iy=%i" xy //  ,    subFunction //  </code> </pre> <br><p>  Betrachten Sie diesen Prozess genauer: </p><br><ol><li>  Eine Funktion mit dem Namen " <code>printTwoParameters</code> " wird <code>printTwoParameters</code> , akzeptiert jedoch nur <em>einen</em> Parameter: "x". </li><li>  Darin wird eine lokale Funktion erstellt, die auch nur <em>einen</em> Parameter akzeptiert: "y".  Beachten Sie, dass die lokale Funktion den Parameter "x" verwendet, x jedoch nicht als Argument an sie √ºbergeben wird.  "x" befindet sich in einem solchen Bereich, dass eine verschachtelte Funktion es sehen und verwenden kann, ohne es √ºbergeben zu m√ºssen. </li><li>  Schlie√ülich wird die neu erstellte lokale Funktion zur√ºckgegeben. </li><li>  Die zur√ºckgegebene Funktion wird dann auf das Argument "y" angewendet.  Der Parameter "x" ist darin geschlossen, so dass die zur√ºckgegebene Funktion nur den Parameter "y" ben√∂tigt, um ihre Logik zu vervollst√§ndigen. </li></ol><br><p>  Durch das Umschreiben von Funktionen auf diese Weise stellt der Compiler sicher, dass jede Funktion je nach Bedarf nur einen Parameter akzeptiert.  Wenn Sie also " <code>printTwoParameters</code> " verwenden, denken Sie m√∂glicherweise, dass dies eine Funktion mit zwei Parametern ist, aber tats√§chlich wird eine Funktion mit nur einem Parameter verwendet.  Sie k√∂nnen dies √ºberpr√ºfen, indem Sie nur ein Argument anstelle von zwei √ºbergeben: </p><br><pre> <code class="plaintext hljs">//     printTwoParameters 1 //    val it : (int -&gt; unit) = &lt;fun:printTwoParameters@286-3&gt;</code> </pre> <br><p>  Wenn wir es mit einem Argument berechnen, erhalten wir keinen Fehler - die Funktion wird zur√ºckgegeben. </p><br><p>  <code>printTwoParameters</code> passiert also tats√§chlich, wenn <code>printTwoParameters</code> mit zwei Argumenten <code>printTwoParameters</code> wird: </p><br><ul><li>  <code>printTwoParameters</code> wird mit dem ersten Argument (x) <code>printTwoParameters</code> </li><li>  <code>printTwoParameters</code> gibt eine neue Funktion zur√ºck, in der "x" geschlossen ist. </li><li>  Dann wird eine neue Funktion mit dem zweiten Argument (y) aufgerufen. </li></ul><br><p>  Hier ist ein Beispiel f√ºr schrittweise und normale Versionen: </p><br><pre> <code class="plaintext hljs">//   let x = 6 let y = 99 let intermediateFn = printTwoParameters x //  -  // x   let result = intermediateFn y //     let result = (printTwoParameters x) y //   let result = printTwoParameters xy</code> </pre> <br><p>  Hier ist ein weiteres Beispiel: </p><br><pre> <code class="plaintext hljs">//  let addTwoParameters xy = x + y //   let addTwoParameters x = //   ! let subFunction y = x + y //      subFunction //   //       let x = 6 let y = 99 let intermediateFn = addTwoParameters x //  -  // x   let result = intermediateFn y //   let result = addTwoParameters xy</code> </pre> <br><p>  Wiederum ist eine "Funktion mit zwei Parametern" tats√§chlich eine Funktion mit einem Parameter, die eine Zwischenfunktion zur√ºckgibt. </p><br><p>  Aber warte, was ist mit dem Operator <code>+</code> ?  Ist dies eine bin√§re Operation, die zwei Parameter annehmen muss?  Nein, es ist auch Curry, wie andere Funktionen.  Dies ist eine Funktion namens " <code>+</code> ", die einen Parameter verwendet und eine neue Zwischenfunktion zur√ºckgibt, genau wie oben bei <code>addTwoParameters</code> . </p><br><p>  Wenn wir den Ausdruck <code>x+y</code> schreiben, <em>ordnet</em> der Compiler <em>den</em> Code so um, dass das Infix in <code>(+) xy</code> konvertiert wird. Dies <em>ist eine Funktion mit dem Namen <code>+</code> , die zwei Parameter akzeptiert.</em>  Beachten Sie, dass die Funktion ‚Äû+‚Äú Klammern ben√∂tigt, um anzugeben, dass sie als regul√§re Funktion und nicht als Infix-Operator verwendet wird. </p><br><p>  Schlie√ülich wird eine Funktion mit zwei Parametern, <code>+</code> , wie jede andere Funktion mit zwei Parametern behandelt. </p><br><pre> <code class="plaintext hljs">//         let x = 6 let y = 99 let intermediateFn = (+) x //   ""  ""   let result = intermediateFn y //        let result = (+) xy //       let result = x + y</code> </pre> <br><p>  Und ja, dies funktioniert f√ºr alle anderen Operatoren und integrierten Funktionen wie <code>printf</code> . </p><br><pre> <code class="plaintext hljs">//    let result = 3 * 5 //    - let intermediateFn = (*) 3 //  ""  3   let result = intermediateFn 5 //    printfn let result = printfn "x=%iy=%i" 3 5 // printfn   - let intermediateFn = printfn "x=%iy=%i" 3 // "3"   let result = intermediateFn 5</code> </pre> <br><h2>  Curry-Funktionssignaturen </h2><br><p>  Jetzt, da wir wissen, wie Curry-Funktionen funktionieren, ist es interessant zu wissen, wie ihre Signaturen aussehen werden. </p><br><p>  Zur√ºck zum ersten Beispiel, " <code>printTwoParameter</code> ", haben wir gesehen, dass die Funktion ein Argument verwendet und eine Zwischenfunktion zur√ºckgegeben hat.  Die Zwischenfunktion nahm auch ein Argument und gab nichts zur√ºck (d. H. <code>unit</code> ).  Daher war die Zwischenfunktion vom Typ <code>int-&gt;unit</code> .  Mit anderen Worten, domain <code>printTwoParameters</code> ist <code>int</code> und range ist <code>int-&gt;unit</code> .  Wenn wir alles zusammenf√ºgen, sehen wir die endg√ºltige Unterschrift: </p><br><pre> <code class="plaintext hljs">val printTwoParameters : int -&gt; (int -&gt; unit)</code> </pre> <br><p>  Wenn Sie eine explizit Curry-Implementierung berechnen, sehen Sie die Klammern in der Signatur. Wenn Sie jedoch eine normale, implizit Curry-Implementierung berechnen, gibt es keine Klammern: </p><br><pre> <code class="plaintext hljs">val printTwoParameters : int -&gt; int -&gt; unit</code> </pre> <br><p>  Klammern sind optional.  Sie k√∂nnen jedoch im Kopf dargestellt werden, um die Wahrnehmung von Funktionssignaturen zu vereinfachen. </p><br><p>  Und was ist der Unterschied zwischen einer Funktion, die eine Zwischenfunktion zur√ºckgibt, und einer regul√§ren Funktion mit zwei Parametern? </p><br><p>  Hier ist eine Funktion mit einem Parameter, die eine andere Funktion zur√ºckgibt: </p><br><pre> <code class="plaintext hljs">let add1Param x = (+) x // signature is = int -&gt; (int -&gt; int)</code> </pre> <br><p>  Und hier ist eine Funktion mit zwei Parametern, die einen einfachen Wert zur√ºckgibt: </p><br><pre> <code class="plaintext hljs">let add2Params xy = (+) xy // signature is = int -&gt; int -&gt; int</code> </pre> <br><p>  Ihre Signaturen unterscheiden sich geringf√ºgig, aber im praktischen Sinne gibt es keinen gro√üen Unterschied zwischen ihnen, au√üer dass die zweite Funktion automatisch ausgef√ºhrt wird. </p><br><h2>  Funktioniert mit mehr als zwei Parametern </h2><br><p>  Wie funktioniert das Currying f√ºr Funktionen mit mehr als zwei Parametern?  Auf die gleiche Weise: F√ºr jeden Parameter au√üer dem letzten gibt die Funktion eine Zwischenfunktion zur√ºck, die den vorherigen Parameter schlie√üt. </p><br><p>  Betrachten Sie dieses schwierige Beispiel.  Ich habe explizit Parametertypen deklariert, aber die Funktion macht nichts. </p><br><pre> <code class="plaintext hljs">let multiParamFn (p1:int)(p2:bool)(p3:string)(p4:float)= () //   let intermediateFn1 = multiParamFn 42 // multoParamFn  int   (bool -&gt; string -&gt; float -&gt; unit) // intermediateFn1  bool //   (string -&gt; float -&gt; unit) let intermediateFn2 = intermediateFn1 false // intermediateFn2  string //   (float -&gt; unit) let intermediateFn3 = intermediateFn2 "hello" // intermediateFn3 float //     (unit) let finalResult = intermediateFn3 3.141</code> </pre> <br><p>  Unterschrift der gesamten Funktion: </p><br><pre> <code class="plaintext hljs">val multiParamFn : int -&gt; bool -&gt; string -&gt; float -&gt; unit</code> </pre> <br><p>  und Signaturen von Zwischenfunktionen: </p><br><pre> <code class="plaintext hljs">val intermediateFn1 : (bool -&gt; string -&gt; float -&gt; unit) val intermediateFn2 : (string -&gt; float -&gt; unit) val intermediateFn3 : (float -&gt; unit) val finalResult : unit = ()</code> </pre> <br><p>  Die Signatur der Funktion kann Ihnen sagen, wie viele Parameter die Funktion ben√∂tigt: Z√§hlen Sie einfach die Anzahl der Pfeile au√üerhalb der Klammern.  Wenn die Funktion eine andere Funktion akzeptiert oder zur√ºckgibt, werden mehr Pfeile angezeigt, die sich jedoch in Klammern befinden und ignoriert werden k√∂nnen.  Hier einige Beispiele: </p><br><pre> <code class="plaintext hljs">int-&gt;int-&gt;int // 2  int  int string-&gt;bool-&gt;int //   string,  - bool, //  int int-&gt;string-&gt;bool-&gt;unit //   (int,string,bool) //    (unit) (int-&gt;string)-&gt;int //   ,  // ( int  string) //   int (int-&gt;string)-&gt;(int-&gt;bool) //   (int  string) //   (int  bool)</code> </pre> <br><h2>  Schwierigkeiten mit mehreren Parametern </h2><br><p>  Bis Sie die Logik hinter dem Curry verstehen, werden einige unerwartete Ergebnisse erzielt.  Denken Sie daran, dass Sie keine Fehlermeldung erhalten, wenn Sie die Funktion mit weniger Argumenten als erwartet ausf√ºhren.  Stattdessen erhalten Sie eine teilweise angewendete Funktion.  Wenn Sie dann die teilweise angewendete Funktion in dem Kontext verwenden, in dem der Wert erwartet wird, kann der Compiler einen undurchsichtigen Fehler erhalten. </p><br><p>  Stellen Sie sich eine Funktion vor, die auf den ersten Blick harmlos ist: </p><br><pre> <code class="plaintext hljs">//   let printHello() = printfn "hello"</code> </pre> <br><p>  Was wird Ihrer Meinung nach passieren, wenn Sie es wie unten gezeigt aufrufen?  Wird "Hallo" auf der Konsole gedruckt?  Versuchen Sie vor der Ausf√ºhrung zu raten.  Hinweis: Sehen Sie sich die Signatur der Funktion an. </p><br><pre> <code class="plaintext hljs">//   printHello</code> </pre> <br><p>  Entgegen den Erwartungen wird es <em>keinen</em> Anruf geben.  Die urspr√ºngliche Funktion erwartet <code>unit</code> als ein Argument, das nicht √ºbergeben wurde.  Daher wurde eine teilweise angewendete Funktion erhalten (in diesem Fall ohne Argumente). </p><br><p>  Was ist mit diesem Fall?  Wird es kompiliert? </p><br><pre> <code class="plaintext hljs">let addXY xy = printfn "x=%iy=%i" x x + y</code> </pre> <br><p>  Wenn Sie es ausf√ºhren, beschwert sich der Compiler √ºber die Zeile mit <code>printfn</code> . </p><br><pre> <code class="plaintext hljs">printfn "x=%iy=%i" x //^^^^^^^^^^^^^^^^^^^^^ //warning FS0193: This expression is a function value, ie is missing //arguments. Its type is ^a -&gt; unit.</code> </pre> <br><p>  Wenn Sie kein Verst√§ndnis f√ºr Curry haben, kann diese Nachricht sehr kryptisch sein.  Tatsache ist, dass alle Ausdr√ºcke, die separat ausgewertet werden (dh nicht als R√ºckgabewert verwendet werden oder mittels "let" an etwas gebunden sind) <em>,</em> im <code>unit</code> ausgewertet werden <em>m√ºssen</em> .  In diesem Fall wird es <em>nicht</em> im <code>unit</code> berechnet, sondern gibt eine Funktion zur√ºck.  Dies ist ein langer Weg zu sagen, dass <code>printfn</code> ein Argument fehlt. </p><br><p>  In den meisten F√§llen treten solche Fehler bei der Interaktion mit einer Bibliothek aus der .NET-Welt auf.  Beispielsweise muss die <code>Readline</code> Methode der <code>TextReader</code> Klasse einen <code>unit</code> annehmen.  Sie k√∂nnen dies oft vergessen und keine Klammern setzen. In diesem Fall k√∂nnen Sie zum Zeitpunkt des ‚ÄûAufrufs‚Äú keinen Compilerfehler erhalten. Dieser wird jedoch angezeigt, wenn Sie versuchen, das Ergebnis als Zeichenfolge zu interpretieren. </p><br><pre> <code class="plaintext hljs">let reader = new System.IO.StringReader("hello"); let line1 = reader.ReadLine // ,    printfn "The line is %s" line1 //    // ==&gt; error FS0001: This expression was expected to have // type string but here has type unit -&gt; string let line2 = reader.ReadLine() // printfn "The line is %s" line2 //  </code> </pre> <br><p>  Im obigen Code ist <code>line1</code> nur ein Zeiger oder Delegat an die <code>Readline</code> Methode, nicht wie erwartet eine Zeichenfolge.  Wenn Sie <code>()</code> in <code>reader.ReadLine()</code> wird die Funktion tats√§chlich aufgerufen. </p><br><h2>  Zu viele Optionen </h2><br><p>  Sie k√∂nnen gleicherma√üen kryptische Nachrichten erhalten, wenn Sie zu viele Parameter an eine Funktion √ºbergeben.  Einige Beispiele f√ºr die √úbergabe zu vieler Parameter an <code>printf</code> : </p><br><pre> <code class="plaintext hljs">printfn "hello" 42 // ==&gt; error FS0001: This expression was expected to have // type 'a -&gt; 'b but here has type unit printfn "hello %i" 42 43 // ==&gt; Error FS0001: Type mismatch. Expecting a 'a -&gt; 'b -&gt; 'c // but given a 'a -&gt; unit printfn "hello %i %i" 42 43 44 // ==&gt; Error FS0001: Type mismatch. Expecting a 'a-&gt;'b-&gt;'c-&gt;'d // but given a 'a -&gt; 'b -&gt; unit</code> </pre> <br><p>  Im letzteren Fall meldet der Compiler beispielsweise, dass eine Formatzeichenfolge mit drei Parametern erwartet wird (Signatur <code>'a -&gt; 'b -&gt; 'c -&gt; 'd</code> hat drei Parameter), aber stattdessen wird eine Zeichenfolge mit zwei Parametern empfangen (f√ºr Signatur <code>'a -&gt; 'b -&gt; unit</code> zwei Parameter). </p><br><p>  In den F√§llen, in denen <code>printf</code> nicht verwendet wird, bedeutet das √úbergeben einer gro√üen Anzahl von Parametern h√§ufig, dass in einer bestimmten Phase der Berechnung ein einfacher Wert erhalten wurde, f√ºr den der Parameter ausprobiert wird.  Der Compiler wird erneut senden, dass ein einfacher Wert keine Funktion ist. </p><br><pre> <code class="plaintext hljs">let add1 x = x + 1 let x = add1 2 3 // ==&gt; error FS0003: This value is not a function // and cannot be applied</code> </pre> <br><p>  Wenn wir den allgemeinen Aufruf wie zuvor in eine Reihe expliziter Zwischenfunktionen aufteilen, k√∂nnen wir sehen, was genau falsch l√§uft. </p><br><pre> <code class="plaintext hljs">let add1 x = x + 1 let intermediateFn = add1 2 //   let x = intermediateFn 3 //intermediateFn  ! // ==&gt; error FS0003: This value is not a function // and cannot be applied</code> </pre> <br><h1>  Zus√§tzliche Ressourcen </h1><br><p>  Es gibt viele Tutorials f√ºr F #, einschlie√ülich Materialien f√ºr diejenigen, die mit C # oder Java-Erfahrung kommen.  Die folgenden Links k√∂nnen hilfreich sein, wenn Sie tiefer in F # einsteigen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Anleitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # f√ºr Spa√ü und Profit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lerne X in Y Minuten: F #</a> </li></ul><br><p>  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> auch verschiedene andere M√∂glichkeiten beschrieben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, um mit dem Lernen von F # zu beginnen</a> . </p><br><p>  Schlie√ülich ist die F # Community sehr anf√§ngerfreundlich.  Bei Slack gibt es einen sehr aktiven Chat, der von der F # Software Foundation unterst√ºtzt wird, mit Anf√§ngerr√§umen, an denen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">frei teilnehmen k√∂nnen</a> .  Wir empfehlen Ihnen dringend, dies zu tun! </p><br><p>  Vergessen Sie nicht, die Seite der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community F #</a> zu besuchen!  Wenn Sie Fragen zum Erlernen einer Sprache haben, diskutieren wir diese gerne in Chatrooms: </p><br><ul><li>  Raum <code>#ru_general</code> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack Chat</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Telegramm chatten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chatte in gitter</a> </li></ul><br><h2>  √úber √úbersetzungsautoren </h2><br><p>  √úbersetzt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  √úbersetzungs- und redaktionelle √Ñnderungen wurden durch die Bem√ºhungen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community von F # -Entwicklern vorgenommen</a> .  Wir danken auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@schvepsss</em></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@shwars</em></a> f√ºr die Vorbereitung dieses Artikels zur Ver√∂ffentlichung. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430620/">https://habr.com/ru/post/de430620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430610/index.html">So entfernen Sie Ihre elektronischen Ger√§te sicher</a></li>
<li><a href="../de430612/index.html">Wie in den 1980er Jahren Menschen Spiele aus dem Radio heruntergeladen haben</a></li>
<li><a href="../de430614/index.html">Schwarzer Freitag 2018 bei Madrobots.</a></li>
<li><a href="../de430616/index.html">Seminar "Testen und √úberwachen", 27. November, Moskau</a></li>
<li><a href="../de430618/index.html">Vue.js SSR & Mobile Safari: Ein nicht offensichtliches Problem mit zu intelligenter Software</a></li>
<li><a href="../de430622/index.html">Funktionales Denken. Teil 5</a></li>
<li><a href="../de430626/index.html">Ank√ºndigung des Moscow GraphQL Meetup</a></li>
<li><a href="../de430628/index.html">Fortune-Algorithmus, Implementierungsdetails</a></li>
<li><a href="../de430630/index.html">Vergleich der Two Balls Sneakers aus den 60ern und 2016. Von der Sohle bis zu den Schn√ºrsenkeln</a></li>
<li><a href="../de430632/index.html">Service in der Wirtschaft: Wie ausl√§ndische Einzelh√§ndler schl√ºsselfertige Gesch√§fte in Russland er√∂ffnen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>