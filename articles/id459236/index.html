<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽 💆🏾 🧗🏼 SQL: solusi tugas waktu kerja 🌗 ✌🏼 👢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Radio SQL kembali mengudara! Hari ini kami memiliki solusi untuk masalah yang kami transmisikan pada siaran sebelumnya, dan berjanji untuk kelua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL: solusi tugas waktu kerja</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459236/"><p>  Halo, Radio SQL kembali mengudara!  Hari ini kami memiliki solusi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah</a> yang kami transmisikan pada siaran sebelumnya, dan berjanji untuk keluar nanti.  Dan ini waktu berikutnya telah datang. </p><br><p>  Tugas itu membangkitkan respons yang hidup di antara humanoids galaksi Bima Sakti (dan tidak mengherankan, dengan perbudakan tenaga kerja mereka, yang masih mereka hormati demi manfaat peradaban).  Sayangnya, di planet ketiga, peluncuran observatorium ruang Spectrum-RG ditunda pada akhir Juli 2019, RC (kronologi lokal), dengan bantuan yang direncanakan untuk menyiarkan program ini.  Saya harus mencari rute transmisi alternatif, yang menyebabkan sedikit keterlambatan dalam sinyal.  Tapi semuanya baik-baik saja, itu berakhir dengan baik. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/a6/z4/rca6z4cduxlps2le_c4l_3rwnrg.png"></div><br><p>  Saya harus mengatakan segera bahwa tidak akan ada keajaiban dalam analisis tugas, tidak perlu mencari wahyu di sini atau menunggu beberapa implementasi yang sangat efektif (atau terutama beberapa dalam arti lain).  Ini hanya tugas parsing.  Di dalamnya, mereka yang tidak tahu cara mendekati solusi dari masalah seperti itu akan dapat melihat bagaimana menyelesaikannya.  Apalagi, tidak ada yang mengerikan di sini. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Biarkan saya mengingatkan Anda kondisinya.</b> <div class="spoiler_text"><p>  Ada beberapa interval waktu yang ditentukan oleh tanggal-waktu awal dan akhir (contoh dalam sintaks PostgreSQL): </p><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:07:12'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) )</code> </pre> <br><p>  Diperlukan dalam satu query SQL (c) untuk menghitung durasi setiap interval dalam jam kerja.  Kami percaya bahwa kami bekerja pada hari kerja dari Senin hingga Jumat, jam kerja selalu dari 10:00 hingga 19:00.  Selain itu, sesuai dengan kalender produksi Federasi Rusia, ada sejumlah hari libur resmi yang bukan hari kerja, dan beberapa hari libur, sebaliknya, adalah hari kerja karena penundaan hari libur yang sama.  Pemendekan hari pra-liburan tidak diperlukan, kami menganggapnya lengkap.  Karena liburan bervariasi dari tahun ke tahun, yaitu, ditetapkan oleh daftar eksplisit, kami akan membatasi diri hanya untuk tanggal dari 2018 dan 2019.  Saya yakin, jika perlu, solusinya dapat dengan mudah ditambahkan. </p><br><p>  Penting untuk menambahkan satu kolom dengan durasi dalam jam kerja ke periode awal dari <em>periode</em> .  Inilah hasilnya: </p><br><pre> <code class="pgsql hljs"> id | start_time | stop_time | work_hrs <span class="hljs-comment"><span class="hljs-comment">----+---------------------+---------------------+---------- 1 | 2019-03-29 07:00:00 | 2019-04-08 14:00:00 | 58:00:00 2 | 2019-04-10 07:00:00 | 2019-04-10 20:00:00 | 09:00:00 3 | 2019-04-11 12:00:00 | 2019-04-12 16:07:12 | 13:07:12 4 | 2018-12-28 12:00:00 | 2019-01-16 16:00:00 | 67:00:00</span></span></code> </pre> <br><p>  Kami tidak memeriksa data awal untuk kebenaran, kami selalu mempertimbangkan <em>start_time &lt;= stop_time</em> . </p><br><p>  Akhir dari kondisi, yang asli ada di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/en/company/postgrespro/blog/448368/</a> . </p></div></div><br><p>  Tugas ini memberikan sedikit perhatian pada kenyataan bahwa saya secara sadar telah memberikan setengah kondisi yang baik dalam bentuk deskriptif (seperti yang biasanya terjadi dalam kehidupan nyata), meninggalkan pada kebijaksanaan implementasi teknis bagaimana jadwal harus ditetapkan.  Di satu sisi, ini memerlukan beberapa keterampilan berpikir arsitektur.  Dan di sisi lain, format yang sudah jadi dari jadwal ini akan mendorong beberapa penggunaan template dari jadwal ini.  Dan jika Anda menghilangkan, maka pikiran dan fantasi akan bekerja lebih penuh.  Penerimaan terbayar sepenuhnya, memungkinkan saya juga menemukan pendekatan menarik dalam solusi yang dipublikasikan. </p><br><p>  Jadi, untuk menyelesaikan masalah asli dengan cara ini, dua subtugas perlu dipecahkan: </p><br><ol><li>  Tentukan cara paling padat mengatur jadwal kerja, dan bahkan agar nyaman digunakan untuk solusi. </li><li>  Sebenarnya menghitung durasi setiap periode sumber dalam jam kerja sesuai dengan jadwal kerja dari subtugas sebelumnya. </li></ol><br><p>  Dan lebih baik memulai dengan yang kedua, untuk memahami dalam bentuk apa kita perlu menyelesaikan yang pertama.  Kemudian selesaikan yang pertama dan kembali lagi ke yang kedua untuk mendapatkan hasil akhir. <br>  Kami akan mengumpulkan hasilnya secara bertahap, menggunakan sintaksis CTE, yang memungkinkan kami untuk menempatkan semua sampel data yang diperlukan ke dalam subquery bernama terpisah, dan kemudian menautkan semuanya. </p><br><p>  Baiklah, ayo pergi. </p><br><h3 id="poschitat-dlitelnost-v-rabochih-chasah">  Hitung durasi dalam jam kerja </h3><br><p>  Untuk menghitung durasi masing-masing periode dalam jam kerja di dahi, Anda harus melewati periode awal (warna hijau pada diagram) dengan interval yang menggambarkan waktu kerja (oranye).  Interval jam kerja adalah Senin 10: 00-19: 00, Selasa 10: 00-19: 00 dan seterusnya.  Hasilnya ditunjukkan dengan warna biru: </p><br><p><img src="https://habrastorage.org/webt/o4/yh/6_/o4yh6_ca7loarlvtghe572p6zdo.png" alt="gambar"></p><br><p>  Ngomong-ngomong, agar tidak bingung, saya akan terus menyebut periode awal sebagai periode awal, dan saya akan memanggil interval jam kerja. </p><br><p>  Prosedur harus diulang untuk setiap periode awal.  Periode awal untuk kita sudah diatur di <em>tab periode (start_time, stop_time)</em> , kami akan mewakili jam kerja dalam bentuk tabel, katakanlah, <em>jadwal (strat_time, stop_time)</em> , di mana setiap hari kerja hadir.  Hasilnya adalah produk Cartesian lengkap dari semua periode awal dan interval waktu kerja. </p><br><p>  Persimpangan dapat dihitung dengan cara klasik, setelah mempertimbangkan semua opsi yang memungkinkan untuk memotong interval - kami memotong hijau dengan oranye, hasilnya biru: </p><br><p><img src="https://habrastorage.org/webt/fx/aq/wo/fxaqwo7uud0kyzismeqn6cqeap0.png" alt="gambar"></p><br><p>  dan mengambil dalam setiap kasus nilai yang diinginkan untuk awal dan akhir hasil: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.start_time, s.stop_time <span class="hljs-comment"><span class="hljs-comment">-- case #1 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &gt; s.stop_time union all select p.start_time, s.stop_time -- case #2 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &gt; s.stop_time and p.start_time &lt; s.stop_time union all select s.start_time, p.stop_time -- case #3 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &lt; s.stop_time and p.stop_time &gt; s.start_time union all select p.start_time, p.stop_time -- case #4 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &lt; s.stop_time</span></span></code> </pre> <br><p>  Karena untuk setiap persimpangan, kita hanya dapat memiliki satu dari empat opsi, semuanya digabungkan menjadi satu permintaan menggunakan <em>gabungan semua</em> . </p><br><p>  Anda dapat melakukan sebaliknya dengan menggunakan <em>tipe</em> rentang <em>tsrange yang</em> tersedia di PostgreSQL dan operasi persimpangan sudah tersedia untuk itu: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s</code> </pre> <br><p>  Setuju bahwa jadi - uh - sedikit lebih mudah.  Secara umum, ada banyak hal-hal kecil yang nyaman di PostgreSQL, jadi menulis pertanyaan tentang itu sangat bagus. </p><br><h3 id="sgenerirovat-kalendar">  Hasilkan kalender </h3><br><p>  Sekarang kembali ke sub-tugas dengan jadwal jam kerja. </p><br><p>  Kita perlu mendapatkan jadwal kerja dalam bentuk interval waktu kerja dari 10:00 hingga 19:00 untuk setiap hari kerja, seperti <em>jadwal (start_time, stop_time)</em> .  Seperti yang kita pahami, akan lebih mudah untuk menyelesaikan masalah kita.  Dalam kehidupan nyata, jadwal seperti itu harus ditetapkan, untuk dua tahun hanya sekitar 500 catatan, untuk tujuan praktis akan diperlukan untuk mengatur bahkan sepuluh tahun - ini adalah beberapa setengah ribu catatan, sampah nyata untuk database modern.  Tetapi kami memiliki masalah yang akan diselesaikan dalam satu permintaan, dan mendaftar seluruh tabel di dalamnya tidak terlalu praktis.  Mari kita coba implementasikan dengan lebih kompak. </p><br><p>  Bagaimanapun, kami membutuhkan hari libur untuk menghapusnya dari jadwal dasar, dan di sini hanya daftar yang cocok: </p><br><pre> <code class="pgsql hljs"> dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) )</span></span></code> </pre> <br><p>  dan hari kerja tambahan yang akan ditambahkan: </p><br><pre> <code class="pgsql hljs"> dates_include(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-comment"><span class="hljs-comment">--  2018,  2019  ('2018-04-28'::date), ('2018-06-09'::date), ('2018-12-29'::date) )</span></span></code> </pre> <br><p>  Urutan hari kerja selama dua tahun dapat dihasilkan oleh fungsi <em>generate_series () yang</em> khusus dan sangat cocok, segera melemparkan hari Sabtu dan Minggu di sepanjang jalan: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--    </span></span></code> </pre> <br><p>  Kami mendapatkan hari kerja dengan menghubungkan semuanya: kami menghasilkan urutan semua hari kerja dalam dua tahun, menambahkan hari kerja tambahan dari <em>tanggal_sertakan</em> dan menghapus semua hari tambahan dari <em>tanggal_sertakan</em> : </p><br><pre> <code class="pgsql hljs"> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--     union select d from dates_include --     except select d from dates_exclude --     )</span></span></code> </pre> <br><p>  Dan sekarang kita mendapatkan interval waktu yang kita butuhkan: </p><br><pre> <code class="pgsql hljs"> schedule(start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>, d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base )</code> </pre> <br><p>  Jadi, kami mendapat jadwalnya. </p><br><h3 id="sobiraem-vsyo-vmeste">  Menyatukan semuanya </h3><br><p>  Sekarang kita akan mendapatkan persimpangan: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time)</code> </pre> <br><p>  Perhatikan kondisi bergabung <em>ON</em> , itu tidak cocok dengan dua catatan yang sesuai dari tabel bergabung, tidak ada korespondensi seperti itu, tetapi beberapa optimasi diperkenalkan yang memotong interval waktu kerja dimana periode awal kami tidak berpotongan.  Ini dilakukan menggunakan operator <em>&amp;&amp;</em> , yang memeriksa persimpangan interval <em>tsrange</em> .  Ini menghilangkan banyak persimpangan kosong agar tidak menghalangi mata, tetapi, di sisi lain, menghilangkan informasi tentang periode-periode awal yang jatuh seluruhnya dari jam kerja.  Jadi kami mengagumi bahwa pendekatan kami berhasil, dan menulis ulang permintaan sebagai berikut: </p><br><pre> <code class="pgsql hljs"> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p , schedule s ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , sum(upper(wrkh)-lower(wrkh)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  Dalam <em>period_wrk kami</em> mendekomposisi setiap periode sumber ke dalam interval kerja, dan kemudian kami mempertimbangkan durasi totalnya.  Hasilnya adalah produk Cartesian lengkap dari semua periode dan interval, tetapi tidak satu periode pun hilang. </p><br><p>  Semuanya, hasilnya diterima.  Saya tidak suka nilai <em>NULL</em> untuk interval kosong, biarkan kueri menunjukkan interval panjang nol lebih baik.  Bungkus jumlahnya dalam <em>gabungan ()</em> : </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , coalesce(sum(upper(wrkh)-lower(wrkh)), <span class="hljs-string"><span class="hljs-string">'0 sec'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  Semuanya memberikan hasil akhir: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) ), dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) ), dates_include(start_time, stop_time) as ( values --  2018,  2019  ('2018-04-28 10:00:00'::timestamp, '2018-04-28 19:00:00'::timestamp), ('2018-06-09 10:00:00'::timestamp, '2018-06-09 19:00:00'::timestamp), ('2018-12-29 10:00:00'::timestamp, '2018-12-29 19:00:00'::timestamp) ) ), schedule_base(start_time, stop_time) as ( select d::timestamp + '10:00:00', d::timestamp + '19:00:00' from generate_series( (select min(start_time) from periods)::date::timestamp , (select max(stop_time) from periods)::date::timestamp , '1 day'::interval ) as days(d) where extract(dow from d) not in (0,6) ), schedule as ( select * from schedule_base where start_time::date not in (select d from dates_exclude) union select * from dates_include ), periods_wrk as ( select p.* , tsrange(p.start_time, p.stop_time) * tsrange(s.start_time, s.stop_time) as wrkh from periods p , schedule s ) select id, start_time, stop_time , sum(coalesce(upper(wrkh)-lower(wrkh), '0 sec'::interval)) from periods_wrk group by id, start_time, stop_time</span></span></code> </pre> <br><p>  Hore! .. Ini bisa selesai, tetapi demi kelengkapan kami akan mempertimbangkan beberapa topik yang lebih terkait. </p><br><h3 id="dalneyshee-razvitie-temy">  Pengembangan topik selanjutnya </h3><br><p>  Hari pra-liburan singkat, istirahat makan siang, jadwal berbeda untuk hari yang berbeda dalam seminggu ... Pada prinsipnya, semuanya jelas, Anda perlu memperbaiki definisi <em>jadwal</em> , cukup berikan beberapa contoh. </p><br><p>  Ini adalah bagaimana Anda dapat mengatur waktu mulai dan berakhir yang berbeda untuk hari kerja, tergantung pada hari dalam seminggu: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-comment"><span class="hljs-comment">--  when 2 then '11:00:00'::time --  when 3 then '11:00:00'::time --  --        else '10:00:00'::time end , d + case extract(dow from d) --   19   when 5 then '14:00:00'::time --  else '19:00:00'::time end from schedule_base</span></span></code> </pre> <br><p>  Jika Anda perlu mempertimbangkan istirahat makan siang dari pukul 13: 00-14: 00, maka alih-alih satu interval per hari, lakukan dua: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'13:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base</code> </pre> <br><p>  Baik dan sebagainya. </p><br><h3 id="proizvoditelnost">  Performa </h3><br><p>  Saya akan mengatakan beberapa kata tentang kinerja, karena selalu ada pertanyaan tentangnya.  Saya tidak akan mengunyah banyak, ini adalah bagian dengan tanda bintang. </p><br><p>  Secara umum, optimasi prematur adalah kejahatan.  Menurut pengamatan saya selama bertahun-tahun, keterbacaan kode adalah keuntungan terpentingnya.  Jika kode dibaca dengan baik, maka lebih mudah untuk memelihara dan mengembangkannya.  Kode yang dapat dibaca dengan baik secara implisit membutuhkan arsitektur solusi yang baik, komentar yang tepat, dan nama variabel yang baik, kekompakan tanpa mengorbankan keterbacaan, dll. Yaitu, semua kode itu disebut baik untuk. </p><br><p>  Oleh karena itu, permintaan selalu ditulis sebagai dapat dibaca, dan kami mulai mengoptimalkan jika dan hanya jika ternyata kinerjanya tidak mencukupi.  Selain itu, kami akan mengoptimalkannya secara tepat di mana kinerja tidak mencukupi dan tepat sejauh itu menjadi cukup.  Jika Anda menghargai waktu Anda sendiri, dan Anda memiliki sesuatu untuk dilakukan. </p><br><p>  Tetapi tidak melakukan pekerjaan yang tidak perlu dalam permintaan itu benar, Anda harus selalu mencoba untuk mempertimbangkan ini. </p><br><p>  Berdasarkan hal ini, kami akan segera menyertakan satu optimasi dalam kueri - biarkan setiap periode sumber hanya bersinggungan dengan interval waktu kerja yang memiliki poin umum (alih-alih kondisi klasik panjang pada batas rentang, lebih mudah menggunakan operator built <em>&amp;</em> in untuk tipe <em>tsrange</em> ).  Optimalisasi ini sudah muncul dalam permintaan, tetapi telah menyebabkan fakta bahwa periode awal yang benar-benar keluar dari jam kerja hilang dari hasil. </p><br><p>  Bawa kembali pengoptimalan ini.  Untuk melakukan ini, gunakan <em>LEFT JOIN</em> , yang akan menyimpan semua catatan dari tabel <em>periode</em> .  Sekarang subquery <em>period_wrk</em> akan terlihat seperti ini: </p><br><pre> <code class="pgsql hljs">, periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">left join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time))</code> </pre> <br><p>  Analisis permintaan menunjukkan bahwa waktu pada data uji telah berkurang sekitar setengahnya.  Karena runtime tergantung pada apa yang dilakukan server pada saat yang sama, saya mengambil beberapa pengukuran dan memberikan beberapa hasil "khas", bukan yang terbesar, bukan yang terkecil, dari tengah. </p><br><p>  Permintaan lama: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=334.42..338.39 rows=397 width=36) (actual time=10.724..10.731 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Baru: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=186.37..186.57 rows=20 width=36) (actual time=5.431..5.440 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Tetapi yang paling penting adalah bahwa permintaan semacam itu juga akan skala lebih baik, membutuhkan lebih sedikit sumber daya server, karena produk Cartesian penuh tumbuh sangat cepat. </p><br><p>  Dan dalam hal ini saya akan berhenti dengan optimasi.  Ketika saya memecahkan masalah ini untuk diri saya sendiri, saya memiliki kinerja yang cukup bahkan dalam bentuk yang jauh lebih buruk dari permintaan ini, tetapi sebenarnya tidak perlu untuk mengoptimalkan.  Untuk mendapatkan laporan data saya sekali dalam seperempat, saya bisa menunggu sepuluh detik ekstra.  Jam tambahan yang dihabiskan untuk optimasi dalam kondisi seperti itu tidak akan pernah berhasil. </p><br><p>  Tetapi ternyata tidak menarik, mari kita masih berpikir tentang bagaimana peristiwa dapat berkembang jika optimasi dalam hal waktu eksekusi benar-benar diperlukan.  Misalnya, kami ingin memantau parameter ini secara real time untuk setiap catatan kami di database, yaitu, untuk setiap bersin permintaan seperti itu akan dipanggil.  Ya, atau buat alasan Anda sendiri, mengapa Anda perlu mengoptimalkan. </p><br><p>  Hal pertama yang terlintas dalam pikiran adalah menghitung satu kali dan menempatkan tabel dalam tabel dengan interval kerja.  Mungkin ada kontraindikasi: jika database tidak dapat diubah, atau kesulitan diharapkan dengan dukungan data yang relevan dalam tabel seperti itu.  Maka Anda harus meninggalkan generasi waktu kerja "on the fly" dalam permintaan itu sendiri, karena ini bukan subquery yang sangat berat. </p><br><p>  Pendekatan berikutnya dan yang paling kuat (tetapi tidak selalu berlaku) adalah optimasi algoritmik.  Beberapa pendekatan ini telah disajikan dalam komentar pada artikel dengan kondisi masalah. </p><br><p>  Saya paling suka yang ini.  Jika Anda membuat tabel dengan semua (tidak hanya berfungsi) kalender dan menghitung total kumulatif berapa jam kerja setiap hari dari "penciptaan dunia" tertentu telah berlalu, maka Anda bisa mendapatkan jumlah jam kerja antara dua tanggal dengan satu operasi pengurangan.  Tinggal menghitung jam kerja dengan benar untuk hari pertama dan terakhir - dan Anda selesai.  Inilah yang saya dapatkan dalam pendekatan ini: </p><br><pre> <code class="pgsql hljs"> schedule_base(d, is_working) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">all</span></span>(<span class="hljs-string"><span class="hljs-string">'{2019-01-01,2019-01-02,2019-01-03,2019-01-04,2019-01-07,2019-01-08,2019-03-08,2019-05-01,2019-05-02,2019-05-03,2019-05-09,2019-05-10,2019-06-12,2019-11-04,2018-01-01,2018-01-02,2018-01-03,2018-01-04,2018-01-05,2018-01-08,2018-02-23,2018-03-08,2018-03-09,2018-04-30,2018-05-01,2018-05-02,2018-05-09,2018-06-11,2018-06-12,2018-11-05,2018-12-31}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>(<span class="hljs-string"><span class="hljs-string">'{2018-04-28,2018-06-09,2018-12-29}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> d &lt; <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span> ), schedule(d, is_working, work_hours) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d, is_working , sum(is_working*<span class="hljs-string"><span class="hljs-string">'9 hours'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unbounded</span></span> <span class="hljs-keyword"><span class="hljs-keyword">preceding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , s2.work_hours - s1.work_hours + (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.start_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s1.is_working - (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.stop_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s2.is_working <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s1, schedule s2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> s1.d = p.start_time::<span class="hljs-type"><span class="hljs-type">date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> s2.d = p.stop_time::<span class="hljs-type"><span class="hljs-type">date</span></span></code> </pre> <br><p>  Saya akan menjelaskan secara singkat apa yang terjadi di sini.  Dalam subquery <em>schedule_base</em> , kami membuat semua hari kalender selama dua tahun dan setiap hari kami menentukan tanda apakah hari kerja (= 1) atau tidak (= 0).  Lebih jauh, dalam subquery <em>jadwal</em> , kami menganggap fungsi jendela sebagai jumlah total jam kerja kumulatif dari 2018-01-01.  Adalah mungkin untuk melakukan semuanya dalam satu subquery, tetapi akan menjadi lebih rumit, yang akan mengganggu keterbacaan.  Kemudian, dalam permintaan utama, kami mempertimbangkan perbedaan antara jumlah jam kerja pada akhir dan awal periode dan, agak terlalu lambat, memperhitungkan jam kerja untuk hari pertama dan terakhir periode tersebut.  Floriditas dikaitkan dengan pengalihan waktu sebelum awal hari kerja ke awal, dan waktu setelah akhir hari kerja hingga akhir.  Selain itu, jika bagian dari permintaan dengan <em>shedule_base</em> dan <em>jadwal</em> dihapus ke dalam tabel pra-perhitungan yang terpisah (seperti yang disarankan sebelumnya), permintaan tersebut akan berubah menjadi sangat sepele. </p><br><p>  Mari kita bandingkan eksekusi pada sampel yang lebih besar untuk menunjukkan lebih baik optimasi dilakukan, untuk empat periode dari kondisi tugas lebih banyak waktu dihabiskan untuk menghasilkan jadwal kerja. </p><br><p>  Saya mengambil sekitar 3 ribu periode.  Saya hanya akan memberikan baris ringkasan teratas dalam EXPLAIN, nilai-nilai tipikal adalah sebagai berikut. </p><br><p>  Opsi asli: </p><br><pre> <code class="pgsql hljs">GroupAggregate (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">265790.95</span></span>.<span class="hljs-number"><span class="hljs-number">.296098</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">144320</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">656.654</span></span>.<span class="hljs-number"><span class="hljs-number">.894</span></span><span class="hljs-number"><span class="hljs-number">.383</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  Dioptimalkan: </p><br><pre> <code class="pgsql hljs">Hash <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">45.01</span></span>.<span class="hljs-number"><span class="hljs-number">.127</span></span><span class="hljs-number"><span class="hljs-number">.52</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">70</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">1.620</span></span>.<span class="hljs-number"><span class="hljs-number">.5</span></span><span class="hljs-number"><span class="hljs-number">.385</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  Keuntungan waktu adalah beberapa perintah yang besarnya.  Dengan peningkatan jumlah periode dan lamanya dalam beberapa tahun, kesenjangan hanya akan melebar. </p><br><p>  Segalanya tampak baik-baik saja, tetapi mengapa, setelah melakukan optimasi seperti itu, saya meninggalkan versi pertama dari permintaan itu sendiri sampai kinerjanya cukup?  Ya, karena versi yang dioptimalkan tidak diragukan lagi lebih cepat, tetapi membutuhkan lebih banyak waktu untuk memahami cara kerjanya, yaitu keterbacaan semakin memburuk.  Artinya, saat berikutnya saya harus menulis ulang permintaan dalam kondisi saya yang berubah, saya (atau tidak saya) harus menghabiskan lebih banyak waktu untuk memahami bagaimana permintaan itu bekerja. </p><br><p>  Itu saja untuk hari ini, jaga agar tentakelnya tetap hangat, dan saya ucapkan selamat tinggal kepada Anda sampai Radio SQL rilis berikutnya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459236/">https://habr.com/ru/post/id459236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459224/index.html">Dari makelar ke pengembang game 2. "Operasi: Android"</a></li>
<li><a href="../id459226/index.html">"Fast-PoE dan Perpetual-PoE - apakah ini standar baru atau tidak?"</a></li>
<li><a href="../id459230/index.html">Perjalanan ke pusat panggilan dan Product Backlog melalui mata pengembang</a></li>
<li><a href="../id459232/index.html">Kelilingi, gigit, potong: kompetisi Mini AI Cup # 4 yang baru</a></li>
<li><a href="../id459234/index.html">Smem - Laporan alokasi memori antara proses dan pengguna di Linux</a></li>
<li><a href="../id459238/index.html">Dari fungsi matematika ajaib - satu solusi untuk mengatur semuanya</a></li>
<li><a href="../id459240/index.html">10 tahun di IT yang didiagnosis menderita skizofrenia, kiat bertahan hidup</a></li>
<li><a href="../id459242/index.html">Mengikuti konferensi T + Conf 2019</a></li>
<li><a href="../id459244/index.html">Catatan manajer produk: perilaku pengguna pada halaman game di app store. Berapa lama untuk mengunduh game</a></li>
<li><a href="../id459246/index.html">Mengapa konversi situs menurun? Contoh 60 desain dan kesalahan penggunaan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>