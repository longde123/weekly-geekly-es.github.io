<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏼 👦 💜 Collecter le paquet de rêves avec Webpack 🎓 🙍🏼 ♾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les applications, sites et autres ressources JS deviennent de plus en plus complexes et les outils de construction sont la réalité du développement We...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Collecter le paquet de rêves avec Webpack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433324/">  Les applications, sites et autres ressources JS deviennent de plus en plus complexes et les outils de construction sont la réalité du développement Web.  Les bundlers aident à emballer, compiler et organiser les bibliothèques.  Webpack est l'un des outils open source puissants et flexibles qui peuvent être parfaitement personnalisés pour créer l'application client. <br><br>  Maxim Sosnov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">crazymax11</a> ) - Lead frontend dans N1.RU a introduit Webpack dans plusieurs grands projets qui avaient auparavant leur propre build personnalisé, et y a contribué plusieurs projets.  Maxim sait comment créer un bundle de rêve avec Webpack, le faire rapidement et le configurer pour que la configuration reste propre, prise en charge et modulaire. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4ClK_0fxsVM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  L'interprétation est différente du rapport - c'est une version grandement améliorée des proflinks.  Tout au long de la transcription, les oeufs de Pâques sont éparpillés sur des articles, des plugins, des minificateurs, des options, des transpilers et des preuves des mots du locuteur, des liens vers lesquels il est tout simplement impossible d'insérer un discours.  Si vous collectez tout, le niveau bonus dans Webpack s'ouvre :-) <br><a name="habracut"></a><br><h2>  Intégration de Webpack dans un projet typique </h2><br>  Habituellement, la procédure d'implémentation est la suivante: le développeur a lu quelque part un article sur Webpack, décide de le connecter, commence à le construire, d'une manière ou d'une autre, cela commence, tout démarre et pendant un certain temps, webpack-config fonctionne - pendant six mois, un an, deux.  Localement, tout va bien - le soleil, l'arc-en-ciel et les papillons.  Et puis les vrais utilisateurs viennent: <br><br>  <em>- À partir d'appareils mobiles, votre site ne se charge pas.</em> <em><br></em>  <em>- Tout fonctionne pour nous.</em>  <em>Localement, tout va bien!</em> <br><br>  Au cas où, le développeur va tout profiler et voit que pour les appareils mobiles, le <strong>bundle pèse 7 Mo et prend 30 secondes pour se charger</strong> .  Cela ne convient à personne et le développeur commence à chercher comment résoudre le problème - il peut connecter un chargeur ou trouver un plug-in magique qui résoudra tous les problèmes.  Miraculeusement, un tel plugin est localisé.  Notre développeur va sur webpack-config, essaie d'installer, mais la ligne de code interfère: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { config.module.rules[<span class="hljs-number"><span class="hljs-number">7</span></span>].options.magic = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  La ligne est traduite comme suit: "Si la configuration est en cours d'assemblage pour la production, alors prenez la septième règle et mettez l'option <code>magic = true</code> là-bas."  Le développeur ne sait pas quoi faire avec cela et comment le résoudre.  C'est une situation où vous avez besoin d'un paquet de rêves. <br><br><h2>  Comment collecter un paquet de rêves? </h2><br>  Tout d'abord, définissons ce que c'est.  Tout d'abord, le bundle de rêve a deux caractéristiques principales: <br><br><ul><li>  <strong>Ça pèse un peu</strong> .  Le moins de poids - plus rapidement l'utilisateur obtiendra une application qui fonctionne.  Vous ne voulez pas que votre site s'ouvre pendant 15 secondes. </li><li>  L'utilisateur <strong>télécharge uniquement ce qui doit être</strong> téléchargé pour afficher la page actuelle du site, et pas un octet de plus! </li></ul><br>  Et pour réduire la taille du bundle, vous devez d'abord évaluer sa taille. <br><br><h3>  Taux de forfait </h3><br>  La solution la plus populaire est le plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebpackBundleAnalyzer</a> .  Il recueille des statistiques de construction d'applications et affiche une page interactive où vous pouvez voir l'emplacement et le poids de chaque module. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/27a/803/6b9/27a8036b994a09b7371c567b6df6cd82.png" alt="image"><br><br>  Si cela ne suffit pas, vous pouvez créer un <strong>graphe de dépendances à l'</strong> aide d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un autre plugin</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/900/24a/7c390024a9d902ca99e3d00c0d8081b3.png" alt="image"><br><br>  Ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un graphique à secteurs</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/350/14a/ec4/35014aec45623d06972bca310b3f8edf.png" alt="image"><br><br>  Si cela ne suffit pas et que vous souhaitez vendre Webpack à des spécialistes du marketing, vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">créer un univers entier</a> où chaque point est un module, comme une étoile dans l'Univers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a6e/2d2/45ba6e2d2daff144c69df2a43e8ef53a.png" alt="image"><br><br>  Il existe de nombreux outils qui évaluent la taille du bundle et le surveillent.  Il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une option dans la configuration Webpack</a> qui bloque l'assemblage si le paquet pèse trop, par exemple.  Il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin duplicate-package-checker-webpack-plugin</a> qui vous empêchera de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">créer un</a> bundle si vous avez 2 packages npm de versions différentes, par exemple, Lodash 4.15 et Lodash 4.14. <br><br><h3>  Comment réduire le forfait </h3><br><ul><li>  Le plus évident est de brancher <strong>UglifyJS</strong> pour qu'il minimise JavaScript. </li><li>  Utilisez <strong>des chargeurs et des plugins spéciaux</strong> qui compressent et optimisent une ressource spécifique.  Par exemple, <strong>css-nano</strong> pour css, ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SVGO</a> , qui optimise SVG. </li><li>  Compressez tous les fichiers directement dans Webpack via les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugins gzip / brotli</a> . </li><li>  D'autres outils. </li></ul><br>  Nous allons maintenant comprendre comment jeter l'excédent du paquet. <br><br><h3>  Jetez l'excédent </h3><br>  Considérez ceci dans un exemple populaire avec <strong>moment.js</strong> : <code>import moment from 'moment'</code> .  Si vous prenez une application vide, importez moment.js et <strong>ReactDOM</strong> dedans, puis passez-la via <strong>WebpackBundleAnalyzer</strong> , vous verrez l'image suivante. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/105/e0f/833/105e0f8334a83c529077c693fda3d3de.png" alt="image"><br><br>  Il s'avère que lorsque vous ajoutez un jour, une heure à une date, ou si vous voulez simplement mettre le lien «en 15 minutes» à l'aide de moment.js, vous connectez un total de <strong>230 Ko de code</strong> !  Pourquoi cela se produit-il et comment est-il résolu? <br><br><h4>  Chargement des paramètres régionaux actuellement </h4><br>  Il y a une fonction dans moment.js qui définit les paramètres régionaux: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLocale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locale</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> localePath = <span class="hljs-string"><span class="hljs-string">'locale/'</span></span> + locale + <span class="hljs-string"><span class="hljs-string">'.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentLocale = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(localePath); }</code> </pre><br>  Le code montre que les paramètres régionaux sont chargés le long du chemin dynamique, c'est-à-dire  calculé en runtime.  Webpack agit intelligemment et essaie de s'assurer que votre bundle ne plante pas pendant l'exécution du code: il trouve tous les paramètres régionaux possibles dans le projet et les regroupe.  Par conséquent, l'application pèse tellement. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/4cc/b3f/a034ccb3fc36dd03b916b0bc28acb057.png" alt="image"><br><br>  La solution est très simple - nous prenons un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin standard</a> de Webpack et lui disons: "Si vous voyez que quelqu'un veut télécharger beaucoup de paramètres régionaux, car ils ne peuvent pas déterminer lequel, il suffit de prendre le russe!" <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/fe6/e38/587fe6e38333e8b482fed615e3c00ee1.png" alt="image"><br><br>  Webpack ne prendra que le russe, et WebpackBundleAnalyzer affichera 54 Ko, ce qui est déjà plus facile de 200 Ko. <br><br><h3>  Élimination du code mort </h3><br>  La prochaine optimisation qui nous intéresse est l' <strong>élimination du code mort</strong> .  Considérez le code suivant. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cond) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; someFunction(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  La plupart des lignes de ce code ne sont pas nécessaires dans le bundle final - le bloc avec la condition ne sera pas exécuté, la fonction après retour aussi.  Tout ce que vous devez laisser, c'est <code>return true</code> .  C'est exactement ce qu'est l'élimination du code mort: l'outil de construction détecte le code qui ne peut pas être exécuté et le coupe.  Il y a une fonctionnalité intéressante qu'UglifyJS peut faire. <br><br>  Passons maintenant à l'élimination plus avancée du code mort - <strong>méthode d'agitation d'arbre</strong> . <br><br><h3>  Tremblement d'arbre </h3><br>  Disons que nous avons une application qui utilise <strong>Lodash</strong> .  Je doute fortement que quelqu'un utilise tout le Lodash.  Très probablement, plusieurs fonctions telles que <strong>get</strong> , <strong>IsEmpty</strong> , <strong>unionBy</strong> ou similaires sont <strong>exploitées</strong> . <br><br>  Lorsque nous secouons l'arbre, nous voulons que Webpack «secoue» les modules inutiles et les jette, et nous n'avons que les modules nécessaires.  C'est Tree secouant. <br><br><h4>  Fonctionnement du tremblement d'arbre dans Webpack </h4><br>  Disons que vous avez un code comme celui-ci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { a } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./a.js'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a);</code> </pre><br>  Le code est très simple: à partir d'un module, importez la variable a et sortez-la.  Mais il y a deux variables dans ce module: <strong>a</strong> et <strong>b</strong> .  Nous n'avons pas besoin de la variable <b>b</b> et nous voulons la supprimer. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  Lorsque Webpack arrive, il convertit le code d'importation en ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(d[<span class="hljs-string"><span class="hljs-string">"a"</span></span>]);</code> </pre><br>  Notre <code>import</code> s'est transformée en <code>require</code> , mais <code>console.log</code> pas changé. <br><br>  La dépendance Webpack est convertie dans le code suivant: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports[<span class="hljs-string"><span class="hljs-string">"a«] = a; /* unused harmony export b */ var b = 4;</span></span></code> </pre><br><br>  Webpack a quitté l'exportation de la variable <b>a</b> et a supprimé l'exportation de la variable <b>b</b> , mais a laissé la variable elle-même, en la marquant d'un commentaire spécial.  Dans le code converti, la variable <b>b n'est</b> pas utilisée et UglifyJS peut la supprimer. <br><br><blockquote>  Le tremblement d'arbre Webpack ne fonctionne que si vous avez une sorte de minifieur de code, comme UglifyJS ou <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">babel-minify</a></b> . </blockquote><br>  Prenons des cas plus intéressants - lorsque le tremblement d'arbre ne fonctionne pas. <br><br><h4>  Quand le tremblement d'arbre ne fonctionne pas </h4><br>  Cas n ° 1. Vous écrivez le code: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.b = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Exécutez le code via Webpack, et il reste le même.  En effet, le bundler organise le tremblement d'arbre uniquement si vous utilisez des modules ES6.  Si vous utilisez des modules CommonJS, le tremblement d'arbre ne fonctionnera pas. <br><br>  Cas n ° 2. Vous écrivez du code avec des modules ES6 et des exportations nommées. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  Si votre code passe par Babel et que vous n'avez pas défini l'option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modules sur false</a> , Babel apportera vos modules à CommonJS et Webpack ne pourra à nouveau pas exécuter le tremblement d'arbre, car il ne fonctionne qu'avec les modules ES6. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.b = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  En conséquence, nous devons être sûrs que personne dans notre plan d'assemblage ne transsipera les modules ES6. <br><br>  Cas n ° 3. Supposons que nous ayons une telle classe inutile qui ne fait rien: <code>export class ShakeMe {}</code> .  De plus, nous ne l'utilisons toujours pas.  Lorsque Webpack passe par l'importation et l'exportation, Babel transformera la classe en fonction, et le bundler notera que la fonction n'est pas utilisée: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* unused harmony e[port b */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShakeMe = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShakeMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ babelHelpers.classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ShakeMe); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShakeMe; }();</code> </pre><br>  Il semble que tout devrait bien se passer, mais si nous regardons de plus près, nous verrons qu'à l'intérieur de cette fonction il y a une variable globale <code>babelHelpers</code> , à partir de laquelle une fonction est appelée.  Ceci est un <b>effet secondaire</b> : UglifyJS voit qu'une fonction globale est appelée et ne coupera pas le code, car il a peur que quelque chose se casse. <br><br>  Lorsque vous écrivez des cours et que vous les exécutez via Babel, ils ne sont jamais supprimés.  Comment est-ce résolu?  Il existe un hack standardisé - ajoutez un commentaire <code>/*#__PURE__*/</code> avant la fonction: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* unused harmony export b */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShakeMe = <span class="hljs-comment"><span class="hljs-comment">/*#__PURE__*/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShakeMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ babelHelpers.classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ShakeMe); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShakeMe; }();</code> </pre><br>  Ensuite, UglifyJS croira au mot que la prochaine fonction est pure.  Heureusement, <b><a href="">Babel 7 le</a></b> fait maintenant, et dans Babel 6, rien n'a été supprimé jusqu'à présent. <br><br><blockquote>  Règle: si vous avez un effet secondaire quelque part, alors UglifyJS ne fera rien. </blockquote><br>  Pour résumer: <br><br><ul><li>  <b>Le tremblement d'arbre ne fonctionne pas pour la plupart des bibliothèques à partir de npm</b> , car elles proviennent toutes de CommonJS et sont construites par l'ancien Babel. </li><li>  Très probablement, le <b>tremblement d'arbre fonctionnera correctement pour les bibliothèques qui sont déjà préparées pour cela</b> , par exemple, Lodash-es, Date-fns et votre code ou vos bibliothèques. </li><li>  UglifyJS est impliqué dans l'assemblage. </li><li>  Modules ES6 d'occasion. </li><li>  Pas d'effets secondaires. </li></ul><br>  Nous avons compris comment réduire le poids du bundle, et maintenant apprenons-le à ne charger que les fonctionnalités nécessaires. <br><br><h3>  Nous ne chargeons que les fonctionnalités nécessaires </h3><br>  Nous divisons cette partie en deux.  Dans la première partie, <b>seul le code dont l'utilisateur a besoin est chargé</b> : si l'utilisateur visite la page principale de votre site, il ne charge pas les pages du compte personnel.  Dans le second, les <b>modifications du code entraînent le rechargement des ressources le plus petit possible</b> . <br><br><h4>  Nous chargeons uniquement le code nécessaire </h4><br>  Considérez la structure d'une application imaginaire.  Il a: <br><br><ul><li>  Point d'entrée - APP. </li><li>  Trois pages: accueil, recherche et carte. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/872/142/14e/87214214e5fc6514a1a72cb20f6be4b2.png" alt="image"><br><br>  Le premier problème que nous voulons résoudre est d' <b>émettre un code commun</b> .  Notons le code rouge comme code commun à toutes les pages, le cercle vert pour la page principale et la page de recherche.  Les chiffres restants ne sont pas particulièrement importants. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/854/ec8/80f/854ec880feff7813d267ca834209db71.png" alt="image"><br><br>  Lorsque l'utilisateur revient à la recherche à partir de la page principale, il rechargera à la fois la boîte et le cercle une deuxième fois, bien qu'il les ait déjà.  Idéalement, nous aimerions voir quelque chose comme ça. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b75/290/36d/b7529036de4cf6923a279666d00ca297.png" alt="image"><br><br>  C'est bien que Webpack 4 dispose déjà d'un plugin intégré qui le fait pour nous - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SplitChunksPlugin</a> .  Le plugin supprime le code d'application ou le code des modules de noeud, qui est utilisé par plusieurs morceaux dans un morceau séparé, tout en garantissant que le morceau avec le code commun sera supérieur à 30 Ko, et pour charger la page, vous devez télécharger pas plus de 5 morceaux.  La stratégie est optimale: charger trop de petits morceaux n'est pas rentable, et charger trop de morceaux est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://engineering.khanacademy.org/posts/js-packaging-">long et pas aussi efficace</a> que de télécharger moins de morceaux même sur http2.  Pour répéter ce comportement sur 2 ou 3 versions de Webpack, j'ai dû écrire 20 à 30 lignes avec des fonctionnalités non documentées.  Maintenant, cela est résolu en une seule ligne. <br><br><h4>  CSS à emporter </h4><br>  Ce serait formidable si nous enlevions toujours le CSS pour chaque morceau dans un fichier séparé.  Il existe une solution toute faite pour cela - <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mini-Css-Extract-Plugin</a></b> .  Le plugin n'est apparu que dans Webpack 4, et avant cela, il n'y avait pas de solutions adéquates pour une telle tâche - seulement des hacks, des douleurs et des jambes de tir.  Le plugin <b>supprime CSS des morceaux asynchrones</b> et a été créé <b>spécifiquement pour cette tâche</b> , qu'il exécute parfaitement. <br><br><h4>  Recharge minimale possible des ressources </h4><br>  Nous allons voir comment nous assurer que lors de la publication, par exemple, d'un nouveau bloc promotionnel sur la page principale, l'utilisateur <b>rechargera la plus petite partie possible du code</b> . <br><br>  Si nous avions des versions, tout irait bien.  Ici, nous avons la page principale de la version N, et après la sortie du bloc promo - la version N + 1.  Webpack fournit un mécanisme similaire dès la sortie de la boîte en utilisant le hachage.  Une fois que Webpack a collecté tous les actifs, dans ce cas app.js, il calcule son hachage de contenu et l'ajoute au nom du fichier pour obtenir l'application. [Hash] .js.  C'est la <b>version dont</b> nous avons besoin. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd1/3f2/1a9/fd13f21a9daeddd3a1af9083b8134257.png" alt="image"><br><br>  Vérifions comment cela fonctionne.  Activez les hachages, apportez des modifications sur la page principale et voyez si le code de la page principale a vraiment changé. Nous verrons que deux fichiers ont changé: main et app.js. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a2/bc0/b44/2a2bc0b447b7baf927ac729e28ace633.png" alt="image"><br><br>  Pourquoi est-ce arrivé, parce que c'est illogique?  Pour comprendre pourquoi, jetons un <b>œil à app.js.</b>  Il se compose de trois parties: <br><br><ul><li>  code d'application </li><li>  exécution du webpack; </li><li>  des liens vers des blocs asynchrones. </li></ul><br>  Lorsque nous modifions le code en principal, son contenu et son hachage changent, ce qui signifie que le <b>lien</b> vers celui-ci change également dans l'application.  L'application elle-même va également changer et doit être redémarrée.  La solution à ce problème consiste à <b>diviser</b> app.js en deux blocs: code d'application et runtime webpack et liens vers des blocs asynchrones.  Webpack 4 fait tout pour nous avec une option <b>runtimeChunk</b> , qui pèse très peu - moins de 2 Ko en gzip.  Le redémarrer pour l'utilisateur est pratiquement sans valeur.  RuntimeChunk est activé avec une seule option: <br><br><pre> <code class="javascript hljs">optimization: { <span class="hljs-attr"><span class="hljs-attr">runtimeChunk</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  Dans Webpack 3 et 2, nous écrivions 5-6 lignes, au lieu d'une.  Ce n'est pas beaucoup plus, mais c'est toujours un inconvénient inutile. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e4/125/5d8/6e41255d837ac2a5c4bb8a6e9b74f686.png" alt="image"><br><br>  Tout est super, nous avons appris à faire des liens et du runtime!  Écrivons un nouveau module dans main, libérons-le et - op!  - maintenant, en général, tout redémarre. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc7/8f6/a5f/cc78f6a5f6ffcd8b2da956d5463fefc8.png" alt="image"><br><br>  Pourquoi  Voyons comment fonctionnent les modules dans webpack. <br><br><h4>  Modules Webpack </h4><br>  Supposons qu'il existe du code dans lequel vous ajoutez des modules <b>a</b> , <b>b</b> , <b>d</b> et <b>e</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>;</code> </pre><br>  Webpack convertit les importations pour exiger: <b>a</b> , <b>b</b> , <b>d</b> et <b>e sont</b> remplacés par require (0), require (1), require (2) et require (3). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  Imaginez une image qui se produit très souvent: vous écrivez un nouveau module c <code>import c from 'c';</code>  et collez-le quelque part au milieu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>;</code> </pre><br>  Lorsque Webpack traite tout, il convertit l'importation du nouveau module en require (2): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Les modules <b>d</b> et <b>e</b> , qui étaient 2 et 3, recevront les numéros 3 et 4 - le nouvel identifiant.  Une conclusion simple en découle: utiliser des numéros de série comme id est un peu idiot, mais Webpack le fait. <br><br><blockquote>  N'utilisez pas le numéro de série comme identifiant unique </blockquote><br>  Pour résoudre le problème, il existe une solution Webpack intégrée - <b>HashedModuleIdsPlugin</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.HashedModuleIdsPlugin({ <span class="hljs-attr"><span class="hljs-attr">hashFunction</span></span>: <span class="hljs-string"><span class="hljs-string">'md4′, hashDigest:'</span></span>base64′, <span class="hljs-attr"><span class="hljs-attr">hashDigestLength</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, }),</code> </pre><br>  Ce plugin utilise 4 caractères de <b>hachage md4</b> au lieu de l'identifiant numérique du chemin absolu vers le fichier.  Avec lui, notre besoin se transformera en ceux-ci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'YmRl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'N2Fl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'OWE4′); var d = require('</span></span>NWQz<span class="hljs-string"><span class="hljs-string">'); var e = require('</span></span>YWVj<span class="hljs-string"><span class="hljs-string">');</span></span></code> </pre><br>  Au lieu de chiffres, des lettres sont apparues.  Bien sûr, il y a un problème caché - c'est une <b>collision de hachages</b> .  Nous sommes tombés dessus une fois et pouvons vous conseiller d'utiliser 8 caractères au lieu de 4. Après avoir configuré correctement les hachages, tout fonctionnera comme nous le voulions à l'origine. <br><br>  Nous savons maintenant comment collecter des bundles de rêve. <br><br><ul><li>  <b>Réduisez</b> . </li><li>  <b>Utilisez le fractionnement de code</b> . </li><li>  <b>Configurez des hachages</b> . </li></ul><br>  Nous avons appris à collectionner, et maintenant nous allons travailler sur la vitesse. <br><br><h2>  Comment assembler <b>rapidement</b> un bundle de rêve? </h2><br>  Dans notre N1.RU, la plus grande application se compose de 10 000 modules, et sans optimisation, cela prend 28 minutes.  Nous avons pu accélérer le montage à deux minutes!  Comment avons-nous fait ça?  Il existe 3 façons d'accélérer les calculs, et les trois sont applicables à Webpack. <br><br><h3>  Parallélisation d'assemblage </h3><br>  La première chose que nous avons faite a été de <b>paralléliser l'assemblage</b> .  Pour cela nous avons: <br><br><ul><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HappyPackPlugin</a></b> , qui <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">encapsule</a></b> vos chargeurs dans d'autres chargeurs, et prend tous les calculs qui sont encapsulés dans des processus séparés.  Cela permet, par exemple, de paralléliser Babel et node-sass. </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chargeur de fil</a></b> .  Fonctionne à peu près de la même manière que HappyPackPlugin, n'utilise pas non plus des processus, mais un pool de threads.  Passer à un thread séparé est une opération coûteuse, utilisez-la avec précaution et uniquement si vous souhaitez encapsuler des opérations gourmandes en ressources et lourdes, telles que babel ou node-sass.  Pour charger json, par exemple, la parallélisation n'est pas nécessaire, car elle se charge rapidement. </li><li>  Les plugins et chargeurs que vous utilisez sont probablement déjà dotés d' <b>outils de parallélisation intégrés</b> - il suffit de regarder.  Par exemple, cette option se trouve dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UglifyJS</a> . </li></ul><br><h3>  Mise en cache des résultats de génération </h3><br>  <b>La mise en cache des résultats d'assemblage</b> est le moyen le plus efficace d'accélérer l'assemblage de Webpack. <br><br>  La première solution que nous avons est le <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cache-loader</a></b> .  Il s'agit d'un chargeur qui entre dans une chaîne de chargeurs et enregistre le résultat de la création d'un fichier spécifique pour une chaîne de chargeurs spécifique dans le système de fichiers.  Lors du prochain assemblage du bundle, si ce fichier est sur le système de fichiers et a déjà été traité avec cette chaîne, cache-loader prendra les résultats et n'appellera pas les chargeurs qui sont derrière eux, par exemple, Babel-loader ou node-sass. <br><br>  Le graphique montre le temps d'assemblage.  Barre bleue - 100% de temps de construction, sans chargeur de cache, et avec elle - 7% plus lent.  En effet, le chargeur de cache passe plus de temps à économiser les caches sur le système de fichiers.  Déjà lors du deuxième montage, nous avons réalisé un bénéfice tangible - le montage était 2 fois plus rapide. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bc/e73/210/6bce732104fda8263464528d91d1a8a1.png" alt="image"><br><br>  La deuxième solution est plus <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sophistiquée</a></b> - <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HardSourcePlugin</a></b> .  La principale différence: le cache-chargeur n'est qu'un chargeur qui ne peut fonctionner que dans une chaîne de chargeurs avec du code ou des fichiers, et HardSourcePlugin a un accès presque complet à l'écosystème Webpack, peut fonctionner avec d'autres plugins et chargeurs, et il étend l'écosystème pour la mise en cache un peu.  Le graphique ci-dessus montre qu'au premier lancement, le temps de build a augmenté de 37%, mais au deuxième lancement avec tous les caches, nous avons accéléré 5 fois. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb6/acf/d36/cb6acfd36adbaaadffd68af19889f960.png" alt="image"><br><br>  La meilleure partie est que vous pouvez utiliser les deux solutions ensemble, ce que nous faisons chez N1.RU.  Soyez prudent, car il y a des problèmes avec les caches, dont je parlerai un peu plus tard. <br><br>  Les plugins / chargeurs que vous utilisez déjà peuvent avoir des <b>mécanismes de mise en cache intégrés</b> .  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">babel-loader a un</a> système de mise en cache très efficace, mais pour une raison quelconque, il est désactivé par défaut.  La même fonctionnalité se trouve dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">awesome-typeScript-loader</a> .  Le plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UglifyJS</a> a également une mise en cache, ce qui fonctionne très bien.  Il nous a accélérés de plusieurs minutes. <br><br>  Et maintenant les problèmes. <br><br><h4>  Problèmes de mise en cache </h4><br><ul><li>  Le cache peut <b>ne pas valider correctement</b> . </li><li>  Les solutions appliquées peuvent <b>ne pas fonctionner avec les plugins connectés, les chargeurs, votre code ou les uns avec les autres</b> .  À cet égard, le cache-chargeur est une solution simple et sans tracas.  Mais avec HardSourcePlugin, vous devez être plus prudent. </li><li>  <b>Il est difficile de faire ses débuts si tout est cassé</b> .  Lorsque la mise en cache ne fonctionne pas correctement et qu'une erreur incompréhensible se produit, il sera très difficile de déterminer le problème. </li></ul><br><h3>  Comment économiser sur la production? </h3><br>  La dernière façon d'accélérer un processus est de ne faire aucune partie du processus.  Réfléchissons à la façon dont vous pouvez économiser sur la production?  Que pouvons-nous ne pas faire?  La réponse est courte - <b>nous ne pouvons rien faire</b> !  Nous n'avons pas le droit de refuser quelque chose en production, mais nous pouvons économiser beaucoup en développement. <br><br>  Sur quoi économiser: <br><br><ul><li>  <b>Ne récupérez pas la carte source</b> avant d'en avoir besoin. </li><li>  <b>Utilisez style-loader</b> au lieu d'un schéma sympa avec suppression et traitement css via des chargeurs css.  Le chargeur de style lui-même est très rapide, car il prend la ligne css et la pousse dans une fonction qui insère cette ligne dans la balise de style. </li><li>  <b>Vous ne pouvez laisser dans la liste des navigateurs que le navigateur que vous utilisez spécifiquement - il s'agit très probablement du dernier chrome</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cela va considérablement s'accélérer</a> . </li><li>  <b>Abandonner complètement toute optimisation des ressources</b> : depuis UglifyJS, css-nano, gzip / brotli. </li></ul><br><blockquote>  L'accélération de la construction est la parallélisation, la mise en cache et le refus des calculs.  En suivant ces trois étapes simples, vous pouvez accélérer beaucoup. </blockquote><br><h2>  Comment configurer le webpack? </h2><br>  Nous avons compris comment assembler un bundle de rêve et comment l'assembler rapidement, et maintenant nous allons voir comment configurer Webpack pour ne pas nous tirer une balle dans la jambe à chaque fois que vous changez la configuration. <br><br><h3>  Evolution de la configuration dans le projet </h3><br>  Un chemin de configuration Webpack typique dans un projet commence par une configuration <b>simple</b> .  Au début, vous insérez simplement Webpack, Babel-Loader, Sass-Loader et tout va bien.  Puis, de manière inattendue, certaines <b>conditions</b> apparaissent <b>sur process.env</b> et vous insérez les conditions.  Un, deuxième, troisième, de plus en plus, jusqu'à ce qu'une condition avec une option «magique» soit ajoutée.  Vous comprenez que tout est déjà assez mauvais, et il vaut mieux simplement <b>dupliquer les configurations</b> pour le développement et la production, et faire des corrections deux fois.  Tout sera plus clair.  Si vous aviez une pensée: "Quelque chose ne va pas ici?", Alors le seul conseil de travail est <b>de garder la configuration en ordre</b> .  Je vais vous dire comment nous procédons. <br><br><h3>  Gardez la configuration en ordre </h3><br>  Nous utilisons le <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package webpack-merge</a></b> .  Il s'agit d'un package npm créé pour combiner plusieurs configurations en une seule.  Si vous n'êtes pas à l'aise avec la stratégie de fusion par défaut, vous pouvez la personnaliser. <br><br><h3>     </h3><br>    4  : <br><br><ul><li> Loaders. </li><li> Plugins. </li><li> Presets. </li><li> Parts. </li></ul><br>    . <br><br><h4> Plugin/Loader </h4><br>  ,        ,       API,  ,      . <br><br>  Cela ressemble à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  JSdoc * @param {Object} options * @see    */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Plugin(options); };</code> </pre><br>  ,   ,   ,   .    ,       url-loader  : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * url-loader    file-loader.        * * @example * -   some-image.png.     url-loader,  url-loader    * 1.    ,  url-loader    base64  * 2. , url-loader    outputPath + name     ,     . *    some-image.png,     outputPath/images/some-image.12345678hash.png,  url-loader  * publicPath/images/some-image.12345678hash.png * * @param {string} prefix    * @param {number} limit    ,    * @return {Object} loader   * @see https://www.npmjs.com/package/url-loader */</span></span></code> </pre><br>     ,   ,  , ,    ,   ,     .  ,  ,   ,  ,   url-loader.    : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">urlLoader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prefix = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'assets'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, limit = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'url-loader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">options</span></span>: { limit, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">/[name].[hash].[ext]`</span></span> } }; };</code> </pre><br>         .    ,   Loader         . <br><br><h4> Preset </h4><br>    webpack.     ,      ,    ,   webpack,    .    —  ,  ,    scss-: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.scss$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [cssLoader, postCssLoader, scssLoader] }</code> </pre><br>     . <br><br><h4> Part </h4><br>  —  ,      .        ,       ,   .  ,       : <br><br><pre> <code class="javascript hljs">entry: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/Frontend/app.js'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">output</span></span>: { <span class="hljs-attr"><span class="hljs-attr">publicPath</span></span>: <span class="hljs-string"><span class="hljs-string">'/static/cabinet/app/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: path.resolve(<span class="hljs-string"><span class="hljs-string">'www/static/app'</span></span>) },</code> </pre><br>     : <br><br><ul><li> <b> </b> ,   ,   , json,     , , splitChunks. </li><li> <b>  dev</b> ,  ,    js/css     </li><li> <b>Part</b> ,   output, publicPath, entry-point    , ,    source map. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/20f/fa6/7ee20ffa6f453c35f11d92e3583d8caf.png" alt="image"><br><br> <b>Webpack-merge</b>     .          ,     .  webpack-merge     3-7 ,    Babel-loader,            .    ,   . <br><br><h3>   </h3><br>  Pour résumer. <b>  </b> ,    . <b> </b> ,   webpack       —     . <b>  </b> ,  . <br><br>   ,    ! <br><br><blockquote>   —     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Frontend Conf</a> . ,    —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ,           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Frontend Conf ++</a>  . <br><br>    -      ?    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FrontenConf ++</a> ,   27  28   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>  27 ,   15          .     — ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433324/">https://habr.com/ru/post/fr433324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433308/index.html">Transfert de la configuration PBX vers le service 3CX PBX Express</a></li>
<li><a href="../fr433316/index.html">Design digest: intégration, feedback, recherche d'idées et prise de décision</a></li>
<li><a href="../fr433318/index.html">garbage.collect ()</a></li>
<li><a href="../fr433320/index.html">Disposition de la grille comme base des mises en page modernes</a></li>
<li><a href="../fr433322/index.html">API JSON - nous travaillons selon les spécifications</a></li>
<li><a href="../fr433326/index.html">Qualité du code</a></li>
<li><a href="../fr433328/index.html">Mieux vaut perdre un jour</a></li>
<li><a href="../fr433330/index.html">Résolvez les mots croisés japonais avec SAT Solver</a></li>
<li><a href="../fr433332/index.html">Prise en charge de Python dans Azure Functions</a></li>
<li><a href="../fr433334/index.html">Comportements XAML pour WPF est désormais Open Source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>