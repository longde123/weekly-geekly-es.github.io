<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💒 🐞 👩🏾‍🤝‍👨🏼 Création de Tower Defense dans Unity, partie 1 🧑🏽 👨🏽‍💻 🛩️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le terrain 


- Création d'un champ de tuiles. 
- Chemins de recherche utilisant une recherche en largeur. 
- Implémentez la prise en charge des tuile...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Création de Tower Defense dans Unity, partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449798/"><h1>  Le terrain </h1><br><ul><li>  Création d'un champ de tuiles. </li><li>  Chemins de recherche utilisant une recherche en largeur. </li><li>  Implémentez la prise en charge des tuiles vides et finales, ainsi que des tuiles murales. </li><li>  Modification du contenu en mode jeu. </li><li>  Affichage facultatif des champs et des chemins de la grille. </li></ul><br>  Ceci est la première partie d'une série de tutoriels sur la création d'un jeu de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tower defense</a> simple.  Dans cette partie, nous envisagerons de créer un terrain de jeu, de trouver un chemin et de placer les tuiles et les murs finaux. <br><br>  Le didacticiel a été créé dans Unity 2018.3.0f2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3d/ae4/591/c3dae459169a0a7f0ce240763b91d55c.jpg"></div><br>  <i>Un champ prêt à l'emploi dans un jeu de tuiles de genre tower defense.</i> <br><br><h2>  Jeu de Tower Defense </h2><br>  Le Tower Defense est un genre dans lequel le but du joueur est de détruire des foules d'ennemis jusqu'à ce qu'ils atteignent leur point final.  Le joueur atteint son objectif en construisant des tours qui attaquent les ennemis.  Ce genre a beaucoup de variations.  Nous allons créer un jeu avec un champ de tuiles.  Les ennemis se déplaceront à travers le champ vers leur point final, et le joueur leur créera des obstacles. <br><a name="habracut"></a><br>  Je suppose que vous avez déjà étudié une série de tutoriels sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gestion des objets</a> . <br><br><h3>  Le terrain </h3><br>  Le terrain de jeu est la partie la plus importante du jeu, nous allons donc le créer en premier.  Ce sera un objet de jeu avec son propre composant <code>GameBoard</code> , qui peut être initialisé en définissant la taille en deux dimensions, pour laquelle nous pouvons utiliser la valeur de <code>Vector2Int</code> .  Le champ devrait fonctionner avec n'importe quelle taille, mais nous choisirons la taille ailleurs, nous allons donc créer une méthode <code>Initialize</code> commune pour cela. <br><br>  De plus, nous visualisons le champ avec un quadrilatère, qui désignera la terre.  Nous ne ferons pas de l'objet champ lui-même un quadrilatère, mais nous y ajouterons un objet enfant quad.  Lors de l'initialisation, nous rendrons l'échelle XY de la terre égale à la taille du champ.  Autrement dit, chaque tuile aura une taille d'une unité de mesure carrée pour le moteur. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform ground = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; Vector2Int size; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Pourquoi définir explicitement Ground à la valeur par défaut?</b> <div class="spoiler_text">  L'idée est que tout ce qui est personnalisable via l'éditeur Unity est accessible via des champs cachés sérialisés.  Il est nécessaire que ces champs ne puissent être modifiés que dans l'inspecteur.  Malheureusement, l'éditeur Unity affichera constamment un compilateur avertissant que la valeur n'est jamais affectée.  Nous pouvons supprimer cet avertissement en définissant explicitement la valeur par défaut du champ.  Vous pouvez également attribuer <code>null</code> , mais je l'ai fait de manière à montrer explicitement que nous utilisons simplement la valeur par défaut, qui n'est pas une véritable référence à la terre, nous utilisons donc la <code>default</code> . </div></div><br>  Créez un objet champ dans une nouvelle scène et ajoutez un quad enfant avec un matériau qui ressemble à la terre.  Puisque nous créons un jeu prototype simple, un matériau vert uniforme sera suffisant.  Faites pivoter le quad de 90 ° le long de l'axe X afin qu'il se trouve sur le plan XZ. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db9/9b8/9af/db99b89afcc551541f1f6adbe4816e54.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/f7c/77d/fa8f7c77d6697bca5e3c8823f5adcd86.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/467/015/f2a467015b8eefc8ca956eaec61d50dc.png"></div><br>  <i>Terrain de jeu.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi ne pas positionner le jeu sur l'avion XY?</b> <div class="spoiler_text">  Bien que le jeu se déroule dans un espace 2D, nous le rendrons en 3D, avec des ennemis 3D et une caméra pouvant être déplacée par rapport à un certain point.  Le plan XZ est plus pratique pour cela et correspond à l'orientation skybox standard utilisée pour l'éclairage ambiant. </div></div><br><h3>  Le jeu </h3><br>  Ensuite, créez un composant de <code>Game</code> qui sera responsable de l'ensemble du jeu.  A ce stade, cela signifie qu'il initialise le champ.  Nous rendons simplement la taille personnalisable via l'inspecteur et forçons le composant à initialiser le champ lorsqu'il se réveille.  Utilisons la taille par défaut de 11 × 11. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Game</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Vector2Int boardSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); [SerializeField] GameBoard board = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize); } }</code> </pre> <br>  La taille des champs ne peut être que positive et il est peu logique de créer un champ avec une seule tuile.  Limitons donc le minimum à 2 × 2.  Cela peut être fait en ajoutant la méthode <code>OnValidate</code> , en limitant de force les valeurs minimales. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnValidate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.x &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.x = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.y &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Quand on appelle Onvalidate?</b> <div class="spoiler_text">  S'il existe, l'éditeur Unity l'appelle pour les composants après les avoir modifiés.  Y compris lors de leur ajout à l'objet de jeu, après le chargement de la scène, après la recompilation, après le changement dans l'éditeur, après l'annulation / la nouvelle tentative et après la réinitialisation du composant. <br><br>  <code>OnValidate</code> est le seul endroit du code où vous pouvez affecter des valeurs aux champs de configuration des composants. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/15d/efd/7ae15defd1e838186f922fc30d346b17.png"></div><br>  <i>Objet de jeu.</i> <br><br>  Maintenant, lorsque vous démarrez le mode de jeu, nous recevrons un champ avec la bonne taille.  Pendant le jeu, positionnez la caméra de manière à ce que tout le plateau soit visible, copiez son composant de transformation, quittez le mode de jeu et collez les valeurs du composant.  Dans le cas d'un champ 11 × 11 à l'origine, pour obtenir une vue pratique d'en haut, vous pouvez positionner la caméra en position (0.10.0) et la faire pivoter de 90 ° le long de l'axe X. Nous laisserons la caméra dans cette position fixe, mais c'est possible changer à l'avenir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/45c/421/eb545c421fdca09acf1258a2fac9e183.png"></div><br>  <i>Caméra sur le terrain.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Comment copier et coller des valeurs de composants?</b> <div class="spoiler_text">  Grâce au menu déroulant qui apparaît lorsque vous cliquez sur le bouton avec l'engrenage dans le coin supérieur droit du composant. </div></div><br><h3>  Tuile préfabriquée </h3><br>  Le champ se compose de carreaux carrés.  Les ennemis pourront se déplacer d'une tuile à l'autre, en traversant les bords, mais pas en diagonale.  Le mouvement se produira toujours vers le point final le plus proche.  Désignons graphiquement la direction du mouvement le long de la tuile avec une flèche.  Vous pouvez télécharger la texture de la flèche <a href="">ici</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/l6/os/tfl6oszqhi93v6aqlllrp1yuhli.png"></div><br>  <i>Flèche sur fond noir.</i> <br><br>  Placez la texture de la flèche dans votre projet et activez l'option <em>Alpha comme transparence</em> .  Créez ensuite un matériau pour la flèche, qui peut être le matériau par défaut pour lequel le mode de découpe est sélectionné, puis sélectionnez la flèche comme texture principale. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/2d6/56c/bfb2d656c07931b8f59ef11715eee93b.png"></div><br>  <i>Matériel de flèche.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi utiliser le mode de rendu découpé?</b> <div class="spoiler_text">  Il vous permet d'obscurcir la flèche à l'aide du pipeline de rendu Unity standard. </div></div><br>  Pour désigner chaque tuile du jeu, nous utiliserons l'objet du jeu.  Chacun d'eux aura son propre quadruple avec un matériau de flèche, tout comme le champ a un quadruple de terre.  Nous ajouterons également des tuiles au composant GameTile avec un lien vers leur flèche. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTile</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform arrow = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }</code> </pre> <br>  Créez un objet tuile et transformez-le en préfabriqué.  Les tuiles seront au ras du sol, alors relevez un peu la flèche pour éviter les problèmes de profondeur lors du rendu.  Faites également un zoom arrière un peu, de sorte qu'il y ait peu d'espace entre les flèches adjacentes.  Un décalage Y de 0,001 et une échelle de 0,8 identique pour tous les axes feront l'affaire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/02b/6d8/f1202b6d8f8f33593bf56ef0d8665537.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/964/1ac/a4b/9641aca4b874f48c3765af10e2c83157.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/7a3/c9f/df77a3c9f539083eab845be6b9c62919.png"></div><br>  <i>Tuile préfabriquée.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Où est la hiérarchie de tuiles préfabriquées?</b> <div class="spoiler_text">  Vous pouvez ouvrir le mode d'édition de préfabriqué en double-cliquant sur l'élément préfabriqué ou en sélectionnant le préfabriqué et en cliquant sur le bouton <em>Ouvrir le préfabriqué</em> dans l'inspecteur.  Vous pouvez quitter le mode d'édition préfabriqué en cliquant sur le bouton avec une flèche dans le coin supérieur gauche de son en-tête de hiérarchie. </div></div><br>  Notez que les tuiles elles-mêmes ne doivent pas nécessairement être des objets de jeu.  Ils ne sont nécessaires que pour suivre l'état du champ.  Nous pourrions utiliser la même approche que pour le comportement dans la série de didacticiels sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gestion d'objets</a> .  Mais dans les premiers stades de jeux simples ou de prototypes d'objets de jeu, nous sommes très heureux.  Cela peut être changé à l'avenir. <br><br><h3>  Nous avons des tuiles </h3><br>  Pour créer des tuiles, le <code>GameBoard</code> doit avoir un lien vers le préfabriqué de tuiles. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTile tilePrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/363/6c2/044/3636c204442368c58858152a7c3efee2.png"></div><br>  <i>Lien vers la tuile préfabriquée.</i> <br><br>  Il peut ensuite créer ses instances à l'aide d'une double boucle sur deux dimensions de la grille.  Bien que la taille soit exprimée en X et Y, nous disposerons les tuiles sur le plan XZ, ainsi que le champ lui-même.  Puisque le champ est centré par rapport à l'origine, nous devons soustraire la taille correspondante moins une divisée par deux des composants de la position de la tuile.  Veuillez noter que ce doit être une division en virgule flottante, sinon cela ne fonctionnera pas pour des tailles égales. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2( (size.x - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, (size.y - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++) { GameTile tile = Instantiate(tilePrefab); tile.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); tile.transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( x - offset.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, y - offset.y ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/391/265/640/391265640fe99dd10be005de76ce93f3.png"></div><br>  <i>Création d'instances de tuiles.</i> <br><br>  Plus tard, nous aurons besoin d'accéder à ces tuiles, nous allons donc les suivre dans un tableau.  Nous n'avons pas besoin d'une liste, car après l'initialisation, la taille du champ ne changera pas. <br><br><pre> <code class="cs hljs"> GameTile[] tiles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { … tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { GameTile tile = tiles[i] = Instantiate(tilePrefab); … } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Comment fonctionne cette mission?</b> <div class="spoiler_text">  Il s'agit d'une affectation liée.  Dans ce cas, cela signifie que nous attribuons un lien à l'instance de tuile à la fois à l'élément de tableau et à la variable locale.  Ces opérations fonctionnent de la même manière que le code ci-dessous. <br><br><pre> <code class="cs hljs">GameTile t = Instantiate(tilePrefab); tiles[i] = t; GameTile tile = t;</code> </pre> </div></div><br><h2>  Rechercher un moyen </h2><br>  À ce stade, chaque tuile a une flèche, mais elles pointent toutes dans la direction positive de l'axe Z, que nous interpréterons comme nord.  L'étape suivante consiste à déterminer la bonne direction pour la tuile.  Nous le faisons en trouvant le chemin que les ennemis doivent suivre jusqu'au point final. <br><br><h3>  Voisins de tuile </h3><br>  Les chemins vont de tuile en tuile, au nord, à l'est, au sud ou à l'ouest.  Pour simplifier la recherche, <code>GameTile</code> des liens de suivi <code>GameTile</code> vers ses quatre voisins. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west;</code> </pre> <br>  Les relations entre voisins sont symétriques.  Si la tuile est le voisin oriental de la deuxième tuile, alors la seconde est le voisin occidental de la première.  Ajoutez une méthode statique générale à <code>GameTile</code> pour définir cette relation entre deux tuiles. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Pourquoi utiliser une méthode statique?</b> <div class="spoiler_text">  Nous pouvons en faire une méthode d'instance avec un seul paramètre, et dans ce cas, nous l'appellerons <code>eastTile.MakeEastWestNeighbors(westTile)</code> ou quelque chose comme ça.  Mais dans les cas où il n'est pas clair sur laquelle des tuiles la méthode doit être appelée, il est préférable d'utiliser des méthodes statiques.  Les exemples sont les méthodes <code>Distance</code> et <code>Dot</code> de la classe <code>Vector3</code> . </div></div><br>  Une fois connecté, il ne devrait jamais changer.  Si cela se produit, nous avons fait une erreur dans le code.  Vous pouvez le vérifier en comparant les deux liens avant d'attribuer des valeurs à <code>null</code> et en affichant une erreur si elle est incorrecte.  Vous pouvez utiliser la méthode <code>Debug.Assert</code> pour <code>Debug.Assert</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( west.east == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; east.west == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Que fait Debug.Assert?</b> <div class="spoiler_text">  Si le premier argument est <code>false</code> , il affiche une erreur de condition, en utilisant le deuxième argument s'il est spécifié.  Un tel appel est inclus uniquement dans les versions de test, mais pas dans les versions.  Par conséquent, c'est un bon moyen d'ajouter des vérifications au cours du processus de développement qui n'affecteront pas la version finale. </div></div><br>  Ajoutez une méthode similaire pour créer des relations entre les voisins du nord et du sud. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeNorthSouthNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile north, GameTile south</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( south.north == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; north.south == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); south.north = north; north.south = south; }</code> </pre> <br>  Nous pouvons établir cette relation lors de la création de tuiles dans <code>GameBoard.Initialize</code> .  Si la coordonnée X est supérieure à zéro, alors nous pouvons créer une relation est-ouest entre les tuiles actuelles et précédentes.  Si la coordonnée Y est supérieure à zéro, alors nous pouvons créer une relation nord-sud entre la tuile actuelle et la tuile de la ligne précédente. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeEastWestNeighbors(tile, tiles[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeNorthSouthNeighbors(tile, tiles[i - size.x]); } } }</code> </pre> <br>  Notez que les tuiles sur les bords du champ n'ont pas quatre voisins.  Une ou deux références voisines resteront <code>null</code> . <br><br><h3>  Distance et direction </h3><br>  Nous n'obligerons pas tous les ennemis à chercher constamment le chemin.  Cela ne doit être fait qu'une seule fois par tuile.  Ensuite, les ennemis pourront demander à la tuile dans laquelle ils se trouvent où aller.  Nous <code>GameTile</code> ces informations dans <code>GameTile</code> en ajoutant un lien vers la <code>GameTile</code> de chemin suivante.  En outre, nous enregistrerons également la distance jusqu'au point final, exprimée en nombre de tuiles qui doivent être visitées avant que l'ennemi n'atteigne le point final.  Pour les ennemis, ces informations sont inutiles, mais nous les utiliserons pour trouver les chemins les plus courts. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west, nextOnPath; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br>  Chaque fois que nous décidons que nous devons rechercher des chemins, nous devons initialiser les données de chemin.  Jusqu'à ce que le chemin soit trouvé, il n'y a pas de tuile suivante et la distance peut être considérée comme infinie.  Nous pouvons imaginer cela comme la valeur entière maximale possible de <code>int.MaxValue</code> .  Ajoutez une méthode générique <code>ClearPath</code> pour réinitialiser le <code>GameTile</code> à cet état. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Les chemins ne peuvent être recherchés que si nous avons un point de terminaison.  Cela signifie que la tuile doit devenir le point de terminaison.  Une telle tuile a une distance de zéro, et elle n'a pas la dernière tuile, car le chemin se termine dessus.  Ajoutez une méthode générique qui transforme une tuile en point de terminaison. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BecomeDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  En fin de compte, toutes les tuiles devraient se transformer en un chemin, de sorte que leur distance ne sera plus égale à <code>int.MaxValue</code> .  Ajoutez une propriété getter pratique pour vérifier si la tuile a actuellement un chemin. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath =&gt; distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Comment fonctionne cette propriété?</b> <div class="spoiler_text">  Il s'agit d'une entrée raccourcie pour une propriété getter contenant une seule expression.  Il fait la même chose que le code ci-dessous. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } }</code> </pre> <br>  L'opérateur de flèche <code>=&gt;</code> peut également être utilisé individuellement pour le getter et le setter de propriétés, pour les corps de méthodes, les constructeurs et dans d'autres endroits. </div></div><br><h3>  Nous grandissons </h3><br>  Si nous avons une tuile avec un chemin, nous pouvons la laisser pousser un chemin vers l'un de ses voisins.  Initialement, la seule tuile avec le chemin est le point final, donc nous partons de la distance zéro et l'augmentons à partir d'ici, en nous déplaçant dans la direction opposée au mouvement des ennemis.  Autrement dit, tous les voisins immédiats du point de terminaison auront une distance de 1, et tous les voisins de ces tuiles auront une distance de 2, et ainsi de suite. <br><br>  Ajoutez une méthode masquée <code>GameTile</code> pour développer le chemin vers l'un de ses voisins, spécifié via le paramètre.  La distance par rapport au voisin est une de plus que la tuile actuelle, et le chemin du voisin indique la tuile actuelle.  Cette méthode ne doit être appelée que pour les tuiles qui ont déjà un chemin, vérifions donc cela avec assert. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  L'idée est que nous appelons cette méthode une fois pour chacun des quatre voisins de la tuile.  Étant donné que certains de ces liens seront <code>null</code> , nous allons vérifier cela et arrêter l'exécution, le cas échéant.  De plus, si un voisin a déjà un chemin, nous ne devons rien faire et cesser de le faire. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  La façon dont <code>GameTile</code> suit ses voisins est inconnue du reste du code.  Par conséquent, <code>GrowPathTo</code> est masqué.  Nous ajouterons des méthodes générales qui indiquent à la tuile de se développer dans une certaine direction, en appelant indirectement <code>GrowPathTo</code> .  Mais le code qui recherche dans tout le champ doit garder une trace des tuiles visitées.  Par conséquent, nous lui ferons retourner un voisin ou <code>null</code> si l'exécution est terminée. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor; }</code> </pre> <br>  Ajoutez maintenant des méthodes pour développer des chemins dans des directions spécifiques. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathNorth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(north); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathEast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(east); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathSouth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(south); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathWest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(west);</code> </pre> <br><h3>  Recherche large </h3><br>  <code>GameBoard</code> doit <code>GameBoard</code> que toutes les tuiles contiennent les données de chemin correctes.  Pour ce faire, nous effectuons une recherche en premier.  Commençons par la tuile de point de terminaison, puis développons le chemin vers ses voisins, puis vers les voisins de ces tuiles, etc.  À chaque étape, la distance augmente d'une unité et les chemins ne croissent jamais en direction des tuiles qui ont déjà des chemins.  Cela garantit que toutes les tuiles pointeront le long du chemin le plus court vers le point final. <br><br><div class="spoiler">  <b class="spoiler_title">Que diriez-vous de trouver un chemin en utilisant A *?</b> <div class="spoiler_text">  L'algorithme A <sup>*</sup> est le développement évolutif de la recherche en largeur d'abord.  Il est utile lorsque nous recherchons le seul chemin le plus court.  Mais nous avons besoin de tous les chemins les plus courts, donc A <sup>*</sup> ne donne aucun avantage.  Pour des exemples de recherche en largeur et A <sup>*</sup> sur une grille d'hexagones avec animation, voir la série de tutoriels sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cartes d'hexagones</a> . </div></div><br>  Pour effectuer la recherche, nous devons suivre les tuiles que nous avons ajoutées au chemin, mais à partir desquelles nous n'avons pas encore développé le chemin.  Cette collection de tuiles est souvent appelée la frontière de recherche.  Il est important que les tuiles soient traitées dans le même ordre dans lequel elles sont ajoutées à la bordure, utilisons donc la <code>Queue</code> .  Plus tard, nous devrons effectuer la recherche plusieurs fois, nous allons donc le définir comme le champ du <code>GameBoard</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … Queue&lt;GameTile&gt; searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;GameTile&gt;(); … }</code> </pre> <br>  Pour que l'état du terrain de jeu soit toujours vrai, nous devons trouver les chemins à la fin de <code>Initialize</code> , mais placer le code dans une méthode <code>FindPaths</code> distincte.  Tout d'abord, vous devez effacer le chemin de toutes les tuiles, puis faire d'une tuile le point final et l'ajouter à la bordure.  Sélectionnons d'abord la première tuile.  Comme les <code>tiles</code> sont un tableau, nous pouvons utiliser la <code>foreach</code> sans crainte de pollution de la mémoire.  Si nous passons plus tard d'un tableau à une liste, nous devrons également remplacer les boucles <code>foreach</code> par <code>for</code> boucles <code>for</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { … FindPaths(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Ensuite, nous devons prendre une tuile de la frontière et développer un chemin vers tous ses voisins, en les ajoutant tous à la frontière.  Nous allons d'abord nous déplacer vers le nord, puis vers l'est, le sud et enfin vers l'ouest. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  Nous répétons cette étape, alors qu'il y a des tuiles à la frontière. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  La croissance d'un chemin ne nous mène pas toujours à une nouvelle tuile.  Avant d'ajouter à la file d'attente, nous devons vérifier la valeur de <code>null</code> , mais nous pouvons reporter la vérification de <code>null</code> jusqu'à la sortie de la file d'attente. <br><br><pre> <code class="cs hljs"> GameTile tile = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br><h3>  Afficher les chemins </h3><br>  Nous avons maintenant un champ contenant les bons chemins, mais jusqu'à présent, nous ne voyons pas cela.  Vous devez configurer les flèches afin qu'elles pointent le long du chemin à travers leurs tuiles.  Cela peut être fait en les tournant.  Comme ces virages sont toujours les mêmes, nous ajoutons au <code>GameTile</code> un champ <code>Quaternion</code> statique pour chacune des directions. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Quaternion northRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), eastRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), southRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">180f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), westRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">270f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>);</code> </pre> <br>  Ajoutez également la méthode générale <code>ShowPath</code> .  Si la distance est nulle, alors la tuile est le point final et il n'y a rien vers quoi pointer, alors désactivez sa flèche.  Sinon, activez la flèche et réglez sa rotation.  La direction souhaitée peut être déterminée en comparant <code>nextOnPath</code> avec ses voisins. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance == <span class="hljs-number"><span class="hljs-number">0</span></span>) { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); arrow.localRotation = nextOnPath == north ? northRotation : nextOnPath == east ? eastRotation : nextOnPath == south ? southRotation : westRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appelez cette méthode pour toutes les tuiles à la fin </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/4fe/4d5/b2d4fe4d511b4e729910ea78b267f268.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trouve des moyens.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ne transformons-nous pas la flèche directement en GrowPathTo?</font></font></b> <div class="spoiler_text">      .     .    ,          <code>FindPaths</code> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modifier la priorité de recherche </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'avère que lorsque le point final est le coin sud-ouest, tous les chemins vont exactement vers l'ouest jusqu'à ce qu'ils atteignent le bord du champ, après quoi ils tournent vers le sud. </font><font style="vertical-align: inherit;">Tout est vrai ici, car il n'y a vraiment pas de chemins plus courts vers le point final, car les mouvements diagonaux sont impossibles. </font><font style="vertical-align: inherit;">Cependant, il existe de nombreux autres chemins les plus courts qui peuvent sembler plus beaux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour mieux comprendre pourquoi de tels chemins sont trouvés, déplacez le point final au centre de la carte. </font><font style="vertical-align: inherit;">Avec une taille de champ impaire, ce n'est qu'une tuile au milieu du tableau.</font></font><br><br><pre> <code class="cs hljs"> tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d3/d09/d78/6d3d09d7844fbe6a4aaf4618449598de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Point d'arrivée au centre.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le résultat semble logique si vous vous souvenez du fonctionnement de la recherche. Puisque nous ajoutons des voisins dans l'ordre nord-est-sud-ouest, le nord a la plus haute priorité. Puisque nous effectuons la recherche dans l'ordre inverse, cela signifie que la dernière direction que nous avons parcourue est le sud. C'est pourquoi seules quelques flèches pointent vers le sud et beaucoup pointent vers l'est. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez modifier le résultat en définissant les priorités des directions. Échangeons l'est et le sud. Nous devons donc obtenir la symétrie nord-sud et est-ouest.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest())</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/2c7/0b7/a9a2c70b7d7d178b041f30c11d256ad3.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ordre de recherche est nord-sud-est-ouest. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble plus joli, mais il vaut mieux que les chemins changent de direction, s'approchant du mouvement diagonal où il aura l'air naturel. </font><font style="vertical-align: inherit;">Nous pouvons le faire en inversant les priorités de recherche des tuiles voisines dans un motif en damier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu de déterminer quel type de mosaïque nous traitons pendant la recherche, nous ajoutons à la </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriété générale qui indique si la mosaïque actuelle est une alternative.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsAlternative { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons définir cette propriété dans </font></font><code>GameBoard.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tout d'abord, marquez les tuiles comme alternative si leur coordonnée X est paire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que fait l'opération (x &amp; 1) == 0?</font></font></b> <div class="spoiler_text">   —     (AND).            .       1,       1.  10101010  00001111   00001010. <br><br>       .      0  1.     1, 2, 3, 4   1, 10, 11, 100.  ,       . <br><br>    AND  ,  ,    .    ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement, nous changeons le signe du résultat si leur coordonnée Y est paire. </font><font style="vertical-align: inherit;">Nous allons donc créer un modèle d'échecs.</font></font><br><br><pre> <code class="cs hljs"> tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((y &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { tile.IsAlternative = !tile.IsAlternative; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous gardons le même ordre que la recherche de tuiles alternative, mais de le </font><font style="vertical-align: inherit;">faire revenir à toutes les </font><font style="vertical-align: inherit;">autres tuiles. </font><font style="vertical-align: inherit;">Cela forcera le chemin vers le mouvement diagonal et créera des zigzags.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.IsAlternative) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Enqueue(tile.GrowPathWest()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathNorth()); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b43/e3a/d63/b43e3ad6370a6b552073b4f0b4cf0e8b.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordre de recherche variable.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changer les tuiles </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À ce stade, toutes les tuiles sont vides. </font><font style="vertical-align: inherit;">Une tuile est utilisée comme point de terminaison, mais en plus de l'absence d'une flèche visible, elle ressemble à tout le monde. </font><font style="vertical-align: inherit;">Nous ajouterons la possibilité de changer les tuiles en plaçant des objets dessus.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contenu des tuiles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les objets en mosaïque eux-mêmes sont simplement un moyen de suivre les informations sur les mosaïques. </font><font style="vertical-align: inherit;">Nous ne modifions pas ces objets directement. </font><font style="vertical-align: inherit;">Ajoutez plutôt du contenu séparé et placez-le sur le terrain. </font><font style="vertical-align: inherit;">Pour l'instant, nous pouvons distinguer entre les tuiles vides et les tuiles de point de terminaison. </font><font style="vertical-align: inherit;">Pour indiquer ces cas, créez une énumération </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, créez un type de composant </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui vous permet de définir le type de son contenu via l'inspecteur, et l'accès à celui-ci se fera via une propriété getter commune.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] GameTileContentType type = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentType Type =&gt; type; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous créerons des préfabriqués pour deux types de contenu, chacun ayant un composant </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec le type spécifié correspondant. </font><font style="vertical-align: inherit;">Utilisons un cube bleu aplati pour désigner les tuiles d'extrémité. </font><font style="vertical-align: inherit;">Comme il est presque plat, il n'a pas besoin de collisionneur. </font><font style="vertical-align: inherit;">Pour préfabriquer du contenu vide, utilisez un objet de jeu vide.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f55/25d/8db/f5525d8db707ff187e17ce96a11d86ae.png" width="320" height="262" alt="destination"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/463/e19/c6f463e198abca6134b7bc74d3207833.png" width="320" height="176" alt="vide"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Préfabriqués du point de terminaison et du contenu vide. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous donnerons l'objet de contenu aux tuiles vides, car alors toutes les tuiles auront toujours le contenu, ce qui signifie que nous n'aurons pas besoin de vérifier l'égalité des liens vers les contenus </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Content Factory </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour rendre le contenu modifiable, nous allons également créer une fabrique pour cela, en utilisant la même approche que dans le didacticiel de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gestion des objets</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cela signifie que vous </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devez garder une trace de votre usine d'origine, qui ne doit être définie qu'une seule fois, et vous renvoyer à l'usine dans la méthode </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory originFactory; … <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentFactory OriginFactory { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; originFactory; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(originFactory == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined origin factory!"</span></span>); originFactory = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela suppose l'existence </font></font><code>GameTileContentFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, par conséquent, nous allons créer un type d'objet scriptable pour cela avec la méthode requise </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">À ce stade, nous ne nous occuperons pas de la création d'une usine entièrement fonctionnelle qui utilise le contenu, nous allons donc la faire simplement détruire le contenu. </font><font style="vertical-align: inherit;">Plus tard, il sera possible d'ajouter la réutilisation des objets à l'usine sans changer le reste du code.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.SceneManagement; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContentFactory</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reclaim</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent content</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(content.OriginFactory == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"Wrong factory reclaimed!"</span></span>); Destroy(content.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une méthode cachée </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à l' </font><font style="vertical-align: inherit;">usine </font><font style="vertical-align: inherit;">avec un préfabriqué comme paramètre. </font><font style="vertical-align: inherit;">Ici, nous sautons à nouveau la réutilisation des objets. </font><font style="vertical-align: inherit;">Il crée une instance de l'objet, définit son usine d'origine, le déplace vers la scène d'usine et le renvoie.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent prefab</span></span></span><span class="hljs-function">)</span></span> { GameTileContent instance = Instantiate(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; MoveToFactoryScene(instance.gameObject); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'instance a été déplacée vers la scène de contenu d'usine, qui peut être créée selon les besoins. </font><font style="vertical-align: inherit;">Si nous sommes dans l'éditeur, avant de créer une scène, nous devons vérifier si elle existe, au cas où nous la perdrions de vue lors d'un redémarrage à chaud.</font></font><br><br><pre> <code class="cs hljs"> Scene contentScene; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveToFactoryScene</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.isEditor) { contentScene = SceneManager.GetSceneByName(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { contentScene = SceneManager.CreateScene(name); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentScene = SceneManager.CreateScene(name); } } SceneManager.MoveGameObjectToScene(o, contentScene); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous n'avons que deux types de contenu, il suffit donc d'ajouter deux champs de configuration préfabriqués pour eux. </font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent destinationPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] GameTileContent emptyPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La dernière chose à faire pour que l'usine fonctionne est de créer une méthode générale </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un paramètre </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui reçoit une instance du préfabriqué correspondant.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est-il obligatoire d'ajouter une instance distincte de contenu vide à chaque tuile?</font></font></b> <div class="spoiler_text">       ,               .         .  ,        - , , , ,    .     ,       .     ,        ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Créons un actif d'usine et configurons ses liens vers les préfabriqués. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7eb/75f/1cd/7eb75f1cd4bed3c72ffd7f0c42b69cbe.png" width="320" height="106"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content Factory </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et puis passez le </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien à l'usine.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContentFactory tileContentFactory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/d6a/506/b12d6a5067fa91177dbed14a876f8b3d.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeu avec une usine.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Taper sur une tuile </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour changer de champ, nous devons pouvoir sélectionner une tuile. Nous le rendrons possible en mode jeu. Nous émettrons un faisceau dans la scène à l'endroit où le joueur a cliqué sur la fenêtre de jeu. Si la poutre croise la tuile, le joueur la touche, c'est-à-dire qu'elle doit être changée. </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gérera l'entrée du joueur, mais sera responsable de déterminer la tuile que le joueur a touchée </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous les rayons ne se croisent pas avec la tuile, donc parfois nous ne recevrons rien. Par conséquent, nous ajoutons à la </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode </font></font><code>GetTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui renvoie toujours toujours initialement </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(cela signifie que la tuile n'a pas été trouvée).</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour déterminer si un rayon a traversé une tuile, nous devons appeler </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en spécifiant le rayon comme argument. </font><font style="vertical-align: inherit;">Il renvoie des informations sur la présence d'une intersection. </font><font style="vertical-align: inherit;">Si c'est le cas, nous pouvons retourner la tuile, bien que nous ne sachions pas encore laquelle, donc pour le moment nous la retournerons </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryGetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour savoir s'il y avait une intersection avec une tuile, nous avons besoin de plus d'informations sur l'intersection. </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut fournir ces informations à l'aide du deuxième paramètre </font></font><code>RaycastHit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il s'agit du paramètre de sortie, qui est indiqué par le mot </font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devant lui. </font><font style="vertical-align: inherit;">Cela signifie qu'un appel de méthode peut affecter une valeur à la variable que nous lui transmettons.</font></font><br><br><pre> <code class="cs hljs"> RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons incorporer la déclaration des variables utilisées pour les paramètres de sortie, alors faisons-le. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne nous soucions pas avec quel collisionneur l'intersection s'est produite, nous utilisons simplement la position de l'intersection XZ pour déterminer la tuile. </font><font style="vertical-align: inherit;">Nous obtenons les coordonnées de la tuile en ajoutant la moitié de la taille du champ aux coordonnées du point d'intersection, puis en convertissant les résultats en valeurs entières. </font><font style="vertical-align: inherit;">En conséquence, l'index de tuile final sera sa coordonnée X plus la coordonnée Y multipliée par la largeur du champ.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais cela n'est possible que lorsque les coordonnées de la tuile sont dans le champ, nous allons donc vérifier cela. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, la tuile ne sera pas retournée.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; size.x &amp;&amp; y &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; y &lt; size.y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changement de contenu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour pouvoir modifier le contenu de la tuile, ajoutez-la à la </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriété générale </font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Son getter renvoie simplement le contenu et le setter rejette le contenu précédent, le cas échéant, et place le nouveau contenu.</font></font><br><br><pre> <code class="cs hljs"> GameTileContent content; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContent Content { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; content; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { content.Recycle(); } content = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; content.transform.localPosition = transform.localPosition; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est le seul endroit où vous devez vérifier le contenu </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car au départ, nous n'avons pas de contenu. </font><font style="vertical-align: inherit;">Pour garantir, nous exécutons assert afin que le passeur ne soit pas appelé avec </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Null assigned to content!"</span></span>); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin, nous avons besoin d'une entrée de joueur. </font><font style="vertical-align: inherit;">La conversion d'un clic de souris en rayon peut être effectuée en appelant </font></font><code>ScreenPointToRay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec </font></font><code>Input.mousePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme argument. </font><font style="vertical-align: inherit;">L'appel doit être effectué pour la caméra principale, accessible via </font></font><code>Camera.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ajoutez la propriété c pour cela </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> Ray TouchRay =&gt; Camera.main.ScreenPointToRay(Input.mousePosition);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous ajoutons une méthode </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui vérifie si le bouton principal de la souris a été enfoncé pendant la mise à niveau. </font><font style="vertical-align: inherit;">Pour ce faire, appelez </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec zéro comme argument. </font><font style="vertical-align: inherit;">Si la touche a été enfoncée, nous traitons le toucher du joueur, c'est-à-dire que nous prenons la tuile sur le terrain et définissons le point final comme son contenu, en le prenant de l'usine.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { tile.Content = tileContentFactory.Get(GameTileContentType.Destination); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, nous pouvons transformer n'importe quelle tuile en point final en appuyant sur le curseur. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99a/f15/da3/99af15da39bfc08cb8886b98e0ae15df.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plusieurs points de terminaison.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faire le bon terrain </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous puissions transformer des tuiles en points de terminaison, cela n'affecte pas les chemins jusqu'à présent. </font><font style="vertical-align: inherit;">De plus, nous n'avons pas encore défini de contenu vide pour les tuiles. </font><font style="vertical-align: inherit;">Le maintien de l'exactitude et de l'intégrité du champ est une tâche </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous allons donc lui donner la responsabilité de définir le contenu de la tuile. </font><font style="vertical-align: inherit;">Pour l'implémenter, nous allons lui donner un lien vers la fabrique de contenu via sa méthode </font></font><code>Intialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et l'utiliser pour donner à toutes les tuiles une instance de contenu vide.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory contentFactory; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.contentFactory = contentFactory; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … tile.Content = contentFactory.Get(GameTileContentType.Empty); } } FindPaths(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, je </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois transférer mon usine sur le terrain.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ne pas ajouter un champ de configuration d'usine au GameBoard?</font></font></b> <div class="spoiler_text">   ,    ,   .        ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous avons maintenant plusieurs points de terminaison, nous le modifions </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il appelle </font></font><code>BecomeDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chacun d'eux et les ajoute tous à la frontière. </font><font style="vertical-align: inherit;">Et c'est tout ce qu'il faut pour prendre en charge plusieurs points de terminaison. </font><font style="vertical-align: inherit;">Toutes les autres tuiles sont effacées comme d'habitude. </font><font style="vertical-align: inherit;">Ensuite, nous supprimons le point de terminaison défini au centre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.BecomeDestination(); searchFrontier.Enqueue(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.ClearPath(); } } <span class="hljs-comment"><span class="hljs-comment">//tiles[tiles.Length / 2].BecomeDestination(); //searchFrontier.Enqueue(tiles[tiles.Length / 2]); … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais si nous pouvons transformer des tuiles en points de terminaison, alors nous devrions être en mesure d'effectuer l'opération inverse, transformer les points de terminaison en tuiles vides. </font><font style="vertical-align: inherit;">Mais alors nous pouvons obtenir un champ sans aucun point final. </font><font style="vertical-align: inherit;">Dans ce cas, </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne pourra pas effectuer sa tâche. </font><font style="vertical-align: inherit;">Cela se produit lorsque la bordure est vide après l'initialisation du chemin pour toutes les cellules. </font><font style="vertical-align: inherit;">Nous désignons cela comme un état non valide du champ, renvoyant </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et terminant l'exécution; </font><font style="vertical-align: inherit;">sinon retournez à la fin </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le moyen le plus simple de mettre en œuvre la prise en charge de la suppression des points de terminaison, ce qui en fait une opération de commutation. En cliquant sur les tuiles vides, nous les transformerons en points de terminaison, et en cliquant sur les points de terminaison, nous les supprimerons. Mais maintenant, il est engagé dans la modification du contenu </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous allons donc lui donner une méthode générale </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dont le paramètre est la vignette. Si la tuile est le point de terminaison, faites-la vide et appelez </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sinon, nous en faisons le point final et nous l'appelons également </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ajout d'un point de terminaison ne peut jamais créer un état de champ non valide, et la suppression d'un point de terminaison peut le faire. </font><font style="vertical-align: inherit;">Par conséquent, nous vérifierons s'il a réussi à s'exécuter </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">après avoir rendu la tuile vide. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, annulez la modification, ramenez la tuile au point de terminaison et appelez à nouveau </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour revenir à l'état correct précédent.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La validation peut-elle être rendue plus efficace?</font></font></b> <div class="spoiler_text">      ,      .           ,   .  ,          .        <code>FindPaths</code> ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, à la fin, </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous pouvons appeler </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec la tuile centrale comme argument, au lieu d'appeler explicitement </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C'est la seule fois où nous commençons avec un état de champ non valide, mais nous sommes garantis de terminer avec l'état correct.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-comment"><span class="hljs-comment">//FindPaths(); ToggleDestination(tiles[tiles.Length / 2]); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, nous forçons à </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appeler </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au lieu de définir le contenu de la tuile elle-même.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//tile.Content = //tileContentFactory.Get(GameTileContentType.Destination); board.ToggleDestination(tile); } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/685/8a9/8326858a93b938353376ff97259df1a7.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plusieurs points de terminaison avec des chemins corrects.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne devrions-nous pas interdire à Game de définir directement le contenu de la vignette?</font></font></b> <div class="spoiler_text">   .       .       ,   <code>Game</code>             .    ,      . </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les murs </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le but de la défense de tour est d'empêcher les ennemis d'atteindre le point final. </font><font style="vertical-align: inherit;">Cet objectif est atteint de deux manières. </font><font style="vertical-align: inherit;">Premièrement, nous les tuons, et deuxièmement, nous les ralentissons afin qu'il y ait plus de temps pour les tuer. </font><font style="vertical-align: inherit;">Sur le champ de tuiles, le temps peut être allongé, augmentant la distance que les ennemis doivent parcourir. </font><font style="vertical-align: inherit;">Ceci peut être réalisé en plaçant des obstacles sur le terrain. </font><font style="vertical-align: inherit;">Ce sont généralement des tours qui tuent également les ennemis, mais dans ce didacticiel, nous nous limiterons aux murs.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le contenu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les murs sont un autre type de contenu, alors ajoutons-y </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un élément.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez ensuite le préfabriqué mural. </font><font style="vertical-align: inherit;">Cette fois, nous allons créer un objet de jeu du contenu de la tuile et y ajouter un cube enfant, qui sera au-dessus du champ et remplira la tuile entière. </font><font style="vertical-align: inherit;">Faites-le à une demi-unité de hauteur et sauvez le collisionneur, car les murs peuvent chevaucher visuellement une partie des tuiles derrière lui. </font><font style="vertical-align: inherit;">Par conséquent, lorsqu'un joueur touche un mur, il influence la tuile correspondante.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/a33/779/1d3a33779b0c4d49f8ab4fed3d8abd20.png" width="320" height="176" alt="racine"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/431/b5c/9f6/431b5c9f65000bab15dd9e1eed14696d.png" width="320" height="226" alt="cube"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6b/875/3b2/e6b8753b2e9b954b55a4a3a6e0154560.png" width="225" height="60" alt="préfabriqué"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mur préfabriqué. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez le préfabriqué mural à l'usine, à la fois dans le code et dans l'inspecteur.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent wallPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Wall: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(wallPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/eaa/50f/262eaa50f1bf4f80b2d2861d6232368b.png" width="320" height="80"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usine avec mur préfabriqué.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Activer et désactiver les murs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez à </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la méthode marche / arrêt des murs, comme nous l'avons fait pour le point final. </font><font style="vertical-align: inherit;">Initialement, nous ne vérifierons pas l'état incorrect du champ.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Wall); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous prendrons en charge la commutation uniquement entre les carreaux vides et les carreaux muraux, sans permettre aux murs de remplacer directement les points de terminaison. </font><font style="vertical-align: inherit;">Par conséquent, nous ne créerons un mur que lorsque la tuile sera vide. </font><font style="vertical-align: inherit;">De plus, les murs doivent bloquer la recherche du chemin. </font><font style="vertical-align: inherit;">Mais chaque tuile doit avoir un chemin vers le point final, sinon les ennemis se coincent. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons à nouveau utiliser la validation </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ignorer les modifications si elles ont créé un état de champ incorrect.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Wall); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'activation et la désactivation des murs seront utilisées beaucoup plus souvent que l'activation et la désactivation des points de terminaison, nous allons donc effectuer la commutation des murs dans la </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">touche principale. </font><font style="vertical-align: inherit;">Les points d'extrémité peuvent être commutés par une touche supplémentaire (généralement le bouton droit de la souris), qui peut être reconnue en passant à une </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur de 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { HandleAlternativeTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleAlternativeTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleDestination(tile); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleWall(tile); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d62/e45/4e9/d62e454e94a659dd9da841a915a93dac.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons les murs.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ai-je de grands écarts entre les ombres des murs adjacents en diagonale?</font></font></b> <div class="spoiler_text">  ,          ,    ,   .   ,   ,  far clipping plane      . ,   far plane  20      .  ,         MSAA,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Veillons également à ce que les extrémités ne puissent pas remplacer directement les murs. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verrou de recherche de chemin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que les murs bloquent la recherche du chemin, il nous suffit de ne pas ajouter de tuiles avec des murs à la bordure de recherche. </font><font style="vertical-align: inherit;">Cela peut être fait en forçant à </font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne pas retourner les carreaux avec des murs. </font><font style="vertical-align: inherit;">Mais le chemin doit toujours croître en direction du mur, afin que toutes les tuiles du terrain aient un chemin. </font><font style="vertical-align: inherit;">Cela est nécessaire car il est possible qu'une tuile avec des ennemis se transforme soudainement en mur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour s'assurer que toutes les tuiles ont un chemin, elles </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doivent le vérifier une fois la recherche terminée. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, l'état du champ n'est pas valide et doit être renvoyé </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il n'est pas nécessaire de mettre à jour la visualisation du chemin pour les états non valides, car le champ reviendra à l'état précédent.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tile.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc3/ff2/c3e/cc3ff2c3e52a087d9fa757d5760623d6.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les murs affectent le chemin. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour vous assurer que les murs ont réellement les bons chemins, vous devez rendre les cubes translucides.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9b/2f6/70c/d9b2f670c9bcf0fc568c1484750c2e77.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Murs transparents. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que l'exigence d'exactitude de tous les chemins ne permet pas aux murs d'enfermer une partie du champ dans laquelle il n'y a pas de point final. </font><font style="vertical-align: inherit;">Nous pouvons diviser la carte, mais seulement s'il y a au moins un point de terminaison dans chaque partie. </font><font style="vertical-align: inherit;">De plus, chaque mur doit être adjacent à une tuile ou à un point de terminaison vide, sinon il ne pourra pas avoir de chemin. </font><font style="vertical-align: inherit;">Par exemple, il est impossible de faire un bloc solide de murs 3 × 3.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cachez le chemin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La visualisation des chemins nous permet de voir comment fonctionne la recherche de chemin et de nous assurer qu'elle est bien correcte. </font><font style="vertical-align: inherit;">Mais il n'a pas besoin d'être montré au joueur, ou du moins pas nécessairement. </font><font style="vertical-align: inherit;">Par conséquent, fournissons la possibilité de désactiver les flèches. </font><font style="vertical-align: inherit;">Cela peut être fait en ajoutant à la </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode générale </font></font><code>HidePath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui désactive simplement sa flèche.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HidePath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'état de mappage de chemin fait partie de l'état du champ. </font><font style="vertical-align: inherit;">Ajoutez un </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ booléen à la valeur par défaut </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour suivre son état, ainsi qu'une propriété commune comme getter et setter. </font><font style="vertical-align: inherit;">Le passeur doit afficher ou masquer les chemins sur toutes les tuiles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowPaths { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showPaths; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showPaths = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.HidePath(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Désormais, la méthode </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne doit afficher les chemins mis à jour que si le rendu est activé.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par défaut, la visualisation du chemin est désactivée. </font><font style="vertical-align: inherit;">Désactivez la flèche dans le préfabriqué de tuiles.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5a/c71/802/a5ac718028d1bb41c145dfabba9051e1.png" width="320" height="44"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La flèche préfabriquée est inactive par défaut. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous faisons en sorte qu'il </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permute l'état de visualisation lorsqu'une touche est enfoncée. </font><font style="vertical-align: inherit;">Il serait logique d'utiliser la touche P, mais c'est aussi un raccourci clavier pour activer / désactiver le mode de jeu dans l'éditeur Unity. </font><font style="vertical-align: inherit;">En conséquence, la visualisation changera lorsque le raccourci clavier pour quitter le mode de jeu est utilisé, ce qui n'est pas très joli. </font><font style="vertical-align: inherit;">Utilisons donc la touche V (abréviation de visualisation).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9c/a96/15c/a9ca9615c10cdab502f1769443ad6b38.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pas de flèches.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affichage de la grille </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque les flèches sont cachées, il devient difficile de discerner l'emplacement de chaque tuile. </font><font style="vertical-align: inherit;">Ajoutons les lignes de la grille. </font><font style="vertical-align: inherit;">Téléchargez ici une </font><font style="vertical-align: inherit;">texture </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> maillage de bordure carrée qui peut être utilisée comme contour de tuile distinct.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/e98/483/4c1e984836babfc368136b83ac2b195b.png" width="128" height="128"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture de maille.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous n'ajouterons pas cette texture individuellement à chaque carreau, mais l'appliquerons au sol. Mais nous rendrons cette grille facultative, ainsi que la visualisation des chemins. Par conséquent, nous allons ajouter au </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ de configuration </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et sélectionner une texture de maillage pour celui-ci.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Texture2D gridTexture = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed4/99a/28e/ed499a28e82a3328c010a71ba1085316.png" width="320" height="94"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Champ avec texture de maille. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un autre champ booléen et une propriété pour contrôler l'état de la visualisation de la grille. </font><font style="vertical-align: inherit;">Dans ce cas, le passeur doit changer le matériau de la terre, ce qui peut être mis en œuvre en appelant la </font></font><code>GetComponent&lt;MeshRenderer&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terre et en accédant à la propriété du </font></font><code>material</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">résultat. </font><font style="vertical-align: inherit;">Si la grille doit être affichée, nous attribuerons la </font></font><code>mainTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texture </font><font style="vertical-align: inherit;">de la </font><font style="vertical-align: inherit;">grille </font><font style="vertical-align: inherit;">à la propriété du </font><font style="vertical-align: inherit;">matériau. </font><font style="vertical-align: inherit;">Sinon, attribuez-le-lui </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Notez que lorsque vous modifiez la texture du matériau, des doublons de l'instance de matériau seront créés, de sorte qu'elle deviendra indépendante de l'actif matériel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showGrid, showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowGrid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showGrid; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showGrid = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Material m = ground.GetComponent&lt;MeshRenderer&gt;().material; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m.mainTexture = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faites - </font><font style="vertical-align: inherit;">le </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commutées en appuyant sur la visualisation de la </font><font style="vertical-align: inherit;">grille G.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.G)) { board.ShowGrid = !board.ShowGrid; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez également la visualisation de maillage par défaut à </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b04/145/190/b04145190e5d8f15972f25374d7f5813.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grille non mise à l'échelle. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'à présent, nous avons une frontière autour de tout le champ. </font><font style="vertical-align: inherit;">Cela correspond à la texture, mais ce n'est pas ce dont nous avons besoin. </font><font style="vertical-align: inherit;">Nous devons mettre à l'échelle la texture principale du matériau afin qu'elle corresponde à la taille de la grille. </font><font style="vertical-align: inherit;">Vous pouvez le faire en appelant la méthode </font></font><code>SetTextureScale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matérielle avec le nom de la propriété de texture ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et la taille bidimensionnelle. </font><font style="vertical-align: inherit;">Nous pouvons utiliser directement la taille du champ, qui est indirectement convertie en valeur </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; m.SetTextureScale(<span class="hljs-string"><span class="hljs-string">"_MainTex"</span></span>, size); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/d2a/b85/edbd2ab858e40a61d5f89452a8809b33.png" width="230" height="230" alt="sans"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/91a/ae5/8bd91aae589309dbd64994bb10a935a9.png" width="230" height="230" alt="avec"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grille à l'échelle avec visualisation du chemin activée et désactivée. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc, à ce stade, nous avons obtenu un champ fonctionnel pour un jeu de tuiles du genre tower defense. </font><font style="vertical-align: inherit;">Dans le prochain tutoriel, nous ajouterons des ennemis. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dépôt</font></font></a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pdf</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449798/">https://habr.com/ru/post/fr449798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449784/index.html">Dans quels cas cela vaut la peine d'utiliser Django (et dans lequel ce n'est pas nécessaire)</a></li>
<li><a href="../fr449788/index.html">Brave Browser présente une plate-forme publicitaire basée sur les récompenses</a></li>
<li><a href="../fr449790/index.html">Développement produit Visual Aid: Design</a></li>
<li><a href="../fr449794/index.html">Réseaux d'antennes adaptatives: comment ça marche? (Bases)</a></li>
<li><a href="../fr449796/index.html">Une fille</a></li>
<li><a href="../fr449802/index.html">Programmeur de carrière. Partie 1. Le premier programme</a></li>
<li><a href="../fr449804/index.html">Aperçu de la thérapie anti-âge pour les biohackers</a></li>
<li><a href="../fr449806/index.html">Programmeur de carrière. Partie 2. École ou auto-éducation</a></li>
<li><a href="../fr449808/index.html">Expérience Positive Hack Days 9: comment la pensée critique aide dans la vie et le travail</a></li>
<li><a href="../fr449814/index.html">Windows XP est officiellement mort, enfin enfin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>