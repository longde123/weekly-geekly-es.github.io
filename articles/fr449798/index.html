<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíí üêû üë©üèæ‚Äçü§ù‚Äçüë®üèº Cr√©ation de Tower Defense dans Unity, partie 1 üßëüèΩ üë®üèΩ‚Äçüíª üõ©Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le terrain 


- Cr√©ation d'un champ de tuiles. 
- Chemins de recherche utilisant une recherche en largeur. 
- Impl√©mentez la prise en charge des tuile...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation de Tower Defense dans Unity, partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449798/"><h1>  Le terrain </h1><br><ul><li>  Cr√©ation d'un champ de tuiles. </li><li>  Chemins de recherche utilisant une recherche en largeur. </li><li>  Impl√©mentez la prise en charge des tuiles vides et finales, ainsi que des tuiles murales. </li><li>  Modification du contenu en mode jeu. </li><li>  Affichage facultatif des champs et des chemins de la grille. </li></ul><br>  Ceci est la premi√®re partie d'une s√©rie de tutoriels sur la cr√©ation d'un jeu de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tower defense</a> simple.  Dans cette partie, nous envisagerons de cr√©er un terrain de jeu, de trouver un chemin et de placer les tuiles et les murs finaux. <br><br>  Le didacticiel a √©t√© cr√©√© dans Unity 2018.3.0f2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3d/ae4/591/c3dae459169a0a7f0ce240763b91d55c.jpg"></div><br>  <i>Un champ pr√™t √† l'emploi dans un jeu de tuiles de genre tower defense.</i> <br><br><h2>  Jeu de Tower Defense </h2><br>  Le Tower Defense est un genre dans lequel le but du joueur est de d√©truire des foules d'ennemis jusqu'√† ce qu'ils atteignent leur point final.  Le joueur atteint son objectif en construisant des tours qui attaquent les ennemis.  Ce genre a beaucoup de variations.  Nous allons cr√©er un jeu avec un champ de tuiles.  Les ennemis se d√©placeront √† travers le champ vers leur point final, et le joueur leur cr√©era des obstacles. <br><a name="habracut"></a><br>  Je suppose que vous avez d√©j√† √©tudi√© une s√©rie de tutoriels sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gestion des objets</a> . <br><br><h3>  Le terrain </h3><br>  Le terrain de jeu est la partie la plus importante du jeu, nous allons donc le cr√©er en premier.  Ce sera un objet de jeu avec son propre composant <code>GameBoard</code> , qui peut √™tre initialis√© en d√©finissant la taille en deux dimensions, pour laquelle nous pouvons utiliser la valeur de <code>Vector2Int</code> .  Le champ devrait fonctionner avec n'importe quelle taille, mais nous choisirons la taille ailleurs, nous allons donc cr√©er une m√©thode <code>Initialize</code> commune pour cela. <br><br>  De plus, nous visualisons le champ avec un quadrilat√®re, qui d√©signera la terre.  Nous ne ferons pas de l'objet champ lui-m√™me un quadrilat√®re, mais nous y ajouterons un objet enfant quad.  Lors de l'initialisation, nous rendrons l'√©chelle XY de la terre √©gale √† la taille du champ.  Autrement dit, chaque tuile aura une taille d'une unit√© de mesure carr√©e pour le moteur. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform ground = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; Vector2Int size; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Pourquoi d√©finir explicitement Ground √† la valeur par d√©faut?</b> <div class="spoiler_text">  L'id√©e est que tout ce qui est personnalisable via l'√©diteur Unity est accessible via des champs cach√©s s√©rialis√©s.  Il est n√©cessaire que ces champs ne puissent √™tre modifi√©s que dans l'inspecteur.  Malheureusement, l'√©diteur Unity affichera constamment un compilateur avertissant que la valeur n'est jamais affect√©e.  Nous pouvons supprimer cet avertissement en d√©finissant explicitement la valeur par d√©faut du champ.  Vous pouvez √©galement attribuer <code>null</code> , mais je l'ai fait de mani√®re √† montrer explicitement que nous utilisons simplement la valeur par d√©faut, qui n'est pas une v√©ritable r√©f√©rence √† la terre, nous utilisons donc la <code>default</code> . </div></div><br>  Cr√©ez un objet champ dans une nouvelle sc√®ne et ajoutez un quad enfant avec un mat√©riau qui ressemble √† la terre.  Puisque nous cr√©ons un jeu prototype simple, un mat√©riau vert uniforme sera suffisant.  Faites pivoter le quad de 90 ¬∞ le long de l'axe X afin qu'il se trouve sur le plan XZ. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db9/9b8/9af/db99b89afcc551541f1f6adbe4816e54.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/f7c/77d/fa8f7c77d6697bca5e3c8823f5adcd86.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/467/015/f2a467015b8eefc8ca956eaec61d50dc.png"></div><br>  <i>Terrain de jeu.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi ne pas positionner le jeu sur l'avion XY?</b> <div class="spoiler_text">  Bien que le jeu se d√©roule dans un espace 2D, nous le rendrons en 3D, avec des ennemis 3D et une cam√©ra pouvant √™tre d√©plac√©e par rapport √† un certain point.  Le plan XZ est plus pratique pour cela et correspond √† l'orientation skybox standard utilis√©e pour l'√©clairage ambiant. </div></div><br><h3>  Le jeu </h3><br>  Ensuite, cr√©ez un composant de <code>Game</code> qui sera responsable de l'ensemble du jeu.  A ce stade, cela signifie qu'il initialise le champ.  Nous rendons simplement la taille personnalisable via l'inspecteur et for√ßons le composant √† initialiser le champ lorsqu'il se r√©veille.  Utilisons la taille par d√©faut de 11 √ó 11. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Game</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Vector2Int boardSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); [SerializeField] GameBoard board = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize); } }</code> </pre> <br>  La taille des champs ne peut √™tre que positive et il est peu logique de cr√©er un champ avec une seule tuile.  Limitons donc le minimum √† 2 √ó 2.  Cela peut √™tre fait en ajoutant la m√©thode <code>OnValidate</code> , en limitant de force les valeurs minimales. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnValidate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.x &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.x = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.y &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Quand on appelle Onvalidate?</b> <div class="spoiler_text">  S'il existe, l'√©diteur Unity l'appelle pour les composants apr√®s les avoir modifi√©s.  Y compris lors de leur ajout √† l'objet de jeu, apr√®s le chargement de la sc√®ne, apr√®s la recompilation, apr√®s le changement dans l'√©diteur, apr√®s l'annulation / la nouvelle tentative et apr√®s la r√©initialisation du composant. <br><br>  <code>OnValidate</code> est le seul endroit du code o√π vous pouvez affecter des valeurs aux champs de configuration des composants. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/15d/efd/7ae15defd1e838186f922fc30d346b17.png"></div><br>  <i>Objet de jeu.</i> <br><br>  Maintenant, lorsque vous d√©marrez le mode de jeu, nous recevrons un champ avec la bonne taille.  Pendant le jeu, positionnez la cam√©ra de mani√®re √† ce que tout le plateau soit visible, copiez son composant de transformation, quittez le mode de jeu et collez les valeurs du composant.  Dans le cas d'un champ 11 √ó 11 √† l'origine, pour obtenir une vue pratique d'en haut, vous pouvez positionner la cam√©ra en position (0.10.0) et la faire pivoter de 90 ¬∞ le long de l'axe X. Nous laisserons la cam√©ra dans cette position fixe, mais c'est possible changer √† l'avenir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/45c/421/eb545c421fdca09acf1258a2fac9e183.png"></div><br>  <i>Cam√©ra sur le terrain.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Comment copier et coller des valeurs de composants?</b> <div class="spoiler_text">  Gr√¢ce au menu d√©roulant qui appara√Æt lorsque vous cliquez sur le bouton avec l'engrenage dans le coin sup√©rieur droit du composant. </div></div><br><h3>  Tuile pr√©fabriqu√©e </h3><br>  Le champ se compose de carreaux carr√©s.  Les ennemis pourront se d√©placer d'une tuile √† l'autre, en traversant les bords, mais pas en diagonale.  Le mouvement se produira toujours vers le point final le plus proche.  D√©signons graphiquement la direction du mouvement le long de la tuile avec une fl√®che.  Vous pouvez t√©l√©charger la texture de la fl√®che <a href="">ici</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/l6/os/tfl6oszqhi93v6aqlllrp1yuhli.png"></div><br>  <i>Fl√®che sur fond noir.</i> <br><br>  Placez la texture de la fl√®che dans votre projet et activez l'option <em>Alpha comme transparence</em> .  Cr√©ez ensuite un mat√©riau pour la fl√®che, qui peut √™tre le mat√©riau par d√©faut pour lequel le mode de d√©coupe est s√©lectionn√©, puis s√©lectionnez la fl√®che comme texture principale. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/2d6/56c/bfb2d656c07931b8f59ef11715eee93b.png"></div><br>  <i>Mat√©riel de fl√®che.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi utiliser le mode de rendu d√©coup√©?</b> <div class="spoiler_text">  Il vous permet d'obscurcir la fl√®che √† l'aide du pipeline de rendu Unity standard. </div></div><br>  Pour d√©signer chaque tuile du jeu, nous utiliserons l'objet du jeu.  Chacun d'eux aura son propre quadruple avec un mat√©riau de fl√®che, tout comme le champ a un quadruple de terre.  Nous ajouterons √©galement des tuiles au composant GameTile avec un lien vers leur fl√®che. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTile</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform arrow = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }</code> </pre> <br>  Cr√©ez un objet tuile et transformez-le en pr√©fabriqu√©.  Les tuiles seront au ras du sol, alors relevez un peu la fl√®che pour √©viter les probl√®mes de profondeur lors du rendu.  Faites √©galement un zoom arri√®re un peu, de sorte qu'il y ait peu d'espace entre les fl√®ches adjacentes.  Un d√©calage Y de 0,001 et une √©chelle de 0,8 identique pour tous les axes feront l'affaire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/02b/6d8/f1202b6d8f8f33593bf56ef0d8665537.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/964/1ac/a4b/9641aca4b874f48c3765af10e2c83157.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/7a3/c9f/df77a3c9f539083eab845be6b9c62919.png"></div><br>  <i>Tuile pr√©fabriqu√©e.</i> <br><br><div class="spoiler">  <b class="spoiler_title">O√π est la hi√©rarchie de tuiles pr√©fabriqu√©es?</b> <div class="spoiler_text">  Vous pouvez ouvrir le mode d'√©dition de pr√©fabriqu√© en double-cliquant sur l'√©l√©ment pr√©fabriqu√© ou en s√©lectionnant le pr√©fabriqu√© et en cliquant sur le bouton <em>Ouvrir le pr√©fabriqu√©</em> dans l'inspecteur.  Vous pouvez quitter le mode d'√©dition pr√©fabriqu√© en cliquant sur le bouton avec une fl√®che dans le coin sup√©rieur gauche de son en-t√™te de hi√©rarchie. </div></div><br>  Notez que les tuiles elles-m√™mes ne doivent pas n√©cessairement √™tre des objets de jeu.  Ils ne sont n√©cessaires que pour suivre l'√©tat du champ.  Nous pourrions utiliser la m√™me approche que pour le comportement dans la s√©rie de didacticiels sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gestion d'objets</a> .  Mais dans les premiers stades de jeux simples ou de prototypes d'objets de jeu, nous sommes tr√®s heureux.  Cela peut √™tre chang√© √† l'avenir. <br><br><h3>  Nous avons des tuiles </h3><br>  Pour cr√©er des tuiles, le <code>GameBoard</code> doit avoir un lien vers le pr√©fabriqu√© de tuiles. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTile tilePrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/363/6c2/044/3636c204442368c58858152a7c3efee2.png"></div><br>  <i>Lien vers la tuile pr√©fabriqu√©e.</i> <br><br>  Il peut ensuite cr√©er ses instances √† l'aide d'une double boucle sur deux dimensions de la grille.  Bien que la taille soit exprim√©e en X et Y, nous disposerons les tuiles sur le plan XZ, ainsi que le champ lui-m√™me.  Puisque le champ est centr√© par rapport √† l'origine, nous devons soustraire la taille correspondante moins une divis√©e par deux des composants de la position de la tuile.  Veuillez noter que ce doit √™tre une division en virgule flottante, sinon cela ne fonctionnera pas pour des tailles √©gales. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2( (size.x - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, (size.y - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++) { GameTile tile = Instantiate(tilePrefab); tile.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); tile.transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( x - offset.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, y - offset.y ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/391/265/640/391265640fe99dd10be005de76ce93f3.png"></div><br>  <i>Cr√©ation d'instances de tuiles.</i> <br><br>  Plus tard, nous aurons besoin d'acc√©der √† ces tuiles, nous allons donc les suivre dans un tableau.  Nous n'avons pas besoin d'une liste, car apr√®s l'initialisation, la taille du champ ne changera pas. <br><br><pre> <code class="cs hljs"> GameTile[] tiles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { GameTile tile = tiles[i] = Instantiate(tilePrefab); ‚Ä¶ } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Comment fonctionne cette mission?</b> <div class="spoiler_text">  Il s'agit d'une affectation li√©e.  Dans ce cas, cela signifie que nous attribuons un lien √† l'instance de tuile √† la fois √† l'√©l√©ment de tableau et √† la variable locale.  Ces op√©rations fonctionnent de la m√™me mani√®re que le code ci-dessous. <br><br><pre> <code class="cs hljs">GameTile t = Instantiate(tilePrefab); tiles[i] = t; GameTile tile = t;</code> </pre> </div></div><br><h2>  Rechercher un moyen </h2><br>  √Ä ce stade, chaque tuile a une fl√®che, mais elles pointent toutes dans la direction positive de l'axe Z, que nous interpr√©terons comme nord.  L'√©tape suivante consiste √† d√©terminer la bonne direction pour la tuile.  Nous le faisons en trouvant le chemin que les ennemis doivent suivre jusqu'au point final. <br><br><h3>  Voisins de tuile </h3><br>  Les chemins vont de tuile en tuile, au nord, √† l'est, au sud ou √† l'ouest.  Pour simplifier la recherche, <code>GameTile</code> des liens de suivi <code>GameTile</code> vers ses quatre voisins. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west;</code> </pre> <br>  Les relations entre voisins sont sym√©triques.  Si la tuile est le voisin oriental de la deuxi√®me tuile, alors la seconde est le voisin occidental de la premi√®re.  Ajoutez une m√©thode statique g√©n√©rale √† <code>GameTile</code> pour d√©finir cette relation entre deux tuiles. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Pourquoi utiliser une m√©thode statique?</b> <div class="spoiler_text">  Nous pouvons en faire une m√©thode d'instance avec un seul param√®tre, et dans ce cas, nous l'appellerons <code>eastTile.MakeEastWestNeighbors(westTile)</code> ou quelque chose comme √ßa.  Mais dans les cas o√π il n'est pas clair sur laquelle des tuiles la m√©thode doit √™tre appel√©e, il est pr√©f√©rable d'utiliser des m√©thodes statiques.  Les exemples sont les m√©thodes <code>Distance</code> et <code>Dot</code> de la classe <code>Vector3</code> . </div></div><br>  Une fois connect√©, il ne devrait jamais changer.  Si cela se produit, nous avons fait une erreur dans le code.  Vous pouvez le v√©rifier en comparant les deux liens avant d'attribuer des valeurs √† <code>null</code> et en affichant une erreur si elle est incorrecte.  Vous pouvez utiliser la m√©thode <code>Debug.Assert</code> pour <code>Debug.Assert</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( west.east == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; east.west == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Que fait Debug.Assert?</b> <div class="spoiler_text">  Si le premier argument est <code>false</code> , il affiche une erreur de condition, en utilisant le deuxi√®me argument s'il est sp√©cifi√©.  Un tel appel est inclus uniquement dans les versions de test, mais pas dans les versions.  Par cons√©quent, c'est un bon moyen d'ajouter des v√©rifications au cours du processus de d√©veloppement qui n'affecteront pas la version finale. </div></div><br>  Ajoutez une m√©thode similaire pour cr√©er des relations entre les voisins du nord et du sud. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeNorthSouthNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile north, GameTile south</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( south.north == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; north.south == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); south.north = north; north.south = south; }</code> </pre> <br>  Nous pouvons √©tablir cette relation lors de la cr√©ation de tuiles dans <code>GameBoard.Initialize</code> .  Si la coordonn√©e X est sup√©rieure √† z√©ro, alors nous pouvons cr√©er une relation est-ouest entre les tuiles actuelles et pr√©c√©dentes.  Si la coordonn√©e Y est sup√©rieure √† z√©ro, alors nous pouvons cr√©er une relation nord-sud entre la tuile actuelle et la tuile de la ligne pr√©c√©dente. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeEastWestNeighbors(tile, tiles[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeNorthSouthNeighbors(tile, tiles[i - size.x]); } } }</code> </pre> <br>  Notez que les tuiles sur les bords du champ n'ont pas quatre voisins.  Une ou deux r√©f√©rences voisines resteront <code>null</code> . <br><br><h3>  Distance et direction </h3><br>  Nous n'obligerons pas tous les ennemis √† chercher constamment le chemin.  Cela ne doit √™tre fait qu'une seule fois par tuile.  Ensuite, les ennemis pourront demander √† la tuile dans laquelle ils se trouvent o√π aller.  Nous <code>GameTile</code> ces informations dans <code>GameTile</code> en ajoutant un lien vers la <code>GameTile</code> de chemin suivante.  En outre, nous enregistrerons √©galement la distance jusqu'au point final, exprim√©e en nombre de tuiles qui doivent √™tre visit√©es avant que l'ennemi n'atteigne le point final.  Pour les ennemis, ces informations sont inutiles, mais nous les utiliserons pour trouver les chemins les plus courts. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west, nextOnPath; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br>  Chaque fois que nous d√©cidons que nous devons rechercher des chemins, nous devons initialiser les donn√©es de chemin.  Jusqu'√† ce que le chemin soit trouv√©, il n'y a pas de tuile suivante et la distance peut √™tre consid√©r√©e comme infinie.  Nous pouvons imaginer cela comme la valeur enti√®re maximale possible de <code>int.MaxValue</code> .  Ajoutez une m√©thode g√©n√©rique <code>ClearPath</code> pour r√©initialiser le <code>GameTile</code> √† cet √©tat. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Les chemins ne peuvent √™tre recherch√©s que si nous avons un point de terminaison.  Cela signifie que la tuile doit devenir le point de terminaison.  Une telle tuile a une distance de z√©ro, et elle n'a pas la derni√®re tuile, car le chemin se termine dessus.  Ajoutez une m√©thode g√©n√©rique qui transforme une tuile en point de terminaison. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BecomeDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  En fin de compte, toutes les tuiles devraient se transformer en un chemin, de sorte que leur distance ne sera plus √©gale √† <code>int.MaxValue</code> .  Ajoutez une propri√©t√© getter pratique pour v√©rifier si la tuile a actuellement un chemin. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath =&gt; distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Comment fonctionne cette propri√©t√©?</b> <div class="spoiler_text">  Il s'agit d'une entr√©e raccourcie pour une propri√©t√© getter contenant une seule expression.  Il fait la m√™me chose que le code ci-dessous. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } }</code> </pre> <br>  L'op√©rateur de fl√®che <code>=&gt;</code> peut √©galement √™tre utilis√© individuellement pour le getter et le setter de propri√©t√©s, pour les corps de m√©thodes, les constructeurs et dans d'autres endroits. </div></div><br><h3>  Nous grandissons </h3><br>  Si nous avons une tuile avec un chemin, nous pouvons la laisser pousser un chemin vers l'un de ses voisins.  Initialement, la seule tuile avec le chemin est le point final, donc nous partons de la distance z√©ro et l'augmentons √† partir d'ici, en nous d√©pla√ßant dans la direction oppos√©e au mouvement des ennemis.  Autrement dit, tous les voisins imm√©diats du point de terminaison auront une distance de 1, et tous les voisins de ces tuiles auront une distance de 2, et ainsi de suite. <br><br>  Ajoutez une m√©thode masqu√©e <code>GameTile</code> pour d√©velopper le chemin vers l'un de ses voisins, sp√©cifi√© via le param√®tre.  La distance par rapport au voisin est une de plus que la tuile actuelle, et le chemin du voisin indique la tuile actuelle.  Cette m√©thode ne doit √™tre appel√©e que pour les tuiles qui ont d√©j√† un chemin, v√©rifions donc cela avec assert. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  L'id√©e est que nous appelons cette m√©thode une fois pour chacun des quatre voisins de la tuile.  √âtant donn√© que certains de ces liens seront <code>null</code> , nous allons v√©rifier cela et arr√™ter l'ex√©cution, le cas √©ch√©ant.  De plus, si un voisin a d√©j√† un chemin, nous ne devons rien faire et cesser de le faire. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  La fa√ßon dont <code>GameTile</code> suit ses voisins est inconnue du reste du code.  Par cons√©quent, <code>GrowPathTo</code> est masqu√©.  Nous ajouterons des m√©thodes g√©n√©rales qui indiquent √† la tuile de se d√©velopper dans une certaine direction, en appelant indirectement <code>GrowPathTo</code> .  Mais le code qui recherche dans tout le champ doit garder une trace des tuiles visit√©es.  Par cons√©quent, nous lui ferons retourner un voisin ou <code>null</code> si l'ex√©cution est termin√©e. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor; }</code> </pre> <br>  Ajoutez maintenant des m√©thodes pour d√©velopper des chemins dans des directions sp√©cifiques. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathNorth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(north); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathEast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(east); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathSouth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(south); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathWest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(west);</code> </pre> <br><h3>  Recherche large </h3><br>  <code>GameBoard</code> doit <code>GameBoard</code> que toutes les tuiles contiennent les donn√©es de chemin correctes.  Pour ce faire, nous effectuons une recherche en premier.  Commen√ßons par la tuile de point de terminaison, puis d√©veloppons le chemin vers ses voisins, puis vers les voisins de ces tuiles, etc.  √Ä chaque √©tape, la distance augmente d'une unit√© et les chemins ne croissent jamais en direction des tuiles qui ont d√©j√† des chemins.  Cela garantit que toutes les tuiles pointeront le long du chemin le plus court vers le point final. <br><br><div class="spoiler">  <b class="spoiler_title">Que diriez-vous de trouver un chemin en utilisant A *?</b> <div class="spoiler_text">  L'algorithme A <sup>*</sup> est le d√©veloppement √©volutif de la recherche en largeur d'abord.  Il est utile lorsque nous recherchons le seul chemin le plus court.  Mais nous avons besoin de tous les chemins les plus courts, donc A <sup>*</sup> ne donne aucun avantage.  Pour des exemples de recherche en largeur et A <sup>*</sup> sur une grille d'hexagones avec animation, voir la s√©rie de tutoriels sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cartes d'hexagones</a> . </div></div><br>  Pour effectuer la recherche, nous devons suivre les tuiles que nous avons ajout√©es au chemin, mais √† partir desquelles nous n'avons pas encore d√©velopp√© le chemin.  Cette collection de tuiles est souvent appel√©e la fronti√®re de recherche.  Il est important que les tuiles soient trait√©es dans le m√™me ordre dans lequel elles sont ajout√©es √† la bordure, utilisons donc la <code>Queue</code> .  Plus tard, nous devrons effectuer la recherche plusieurs fois, nous allons donc le d√©finir comme le champ du <code>GameBoard</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ Queue&lt;GameTile&gt; searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;GameTile&gt;(); ‚Ä¶ }</code> </pre> <br>  Pour que l'√©tat du terrain de jeu soit toujours vrai, nous devons trouver les chemins √† la fin de <code>Initialize</code> , mais placer le code dans une m√©thode <code>FindPaths</code> distincte.  Tout d'abord, vous devez effacer le chemin de toutes les tuiles, puis faire d'une tuile le point final et l'ajouter √† la bordure.  S√©lectionnons d'abord la premi√®re tuile.  Comme les <code>tiles</code> sont un tableau, nous pouvons utiliser la <code>foreach</code> sans crainte de pollution de la m√©moire.  Si nous passons plus tard d'un tableau √† une liste, nous devrons √©galement remplacer les boucles <code>foreach</code> par <code>for</code> boucles <code>for</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ FindPaths(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Ensuite, nous devons prendre une tuile de la fronti√®re et d√©velopper un chemin vers tous ses voisins, en les ajoutant tous √† la fronti√®re.  Nous allons d'abord nous d√©placer vers le nord, puis vers l'est, le sud et enfin vers l'ouest. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  Nous r√©p√©tons cette √©tape, alors qu'il y a des tuiles √† la fronti√®re. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  La croissance d'un chemin ne nous m√®ne pas toujours √† une nouvelle tuile.  Avant d'ajouter √† la file d'attente, nous devons v√©rifier la valeur de <code>null</code> , mais nous pouvons reporter la v√©rification de <code>null</code> jusqu'√† la sortie de la file d'attente. <br><br><pre> <code class="cs hljs"> GameTile tile = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br><h3>  Afficher les chemins </h3><br>  Nous avons maintenant un champ contenant les bons chemins, mais jusqu'√† pr√©sent, nous ne voyons pas cela.  Vous devez configurer les fl√®ches afin qu'elles pointent le long du chemin √† travers leurs tuiles.  Cela peut √™tre fait en les tournant.  Comme ces virages sont toujours les m√™mes, nous ajoutons au <code>GameTile</code> un champ <code>Quaternion</code> statique pour chacune des directions. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Quaternion northRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), eastRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), southRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">180f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), westRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">270f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>);</code> </pre> <br>  Ajoutez √©galement la m√©thode g√©n√©rale <code>ShowPath</code> .  Si la distance est nulle, alors la tuile est le point final et il n'y a rien vers quoi pointer, alors d√©sactivez sa fl√®che.  Sinon, activez la fl√®che et r√©glez sa rotation.  La direction souhait√©e peut √™tre d√©termin√©e en comparant <code>nextOnPath</code> avec ses voisins. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance == <span class="hljs-number"><span class="hljs-number">0</span></span>) { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); arrow.localRotation = nextOnPath == north ? northRotation : nextOnPath == east ? eastRotation : nextOnPath == south ? southRotation : westRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appelez cette m√©thode pour toutes les tuiles √† la fin </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/4fe/4d5/b2d4fe4d511b4e729910ea78b267f268.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trouve des moyens.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ne transformons-nous pas la fl√®che directement en GrowPathTo?</font></font></b> <div class="spoiler_text">      .     .    ,          <code>FindPaths</code> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modifier la priorit√© de recherche </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'av√®re que lorsque le point final est le coin sud-ouest, tous les chemins vont exactement vers l'ouest jusqu'√† ce qu'ils atteignent le bord du champ, apr√®s quoi ils tournent vers le sud. </font><font style="vertical-align: inherit;">Tout est vrai ici, car il n'y a vraiment pas de chemins plus courts vers le point final, car les mouvements diagonaux sont impossibles. </font><font style="vertical-align: inherit;">Cependant, il existe de nombreux autres chemins les plus courts qui peuvent sembler plus beaux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour mieux comprendre pourquoi de tels chemins sont trouv√©s, d√©placez le point final au centre de la carte. </font><font style="vertical-align: inherit;">Avec une taille de champ impaire, ce n'est qu'une tuile au milieu du tableau.</font></font><br><br><pre> <code class="cs hljs"> tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d3/d09/d78/6d3d09d7844fbe6a4aaf4618449598de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Point d'arriv√©e au centre.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le r√©sultat semble logique si vous vous souvenez du fonctionnement de la recherche. Puisque nous ajoutons des voisins dans l'ordre nord-est-sud-ouest, le nord a la plus haute priorit√©. Puisque nous effectuons la recherche dans l'ordre inverse, cela signifie que la derni√®re direction que nous avons parcourue est le sud. C'est pourquoi seules quelques fl√®ches pointent vers le sud et beaucoup pointent vers l'est. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez modifier le r√©sultat en d√©finissant les priorit√©s des directions. √âchangeons l'est et le sud. Nous devons donc obtenir la sym√©trie nord-sud et est-ouest.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest())</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/2c7/0b7/a9a2c70b7d7d178b041f30c11d256ad3.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ordre de recherche est nord-sud-est-ouest. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble plus joli, mais il vaut mieux que les chemins changent de direction, s'approchant du mouvement diagonal o√π il aura l'air naturel. </font><font style="vertical-align: inherit;">Nous pouvons le faire en inversant les priorit√©s de recherche des tuiles voisines dans un motif en damier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu de d√©terminer quel type de mosa√Øque nous traitons pendant la recherche, nous ajoutons √† la </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√© g√©n√©rale qui indique si la mosa√Øque actuelle est une alternative.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsAlternative { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons d√©finir cette propri√©t√© dans </font></font><code>GameBoard.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tout d'abord, marquez les tuiles comme alternative si leur coordonn√©e X est paire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que fait l'op√©ration (x &amp; 1) == 0?</font></font></b> <div class="spoiler_text">   ‚Äî     (AND).            .       1,       1.  10101010  00001111   00001010. <br><br>       .      0  1.     1, 2, 3, 4   1, 10, 11, 100.  ,       . <br><br>    AND  ,  ,    .    ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxi√®mement, nous changeons le signe du r√©sultat si leur coordonn√©e Y est paire. </font><font style="vertical-align: inherit;">Nous allons donc cr√©er un mod√®le d'√©checs.</font></font><br><br><pre> <code class="cs hljs"> tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((y &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { tile.IsAlternative = !tile.IsAlternative; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous gardons le m√™me ordre que la recherche de tuiles alternative, mais de le </font><font style="vertical-align: inherit;">faire revenir √† toutes les </font><font style="vertical-align: inherit;">autres tuiles. </font><font style="vertical-align: inherit;">Cela forcera le chemin vers le mouvement diagonal et cr√©era des zigzags.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.IsAlternative) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Enqueue(tile.GrowPathWest()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathNorth()); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b43/e3a/d63/b43e3ad6370a6b552073b4f0b4cf0e8b.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordre de recherche variable.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changer les tuiles </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, toutes les tuiles sont vides. </font><font style="vertical-align: inherit;">Une tuile est utilis√©e comme point de terminaison, mais en plus de l'absence d'une fl√®che visible, elle ressemble √† tout le monde. </font><font style="vertical-align: inherit;">Nous ajouterons la possibilit√© de changer les tuiles en pla√ßant des objets dessus.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contenu des tuiles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les objets en mosa√Øque eux-m√™mes sont simplement un moyen de suivre les informations sur les mosa√Øques. </font><font style="vertical-align: inherit;">Nous ne modifions pas ces objets directement. </font><font style="vertical-align: inherit;">Ajoutez plut√¥t du contenu s√©par√© et placez-le sur le terrain. </font><font style="vertical-align: inherit;">Pour l'instant, nous pouvons distinguer entre les tuiles vides et les tuiles de point de terminaison. </font><font style="vertical-align: inherit;">Pour indiquer ces cas, cr√©ez une √©num√©ration </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, cr√©ez un type de composant </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui vous permet de d√©finir le type de son contenu via l'inspecteur, et l'acc√®s √† celui-ci se fera via une propri√©t√© getter commune.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] GameTileContentType type = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentType Type =&gt; type; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous cr√©erons des pr√©fabriqu√©s pour deux types de contenu, chacun ayant un composant </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec le type sp√©cifi√© correspondant. </font><font style="vertical-align: inherit;">Utilisons un cube bleu aplati pour d√©signer les tuiles d'extr√©mit√©. </font><font style="vertical-align: inherit;">Comme il est presque plat, il n'a pas besoin de collisionneur. </font><font style="vertical-align: inherit;">Pour pr√©fabriquer du contenu vide, utilisez un objet de jeu vide.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f55/25d/8db/f5525d8db707ff187e17ce96a11d86ae.png" width="320" height="262" alt="destination"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/463/e19/c6f463e198abca6134b7bc74d3207833.png" width="320" height="176" alt="vide"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√©fabriqu√©s du point de terminaison et du contenu vide. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous donnerons l'objet de contenu aux tuiles vides, car alors toutes les tuiles auront toujours le contenu, ce qui signifie que nous n'aurons pas besoin de v√©rifier l'√©galit√© des liens vers les contenus </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Content Factory </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour rendre le contenu modifiable, nous allons √©galement cr√©er une fabrique pour cela, en utilisant la m√™me approche que dans le didacticiel de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gestion des objets</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cela signifie que vous </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devez garder une trace de votre usine d'origine, qui ne doit √™tre d√©finie qu'une seule fois, et vous renvoyer √† l'usine dans la m√©thode </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory originFactory; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentFactory OriginFactory { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; originFactory; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(originFactory == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined origin factory!"</span></span>); originFactory = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela suppose l'existence </font></font><code>GameTileContentFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, par cons√©quent, nous allons cr√©er un type d'objet scriptable pour cela avec la m√©thode requise </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">√Ä ce stade, nous ne nous occuperons pas de la cr√©ation d'une usine enti√®rement fonctionnelle qui utilise le contenu, nous allons donc la faire simplement d√©truire le contenu. </font><font style="vertical-align: inherit;">Plus tard, il sera possible d'ajouter la r√©utilisation des objets √† l'usine sans changer le reste du code.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.SceneManagement; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContentFactory</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reclaim</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent content</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(content.OriginFactory == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"Wrong factory reclaimed!"</span></span>); Destroy(content.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une m√©thode cach√©e </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† l' </font><font style="vertical-align: inherit;">usine </font><font style="vertical-align: inherit;">avec un pr√©fabriqu√© comme param√®tre. </font><font style="vertical-align: inherit;">Ici, nous sautons √† nouveau la r√©utilisation des objets. </font><font style="vertical-align: inherit;">Il cr√©e une instance de l'objet, d√©finit son usine d'origine, le d√©place vers la sc√®ne d'usine et le renvoie.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent prefab</span></span></span><span class="hljs-function">)</span></span> { GameTileContent instance = Instantiate(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; MoveToFactoryScene(instance.gameObject); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'instance a √©t√© d√©plac√©e vers la sc√®ne de contenu d'usine, qui peut √™tre cr√©√©e selon les besoins. </font><font style="vertical-align: inherit;">Si nous sommes dans l'√©diteur, avant de cr√©er une sc√®ne, nous devons v√©rifier si elle existe, au cas o√π nous la perdrions de vue lors d'un red√©marrage √† chaud.</font></font><br><br><pre> <code class="cs hljs"> Scene contentScene; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveToFactoryScene</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.isEditor) { contentScene = SceneManager.GetSceneByName(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { contentScene = SceneManager.CreateScene(name); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentScene = SceneManager.CreateScene(name); } } SceneManager.MoveGameObjectToScene(o, contentScene); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous n'avons que deux types de contenu, il suffit donc d'ajouter deux champs de configuration pr√©fabriqu√©s pour eux. </font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent destinationPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] GameTileContent emptyPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La derni√®re chose √† faire pour que l'usine fonctionne est de cr√©er une m√©thode g√©n√©rale </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un param√®tre </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui re√ßoit une instance du pr√©fabriqu√© correspondant.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est-il obligatoire d'ajouter une instance distincte de contenu vide √† chaque tuile?</font></font></b> <div class="spoiler_text">       ,               .         .  ,        - , , , ,    .     ,       .     ,        ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ons un actif d'usine et configurons ses liens vers les pr√©fabriqu√©s. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7eb/75f/1cd/7eb75f1cd4bed3c72ffd7f0c42b69cbe.png" width="320" height="106"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content Factory </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et puis passez le </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien √† l'usine.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContentFactory tileContentFactory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/d6a/506/b12d6a5067fa91177dbed14a876f8b3d.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeu avec une usine.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Taper sur une tuile </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour changer de champ, nous devons pouvoir s√©lectionner une tuile. Nous le rendrons possible en mode jeu. Nous √©mettrons un faisceau dans la sc√®ne √† l'endroit o√π le joueur a cliqu√© sur la fen√™tre de jeu. Si la poutre croise la tuile, le joueur la touche, c'est-√†-dire qu'elle doit √™tre chang√©e. </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g√©rera l'entr√©e du joueur, mais sera responsable de d√©terminer la tuile que le joueur a touch√©e </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous les rayons ne se croisent pas avec la tuile, donc parfois nous ne recevrons rien. Par cons√©quent, nous ajoutons √† la </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>GetTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui renvoie toujours toujours initialement </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(cela signifie que la tuile n'a pas √©t√© trouv√©e).</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour d√©terminer si un rayon a travers√© une tuile, nous devons appeler </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en sp√©cifiant le rayon comme argument. </font><font style="vertical-align: inherit;">Il renvoie des informations sur la pr√©sence d'une intersection. </font><font style="vertical-align: inherit;">Si c'est le cas, nous pouvons retourner la tuile, bien que nous ne sachions pas encore laquelle, donc pour le moment nous la retournerons </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryGetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour savoir s'il y avait une intersection avec une tuile, nous avons besoin de plus d'informations sur l'intersection. </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut fournir ces informations √† l'aide du deuxi√®me param√®tre </font></font><code>RaycastHit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il s'agit du param√®tre de sortie, qui est indiqu√© par le mot </font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devant lui. </font><font style="vertical-align: inherit;">Cela signifie qu'un appel de m√©thode peut affecter une valeur √† la variable que nous lui transmettons.</font></font><br><br><pre> <code class="cs hljs"> RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons incorporer la d√©claration des variables utilis√©es pour les param√®tres de sortie, alors faisons-le. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne nous soucions pas avec quel collisionneur l'intersection s'est produite, nous utilisons simplement la position de l'intersection XZ pour d√©terminer la tuile. </font><font style="vertical-align: inherit;">Nous obtenons les coordonn√©es de la tuile en ajoutant la moiti√© de la taille du champ aux coordonn√©es du point d'intersection, puis en convertissant les r√©sultats en valeurs enti√®res. </font><font style="vertical-align: inherit;">En cons√©quence, l'index de tuile final sera sa coordonn√©e X plus la coordonn√©e Y multipli√©e par la largeur du champ.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais cela n'est possible que lorsque les coordonn√©es de la tuile sont dans le champ, nous allons donc v√©rifier cela. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, la tuile ne sera pas retourn√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; size.x &amp;&amp; y &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; y &lt; size.y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changement de contenu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour pouvoir modifier le contenu de la tuile, ajoutez-la √† la </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√© g√©n√©rale </font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Son getter renvoie simplement le contenu et le setter rejette le contenu pr√©c√©dent, le cas √©ch√©ant, et place le nouveau contenu.</font></font><br><br><pre> <code class="cs hljs"> GameTileContent content; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContent Content { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; content; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { content.Recycle(); } content = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; content.transform.localPosition = transform.localPosition; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est le seul endroit o√π vous devez v√©rifier le contenu </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car au d√©part, nous n'avons pas de contenu. </font><font style="vertical-align: inherit;">Pour garantir, nous ex√©cutons assert afin que le passeur ne soit pas appel√© avec </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Null assigned to content!"</span></span>); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin, nous avons besoin d'une entr√©e de joueur. </font><font style="vertical-align: inherit;">La conversion d'un clic de souris en rayon peut √™tre effectu√©e en appelant </font></font><code>ScreenPointToRay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec </font></font><code>Input.mousePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme argument. </font><font style="vertical-align: inherit;">L'appel doit √™tre effectu√© pour la cam√©ra principale, accessible via </font></font><code>Camera.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ajoutez la propri√©t√© c pour cela </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> Ray TouchRay =&gt; Camera.main.ScreenPointToRay(Input.mousePosition);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous ajoutons une m√©thode </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui v√©rifie si le bouton principal de la souris a √©t√© enfonc√© pendant la mise √† niveau. </font><font style="vertical-align: inherit;">Pour ce faire, appelez </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec z√©ro comme argument. </font><font style="vertical-align: inherit;">Si la touche a √©t√© enfonc√©e, nous traitons le toucher du joueur, c'est-√†-dire que nous prenons la tuile sur le terrain et d√©finissons le point final comme son contenu, en le prenant de l'usine.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { tile.Content = tileContentFactory.Get(GameTileContentType.Destination); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, nous pouvons transformer n'importe quelle tuile en point final en appuyant sur le curseur. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99a/f15/da3/99af15da39bfc08cb8886b98e0ae15df.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plusieurs points de terminaison.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faire le bon terrain </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous puissions transformer des tuiles en points de terminaison, cela n'affecte pas les chemins jusqu'√† pr√©sent. </font><font style="vertical-align: inherit;">De plus, nous n'avons pas encore d√©fini de contenu vide pour les tuiles. </font><font style="vertical-align: inherit;">Le maintien de l'exactitude et de l'int√©grit√© du champ est une t√¢che </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous allons donc lui donner la responsabilit√© de d√©finir le contenu de la tuile. </font><font style="vertical-align: inherit;">Pour l'impl√©menter, nous allons lui donner un lien vers la fabrique de contenu via sa m√©thode </font></font><code>Intialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et l'utiliser pour donner √† toutes les tuiles une instance de contenu vide.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory contentFactory; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.contentFactory = contentFactory; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ tile.Content = contentFactory.Get(GameTileContentType.Empty); } } FindPaths(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, je </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois transf√©rer mon usine sur le terrain.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ne pas ajouter un champ de configuration d'usine au GameBoard?</font></font></b> <div class="spoiler_text">   ,    ,   .        ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous avons maintenant plusieurs points de terminaison, nous le modifions </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il appelle </font></font><code>BecomeDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chacun d'eux et les ajoute tous √† la fronti√®re. </font><font style="vertical-align: inherit;">Et c'est tout ce qu'il faut pour prendre en charge plusieurs points de terminaison. </font><font style="vertical-align: inherit;">Toutes les autres tuiles sont effac√©es comme d'habitude. </font><font style="vertical-align: inherit;">Ensuite, nous supprimons le point de terminaison d√©fini au centre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.BecomeDestination(); searchFrontier.Enqueue(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.ClearPath(); } } <span class="hljs-comment"><span class="hljs-comment">//tiles[tiles.Length / 2].BecomeDestination(); //searchFrontier.Enqueue(tiles[tiles.Length / 2]); ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais si nous pouvons transformer des tuiles en points de terminaison, alors nous devrions √™tre en mesure d'effectuer l'op√©ration inverse, transformer les points de terminaison en tuiles vides. </font><font style="vertical-align: inherit;">Mais alors nous pouvons obtenir un champ sans aucun point final. </font><font style="vertical-align: inherit;">Dans ce cas, </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne pourra pas effectuer sa t√¢che. </font><font style="vertical-align: inherit;">Cela se produit lorsque la bordure est vide apr√®s l'initialisation du chemin pour toutes les cellules. </font><font style="vertical-align: inherit;">Nous d√©signons cela comme un √©tat non valide du champ, renvoyant </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et terminant l'ex√©cution; </font><font style="vertical-align: inherit;">sinon retournez √† la fin </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le moyen le plus simple de mettre en ≈ìuvre la prise en charge de la suppression des points de terminaison, ce qui en fait une op√©ration de commutation. En cliquant sur les tuiles vides, nous les transformerons en points de terminaison, et en cliquant sur les points de terminaison, nous les supprimerons. Mais maintenant, il est engag√© dans la modification du contenu </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous allons donc lui donner une m√©thode g√©n√©rale </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dont le param√®tre est la vignette. Si la tuile est le point de terminaison, faites-la vide et appelez </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sinon, nous en faisons le point final et nous l'appelons √©galement </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ajout d'un point de terminaison ne peut jamais cr√©er un √©tat de champ non valide, et la suppression d'un point de terminaison peut le faire. </font><font style="vertical-align: inherit;">Par cons√©quent, nous v√©rifierons s'il a r√©ussi √† s'ex√©cuter </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apr√®s avoir rendu la tuile vide. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, annulez la modification, ramenez la tuile au point de terminaison et appelez √† nouveau </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour revenir √† l'√©tat correct pr√©c√©dent.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La validation peut-elle √™tre rendue plus efficace?</font></font></b> <div class="spoiler_text">      ,      .           ,   .  ,          .        <code>FindPaths</code> ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, √† la fin, </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous pouvons appeler </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec la tuile centrale comme argument, au lieu d'appeler explicitement </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C'est la seule fois o√π nous commen√ßons avec un √©tat de champ non valide, mais nous sommes garantis de terminer avec l'√©tat correct.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//FindPaths(); ToggleDestination(tiles[tiles.Length / 2]); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, nous for√ßons √† </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appeler </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au lieu de d√©finir le contenu de la tuile elle-m√™me.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//tile.Content = //tileContentFactory.Get(GameTileContentType.Destination); board.ToggleDestination(tile); } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/685/8a9/8326858a93b938353376ff97259df1a7.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plusieurs points de terminaison avec des chemins corrects.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne devrions-nous pas interdire √† Game de d√©finir directement le contenu de la vignette?</font></font></b> <div class="spoiler_text">   .       .       ,   <code>Game</code>             .    ,      . </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les murs </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le but de la d√©fense de tour est d'emp√™cher les ennemis d'atteindre le point final. </font><font style="vertical-align: inherit;">Cet objectif est atteint de deux mani√®res. </font><font style="vertical-align: inherit;">Premi√®rement, nous les tuons, et deuxi√®mement, nous les ralentissons afin qu'il y ait plus de temps pour les tuer. </font><font style="vertical-align: inherit;">Sur le champ de tuiles, le temps peut √™tre allong√©, augmentant la distance que les ennemis doivent parcourir. </font><font style="vertical-align: inherit;">Ceci peut √™tre r√©alis√© en pla√ßant des obstacles sur le terrain. </font><font style="vertical-align: inherit;">Ce sont g√©n√©ralement des tours qui tuent √©galement les ennemis, mais dans ce didacticiel, nous nous limiterons aux murs.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le contenu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les murs sont un autre type de contenu, alors ajoutons-y </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un √©l√©ment.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez ensuite le pr√©fabriqu√© mural. </font><font style="vertical-align: inherit;">Cette fois, nous allons cr√©er un objet de jeu du contenu de la tuile et y ajouter un cube enfant, qui sera au-dessus du champ et remplira la tuile enti√®re. </font><font style="vertical-align: inherit;">Faites-le √† une demi-unit√© de hauteur et sauvez le collisionneur, car les murs peuvent chevaucher visuellement une partie des tuiles derri√®re lui. </font><font style="vertical-align: inherit;">Par cons√©quent, lorsqu'un joueur touche un mur, il influence la tuile correspondante.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/a33/779/1d3a33779b0c4d49f8ab4fed3d8abd20.png" width="320" height="176" alt="racine"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/431/b5c/9f6/431b5c9f65000bab15dd9e1eed14696d.png" width="320" height="226" alt="cube"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6b/875/3b2/e6b8753b2e9b954b55a4a3a6e0154560.png" width="225" height="60" alt="pr√©fabriqu√©"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mur pr√©fabriqu√©. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez le pr√©fabriqu√© mural √† l'usine, √† la fois dans le code et dans l'inspecteur.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent wallPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Wall: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(wallPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/eaa/50f/262eaa50f1bf4f80b2d2861d6232368b.png" width="320" height="80"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usine avec mur pr√©fabriqu√©.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Activer et d√©sactiver les murs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez √† </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la m√©thode marche / arr√™t des murs, comme nous l'avons fait pour le point final. </font><font style="vertical-align: inherit;">Initialement, nous ne v√©rifierons pas l'√©tat incorrect du champ.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Wall); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous prendrons en charge la commutation uniquement entre les carreaux vides et les carreaux muraux, sans permettre aux murs de remplacer directement les points de terminaison. </font><font style="vertical-align: inherit;">Par cons√©quent, nous ne cr√©erons un mur que lorsque la tuile sera vide. </font><font style="vertical-align: inherit;">De plus, les murs doivent bloquer la recherche du chemin. </font><font style="vertical-align: inherit;">Mais chaque tuile doit avoir un chemin vers le point final, sinon les ennemis se coincent. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons √† nouveau utiliser la validation </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ignorer les modifications si elles ont cr√©√© un √©tat de champ incorrect.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Wall); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'activation et la d√©sactivation des murs seront utilis√©es beaucoup plus souvent que l'activation et la d√©sactivation des points de terminaison, nous allons donc effectuer la commutation des murs dans la </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">touche principale. </font><font style="vertical-align: inherit;">Les points d'extr√©mit√© peuvent √™tre commut√©s par une touche suppl√©mentaire (g√©n√©ralement le bouton droit de la souris), qui peut √™tre reconnue en passant √† une </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur de 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { HandleAlternativeTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleAlternativeTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleDestination(tile); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleWall(tile); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d62/e45/4e9/d62e454e94a659dd9da841a915a93dac.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons les murs.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ai-je de grands √©carts entre les ombres des murs adjacents en diagonale?</font></font></b> <div class="spoiler_text">  ,          ,    ,   .   ,   ,  far clipping plane      . ,   far plane  20      .  ,         MSAA,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Veillons √©galement √† ce que les extr√©mit√©s ne puissent pas remplacer directement les murs. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verrou de recherche de chemin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que les murs bloquent la recherche du chemin, il nous suffit de ne pas ajouter de tuiles avec des murs √† la bordure de recherche. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en for√ßant √† </font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne pas retourner les carreaux avec des murs. </font><font style="vertical-align: inherit;">Mais le chemin doit toujours cro√Ætre en direction du mur, afin que toutes les tuiles du terrain aient un chemin. </font><font style="vertical-align: inherit;">Cela est n√©cessaire car il est possible qu'une tuile avec des ennemis se transforme soudainement en mur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour s'assurer que toutes les tuiles ont un chemin, elles </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doivent le v√©rifier une fois la recherche termin√©e. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, l'√©tat du champ n'est pas valide et doit √™tre renvoy√© </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il n'est pas n√©cessaire de mettre √† jour la visualisation du chemin pour les √©tats non valides, car le champ reviendra √† l'√©tat pr√©c√©dent.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tile.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc3/ff2/c3e/cc3ff2c3e52a087d9fa757d5760623d6.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les murs affectent le chemin. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour vous assurer que les murs ont r√©ellement les bons chemins, vous devez rendre les cubes translucides.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9b/2f6/70c/d9b2f670c9bcf0fc568c1484750c2e77.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Murs transparents. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que l'exigence d'exactitude de tous les chemins ne permet pas aux murs d'enfermer une partie du champ dans laquelle il n'y a pas de point final. </font><font style="vertical-align: inherit;">Nous pouvons diviser la carte, mais seulement s'il y a au moins un point de terminaison dans chaque partie. </font><font style="vertical-align: inherit;">De plus, chaque mur doit √™tre adjacent √† une tuile ou √† un point de terminaison vide, sinon il ne pourra pas avoir de chemin. </font><font style="vertical-align: inherit;">Par exemple, il est impossible de faire un bloc solide de murs 3 √ó 3.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cachez le chemin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La visualisation des chemins nous permet de voir comment fonctionne la recherche de chemin et de nous assurer qu'elle est bien correcte. </font><font style="vertical-align: inherit;">Mais il n'a pas besoin d'√™tre montr√© au joueur, ou du moins pas n√©cessairement. </font><font style="vertical-align: inherit;">Par cons√©quent, fournissons la possibilit√© de d√©sactiver les fl√®ches. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en ajoutant √† la </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode g√©n√©rale </font></font><code>HidePath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui d√©sactive simplement sa fl√®che.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HidePath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'√©tat de mappage de chemin fait partie de l'√©tat du champ. </font><font style="vertical-align: inherit;">Ajoutez un </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ bool√©en √† la valeur par d√©faut </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour suivre son √©tat, ainsi qu'une propri√©t√© commune comme getter et setter. </font><font style="vertical-align: inherit;">Le passeur doit afficher ou masquer les chemins sur toutes les tuiles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowPaths { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showPaths; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showPaths = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.HidePath(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sormais, la m√©thode </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne doit afficher les chemins mis √† jour que si le rendu est activ√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par d√©faut, la visualisation du chemin est d√©sactiv√©e. </font><font style="vertical-align: inherit;">D√©sactivez la fl√®che dans le pr√©fabriqu√© de tuiles.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5a/c71/802/a5ac718028d1bb41c145dfabba9051e1.png" width="320" height="44"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fl√®che pr√©fabriqu√©e est inactive par d√©faut. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous faisons en sorte qu'il </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permute l'√©tat de visualisation lorsqu'une touche est enfonc√©e. </font><font style="vertical-align: inherit;">Il serait logique d'utiliser la touche P, mais c'est aussi un raccourci clavier pour activer / d√©sactiver le mode de jeu dans l'√©diteur Unity. </font><font style="vertical-align: inherit;">En cons√©quence, la visualisation changera lorsque le raccourci clavier pour quitter le mode de jeu est utilis√©, ce qui n'est pas tr√®s joli. </font><font style="vertical-align: inherit;">Utilisons donc la touche V (abr√©viation de visualisation).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9c/a96/15c/a9ca9615c10cdab502f1769443ad6b38.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pas de fl√®ches.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affichage de la grille </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque les fl√®ches sont cach√©es, il devient difficile de discerner l'emplacement de chaque tuile. </font><font style="vertical-align: inherit;">Ajoutons les lignes de la grille. </font><font style="vertical-align: inherit;">T√©l√©chargez ici une </font><font style="vertical-align: inherit;">texture </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> maillage de bordure carr√©e qui peut √™tre utilis√©e comme contour de tuile distinct.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/e98/483/4c1e984836babfc368136b83ac2b195b.png" width="128" height="128"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture de maille.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous n'ajouterons pas cette texture individuellement √† chaque carreau, mais l'appliquerons au sol. Mais nous rendrons cette grille facultative, ainsi que la visualisation des chemins. Par cons√©quent, nous allons ajouter au </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ de configuration </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et s√©lectionner une texture de maillage pour celui-ci.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Texture2D gridTexture = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed4/99a/28e/ed499a28e82a3328c010a71ba1085316.png" width="320" height="94"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Champ avec texture de maille. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un autre champ bool√©en et une propri√©t√© pour contr√¥ler l'√©tat de la visualisation de la grille. </font><font style="vertical-align: inherit;">Dans ce cas, le passeur doit changer le mat√©riau de la terre, ce qui peut √™tre mis en ≈ìuvre en appelant la </font></font><code>GetComponent&lt;MeshRenderer&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terre et en acc√©dant √† la propri√©t√© du </font></font><code>material</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©sultat. </font><font style="vertical-align: inherit;">Si la grille doit √™tre affich√©e, nous attribuerons la </font></font><code>mainTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texture </font><font style="vertical-align: inherit;">de la </font><font style="vertical-align: inherit;">grille </font><font style="vertical-align: inherit;">√† la propri√©t√© du </font><font style="vertical-align: inherit;">mat√©riau. </font><font style="vertical-align: inherit;">Sinon, attribuez-le-lui </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Notez que lorsque vous modifiez la texture du mat√©riau, des doublons de l'instance de mat√©riau seront cr√©√©s, de sorte qu'elle deviendra ind√©pendante de l'actif mat√©riel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showGrid, showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowGrid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showGrid; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showGrid = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Material m = ground.GetComponent&lt;MeshRenderer&gt;().material; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m.mainTexture = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faites - </font><font style="vertical-align: inherit;">le </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commut√©es en appuyant sur la visualisation de la </font><font style="vertical-align: inherit;">grille G.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.G)) { board.ShowGrid = !board.ShowGrid; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez √©galement la visualisation de maillage par d√©faut √† </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b04/145/190/b04145190e5d8f15972f25374d7f5813.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grille non mise √† l'√©chelle. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous avons une fronti√®re autour de tout le champ. </font><font style="vertical-align: inherit;">Cela correspond √† la texture, mais ce n'est pas ce dont nous avons besoin. </font><font style="vertical-align: inherit;">Nous devons mettre √† l'√©chelle la texture principale du mat√©riau afin qu'elle corresponde √† la taille de la grille. </font><font style="vertical-align: inherit;">Vous pouvez le faire en appelant la m√©thode </font></font><code>SetTextureScale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mat√©rielle avec le nom de la propri√©t√© de texture ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et la taille bidimensionnelle. </font><font style="vertical-align: inherit;">Nous pouvons utiliser directement la taille du champ, qui est indirectement convertie en valeur </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; m.SetTextureScale(<span class="hljs-string"><span class="hljs-string">"_MainTex"</span></span>, size); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/d2a/b85/edbd2ab858e40a61d5f89452a8809b33.png" width="230" height="230" alt="sans"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/91a/ae5/8bd91aae589309dbd64994bb10a935a9.png" width="230" height="230" alt="avec"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grille √† l'√©chelle avec visualisation du chemin activ√©e et d√©sactiv√©e. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc, √† ce stade, nous avons obtenu un champ fonctionnel pour un jeu de tuiles du genre tower defense. </font><font style="vertical-align: inherit;">Dans le prochain tutoriel, nous ajouterons des ennemis. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©p√¥t</font></font></a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pdf</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449798/">https://habr.com/ru/post/fr449798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449784/index.html">Dans quels cas cela vaut la peine d'utiliser Django (et dans lequel ce n'est pas n√©cessaire)</a></li>
<li><a href="../fr449788/index.html">Brave Browser pr√©sente une plate-forme publicitaire bas√©e sur les r√©compenses</a></li>
<li><a href="../fr449790/index.html">D√©veloppement produit Visual Aid: Design</a></li>
<li><a href="../fr449794/index.html">R√©seaux d'antennes adaptatives: comment √ßa marche? (Bases)</a></li>
<li><a href="../fr449796/index.html">Une fille</a></li>
<li><a href="../fr449802/index.html">Programmeur de carri√®re. Partie 1. Le premier programme</a></li>
<li><a href="../fr449804/index.html">Aper√ßu de la th√©rapie anti-√¢ge pour les biohackers</a></li>
<li><a href="../fr449806/index.html">Programmeur de carri√®re. Partie 2. √âcole ou auto-√©ducation</a></li>
<li><a href="../fr449808/index.html">Exp√©rience Positive Hack Days 9: comment la pens√©e critique aide dans la vie et le travail</a></li>
<li><a href="../fr449814/index.html">Windows XP est officiellement mort, enfin enfin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>