<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçó üßôüèº ‚è≤Ô∏è Tests en C ++ sans macros et m√©moire dynamique üåÄ ü§¥üèº üëèüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nombreuses biblioth√®ques de test populaires, par exemple Google Test, Catch2, Boost.Test, sont fortement li√©es √† l'utilisation de macros, donc √† ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests en C ++ sans macros et m√©moire dynamique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434906/"><p> De nombreuses biblioth√®ques de test populaires, par exemple Google Test, Catch2, Boost.Test, sont fortement li√©es √† l'utilisation de macros, donc √† titre d'exemple de tests sur ces biblioth√®ques, vous voyez g√©n√©ralement une image comme celle-ci: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Tests the default c'tor. TEST(MyString, DefaultConstructor) { const MyString s; EXPECT_STREQ(nullptr, s.c_string()); EXPECT_EQ(0u, s.Length()); } const char kHelloString[] = "Hello, world!"; // Tests the c'tor that accepts a C string. TEST(MyString, ConstructorFromCString) { const MyString s(kHelloString); EXPECT_EQ(0, strcmp(s.c_string(), kHelloString)); EXPECT_EQ(sizeof(kHelloString)/sizeof(kHelloString[0]) - 1, s.Length()); } // Tests the copy c'tor. TEST(MyString, CopyConstructor) { const MyString s1(kHelloString); const MyString s2 = s1; EXPECT_EQ(0, strcmp(s2.c_string(), kHelloString)); } } // namespace</span></span></code> </pre> <br><p>  Les macros en C ++ se m√©fient, pourquoi sont-elles si florissantes dans les biblioth√®ques pour cr√©er des tests? </p><a name="habracut"></a><br><p>  La biblioth√®que de tests unitaires doit fournir √† ses utilisateurs un moyen d'√©crire des tests afin que le runtime de test puisse les trouver et les ex√©cuter d'une mani√®re ou d'une autre.  Lorsque vous r√©fl√©chissez √† la fa√ßon de proc√©der, l'utilisation des macros semble √™tre la plus simple.  La macro TEST () d√©finit g√©n√©ralement en quelque sorte une fonction (dans le cas de Google Test, la macro cr√©e √©galement une classe) et garantit que l'adresse de cette fonction p√©n√®tre dans un conteneur global. </p><br><p>  La biblioth√®que bien connue dans laquelle l'approche sans macro unique est impl√©ment√©e est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tut-framework</a> .  Voyons son exemple dans le tutoriel: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tut/tut.hpp&gt; namespace tut { struct basic{}; typedef test_group&lt;basic&gt; factory; typedef factory::object object; } namespace { tut::factory tf("basic test"); } namespace tut { template&lt;&gt; template&lt;&gt; void object::test&lt;1&gt;() { ensure_equals("2+2=?", 2+2, 4); } }</span></span></span></span></code> </pre> <br><p>  L'id√©e qui sous-tend est assez int√©ressante et fonctionne, ce n'est pas tr√®s difficile.  En bref, vous avez une classe de base qui impl√©mente une fonction de mod√®le qui implique le param√©trage avec un entier: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_object</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Data { <span class="hljs-comment"><span class="hljs-comment">/** * Default do-nothing test. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ called_method_was_a_dummy_test_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Maintenant, lorsque vous √©crivez un tel test: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> object::test&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;() { ensure_equals(<span class="hljs-string"><span class="hljs-string">"2+2=?"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br><p>  Vous cr√©ez en fait une sp√©cialisation de m√©thode de test pour un nombre sp√©cifique N = 1 (c'est exactement ce que le <code>template&lt;&gt;template&lt;&gt;</code> signifie).  En appelant <code>test&lt;N&gt;()</code> le runtime de test peut comprendre s'il s'agissait d'un test r√©el ou d'un stub regardant la valeur <code>called_method_was_a_dummy_test_</code> apr√®s l'ex√©cution du test. </p><br><p>  Ensuite, lorsque vous d√©clarez un groupe de test: </p><br><pre> <code class="cpp hljs">tut::<span class="hljs-function"><span class="hljs-function">factory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"basic test"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>  Premi√®rement, vous √©num√©rez tous les <code>test&lt;N&gt;</code> √† une certaine constante qui est c√¢bl√©e √† la biblioth√®que, et deuxi√®mement, par effet secondaire, vous ajoutez des informations sur le groupe au conteneur global (nom de groupe et adresses de toutes les fonctions de test). </p><br><p>  Les exceptions sont utilis√©es comme conditions de test dans tut, donc la fonction <code>tut::ensure_equals()</code> simplement une exception si les deux valeurs qui lui sont pass√©es ne sont pas √©gales, et l'environnement d'ex√©cution de test intercepte une exception et consid√®re le test comme ayant √©chou√©.  J'aime cette approche, elle devient imm√©diatement claire pour tout d√©veloppeur C ++ o√π de telles assertions peuvent √™tre utilis√©es.  Par exemple, si mon test a cr√©√© un thread auxiliaire, il est inutile de placer des assertions l√†-bas, personne ne les rattrapera.  De plus, il est clair pour moi que mon test devrait pouvoir lib√©rer des ressources en cas d'exception, comme s'il s'agissait d'un code ordinaire prot√©g√© contre les exceptions. </p><br><p>  En principe, la biblioth√®que tut-framework semble assez bonne, mais il y a quelques inconv√©nients √† sa mise en ≈ìuvre.  Par exemple, pour mon cas, je voudrais que le test ait non seulement un nombre, mais aussi d'autres attributs, en particulier le nom, ainsi que la "taille" du test (par exemple, s'agit-il d'un test d'int√©gration ou d'un test unitaire).  Cela peut √™tre r√©solu dans le cadre de l'API tut, et m√™me quelque chose existe d√©j√†, et quelque chose peut √™tre impl√©ment√© si vous ajoutez une m√©thode √† l'API de la biblioth√®que et l'appellez dans le corps du test pour d√©finir l'un de ses param√®tres: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> object::test&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;() { set_name(<span class="hljs-string"><span class="hljs-string">"2+2"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Set test name to be shown in test report ensure_equals("2+2=?", 2+2, 4); }</span></span></code> </pre> <br><p>  Un autre probl√®me est que le lanceur de test tut ne sait rien d'un √©v√©nement tel que le d√©but d'un test.  L'environnement ex√©cute <code>object::test&lt;N&gt;()</code> et il ne sait pas √† l'avance si le test est impl√©ment√© pour un N donn√©, ou s'il s'agit simplement d'un talon.  Elle ne <code>called_method_was_a_dummy_test_</code> que lorsque le test est termin√© en analysant la valeur <code>called_method_was_a_dummy_test_</code> .  Cette fonctionnalit√© ne se montre pas tr√®s bien dans les syst√®mes CI, qui sont capables de regrouper la sortie que le programme a faite entre le d√©but et la fin du test. </p><br><p>  Cependant, √† mon avis, la principale chose qui peut √™tre am√©lior√©e (un "d√©faut fatal") est la pr√©sence de code auxiliaire suppl√©mentaire requis pour √©crire des tests.  Il y a beaucoup de choses dans le tutoriel tut-framework: il est propos√© de cr√©er d'abord une certaine <code>struct basic{}</code> classe de <code>struct basic{}</code> , et de d√©crire les tests comme des m√©thodes d'objet associ√©es √† cela.  Dans cette classe, vous pouvez d√©finir les m√©thodes et les donn√©es que vous souhaitez utiliser dans le groupe de test, et le constructeur et le destructeur encadrent l'ex√©cution du test, cr√©ant une chose telle que fixture √† partir de jUnit.  Dans ma pratique avec tut, cet objet est presque toujours vide, mais il tra√Æne sur un certain nombre de lignes de code. </p><br><p>  Donc, nous allons √† l'atelier de v√©lo et essayons d'arranger l'id√©e sous la forme d'une petite biblioth√®que. </p><br><p>  Voici √† quoi ressemble le fichier de test minimal dans la biblioth√®que test√©e: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Test group for std::vector (illustrative purposes) #include "tested.h" #include &lt;vector&gt; template&lt;&gt; void tested::Case&lt;CASE_COUNTER&gt;(tested::IRuntime* runtime) { runtime-&gt;StartCase("emptiness"); std::vector&lt;int&gt; vec; tested::Is(vec.empty(), "Vector must be empty by default"); } template&lt;&gt; void tested::Case&lt;CASE_COUNTER&gt;(tested::IRuntime* runtime) { runtime-&gt;StartCase("AddElement"); std::vector&lt;int&gt; vec; vec.push_back(1); tested::Is(vec.size() == 1); tested::Is(vec[0] == 1); tested::FailIf(vec.empty()); } void LinkVectorTests() { static tested::Group&lt;CASE_COUNTER&gt; x("std.vector", __FILE__); }</span></span></code> </pre> <br><p>  En plus du manque de macros, le bonus est l'absence d'utilisation de la m√©moire dynamique √† l'int√©rieur de la biblioth√®que. </p><br><h3 id="opredelenie-test-keysov">  D√©finition des cas de test </h3><br><p>  Pour l'enregistrement des tests, la magie √©l√©mentaire d'entr√©e de gamme est utilis√©e sur le m√™me principe que tut.  Quelque part dans test√©.h, il existe une fonction passe-partout de ce type: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Case</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IRuntime* runtime)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> TheCaseIsAStub(); }</code> </pre> <br><p>  Les cas de test √©crits par les utilisateurs de biblioth√®que sont simplement des sp√©cialisations de cette m√©thode.  La fonction est d√©clar√©e statique, c'est-√†-dire  dans chaque unit√© de traduction, nous cr√©ons des sp√©cialisations qui ne se coupent pas mutuellement lors de la liaison. </p><br><p>  Il existe une telle r√®gle que vous devez d'abord appeler <code>StartCase()</code> , √† laquelle vous pouvez passer des choses comme le nom du test et peut-√™tre d'autres choses encore en d√©veloppement. </p><br><p>  Lorsqu'un test appelle <code>runtime-&gt;StartTest()</code> , des choses int√©ressantes peuvent se produire.  Premi√®rement, si les tests sont maintenant en mode ex√©cution, vous pouvez dire quelque part que le test a commenc√© son ex√©cution.  Deuxi√®mement, s'il existe un mode de collecte d'informations sur les tests disponibles, <code>StartTest()</code> un type sp√©cial d'exception qui signifiera que le test est r√©el et non un talon. </p><br><h3 id="registraciya">  Inscription </h3><br><p>  √Ä un moment donn√©, vous devez collecter les adresses de tous les cas de test et les mettre quelque part.  Dans test√©, cela se fait √† l'aide de groupes.  Le constructeur de la classe test√©e :: Group fait cela comme un effet secondaire: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__);</code> </pre> <br><p>  Le constructeur cr√©e un groupe avec le nom sp√©cifi√© et y ajoute tous les <code>Case&lt;N&gt;</code> qu'il trouve dans l'unit√© de traduction actuelle.  Il s'av√®re que dans une unit√© de traduction, vous ne pouvez pas avoir deux groupes.  Cela signifie √©galement que vous ne pouvez pas diviser un groupe en plusieurs unit√©s de traduction. </p><br><p>  Le param√®tre du mod√®le est le nombre de cas de test √† rechercher dans l'unit√© de traduction actuelle pour le groupe cr√©√©. </p><br><h3 id="linkovka">  Lien </h3><br><p>  Dans l'exemple ci-dessus, la cr√©ation de l'objet test√© :: Group () se produit √† l'int√©rieur de la fonction que nous devons appeler √† partir de notre application pour enregistrer les tests: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); }</code> </pre> <br><p>  Une fonction n'est pas toujours requise, parfois vous pouvez simplement d√©clarer un objet de la classe <code>tested::Group</code> dans un fichier.  Cependant, mon exp√©rience est que l'√©diteur de liens "optimise" parfois le fichier entier s'il est assembl√© √† l'int√©rieur de la biblioth√®que, et aucune des applications principales n'utilise de caract√®res de ce fichier cpp: </p><br><pre> <code class="plaintext hljs">calc.lib &lt;- calc_test.lib(calc_test.cpp) ^ ^ | | app.exe run_test.exe</code> </pre> <br><p>  Lorsque calc_test.cpp n'est pas li√© √† partir de la source run_test.exe, l'√©diteur de liens supprime simplement ce fichier de toute consid√©ration, ainsi que la cr√©ation d'un objet statique, malgr√© le fait qu'il pr√©sente les effets secondaires dont nous avons besoin. </p><br><p>  Si la cha√Æne r√©sulte de run_test.exe, l'objet statique appara√Ætra dans le fichier ex√©cutable.  Et peu importe comment cela se fait, comme dans l'exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); }</code> </pre> <br><p>  ou alors: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><p>  La premi√®re option, √† mon avis, est meilleure car le constructeur est appel√© apr√®s le d√©but de main () et l'application a un certain contr√¥le sur ce processus. </p><br><p>  Je pense que ce param√®tre de b√©quilles est requis pour toute biblioth√®que de tests unitaires qui utilise des variables globales et des effets secondaires du constructeur pour cr√©er une base de donn√©es de test.  Cependant, cela peut probablement √™tre √©vit√© en liant la biblioth√®que de test avec la cl√© --whole-archive (un analogue dans MSVC n'est apparu que dans Visual Studio 2015.3). </p><br><h3 id="makrosy">  Macros </h3><br><p>  J'ai promis qu'il n'y aurait pas de macros, mais c'est - <code>CASE_COUNTER</code> .  L'option de travail est qu'elle est utilis√©e par <code>__COUNTER__</code> , une macro que le compilateur incr√©mente d'une unit√© √† chaque fois qu'elle est utilis√©e dans l'unit√© de traduction. <br>  Pris en charge par GCC, CLANG, MSVC, mais pas la norme.  Si cela est frustrant, voici quelques alternatives: </p><br><ul><li>  utilisez les chiffres 0, 1, 2 </li><li>  utilisez la norme <code>__LINE__</code> . </li><li>  utilisez la magie constexpr de niveau 80.  Vous pouvez rechercher "constexpr counter" et essayer de trouver le compilateur sur lequel il fonctionnera. </li></ul><br><p>  Le probl√®me avec <code>__LINE__</code> est que l'utilisation de grands nombres dans les options de mod√®le cr√©e une grande taille de fichier ex√©cutable.  C'est pourquoi j'ai limit√© le type du mod√®le de caract√®re sign√© √† 128 comme nombre maximal de tests dans le groupe. </p><br><h3 id="otkaz-ot-dinamicheskoy-pamyati">  D√©faillance de la m√©moire dynamique </h3><br><p>  Il s'est av√©r√© que lors de l'enregistrement des tests, vous ne pouvez pas utiliser la m√©moire dynamique, que j'ai utilis√©e.  Il est possible que votre environnement ne dispose pas de m√©moire dynamique ou que vous utilisiez la recherche de fuites de m√©moire dans les cas de test, donc l'intervention de l'environnement d'ex√©cution du test n'est pas ce dont vous avez besoin.  Google Test a du mal avec cela, voici un extrait de l√†: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Use the RAII idiom to flag mem allocs that are intentionally never // deallocated. The motivation is to silence the false positive mem leaks // that are reported by the debug version of MS's CRT which can only detect // if an alloc is missing a matching deallocation. // Example: // MemoryIsNotDeallocated memory_is_not_deallocated; // critical_section_ = new CRITICAL_SECTION; class MemoryIsNotDeallocated</span></span></code> </pre> <br><p>  Et nous ne pouvons tout simplement pas cr√©er de difficult√©s. </p><br><p>  Comment obtenir alors une liste de tests?  Ce sont des internes plus techniques, qui sont plus faciles √† voir dans le code source, mais je vous le dirai quand m√™me. </p><br><p>  Lors de la cr√©ation d'un groupe, sa classe recevra un pointeur vers la fonction <code>tested::CaseCollector&lt;CASE_COUNTER&gt;::collect</code> , qui collectera tous les tests unitaires de traduction dans une liste.  Voici comment cela fonctionne: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make the anonymouse namespace to have instances be hidden to specific translation unit namespace { template &lt;Ordinal_t N&gt; struct CaseCollector { // Test runtime that collects the test case struct CollectorRuntime final : IRuntime { void StartCase(const char* caseName, const char* description = nullptr) final { // the trick is exit from test case function into the collector via throw throw CaseIsReal(); } }; // Finds the Case&lt;N&gt; function in current translation unit and adds into the static list. It uses the // reverse order, so the case executed in order of appearance in C++ file. static CaseListEntry* collect(CaseListEntry* tail) { CaseListEntry* current = nullptr; CollectorRuntime collector; try { Case&lt;N&gt;(&amp;collector); } catch (CaseIsStub) { current = tail; } catch (CaseIsReal) { s_caseListEntry.CaseProc = Case&lt;N&gt;; s_caseListEntry.Next = tail; s_caseListEntry.Ordinal = N; current = &amp;s_caseListEntry; } return CaseCollector&lt;N - 1&gt;::collect(current); } private: static CaseListEntry s_caseListEntry; }; // This static storage will be instantiated in any cpp file template &lt;Ordinal_t N&gt; CaseListEntry CaseCollector&lt;N&gt;::s_caseListEntry; }</span></span></code> </pre> <br><p>  Il s'av√®re que dans chaque unit√© de traduction de nombreuses variables statiques du type CaseListEntry CaseCollector \ :: s_caseListEntry sont cr√©√©es, qui sont des √©l√©ments de la liste de tests, et la m√©thode collect () collecte ces √©l√©ments dans une liste connect√©e individuellement.  De la m√™me mani√®re, la liste forme des groupes de tests, mais sans sch√©mas ni r√©cursivit√©. <br></p><br><h3 id="struktura">  La structure </h3><br><p>  Les tests n√©cessitent une liaison diff√©rente, telle que la sortie vers la console en lettres rouges √âchec, la cr√©ation de rapports de test dans un format compr√©hensible pour CI ou GUI dans lequel vous pouvez voir la liste des tests et ex√©cuter ceux s√©lectionn√©s - en g√©n√©ral, beaucoup de choses.  J'ai une vision de la fa√ßon dont cela peut √™tre fait, ce qui est diff√©rent de ce que j'ai vu plus t√¥t dans la biblioth√®que de tests.  La revendication concerne principalement les biblioth√®ques qui se disent "en-t√™te uniquement", tout en incluant une grande quantit√© de code, qui n'est essentiellement pas destin√© aux fichiers d'en-t√™te. </p><br><p>  L'approche que je suppose est que nous divisons la biblioth√®que en front-end - c'est test√©.h et les biblioth√®ques back-end elles-m√™mes.  Pour √©crire des tests, vous n'avez besoin que de testing.h, qui est maintenant C ++ 17 (en raison de std :: std :: string_view), mais il est suppos√© qu'il y aura C ++ 98.  Tested.h effectue en fait l'enregistrement et la recherche de tests, une option de lancement minimalement pratique, ainsi que la possibilit√© d'exporter des tests (groupes, adresses des fonctions de cas de test).  Les biblioth√®ques d'arri√®re-plan qui n'existent pas encore peuvent faire tout ce dont elles ont besoin en termes de sortie des r√©sultats et de lancement √† l'aide de la fonctionnalit√© d'exportation.  De la m√™me mani√®re, vous pouvez adapter le lancement aux besoins de votre projet. </p><br><h3 id="itog">  R√©sum√© </h3><br><p>  La biblioth√®que test√©e ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code github</a> ) a encore besoin d'une certaine stabilisation.  Dans un avenir proche, ajoutez la possibilit√© d'ex√©cuter des tests asynchrones (n√©cessaires pour les tests d'int√©gration dans WebAssembly) et indiquez la taille des tests.  √Ä mon avis, la biblioth√®que n'est pas encore tout √† fait pr√™te √† √™tre utilis√©e en production, mais j'ai soudainement pass√© beaucoup de temps et la sc√®ne est venue s'arr√™ter, reprendre mon souffle et demander les commentaires de la communaut√©.  Seriez-vous int√©ress√© √† utiliser ce type de biblioth√®que?  Peut-√™tre qu'il y a d'autres id√©es dans l'arsenal C ++ car il serait possible de cr√©er une biblioth√®que sans macros?  Une telle d√©claration du probl√®me est-elle int√©ressante du tout? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434906/">https://habr.com/ru/post/fr434906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434892/index.html">Code de dessin dans Swift, PaintCode</a></li>
<li><a href="../fr434894/index.html">L'art du chamanisme ou du firmware personnalis√© pour Olinuxino. Partie 1</a></li>
<li><a href="../fr434896/index.html">Temple de la renomm√©e de l'√©lectronique grand public: les histoires des meilleurs gadgets des 50 derni√®res ann√©es, partie 1</a></li>
<li><a href="../fr434898/index.html">Grasp2Vec: apprendre √† repr√©senter des objets gr√¢ce √† la capture d'auto-apprentissage</a></li>
<li><a href="../fr434902/index.html">Cr√©ation d'un g√©n√©rateur de requ√™tes personnalis√© dans Spring Data Neo4j (partie 1)</a></li>
<li><a href="../fr434908/index.html">Formation des programmeurs - Quoi? O?? Quand?</a></li>
<li><a href="../fr434912/index.html">Le stock annuel de Porsche Taycan est d√©j√† r√©serv√©, principalement par les propri√©taires de Tesla</a></li>
<li><a href="../fr434924/index.html">Ce qu'il faut lire sur l'organisation des lieux de travail, le coworking et la conception d'espaces pour le travail √† distance</a></li>
<li><a href="../fr434928/index.html">M√©thodes d'application et distorsion de la pr√©cision dans les jeux. Tableaux visuels pour comparaison</a></li>
<li><a href="../fr434930/index.html">Annonce vid√©o aujourd'hui: doit avoir une entreprise prosp√®re</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>