<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â›ï¸ ğŸ’ƒğŸ¼ ğŸ‘©â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦ ZIO & Cats Effect: une alliance rÃ©ussie ğŸ˜¾ ğŸ˜‰ ğŸ‘¼ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cats Effect est devenu une sorte de Â«flux rÃ©actifsÂ» pour le monde Scala fonctionnel, vous permettant de combiner l'ensemble de l'Ã©cosystÃ¨me diversifiÃ©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ZIO & Cats Effect: une alliance rÃ©ussie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/472386/">  Cats Effect est devenu une sorte de Â«flux rÃ©actifsÂ» pour le monde Scala fonctionnel, vous permettant de combiner l'ensemble de l'Ã©cosystÃ¨me diversifiÃ© des bibliothÃ¨ques. <br><br>  Beaucoup d'excellentes bibliothÃ¨ques: http4s, fs2, doobie - sont implÃ©mentÃ©es uniquement sur la base des classes de type de Cats Effect.  Et des bibliothÃ¨ques comme ZIO et Monix, Ã  leur tour, fournissent des instances de ces classes de types pour leurs types d'effets.  MalgrÃ© certains problÃ¨mes qui seront corrigÃ©s dans la version 3.0, Cats Effect aide de nombreux contributeurs open source Ã  prendre en charge de maniÃ¨re organique l'intÃ©gralitÃ© de l'Ã©cosystÃ¨me fonctionnel du langage Scala.  Les dÃ©veloppeurs qui utilisent Cats Effect sont confrontÃ©s Ã  un choix difficile: la mise en Å“uvre des effets Ã  utiliser pour leurs applications. <br><br>  Aujourd'hui, il existe trois alternatives: <br><br><ul><li>  Cats IO, implÃ©mentation de rÃ©fÃ©rence; </li><li>  Monix, le type de donnÃ©es Task et sa rÃ©activitÃ© en code; </li><li>  ZIO, le type de donnÃ©es ZIO et sa portÃ©e de cross-threading. </li></ul><br>  Dans cet article, je vais essayer de vous prouver que pour crÃ©er votre application Ã  l'aide de Cats Effect, ZIO est un bon choix avec des solutions et des capacitÃ©s de conception assez diffÃ©rentes de l'implÃ©mentation de rÃ©fÃ©rence dans Cats IO. <br><a name="habracut"></a><br><h2>  1. Meilleure architecture MTL / Tagless-Final </h2><br>  MTL (Monad Transformers Library) est un style de programmation dans lequel les fonctions sont polymorphes par leur type d'effet et expriment leurs exigences Ã  travers une Â«contrainte de classe de typeÂ».  Dans Scala, cela est souvent appelÃ© le style final sans Ã©tiquette (bien que ce ne soit pas la mÃªme chose), surtout lorsque la classe de type n'a pas de lois. <br><br>  Il est bien connu qu'il est impossible de dÃ©finir une instance globale pour des classes de type MTL classiques telles que Writer et State, ainsi que pour des types d'effet tels que Cats IO.  Le problÃ¨me est que les instances de ces classes de type pour ces types d'effets nÃ©cessitent l'accÃ¨s Ã  un Ã©tat mutable, qui ne peut pas Ãªtre crÃ©Ã© globalement, car la crÃ©ation d'un Ã©tat mutable est Ã©galement un effet. <br><br>  Pour de meilleures performances, cependant, il est important d'Ã©viter les "transformateurs monades" et de fournir directement l'implÃ©mentation Write et State, en plus du type d'effet principal. <br><br>  Pour y parvenir, les programmeurs Scala utilisent une astuce: ils crÃ©ent (mais nettoient) des instances au niveau supÃ©rieur de leurs programmes avec des effets, puis les fournissent plus loin dans le programme sous forme d'implications locales: <br><br><pre><code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Ref</span></span>.make[<span class="hljs-type"><span class="hljs-type">AppState</span></span>](initialAppState).flatMap(ref =&gt; <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monadState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>, <span class="hljs-type"><span class="hljs-type">AppState</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">AppState</span></span>] = ref.get <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">AppState</span></span>): <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = ref.set(s).unit } myProgram )</code> </pre> <br>  MalgrÃ© le fait qu'une telle astuce soit utile, c'est toujours une Â«bÃ©quilleÂ».  Dans un monde idÃ©al, toutes les instances de classes de types pourraient Ãªtre cohÃ©rentes (une instance par type) et ne pas Ãªtre crÃ©Ã©es localement, gÃ©nÃ©rant des effets, puis s'enveloppant comme par magie dans des valeurs implicites Ã  utiliser par les mÃ©thodes suivantes. <br><br>  Une grande fonctionnalitÃ© de MTL / tagless-final est que vous pouvez dÃ©finir directement la plupart des instances au-dessus du type de donnÃ©es ZIO Ã  l'aide de l'environnement ZIO. <br><br>  Voici une faÃ§on de crÃ©er une dÃ©finition globale MonadState pour un type de donnÃ©es ZIO: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadState</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">State</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">S</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.set(s).unit) }</code> </pre><br>  Une instance est dÃ©sormais dÃ©finie globalement pour tout environnement prenant en charge au moins <code>State[S]</code> . <br><br>  De mÃªme pour <code>FunctorListen</code> , autrement connu sous le nom de <code>MonadWriter</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOFunctorListen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>: <span class="hljs-type"><span class="hljs-type">Semigroup</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">Writer</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, (<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>)] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get.flatMap(w =&gt; fa.map(a =&gt; a -&gt; w))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tell</span></span></span></span>(w: <span class="hljs-type"><span class="hljs-type">W</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.update(_ |+| w).unit) }</code> </pre><br>  Et bien sÃ»r, nous pouvons faire de mÃªme pour <code>MonadError</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>]{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">E</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = fa catchAll f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raiseError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](e: <span class="hljs-type"><span class="hljs-type">E</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fail(e) }</code> </pre> <br>  Cette technique est facilement applicable Ã  d'autres classes de type, y compris les classes de type tagless-final, dont les instances peuvent nÃ©cessiter la gÃ©nÃ©ration d'effets (modifications, configurations), les fonctions de test qui gÃ©nÃ¨rent des effets (combinaison des effets d'environnement avec tagless-final), ou toute autre chose facilement accessible depuis l'environnement . <br><br>  Plus de transformations monadiques lentes!  Disons Â«nonÂ» Ã  la crÃ©ation d'effets lors de l'initialisation des instances de la classe, aux implications locales.  Plus besoin de bÃ©quilles.  Immersion directe dans une programmation fonctionnelle pure. <br><br><h2>  2. Ã‰conomiser des ressources pour les simples mortels </h2><br>  L'une des premiÃ¨res fonctionnalitÃ©s de ZIO a Ã©tÃ© l'interruption - la capacitÃ© du runtime ZIO d'interrompre instantanÃ©ment tout effet exÃ©cutable et garanti de libÃ©rer toutes les ressources.  Une implÃ©mentation brute de cette fonctionnalitÃ© a atteint Cats IO. <br><br>  Haskell a appelÃ© une telle fonctionnalitÃ© une exception asynchrone, qui vous permet de crÃ©er et d'utiliser efficacement la latence, des opÃ©rations parallÃ¨les et compÃ©titives efficaces et des calculs optimaux Ã  l'Ã©chelle mondiale.  De telles interruptions apportent non seulement de grands avantages, mais posent Ã©galement des tÃ¢ches complexes dans le domaine de la prise en charge d'un accÃ¨s sÃ©curisÃ© aux ressources. <br><br>  Les programmeurs sont habituÃ©s Ã  suivre les erreurs dans les programmes grÃ¢ce Ã  une analyse simple.  Cela peut Ã©galement Ãªtre fait avec ZIO, qui utilise un systÃ¨me de type pour aider Ã  dÃ©tecter les erreurs.  Mais l'interruption est autre chose.  Un effet crÃ©Ã© Ã  partir de nombreux autres effets peut Ãªtre interrompu Ã  n'importe quelle frontiÃ¨re. <br><br>  ConsidÃ©rez l'effet suivant: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle) _ &lt;- closeFile(handle) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> data</code> </pre> <br>  La plupart des dÃ©veloppeurs ne seront pas surpris de ce scÃ©nario: <code>closeFile</code> ne sera pas exÃ©cutÃ© si <code>readFile</code> plante.  Heureusement, le systÃ¨me d'effets a une <code>ensuring</code> ( <code>guarantee</code> dans Cats Effect) qui vous permet d'ajouter un gestionnaire final Ã  l'effet finalizer, comme pour finalement. <br><br>  Ainsi, le problÃ¨me principal du code ci-dessus peut Ãªtre facilement rÃ©solu: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle).ensuring(closeFile(handle)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> ()</code> </pre> <br>  Maintenant, l'effet est devenu Â«rÃ©sistant aux chutesÂ», en ce sens que si le <code>readFile</code> casse, le fichier sera toujours fermÃ©.  Et si <code>readFile</code> rÃ©ussit, le fichier sera Ã©galement fermÃ©.  Dans tous les cas, le dossier sera fermÃ©. <br><br>  Mais pas tout Ã  fait du tout.  L'interruption signifie que l'effet peut Ãªtre interrompu partout, mÃªme entre <code>openFile</code> et <code>readFile</code> .  Si cela se produit, le fichier ouvert ne sera pas fermÃ© et une fuite de ressources se produira. <br><br>  Le modÃ¨le d'obtention et de libÃ©ration d'une ressource est si rÃ©pandu que ZIO a introduit un opÃ©rateur de support, qui est Ã©galement apparu dans Cats Effect 1.0.  L'instruction Bracket protÃ¨ge contre les interruptions: si la ressource est reÃ§ue avec succÃ¨s, la libÃ©ration se produit mÃªme si l'effet utilisant la ressource est interrompu.  De plus, ni la rÃ©ception ni la libÃ©ration de la ressource ne peuvent Ãªtre interrompues, offrant ainsi une garantie de sÃ©curitÃ© des ressources. <br><br>  En utilisant un support, l'exemple ci-dessus ressemblerait Ã  ceci: <br><br><pre> <code class="scala hljs">openFile(file).bracket(closeFile(_))(readFile(_))</code> </pre> <br>  Malheureusement, la parenthÃ¨se n'encapsule qu'un seul modÃ¨le de consommation de ressources (assez gÃ©nÃ©ral).  Il en existe bien d'autres, notamment avec des structures de donnÃ©es compÃ©titives, dont l'accÃ¨s doit Ãªtre accessible pour les interruptions, sinon des fuites sont possibles. <br><br>  En gÃ©nÃ©ral, tout travail d'interruption se rÃ©sume Ã  deux choses principales: <br><br><ul><li>  prÃ©venir les interruptions dans certaines zones qui pourraient Ãªtre interrompues; </li><li>  permettre une interruption dans les zones susceptibles de geler. </li></ul><br>  ZIO a la capacitÃ© de mettre en Å“uvre les deux.  Par exemple, nous pouvons dÃ©velopper notre propre version de bracket en utilisant des abstractions ZIO de bas niveau: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.uninterruptible { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { a &lt;- acquire exit &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.interruptible(use(a)) .run.flatMap(exit =&gt; release(a, exit) .const(exit)) b &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.done(exit) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> b }</code> </pre><br>  Dans ce code, l' <code>use(a)</code> est la seule partie qui peut Ãªtre interrompue.  Le code environnant garantit l'exÃ©cution de la <code>release</code> dans tous les cas. <br><br>  Ã€ tout moment, vous pouvez vÃ©rifier s'il existe une possibilitÃ© d'interruption.  Pour cela, seules deux opÃ©rations primitives sont nÃ©cessaires (toutes les autres en sont dÃ©rivÃ©es). <br><br>  Ce modÃ¨le d'interruption de composition complÃ¨te vous permet d'implÃ©menter non seulement une implÃ©mentation de support simple, mais Ã©galement d'implÃ©menter d'autres scÃ©narios dans la gestion des ressources, dans lesquels un Ã©quilibre est trouvÃ© entre les avantages et les inconvÃ©nients des interruptions. <br><br>  Cats IO ne fournit qu'une seule opÃ©ration pour contrÃ´ler les interruptions: le combinateur non annulable.  Cela rend le bloc de code entier ininterrompu.  Bien que cette opÃ©ration soit rarement utilisÃ©e, elle peut entraÃ®ner une fuite de ressources ou des verrous. <br><br>  En mÃªme temps, il s'avÃ¨re que vous pouvez dÃ©finir une primitive Ã  l'intÃ©rieur de Cats IO, ce qui vous permet d'obtenir plus de contrÃ´le sur les interruptions.  L'implÃ©mentation trÃ¨s compliquÃ©e de Fabio Labella s'est avÃ©rÃ©e extrÃªmement lente. <br><br>  ZIO vous permet d'Ã©crire du code avec des interruptions, fonctionnant Ã  un niveau Ã©levÃ© avec des instructions composÃ©es dÃ©claratives, et ne vous oblige pas Ã  choisir entre une complexitÃ© sÃ©vÃ¨re combinÃ©e Ã  de faibles performances et des fuites bloquantes. <br><br>  De plus, la mÃ©moire transactionnelle logicielle rÃ©cemment ajoutÃ©e dans ZIO permet Ã  l'utilisateur d'Ã©crire de maniÃ¨re dÃ©clarative des structures de donnÃ©es et du code qui sont automatiquement asynchrones, compÃ©titifs et autorisent les interruptions. <br><br><h2>  3. Finaliseurs garantis </h2><br>  Le bloc try / finally dans de nombreux langages de programmation offre les garanties nÃ©cessaires pour Ã©crire du code synchrone sans fuite de ressources. <br><br>  En particulier, ce bloc garantit ce qui suit: si un bloc try dÃ©marre l'exÃ©cution, alors le bloc finally s'exÃ©cutera lorsque try s'arrÃªtera. <br><br>  Cette garantie s'applique Ã : <br><br><ul><li>  il y a des blocs "try / finally" imbriquÃ©s; </li><li>  il y a des erreurs dans le "bloc try"; </li><li>  il y a des erreurs dans le bloc nichÃ© finalement. </li></ul><br>  L'opÃ©ration Â«assurerÂ» ZIO peut Ãªtre utilisÃ©e comme try / enfin: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect2 = effect.ensuring(cleanup)</code> </pre> <br>  ZIO fournit les garanties suivantes pour "effect.ensuring (finalizer)": si "effect" a commencÃ© Ã  Ãªtre exÃ©cutÃ©, alors "finalizer" commencera son exÃ©cution lorsque "effect" s'arrÃªtera. <br><br>  Comme try / enfin, ces garanties restent dans les cas suivants: <br><br><ul><li>  Il existe des compositions Â«assurantÂ» imbriquÃ©es; </li><li>  il y a des erreurs dans "l'effet"; </li><li>  il y a des erreurs dans le "finaliseur" imbriquÃ©. </li></ul><br>  De plus, la garantie est maintenue mÃªme si l'effet est interrompu (les garanties sur la Â«trancheÂ» sont similaires, en fait, la Â«trancheÂ» est mise en Å“uvre sur la Â«garantieÂ»). <br><br>  Le type de donnÃ©es Cats IO fournit une autre garantie, plus faible.  Pour Â«effect.guarantee (finalizer)Â», il est affaibli comme suit: si Â«effectÂ» a commencÃ© Ã  Ãªtre exÃ©cutÃ©, Â«finalizerÂ» commencera l'exÃ©cution lorsque Â«effectÂ» s'arrÃªtera, si l'effet problÃ©matique n'est pas insÃ©rÃ© dans Â«effectÂ». <br><br>  Une garantie plus faible se retrouve Ã©galement dans la mise en Å“uvre du Â«bracketÂ» dans Cats IO. <br><br>  Pour obtenir une fuite de ressources, utilisez simplement l'effet utilisÃ© Ã  l'intÃ©rieur de l'effet "Guarantee" ou "bracket.use", composez-le avec quelque chose comme ceci: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   `interruptedFiber` -    val bigTrouble = interruptedFiber.join</span></span></code> </pre> <br>  Lorsque bigTrouble est insÃ©rÃ© de cette maniÃ¨re dans un autre effet, l'effet devient ininterrompu - aucun "finaliseur" dÃ©fini via la "garantie", ou le nettoyage des ressources via le "support" ne sera pas exÃ©cutÃ©.  Tout cela conduit Ã  un Ã©puisement des ressources, mÃªme lorsqu'il y a un Â«finaliseurÂ» dans le bloc. <br><br>  Par exemple, le Â«finalizerÂ» dans le code suivant ne dÃ©marrera jamais l'exÃ©cution: <br><br><pre> <code class="scala hljs">(<span class="hljs-type"><span class="hljs-type">IO</span></span>.unit &gt;&gt; bigTrouble).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>(println(<span class="hljs-string"><span class="hljs-string">"Won't be executed!!!Â«)))</span></span></code> </pre> <br>  Lors de l'Ã©valuation du code sans prendre en compte le contexte global, il est impossible de dÃ©terminer si un effet, tel que "bigTrouble", sera insÃ©rÃ© n'importe oÃ¹ dans l'effet "use" de l'opÃ©ration "bracket" ou Ã  l'intÃ©rieur du bloc "finalizer". <br><br>  Par consÃ©quent, vous ne pourrez pas savoir si le programme Cats IO fonctionnera avec des fuites de ressources ou des blocs de Â«finaliseurÂ» manquants sans Ã©valuer lâ€™ensemble du programme.  L'ensemble du programme ne peut Ãªtre Ã©valuÃ© que manuellement, et ce processus est toujours accompagnÃ© d'erreurs qui ne peuvent pas Ãªtre vÃ©rifiÃ©es par le compilateur.  En outre, ce processus doit Ãªtre rÃ©pÃ©tÃ© chaque fois que des modifications importantes du code se produisent. <br><br>  ZIO a une implÃ©mentation personnalisÃ©e de Â«garantieÂ» de Cats Effect, Â«GuaranteeCaseÂ» et Â«bracketÂ».  Les implÃ©mentations utilisent la sÃ©mantique ZIO native (pas la sÃ©mantique Cats IO), ce qui nous permet d'Ã©valuer les problÃ¨mes possibles avec les fuites de ressources ici et maintenant, sachant que dans toutes les situations, les finaliseurs seront lancÃ©s et les ressources seront libÃ©rÃ©es. <br><br><h2>  4. Commutation stable </h2><br>  Cats Effect a la mÃ©thode Â«evalOnÂ» de Â«ContextShiftÂ», qui vous permet de dÃ©placer l'exÃ©cution de certains codes vers un autre contexte d'exÃ©cution. <br><br>  Ceci est utile pour plusieurs raisons: <br><br><ul><li>  de nombreuses bibliothÃ¨ques clientes vous obligent Ã  travailler dans leur pool de threads; </li><li>  Les bibliothÃ¨ques d'interface utilisateur nÃ©cessitent certaines mises Ã  jour pour se produire dans le thread d'interface utilisateur; </li><li>  certains effets nÃ©cessitent une isolation sur des pools de threads adaptÃ©s Ã  leurs spÃ©cificitÃ©s. </li></ul><br>  L'opÃ©ration Â«EvalOnÂ» exÃ©cute l'effet lÃ  oÃ¹ il doit Ãªtre exÃ©cutÃ©, puis revient au contexte d'exÃ©cution d'origine.  Par exemple: <br><br><pre> <code class="scala hljs">cs.evalOn(kafkaContext)(kafkaEffect)</code> </pre> <br>  Remarque: Cats IO a une construction "shift" similaire, qui vous permet de basculer vers un contexte diffÃ©rent sans revenir en arriÃ¨re, mais en pratique, ce comportement est rarement requis, donc "evalOn" est prÃ©fÃ©rÃ©. <br><br>  L'implÃ©mentation ZIO de Â«evalOnÂ» (rÃ©alisÃ©e sur le Â«verrouÂ» primitif ZIO) fournit les garanties nÃ©cessaires pour comprendre de maniÃ¨re unique oÃ¹ fonctionne l'effet - l'effet sera toujours exÃ©cutÃ© dans un contexte spÃ©cifique. <br><br>  Cats IO a une garantie diffÃ©rente et plus faible - l'effet sera exÃ©cutÃ© dans un certain contexte jusqu'au premier fonctionnement asynchrone ou commutation interne. <br><br>  En considÃ©rant un petit morceau de code, il est impossible de savoir avec certitude si un effet asynchrone (ou une commutation imbriquÃ©e) sera intÃ©grÃ© Ã  l'effet qui basculera, car l'asynchronie n'est pas affichÃ©e dans les types. <br><br>  Par consÃ©quent, comme dans le cas de la sÃ©curitÃ© des ressources, pour comprendre oÃ¹ l'effet Cats IO sera lancÃ©, il est nÃ©cessaire d'Ã©tudier l'ensemble du programme.  Dans la pratique, et d'aprÃ¨s mon expÃ©rience, les utilisateurs de Cats IO sont surpris quand, en utilisant Â«evalOnÂ» dans un contexte, on dÃ©couvre par la suite que la plupart de l'effet a Ã©tÃ© accidentellement exÃ©cutÃ© dans un autre. <br><br>  ZIO vous permet de dÃ©terminer oÃ¹ les effets doivent Ãªtre dÃ©clenchÃ©s et de croire que cela se produira dans tous les cas, quelle que soit la faÃ§on dont les effets sont intÃ©grÃ©s dans d'autres effets. <br><br><h2>  5. SÃ©curitÃ© des messages d'erreur </h2><br>  Tout effet qui prend en charge la simultanÃ©itÃ©, la simultanÃ©itÃ© ou l'accÃ¨s sÃ©curisÃ© aux ressources s'exÃ©cutera dans un modÃ¨le d'erreur linÃ©aire: en gÃ©nÃ©ral, toutes les erreurs ne peuvent pas Ãªtre enregistrÃ©es. <br><br>  Cela est vrai Ã  la fois pour Throwable, un type d'erreur fixe intÃ©grÃ© Ã  Cats IO et pour le type d'erreur polymorphe pris en charge par ZIO. <br><br>  Exemples de situations avec plusieurs erreurs ponctuelles: <br><br><ul><li>  Finalizer lÃ¨ve une exception; </li><li>  deux effets (en baisse) sont combinÃ©s en exÃ©cution parallÃ¨le; </li><li>  deux effets (en baisse) en Ã©tat de course; </li><li>  l'effet interrompu diminue avant de quitter la section Ã  l'abri des interruptions. </li></ul><br>  Ã‰tant donnÃ© que toutes les erreurs ne sont pas enregistrÃ©es, ZIO fournit une structure de donnÃ©es Â«Cause [E]Â» basÃ©e sur un semirage libre (une abstraction de l'algÃ¨bre abstraite, sa connaissance n'est pas supposÃ©e ici), qui permet de connecter des erreurs sÃ©rie et parallÃ¨les pour tout type d'erreur.  Pendant toutes les opÃ©rations (y compris le nettoyage pour un effet tombÃ© ou interrompu), ZIO regroupe les erreurs dans la structure de donnÃ©es Â«Cause [E]Â».  Cette structure de donnÃ©es est disponible Ã  tout moment.  Par consÃ©quent, ZIO stocke toujours toutes les erreurs: elles sont toujours disponibles, elles peuvent Ãªtre enregistrÃ©es, Ã©tudiÃ©es et transformÃ©es selon les besoins de l'entreprise. <br><br>  Cats IO a choisi un modÃ¨le avec perte d'informations d'erreur.  Alors que ZIO connectera les deux erreurs via Cause [E], Cats IO Â«perdraÂ» l'un des messages d'erreur, par exemple, en appelant Â«e.printStackTrace ()Â» sur l'erreur qui se produit. <br><br>  Par exemple, une erreur dans le Â«finaliseurÂ» de ce code sera perdue. <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 1"</span></span>)).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 2Â«)))</span></span></code> </pre> <br>  Cette approche du suivi des erreurs signifie que vous ne pouvez pas localiser et traiter localement tout le spectre des erreurs qui se produisent en raison de la combinaison d'effets.  ZIO vous permet d'utiliser tout type d'erreur, y compris Â«ThrowableÂ» (ou des sous-types plus spÃ©cifiques comme Â«IOExceptioÂ» ou une autre hiÃ©rarchie d'exceptions personnalisÃ©e), garantissant qu'aucune erreur n'est perdue pendant l'exÃ©cution du programme. <br><br><h2>  6. Asynchronie sans blocages </h2><br>  ZIO et Cats IO fournissent un constructeur qui vous permet de prendre du code avec un rappel et de l'envelopper en effet <br><br>  Cette fonctionnalitÃ© est fournie via la classe de canal Async dans Cats Effect: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Data</span></span>] = <span class="hljs-type"><span class="hljs-type">Async</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>].async(k =&gt; getDataWithCallbacks( onSuccess = v =&gt; k(<span class="hljs-type"><span class="hljs-type">Right</span></span>(v)), onFailure = e =&gt; k(<span class="hljs-type"><span class="hljs-type">Left</span></span>(e)) ))</code> </pre><br>  Cela crÃ©e un effet asynchrone qui, une fois exÃ©cutÃ©, attendra que la valeur apparaisse, puis continue, et tout cela sera Ã©vident pour l'utilisateur de l'effet.  Par consÃ©quent, la programmation fonctionnelle est si intÃ©ressante pour dÃ©velopper du code asynchrone. <br><br>  Notez que dÃ¨s que le code de rappel se transforme en effet, la fonction de rappel (ici on l'appelle `k`) est appelÃ©e.  Cette fonction de rappel se termine avec une valeur de succÃ¨s / erreur.  Lorsque cette fonction de rappel est appelÃ©e, l'exÃ©cution de l'effet (prÃ©cÃ©demment interrompu) reprend. <br><br>  ZIO garantit que l'effet reprendra son exÃ©cution sur le pool de threads d'exÃ©cution si l'effet n'a pas Ã©tÃ© affectÃ© Ã  un contexte spÃ©cial particulier ou Ã  un autre contexte auquel l'effet a Ã©tÃ© attachÃ©. <br><br>  Cats IO reprend l'effet sur le thread de rappel.  La diffÃ©rence entre ces options est assez profonde: le thread provoquant le rappel ne s'attend pas Ã  ce que le code de rappel soit exÃ©cutÃ© pour toujours, mais n'autorise qu'un lÃ©ger dÃ©lai avant le retour du contrÃ´le.  D'un autre cÃ´tÃ©, Cats IO n'offre aucune garantie: le thread appelant, le rappel de lancement, peut se bloquer, en attendant un temps indÃ©fini lorsque le contrÃ´le d'exÃ©cution revient. <br><br>  Les versions antÃ©rieures des structures de donnÃ©es concurrentielles dans Cats Effect (Â«diffÃ©rÃ©Â», Â«sÃ©maphoreÂ») ont repris des effets qui ne renvoyaient pas le contrÃ´le de l'exÃ©cution au thread appelant.  En consÃ©quence, des problÃ¨mes liÃ©s aux blocages et Ã  un programmateur d'exÃ©cution cassÃ© ont Ã©tÃ© dÃ©couverts dans ces derniers.  Bien que tous ces problÃ¨mes aient Ã©tÃ© trouvÃ©s, ils ne sont rÃ©solus que pour les structures de donnÃ©es compÃ©titives dans Cats Effect. <br><br>  Le code utilisateur qui utilise une approche similaire Ã  celle de Cats IO se heurtera Ã  de tels problÃ¨mes, car ces tÃ¢ches ne sont pas dÃ©terministes, les erreurs ne peuvent se produire que trÃ¨s rarement pendant l'exÃ©cution, ce qui rend le dÃ©bogage et la dÃ©tection des problÃ¨mes un processus difficile. <br><br>  ZIO fournit une protection contre les interblocages et un planificateur de tÃ¢ches normal, et oblige Ã©galement l'utilisateur Ã  choisir explicitement le comportement de Cats IO (par exemple, en utilisant "unsafeRun" sur "Promise", ce qui s'est terminÃ© par un effet asynchrone repris). <br><br>  Bien qu'aucune des solutions ne convienne Ã  tous les cas et que ZIO et Cats IO offrent suffisamment de flexibilitÃ© pour rÃ©soudre toutes les situations (de diffÃ©rentes maniÃ¨res), choisir ZIO signifie utiliser "Async" sans aucun souci et vous oblige Ã  mettre le code du problÃ¨me dans "unsafeRun", qui est connu pour provoquer une impasse <br><br><h2>  7. Compatible avec Future </h2><br>  L'utilisation de Â«FutureÂ» de la bibliothÃ¨que standard de Scala est une rÃ©alitÃ© pour un grand nombre de bases de code.  ZIO est livrÃ© avec une mÃ©thode Â«fromFutureÂ», qui fournit un contexte d'exÃ©cution prÃªt Ã  l'emploi: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fromFuture(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ec =&gt; <span class="hljs-comment"><span class="hljs-comment">// Create some Future using `ec`: ??? )</span></span></code> </pre> <br>  Lorsque cette mÃ©thode est utilisÃ©e pour envelopper Future dans un effet, ZIO peut dÃ©finir oÃ¹ Future sera exÃ©cutÃ© et d'autres mÃ©thodes, telles que evalOn, transfÃ¨reront correctement Future dans le contexte d'exÃ©cution souhaitÃ©.  Cats IO accepte "Future", qui a Ã©tÃ© crÃ©Ã© avec un "ExecutionContext" externe.  Cela signifie que Cats IO ne peut pas dÃ©placer l'exÃ©cution de Future selon les exigences des mÃ©thodes evalOn ou shift.  De plus, cela oblige l'utilisateur Ã  dÃ©terminer le contexte d'exÃ©cution pour Future, ce qui signifie une sÃ©lection Ã©troite et un environnement sÃ©parÃ©. <br><br>  Ã‰tant donnÃ© que le ExecutionContext fourni peut Ãªtre ignorÃ©, ZIO peut Ãªtre reprÃ©sentÃ© comme la somme des capacitÃ©s Cats IO, garantissant une interaction plus fluide et plus prÃ©cise avec Future dans le cas gÃ©nÃ©ral, mais il existe toujours des exceptions. <br><br><h2>  8. Blocage des E / S </h2><br>  Comme indiquÃ© dans l'article Â« <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Thread Pool.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Meilleures pratiques avec ZIO</a> â€, pour les applications serveur, au moins deux pools distincts sont requis pour une efficacitÃ© maximale: <br><br><ul><li>  pool fixe pour CPU / effets asynchrones; </li><li>  dynamique, avec la possibilitÃ© d'augmenter le nombre de threads de blocage. </li></ul><br>  La dÃ©cision d'exÃ©cuter tous les effets sur un pool de threads fixe entraÃ®nera un jour un blocage, tandis que le dÃ©clenchement de tous les effets sur un pool dynamique peut entraÃ®ner une perte de performances. <br><br>  Sur la JVM, ZIO propose deux opÃ©rations qui prennent en charge les effets de blocage: <br><br><ul><li>  OpÃ©rateur "Blocking (effect"), qui commute l'exÃ©cution d'un certain effet dans un pool de threads de blocage qui ont de bons prÃ©rÃ©glages qui peuvent Ãªtre modifiÃ©s si vous le souhaitez); </li><li> Â«effectBlocking(effect)Â» ,          ,        . </li></ul><br>     ,     ,       ,       Â«blockingÂ».   ,    -    ,  ,       Â«effectBlockingÂ»     ,    ZIO  (  ). <br><br> Cats IO    ,         .    ,     Â«blockingÂ»,    Â«evalOnÂ», , ,         . <br><br>           (      ZIO)         (,        ),          . <br><br><h2> 9.   </h2><br>  ,      Scala,          : <br><br><ul><li> Â«ReaderTÂ»/ Â«KleisliÂ»,       ; </li><li> Â«EitherTÂ»,      ( Â«OptionTÂ»,     Â«EitherTÂ»   Â«UnitÂ»    ). </li></ul><br>    ,          (, http4s   Â«KleisliÂ»  Â«OptionTÂ»).        (Â«effect totationÂ»), ZIO   Â«readerÂ»  Â«typed errorÂ»      ZIO.         Â«readerÂ»  Â«typed errorÂ» , ZIO    ,    . , Â«Task[A]Â»,    Â«readerÂ»  Â«typed errorsÂ». <br><br>   ZIO     ()      - .  ,      ZIO     ,      . <br><br> Cats IO    .  ,  ,   Â«readerÂ»  Â«typed errorsÂ»      Â«stateÂ», Â«writerÂ»  ,      . <br><br> ZIO     8   Cats IO    .               ,          Scala          . <br><br><h2> 10.   </h2><br> ZIO   ,        ,      . ,           Scala,      . <br><br>   ZIO   2000  ,    Â«typed errorsÂ»  ,       â€”     375    .        Scala ,      .     ,      ,         . <br><br>           : <br><br><ul><li>      ; </li><li>        ; </li><li>  ,       ; </li><li>       . </li></ul><br>         .   , -    ,      . <br><br> -            .        ,     .      ZIO    . Cats IO    ,     ,  ZIO ( ,       ). <br><br><h2> 11.   </h2><br>  ZIO   ,     ,  -       . <br><br><ul><li>  ,  : Â«ZIO. succeedÂ»  Â«Applicative[F].pureÂ», Â«zipÂ»  Â«Apply[F].productÂ», Â«ZIO.foreachÂ»  Â«Traverse[F].traverseÂ». <br></li><li>         (Cats, Cats Effect, Scalaz     ). </li><li>  ,       (  Â«RuntimeÂ»,      Cats Effect  -   Cats Effect).  â€”        Cats IO. </li><li>    . </li><li>         . : "zip"/"zipPar", "ZIO.foreach"/"ZIO.foreachPar", "ZIO.succeed"/"ZIO.succeedLazyÂ«. <br></li><li>      ,        Â«Â».   ZIO    IDE. </li><li>      Scala  ZIO  : Â«ZIO.fromFutureÂ», Â«ZIO.fromOptionÂ», Â«ZIO.fromEitherÂ», Â«ZIO.fromTryÂ». </li><li>         Â«Â». </li></ul><br> ,          Scala,    ,  ZIO   ,       ,   ,   ZIO,     . Cats IO     ,        Cats. <br><br>     ,      ,     ,       ( , ,    ). <br><br><h2> 12.  </h2><br> ZIO â€”  - ,           . <br><br>     : <br><br><ul><li>     ,  Â«RefÂ», Â«PromiseÂ», Â«QueueÂ», Â«SemaphoreÂ»   Â«StreamÂ»    //; </li><li> STM,       , ,     ; </li><li> Â«ScheduleÂ»,    ; </li><li>    Â«ClockÂ», Â«RandomÂ», Â«ConsoleÂ»  Â«SystemÂ» ,     ; </li><li>      ,    . </li></ul><br> -   Cats IO    .    Cats IO  ,      (  )      . <br><br><h2>  Conclusion </h2><br>  Cats Effect      Scala-,   ,    . <br><br>  ,   Cats Effect,    ,         Cats Effect : Cats IO, Monix, Zio. <br><br>    ,      .        ,    , ,  : ZIO  Cats Effect    . <br><br><blockquote>          Scala      â€”    .          ,   Scala. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ScalaConf  ,   18     ,     John A De Goes  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472386/">https://habr.com/ru/post/fr472386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472372/index.html">Automatisation Android Guide super simple pour crÃ©er votre premier test Espresso</a></li>
<li><a href="../fr472374/index.html">Pourquoi nous avons dÃ©placÃ© des serveurs en Islande</a></li>
<li><a href="../fr472378/index.html">FiabilitÃ© du flash: attendue et inattendue. Partie 2. XIV confÃ©rence de l'association USENIX. Technologies de stockage de fichiers</a></li>
<li><a href="../fr472380/index.html">MIRO - une plateforme robotique intÃ©rieure ouverte</a></li>
<li><a href="../fr472384/index.html">Un aperÃ§u des mises Ã  jour Android du point de vue d'un dÃ©veloppeur</a></li>
<li><a href="../fr472388/index.html">Walmart dÃ©clare la guerre des prix sur Amazon</a></li>
<li><a href="../fr472392/index.html">La montÃ©e, la chute et le retour possible des cassettes audio - nous traitons des mythes et donnons un aperÃ§u de la situation</a></li>
<li><a href="../fr472394/index.html">Ã‰valuer l'impact de l'intelligence artificielle sur le pÃ©trole et le gaz offshore</a></li>
<li><a href="../fr472396/index.html">Le tour du monde en 4 secondes au Columnstore (partie 1)</a></li>
<li><a href="../fr472402/index.html">Streaming d'appels vidÃ©o RTMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>