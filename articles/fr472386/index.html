<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛏️ 💃🏼 👩‍👩‍👦‍👦 ZIO & Cats Effect: une alliance réussie 😾 😉 👼🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cats Effect est devenu une sorte de «flux réactifs» pour le monde Scala fonctionnel, vous permettant de combiner l'ensemble de l'écosystème diversifié...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ZIO & Cats Effect: une alliance réussie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/472386/">  Cats Effect est devenu une sorte de «flux réactifs» pour le monde Scala fonctionnel, vous permettant de combiner l'ensemble de l'écosystème diversifié des bibliothèques. <br><br>  Beaucoup d'excellentes bibliothèques: http4s, fs2, doobie - sont implémentées uniquement sur la base des classes de type de Cats Effect.  Et des bibliothèques comme ZIO et Monix, à leur tour, fournissent des instances de ces classes de types pour leurs types d'effets.  Malgré certains problèmes qui seront corrigés dans la version 3.0, Cats Effect aide de nombreux contributeurs open source à prendre en charge de manière organique l'intégralité de l'écosystème fonctionnel du langage Scala.  Les développeurs qui utilisent Cats Effect sont confrontés à un choix difficile: la mise en œuvre des effets à utiliser pour leurs applications. <br><br>  Aujourd'hui, il existe trois alternatives: <br><br><ul><li>  Cats IO, implémentation de référence; </li><li>  Monix, le type de données Task et sa réactivité en code; </li><li>  ZIO, le type de données ZIO et sa portée de cross-threading. </li></ul><br>  Dans cet article, je vais essayer de vous prouver que pour créer votre application à l'aide de Cats Effect, ZIO est un bon choix avec des solutions et des capacités de conception assez différentes de l'implémentation de référence dans Cats IO. <br><a name="habracut"></a><br><h2>  1. Meilleure architecture MTL / Tagless-Final </h2><br>  MTL (Monad Transformers Library) est un style de programmation dans lequel les fonctions sont polymorphes par leur type d'effet et expriment leurs exigences à travers une «contrainte de classe de type».  Dans Scala, cela est souvent appelé le style final sans étiquette (bien que ce ne soit pas la même chose), surtout lorsque la classe de type n'a pas de lois. <br><br>  Il est bien connu qu'il est impossible de définir une instance globale pour des classes de type MTL classiques telles que Writer et State, ainsi que pour des types d'effet tels que Cats IO.  Le problème est que les instances de ces classes de type pour ces types d'effets nécessitent l'accès à un état mutable, qui ne peut pas être créé globalement, car la création d'un état mutable est également un effet. <br><br>  Pour de meilleures performances, cependant, il est important d'éviter les "transformateurs monades" et de fournir directement l'implémentation Write et State, en plus du type d'effet principal. <br><br>  Pour y parvenir, les programmeurs Scala utilisent une astuce: ils créent (mais nettoient) des instances au niveau supérieur de leurs programmes avec des effets, puis les fournissent plus loin dans le programme sous forme d'implications locales: <br><br><pre><code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Ref</span></span>.make[<span class="hljs-type"><span class="hljs-type">AppState</span></span>](initialAppState).flatMap(ref =&gt; <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monadState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>, <span class="hljs-type"><span class="hljs-type">AppState</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">AppState</span></span>] = ref.get <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">AppState</span></span>): <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = ref.set(s).unit } myProgram )</code> </pre> <br>  Malgré le fait qu'une telle astuce soit utile, c'est toujours une «béquille».  Dans un monde idéal, toutes les instances de classes de types pourraient être cohérentes (une instance par type) et ne pas être créées localement, générant des effets, puis s'enveloppant comme par magie dans des valeurs implicites à utiliser par les méthodes suivantes. <br><br>  Une grande fonctionnalité de MTL / tagless-final est que vous pouvez définir directement la plupart des instances au-dessus du type de données ZIO à l'aide de l'environnement ZIO. <br><br>  Voici une façon de créer une définition globale MonadState pour un type de données ZIO: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadState</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">State</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">S</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.set(s).unit) }</code> </pre><br>  Une instance est désormais définie globalement pour tout environnement prenant en charge au moins <code>State[S]</code> . <br><br>  De même pour <code>FunctorListen</code> , autrement connu sous le nom de <code>MonadWriter</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOFunctorListen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>: <span class="hljs-type"><span class="hljs-type">Semigroup</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">Writer</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, (<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>)] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get.flatMap(w =&gt; fa.map(a =&gt; a -&gt; w))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tell</span></span></span></span>(w: <span class="hljs-type"><span class="hljs-type">W</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.update(_ |+| w).unit) }</code> </pre><br>  Et bien sûr, nous pouvons faire de même pour <code>MonadError</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>]{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">E</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = fa catchAll f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raiseError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](e: <span class="hljs-type"><span class="hljs-type">E</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fail(e) }</code> </pre> <br>  Cette technique est facilement applicable à d'autres classes de type, y compris les classes de type tagless-final, dont les instances peuvent nécessiter la génération d'effets (modifications, configurations), les fonctions de test qui génèrent des effets (combinaison des effets d'environnement avec tagless-final), ou toute autre chose facilement accessible depuis l'environnement . <br><br>  Plus de transformations monadiques lentes!  Disons «non» à la création d'effets lors de l'initialisation des instances de la classe, aux implications locales.  Plus besoin de béquilles.  Immersion directe dans une programmation fonctionnelle pure. <br><br><h2>  2. Économiser des ressources pour les simples mortels </h2><br>  L'une des premières fonctionnalités de ZIO a été l'interruption - la capacité du runtime ZIO d'interrompre instantanément tout effet exécutable et garanti de libérer toutes les ressources.  Une implémentation brute de cette fonctionnalité a atteint Cats IO. <br><br>  Haskell a appelé une telle fonctionnalité une exception asynchrone, qui vous permet de créer et d'utiliser efficacement la latence, des opérations parallèles et compétitives efficaces et des calculs optimaux à l'échelle mondiale.  De telles interruptions apportent non seulement de grands avantages, mais posent également des tâches complexes dans le domaine de la prise en charge d'un accès sécurisé aux ressources. <br><br>  Les programmeurs sont habitués à suivre les erreurs dans les programmes grâce à une analyse simple.  Cela peut également être fait avec ZIO, qui utilise un système de type pour aider à détecter les erreurs.  Mais l'interruption est autre chose.  Un effet créé à partir de nombreux autres effets peut être interrompu à n'importe quelle frontière. <br><br>  Considérez l'effet suivant: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle) _ &lt;- closeFile(handle) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> data</code> </pre> <br>  La plupart des développeurs ne seront pas surpris de ce scénario: <code>closeFile</code> ne sera pas exécuté si <code>readFile</code> plante.  Heureusement, le système d'effets a une <code>ensuring</code> ( <code>guarantee</code> dans Cats Effect) qui vous permet d'ajouter un gestionnaire final à l'effet finalizer, comme pour finalement. <br><br>  Ainsi, le problème principal du code ci-dessus peut être facilement résolu: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle).ensuring(closeFile(handle)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> ()</code> </pre> <br>  Maintenant, l'effet est devenu «résistant aux chutes», en ce sens que si le <code>readFile</code> casse, le fichier sera toujours fermé.  Et si <code>readFile</code> réussit, le fichier sera également fermé.  Dans tous les cas, le dossier sera fermé. <br><br>  Mais pas tout à fait du tout.  L'interruption signifie que l'effet peut être interrompu partout, même entre <code>openFile</code> et <code>readFile</code> .  Si cela se produit, le fichier ouvert ne sera pas fermé et une fuite de ressources se produira. <br><br>  Le modèle d'obtention et de libération d'une ressource est si répandu que ZIO a introduit un opérateur de support, qui est également apparu dans Cats Effect 1.0.  L'instruction Bracket protège contre les interruptions: si la ressource est reçue avec succès, la libération se produit même si l'effet utilisant la ressource est interrompu.  De plus, ni la réception ni la libération de la ressource ne peuvent être interrompues, offrant ainsi une garantie de sécurité des ressources. <br><br>  En utilisant un support, l'exemple ci-dessus ressemblerait à ceci: <br><br><pre> <code class="scala hljs">openFile(file).bracket(closeFile(_))(readFile(_))</code> </pre> <br>  Malheureusement, la parenthèse n'encapsule qu'un seul modèle de consommation de ressources (assez général).  Il en existe bien d'autres, notamment avec des structures de données compétitives, dont l'accès doit être accessible pour les interruptions, sinon des fuites sont possibles. <br><br>  En général, tout travail d'interruption se résume à deux choses principales: <br><br><ul><li>  prévenir les interruptions dans certaines zones qui pourraient être interrompues; </li><li>  permettre une interruption dans les zones susceptibles de geler. </li></ul><br>  ZIO a la capacité de mettre en œuvre les deux.  Par exemple, nous pouvons développer notre propre version de bracket en utilisant des abstractions ZIO de bas niveau: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.uninterruptible { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { a &lt;- acquire exit &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.interruptible(use(a)) .run.flatMap(exit =&gt; release(a, exit) .const(exit)) b &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.done(exit) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> b }</code> </pre><br>  Dans ce code, l' <code>use(a)</code> est la seule partie qui peut être interrompue.  Le code environnant garantit l'exécution de la <code>release</code> dans tous les cas. <br><br>  À tout moment, vous pouvez vérifier s'il existe une possibilité d'interruption.  Pour cela, seules deux opérations primitives sont nécessaires (toutes les autres en sont dérivées). <br><br>  Ce modèle d'interruption de composition complète vous permet d'implémenter non seulement une implémentation de support simple, mais également d'implémenter d'autres scénarios dans la gestion des ressources, dans lesquels un équilibre est trouvé entre les avantages et les inconvénients des interruptions. <br><br>  Cats IO ne fournit qu'une seule opération pour contrôler les interruptions: le combinateur non annulable.  Cela rend le bloc de code entier ininterrompu.  Bien que cette opération soit rarement utilisée, elle peut entraîner une fuite de ressources ou des verrous. <br><br>  En même temps, il s'avère que vous pouvez définir une primitive à l'intérieur de Cats IO, ce qui vous permet d'obtenir plus de contrôle sur les interruptions.  L'implémentation très compliquée de Fabio Labella s'est avérée extrêmement lente. <br><br>  ZIO vous permet d'écrire du code avec des interruptions, fonctionnant à un niveau élevé avec des instructions composées déclaratives, et ne vous oblige pas à choisir entre une complexité sévère combinée à de faibles performances et des fuites bloquantes. <br><br>  De plus, la mémoire transactionnelle logicielle récemment ajoutée dans ZIO permet à l'utilisateur d'écrire de manière déclarative des structures de données et du code qui sont automatiquement asynchrones, compétitifs et autorisent les interruptions. <br><br><h2>  3. Finaliseurs garantis </h2><br>  Le bloc try / finally dans de nombreux langages de programmation offre les garanties nécessaires pour écrire du code synchrone sans fuite de ressources. <br><br>  En particulier, ce bloc garantit ce qui suit: si un bloc try démarre l'exécution, alors le bloc finally s'exécutera lorsque try s'arrêtera. <br><br>  Cette garantie s'applique à: <br><br><ul><li>  il y a des blocs "try / finally" imbriqués; </li><li>  il y a des erreurs dans le "bloc try"; </li><li>  il y a des erreurs dans le bloc niché finalement. </li></ul><br>  L'opération «assurer» ZIO peut être utilisée comme try / enfin: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect2 = effect.ensuring(cleanup)</code> </pre> <br>  ZIO fournit les garanties suivantes pour "effect.ensuring (finalizer)": si "effect" a commencé à être exécuté, alors "finalizer" commencera son exécution lorsque "effect" s'arrêtera. <br><br>  Comme try / enfin, ces garanties restent dans les cas suivants: <br><br><ul><li>  Il existe des compositions «assurant» imbriquées; </li><li>  il y a des erreurs dans "l'effet"; </li><li>  il y a des erreurs dans le "finaliseur" imbriqué. </li></ul><br>  De plus, la garantie est maintenue même si l'effet est interrompu (les garanties sur la «tranche» sont similaires, en fait, la «tranche» est mise en œuvre sur la «garantie»). <br><br>  Le type de données Cats IO fournit une autre garantie, plus faible.  Pour «effect.guarantee (finalizer)», il est affaibli comme suit: si «effect» a commencé à être exécuté, «finalizer» commencera l'exécution lorsque «effect» s'arrêtera, si l'effet problématique n'est pas inséré dans «effect». <br><br>  Une garantie plus faible se retrouve également dans la mise en œuvre du «bracket» dans Cats IO. <br><br>  Pour obtenir une fuite de ressources, utilisez simplement l'effet utilisé à l'intérieur de l'effet "Guarantee" ou "bracket.use", composez-le avec quelque chose comme ceci: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   `interruptedFiber` -    val bigTrouble = interruptedFiber.join</span></span></code> </pre> <br>  Lorsque bigTrouble est inséré de cette manière dans un autre effet, l'effet devient ininterrompu - aucun "finaliseur" défini via la "garantie", ou le nettoyage des ressources via le "support" ne sera pas exécuté.  Tout cela conduit à un épuisement des ressources, même lorsqu'il y a un «finaliseur» dans le bloc. <br><br>  Par exemple, le «finalizer» dans le code suivant ne démarrera jamais l'exécution: <br><br><pre> <code class="scala hljs">(<span class="hljs-type"><span class="hljs-type">IO</span></span>.unit &gt;&gt; bigTrouble).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>(println(<span class="hljs-string"><span class="hljs-string">"Won't be executed!!!«)))</span></span></code> </pre> <br>  Lors de l'évaluation du code sans prendre en compte le contexte global, il est impossible de déterminer si un effet, tel que "bigTrouble", sera inséré n'importe où dans l'effet "use" de l'opération "bracket" ou à l'intérieur du bloc "finalizer". <br><br>  Par conséquent, vous ne pourrez pas savoir si le programme Cats IO fonctionnera avec des fuites de ressources ou des blocs de «finaliseur» manquants sans évaluer l’ensemble du programme.  L'ensemble du programme ne peut être évalué que manuellement, et ce processus est toujours accompagné d'erreurs qui ne peuvent pas être vérifiées par le compilateur.  En outre, ce processus doit être répété chaque fois que des modifications importantes du code se produisent. <br><br>  ZIO a une implémentation personnalisée de «garantie» de Cats Effect, «GuaranteeCase» et «bracket».  Les implémentations utilisent la sémantique ZIO native (pas la sémantique Cats IO), ce qui nous permet d'évaluer les problèmes possibles avec les fuites de ressources ici et maintenant, sachant que dans toutes les situations, les finaliseurs seront lancés et les ressources seront libérées. <br><br><h2>  4. Commutation stable </h2><br>  Cats Effect a la méthode «evalOn» de «ContextShift», qui vous permet de déplacer l'exécution de certains codes vers un autre contexte d'exécution. <br><br>  Ceci est utile pour plusieurs raisons: <br><br><ul><li>  de nombreuses bibliothèques clientes vous obligent à travailler dans leur pool de threads; </li><li>  Les bibliothèques d'interface utilisateur nécessitent certaines mises à jour pour se produire dans le thread d'interface utilisateur; </li><li>  certains effets nécessitent une isolation sur des pools de threads adaptés à leurs spécificités. </li></ul><br>  L'opération «EvalOn» exécute l'effet là où il doit être exécuté, puis revient au contexte d'exécution d'origine.  Par exemple: <br><br><pre> <code class="scala hljs">cs.evalOn(kafkaContext)(kafkaEffect)</code> </pre> <br>  Remarque: Cats IO a une construction "shift" similaire, qui vous permet de basculer vers un contexte différent sans revenir en arrière, mais en pratique, ce comportement est rarement requis, donc "evalOn" est préféré. <br><br>  L'implémentation ZIO de «evalOn» (réalisée sur le «verrou» primitif ZIO) fournit les garanties nécessaires pour comprendre de manière unique où fonctionne l'effet - l'effet sera toujours exécuté dans un contexte spécifique. <br><br>  Cats IO a une garantie différente et plus faible - l'effet sera exécuté dans un certain contexte jusqu'au premier fonctionnement asynchrone ou commutation interne. <br><br>  En considérant un petit morceau de code, il est impossible de savoir avec certitude si un effet asynchrone (ou une commutation imbriquée) sera intégré à l'effet qui basculera, car l'asynchronie n'est pas affichée dans les types. <br><br>  Par conséquent, comme dans le cas de la sécurité des ressources, pour comprendre où l'effet Cats IO sera lancé, il est nécessaire d'étudier l'ensemble du programme.  Dans la pratique, et d'après mon expérience, les utilisateurs de Cats IO sont surpris quand, en utilisant «evalOn» dans un contexte, on découvre par la suite que la plupart de l'effet a été accidentellement exécuté dans un autre. <br><br>  ZIO vous permet de déterminer où les effets doivent être déclenchés et de croire que cela se produira dans tous les cas, quelle que soit la façon dont les effets sont intégrés dans d'autres effets. <br><br><h2>  5. Sécurité des messages d'erreur </h2><br>  Tout effet qui prend en charge la simultanéité, la simultanéité ou l'accès sécurisé aux ressources s'exécutera dans un modèle d'erreur linéaire: en général, toutes les erreurs ne peuvent pas être enregistrées. <br><br>  Cela est vrai à la fois pour Throwable, un type d'erreur fixe intégré à Cats IO et pour le type d'erreur polymorphe pris en charge par ZIO. <br><br>  Exemples de situations avec plusieurs erreurs ponctuelles: <br><br><ul><li>  Finalizer lève une exception; </li><li>  deux effets (en baisse) sont combinés en exécution parallèle; </li><li>  deux effets (en baisse) en état de course; </li><li>  l'effet interrompu diminue avant de quitter la section à l'abri des interruptions. </li></ul><br>  Étant donné que toutes les erreurs ne sont pas enregistrées, ZIO fournit une structure de données «Cause [E]» basée sur un semirage libre (une abstraction de l'algèbre abstraite, sa connaissance n'est pas supposée ici), qui permet de connecter des erreurs série et parallèles pour tout type d'erreur.  Pendant toutes les opérations (y compris le nettoyage pour un effet tombé ou interrompu), ZIO regroupe les erreurs dans la structure de données «Cause [E]».  Cette structure de données est disponible à tout moment.  Par conséquent, ZIO stocke toujours toutes les erreurs: elles sont toujours disponibles, elles peuvent être enregistrées, étudiées et transformées selon les besoins de l'entreprise. <br><br>  Cats IO a choisi un modèle avec perte d'informations d'erreur.  Alors que ZIO connectera les deux erreurs via Cause [E], Cats IO «perdra» l'un des messages d'erreur, par exemple, en appelant «e.printStackTrace ()» sur l'erreur qui se produit. <br><br>  Par exemple, une erreur dans le «finaliseur» de ce code sera perdue. <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 1"</span></span>)).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 2«)))</span></span></code> </pre> <br>  Cette approche du suivi des erreurs signifie que vous ne pouvez pas localiser et traiter localement tout le spectre des erreurs qui se produisent en raison de la combinaison d'effets.  ZIO vous permet d'utiliser tout type d'erreur, y compris «Throwable» (ou des sous-types plus spécifiques comme «IOExceptio» ou une autre hiérarchie d'exceptions personnalisée), garantissant qu'aucune erreur n'est perdue pendant l'exécution du programme. <br><br><h2>  6. Asynchronie sans blocages </h2><br>  ZIO et Cats IO fournissent un constructeur qui vous permet de prendre du code avec un rappel et de l'envelopper en effet <br><br>  Cette fonctionnalité est fournie via la classe de canal Async dans Cats Effect: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Data</span></span>] = <span class="hljs-type"><span class="hljs-type">Async</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>].async(k =&gt; getDataWithCallbacks( onSuccess = v =&gt; k(<span class="hljs-type"><span class="hljs-type">Right</span></span>(v)), onFailure = e =&gt; k(<span class="hljs-type"><span class="hljs-type">Left</span></span>(e)) ))</code> </pre><br>  Cela crée un effet asynchrone qui, une fois exécuté, attendra que la valeur apparaisse, puis continue, et tout cela sera évident pour l'utilisateur de l'effet.  Par conséquent, la programmation fonctionnelle est si intéressante pour développer du code asynchrone. <br><br>  Notez que dès que le code de rappel se transforme en effet, la fonction de rappel (ici on l'appelle `k`) est appelée.  Cette fonction de rappel se termine avec une valeur de succès / erreur.  Lorsque cette fonction de rappel est appelée, l'exécution de l'effet (précédemment interrompu) reprend. <br><br>  ZIO garantit que l'effet reprendra son exécution sur le pool de threads d'exécution si l'effet n'a pas été affecté à un contexte spécial particulier ou à un autre contexte auquel l'effet a été attaché. <br><br>  Cats IO reprend l'effet sur le thread de rappel.  La différence entre ces options est assez profonde: le thread provoquant le rappel ne s'attend pas à ce que le code de rappel soit exécuté pour toujours, mais n'autorise qu'un léger délai avant le retour du contrôle.  D'un autre côté, Cats IO n'offre aucune garantie: le thread appelant, le rappel de lancement, peut se bloquer, en attendant un temps indéfini lorsque le contrôle d'exécution revient. <br><br>  Les versions antérieures des structures de données concurrentielles dans Cats Effect («différé», «sémaphore») ont repris des effets qui ne renvoyaient pas le contrôle de l'exécution au thread appelant.  En conséquence, des problèmes liés aux blocages et à un programmateur d'exécution cassé ont été découverts dans ces derniers.  Bien que tous ces problèmes aient été trouvés, ils ne sont résolus que pour les structures de données compétitives dans Cats Effect. <br><br>  Le code utilisateur qui utilise une approche similaire à celle de Cats IO se heurtera à de tels problèmes, car ces tâches ne sont pas déterministes, les erreurs ne peuvent se produire que très rarement pendant l'exécution, ce qui rend le débogage et la détection des problèmes un processus difficile. <br><br>  ZIO fournit une protection contre les interblocages et un planificateur de tâches normal, et oblige également l'utilisateur à choisir explicitement le comportement de Cats IO (par exemple, en utilisant "unsafeRun" sur "Promise", ce qui s'est terminé par un effet asynchrone repris). <br><br>  Bien qu'aucune des solutions ne convienne à tous les cas et que ZIO et Cats IO offrent suffisamment de flexibilité pour résoudre toutes les situations (de différentes manières), choisir ZIO signifie utiliser "Async" sans aucun souci et vous oblige à mettre le code du problème dans "unsafeRun", qui est connu pour provoquer une impasse <br><br><h2>  7. Compatible avec Future </h2><br>  L'utilisation de «Future» de la bibliothèque standard de Scala est une réalité pour un grand nombre de bases de code.  ZIO est livré avec une méthode «fromFuture», qui fournit un contexte d'exécution prêt à l'emploi: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fromFuture(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ec =&gt; <span class="hljs-comment"><span class="hljs-comment">// Create some Future using `ec`: ??? )</span></span></code> </pre> <br>  Lorsque cette méthode est utilisée pour envelopper Future dans un effet, ZIO peut définir où Future sera exécuté et d'autres méthodes, telles que evalOn, transfèreront correctement Future dans le contexte d'exécution souhaité.  Cats IO accepte "Future", qui a été créé avec un "ExecutionContext" externe.  Cela signifie que Cats IO ne peut pas déplacer l'exécution de Future selon les exigences des méthodes evalOn ou shift.  De plus, cela oblige l'utilisateur à déterminer le contexte d'exécution pour Future, ce qui signifie une sélection étroite et un environnement séparé. <br><br>  Étant donné que le ExecutionContext fourni peut être ignoré, ZIO peut être représenté comme la somme des capacités Cats IO, garantissant une interaction plus fluide et plus précise avec Future dans le cas général, mais il existe toujours des exceptions. <br><br><h2>  8. Blocage des E / S </h2><br>  Comme indiqué dans l'article « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Thread Pool.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Meilleures pratiques avec ZIO</a> ”, pour les applications serveur, au moins deux pools distincts sont requis pour une efficacité maximale: <br><br><ul><li>  pool fixe pour CPU / effets asynchrones; </li><li>  dynamique, avec la possibilité d'augmenter le nombre de threads de blocage. </li></ul><br>  La décision d'exécuter tous les effets sur un pool de threads fixe entraînera un jour un blocage, tandis que le déclenchement de tous les effets sur un pool dynamique peut entraîner une perte de performances. <br><br>  Sur la JVM, ZIO propose deux opérations qui prennent en charge les effets de blocage: <br><br><ul><li>  Opérateur "Blocking (effect"), qui commute l'exécution d'un certain effet dans un pool de threads de blocage qui ont de bons préréglages qui peuvent être modifiés si vous le souhaitez); </li><li> «effectBlocking(effect)» ,          ,        . </li></ul><br>     ,     ,       ,       «blocking».   ,    -    ,  ,       «effectBlocking»     ,    ZIO  (  ). <br><br> Cats IO    ,         .    ,     «blocking»,    «evalOn», , ,         . <br><br>           (      ZIO)         (,        ),          . <br><br><h2> 9.   </h2><br>  ,      Scala,          : <br><br><ul><li> «ReaderT»/ «Kleisli»,       ; </li><li> «EitherT»,      ( «OptionT»,     «EitherT»   «Unit»    ). </li></ul><br>    ,          (, http4s   «Kleisli»  «OptionT»).        («effect totation»), ZIO   «reader»  «typed error»      ZIO.         «reader»  «typed error» , ZIO    ,    . , «Task[A]»,    «reader»  «typed errors». <br><br>   ZIO     ()      - .  ,      ZIO     ,      . <br><br> Cats IO    .  ,  ,   «reader»  «typed errors»      «state», «writer»  ,      . <br><br> ZIO     8   Cats IO    .               ,          Scala          . <br><br><h2> 10.   </h2><br> ZIO   ,        ,      . ,           Scala,      . <br><br>   ZIO   2000  ,    «typed errors»  ,       —     375    .        Scala ,      .     ,      ,         . <br><br>           : <br><br><ul><li>      ; </li><li>        ; </li><li>  ,       ; </li><li>       . </li></ul><br>         .   , -    ,      . <br><br> -            .        ,     .      ZIO    . Cats IO    ,     ,  ZIO ( ,       ). <br><br><h2> 11.   </h2><br>  ZIO   ,     ,  -       . <br><br><ul><li>  ,  : «ZIO. succeed»  «Applicative[F].pure», «zip»  «Apply[F].product», «ZIO.foreach»  «Traverse[F].traverse». <br></li><li>         (Cats, Cats Effect, Scalaz     ). </li><li>  ,       (  «Runtime»,      Cats Effect  -   Cats Effect).  —        Cats IO. </li><li>    . </li><li>         . : "zip"/"zipPar", "ZIO.foreach"/"ZIO.foreachPar", "ZIO.succeed"/"ZIO.succeedLazy«. <br></li><li>      ,        «».   ZIO    IDE. </li><li>      Scala  ZIO  : «ZIO.fromFuture», «ZIO.fromOption», «ZIO.fromEither», «ZIO.fromTry». </li><li>         «». </li></ul><br> ,          Scala,    ,  ZIO   ,       ,   ,   ZIO,     . Cats IO     ,        Cats. <br><br>     ,      ,     ,       ( , ,    ). <br><br><h2> 12.  </h2><br> ZIO —  - ,           . <br><br>     : <br><br><ul><li>     ,  «Ref», «Promise», «Queue», «Semaphore»   «Stream»    //; </li><li> STM,       , ,     ; </li><li> «Schedule»,    ; </li><li>    «Clock», «Random», «Console»  «System» ,     ; </li><li>      ,    . </li></ul><br> -   Cats IO    .    Cats IO  ,      (  )      . <br><br><h2>  Conclusion </h2><br>  Cats Effect      Scala-,   ,    . <br><br>  ,   Cats Effect,    ,         Cats Effect : Cats IO, Monix, Zio. <br><br>    ,      .        ,    , ,  : ZIO  Cats Effect    . <br><br><blockquote>          Scala      —    .          ,   Scala. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ScalaConf  ,   18     ,     John A De Goes  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472386/">https://habr.com/ru/post/fr472386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472372/index.html">Automatisation Android Guide super simple pour créer votre premier test Espresso</a></li>
<li><a href="../fr472374/index.html">Pourquoi nous avons déplacé des serveurs en Islande</a></li>
<li><a href="../fr472378/index.html">Fiabilité du flash: attendue et inattendue. Partie 2. XIV conférence de l'association USENIX. Technologies de stockage de fichiers</a></li>
<li><a href="../fr472380/index.html">MIRO - une plateforme robotique intérieure ouverte</a></li>
<li><a href="../fr472384/index.html">Un aperçu des mises à jour Android du point de vue d'un développeur</a></li>
<li><a href="../fr472388/index.html">Walmart déclare la guerre des prix sur Amazon</a></li>
<li><a href="../fr472392/index.html">La montée, la chute et le retour possible des cassettes audio - nous traitons des mythes et donnons un aperçu de la situation</a></li>
<li><a href="../fr472394/index.html">Évaluer l'impact de l'intelligence artificielle sur le pétrole et le gaz offshore</a></li>
<li><a href="../fr472396/index.html">Le tour du monde en 4 secondes au Columnstore (partie 1)</a></li>
<li><a href="../fr472402/index.html">Streaming d'appels vidéo RTMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>