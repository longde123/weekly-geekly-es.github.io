<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∑ üè• üßñüèø Hola mundo Inmersi√≥n profunda en terminales üåª üç© üßï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Me inspir√≥ para escribir este art√≠culo un art√≠culo sobre el an√°lisis de Sishny printf . Sin embargo, se perdi√≥ un momento sobre la forma en que van lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hola mundo Inmersi√≥n profunda en terminales</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460257/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ha/5f/0v/ha5f0vjiijc9c92bnnt56z7jcpg.jpeg"></a> </p><br><p>  Me inspir√≥ para escribir este art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un art√≠culo sobre el an√°lisis de Sishny printf</a> .  Sin embargo, se perdi√≥ un momento sobre la forma en que van los datos despu√©s de que ingresan al dispositivo terminal.  En este art√≠culo quiero corregir este defecto y analizar la ruta de datos en el terminal.  Tambi√©n descubriremos c√≥mo Terminal se diferencia de Shell, qu√© es Pseudoterminal, c√≥mo funcionan los emuladores de terminal y mucho m√°s. </p><a name="habracut"></a><br><h2 id="osnovy">  Los fundamentos </h2><br><p>  Primero, comprendamos qu√© es Terminal, Shell, Console, c√≥mo Terminal Emulator difiere de Terminal ordinario, y por qu√© se llama as√≠.  Ya se ha escrito mucha informaci√≥n sobre esto, por lo que no escuchar√° nada nuevo aqu√≠.  Casi toda la informaci√≥n aqu√≠ fue tomada de Internet, proporcionar√© enlaces al final del art√≠culo.  Quien ya sabe lo que significan todas estas cosas, puede saltarse esta secci√≥n de manera segura. </p><br><hr><br><h3 id="terminal">  Terminal </h3><br><p>  <strong>Un terminal</strong> es una combinaci√≥n de una pantalla y un teclado, es decir, un dispositivo f√≠sico.  Antes de que los terminales se convirtieran en esta combinaci√≥n particular, eran un tipo de dispositivo llamado teleimpresora (teletipo, teletipo o TTY para abreviar), es decir, una combinaci√≥n de una impresora y un teclado.  T√≠picamente, m√∫ltiples terminales est√°n conectados a la misma computadora.  Por lo tanto, era posible trabajar para varios usuarios en la misma computadora, y cada uno ten√≠a su propia sesi√≥n, independiente de los dem√°s.  El terminal se llam√≥ as√≠ porque estaba ubicado al final del cable del terminal. </p><br><p>  Esto es <strong>teletipo</strong> : </p><br><img src="https://habrastorage.org/webt/m3/_3/yt/m3_3ytmmoofzwgpr3dpu78w8m7i.jpeg" alt="Teletype" title="Teletipo" width="430" height="370"><br><br><p>  Y esta es la <strong>Terminal</strong> : </p><br><img src="https://habrastorage.org/webt/pz/lj/eu/pzljeumccjvqmrunt-pqolnyx-c.jpeg" alt="Terminal" title="Terminal" width="430" height="370"><br><br><hr><br><h3 id="console">  Consola </h3><br><p>  <strong>Consola (consola)</strong> : un terminal que est√° conectado directamente a la computadora.  El hecho es que la mayor√≠a de los terminales estaban conectados impl√≠citamente, pero al menos uno estaba conectado directamente a la computadora.  La consola pod√≠a usar un c√≠rculo de personas estrictamente definido, ya que le permit√≠a configurar la computadora. </p><br><hr><br><h3 id="shell">  Concha </h3><br><p>  Si los dos anteriores son dispositivos f√≠sicos, entonces esta definici√≥n se refiere exclusivamente al software. </p><br><p>  <strong>Shell</strong> es un int√©rprete de l√≠nea de comando.  El objetivo principal es ejecutar otros programas.  Hay una gran cantidad de conchas diferentes.  El m√°s com√∫n es Bash (del ingl√©s Bourne Again SHell, que, como sugiere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a> , es un juego de palabras para Shell "nacido de nuevo", es decir, un Shell "revivido").  Otros ejemplos: Dash (un Shell ligero, disponible si ejecuta el binario en / bin / sh), Zsh. </p><br><hr><br><p>  Por supuesto, tanto los terminales como las consolas no pudieron sino encontrar su reflejo en los tiempos modernos.  Por lo tanto, adem√°s consideraremos cosas como <em>Terminal Emulator</em> y <em>Virtual Console</em> . </p><br><h3 id="terminal-emulator">  Emulador de terminal </h3><br><p>  <strong>Emulador de terminal</strong> : un emulador del buen terminal antiguo.  Se requiere un emulador de terminal para los programas que no pueden interactuar directamente con el sistema X Window: Bash, Vim y otros. </p><br><p>  Primero establezcamos las responsabilidades de la terminal: </p><br><ol><li>  Transferir la entrada del usuario a una computadora </li><li>  Entrega de salida de computadora a la pantalla </li></ol><br><p>  Por lo tanto, nuestro emulador de terminal hace exactamente lo mismo: proporciona la entrada del usuario al programa en ejecuci√≥n y tambi√©n muestra la salida del programa en la pantalla.  En cualquier caso, el significado permanece: entre el usuario y el programa en ejecuci√≥n, hay alg√∫n tipo de capa responsable de la entrada / salida.  Ejemplos de emulador de terminal: gnome-terminal, xterm, konsole. </p><br><p>  <strong>¬°No confunda el emulador de shell y terminal!</strong> <br>  Terminal Emulator es una aplicaci√≥n GUI, es decir, una ventana en el sistema X Window.  Shell es un int√©rprete de l√≠nea de comandos, es decir, solo un ejecutor de comandos, no tiene un shell gr√°fico.  Hablando correctamente, <strong>no</strong> <strong>ejecutas</strong> <strong>Bash</strong> , <strong>ejecutas Terminal Emulator, que inicia Bash dentro de s√≠ mismo</strong> .  Terminal Emulator y Bash son absolutamente 2 programas diferentes.  El primero es el √∫nico responsable de la entrada / salida, el segundo, de procesar los comandos. </p><br><p>  Adem√°s en el art√≠culo, todas las referencias al terminal se referir√°n al emulador de terminal. </p><br><hr><br><h3 id="virtual-console-virtual-terminal">  Consola virtual (terminal virtual) </h3><br><p>  Presione Ctrl + Alt + FN, donde N generalmente tiene valores del 1 al 6. Lo que acaba de ver se llama Consola virtual (consola virtual) o Terminal virtual (terminal virtual).  ¬øRecuerdas lo que dije antes sobre las terminales?  Muchas terminales estaban conectadas a una computadora y cada terminal era una sesi√≥n separada, independiente de las dem√°s.  La consola virtual repite esta idea: puede haber varias sesiones independientes dentro de su computadora (sin embargo, los recursos de la computadora a√∫n se comparten obviamente). </p><br><p>  Puede nombrar esta entidad como Consola virtual y Terminal virtual, porque, por definici√≥n, una consola es un terminal conectado directamente a una computadora, pero todos los terminales virtuales est√°n, en cierto sentido, conectados directamente a una computadora. </p><br><hr><br><h3 id="tty-ustroystva">  Dispositivos TTY </h3><br><p>  A cada terminal se le asigna su propio <em>dispositivo TTY</em> (dispositivo terminal), que proporciona la consola.  Aunque es poco probable que encuentres teletipos, pero la reducci√≥n en TTY ha sobrevivido hasta nuestros d√≠as. </p><br><p>  Un dispositivo TTY consta de dos componentes fundamentales: </p><br><ol><li>  <strong>Controlador de dispositivo</strong>  Es responsable de entregar la entrada del teclado al programa y de mostrar la salida del programa en la pantalla. </li><li>  <strong>TTY Line Discipline</strong> ( <strong>disciplina de l√≠nea</strong> rusa).  La disciplina de l√≠nea es la interfaz de acceso del controlador, que, sin embargo, aporta mucha l√≥gica al dispositivo TTY.  Podemos decir que la disciplina de l√≠nea llama al conductor.  ¬øCu√°l es el √°rea de responsabilidad de este componente? Lo descubriremos durante el art√≠culo. </li></ol><br><p>  Construir dispositivo TTY: </p><br><p><img src="https://habrastorage.org/webt/zn/zw/dy/znzwdyjadyeidyogqoap8kfvgng.jpeg" title="Construir dispositivo TTY"></p><br><p>  Hay 3 tipos de dispositivos TTY: </p><br><ol><li>  <em>Dispositivo de consola</em> : proporciona operaci√≥n de consola virtual.  La entrada y salida de este dispositivo est√° totalmente controlada por el n√∫cleo. </li><li>  <em>Dispositivo PTY</em> (pseudo-terminal): proporciona la operaci√≥n del terminal en la interfaz de la ventana.  La entrada y salida de este dispositivo est√° controlada por un emulador de terminal que opera en el espacio del usuario. </li><li>  <em>Dispositivo en serie</em> : se comunica directamente con el hardware.  Por lo general, no se usa directamente, pero existe como el nivel m√°s bajo en la organizaci√≥n de la arquitectura de un dispositivo terminal. </li></ol><br><p>  En este art√≠culo, hablaremos espec√≠ficamente sobre el segundo tipo de dispositivos TTY: pseudo terminales. </p><br><hr><br><h2 id="tty-line-discipline">  Disciplina de l√≠nea TTY </h2><br><p>  Comenzamos a examinar la disciplina de la l√≠nea de dispositivos TTY. </p><br><p>  La primera caracter√≠stica importante de una disciplina de l√≠nea es que es responsable del procesamiento de E / S.  Esto incluye, por ejemplo, procesar caracteres de control (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="Personajes de control">Caracteres de control</a> ) y formatear la salida.  Por ejemplo, ingresa cualquier texto, pero de repente se da cuenta de que se equivoc√≥ al escribir algo y quiere borrarlo; aqu√≠ es donde entra en juego la disciplina de l√≠nea. </p><br><p>  Analizaremos en detalle qu√© sucede exactamente cuando trabajamos en Bash ejecut√°ndose en la terminal.  Por defecto, un dispositivo TTY funciona en modo can√≥nico con <em>eco habilitado</em> .  Un eco es una visualizaci√≥n de los caracteres que ingres√≥ en la pantalla. </p><br><p> Cuando ingresamos, por ejemplo, el car√°cter <code>a</code> , este car√°cter se env√≠a al dispositivo TTY, pero es interceptado por la disciplina de la l√≠nea TTY del dispositivo.  Ella lee un personaje en su b√∫fer interno, ve que el modo de <code>echo</code> est√° activado y muestra el personaje en la pantalla.  En este momento, todav√≠a no hay nada disponible para leer en el programa al que est√° conectado el dispositivo terminal.  Presionemos la tecla de <code>backspace</code> en el teclado.  S√≠mbolo <code>^?</code>  nuevamente interceptado por la disciplina de la l√≠nea, y este √∫ltimo, al darse cuenta de que el usuario desea borrar el √∫ltimo car√°cter ingresado, elimina este car√°cter de su b√∫fer interno y tambi√©n lo borra de la pantalla.  Ahora, si presionamos Enter, la disciplina de l√≠nea TTY finalmente env√≠a al b√∫fer de lectura del dispositivo terminal todo lo que se escribi√≥ previamente en el b√∫fer de disciplina interna, incluido LF.  Al mismo tiempo, los caracteres CR y LF se muestran en la pantalla para mover el cursor a una nueva l√≠nea; este es el formato de la salida. </p><br><p>  As√≠ es como funciona el modo can√≥nico: transfiere todos los caracteres ingresados ‚Äã‚Äãal dispositivo solo despu√©s de presionar <code>Enter</code> , procesa los caracteres de control y formatea la salida. </p><br><h3 id="tty-line-editing">  Edici√≥n de l√≠nea TTY </h3><br><p>  <strong>La edici√≥n de l√≠nea TTY</strong> es el componente responsable de procesar la entrada en la disciplina de l√≠nea.  Debe decirse que la <em>Edici√≥n de l√≠nea</em> es un concepto general y se relaciona con el procesamiento de entrada.  Por ejemplo, Bash y Vim tienen su propia edici√≥n de l√≠nea. </p><br><p>  Podemos controlar la configuraci√≥n de disciplina de la l√≠nea del dispositivo TTY actual utilizando el programa <strong>stty</strong> .  Experimentemos un poco. </p><br><p>  Abra Bash o cualquier otro Shell y escriba: </p><br><pre> <code class="plaintext hljs">stty icanon -echo</code> </pre> <br><p>  Ahora intente escribir algo y no ver√° su entrada (no se preocupe, a√∫n puede pasar la entrada al programa).  Acaba de deshabilitar el eco, es decir, la visualizaci√≥n de los caracteres ingresados ‚Äã‚Äãen la pantalla.  Ahora ingrese: </p><br><pre> <code class="plaintext hljs">stty raw echo</code> </pre> <br><p>  Intenta escribir algo.  Ya ves c√≥mo se rompe la conclusi√≥n.  Pero para m√°s efecto, vayamos a Dash - escriba <code>/bin/sh</code> .  Ahora intente ingresar caracteres especiales ( <code>Ctrl</code> + cualquier car√°cter en el teclado) o simplemente presione <code>Enter</code> .  Est√°s perplejo, ¬øqu√© son estos extra√±os personajes en la pantalla?  El hecho es que, despu√©s de haber ingresado al Shell m√°s simple, adem√°s de la Edici√≥n de l√≠nea de la disciplina en s√≠, tambi√©n deshabilitamos Line Editing Bash, y ahora podemos observar con fuerza y ‚Äã‚Äãprincipal el efecto de la inclusi√≥n del modo <em>crudo</em> de disciplina de la l√≠nea.  Este modo no procesa la entrada en absoluto y no formatea la salida.  ¬øPor qu√© se necesita el modo sin formato?  Por ejemplo, para <em>Vim</em> : se abre en toda la ventana de terminal y procesa la entrada en s√≠, al menos para que los s√≠mbolos especiales de disciplina de l√≠nea no se crucen con s√≠mbolos especiales de Vim. </p><br><p>  Para una mayor comprensi√≥n, veamos c√≥mo personalizar los caracteres de control.  El <code>stty &lt;control-character&gt; &lt;string&gt;</code> nos ayudar√° con esto. <br>  Ingrese en Bash: </p><br><pre> <code class="bash hljs">stty erase 0</code> </pre> <br><p>  Ahora el car√°cter de control de <code>erase</code> se asignar√° al car√°cter <code>0</code> .  El bot√≥n de <code>backspace</code> generalmente importa <code>^?</code>  , pero ahora este car√°cter especial se enviar√° al b√∫fer de lectura PTS literalmente; pru√©belo usted mismo.  Ahora puede borrar caracteres usando el bot√≥n <code>0</code> en el teclado, porque usted mismo le pidi√≥ a tty line disciplina que reconozca el car√°cter ingresado como un car√°cter de control de <code>erase</code> .  Puede devolver la configuraci√≥n con el comando <code>stty erase ^\?</code>  o simplemente cerrando la terminal, porque solo afectamos al dispositivo tty actual. </p><br><p>  Puede encontrar m√°s informaci√≥n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="hombre stty">man stty</a> . </p><br><hr><br><h2 id="terminal-emulator-i-pseudoterminal">  Emulador de Terminal y Pseudoterminal </h2><br><p>  Cada vez que abrimos una nueva terminal en el sistema X Window, el servidor de terminal GNOME genera un nuevo proceso y lanza el programa predeterminado en √©l.  Por lo general, este es alg√∫n tipo de Shell (por ejemplo, Bash). </p><br><p>  La comunicaci√≥n con el programa en ejecuci√≥n ocurre a trav√©s del llamado <strong>Pseudoterminal</strong> (pseudo-terminal, PTY).  El pseudo-terminal en s√≠ existe en el n√∫cleo, sin embargo, recibe informaci√≥n del espacio del usuario, desde el emulador de terminal. </p><br><p>  El pseudo-terminal consta de los siguientes dos <em>dispositivos TTY virtuales</em> : <br>  1) <strong>PTY master (PTM)</strong> : la parte principal del pseudo-terminal.  Utilizado por GNOME Terminal Server para transferir la entrada del teclado a un programa que se ejecuta dentro del terminal, as√≠ como para leer la salida del programa y mostrar la salida.  El GNOME Terminal Server, a su vez, se comunica con el sistema X Window a trav√©s del protocolo X. <br>  2) <strong>PTY esclavo (PTS)</strong> : parte esclava del pseudo-terminal.  Utilizado por un programa que se ejecuta dentro del terminal para leer la entrada del teclado y mostrar la salida en la pantalla.  Al menos, el programa en s√≠ lo cree (explicar√© lo que esto significa, un poco m√°s adelante). </p><br><p>  Cualquier dato registrado en el dispositivo PTS es la entrada del dispositivo PTM, es decir, se vuelve legible en el dispositivo PTM.  Y viceversa: cualquier dato registrado en el dispositivo PTM es la entrada del dispositivo PTS.  As√≠ es como se comunican el Terminal Server de GNOME y el programa que se ejecuta dentro del terminal.  Cada dispositivo PTM est√° asociado con su propio dispositivo PTS. </p><br><p>  El proceso de lanzamiento de una nueva terminal se ve as√≠: <br>  1) GNOME Terminal Server crea dispositivos maestros y esclavos llamando a la funci√≥n open () en un dispositivo especial <strong>/ dev / ptmx</strong> .  La llamada open () devuelve el descriptor de archivo del dispositivo PTM creado: <em>master_fd</em> . <br>  2) GNOME Terminal Server crea un nuevo proceso llamando a <code>fork()</code> .  Este proceso ser√° la nueva terminal. <br>  3) En el terminal PTS, el dispositivo se abre en los descriptores de archivo 0, 1, 2 (stdin, stdout y stderr, respectivamente).  Ahora, el terminal est√°ndar de E / S fluye a este dispositivo. <br>  4) El programa deseado se inicia en el terminal llamando a la funci√≥n <code>exec()</code> .  Algunos Shell generalmente se inician (por ejemplo, Bash).  Cualquier programa que se inicie posteriormente desde Bash tendr√° los mismos descriptores de archivo que Bash, es decir, los flujos del programa se dirigir√°n al dispositivo PTS. </p><br><p>  Puede ver por s√≠ mismo hacia d√≥nde se dirigen los flujos de salida de terminal est√°ndar utilizando el <code>ls -la /proc/self/fd</code> : <br><img src="https://habrastorage.org/webt/nr/dx/97/nrdx97wllflvapnt76p3qqki3fw.jpeg"></p><br><p>  El dispositivo PTS se encuentra en la ruta <strong>/ dev / pts / N</strong> , y la ruta al dispositivo PTM no nos interesa en absoluto.  El hecho es que GNOME Terminal Server ya tiene un descriptor de archivo para el dispositivo PTM abierto y no necesita una ruta hacia √©l, sin embargo, en el proceso secundario, debemos abrir el dispositivo PTS en flujos de salida est√°ndar llamando a la funci√≥n <code>open()</code> , que requiere la ruta al archivo. </p><br><p>  ¬øRecuerdas que dije que un programa que usa un dispositivo PTS solo piensa que se comunica directamente con el terminal?  El hecho es que el PTS tambi√©n es un <em>dispositivo terminal</em> ( <em>dispositivo</em> TTY), pero la diferencia entre el dispositivo PTS y el dispositivo TTY real es que el dispositivo PTS recibe la entrada no desde el teclado, sino desde el dispositivo maestro, y la salida no va a la pantalla, sino a dispositivo maestro  Es por eso que el pseudo-terminal se llama as√≠: el pseudo-terminal solo imita (de nuevo ??) al terminal.  La diferencia entre el emulador de terminal y el pseudo-terminal es que el emulador de terminal es solo un programa gr√°fico que le permite ejecutar el terminal directamente dentro de la interfaz de la ventana, pero esta caracter√≠stica se implementa usando el pseudo-terminal. </p><br><p>  El hecho de que el <em>dispositivo PTS sea un dispositivo TTY</em> es muy importante.  He aqu√≠ por qu√©: </p><br><ol><li>  El programa al que est√° conectado el dispositivo terminal tiene todas las capacidades de un terminal convencional.  Por ejemplo: deshabilitar echo, deshabilitar / habilitar vista can√≥nica. </li><li>  El programa, sabiendo que un dispositivo terminal est√° conectado a √©l (se dice que el programa tiene un terminal de control), puede trabajar de manera interactiva y pedirle al usuario su entrada.  Por ejemplo, solicite un nombre de usuario y contrase√±a. </li><li>  Tambi√©n hay una disciplina de l√≠nea TTY, por lo que tenemos la capacidad de procesar caracteres de control antes de que lleguen al programa, as√≠ como formatear la salida del programa. </li></ol><br><p>  El dispositivo PTM tambi√©n es un dispositivo TTY, pero esto no juega ning√∫n papel, ya que no se utiliza como terminal de control.  Adem√°s, la disciplina de l√≠nea del dispositivo PTM se establece en modo sin procesar, por lo tanto, el procesamiento no se realiza cuando se transfieren datos del PTS al dispositivo PTM.  Sin embargo, las llamadas a <code>read()</code> y <code>write()</code> desde el espacio del usuario todav√≠a son atendidas primero por la disciplina de l√≠nea en ambos dispositivos.  Este momento jugar√° un papel a√∫n mayor, como veremos m√°s adelante. </p><br><p>  El proceso de comunicaci√≥n entre el Terminal Server de GNOME y el programa que se ejecuta dentro del terminal es el siguiente: </p><br><p><img src="https://habrastorage.org/webt/jz/y0/sg/jzy0sg0zjcceaflg6wyg7d5lkti.jpeg" title="El proceso de comunicaci√≥n GNOME Terminal Server y un programa que se ejecuta dentro de la terminal"></p><br><p>  Vale la pena examinar con m√°s detalle el papel que juega la disciplina de l√≠nea en la comunicaci√≥n entre ambas partes de un pseudo-terminal.  Aqu√≠, la disciplina de l√≠nea es responsable del procesamiento de los datos que <em>pasan del PTM al dispositivo PTS</em> , as√≠ como del env√≠o de datos de una parte del pseudo terminal a otra.  Cuando estamos en el controlador del dispositivo PTS, aplicamos la disciplina de l√≠nea del dispositivo PTM y viceversa. </p><br><hr><br><h2 id="virtualnye-ustroystva">  Dispositivos virtuales </h2><br><p>  Probablemente habr√≠a pensado que podr√≠a abrir el archivo a lo largo de la ruta <em>/ dev / pts / N</em> y escribir o leer datos de √©l, como de un archivo de texto normal.  S√≠, todos los dispositivos en sistemas tipo Unix son archivos, gracias al principio fundamental de Unix, que establece que todo es un archivo.  Sin embargo, ning√∫n archivo de dispositivo especial (ingl√©s - archivo de dispositivo) son archivos de texto.  Dichos dispositivos se denominan <strong>dispositivos virtuales</strong> , es decir, existen exclusivamente en la memoria, no en el disco. </p><br><p>  No intente abrir estos archivos como archivos de texto normales.  Sin embargo, puede usar estos dispositivos mediante operaciones de <code>write()</code> y <code>read()</code> , cuya llamada ser√° atendida por el controlador del dispositivo.  Intentemos hacerlo. </p><br><p>  Abra dos ventanas de terminal e ingrese <code>tty</code> en cada comando.  Este comando mostrar√° qu√© dispositivo TTY est√° sirviendo el terminal actualmente activo.  Ahora ingrese <code>echo "Hello, World!" &gt; /dev/pts/N</code>  <code>echo "Hello, World!" &gt; /dev/pts/N</code> en la primera ventana de terminal, donde N es el √≠ndice PTS del segundo dispositivo de ventana, cambie a la segunda ventana y ver√° su entrada desde la primera ventana.  Ahora ha escrito los datos en el dispositivo PTS de la segunda ventana <em>como si lo hubiera hecho un programa que se ejecuta en ese terminal</em> . </p><br><p><img src="https://habrastorage.org/webt/nj/3s/rp/nj3srpuzyahyvukzicfr0b5wnja.png"></p><br><hr><br><h2 id="ustroystvo-psevdoterminala">  Dispositivo pseudo terminal </h2><br><p>  Nos estamos acercando cada vez m√°s a la parte final del art√≠culo, pero antes de eso echamos un vistazo "bajo el cap√≥" de Linux: considere el dispositivo del pseudo-terminal a nivel del n√∫cleo.  Habr√° mucho c√≥digo, pero intentar√© explicar cada bloque de c√≥digo dado con el mayor detalle posible, reducir los detalles sin importancia e ir secuencialmente. </p><br><p>  Antes de comenzar, presentamos la llamada "cesta de componentes".  A medida que avanzamos a lo largo del n√∫cleo, le agregaremos m√°s y m√°s componentes y encontraremos una conexi√≥n entre ellos.  Espero que esto te ayude a comprender mejor el dispositivo pseudo-terminal.  Empecemos </p><br><p>  Cuando se inicia Linux, carga los controladores de dispositivo necesarios.  Nuestro pseudo-terminal tambi√©n tiene dicho controlador.  Su registro comienza con una llamada a esta funci√≥n: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __init pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { legacy_pty_init(); unix98_pty_init(); <span class="hljs-comment"><span class="hljs-comment">// &lt;- ,    return 0; } device_initcall(pty_init); // ,      </span></span></code> </pre> <br><p>  Para todos los sistemas modernos, la funci√≥n <code>unix98_pty_init()</code> se llamar√°: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __init unix98_pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { ptm_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 ptm driver"</span></span>); pts_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 pts driver"</span></span>); ptm_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_master"</span></span>; ptm_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"ptm"</span></span>; ptm_driver-&gt;major = UNIX98_PTY_MASTER_MAJOR; ptm_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;type = TTY_DRIVER_TYPE_PTY; ptm_driver-&gt;subtype = PTY_TYPE_MASTER; ptm_driver-&gt;init_termios = tty_std_termios; ptm_driver-&gt;init_termios.c_iflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_oflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; ptm_driver-&gt;init_termios.c_lflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;other = pts_driver; tty_set_operations(ptm_driver, &amp;ptm_unix98_ops); pts_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_slave"</span></span>; pts_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"pts"</span></span>; pts_driver-&gt;major = UNIX98_PTY_SLAVE_MAJOR; pts_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; pts_driver-&gt;type = TTY_DRIVER_TYPE_PTY; pts_driver-&gt;subtype = PTY_TYPE_SLAVE; pts_driver-&gt;init_termios = tty_std_termios; pts_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; pts_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;other = ptm_driver; tty_set_operations(pts_driver, &amp;pty_unix98_ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 ptm driver"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 pts driver"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Now create the /dev/ptmx special device */</span></span> tty_default_fops(&amp;ptmx_fops); ptmx_fops.open = ptmx_open; cdev_init(&amp;ptmx_cdev, &amp;ptmx_fops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cdev_add(&amp;ptmx_cdev, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>) || register_chrdev_region(<span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"/dev/ptmx"</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register /dev/ptmx driver"</span></span>); device_create(tty_class, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"ptmx"</span></span>);</code> </pre> <br><p>  Aqu√≠ estamos interesados ‚Äã‚Äãen 3 cosas: </p><br><ol><li>  Llama a <code>tty_set_operatons</code> para el controlador maestro pty y los dispositivos esclavos pty. </li><li>  La funci√≥n <code>ptmx_open</code> , que es responsable de crear ambas partes del pseudo-terminal al abrir el dispositivo especial <em>/ dev / ptmx</em> .  Importante: / dev / ptmx no es un dispositivo PTM, sino solo una interfaz para crear un nuevo pseudo-terminal. </li><li>  Registre los controladores de dispositivo PTM y PTS. </li></ol><br><p>  Vamos en orden: </p><br><h4 id="1-tty_set_operations">  1. tty_set_operations </h4><br><p>  La funci√≥n <strong>tty_set_operations ()</strong> simplemente configura una tabla de funciones para el controlador actual: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_set_operations(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations *op) { driver-&gt;ops = op; };</code> </pre> <br><p>  La estructura <strong>tty_operations</strong> es una tabla de funciones que se utiliza para acceder a las funciones del controlador TTY del dispositivo. </p><br><p>  <code>pty_unix98_ops</code> lo m√°s importante en las estructuras <code>pty_unix98_ops</code> y <code>ptm_unix98_ops</code> , que son la tabla de funciones para las partes correspondientes del pseudo-terminal: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }; static const struct tty_operations pty_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, // ... };</span></span></code> </pre> <br><p>  Aqu√≠ puede observar la funci√≥n pty_write, <code>pty_write</code> ya es familiar en el art√≠culo sobre Sishny printf; volveremos a ella un poco m√°s tarde. </p><br><p>  Agreguemos esta estructura a nuestra cesta de componentes: <br><img src="https://habrastorage.org/webt/o8/e-/kc/o8e-kcpqestn7f481gcx38qmzuo.jpeg"></p><br><p>  Como puede ver, los m√©todos principales de ambos controladores no son para nada diferentes.  Por cierto, observe que no hay una funci√≥n para la operaci√≥n read (), no hay nada como <code>pty_read()</code> .  El hecho es que la lectura ser√° servida √∫nicamente por disciplina de l√≠nea.  Por lo tanto, aprendemos sobre la segunda caracter√≠stica importante de la disciplina de l√≠nea: leer datos de un dispositivo TTY. </p><br><hr><br><h4 id="2-ptmx_open">  2. ptmx_open </h4><br><p>  Ahora pasemos a <strong>ptmx_open ()</strong> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptmx_open(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> inode *inode, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *filp) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; <span class="hljs-comment"><span class="hljs-comment">//    -   ! fsi = devpts_acquire(filp); //     devpts index = devpts_new_index(fsi); //       /dev/pts // ... tty = tty_init_dev(ptm_driver, index); // ... devpts_pty_new(fsi, index, tty-&gt;link); //     /dev/pts retval = ptm_driver-&gt;ops-&gt;open(tty, filp); //  PTM ,   }</span></span></code> </pre> <br><p>  Estamos interesados ‚Äã‚Äãen la funci√≥n <code>tty_init_dev()</code> , donde el primer argumento es el controlador del dispositivo PTM, y el segundo es el √≠ndice del dispositivo.  Aqu√≠ dejamos la zona de responsabilidad del controlador PTY y vamos al archivo, que solo es responsable de los dispositivos TTY generales y no sabe nada acerca de nuestro pseudo terminal. </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty_init_dev(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = alloc_tty_struct(driver, idx); retval = tty_driver_install_tty(driver, tty); <span class="hljs-comment"><span class="hljs-comment">/* * Structures all installed ... call the ldisc open routines. */</span></span> retval = tty_ldisc_setup(tty, tty-&gt;link); <span class="hljs-comment"><span class="hljs-comment">//  ,       return tty; }</span></span></code> </pre> <br><p>  Primero, <code>alloc_tty_struct()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *alloc_tty_struct(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*tty), GFP_KERNEL); <span class="hljs-comment"><span class="hljs-comment">//  tty_struct tty_ldisc_init(tty) //      tty_struct tty-&gt;driver = driver; //       tty_struct tty-&gt;ops = driver-&gt;ops; //        tty_struct.     tty-&gt;index = idx; //   tty  return tty; }</span></span></code> </pre> <br><p>  Lo √∫nico que nos interesa aqu√≠ es la funci√≥n <code>tty_ldisc_init()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_ldisc_init(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld = tty_ldisc_get(tty, N_TTY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ld)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(ld); tty-&gt;ldisc = ld; <span class="hljs-comment"><span class="hljs-comment">//        tty_struct return 0; }</span></span></code> </pre> <br><p>  Que llama a <code>tty_ldisc_get()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *tty_ldisc_get(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> disc) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_ldisc_ops *ldops; //     ldops = get_ldops(disc); //      .   ,       .   - N_TTY ld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL | __GFP_NOFAIL); ld-&gt;ops = ldops; //       ld-&gt;tty = tty; //    tty_struct   .          return ld; }</span></span></code> </pre> <br><p>  Entonces, examinamos la llamada a la funci√≥n <code>alloc_tty_struct()</code> , que crea la estructura <em>tty_struct</em> junto con la disciplina de l√≠nea, la estructura <em>tty_ldisc</em> .  Ambas estructuras tienen enlaces entre s√≠.  Echemos un vistazo m√°s de cerca a estas estructuras. </p><br><ul><li>  <strong>tty_struct</strong> es una estructura para acceder al controlador de dispositivo TTY y algunos otros campos.  Se ve as√≠: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver; <span class="hljs-comment"><span class="hljs-comment">//  TTY  const struct tty_operations *ops; //  .    ,   driver-&gt;ops,       int index; //   struct tty_ldisc *ldisc; //     struct tty_struct *link; //     PTY // ... }</span></span></code> </pre> <br><ul><li>  <strong>tty_ldisc</strong> es la estructura para la disciplina de la l√≠nea TTY del dispositivo.  Consta de solo dos campos y tiene el siguiente aspecto: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops *ops; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_struct *tty; //   tty_struct  .       };</span></span></code> </pre> <br><p>  Parece que no es nada complicado?  Agreguemos todas las estructuras consideradas hasta este momento a nuestra cesta y vincul√©moslas de la misma manera que est√°n conectadas en el c√≥digo: <br><img src="https://habrastorage.org/webt/1d/bt/n4/1dbtn4m_6c6i4n7oaohoguci2m0.jpeg" alt="Construir tty_struct" title="Construir tty_struct"></p><br><p>  Pero creamos tty_struct solo para el dispositivo PTM.  ¬øQu√© pasa con el dispositivo PTS?  Para hacer esto, volvemos a la funci√≥n <code>tty_init_dev()</code> y recordamos que se espera que llamemos a la funci√≥n <code>tty_driver_install_tty()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This method is responsible * for ensuring any need additional structures are allocated and configured. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_driver_install_tty(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> driver-&gt;ops-&gt;install ? driver-&gt;ops-&gt;install(driver, tty) : tty_standard_install(driver, tty); }</code> </pre> <br><p>  El comentario nos dice que este m√©todo es responsable de crear varias estructuras adicionales.  Dispositivo PTS y ser√° nuestra estructura adicional.  Lo admito, fue extremadamente sorprendente para m√≠, porque es, ¬°demonios, todo el dispositivo, y no solo alg√∫n tipo de estructura adicional!  Pero todos entendemos que todos los dispositivos son solo una especie de estructura, as√≠ que sigan adelante.  Ok, ¬øqu√© es <em>driver-&gt; ops-&gt; install here</em> ?  Para hacer esto, mire nuevamente la tabla de funciones para el controlador PTM: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Y entendemos que estamos interesados ‚Äã‚Äãen la funci√≥n <code>pty_unix98_install()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_unix98_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pty_common_install(driver, tty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><p>  Que llama a la funci√≥n <code>pty_common_install()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_common_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> legacy) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *o_tty; <span class="hljs-comment"><span class="hljs-comment">// tty_struct    PTY -    PTS  //    ,       install.   ,   PTM     tty_struct,        if (driver-&gt;subtype != PTY_TYPE_MASTER) return -EIO; o_tty = alloc_tty_struct(driver-&gt;other, idx); tty-&gt;link = o_tty; o_tty-&gt;link = tty; }</span></span></code> </pre> <br><p>  ,   PTS       <em>tty_struct</em>   ,       PTS .           .  tty_struct  PTS    . </p><br><hr><br><h4 id="registraciya-drayvera">   </h4><br><p>        ,           TTY  (   -         ?). <br>  ‚Äî  ,       PTM,   PTS : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { .llseek = no_llseek, .read = tty_read, .write = tty_write, .poll = tty_poll, .unlocked_ioctl = tty_ioctl, .compat_ioctl = tty_compat_ioctl, .open = tty_open, .release = tty_release, .fasync = tty_fasync, .show_fdinfo = tty_show_fdinfo, };</code> </pre> <br><p>         ,                  TTY . </p><br><hr><br><p>  Listo      ,       <em>/dev/ptmx</em> .  ,   PTS ,      ,   PTM ,      : </p><br><p><img src="https://habrastorage.org/webt/5w/aw/rg/5wawrgbqqw1_llmi1r8g2kbwrzc.jpeg" title="Construir PTY"></p><br><hr><br><h2 id="hello-world">  Hola mundo </h2><br><p>        .          "Hello, World!",        . </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><span class="hljs-meta"> void main() { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Hello, World!\n"</span></span></span><span class="hljs-meta">); }</span></span></code> </pre> <br><p> ,   "Hello, World!"    .   ,    ,  ,       .    ,    .  stdout  <em>/dev/null</em> ‚Äî       .          ,       Linux. </p><br><p>      Unix        <em>write()</em> , <em>read()</em> , <em>close()</em>  ,    write()  /dev/pts/0         <code>__vfs_write()</code> : </p><br><pre> <code class="objectivec hljs">ssize_t __vfs_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *pos) { ssize_t ret; <span class="hljs-comment"><span class="hljs-comment">//... ret = file-&gt;f_op-&gt;write(file, buf, count, pos); //... return ret; }</span></span></code> </pre> <br><p>     write()      .   ,            : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { <span class="hljs-comment"><span class="hljs-comment">// ... .write = tty_write, // ...</span></span></code> </pre> <br><p>  <code>tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *ppos) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty = file_tty(file); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; ssize_t ret; ld = tty_ldisc_ref_wait(tty); ret = do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count); tty_ldisc_deref(ld); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br><p>     <em>tty_struct</em>    TTY ,           write()  .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops n_tty_ops = { .write = n_tty_write, <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>    <code>n_tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * n_tty_write - write function for tty * @tty: tty device * @file: file object * @buf: userspace buffer pointer * @nr: size of I/O */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t n_tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, size_t nr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *b = buf; <span class="hljs-comment"><span class="hljs-comment">// b - ,       "Hello, World!".          int c; //    //     PTS ,  write()    0,  ,     while (nr &gt; 0) { c = tty-&gt;ops-&gt;write(tty, b, nr); //  write()       TTY  if (!c) break; b += c; //     nr -= c; //      :  -  -  -  } }</span></span></code> </pre> <br><p> ,  "Hello, World!"    write()   PTS .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations pty_unix98_ops = { .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  <code>pty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *to = tty-&gt;link; <span class="hljs-comment"><span class="hljs-comment">//      PTY.    -  PTM  if (c &gt; 0) { //    PTM  c = tty_insert_flip_string(to-&gt;port, buf, c); //     ,       if (c) { tty_flip_buffer_push(to-&gt;port); tty_wakeup(tty); } } return c; }</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="objectivec hljs"> __vfs_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 1- :   tty_write() -&gt; do_tty_write() -&gt; n_tty_write() -&gt; // 2- :   pty_write() // 3- : </span></span></code> </pre> <br><p>     . ,       PTM . ,    . </p><br><p>  ,          <em>flip buffer</em> . <strong>Flip buffer</strong> ‚Äî   ,    .  tty driver   ,      .   ,              .      ,        ,       .     ,      ,            .  -        flip buffer ‚Äî       (,    -  ,         flip). </p><br><p>          ,       .  <code>tty_insert_flip_string()</code>         <code>tty_insert_flip_string_fixed_flag()</code> ,           PTM : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_insert_flip_string_fixed_flag(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *chars, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag, size_t size) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> copied = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE); <span class="hljs-comment"><span class="hljs-comment">//      int space = __tty_buffer_request_room(port, goal, flags); //     struct tty_buffer *tb = port-&gt;buf.tail; //       if (unlikely(space == 0)) break; memcpy(char_buf_ptr(tb, tb-&gt;used), chars, space); //      tb-&gt;used += space; copied += space; chars += space; /* There is a small chance that we need to split the data over several buffers. If this is the case we must loop */ } while (unlikely(size &gt; copied)); return copied; }</span></span></code> </pre> <br><p>   , flip buffer        ,       ,         .        ,   ‚Äî        PTM ,             . </p><br><p> ,   "Hello, World!"   PTM .    GNOME Terminal Server    <em>poll()</em> (  I/O)        master .  ,         ?  No importa como.      ,     ,      ‚Äî        . </p><br><p>            <code>tty_flip_buffer_push()</code> (   pty_write): </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_flip_buffer_push - terminal * @port: tty port to push * * Queue a push of the terminal flip buffers to the line discipline. * Can be called from IRQ/atomic context. * * In the event of the queue being busy for flipping the work will be * held off and retried later. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_flip_buffer_push(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { tty_schedule_flip(port); }</code> </pre> <br><p>  <code>tty_schedule_flip()</code> ,   ,        : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_schedule_flip - push characters to ldisc * @port: tty port to push from * * Takes any pending buffers and transfers their ownership to the * ldisc side of the queue. It then schedules those characters for * processing by the line discipline. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_schedule_flip(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_bufhead *buf = &amp;port-&gt;buf; <span class="hljs-comment"><span class="hljs-comment">/* paired w/ acquire in flush_to_ldisc(); ensures * flush_to_ldisc() sees buffer data. */</span></span> smp_store_release(&amp;buf-&gt;tail-&gt;commit, buf-&gt;tail-&gt;used); queue_work(system_unbound_wq, &amp;buf-&gt;work); }</code> </pre> <br><p>   ,     <em>work</em> (,   -       )       ,      ‚Äî    ,    <code>flush_to_ldisc()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> flush_to_ldisc(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> work_struct *work) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port = container_of(work, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port, buf.work); <span class="hljs-comment"><span class="hljs-comment">//   tty_port PTM . tty_port -       TTY  struct tty_bufhead *buf = &amp;port-&gt;buf; struct tty_buffer *head = buf-&gt;head; // ... receive_buf(port, head); // ... }</span></span></code> </pre> <br><p>  <code>receive_buf()</code>          <code>__receive_buf()</code> ,      : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __receive_buf(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fp, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> n_tty_data *ldata = tty-&gt;disc_data; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> preops = I_ISTRIP(tty) || (I_IUCLC(tty) &amp;&amp; L_IEXTEN(tty)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;real_raw) n_tty_receive_buf_real_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;raw || (L_EXTPROC(tty) &amp;&amp; !preops)) n_tty_receive_buf_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty-&gt;closing &amp;&amp; !L_EXTPROC(tty)) n_tty_receive_buf_closing(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;lnext) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag = TTY_NORMAL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fp) flag = *fp++; n_tty_receive_char_lnext(tty, *cp++, flag); count--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!preops &amp;&amp; !I_PARMRK(tty)) n_tty_receive_buf_fast(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> n_tty_receive_buf_standard(tty, cp, fp, count); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_cnt(ldata)) { kill_fasync(&amp;tty-&gt;fasync, SIGIO, POLL_IN); wake_up_interruptible_poll(&amp;tty-&gt;read_wait, EPOLLIN); } }</code> </pre> <br><p>  ,   <em>n_tty_receive_buf</em> ( ,    _raw)           <strong>read_buf</strong> ,         TTY .      PTM    raw ,           read_buf. ,        PTM  PTS ,     . </p><br><p>       ,   : </p><br><pre> <code class="objectivec hljs"> ... pty_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 3- :  PTS  tty_insert_flip_string + tty_flip_buffer_push() -&gt; tty_schedule_flip() -&gt; --- //    PTM  flush_to_ldisc() -&gt; // 2- :   PTM  receive_buf() -&gt; n_tty_receive_buf -&gt; n_tty_receive_buf_common -&gt; __receive_buf()</span></span></code> </pre> <br><p> ,   PTM        ‚Äî         PTS . </p><br><p>  :       PTM .  GNOME Terminal Server      "Hello, World!",  read()  PTM .  read()    write()    ‚Äî  <code>n_tty_read()</code> .      ,  ,          ‚Äî <em>read_buf</em> ‚Äî   .  GNOME Terminal Server    X Server,     . </p><br><p>  ,   "Hello, World!"   : </p><br><pre> <code class="plaintext hljs"> -&gt; PTY slave -&gt; PTY master -&gt; GNOME-TERMINAl-SERVER -&gt; X Server -&gt; -&gt; </code> </pre> <br><hr><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  .     : </p><br><ol><li>     </li><li>     </li><li>   TTY  </li><li>    </li><li>    ,         </li></ol><br><p>   ,   !     -  ‚Äî     ,   ! </p><br><h3 id="istochniki">  Fuentes </h3><br><ul><li> Linux man pages </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://unix.stackexchange.com/q/96694/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://unix.stackexchange.com/q/93531/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://unix.stackexchange.com/q/117981/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://askubuntu.com/q/506510</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.linusakesson.net/programming/tty/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://spin0r.wordpress.com/2012/12/28/terminally-confused-part-seven/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://habr.com/ru/company/neobit/blog/330764/</a> </li><li>  Advanced Programming in the UNIX Environment, 3rd Edition </li></ul><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460257/">https://habr.com/ru/post/460257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460247/index.html">Recetas para ELF</a></li>
<li><a href="../460249/index.html">Soluci√≥n de la tarea con pwnable.kr 07 - input. Entendiendo pwntools</a></li>
<li><a href="../460251/index.html">Estupidez artificial: un bot que no me ayud√≥</a></li>
<li><a href="../460253/index.html">10 razones para hacer tu habilidad para asistente de voz</a></li>
<li><a href="../460255/index.html">Backdoor on Node.js: por qu√©, por qu√© y c√≥mo funciona</a></li>
<li><a href="../460259/index.html">¬øQu√© es el dise√±o de UI y UX? ¬øQu√© es com√∫n y diferente?</a></li>
<li><a href="../460261/index.html">Amazon: 25 a√±os de √©xito de comercio electr√≥nico</a></li>
<li><a href="../460263/index.html">Hacer una b√∫squeda realmente inteligente: gu√≠a paso a paso</a></li>
<li><a href="../460265/index.html">Crear una plantilla de proyecto Xcode</a></li>
<li><a href="../460273/index.html">Autorizaci√≥n en Apple Pay para los m√°s peque√±os</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>