<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏻 😺 😬 Redux ReactiveX 🎄 🥌 👩🏻‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setiap orang yang bekerja dengan Redux cepat atau lambat akan mengalami masalah tindakan asinkron. Tetapi aplikasi modern tidak dapat dikembangkan tan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redux ReactiveX</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfa/blog/460155/">  Setiap orang yang bekerja dengan Redux cepat atau lambat akan mengalami masalah tindakan asinkron.  Tetapi aplikasi modern tidak dapat dikembangkan tanpa mereka.  Ini adalah http-request ke backend, dan semua jenis timer / penundaan.  Pembuat Redux sendiri berbicara dengan jelas - secara default, hanya aliran data sinkron yang didukung, semua tindakan asinkron harus ditempatkan dalam middleware. <br><br>  Tentu saja, ini terlalu verbal dan merepotkan, sehingga sulit menemukan pengembang yang hanya menggunakan middleware "asli".  Perpustakaan dan kerangka kerja seperti Thunk, Saga, dan sejenisnya selalu datang untuk menyelamatkan. <br><br>  Untuk sebagian besar tugas, itu sudah cukup.  Tetapi bagaimana jika logika yang sedikit lebih rumit diperlukan daripada mengirim satu permintaan atau membuat satu pengatur waktu?  Ini adalah contoh kecil: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> dispatch =&gt; { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> .all([fetchOne, fetchTwo]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[respOne, respTwo]</span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo }); }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }); } }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }</code> </pre> <br>  Sangat menyakitkan bahkan untuk melihat kode seperti itu, tetapi tidak mungkin untuk mempertahankan dan memperluas.  Apa yang harus dilakukan ketika penanganan kesalahan yang lebih canggih diperlukan?  Bagaimana jika Anda membutuhkan permintaan berulang?  Dan jika saya ingin menggunakan kembali fitur ini? <br><br>  Nama saya Dmitry Samokhvalov, dan dalam posting ini saya akan memberi tahu Anda apa konsep Observable dan bagaimana mempraktikkannya bersama dengan Redux, dan juga membandingkan semua ini dengan kemampuan Redux-Saga. <br><a name="habracut"></a><br>  Sebagai aturan, dalam kasus seperti itu, ambil redux-saga.  Oke, kami menulis ulang kisah-kisahnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(delay, <span class="hljs-number"><span class="hljs-number">2000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [respOne, respTwo] = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> [ call(fetchOne), call(fetchTwo) ]; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }); }</code> </pre><br>  Ini menjadi lebih baik - kode hampir linier, terlihat dan lebih baik dibaca.  Tetapi memperluas dan menggunakan kembali masih sulit, karena hikayat sama pentingnya dengan thunk. <br><br>  Ada pendekatan lain.  Ini persis pendekatan, dan bukan hanya perpustakaan lain untuk menulis kode asinkron.  Ini disebut Rx (mereka juga dapat diamati, Streaming Reaktif, dll.).  Kami akan menggunakannya dan menulis ulang contoh di Observable: <br><br><pre> <code class="javascript hljs">action$ .delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>) .switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable.merge(fetchOne, fetchTwo) .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[respOne, respTwo]</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo })) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }))</code> </pre> <br>  Kode tidak hanya menjadi datar dan menurun volumenya, prinsip menggambarkan tindakan asinkron telah berubah.  Sekarang kita tidak bekerja secara langsung dengan query, tetapi melakukan operasi pada objek khusus yang disebut Observable. <br><br>  Lebih mudah untuk mewakili Observable sebagai fungsi yang memberikan aliran (urutan) nilai.  Dapat diamati memiliki tiga keadaan utama - berikutnya ("berikan nilai berikutnya"), kesalahan ("terjadi kesalahan") dan lengkap ("nilai-nilai sudah berakhir, tidak ada lagi yang bisa diberikan").  Dalam hal ini, ini agak seperti Janji, tetapi berbeda karena mungkin untuk mengulangi nilai-nilai ini (dan ini adalah salah satu kekuatan super yang Dapat Diamati).  Anda dapat membungkus apa pun di Observable - timeout, permintaan http, acara DOM, hanya objek js. <br><br><img src="https://habrastorage.org/webt/be/qu/yr/bequyrg-gjvichysgtzom-c0mju.png" width="540"><br><br>  Negara adikuasa kedua yang dapat diamati adalah operator.  Operator adalah fungsi yang menerima dan mengembalikan Observable, tetapi melakukan beberapa tindakan pada aliran nilai.  Analogi terdekat adalah peta dan filter dari javascript (omong-omong, operator seperti itu ada di Rx). <br><br><img src="https://habrastorage.org/webt/bu/hi/mc/buhimcdgpjmngscttymdt1rzsqk.png" width="540"><br><br>  Bagi saya pribadi yang paling berguna adalah operator zip, forkJoin, dan flatMap.  Menggunakan contoh mereka, paling mudah untuk menjelaskan pekerjaan operator. <br><br>  Operator zip bekerja sangat sederhana - dibutuhkan beberapa yang dapat diobservasi (tidak lebih dari 9) dan mengembalikan dalam array nilai yang dipancarkannya. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = fromEvent(<span class="hljs-string"><span class="hljs-string">"mousedown"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = fromEvent(<span class="hljs-string"><span class="hljs-string">"mouseup"</span></span>); zip(first, second) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${e[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">].x}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${e[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">].x}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//output [119,120] [120,233] …</span></span></code> </pre><br>  Secara umum, pekerjaan zip dapat diwakili oleh skema: <br><br><img src="https://habrastorage.org/webt/zu/4j/in/zu4jinxmtwpt4vs3azoy81a6xpc.png" width="540"><br><br>  Zip digunakan jika Anda memiliki beberapa Observable dan Anda perlu secara konsisten menerima nilai dari mereka (terlepas dari kenyataan bahwa mereka dapat dipancarkan pada interval yang berbeda, secara sinkron atau tidak).  Ini sangat berguna saat bekerja dengan acara DOM. <br><br>  Pernyataan forkJoin mirip dengan zip dengan satu pengecualian - hanya mengembalikan nilai terbaru dari setiap Observable. <br><br><img src="https://habrastorage.org/webt/3p/mb/s6/3pmbs6uzqz4w9c3fklfhslw6j6k.png" width="540"><br><br>  Dengan demikian, masuk akal untuk menggunakannya ketika hanya nilai terbatas dari aliran diperlukan. <br>  Yang sedikit lebih rumit adalah operator flatMap.  Dibutuhkan Observable sebagai input dan mengembalikan Observable baru, dan memetakan nilai-nilai dari itu ke Observable baru, baik menggunakan fungsi pemilih atau Observable lainnya.  Kedengarannya membingungkan, tetapi diagramnya cukup sederhana: <br><br><img src="https://habrastorage.org/webt/kz/7t/fn/kz7tfnjuhklblx5czaxhbs06_mi.png" width="540"><br><br>  Lebih jelas dalam kode: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string"> World`</span></span>); observable .flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> promise(value)) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result)); <span class="hljs-comment"><span class="hljs-comment">//output "Hello World"</span></span></code> </pre> <br>  Paling sering, flatMap digunakan dalam permintaan backend, bersama dengan switchMap dan concatMap. <br>  Bagaimana saya bisa menggunakan Rx di Redux?  Ada perpustakaan redux-observable yang indah untuk ini.  Arsitekturnya terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/9p/y1/kv/9py1kvsgrpqjaovs3zrukrghbwc.png" width="540"><br><br>  Semua operator dan tindakan yang dapat diobservasi dibuat dalam bentuk middleware khusus yang disebut epik.  Setiap epik mengambil tindakan sebagai input, membungkusnya dalam Observable, dan harus mengembalikan action, juga sebagai Observable.  Anda tidak dapat mengembalikan tindakan biasa, ini membuat loop tanpa akhir.  Mari kita menulis epik kecil yang membuat permintaan untuk api. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchEpic = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action$</span></span></span><span class="hljs-function"> =&gt;</span></span> action$ .ofType(<span class="hljs-string"><span class="hljs-string">'FETCH_INFO'</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_START'</span></span> })) .flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable .from(apiRequest) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_SUCCESS'</span></span>, data })) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_ERROR'</span></span>, error })) )</code> </pre><br>  Tidak mungkin dilakukan tanpa membandingkan redux-observable dan redux-saga.  Tampaknya banyak yang dekat dengan fungsionalitas dan kemampuan, tetapi ini sama sekali tidak terjadi.  Sagas adalah alat yang sangat penting, pada dasarnya seperangkat metode untuk bekerja dengan efek samping.  Dapat diamati adalah gaya penulisan kode asinkron yang secara fundamental berbeda, jika Anda mau, filosofi yang berbeda. <br><br>  Saya menulis beberapa contoh untuk menggambarkan kemungkinan dan pendekatan untuk memecahkan masalah. <br><br>  Misalkan kita perlu mengimplementasikan timer yang akan berhenti beraksi.  Inilah yang terlihat dalam kisah-kisah: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> race({ <span class="hljs-attr"><span class="hljs-attr">stopped</span></span>: take(<span class="hljs-string"><span class="hljs-string">'STOP'</span></span>), <span class="hljs-attr"><span class="hljs-attr">tick</span></span>: call(wait, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!timer.stopped) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put(actions.tick()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } }</code> </pre> <br>  Sekarang gunakan Rx: <br><br><pre> <code class="javascript hljs">interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .takeUntil(action$.ofType(<span class="hljs-string"><span class="hljs-string">'STOP'</span></span>))</code> </pre> <br><br>  Misalkan ada tugas untuk mengimplementasikan permintaan dengan pembatalan dalam kisah: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchSaga</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(fetchUser); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-string"><span class="hljs-string">'FETCH'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchSaga = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fork(fetchSaga); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-string"><span class="hljs-string">'FETCH_CANCEL'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> cancel(fetchSaga); }</code> </pre> <br>  Semuanya lebih sederhana di Rx: <br><br><pre> <code class="javascript hljs">switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchUser()) .takeUntil(action$.ofType(<span class="hljs-string"><span class="hljs-string">'FETCH_CANCEL'</span></span>))</code> </pre> <br>  Akhirnya, favorit saya.  Terapkan permintaan api, jika terjadi kegagalan, buat tidak lebih dari 5 permintaan berulang dengan penundaan 2 detik.  Inilah yang kita miliki dalam kisah-kisah: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> apiResponse = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(apiRequest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apiResponse; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(); }</code> </pre> <br>  Apa yang terjadi pada Rx: <br><br><pre> <code class="javascript hljs">.retryWhen(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors</span></span></span><span class="hljs-function"> =&gt;</span></span> errors .delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .take(<span class="hljs-number"><span class="hljs-number">5</span></span>))</code> </pre><br>  Jika Anda merangkum pro dan kontra dari saga, Anda mendapatkan gambar berikut: <br><br><img src="https://habrastorage.org/webt/y6/bs/un/y6bsun3cbbwp4tayqhuuhwpudyc.png" width="540"><br><br>  Sagas mudah dipelajari dan sangat populer, jadi di komunitas Anda dapat menemukan resep untuk hampir semua kesempatan.  Sayangnya, gaya imperatif mencegah penggunaan kisah-kisah yang sangat fleksibel. <br><br>  Rx memiliki situasi yang sama sekali berbeda: <br><br><img src="https://habrastorage.org/webt/mc/5a/wx/mc5awxjs7lszbo9jcq-qzrzg2qa.png" width="540"><br><br>  Tampaknya Rx adalah palu ajaib dan peluru perak.  Sayangnya, ini tidak benar.  Ambang untuk memasukkan Rx jauh lebih tinggi, oleh karena itu lebih sulit untuk memperkenalkan orang baru ke proyek yang secara aktif menggunakan Rx. <br><br>  Selain itu, ketika bekerja dengan Observable, sangat penting untuk berhati-hati dan selalu memahami dengan baik apa yang terjadi.  Jika tidak, Anda mungkin menemukan kesalahan yang tidak terlihat atau perilaku yang tidak terdefinisi. <br><br><pre> <code class="javascript hljs">action$ .ofType(<span class="hljs-string"><span class="hljs-string">'DELETE'</span></span>) .switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable .fromPromise(deleteRequest) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'DELETE_SUCCESS'</span></span>})))</code> </pre> <br>  Setelah saya menulis sebuah epik yang melakukan pekerjaan yang cukup sederhana - dengan setiap tindakan ketik 'HAPUS', metode API dipanggil yang menghapus item.  Namun, ada masalah selama pengujian.  Penguji mengeluh tentang perilaku aneh - kadang-kadang ketika Anda mengklik tombol hapus tidak ada yang terjadi.  Ternyata operator switchMap mendukung pelaksanaan hanya satu Observable pada satu waktu, semacam perlindungan terhadap kondisi balapan. <br><br>  Sebagai hasilnya, saya akan memberikan beberapa rekomendasi yang saya ikuti dan mendesak semua orang yang mulai bekerja dengan Rx untuk mengikuti: <br><br><ul><li>  Berhati-hatilah. </li><li>  Periksa dokumentasinya. </li><li>  Periksa di kotak pasir. </li><li>  Tulis tes. </li><li>  Jangan menembak burung pipit dari meriam. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460155/">https://habr.com/ru/post/id460155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460143/index.html">Modul dis Python dan konvolusi konstanta</a></li>
<li><a href="../id460147/index.html">Kerangka kerja microservices PHP - Swoft 2.0.3 diterbitkan</a></li>
<li><a href="../id460149/index.html">Pengetikan yang benar: aspek kode bersih yang diremehkan</a></li>
<li><a href="../id460151/index.html">Desain berorientasi model. Motor DC Brushless</a></li>
<li><a href="../id460153/index.html">Petualangan tanda tangan elektronik di Rusia</a></li>
<li><a href="../id460157/index.html">Bagaimana jawaban "benar" dari responden dapat mengubah hasil survei tanpa bisa dikenali</a></li>
<li><a href="../id460159/index.html">Metode untuk memantau kondisi jalan Rusia saat ini oleh ponsel cerdas pengguna</a></li>
<li><a href="../id460161/index.html">FusionPBX dan ACL</a></li>
<li><a href="../id460163/index.html">Seperti yang terlihat</a></li>
<li><a href="../id460165/index.html">Latar belakang: kriptografi jari kuantum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>