<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📯 🐧 💇 Ein systematischer Geschwindigkeitsansatz: Online-Messungen am Frontend 🛑 🧔🏼 🌓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Yandex-Geschwindigkeitsbefehl optimiert die Suchergebnisse manuell. Es blind zu machen ist schwierig und oft einfach nutzlos. Daher baute das Unte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein systematischer Geschwindigkeitsansatz: Online-Messungen am Frontend</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/426571/"> Der Yandex-Geschwindigkeitsbefehl optimiert die Suchergebnisse manuell.  Es blind zu machen ist schwierig und oft einfach nutzlos.  Daher baute das Unternehmen eine Infrastruktur zum Sammeln von Metriken, Testen der Geschwindigkeit und Analysieren der Daten auf. <br><br>  Der Entwickler der Yandex-Schnittstellen <b>Andrei Prokopyuk</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Andre_487</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">weiß,</a> welche Metriken verwendet werden sollen und wie alles optimiert werden kann. <br><br><img src="https://habrastorage.org/webt/jh/gn/r4/jhgnr48w9fhjphnfjkjcggtsdds.png"><br><br>  Das Material basiert auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andreys</a> Rede auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HolyJS-</a> Konferenz.  Unter dem Schnitt - und Video und einer Textversion des Berichts. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Whm2FMBIgA0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><blockquote>  Zusätzlich zu diesem Bericht über Online-Messungen gibt es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht von Alexei Kalmakov</a> (ebenfalls von Yandex) über Offline-Messungen. In seinem Fall gibt es keine Textversion, aber ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> ist verfügbar. </blockquote><br><br>  Yandex-Suchergebnisse bestehen aus vielen verschiedenen Blöcken, Klassen von Antworten auf Benutzeranfragen.  Im Unternehmen arbeiten mehr als 50 Mitarbeiter an ihnen, und damit die Emissionsrate nicht sinkt, kümmern wir uns ständig um die Entwicklung. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/044/4e1/e2a/0444e1e2a6db39e37b9c2a085c7433db.jpg"><br><br>  Niemand wird argumentieren, dass Benutzer die schnelle Oberfläche mehr mögen als die langsame.  Bevor Sie jedoch mit der Optimierung beginnen, ist es wichtig zu verstehen, wie sich dies auf Ihr Unternehmen auswirkt.  Müssen Entwickler Zeit damit verbringen, die Benutzeroberfläche zu beschleunigen, wenn dies keine Auswirkungen auf die Geschäftsmetriken hat? <br><br>  Um diese Frage zu beantworten, werde ich zwei Geschichten erzählen. <br><br><h2>  Verlauf der Einführung einer bestimmten Webschriftart bei der Ausgabe </h2><br>  Nachdem wir ein Experiment mit Schriftarten durchgeführt hatten, stellten wir fest, dass sich die durchschnittliche Zeit für das Rendern von Inhalten um 3% und 62 Millisekunden verschlechterte.  Nicht so sehr, wenn man es für ein Delta im Vakuum hält.  Die mit bloßem Auge wahrnehmbare Verzögerung beginnt mit nur 100 Millisekunden - und dennoch erhöht sich die Zeit bis zum ersten Klick sofort um eineinhalb Prozent. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ef/2b5/548/4ef2b5548ae1789980552312d0b92857.jpg"><br><br>  Benutzer begannen später mit der Seite zu interagieren.  Die Anzahl der angeklickten Seiten verringerte sich um fast ein halbes Prozent.  Die Anwesenheitszeit im Dienst wurde verkürzt und die Abwesenheitszeit verlängert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c15/215/b5f/c15215b5fb72633582890da9e018d4a4.jpg"><br><br>  Wir haben nicht damit begonnen, Funktionen mit Schriftarten einzuführen.  Immerhin scheinen diese Zahlen klein zu sein, bis Sie sich an den Umfang des Dienstes erinnern.  In Wirklichkeit eineinhalb Prozent - Hunderttausende von Menschen. <br><br>  Darüber hinaus wirkt sich die Geschwindigkeit kumulativ aus.  Für ein Update mit einem Anteil von nicht beanspruchten - 0,4% werden immer mehr folgen.  In Yandex werden solche Funktionen in Dutzenden pro Tag eingeführt. Wenn Sie nicht um jede Aktie kämpfen, hält sie nicht lange an und erreicht 10%. <br><br><h2>  LS Caching-Verlauf </h2><br>  Diese Geschichte hängt mit der Tatsache zusammen, dass wir viele statische Inhalte in die Seite einbinden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c33/3fd/7d2/c333fd7d205cc0695c8934cb0111c820.jpg"><br><br>  Aufgrund seiner hohen Variabilität können wir es nicht zu einem Bundle zusammenstellen oder mit externen Ressourcen ausliefern.  Die Praxis hat gezeigt, dass bei der Inline-Bereitstellung das Rendern und Initialisieren von JavaScript am schnellsten ist. <br><br>  Einmal entschieden wir, dass die Verwendung eines Browser-Repositorys eine gute Idee wäre.  Fügen Sie alles in localStorage ein und laden Sie es bei nachfolgenden Einträgen auf der Seite von dort und übertragen Sie es nicht über das Netzwerk. <br><br>  Dann haben wir uns hauptsächlich auf die Metriken „HTML-Größe“ und „HTML-Lieferzeit“ konzentriert und gute Ergebnisse erzielt.  Im Laufe der Zeit haben wir neue Methoden zur Geschwindigkeitsmessung erfunden, Erfahrungen gesammelt und beschlossen, diese zu überprüfen, ein umgekehrtes Experiment durchzuführen und die Optimierung auszuschalten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b9/37c/2c9/3b937c2c9c4f0a85c2e76a26d6fdfacf.jpg"><br><br>  Die durchschnittliche HTML-Lieferzeit (die Schlüsselmetrik zum Zeitpunkt der Optimierungsentwicklung) stieg um 12%, was sehr viel ist.  Gleichzeitig jedoch die Zeit bis zum Zeichnen des Headers, bevor das Parsen des Inhalts begann und bevor JavaScript initialisiert wurde.  Reduzierte auch die Zeit bis zum ersten Klick.  Der Prozentsatz ist klein - 0,6, aber wenn Sie sich an die Skala erinnern ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f88/35c/0fd/f8835c0fdce5780914f129f41f445f8d.jpg"><br><br>  Durch das Deaktivieren der Optimierung wurde eine Verschlechterung der Metrik erzielt, die nur für Spezialisten spürbar ist, und gleichzeitig eine Verbesserung, die für den Benutzer spürbar ist. <br><br>  Daraus lassen sich folgende Schlussfolgerungen ziehen: <br><br>  Erstens wirkt sich die Geschwindigkeit wirklich auf das Geschäft und die Geschäftsmetriken aus. <br><br>  Zweitens müssen Optimierungen Messungen vorausgehen.  Wenn Sie etwas implementieren, nachdem Sie schlechte Messungen durchgeführt haben, werden Sie wahrscheinlich nichts Nützliches tun.  Die Zusammensetzung des Publikums, die Geräteflotte, Interaktionsszenarien und Netzwerke sind überall unterschiedlich, und Sie müssen überprüfen, was genau für Sie funktioniert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bf/2c6/06b/0bf2c606bacfb7bc5769594fbc326a52.jpg"><br><br>  Einmal lehrte uns Ash von den finsteren Toten, zuerst zu schießen, dann zu denken oder überhaupt nicht zu denken.  Bei der Geschwindigkeit müssen Sie dies nicht tun. <br><br>  Und der dritte Punkt: Messungen sollten die Benutzererfahrung widerspiegeln.  Beispielsweise sind HTML-Größe und Lieferzeit schlechte Geschwindigkeitsmetriken, da der Benutzer nicht mit devTools zusammenarbeitet und keinen Dienst mit weniger Verzögerung auswählt.  Aber welche Metriken gut und richtig sind - wir werden weiter erzählen. <br><br><h2>  Was und wie messen? </h2><br>  Messungen sollten mit einigen wichtigen Metriken beginnen, die im Gegensatz zur HTML-Größe der Benutzererfahrung nahe kommen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/3c5/783/ec13c57830d7b1b3b8380273dda5bbc8.jpg"><br><br>  Wenn TTFCP (Zeit bis zum ersten inhaltlichen Malen) und TTFMP (Zeit bis zum ersten sinnvollen Malen) die Zeit bis zum ersten Rendern des Inhalts und die Zeit vor dem Rendern des signifikanten Inhalts angeben, ist die dritte Zeit die Zeit vor dem Initialisieren des Frameworks. <br><br>  Dies ist die Zeit, in der das Framework die Seite bereits durchlaufen, alle erforderlichen Daten gesammelt und die Handler aufgehängt hat.  Wenn der Benutzer in diesem Moment irgendwo klickt, erhält er eine dynamische Antwort. <br><br>  Und die letzte, vierte Metrik, die Zeit bis zur ersten Interaktivität, wird normalerweise als Zeit bis zur Interaktivität (TTI) bezeichnet. <br><br>  Diese Metriken liegen im Gegensatz zur HTML-Größe oder Lieferzeit nahe an der Benutzererfahrung. <br><br><h2>  Zeit, zuerst zufrieden zu malen </h2><br>  Um die Zeit zu messen, zu der der Benutzer den ersten Inhalt der Seite gesehen hat, gibt es eine Paint Timing-API, die bisher nur in Chrom verfügbar ist.  Daten daraus können auf folgende Weise erhalten werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e16/80a/c27/e1680ac270e35eaad20070c90e47066d.jpg"><br><br>  Mit diesem Aufruf erhalten wir eine Reihe von Rendering-Ereignissen.  Bisher werden zwei Arten von Ereignissen unterstützt: Erstes Malen - ein beliebiges Rendern und ein erstes inhaltliches Malen - ein beliebiges Rendern von Inhalten außer dem weißen Hintergrund der leeren Registerkarte und dem Hintergrundinhalt der Seite. <br><br>  So erhalten wir eine Reihe von Ereignissen, filtern zuerst die gesamte Farbe und senden sie mit einer bestimmten ID. <br><br><h2>  Zeit für die erste sinnvolle Farbe </h2><br>  In der Paint Timing-API gibt es kein Ereignis, das signalisiert, dass auf der Seite signifikante Inhalte gerendert wurden.  Dies liegt an der Tatsache, dass solche Inhalte auf jeder Seite unterschiedlich sind.  Wenn es sich um einen Videodienst handelt, ist der Player in den Suchergebnissen die Hauptsache - das erste nicht werbliche Ergebnis.  Es gibt viele Dienste, und eine universelle API wurde noch nicht entwickelt.  Aber hier kommen gute, bewährte Krücken ins Spiel. <br><br>  In Yandex gibt es zwei Krückenschulen zum Messen dieser Metrik: Verwenden von RequestAnimationFrame und Messen mit InterceptionObserver. <br><br>  In RequestAnimationFrame wird das Rendern anhand eines Intervalls gemessen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22b/dfe/945/22bdfe945df84617220936267638cc21.jpg"><br><br>  Angenommen, es gibt einige wichtige Inhalte.  Hier ist ein Div mit Hauptinhalt der Klasse.  Davor wird ein Skript platziert, in dem RequestAnimationFrame zweimal aufgerufen wird. <br><br>  Schreiben Sie im Rückruf des ersten Aufrufs die untere Grenze des Intervalls.  Im Rückruf des zweiten - der Spitze.  Dies liegt an der Rahmenstruktur, die der Browser rendert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/79d/783/a88/79d783a883b6a718095228cfbea29469.jpg"><br><br>  Das erste ist die Ausführung von JavaScript, dann die Analyse von Stilen, dann die Berechnung von Layout, Rendering und Komposition. <br><br>  Callback, das RequestAnimationFrame aufruft, wird im selben Stadium wie JavaScript aktiviert und der Inhalt wird während der Komposition im letzten Abschnitt des Frames gerendert.  Daher erhalten wir beim ersten Aufruf nur die untere Grenze, die zeitlich merklich von der Ausgabe der Pixel auf dem Bildschirm entfernt wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81c/788/f38/81c788f38c68e241cf3a34612503f9d0.jpg"><br><br>  Platzieren Sie zwei Rahmen nebeneinander.  Es ist zu sehen, dass am Ende des ersten der Inhalt gerendert wurde.  Wir schreiben den unteren Rand von RequestAnimationFrame auf, der im ersten Rückruf aufgerufen wird, und rufen den Rückruf im zweiten Rahmen auf.  Somit erhalten wir das Intervall von JavaScript, das in dem Frame aufgerufen wird, in dem der Inhalt im zweiten Frame in JavaScript gerendert wurde. <br><br><h2>  InterceptionObserver </h2><br>  Unsere zweite Krücke mit dem gleichen Inhalt funktioniert anders.  Dieses Mal ist das Skript unten platziert.  Darin erstellen wir InterceptionObserver und abonnieren domNode. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd6/dea/87d/fd6dea87dd53e374e2ba19aa79d4a379.jpg"><br><br>  Wir übergeben keine zusätzlichen Parameter und messen daher den Schnittpunkt mit dem Ansichtsfenster.  Diese Zeit wird als genaue Zeit des Renderns aufgezeichnet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/549/5ab/d02/5495abd0268d0d59077d00ade282989a.jpg"><br><br>  Dies funktioniert, da der Schnittpunkt des Hauptinhalts und des Ansichtsfensters genau der Schnittpunkt ist, den der Benutzer sieht.  Diese API wurde entwickelt, um genau zu wissen, wann ein Nutzer eine Anzeige gesehen hat. Unsere Untersuchungen haben jedoch gezeigt, dass dies auch für Nicht-Anzeigenblöcke funktioniert. <br><br>  Von diesen beiden Methoden ist es immer noch besser, RequestAnimationFrame zu verwenden: Die Unterstützung ist breiter und es wird von uns in der Praxis besser getestet. <br><br><h2>  Js inited </h2><br>  Stellen Sie sich ein Framework vor, das eine Art „Init“ -Ereignis enthält, das Sie abonnieren können. Denken Sie jedoch daran, dass JS Inited in der Praxis sowohl eine einfache als auch eine komplexe Metrik ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3bf/6fe/85c/3bf6fe85c743f0ad6c255d8e4c448eae.jpg"><br><br>  Einfach - weil Sie nur den Moment finden müssen, in dem das Framework die Anordnung der Ereignisse abgeschlossen hat.  Komplex - weil Sie diesen Punkt für jedes Framework selbst suchen müssen. <br><br><h2>  Zeit für interaktive </h2><br>  TTI wird oft mit der vorherigen Metrik verwechselt, ist jedoch ein Indikator für den Moment, in dem der Hauptstrom des Browsers freigegeben wird.  Während des Ladens von Seiten werden viele Aufgaben ausgeführt: vom Rendern verschiedener Elemente bis zur Initialisierung des Frameworks.  Erst wenn es entladen ist, kommt die Zeit für die erste Interaktivität. <br><br>  Das Konzept der langen Aufgaben und die API für lange Aufgaben helfen dabei, dies zu messen. <br><br>  Zunächst zu den langen Aufgaben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f79/67b/828/f7967b8283a7302b1d8d9b1bd076cfac.jpg"><br><br>  Zwischen den kurzen Aufgaben, die durch Pfeile angezeigt werden, kann der Browser die Verarbeitung eines Benutzerereignisses, z. B. der Eingabe, leicht überfüllen, da es eine hohe Priorität hat.  Bei den langen Aufgaben, die durch die roten Pfeile angezeigt werden, funktioniert dies jedoch nicht. <br><br>  Der Benutzer muss warten, bis er aufgebraucht ist, und erst, nachdem der Browser die Verarbeitung seiner Eingabe aktiviert hat.  Gleichzeitig kann das Framework bereits initialisiert werden und die Schaltflächen funktionieren langsam.  Eine solche verzögerte Antwort ist eine ziemlich unangenehme Benutzererfahrung.  In dem Moment, in dem die letzte lange Aufgabe abgeschlossen ist und der Thread lange Zeit leer ist, beträgt die Abbildung 7 Sekunden und 300 Millisekunden. <br><br>  Wie messe ich dieses Intervall in JavaScript? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66f/f1b/114/66ff1b114d718aa4e31cf8c2f1094525.jpg"><br><br>  Der erste Schritt wird bedingt als öffnendes Body-Tag bezeichnet, worauf das Skript folgt.  Dadurch wird ein PerformanceObserver erstellt, der das Long Task-Ereignis abonniert.  Innerhalb des Callback PerformanceObservers werden Ereignisinformationen in einem Array gesammelt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e3/1c4/c60/3e31c4c60298c19431ca84a93c908394.jpg"><br><br>  Nach dem Sammeln der Daten ist die Zeit für den zweiten Schritt gekommen.  Es wird bedingt als schließende Körpermarke bezeichnet.  Wir nehmen das letzte Element des Arrays, die letzte lange Aufgabe, schauen uns den Moment seiner Fertigstellung an und prüfen, ob genügend Zeit vergangen ist. <br><br>  In der ursprünglichen Arbeit an dieser Metrik wurden 5 Sekunden als Konstante angenommen, aber die Auswahl wurde in keiner Weise begründet.  Es stellte sich heraus, dass es für 3 Sekunden ausreichte.  Wenn 3 Sekunden vergehen, zählen wir die Zeit bis zur ersten Interaktivität. Wenn nicht, setzen wir Timeout und überprüfen diese Konstante erneut. <br><br><h2>  Wie verarbeite ich die Daten? </h2><br>  Daten müssen von Kunden empfangen, verarbeitet und auf bequeme Weise präsentiert werden.  Unser Konzept, Daten zu senden, ist recht einfach.  Es wird ein Zähler genannt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38f/158/cba/38f158cbaf1233223fdca1ba255f9e25.jpg"><br><br>  Wir übertragen die Daten einer bestimmten Metrik auf einen speziellen Stift im Backend und sammeln sie im Repository. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/884/cda/04a/884cda04a3b619b084dfde376a0645cc.jpg"><br><br>  Hier wird die Datenaggregation üblicherweise als SQL-Abfrage bezeichnet.  Hier sind die Hauptaggregationen, die wir normalerweise anhand von Geschwindigkeitsmetriken berücksichtigen: arithmetisches Mittel und Perzentilgruppe (50., 75., 95., 99.). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/354/84a/d7c/35484ad7c51d967118abb42646a09801.jpg"><br><br>  Der arithmetische Durchschnitt in unserer numerischen Reihe beträgt fast 1900. Er ist deutlich größer als die meisten Elemente der Menge, da diese Aggregation sehr empfindlich gegenüber Ausreißern ist.  Diese Eigenschaft ist für uns immer noch nützlich. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6b/2ac/b00/d6b2acb00b844c6294fa80a50e03495c.jpg"><br><br>  Um Perzentile für denselben Satz zu berechnen, sortieren Sie ihn und setzen Sie den Zeiger auf den Perzentilindex.  Nehmen wir den 50., der auch als Median bezeichnet wird.  Wir fallen zwischen die Elemente.  In diesem Fall können Sie auf unterschiedliche Weise aus der Situation herauskommen. Wir berechnen den Durchschnitt zwischen ihnen.  Wir erhalten 150. Im Vergleich zum arithmetischen Durchschnitt ist deutlich zu erkennen, dass die Perzentile unempfindlich gegenüber Ausreißern sind. <br><br>  Wir berücksichtigen und nutzen diese Merkmale von Aggregationen.  Die arithmetische Empfindlichkeit von Emissionen ist ein Nachteil, wenn Sie versuchen, die Benutzererfahrung damit zu bewerten.  In der Tat kann ein Benutzer immer eine Verbindung zum Netzwerk herstellen, beispielsweise von einem Zug aus, und die Auswahl verderben. <br><br>  Die gleiche Empfindlichkeit ist jedoch ein Vorteil bei der Überwachung.  Um ein wichtiges Problem nicht zu übersehen, verwenden wir das arithmetische Mittel.  Es verschiebt sich leicht, aber das Risiko eines falschen Positivs ist in diesem Fall kein so großes Problem.  Besser zu übersehen als zu übersehen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcb/e92/a6b/dcbe92a6baf2a4ec1e2ef01580dd948d.jpg"><br><br>  Darüber hinaus berücksichtigen wir den Median (wenn wir dies an Zeitmetriken anhängen, ist der Median ein Indikator für den Zeitpunkt, zu dem 50% der Anforderungen passen) und das 75. Perzentil.  75% der Anfragen passen zu diesem Zeitpunkt, wir nehmen es als Schätzung der Gesamtgeschwindigkeit.  Das 95. und 99. Perzentil messen den langen, langsamen Schwanz.  Das sind sehr große Zahlen.  95. wird als die langsamste Anfrage angesehen.  Das 99. Perzentil ist abnormal. <br><br>  Es macht keinen Sinn, das Maximum zu zählen.  Dies ist der Weg zum Wahnsinn.  Nach der Berechnung des Maximums kann sich herausstellen, dass der Benutzer 20 Jahre lang auf das Laden der Seite gewartet hat. <br><br>  Nachdem Aggregationen berücksichtigt wurden, müssen nur diese Zahlen angewendet werden, und das offensichtlichste, was mit ihnen getan werden kann, ist, sie in Diagrammen darzustellen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8d/552/3e9/e8d5523e9eeebf2545a7f214b75b8ede.jpg"><br><br>  In der Grafik ist unsere Echtzeit, um zunächst inhaltliche Farbmetriken für die Suche zu malen.  Die blaue Linie spiegelt die Dynamik für Desktops wider, die rote für mobile Geräte. <br><br>  Wir müssen die Geschwindigkeitsgraphen ständig überwachen und haben diese Aufgabe dem Roboter anvertraut. <br><br><h2>  Überwachung </h2><br>  Da Geschwindigkeitsmetriken volatil sind und mit unterschiedlichen Zeiträumen ständig schwanken, muss die Überwachung genau abgestimmt werden.  Dafür verwenden wir das Konzept der Frustrationen. <br><br>  Das Debuggen ist der Moment, in dem ein zufälliger Prozess seine Eigenschaften wie Varianz oder mathematische Erwartung ändert.  In unserem Fall ist dies die durchschnittliche Stichprobe.  Wie bereits erwähnt, ist der Mittelwert emissionsempfindlich und für die Überwachung gut geeignet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/621/9a7/c0b/6219a7c0bc99aef5991cda07179a487a.jpg"><br><br>  Hier ist ein Beispiel eines Diagramms, in dem die Ausrichtung erfolgte und der Roboter den Vorfall aufzeichnete.  Wie hat er diesen Moment von einer Reihe anderer Zögern isoliert?  Um dies zu verstehen, legen wir zusätzliche Daten fest. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/93e/d21/ec4/93ed21ec4f2a624e3d703dc90b2c2530.jpg"><br><br>  Das gelbe Diagramm ist ein metrischer Indikator, und das blaue Diagramm ist ein gleitender Durchschnitt mit einer ausreichend großen Periode.  Rot ist der Mittelwert plus drei Standardabweichungen.  Grün ist das gleiche, nur mit einem Minuszeichen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c8/899/b90/4c8899b90f7e2696100aa4c7069a868c.jpg"><br><br>  Rote und grüne Indikatoren bilden einen sicheren Korridor.  Während die Metrik und der gleitende Durchschnitt zwischen ihnen schwanken - alles ist normal, sind dies gewöhnliche Schwankungen.  Wenn sie jedoch die Sicherheitszone verlassen, wird die Überwachung ausgelöst. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fb/d41/25e/9fbd4125ece689bd90a84e520304fd3a.jpg"><br><br><h2>  Überprüfen der Funktionen auf Geschwindigkeit </h2><br>  Alles, was besprochen wurde, war die Arbeit mit den Geschwindigkeitsdaten eines bereits gestarteten Projekts, aber ich möchte die Geschwindigkeit einzelner Features messen, bevor ich sie an eine große Produktion sende.  Dazu verwenden wir A / B-Tests - einen Vergleich der Metriken für die Kontroll- und Versuchsgruppe. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/819/128/e94/819128e94c08fec52e22da5914d28cbe.jpg"><br><br>  Wir unterteilen Benutzer in Kontroll- und Versuchsgruppen.  Die Messwerte jedes Slots werden separat gesammelt, aggregiert und tabellarisch dargestellt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31d/89b/1eb/31d89b1eb1915e2a0f8f29bc986f0521.jpg"><br><br>  Bei A / B-Tests wird in der Regel auch das arithmetische Mittel verwendet.  Hier sehen wir ein Delta und um genau zu bestimmen, ob es sich um einen Unfall oder ein signifikantes Ergebnis handelt, wird ein statistischer Test angewendet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e78/37d/134/e7837d1340c59e00cf61a132c6ac72c9.jpg"><br><br>  Es wird als "MW" bezeichnet, da bei der Berechnung der Mann-Whitney-Test verwendet wird.  Mit seiner Hilfe wird der sogenannte "Prozentsatz der Korrektheit" berechnet.  Dieser Indikator hat einen Schwellenwert, nach dem wir das Delta als wahr annehmen.  Hier liegt sie bei 99,9%. <br><br>  Wenn der Test diesen Wert erreicht, wird das Delta in der Schnittstelle hervorgehoben.  Wir nennen es Färbung.  Hier sehen wir Grün, das heißt eine gute Färbung rechtzeitig zum ersten zufriedenstellenden Malen.  Die Zeit bis zur ersten sinnvollen Farbe erreicht diesen Wert nicht, dh das Delta ist ebenfalls gut, aber nicht 99,9%.  Es ist völlig unmöglich, ihr zu vertrauen.  Bei der Initialisierung des Frameworks und der Zeit bis zur Interaktion wird eine sicher schlechte rote Färbung beobachtet.  Daraus können wir die gleiche Schlussfolgerung ziehen wie bei Schriftarten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25b/415/b14/25b415b14b30b25549f514aced7b52dd.jpg"><br><br><h2>  Wie geht das selbst? </h2><br>  Sie können Geschwindigkeitsmessungen auf zwei Arten durchführen.  Das erste ist, alles selbst zu machen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e30/344/cb5/e30344cb56179ed9a633ff26c187291e.jpg"><br><br>  Ein Handle zum Empfangen von Daten von Clients, ein Backend, das all dies in eine Datenbank, MongoDB, PostgreSQL, MySQL, jedes DBMS (sie haben sofort einsatzbereite Aggregationen) sowie eine der vielen Open-Source-Lösungen - um Diagramme zu zeichnen und die Überwachung zu arrangieren. <br><br>  Die zweite Lösung besteht in der Verwendung von Yandex Metric- oder Google Analytics-Analysesystemen.  Am Beispiel von Yandex Metrics sieht es so aus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/424/a97/f61/424a97f61a797dff9419d7df8828046b.jpg"><br><br>  Hier sind die Metriken, die die Metrik dem Benutzer sofort zur Verfügung stellt.  Natürlich ist dies nicht alles, aber schon etwas.  Der Rest kann manuell über Benutzereinstellungen hinzugefügt werden.  A / B-Tests und -Überwachung sind ebenfalls verfügbar. <br><br><h2>  Fazit </h2><br>  Das Konzept der Online-Geschwindigkeitsmessung, über das wir gesprochen haben, ist als RUM - Real User Monitoring bekannt.  Wir lieben sie so sehr, dass wir sogar ein Logo mit einem coolen Rock'n'Roll-Umlaut gezeichnet haben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5f/8a9/448/e5f8a94489f01743c09e5ec04453cc56.jpg"><br><br>  Dieser Ansatz ist gut, da er auf Zahlen aus der realen Welt basiert, den Indikatoren, die das Publikum Ihres Dienstes hat.  Mithilfe von Metriken erhalten Sie anscheinend Feedback von jedem Benutzer.  Beginnen Sie also mit der Optimierung und hören Sie nicht auf. <br><blockquote>  Die Ankündigung am Ende.  Wenn Ihnen dieses Gespräch mit <b>HolyJS 2018 Piter</b> gefallen hat, werden Sie wahrscheinlich an der bevorstehenden <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HolyJS 2018 Moskau</a></b> interessiert sein, <b>die vom 24. bis 25. November stattfinden wird</b> .  Dort können Sie nicht nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele andere</a> JS-Berichte sehen, sondern auch jeden Redner im Diskussionsbereich nach dem Bericht fragen.  Und morgen, ab dem 1. November, steigen die Ticketpreise bis zum Finale. Heute ist die letzte Gelegenheit, sie mit einem Rabatt zu kaufen! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426571/">https://habr.com/ru/post/de426571/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426559/index.html">Neuronale Netze zur Bildverarbeitung. Sagt Alexander Savsunenko von Skylum Software</a></li>
<li><a href="../de426561/index.html">Die Großen Fünf: müssen Werkzeuge haben, um die Entwicklung zu beschleunigen</a></li>
<li><a href="../de426563/index.html">Hierarchisches Adressbuch, Änderung der primären E-Mail und andere Neuerungen in Zimbra 8.8.10</a></li>
<li><a href="../de426565/index.html">"Die Java-Welt wird nie wieder dieselbe sein" - Interview mit Alexander Belokrylov und Alexey Voitilov von BellSoft</a></li>
<li><a href="../de426567/index.html">Das Buch „Mathematisches Chaos. Von der Elementarmathematik zu erhabenen Abstraktionen “</a></li>
<li><a href="../de426573/index.html">ZeroNights 2018. Neu laden</a></li>
<li><a href="../de426575/index.html">Bericht des Club of Rome 2018, Kapitel 1.12: „Von einer leeren Welt zu einer vollständigen Welt“</a></li>
<li><a href="../de426579/index.html">Engie und Ledger entwickeln eine Hardware-Blockchain-Lösung zum Speichern von Daten, die von grünen Energiequellen erzeugt werden</a></li>
<li><a href="../de426581/index.html">Offene Lektion "Übersicht über die Funktionen von Node.j"</a></li>
<li><a href="../de426583/index.html">Zehn Leute auf 90.000 Websites: Wie man nicht verrückt wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>