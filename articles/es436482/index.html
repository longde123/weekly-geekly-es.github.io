<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ñ™Ô∏è üí£ üìù Advanced Three.js: materiales de sombreado y postprocesamiento ü•ñ üßñ üç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hay bastantes introducciones a los conceptos b√°sicos de trabajar con Three.js en la web, pero puede notar una escasez de materiales sobre temas m√°s av...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Advanced Three.js: materiales de sombreado y postprocesamiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436482/"><p><img src="https://habrastorage.org/webt/hh/qv/5o/hhqv5okcynxdjke-qqhtmvokjsw.jpeg"></p><br><p>  Hay bastantes introducciones a los conceptos b√°sicos de trabajar con Three.js en la web, pero puede notar una escasez de materiales sobre temas m√°s avanzados.  Y uno de estos temas es la combinaci√≥n de sombreadores y escenas con modelos tridimensionales.  A los ojos de muchos desarrolladores novatos, estas son cosas aparentemente incompatibles de mundos diferentes.  Hoy, usando un ejemplo simple de una "esfera de plasma", veremos qu√© es ShaderMaterial y con qu√© se come, qu√© efecto de efecto es y qu√© tan r√°pido es posible realizar un procesamiento posterior para una escena renderizada. </p><a name="habracut"></a><br><p> Se supone que el lector est√° familiarizado con los conceptos b√°sicos de trabajar con Three.js y comprende c√≥mo funcionan los sombreadores.  Si no ha encontrado esto antes, le recomiendo leer esto primero: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducci√≥n a la programaci√≥n de sombreadores para dise√±os</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aplicar mosaico Voronoi y m√°scaras geom√©tricas en sombreadores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Presentaciones tridimensionales de productos en Three.js para los m√°s peque√±os.</a> </li></ul><br><p>  Pero empecemos ... </p><br><h2 id="shadermaterial--chto-eto">  ShaderMaterial: ¬øqu√© es eso? </h2><br><p>  Ya hemos visto c√≥mo se usa una textura plana y c√≥mo se estira sobre un objeto tridimensional.  Como esta textura era una imagen ordinaria.  Cuando examinamos la escritura de sombreadores de fragmentos, all√≠ tambi√©n todo era plano.  Entonces: si podemos usar un sombreador para generar una imagen plana, ¬øpor qu√© no usarlo como textura? </p><br><p>  Es esta idea la que forma la base del material de sombreado.  Al crear material para un objeto tridimensional, indicamos sombreadores en lugar de una textura para √©l.  En su forma b√°sica, se ve m√°s o menos as√≠: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderMaterial = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderMaterial({ <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// ... }, vertexShader: '...', fragmentShader: '...' });</span></span></code> </pre> <br><p>  El sombreador de fragmentos se usar√° para crear la textura del material, y usted, por supuesto, pregunta, ¬øqu√© har√° el sombreador de v√©rtices?  ¬øVolver√° a hacer un recuento banal de coordenadas?  S√≠, comenzaremos con esta opci√≥n simple, pero tambi√©n podemos establecer un desplazamiento o realizar otras manipulaciones para cada v√©rtice de un objeto tridimensional; ahora no hay restricciones en el plano.  Pero es mejor ver todo esto con un ejemplo.  En palabras, poco se entiende.  Crea una escena y haz una esfera en el centro. </p><br><p><img src="https://habrastorage.org/webt/ot/0n/zj/ot0nzjfc89iiwsqqdc2isam_woo.jpeg"></p><br><p>  Como material para la esfera, utilizaremos ShaderMaterial: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.SphereBufferGeometry(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderMaterial = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderMaterial({ <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// . . . }, vertexShader: document.getElementById('sphere-vertex-shader').textContent, fragmentShader: document.getElementById('sphere-fragment-shader').textContent }); const sphere = new THREE.Mesh(geometry, shaderMaterial); SCENE.add(sphere);</span></span></code> </pre> <br><p>  El sombreador de v√©rtices ser√° neutral: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Tenga en cuenta que Three.js pasa sus variables uniformes.  No tenemos que hacer nada, est√°n impl√≠citos.  En s√≠ mismos, contienen todo tipo de matrices, a las que ya tenemos acceso desde JS, as√≠ como la posici√≥n de la c√°mara.  Imagine que al comienzo de los sombreadores se inserta algo: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// = object.matrixWorld uniform mat4 modelMatrix; // = camera.matrixWorldInverse * object.matrixWorld uniform mat4 modelViewMatrix; // = camera.projectionMatrix uniform mat4 projectionMatrix; // = camera.matrixWorldInverse uniform mat4 viewMatrix; // = inverse transpose of modelViewMatrix uniform mat3 normalMatrix; // = camera position in world space uniform vec3 cameraPosition;</span></span></code> </pre> <br><p>  Adem√°s, se pasan varias variables de atributo al sombreador de v√©rtices: </p><br><pre> <code class="cpp hljs">attribute vec3 position; attribute vec3 normal; attribute vec2 uv;</code> </pre> <br><p>  Por los nombres queda claro de qu√© se trata: la posici√≥n del v√©rtice actual, la normal a la superficie en este punto y las coordenadas de la textura a la que corresponde el v√©rtice. </p><br><p>  Tradicionalmente, las coordenadas en el espacio se designan como (x, y, z), y las coordenadas en el plano de textura como (u, v).  De ah√≠ el nombre de la variable.  A menudo lo encontrar√°s en varios ejemplos.  En teor√≠a, necesitamos transferir estas coordenadas al sombreador de fragmentos para poder trabajar con ellas all√≠.  Lo haremos </p><br><pre> <code class="cpp hljs">varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Para empezar, el fragment shader deber√≠a ser algo como esto: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPSILON 0.02 varying vec2 vUv; void main() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((fract(vUv.x * 10.0) &lt; EPSILON) || (fract(vUv.y * 10.0) &lt; EPSILON)) { gl_FragColor = vec4(vec3(0.0), 1.0); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { gl_FragColor = vec4(1.0); } }</span></span></code> </pre> <br><p>  Solo crea una malla.  Si piensas un poco, en el plano ser√° solo una cuadr√≠cula de cuadrados, pero como lo superponemos en una esfera, se distorsiona y se convierte en un globo.  Hay una buena imagen en Wikipedia que ilustra lo que est√° sucediendo: </p><br><p><img src="https://habrastorage.org/webt/uc/uq/us/ucuqusdhqwfubpgtrpujvwq7uww.png"></p><br><p>  Es decir, en el sombreador de fragmentos hacemos una textura plana, como en el centro de esta ilustraci√≥n, y Three.js luego la arrastra hacia la esfera.  Muy comodo </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/EGzKOd" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Por supuesto, para modelos m√°s complejos, el barrido ser√° m√°s complicado.  Pero generalmente al crear varios sitios de dise√±o trabajamos con formas geom√©tricas simples y es f√°cil imaginar un barrido en su cabeza. </p><br><h2 id="ok-a-chto-s-etim-mozhno-delat">  Ok, ¬øqu√© puedes hacer al respecto? </h2><br><p>  La caracter√≠stica principal es que el material del sombreador puede cambiar con el tiempo.  Esto no es algo est√°tico que dibujamos una vez y olvidamos, podemos animarlo.  Adem√°s, tanto en color (en el sombreador de fragmentos) como en forma (en el v√©rtice).  Esta es una herramienta muy poderosa. </p><br><p>  En nuestro ejemplo, haremos un fuego que envuelva una esfera.  Habr√° dos esferas: una ordinaria (adentro) y la segunda del material del sombreador (afuera, con un radio grande).  Agregar otra esfera no har√° comentarios. </p><br><p><img src="https://habrastorage.org/webt/ti/_q/4m/ti_q4mo843ywt0fbjdmd8nmrcmy.jpeg"></p><br><p>  Primero, agregue el tiempo como una variable uniforme para los sombreadores de nuestro material.  En ninguna parte sin tiempo.  Ya hicimos esto en JS puro, pero en Three.js es igual de simple.  Deje que el tiempo en los sombreadores se llame uTime y se almacene en la variable TIME: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateUniforms</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ SCENE.traverse(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">child</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> THREE.Mesh &amp;&amp; child.material.type === <span class="hljs-string"><span class="hljs-string">'ShaderMaterial'</span></span>) { child.material.uniforms.uTime.value = TIME; child.material.needsUpdate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }); }</code> </pre> <br><p>  Actualizamos todo con cada llamada a la funci√≥n animada: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ requestAnimationFrame(animate); TIME += <span class="hljs-number"><span class="hljs-number">0.005</span></span>; updateUniforms(); render(); }</code> </pre> <br><h2 id="ogon">  Fuego </h2><br><p>  Crear un fuego es esencialmente muy similar a generar un paisaje, pero en lugar de alturas, color.  O transparencia, como en nuestro caso. </p><br><p>  Funciones de aleatoriedad y ruido que ya hemos visto, no las analizaremos en detalle.  Todo lo que tenemos que hacer es hacer ruido a diferentes frecuencias para agregar variedad, y hacer que cada uno de estos ruidos se mueva a diferentes velocidades.  Obtendr√° algo as√≠ como llamas, las grandes se mueven lentamente, las peque√±as se mueven m√°s r√°pido: </p><br><pre> <code class="cpp hljs">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec2 position1 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime); vec2 position2 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime * <span class="hljs-number"><span class="hljs-number">2.0</span></span>); vec2 position3 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime * <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color = ( noise(position1 * <span class="hljs-number"><span class="hljs-number">5.0</span></span>) + noise(position2 * <span class="hljs-number"><span class="hljs-number">10.0</span></span>) + noise(position3 * <span class="hljs-number"><span class="hljs-number">15.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">3.0</span></span>; gl_FragColor = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, color - smoothstep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1.3</span></span>, vUv.y)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 seed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(dot(seed, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 position)</span></span></span><span class="hljs-function"> </span></span>{ vec2 blockPosition = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> topLeftValue = rand(blockPosition); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> topRightValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottomLeftValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottomRightValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec2 computedValue = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, fract(position)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mix(topLeftValue, topRightValue, computedValue.x) + (bottomLeftValue - topLeftValue) * computedValue.y * (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - computedValue.x) + (bottomRightValue - topRightValue) * computedValue.x * computedValue.y; }</code> </pre> <br><p>  Para que la llama no cubra toda la esfera, jugamos con el cuarto par√°metro de color, la transparencia, y lo unimos a la coordenada y.  En nuestro caso, esta opci√≥n es muy conveniente.  En t√©rminos m√°s generales, aplicamos un gradiente con transparencia al ruido. </p><br><blockquote>  En momentos como estos, es √∫til recordar la funci√≥n smoothstep. </blockquote><p>  En general, este enfoque para crear fuego usando sombreadores es un cl√°sico.  A menudo lo encontrar√°s en varios lugares.  Ser√° √∫til jugar con n√∫meros m√°gicos: se establecen aleatoriamente en el ejemplo, y c√≥mo se ver√° el plasma depende de ellos. </p><br><p>  Para hacer que el fuego sea m√°s interesante, pasemos al sombreador de v√©rtices y a un peque√±o cham√°n ... </p><br><p>  ¬øC√≥mo hacer que la llama se vierta un poco en el espacio?  Para los principiantes, esta pregunta puede causar grandes dificultades, a pesar de su simplicidad.  Vi enfoques muy complejos para resolver este problema, pero en esencia, necesitamos mover suavemente los v√©rtices de la esfera a lo largo de las l√≠neas "desde su centro".  De aqu√≠ para all√°, de aqu√≠ para all√°.  Three.js ya nos ha pasado la posici√≥n actual del v√©rtice y la normal: los usaremos.  Para "hacia adelante y hacia atr√°s" se ajustar√° alguna funci√≥n limitada, por ejemplo, un seno.  Por supuesto, puede experimentar, pero el seno es la opci√≥n predeterminada. </p><br><blockquote>  No s√© qu√© llevar, tome el seno.  Mejor a√∫n, la suma de los senos con diferentes frecuencias. </blockquote><p>  Cambiamos las coordenadas normales al valor obtenido y recalculamos de acuerdo con la f√≥rmula previamente conocida. </p><br><pre> <code class="cpp hljs">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; vec3 delta = normal * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(position.x * position.y * uTime / <span class="hljs-number"><span class="hljs-number">10.0</span></span>); vec3 newPosition = position + delta; gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Lo que obtenemos ya no es una esfera.  Esto ... ni siquiera s√© si este tiene un nombre.  Pero, de nuevo, no te olvides de jugar con las probabilidades: afectan mucho.  Al crear tales efectos, a menudo se selecciona algo por prueba y error y es muy √∫til desarrollar una "intuici√≥n matem√°tica" en uno mismo: la capacidad de imaginar m√°s o menos c√≥mo se comporta una funci√≥n, c√≥mo depende de qu√© variables. </p><br><p>  En esta etapa, tenemos una imagen interesante, pero un poco torpe.  Primero, echemos un vistazo al postprocesamiento y luego pasemos a un ejemplo vivo. </p><br><h2 id="postobrabotka">  Post procesamiento </h2><br><p>  La capacidad de hacer algo con la imagen renderizada de Three.js es algo muy √∫til, aunque se olvida inmerecidamente en numerosas series de lecciones.  T√©cnicamente, esto se implementa de la siguiente manera: la imagen que nos dio el renderizador se env√≠a a EffectComposer (siempre que sea un cuadro negro), que chamaniza algo en s√≠ mismo y muestra la imagen final en el lienzo.  Es decir, despu√©s del renderizador, se agrega un m√≥dulo m√°s.  Transferimos par√°metros a este compositor: qu√© hacer con la imagen recibida.  Uno de esos par√°metros se llama pasar.  En cierto sentido, el compositor funciona como un Gulp: no hace nada, le damos complementos que ya hacen el trabajo.  Quiz√°s no sea del todo correcto decirlo, pero la idea deber√≠a ser clara. </p><br><p>  Todo lo que usaremos m√°s adelante no est√° incluido en la estructura b√°sica de Three.js, por lo que conectamos algunas dependencias y dependencias de las dependencias mismas: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/EffectComposer.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/RenderPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/ShaderPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/shaders/CopyShader.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/shaders/LuminosityHighPassShader.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/UnrealBloomPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><blockquote>  Recuerde que estos scripts est√°n incluidos en el paquete de tres y puede poner todo esto en un solo paquete usando un paquete web o an√°logos. </blockquote><p>  En su forma b√°sica, el compositor se crea as√≠: </p><br><pre> <code class="javascript hljs">COMPOSER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.EffectComposer(RENDERER); COMPOSER.setSize(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> renderPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.RenderPass(SCENE, CAMERA); renderPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(renderPass);</code> </pre> <br><p>  RenderPass en realidad no hace nada nuevo.  Simplemente representa lo que sol√≠amos obtener de un renderizador regular.  De hecho, si observa el c√≥digo fuente de RenderPass, puede encontrar el renderizador est√°ndar all√≠.  Como ahora el renderizado est√° sucediendo all√≠, debemos reemplazar el renderizador con el compositor en nuestro script: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// RENDERER.render(SCENE, CAMERA); COMPOSER.render(SCENE, CAMERA); }</span></span></code> </pre> <br><p>  Este enfoque que utiliza RenderPass como primer paso es una pr√°ctica est√°ndar cuando se trabaja con EffectComposer.  Por lo general, primero necesitamos obtener una imagen renderizada de la escena, luego hacer algo con ella. </p><br><p>  En los ejemplos de Three.js, en la secci√≥n de postprocesamiento, puede encontrar una cosa llamada UnrealBloomPass.  Este es un script portado del motor Unreal.  Agrega un poco de brillo que se puede usar para crear una iluminaci√≥n m√°s bella.  A menudo, este ser√° el primer paso para mejorar la imagen. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bloomPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.UnrealBloomPass( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Vector2(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight), <span class="hljs-number"><span class="hljs-number">1.5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>); bloomPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(bloomPass);</code> </pre> <br><p>  Tenga en cuenta: la opci√≥n renderToScreen est√° configurada solo para el √∫ltimo Pase que pasamos al compositor. </p><br><p>  Pero ya veamos qu√© tipo de brillo nos dio este bloomPass y c√≥mo encaja con la esfera: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/MZdegG" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  De acuerdo, esto es mucho m√°s interesante que solo una esfera y una fuente de luz ordinaria, ya que generalmente se muestran en las lecciones iniciales en Three.js. </p><br><p>  Pero iremos a√∫n m√°s lejos ... </p><br><h2 id="bolshe-sheyderov-bogu-sheyderov">  ¬°M√°s sombreadores para el dios sombreador! </h2><br><p><img src="https://habrastorage.org/webt/kk/ap/ks/kkapksi_a_secwfoh81jjxkgtx4.jpeg"></p><br><p>  Es muy √∫til usar console.log y observar la estructura del compositor.  En √©l, puede encontrar algunos elementos con los nombres renderTarget1, renderTarget2, etc., donde los n√∫meros corresponden a los √≠ndices de los pases pasados.  Y luego queda claro por qu√© se llama a EffectComposer.  Funciona seg√∫n el principio de filtros en SVG.  ¬øRecuerdas que puedes usar el resultado de realizar algunos filtros en otros?  Aqu√≠ lo mismo: puedes combinar efectos. </p><br><blockquote>  Usar console.log para comprender la estructura interna de los objetos Three.js y muchas otras bibliotecas es muy √∫til.  Use este enfoque con m√°s frecuencia para comprender mejor qu√© es qu√©. </blockquote><p>  Agrega otro pase.  Esta vez ser√° ShaderPass. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shader = { <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-attr"><span class="hljs-attr">uRender</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: COMPOSER.renderTarget2 }, <span class="hljs-attr"><span class="hljs-attr">uTime</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: TIME } }, <span class="hljs-attr"><span class="hljs-attr">vertexShader</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'postprocessing-vertex-shader'</span></span>).textContent, <span class="hljs-attr"><span class="hljs-attr">fragmentShader</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'postprocessing-fragment-shader'</span></span>).textContent }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderPass(shader); shaderPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(shaderPass);</code> </pre> <br><p>  RenderTarget2 contiene el resultado del pase anterior: bloomPass (fue el segundo en una fila), lo usamos como una textura (esto es esencialmente una imagen plana) y lo pasamos como una variable uniforme al nuevo sombreador. </p><br><p>  Probablemente valga la pena frenar y darse cuenta de toda la magia aqu√≠ ... </p><br><p>  A continuaci√≥n, cree un sombreador de v√©rtices simple.  En la mayor√≠a de los casos, en esta etapa, no necesitamos hacer nada con los v√©rtices, solo pasamos las coordenadas (u, v) al sombreador de fragmentos: </p><br><pre> <code class="cpp hljs">varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Y en fragmentaria podemos divertirnos a nuestro gusto y color.  Por ejemplo, podemos agregar un efecto de falla de luz, hacer que todo sea en blanco y negro y jugar con brillo / contraste: </p><br><pre> <code class="cpp hljs">uniform sampler2D uRender; uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> randomValue = rand(vec2(<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(vUv.y * <span class="hljs-number"><span class="hljs-number">7.0</span></span>), uTime / <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec4 color; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomValue &lt; <span class="hljs-number"><span class="hljs-number">0.02</span></span>) { color = texture2D(uRender, vec2(vUv.x + randomValue - <span class="hljs-number"><span class="hljs-number">0.01</span></span>, vUv.y)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { color = texture2D(uRender, vUv); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightness = (color.r + color.g + color.b) / <span class="hljs-number"><span class="hljs-number">3.0</span></span>; color.rgb = vec3(smoothstep(<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, lightness)); gl_FragColor = color; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 seed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(dot(seed, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); }</code> </pre> <br><p>  Veamos el resultado: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/MZdeKB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Como puede ver, los filtros se superponen a la esfera.  Todav√≠a es tridimensional, nada se ha roto, pero en el lienzo tenemos una imagen procesada. </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  Los materiales de sombreado y el procesamiento posterior en Three.js son dos herramientas peque√±as pero muy poderosas que definitivamente vale la pena usar.  Hay muchas opciones para su uso: todo est√° limitado por su imaginaci√≥n.  Incluso las escenas m√°s simples con su ayuda pueden cambiarse m√°s all√° del reconocimiento. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436482/">https://habr.com/ru/post/es436482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436468/index.html">Experimento legislativo con innovaci√≥n digital</a></li>
<li><a href="../es436472/index.html">Conferencia DEFCON 20. Captura en 60 segundos: de una cuenta de invitado a un administrador de dominio de Windows. Parte 1</a></li>
<li><a href="../es436474/index.html">Conferencia DEFCON 20. Captura en 60 segundos: de una cuenta de invitado a un administrador de dominio de Windows. Parte 2</a></li>
<li><a href="../es436476/index.html">Nube para aseguradoras</a></li>
<li><a href="../es436480/index.html">Hice un bot que se comunica con los reclutadores para m√≠, y me gust√≥</a></li>
<li><a href="../es436484/index.html">D√≥nde encontrar la configuraci√≥n de DNS en MacOS</a></li>
<li><a href="../es436486/index.html">¬øQu√© est√° pasando en el mercado de podcasts de audio?</a></li>
<li><a href="../es436488/index.html">Curry y aplicaci√≥n parcial en C ++ 14</a></li>
<li><a href="../es436490/index.html">Motorola planea introducir la encarnaci√≥n Razr v3</a></li>
<li><a href="../es436492/index.html">Estamos buscando oradores en el d√©cimo DIY Mitap 17 de febrero de 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>