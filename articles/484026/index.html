<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüî¨ üë©‚Äçüëß‚Äçüëß üë©üèΩ‚Äçüî¨ Parte 6: Portar MemTest86 + a RISC-V üîä ü§ô üìµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probablemente pocos especialistas de TI necesiten explicar qu√© es Memtest86 +, tal vez ya se haya convertido m√°s o menos en el est√°ndar para probar RA...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parte 6: Portar MemTest86 + a RISC-V</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484026/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ne/fb/ha/nefbhar5ihkfmvccfwp0jqrm78u.png"></div><br><p>  Probablemente pocos especialistas de TI necesiten explicar qu√© es Memtest86 +, tal vez ya se haya convertido m√°s o menos en el est√°ndar para probar RAM en una PC.  Cuando en una de las <a href="https://habr.com/ru/post/459470/">partes anteriores</a> me encontr√© con una barra de memoria rota que viene incluida con la placa, (junto con una netbook con DDR2 habilitado) parec√≠a una soluci√≥n obvia.  Otra pregunta es que all√≠, en principio, el funcionamiento inestable del sistema era visible a simple vista.  En casos m√°s complicados, escuch√© que, adem√°s del "toque" banal de las celdas de memoria hasta el infinito, esta herramienta utiliza algunos patrones de datos especiales en los que es m√°s probable que se detecten errores en la operaci√≥n DDR.  En general, algo maravilloso, es una pena que incluso en el nombre que dice: 86 - "Solo para sistemas compatibles con x86".  O no? </p><br><p>  Debajo del corte, ver√° mis intentos de portar MemTest86 + v5.1 a RISC-V y el subtotal.  <em>Spoiler: se mueve!</em> </p><a name="habracut"></a><br><p>  <strong>DESCARGO DE RESPONSABILIDAD: el proyecto resultante fue probado m√≠nimamente espec√≠ficamente por m√≠ en un ensamblaje RocketChip espec√≠fico en un tablero espec√≠fico.</strong>  <strong>La precisi√≥n y la seguridad (especialmente en otros sistemas) no est√°n garantizadas.</strong>  <strong>Use bajo su propio riesgo.</strong>  <strong>En particular, las √°reas de memoria reservadas actualmente no se procesan de ninguna manera si caen en el rango de RAM.</strong> </p><br><p>  Como ya dije, no hace mucho tiempo compr√© una placa base con Cyclone IV en AliExpress, pero la memoria conten√≠a errores.  Afortunadamente, una de las caracter√≠sticas importantes de esta placa fue el uso de m√≥dulos DDR2 SO-DIMM convencionales, lo mismo que en mi viejo netbook.  Sin embargo, ser√≠a interesante obtener, por as√≠ decirlo, una soluci√≥n autohospedada para probar los m√≥dulos de memoria (y, de hecho, tambi√©n el controlador).  La posibilidad de depurar mis errores en las condiciones de mala memoria no era del todo agradable.  Especialmente sin esperar una soluci√≥n r√°pida y mentalmente prepar√°ndome para posponer la reescritura completa en otro ensamblador por un tiempo indefinidamente largo, abr√≠ un art√≠culo de Wikipedia sobre Memtest86 + y de repente vi "Escrito en: C y ensamblaje" en la tarjeta.  Hmm, es decir, √©l, aunque "... 86", pero no est√° escrito completamente en ensamblador?  Esto es alentador.  Solo queda entender la relaci√≥n. </p><br><p>  Entonces, vaya a <a href="http://www.memtest.org/" rel="nofollow">memtest.org</a> y descargue la versi√≥n 5.01 bajo GPL2.  Para facilitar el desarrollo, lo volv√≠ a <a href="https://github.com/atrosinenko/memtest86-plus-riscv" rel="nofollow">cargar</a> en GitHub.  Afortunadamente, justo en el archivo fuente, nos <a href="https://github.com/atrosinenko/memtest86-plus-riscv/blob/68b365d13cf22accd52f88af49c33f57c6643ae5/README.background" rel="nofollow">recibe el</a> archivo <a href="https://github.com/atrosinenko/memtest86-plus-riscv/blob/68b365d13cf22accd52f88af49c33f57c6643ae5/README.background" rel="nofollow">README.background</a> , titulado </p><br><blockquote>  La anatom√≠a y fisiolog√≠a de Memtest86-SMP </blockquote><p> Explica con cierto detalle (e incluso con im√°genes en forma de arte ASCII) la operaci√≥n de alto nivel del c√≥digo.  Al comienzo del documento, vemos un <em>dise√±o binario</em> , que consta de <code>bootsect.o</code> , <code>setup.o</code> , <code>head.o</code> y algunos <code>memtest_shared</code> .  Es f√°cil ver que estos tres archivos de objetos se obtienen de las fuentes de ensamblador correspondientes.  A primera vista, todo lo dem√°s est√° escrito en C!  No est√° mal, no est√° mal ... </p><br><p>  Como resultado, copi√© el <code>Makefile</code> a <code>Makefile.arch</code> y comenc√© a reescribir todo, e intentar tirar lo que no corresponde.  En primer lugar, por supuesto, necesitaba una cadena de herramientas para RISC-V, que, afortunadamente, todav√≠a ha estado conmigo desde los experimentos anteriores.  Al principio pens√© en hacer un puerto para la arquitectura de 32 bits, pero luego record√© que se hab√≠a cargado un procesador de 64 bits en la placa, y ten√≠a la <code>riscv64-</code> con el prefijo <code>riscv64-</code> . </p><br><p>  <em>Digresi√≥n de letras: por</em> supuesto, lo primero fue estudiar el tema de la compatibilidad del c√≥digo de 32 y 64 bits.  Como resultado, la especificaci√≥n para la parte no privilegiada de la ISA (Arquitectura del conjunto de instrucciones) que se encuentra en el p√°rrafo <code>1.3 RISC-V ISA Overview</code> declaraci√≥n <code>1.3 RISC-V ISA Overview</code> : </p><br><blockquote>  La principal ventaja de separar expl√≠citamente las ISA base es que cada ISA base puede optimizarse para sus necesidades sin necesidad de admitir todas las operaciones necesarias para otras ISA base.  Por ejemplo, RV64I puede omitir instrucciones y CSR que solo son necesarios para hacer frente a los registros m√°s estrechos en RV32I.  Las opciones RV32I pueden usar el espacio de codificaci√≥n, de lo contrario reservado para instrucciones que solo son requeridas por variantes de espacio de direcciones m√°s amplias. </blockquote><p>  Tambi√©n quiero se√±alar que es probable que la cadena de herramientas con el prefijo <code>riscv64-</code> recopile f√°cilmente el c√≥digo de 32 bits si la arquitectura de destino se selecciona correctamente, m√°s sobre eso m√°s adelante. </p><br><p>  En el proceso de portabilidad, tiene sentido mantener estos documentos a mano: </p><br><ul><li>  <a href="https://riscv.org/specifications/" rel="nofollow">Manual del conjunto de instrucciones RISC-V Volumen I: ISA sin privilegios</a> </li><li>  <a href="https://riscv.org/specifications/privileged-isa/" rel="nofollow">Manual del conjunto de instrucciones RISC-V Volumen II: Arquitectura privilegiada</a> </li><li>  Adem√°s, algunos <a href="https://sifive.cdn.prismic.io/sifive%252F834354f0-08e6-423c-bf1f-0cb58ef14061_fu540-c000-v1.0.pdf" rel="nofollow">manuales de SiFive FU540-C000</a> , un manual para el chip, similar en comportamiento al procesador de software, que se usa para depurar en FPGA, no estar√°n fuera de lugar </li></ul><br><h2 id="nastroyka-sborki">  Configuraci√≥n de compilaci√≥n </h2><br><p>  Comencemos por aceptar: quiero obtener un puerto adecuado para portar m√°s a arquitecturas que no sean x86 y RISC-V.  Tambi√©n propongo lanzar disquetes de arranque y otros detalles de x86 fuera de la construcci√≥n multiplataforma. </p><br><p>  Lo que finalmente tenemos: hay tres archivos ensambladores: <code>bootsect.S</code> , <code>setup.S</code> y <code>head.S</code>  Los primeros dos son necesarios solo al inicio, y el tercero se necesita m√°s adelante cuando se traslada a otra √°rea de memoria.  El hecho es que para probar la memoria "debajo de uno mismo", el c√≥digo de prueba primero debe moverse a un nuevo lugar.  Estos archivos se recopilan en ELF, de donde se toman secciones de c√≥digo, datos, etc.  Adem√°s, est√° ensamblado en forma de PIC (c√≥digo independiente de posici√≥n), al principio incluso me sorprendi√≥: aunque el c√≥digo es independiente (es decir, sin un n√∫cleo, libc, etc.), utiliza caracter√≠sticas tan avanzadas. </p><br><p>  Adem√°s, en el Makefile se encuentran peri√≥dicamente par√°metros que especifican la arquitectura: <code>-march=i486</code> , <code>-m32</code> y similares.  Necesito escribir algo as√≠ <del>  y luego como un tonto </del>  .  La situaci√≥n con la arquitectura RISC-V es algo como esto: hay <code>rv64</code> <code>rv32</code> y <code>rv64</code> (como, todav√≠a hay los embebidos m√°s truncados y rv128 reservados para el futuro, pero no estamos muy interesados ‚Äã‚Äãen ellos), y el nombre ISA se forma asignando letras a este prefijo extensiones: <code>i</code> - el conjunto de instrucciones de enteros b√°sico, <code>m</code> - multiplicaci√≥n y divisi√≥n de enteros, ... Por supuesto, me gustar√≠a hacer <code>rv64i</code> , pero Memtest86 dif√≠cilmente ser√° portado f√°cilmente a la arquitectura sin multiplicaci√≥n.  Es cierto que parece que el compilador simplemente generar√° llamadas de funci√≥n en lugar de instrucciones "problem√°ticas", pero existe el riesgo de quedarse con un rendimiento muy reducido (sin mencionar el hecho de que estas funciones deber√°n escribirse o llevarse a alg√∫n lado). </p><br><p>  Tambi√©n necesitar√° la l√≠nea ABI.  En principio, los conceptos b√°sicos de la convenci√≥n de convocatoria ya se describen en el <code>Volume I</code> especificado en el "Manual del programador de ensamblaje RISC-V", as√≠ que har√© algo como </p><br><pre> <code class="plaintext hljs">$ riscv64-linux-gnu-gcc-9 -mabi=help riscv64-linux-gnu-gcc-9: error: unrecognized argument in option '-mabi=help' riscv64-linux-gnu-gcc-9: note: valid arguments to '-mabi=' are: ilp32 ilp32d ilp32e ilp32f lp64 lp64d lp64f riscv64-linux-gnu-gcc-9: fatal error: no input files compilation terminated.</code> </pre> <br><p>  Y sin pensarlo <code>lp64</code> , tomar√© <code>lp64</code> .  <em>Mirando hacia el futuro, dir√© que con este ABI, los archivos de encabezado de la biblioteca est√°ndar no funcionaron, as√≠ que tom√© <code>lp64f</code> y ARCH "actualic√©" a <code>rv64imf</code> .</em>  <em>Sin p√°nico, no planeo usar realmente punto flotante en mi puerto.</em> </p><br><p>  Como de alguna manera no quer√≠a profundizar en la escritura de scripts de enlazador multiplataforma y, por lo tanto, no pude <em>encontrar de</em> inmediato <em>las claves de ld</em> , decid√≠ seguir <code>head.S</code> con el archivo de ensamblador <code>head.S</code> , aferr√°ndome al resto de las funciones usando <code>memtest_shared.arch.lds</code> .  Descart√© una indicaci√≥n del formato de salida y la arquitectura (despu√©s de todo, es m√°s f√°cil cambiarlo de una variable en el Makefile), y tambi√©n coment√© temporalmente <code>DISCARD</code> al final, no pudiendo averiguar qu√© secciones espec√≠ficas de informaci√≥n de depuraci√≥n necesitaba.  <em>(Mirando hacia el futuro: informaci√≥n de depuraci√≥n fina, pero <code>.rela</code> tuvo que agregarse)</em> En t√©rminos generales, la versi√≥n x86 enfatiz√≥ la necesidad de encajar en 64k - Espero que esto est√© de alguna manera relacionado con las caracter√≠sticas del modo real y no nos preocupe en RISC-V .  Como resultado, el objeto compartido con el PIC se recopilar√°, ya que en el original, el c√≥digo y los datos que se cargar√°n en la memoria se extraer√°n de √©l. </p><br><p>  Recopilamos ... y la compilaci√≥n recae en el primer archivo <code>reloc.c</code> , aparentemente, est√° tomado de algunos <code>ld-linux.so</code> y es responsable de apoyar la tabla de compensaci√≥n global, etc.  de acuerdo con las convenciones de llamadas para x86.  Result√≥ que requer√≠a trabajar directamente con registros usando insertos de ensamblador.  Pero estamos en RISC-V: se cre√≥ originalmente para admitir PIC de forma nativa, as√≠ que no dude en lanzar <code>reloc.c</code> .  Adem√°s, todav√≠a hab√≠a inserciones, a veces bastante largas.  Afortunadamente, estaban en el c√≥digo de prueba inmediatamente despu√©s del c√≥digo C comentado, que optimizan (a partir de ellos hice de nuevo piezas completas de c√≥digo intercambiadas por la directiva del preprocesador) o algo dependiente de la plataforma, sin el cual, en casos extremos, puedo (probablemente) hacer (como encender / apagar el cach√©, restar el CPUID, etc.).  Finalmente, hubo algunas cosas como la llamada <code>rdtsc</code> , que yo <code>rdtsc</code> , sin grandes problemas, puse en un encabezado dependiente de la plataforma y lo implement√© de acuerdo con la documentaci√≥n en RISC-V. </p><br><p>  Como resultado, obtuvimos el directorio <code>arch/i386</code> , donde se mov√≠a una gran cantidad de c√≥digo de soporte PCI, le√≠a informaci√≥n de los conjuntos de chips, definiciones espec√≠ficas de plataforma de direcciones mapeadas en memoria, etc.  Adem√°s, el principio de la funci√≥n <code>test_start</code> que <code>test_start</code> , que es el punto de entrada desde la <code>setup.S</code> al c√≥digo C. Cu√°nto tiempo, breve, pero comentando todo lo que es posible y realizando todo lo que no se puede comentar bajo RISC-V (como la <code>setup.S</code> y el c√≥digo para trabajar con puerto serie en la implementaci√≥n de SiFive), obtuve el <code>arch/riscv</code> , con el que todo estaba m√°s o menos compilado. </p><br><p>  Aqu√≠ me veo obligado a aclarar que los experimentos en s√≠ se realizaron parcialmente antes de la redacci√≥n del art√≠culo, por lo que una <em>secuencia</em> espec√≠fica <em>de</em> acciones puede contener una cierta cantidad de "ficci√≥n art√≠stica".  Sin embargo, intento al menos realizar la presentaci√≥n de tal manera que, en cualquier caso, represente uno de los caminos posibles <em>(soy programador, lo recuerdo)</em> .  Entonces, veamos c√≥mo comenzar todo. </p><br><h2 id="zapusk-na-zheleze">  Corriendo en hierro </h2><br><p>  Desde experimentos anteriores, todav√≠a tengo un "soporte" polvoriento del Raspberry Pi, conectado a la placa de depuraci√≥n.  Los cables proporcionan UART, JTAG y un adaptador con una tarjeta SD.  Un cierto procesador RV64 con un controlador DDR2 est√° cosido en la memoria de configuraci√≥n.  Como en tiempos anteriores, enciendo la "frambuesa", abro dos sesiones SSH antes, una de las cuales reenv√≠a el puerto TCP 3333 para conectar gdb a OpenOCD.  En una de las sesiones, inicio minicom para ver UART, en otra, openocd para depurar desde el host a trav√©s de JTAG.  Enciendo la alimentaci√≥n de la placa, y se ejecutan mensajes en la consola sobre c√≥mo se cargan los datos de la SD. </p><br><p>  Ahora puedes ejecutar el comando: </p><br><pre> <code class="plaintext hljs">riscv64-unknown-elf-gdb \ -ex 'target remote 127.0.0.1:3333' \ -ex 'restore /path/to/memtest_shared.bin binary 0x80010000' \ -ex 'add-symbol-file /path/to/memtest_shared 0x80010000' -ex 'set $pc=0x80010000'</code> </pre> <br><p>  Las opciones <code>-ex</code> gdb que finja que el usuario ha ingresado estos comandos desde la consola: </p><br><ul><li>  el primero establece una conexi√≥n con OpenOCD </li><li>  el segundo copia el contenido del archivo host especificado a la direcci√≥n especificada </li><li>  el tercero explica a gdb que la informaci√≥n sobre el c√≥digo fuente debe tomarse de <em>este</em> archivo, teniendo en cuenta el hecho de que se descarg√≥ en <em>esta</em> direcci√≥n (y no lo que se indica en s√≠ mismo) <br><ul><li>  nota: tomamos los caracteres del archivo ELF y cargamos el binario "en bruto" </li></ul></li><li>  finalmente, el cuarto traduce a la fuerza el puntero de comando actual a nuestro c√≥digo </li></ul><br><p>  Desafortunadamente, no todo funciona sin problemas, y aunque las l√≠neas de c√≥digo en el depurador se muestran correctamente, pero en todas las variables globales: ceros.  De hecho, si ejecutamos un comando de la forma <code>p &amp;global_var</code> en gdb, <code>p &amp;global_var</code> , vemos la direcci√≥n de acuerdo con la direcci√≥n de descarga inicial (tengo <code>0x0</code> ), que no se especifica usando <code>add-symbol-file</code> .  Como una muleta, pero una soluci√≥n muy simple, simplemente agregu√© <code>0x80010000</code> a la direcci√≥n especificada manualmente y mir√© el contenido de la memoria a trav√©s de <code>x/x 0xADDR</code> .  De hecho, ser√≠a posible indicar temporalmente la direcci√≥n de inicio correcta en el script del vinculador, que <em>en este momento</em> coincidir√° con la direcci√≥n de descarga en <em>esta configuraci√≥n de prueba</em> . </p><br><h2 id="osobennosti-relokacii-na-sovremennyh-arhitekturah">  Caracter√≠sticas de la reubicaci√≥n en arquitecturas modernas. </h2><br><p>  Bueno, c√≥mo descargar el c√≥digo de alguna manera lo descubrimos, lo comenzamos.  No funciona  La depuraci√≥n paso a paso muestra que caemos durante el funcionamiento de la funci√≥n <code>switch_to_main_stack</code> ; parece que todav√≠a est√° intentando utilizar el valor no publicado de la direcci√≥n del s√≠mbolo correspondiente a la pila de trabajo. </p><br><p>  De todos modos, el primer volumen de documentaci√≥n nos informa sobre diferentes pseudoinstrucciones y su trabajo con PIC activado y desactivado: </p><br><p><img src="https://habrastorage.org/webt/vj/7-/_u/vj7-_uqmqyqjloo1webrgpqsdc8.png" alt="Algunas pseudoinstrucciones RISC-V"></p><br><p>  Como puede ver, el principio general es que las direcciones en la memoria se cuentan a partir de la instrucci√≥n actual, con la primera agregando la parte superior del desplazamiento y la siguiente <code>add</code> pulir los bits de orden inferior.  Dif√≠cilmente ayuda declarar una variable global como </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vars</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">variables</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br><p>  Por lo tanto, tomamos la documentaci√≥n RISC-V ELF psABI con <a href="" rel="nofollow">descripciones de los tipos de reubicaciones</a> y escribimos la parte espec√≠fica de la plataforma para <code>reloc.c</code> .  Aqu√≠ debe tenerse en cuenta que el archivo original, aparentemente, fue tomado del c√≥digo multiplataforma.  All√≠, incluso en lugar de especificar una profundidad de bits espec√≠fica, se <code>ElfW(Addr)</code> macros del tipo <code>ElfW(Addr)</code> , <code>Elf32_Addr</code> a <code>Elf32_Addr</code> o <code>Elf64_Addr</code> .  Sin embargo, no en todas partes, es por eso que los agregamos donde no est√°n en el c√≥digo general (as√≠ como en el <a href="" rel="nofollow"><code>arch/riscv/reloc.inc.c</code></a> , despu√©s de todo, para RISC-V no hay ning√∫n sentido especial para estar vinculado a una profundidad de bits espec√≠fica, donde no es requerido) </p><br><p>  Como resultado, <code>switch_to_main_stack</code> comenz√≥ a pasar (no sin las instrucciones del ensamblador dependiente de la plataforma, por supuesto).  El depurador muestra variables globales todav√≠a torcidas.  Bueno, est√° bien :( </p><br><h2 id="opredelenie-oborudovaniya">  Definici√≥n de hardware </h2><br><p>  Por supuesto, para las pruebas ser√≠a posible usar constantes codificadas en lugar del c√≥digo de definici√≥n del equipo que se arroj√≥, pero para cada ensamblaje de procesador espec√≠fico, la reconstrucci√≥n de memtest es incluso demasiado costosa para los est√°ndares de mi aplicaci√≥n.  Por lo tanto, actuaremos "como adultos serios".  Afortunadamente, en RISC-V (y probablemente en la mayor√≠a de las arquitecturas modernas) es habitual que el gestor de arranque pase un puntero al <a href="https://en.wikipedia.org/wiki/Device_tree" rel="nofollow">Blob de √°rbol de dispositivos</a> , que es una versi√≥n compilada de la descripci√≥n DTS como esta: </p><br><div class="spoiler">  <b class="spoiler_title">zeowaa-1gb.dts</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/dts-v1/; / { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt gt^_^; compatible = "freechips,rocketchip-unknown-dev"; model = "freechips,rocketchip-unknown"; chosen { bootargs = "console=ttySIF0,125200 debug loglevel=7"; }; firmware { sifive,uboot = "YYYY-MM-DD"; }; L16: aliases { serial0 = &amp;L8; }; L15: cpus { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt&amp;#0;gt^_^; timebase-frequency = ^_^ltÛ¥âÄgt^_^; L5: cpu@0 { device_type = "cpu"; clock-frequency = ^_^lt&amp;#0;gt^_^; compatible = "sifive,rocket0", "riscv"; d-cache-block-size = ^_^lt gt^_^; d-cache-sets = ^_^lt@gt^_^; d-cache-size = ^_^lt·ÄÄgt^_^; d-tlb-sets = ^_^lt gt^_^; d-tlb-size = ^_^lt gt^_^; i-cache-block-size = ^_^lt gt^_^; i-cache-sets = ^_^lt@gt^_^; i-cache-size = ^_^lt·ÄÄgt^_^; i-tlb-sets = ^_^lt gt^_^; i-tlb-size = ^_^lt gt^_^; mmu-type = "riscv,sv39"; next-level-cache = &lt;&amp;L10&gt;; reg = &lt;0x0&gt;; riscv,isa = "rv64imafdc"; status = "okay"; timebase-frequency = ^_^ltÛ¥âÄgt^_^; tlb-split; L3: interrupt-controller { #interrupt-cells = ^_^lt gt^_^; compatible = "riscv,cpu-intc"; interrupt-controller; }; }; }; L10: ram@80000000 { device_type = "memory"; reg = &lt;0x0 0x80000000 0x0 0x40000000&gt;; reg-names = "mem"; }; L14: soc { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt gt^_^; compatible = "freechips,rocketchip-unknown-soc", "simple-bus"; ranges; L1: clint@2000000 { compatible = "riscv,clint0"; interrupts-extended = &lt;&amp;L3 3 &amp;L3 7&gt;; reg = &lt;0x2000000 0x10000&gt;; reg-names = "control"; }; L2: debug-controller@0 { compatible = "sifive,debug-013", "riscv,debug-013"; interrupts-extended = &lt;&amp;L3 65535&gt;; reg = &lt;0x0 0x1000&gt;; reg-names = "control"; }; L9: gpio@64002000 { #gpio-cells = ^_^lt gt^_^; #interrupt-cells = ^_^lt gt^_^; compatible = "sifive,gpio0"; gpio-controller; interrupt-controller; interrupt-parent = &lt;&amp;L0&gt;; interrupts = &lt;3 4 5 6 7 8&gt;; reg = &lt;0x64002000 0x1000&gt;; reg-names = "control"; }; L0: interrupt-controller@c000000 { #interrupt-cells = ^_^lt gt^_^; compatible = "riscv,plic0"; interrupt-controller; interrupts-extended = &lt;&amp;L3 11 &amp;L3 9&gt;; reg = &lt;0xc000000 0x4000000&gt;; reg-names = "control"; riscv,max-priority = ^_^lt gt^_^; riscv,ndev = ^_^lt gt^_^; }; L6: rom@10000 { compatible = "sifive,maskrom0"; reg = &lt;0x10000 0x2000&gt;; reg-names = "mem"; }; L8: serial@64000000 { compatible = "sifive,uart0"; interrupt-parent = &lt;&amp;L0&gt;; clocks = &lt;&amp;tlclk&gt;; interrupts = ^_^lt gt^_^; reg = &lt;0x64000000 0x1000&gt;; reg-names = "control"; }; L7: spi@64001000 { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt&amp;#0;gt^_^; compatible = "sifive,spi0"; interrupt-parent = &lt;&amp;L0&gt;; interrupts = ^_^lt gt^_^; reg = &lt;0x64001000 0x1000&gt;; clocks = &lt;&amp;tlclk&gt;; reg-names = "control"; L12: mmc@0 { compatible = "mmc-spi-slot"; disable-wp; reg = &lt;0x0&gt;; spi-max-frequency = ^_^lt gt^_^; voltage-ranges = &lt;3300 3300&gt;; }; }; tlclk: tlclk { #clock-cells = ^_^lt&amp;#0;gt^_^; clock-frequency = ^_^lt gt^_^; clock-output-names = "tlclk"; compatible = "fixed-clock"; }; }; };</code> </pre> </div></div><br><p>  Sol√≠a ‚Äã‚Äãanalizar archivos ELF, pero ahora estoy nuevamente convencido con FDT (√°rbol de dispositivos planos): estas <a href="https://github.com/devicetree-org/devicetree-specification/releases/download/v0.2/devicetree-specification-v0.2.pdf" rel="nofollow">especificaciones</a> <em>amables</em> <a href="https://github.com/devicetree-org/devicetree-specification/releases/download/v0.2/devicetree-specification-v0.2.pdf" rel="nofollow">est√°n</a> escritas por <em>personas buenas y afectuosas</em> <del>  (¬°A√∫n as√≠, ellos mismos lo analizan!) </del>  y analizar dichos archivos (al menos hasta que necesite procesar entradas no confiables) no plantea problemas particulares.  As√≠ que aqu√≠: al comienzo del archivo hay una estructura de encabezado simple que contiene el n√∫mero m√°gico <code>0xd00dfeed</code> y algunos campos m√°s.  Estamos interesados ‚Äã‚Äãen el desplazamiento del "√°rbol plano" <code>off_dt_struct</code> y la tabla de filas <code>off_dt_strings</code> .  En realidad, tambi√©n necesita procesar <code>off_mem_rsvmap</code> , que enumera las √°reas de memoria que es mejor evitar.  Todav√≠a los ignoro (no est√°n en mi tablero), pero <strong>no repito esto en casa</strong> . </p><br><p>  En principio, el procesamiento no es particularmente dif√≠cil: solo necesita caminar sobre un √°rbol plano de acuerdo con los tokens.  <em>Hay</em> tres tokens <em>clave</em> : </p><br><ul><li>  <code>FDT_BEGIN_NODE</code> : en los datos adicionales inmediatamente posteriores, aparece el nombre del elemento de sub√°rbol en forma de una cadena terminada en nulo.  Simplemente agregue el nombre a la pila </li><li>  <code>FDT_END_NODE</code> : el sub√°rbol ha terminado, elimine el elemento de la pila </li><li>  <code>FDT_PROP</code> : aqu√≠ hay un poco m√°s complicado: es seguido por una estructura, seguida de len bytes de datos adicionales.  El nombre de la "variable" se encuentra en el nombre de desplazamiento en la tabla de cadenas <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nameoff; }</code> </pre> </li></ul><br><p>  Bueno, en general, eso es todo: revisamos esta secci√≥n, sin olvidar observar la alineaci√≥n de 4 bytes.  Ah, s√≠, una mosca en la pomada: los n√∫meros en FDT est√°n en formato big endian, por lo que hacemos una funci√≥n simple </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">be32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | ((x &amp; <span class="hljs-number"><span class="hljs-number">0xff0000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((x &amp; <span class="hljs-number"><span class="hljs-number">0xff00</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); }</code> </pre> <br><p>  Como resultado, en <code>riscv_entry</code> primero que debe hacer es analizar FDT y la parte de <code>head.S</code> que es responsable de transferir el control a <code>riscv_entry</code> parece a esto </p><br><pre> <code class="plaintext hljs"> .globl startup_32 #  --    ... startup_32: lla sp, boot_stack_top mv s0, a0 # s0, s1 -- callee-saved mv s1, a1 # ...  .bss #   jal _dl_start #      mv a0, s0 mv a1, s1 j riscv_entry</code> </pre> <br><p>  En el registro <code>a0</code> nos da una identificaci√≥n de hart (hart es algo as√≠ como un flujo de hardware en la terminolog√≠a RISC-V). Todav√≠a no lo uso, tendr√≠a que resolverlo en un caso de subproceso √∫nico.  En <code>a1</code> gestor de arranque coloca un puntero al FDT.  Lo pasamos a la funci√≥n <code>void riscv_entry(ulong hartid, uint8_t *fdt_address)</code> . </p><br><p>  Ahora, con el advenimiento de la parsilka FDT en mi c√≥digo, la secuencia de carga del tablero se hizo as√≠: </p><br><ul><li>  enciende el poder </li><li>  espera la consola U-boot </li><li>  ingrese los comandos para preparar el FDT correcto.  En particular, la <code>/chosen/bootargs</code> command <code>/chosen/bootargs</code> almacena la l√≠nea de comando del n√∫cleo.  Todo lo dem√°s que tomo de FDT - rango RAM, direcci√≥n UART, ... - puede y debe dejarse como est√° <br><pre> <code class="plaintext hljs">run fdtsetup fdt set /chosen bootargs "console=ttyS0 btrace"</code> </pre> </li><li>  usando el comando <code>fdt addr</code> , encuentre la direcci√≥n de descarga FDT, si no ha buscado </li></ul><br><p>  Y desde el lado de gdb, se agrega el comando </p><br><ul><li> <code>-ex 'set $a1=0xfdtaddr'</code> </li> </ul><br><h2 id="vyvod-informacii-na-ekran">  Salida de informaci√≥n a la pantalla. </h2><br><p>  Result√≥ que, adem√°s de las inserciones de ensamblador, tambi√©n hay direcciones de memoria conocidas.  Por ejemplo <code>SCREEN_ADR</code> (exactamente as√≠, con una <code>D</code> ), que indica el √°rea correspondiente a lo que se muestra en la pantalla.  Cuando me encontr√© con esto, simplemente coloqu√© con un gesto amplio todo lo que se refiere a √©l en <code>#if HAS_SCREEN</code> , y luego lo <code>#if HAS_SCREEN</code> ciegas durante mucho tiempo.  Ya pens√© manualmente, de vez en cuando, volcar todo esto en la consola, pero luego not√© que el mismo c√≥digo generaba muchas secuencias de escape en el puerto serie.  Result√≥ que todo ya hab√≠a sido escrito antes que nosotros, solo necesita colocar las definiciones con mayor precisi√≥n, y aqu√≠ est√°, la interfaz familiar (aunque en blanco y negro) en la ventana de minicom.  (Por el momento, HAS_SCREEN no se utiliza en absoluto; acabo de iniciar la matriz <code>dummy_con</code> para cambiar el c√≥digo original como m√≠nimo). </p><br><h2 id="otladka-na-qemu">  Depuraci√≥n en QEMU </h2><br><p>  As√≠ que depur√© todo en un tablero real, y durante alg√∫n tiempo, ni siquiera a ciegas.  Pero todo se ralentiza en JTAG: ¬°horror!  Bueno, al final, todo deber√≠a funcionar en hardware real, pero ser√≠a bueno depurar en QEMU.  Despu√©s de un cierto n√∫mero de experimentos, algo result√≥ ser una muleta, pero muy similar a trabajar con una tabla: </p><br><pre> <code class="plaintext hljs">$ qemu-system-riscv64 -M help Supported machines are: none empty machine sifive_e RISC-V Board compatible with SiFive E SDK sifive_u RISC-V Board compatible with SiFive U SDK spike_v1.10 RISC-V Spike Board (Privileged ISA v1.10) (default) spike_v1.9.1 RISC-V Spike Board (Privileged ISA v1.9.1) virt RISC-V VirtIO Board (Privileged ISA v1.10)</code> </pre> <br><p>  Observamos qu√© placas QEMU est√° lista para emular.  Estoy interesado en hardware compatible con <code>sifive_u</code> . </p><br><pre> <code class="plaintext hljs">$ qemu-system-riscv64 -M sifive_u,dumpdtb -m 1g # - QEMU      on --  strace   $ ls -l on -rw-rw-r-- 1 trosinenko trosinenko 1923  19 20:14 on $ dtc -I dtb &lt; on &gt; on.dts #   $ vim on.dts #  bootargs $ dtc &lt; on.dts &gt; on.dtb &lt;stdout&gt;: Warning (clocks_property): /soc/ethernet@100900fc:clocks: cell 0 is not a phandle reference &lt;stdout&gt;: Warning (clocks_property): /soc/ethernet@100900fc:clocks: cell 1 is not a phandle reference &lt;stdout&gt;: Warning (clocks_property): /soc/ethernet@100900fc:clocks: cell 2 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/interrupt-controller@c000000:interrupts-extended: cell 0 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/interrupt-controller@c000000:interrupts-extended: cell 2 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/clint@2000000:interrupts-extended: cell 0 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/clint@2000000:interrupts-extended: cell 2 is not a phandle reference</code> </pre> <br><p>  Ahora tenemos un blob de √°rbol de dispositivo "fijo".  <strong>Sin cambiar la configuraci√≥n de la VM</strong> (¬°muletas!), Ejecute: </p><br><pre> <code class="plaintext hljs">qemu-system-riscv64 \ -M sifive_u -m 1g \ -serial stdio \ -s -S</code> </pre> <br><p>  <code>-serial stdio</code> redirige el puerto serie a la consola, porque las secuencias de escape se utilizar√°n activamente.  Las opciones <code>-s -S</code> aumentan gdbserver y crean una VM para pausar, respectivamente.  Puede descargar el c√≥digo utilizando el <code>loader</code> , pero luego debe reiniciar QEMU cada vez. </p><br><p>  Puedes conectarte usando </p><br><pre> <code class="plaintext hljs">riscv64-unknown-elf-gdb \ -ex 'target remote 127.0.0.1:1234' \ -ex 'restore /path/to/on.dtb binary 0x80100000' \ -ex 'restore /path/to/memtest_shared.bin binary 0x80020000' \ -ex 'add-symbol-file memtest_shared 0x80100000' \ -ex 'set $a1=0x80020000' \ -ex 'set $pc=0x80100000'</code> </pre> <br><p>  Como resultado, ¬°todo funciona m√°s que inteligentemente! </p><br><h2 id="obschiy-princip-raboty">  Principio general de trabajo </h2><br><p> , ,  ,   Memtest86+   <code>btrace</code> ,        ,      (  ,     QEMU): </p><br><p><img src="https://habrastorage.org/webt/su/lr/qh/sulrqhzmiona327osxqzaikijf0.png" alt="modo btrace"></p><br><p>  ,      , memtest          .     ,      (, trap):  ,   ,   QEMU - !  ¬´¬ª   <code>Illegal instruction</code>  ,    .      <code>mcause</code> (?),   ‚Äî <code>mepc</code> (?),   ‚Äî <code>mtval</code> (    ?),    . </p><br><p><img src="https://habrastorage.org/webt/lc/is/ho/lcishowkkjngpnorx_gkyav-svg.png" alt="Instrucci√≥n ilegal"></p><br><p>   ,      : </p><br><p> <strong>head.S:</strong> </p><br><pre> <code class="plaintext hljs">#       #   = 0 ---   ,   #  ,    ,     ... lla t1, _trap_entry csrw mtvec, t1 # ... _trap_entry: csrr a0, mcause csrr a1, mepc csrr a2, mtval jal riscv_trap_entry</code> </pre> <br><p>  ,        calling convention,  .        memtest,    HiFive_U-Boot,      <code>Volume II</code> : </p><br><p> <strong>arch.c:</strong> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *errors[] = { <span class="hljs-string"><span class="hljs-string">"Instruction address misaligned"</span></span>, <span class="hljs-string"><span class="hljs-string">"Instruction access fault"</span></span>, <span class="hljs-string"><span class="hljs-string">"Illegal instruction"</span></span>, <span class="hljs-string"><span class="hljs-string">"Breakpoint"</span></span>, <span class="hljs-string"><span class="hljs-string">"Load address misaligned"</span></span>, <span class="hljs-string"><span class="hljs-string">"Load access fault"</span></span>, <span class="hljs-string"><span class="hljs-string">"Store/AMO address misaligned"</span></span>, <span class="hljs-string"><span class="hljs-string">"Store/AMO access fault"</span></span>, ^_^quot quot^_^, ^_^quot quot^_^, ^_^quot quot^_^, ^_^quot quot^_^, <span class="hljs-string"><span class="hljs-string">"Instruction page fault"</span></span>, <span class="hljs-string"><span class="hljs-string">"Load page fault"</span></span>, ^_^quot quot^_^, <span class="hljs-string"><span class="hljs-string">"Store/AMO page fault"</span></span>, }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">riscv_trap_entry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ulong cause, ulong epc, ulong tval)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; cprint(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"EXCP: "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cause &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(errors) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(errors[<span class="hljs-number"><span class="hljs-number">0</span></span>])) { cprint(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, errors[cause]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { itoa(buf, cause); cprint(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, buf); } cprint(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"PC: "</span></span>); hprint3(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, epc, <span class="hljs-number"><span class="hljs-number">8</span></span>); cprint(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Addr: "</span></span>); hprint3(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, tval, <span class="hljs-number"><span class="hljs-number">8</span></span>); HALT(); }</code> </pre> <br><p>        ‚Äî    ¬´ ¬ª   .   ,   ¬´¬ª    ,  ,      ,  . </p><br><p>         :     .       ,  memtest  :    : ¬´       ,   ,    .        ¬ª.    :  <code>do_test</code>   <code>main.c</code>    2,   (    ),       ‚Äî    ¬´¬ª ,    memtest.       ,    <code>run_at</code> ,    memtest  <code>_start</code>  <code>_end</code>    (   ¬´¬ª  ),  -     spinlock'        <code>goto *addr;</code>        . ,  ,      ¬´¬ª    ,    ¬´¬ª. </p><br><p>      ,    <strong> </strong>  <code>bss</code>    ‚Äî    <code>_dl_start</code>  ,   <code>riscv_entry</code>  ,   trap entry. ,   :     L1I-,   .    ,     <code>fence.i</code> . </p><br><p>   ,  Memtest86+ ‚Äî ,         <code>barrier_s</code>    .       ,          . ,   ,       . </p><br><h2 id="podvodnye-kamni">   </h2><br><p>    ,   :   .   :           .    <em></em> : ,  -       (Own Address,     )   .     ,     ,   .       . -    .   ,   x86 , ,    <code>uint64_t</code>   <code>0x80000002</code>       . ,     : <a href="https://stackoverflow.com/questions/12491578/whats-the-actual-effect-of-successful-unaligned-accesses-on-x86" rel="nofollow"> </a> ,   load/store  x86   ,     ‚Äî .    ,    QEMU    ,  ¬´  ,      ¬ª. </p><br><p> ,     ,  <em>  </em> ‚Äî   unaligned access  .. </p><br><p> ,   ,     RocketChip,   ‚Äî QEMU,   ,  ,   RocketChip ‚Äî unaligned access trap,  QEMU  ¬´  ¬ª. <br>   ¬´misaligned¬ª            ,   </p><br><blockquote> Changed description of misaligned load and store behavior. The specification now allows visible misaligned address traps in execution environment interfaces, rather than just mandating invisible handling of misaligned loads and stores in user mode. Also, now allows access exceptions to be reported for misaligned accesses (including atomics) that should not be emulated. </blockquote><p>  , ,  ‚Äî   ,  user-mode code   ,             .     .   , ,   .   ,       ‚Äî -   machine mode    . ,     <code>rdtsc</code> (x86)  <code>rdtime</code> (rv64),   trap,     . , ,                memory-mapped . </p><br><p>    :      ,  <em> </em>   <code>low_test_addr</code> (       ),  ,   fdt   .   ,  ,  <code>low_test_addr</code>   ,  ,      2   <code>high_test_adr</code>    ‚Ä¶ ,     ‚Äî   : <code>head.S</code>       <code>initial_load_addr</code> ,    <code>riscv_entry</code>    <code>move_to_correct_addr</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move_to_correct_addr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> cur_start = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;_start; <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> cur_end = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;_end; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur_start == low_test_addr || cur_start == high_test_adr) { <span class="hljs-comment"><span class="hljs-comment">//  ,     return; } if (cur_start == initial_load_addr &amp;&amp; (cur_start - low_test_addr) &lt; (cur_end - cur_start) ) { //   " ":   , //           //     ,    ,   //     ... serial_echo_print("FIRST STARTUP RELOCATION...\n"); void *temp_addr = (((uintptr_t)&amp;_end &gt;&gt; 12) + 1) &lt;&lt; 12; run_at(temp_addr, 0); } else { // ,    --- ,  . serial_echo_print("FINAL STARTUP RELOCATION...\n"); run_at(low_test_addr, 0); } }</span></span></code> </pre> <br><p> ,     ‚Äî   ,  memtest ,  RAM  -   .  RISC-V    ,        <code>v-&gt;plim_lower</code> . </p><br><p>     ,   ¬´¬ª ,    -,   ‚Äî  <code>test.c</code>    <code>ulong</code> (  <code>unsigneg long</code> ),   32- x86   <code>uint32_t</code> ,    ¬´ 64 ¬ª   <code>uint64_t</code> .       ¬´!!! Good: ffffffff Real: ffffffff Bad bits: 00000000¬ª.   ?       - -1,  32    1.   ,         ,        0‚Ä¶  ,     : ,  <code>ulong</code>      ( <code>uint32_t</code> ),          ( <code>uintptr_t</code> ). ,       . ,     <code>uint64_t</code>   4. RISC-V  <em></em>  ,       C, ,    ‚Äî    UB. <del>     memtest  UBSan. </del>  ,  ,  UBSan   trap-on-error        JTAG. </p><br><h2 id="upakovyvaem-dlya-zagruzchika">    </h2><br><p> ,  memtest -  ,    ,          U-Boot. </p><br><p>       :    <code>mkimage</code>   U-Boot   <em>  Linux</em> : </p><br><pre> <code class="plaintext hljs">mkimage -A riscv -O linux -T kernel -C none \ -a 0x80000000 -e 0x80000000 \ -n memtest -d memtest.bin memtest.uboot</code> </pre> <br><p>      SD-      </p><br><pre> <code class="plaintext hljs">run mmcsetup; run fdtsetup; fdt set /chosen bootargs "console=ttyS0"; fatload mmc 0:1 82000000 memtest.uboot; bootm fdt; bootm 82000000 - ${fdtaddr}</code> </pre> <br><p> (   ,   <code>run</code>     ‚Äî        ). </p><br><p>      :       FDT: <code>0xbffb7c80</code> . ,  :    <code>ffffffff</code> ,     .     ,         (     ),    :   HiFive_U-Boot      : </p><br><pre> <code class="cpp hljs"> theKernel(machid, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)images-&gt;ft_addr);</code> </pre> <br><p>    ,     </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*theKernel)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arch, uint params);</code> </pre> <br><p>  ,     , ,  ,  32        ,     <code>head.S</code> : </p><br><pre> <code class="plaintext hljs"> li t0, 0xffffffffL and a1, a1, t0</code> </pre> <br><h2 id="promezhutochnyy-itog">   </h2><br><p> ,  , - ,  ,     ,  : </p><br><ul><li>     x86.       ‚Äî       review         <strong>   </strong> </li><li>   SMP   RISC-V </li><li>        <code>arch/</code> -  </li><li>     <code>test.c</code>  RISC-V (      <code>-O0</code> !) </li></ul></div></div><p>Source: <a href="https://habr.com/ru/post/484026/">https://habr.com/ru/post/484026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484012/index.html">Agilice el proceso de escritura en un bloc de notas</a></li>
<li><a href="../484014/index.html">10 mitos SEO para dejar atr√°s en 2020</a></li>
<li><a href="../484016/index.html">Los fundamentos del aprendizaje profundo en el ejemplo de autoencoder de depuraci√≥n, n√∫mero de parte 1</a></li>
<li><a href="../484018/index.html">Lado t√©cnico de la navegaci√≥n.</a></li>
<li><a href="../484020/index.html">¬øA qui√©n est√°s tratando de impresionar con tus plazos?</a></li>
<li><a href="../484028/index.html">Horseshoe Bend - tableta convertible con pantalla plegable</a></li>
<li><a href="../484034/index.html">Implementaci√≥n del esquema de trabajo del almacenamiento dirigido de bienes basado en la unidad de contabilidad de almac√©n 1C Integrated Automation 2</a></li>
<li><a href="../484036/index.html">Nuevo grupo industrial crea un est√°ndar universal para hogares inteligentes</a></li>
<li><a href="../484046/index.html">Comprobaci√≥n de Emby con PVS-Studio</a></li>
<li><a href="../484048/index.html">PHP y expresiones regulares: lo b√°sico para principiantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>