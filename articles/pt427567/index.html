<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèº üë≥üèø üßìüèΩ Mapas hexagonais no Unity: ciclo da √°gua, eros√£o, biomas, mapa cil√≠ndrico üë¶üèΩ üèáüèæ üë©üèº‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes 1-3: malha, cores e altura das c√©lulas 

 Partes 4-7: solavancos, rios e estradas 

 Pe√ßas 8-11: √°gua, formas terrestres e muralhas 

 Pe√ßas 12...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas hexagonais no Unity: ciclo da √°gua, eros√£o, biomas, mapa cil√≠ndrico</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427567/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 1-3: malha, cores e altura das c√©lulas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 4-7: solavancos, rios e estradas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pe√ßas 8-11: √°gua, formas terrestres e muralhas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pe√ßas 12-15: salvar e carregar, texturas, dist√¢ncias</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 16-19: encontrando o caminho, esquadr√µes de jogadores, anima√ß√µes</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 20-23: Nevoeiro da Guerra, Pesquisa de Mapas, Gera√ß√£o de Procedimentos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 24-27: ciclo da √°gua, eros√£o, biomas, mapa cil√≠ndrico</a> <br><br><h1>  Parte 24: regi√µes e eros√£o </h1><br><ul><li>  Adicione uma borda de √°gua ao redor do mapa. </li><li>  Dividimos o mapa em v√°rias regi√µes. </li><li>  Usamos a eros√£o para cortar fal√©sias. </li><li>  N√≥s movemos a terra para suavizar o al√≠vio. </li></ul><br>  Na parte anterior, lan√ßamos as bases para a gera√ß√£o de mapas procedurais.  Desta vez, limitaremos os locais de poss√≠vel ocorr√™ncia de terra e agiremos sobre ela com eros√£o. <br><br>  Este tutorial foi criado no Unity 2017.1.0. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/6a5/30c/5ac6a530cef3718f9031abe862364093.jpg"></div><br>  <i>Separe e alise a terra.</i> <br><a name="habracut"></a><br><h2>  Borda do mapa </h2><br>  Como aumentamos as √°reas de terra aleatoriamente, pode acontecer que a terra toque a borda do mapa.  Isso pode ser indesej√°vel.  O mapa de √°gua limitada cont√©m uma barreira natural que impede que os jogadores se aproximem da borda.  Portanto, seria bom se proib√≠ssemos que a terra subisse acima do n√≠vel da √°gua perto da borda do mapa. <br><br><h3>  Tamanho da borda </h3><br>  Qu√£o perto o terreno deve estar da borda do mapa?  N√£o h√° resposta certa para essa pergunta, portanto, tornaremos esse par√¢metro personaliz√°vel.  Adicionaremos dois controles deslizantes ao componente <code>HexMapGenerator</code> , um para bordas ao longo das bordas ao longo do eixo X e outro para bordas ao longo do eixo Z. Assim, podemos usar uma borda mais larga em uma das dimens√µes ou at√© criar uma borda em apenas uma dimens√£o.  Vamos usar um intervalo de 0 a 10 com um valor padr√£o de 5. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderX = <span class="hljs-number"><span class="hljs-number">5</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/8ab/c74/6948abc743e881596bdea5656e562943.png"></div><br>  <i>Controles deslizantes de bordas.</i> <br><br><h3>  Limitamos os centros de √°reas terrestres </h3><br>  Sem bordas, todas as c√©lulas s√£o v√°lidas.  Quando existem limites, as coordenadas de deslocamento m√≠nimas permitidas aumentam e as coordenadas m√°ximas permitidas diminuem.  Como para gerar os gr√°ficos, precisaremos conhecer o intervalo permitido, vamos control√°-lo usando quatro campos inteiros. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xMin, xMax, zMin, zMax;</code> </pre> <br>  Inicializamos as restri√ß√µes no <code>GenerateMap</code> antes de criar o sushi.  Usamos esses valores como par√¢metros para chamadas <code>Random.Range</code> , para que os altos sejam realmente excepcionais.  Sem uma borda, eles s√£o iguais ao n√∫mero de c√©lulas de medi√ß√£o, portanto, n√£o menos 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } xMin = mapBorderX; xMax = x - mapBorderX; zMin = mapBorderZ; zMax = z - mapBorderZ; CreateLand(); ‚Ä¶ }</code> </pre> <br>  N√£o proibiremos estritamente a apar√™ncia de terras al√©m da fronteira, porque isso criaria bordas bem cortadas.  Em vez disso, limitaremos apenas as c√©lulas usadas para iniciar a gera√ß√£o de plotagens.  Ou seja, os centros aproximados dos locais ser√£o limitados, mas partes dos locais poder√£o ir al√©m da √°rea de fronteira.  Isso pode ser feito modificando <code>GetRandomCell</code> para selecionar uma c√©lula no intervalo de compensa√ß√µes permitidas. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return grid.GetCell(Random.Range(0, cellCount)); return grid.GetCell(Random.Range(xMin, xMax), Random.Range(zMin, zMax)); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/bbf/24b/7a8bbf24b1d46d9b97e8e9c01652fdfd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/0cf/aa2/a310cfaa2bec1cbe019a08c14218c7fd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f1/799/f50/7f1799f5058c0d1e435bfc3c42133b9c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/c4b/1b7/93ac4b1b771eaa896b6c494b69c18b92.jpg"></div><br>  <i>As bordas do mapa s√£o 0 √ó 0, 5 √ó 5, 10 √ó 10 e 0 √ó 10.</i> <br><br>  Quando todos os par√¢metros do mapa s√£o definidos com seus valores padr√£o, uma borda do tamanho 5 protege de maneira confi√°vel a borda do mapa do contato com a terra.  No entanto, isso n√£o √© garantido.  √Äs vezes, a terra pode chegar perto da borda e, √†s vezes, toc√°-la em v√°rios lugares. <br><br>  A probabilidade de a terra cruzar toda a borda depende do tamanho da borda e do tamanho m√°ximo do site.  Sem hesitar, as se√ß√µes permanecem hex√°gonos.  Hex√°gono completo com raio <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.049ex" height="1.455ex" viewBox="0 -520.7 451.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> r </script>  cont√©m <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.32ex" height="2.539ex" viewBox="0 -935.7 5304.3 1093.4" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="1628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-33" x="2628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="3129" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="3803" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="4803" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 3r ^ 2 + 3r + 1 </script>  c√©lulas.  Se houver hex√°gonos com um raio igual ao tamanho da borda, eles poder√£o cruz√°-lo.  Um hex√°gono completo com um raio de 5 cont√©m 91 c√©lulas.  Como, por padr√£o, o m√°ximo √© de 100 c√©lulas por se√ß√£o, isso significa que o terreno poder√° estabelecer uma ponte entre 5 c√©lulas, especialmente se houver vibra√ß√µes.  Para impedir que isso aconte√ßa, reduza o tamanho m√°ximo da plotagem ou aumente o tamanho da borda. <br><br><div class="spoiler">  <b class="spoiler_title">Como √© derivada a f√≥rmula para o n√∫mero de c√©lulas na regi√£o hexagonal?</b> <div class="spoiler_text">  Com um raio de 0, estamos lidando com uma √∫nica c√©lula.  Veio de 1. Com um raio de 1 em torno do centro, existem seis c√©lulas adicionais, ou seja <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.165ex" height="2.211ex" viewBox="0 -772.3 2223.9 952" role="img" focusable="false" style="vertical-align: -0.417ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="722" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="1723" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> 6 + 1 </script>  .  Essas seis c√©lulas podem ser consideradas as extremidades de seis tri√¢ngulos tocando o centro.  Com um raio de 2, uma segunda linha √© adicionada a esses tri√¢ngulos, ou seja, mais duas c√©lulas s√£o obtidas no tri√¢ngulo e, no total, <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.14ex" height="2.762ex" viewBox="0 -831.5 5226.9 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="3113" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="3725" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="4726" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> 6 (1 + 2) + 1 </script>  .  Com um raio de 3, uma terceira linha √© adicionada, ou seja, mais tr√™s c√©lulas por tri√¢ngulo e no total <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.143ex" height="2.762ex" viewBox="0 -831.5 6950.3 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="3336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-33" x="4336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="4837" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="5449" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="6449" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-5"> 6 (1 + 2 + 3) + 1 </script>  .  E assim por diante  Ou seja, em termos gerais, a f√≥rmula parece <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mi>o</mi><mi>m</mi><msub><mi>a</mi><mo stretchy=&quot;false&quot;>(</mo></msub><mi>i</mi><mo>=</mo><mn>1</mn><msup><mo stretchy=&quot;false&quot;>)</mo><mi>r</mi></msup><mi>i</mi><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="74.787ex" height="3.312ex" viewBox="0 -950 32199.9 1426" role="img" focusable="false" style="vertical-align: -1.106ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-73" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-6F" x="1359" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-6D" x="1845" y="0"></use><g transform="translate(2723,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="748" y="-264"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-69" x="3628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-3D" x="4251" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="5307" y="0"></use><g transform="translate(5808,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-69" x="6617" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="6962" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="7574" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="8575" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-3D" x="9353" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-36" x="10409" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="10910" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="11299" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="11689" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="12140" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="12530" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="13203" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="14204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="14705" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="15094" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2F" x="15484" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-32" x="15984" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="16485" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="17096" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="18097" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-3D" x="18875" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-33" x="19932" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="20432" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="20884" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="21273" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="21947" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="22948" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="23448" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="24060" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="25061" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-3D" x="25839" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-33" x="26895" y="0"></use><g transform="translate(27396,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="28523" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-33" x="29524" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="30024" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="30698" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="31699" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mi>s</mi><mi>o</mi><mi>m</mi><msub><mi>a</mi><mo stretchy="false">(</mo></msub><mi>i</mi><mo>=</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>r</mi></msup><mi>i</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mi>r</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-6"> 6 (soma_ (i = 1) ^ r i) +1 = 6 ((r (r + 1)) / 2) +1 = 3r (r + 1) + 1 = 3r ^ 2 + 3r + 1 </script>  . </div></div><br>  Para ver isso mais claramente, podemos definir o tamanho da borda como 200. Como um hex√°gono completo com um raio de 8 cont√©m 217 c√©lulas, √© prov√°vel que o terreno toque a borda do mapa.  Pelo menos se voc√™ usar o valor padr√£o do tamanho da borda (5).  Se voc√™ aumentar a borda para 10, a probabilidade diminuir√° bastante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/75d/eb0/74b75deb060d9bdae2f74c1db4de287e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffa/7ce/e96/ffa7cee967f81ba9fe4ddc6718519d9a.jpg"></div><br>  <i>O terreno tem um tamanho constante de 200, as bordas do mapa s√£o 5 e 10.</i> <br><br><h3>  Pangea </h3><br>  Observe que, quando voc√™ aumenta a borda do mapa e mant√©m a mesma porcentagem de terra, for√ßamos a terra a formar uma √°rea menor.  Como resultado disso, √© muito prov√°vel que um mapa grande, por padr√£o, crie uma √∫nica grande massa de terra - o supercontinente Pangea - possivelmente com v√°rias pequenas ilhas.  Com um aumento no tamanho da fronteira, a probabilidade disso aumenta e, em certos valores, estamos quase garantidos para obter um supercontinente.  No entanto, quando a porcentagem de terra √© muito grande, a maioria das √°reas dispon√≠veis √© preenchida e, como resultado, obtemos uma massa quase retangular de terra.  Para impedir que isso aconte√ßa, voc√™ precisa reduzir a porcentagem de terra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/d84/209/e1bd8420915ccc74cd3470409b9a4236.jpg"></div><br>  <i>Sushi de 40% com uma borda de cart√£o de 10.</i> <br><br><div class="spoiler">  <b class="spoiler_title">De onde veio o nome Pangea?</b> <div class="spoiler_text">  Esse era o nome do √∫ltimo supercontinente conhecido que existia na Terra h√° muitos anos.  O nome √© composto pelas palavras gregas pan e Gaia, que significam algo como "toda a natureza" ou "toda a terra". </div></div><br><br><h3>  Protegemos de cart√µes imposs√≠veis </h3><br>  Geramos a quantidade certa de terra simplesmente continuando a elevar a terra at√© atingirmos a massa desejada.  Isso funciona porque, mais cedo ou mais tarde, elevaremos cada c√©lula no n√≠vel da √°gua.  No entanto, ao usar a borda do mapa, n√£o podemos alcan√ßar todas as c√©lulas.  Quando uma porcentagem muito alta de terra √© necess√°ria, isso leva a in√∫meras tentativas e falhas do gerador para elevar mais terra e fica preso em um ciclo sem fim.  Nesse caso, o aplicativo ir√° congelar, mas isso n√£o deve acontecer. <br><br>  N√£o podemos encontrar com seguran√ßa configura√ß√µes imposs√≠veis com anteced√™ncia, mas podemos nos proteger de ciclos intermin√°veis.  Simplesmente rastrearemos o n√∫mero de ciclos executados no <code>CreateLand</code> .  Se houver muitas itera√ß√µes, provavelmente estamos travados e devemos parar. <br><br>  Para um mapa grande, mil itera√ß√µes parecem aceit√°veis ‚Äã‚Äãe dez mil itera√ß√µes j√° parecem absurdas.  Ent√£o, vamos usar esse valor como um ponto de termina√ß√£o. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// while (landBudget &gt; 0) { for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); ‚Ä¶ } }</span></span></code> </pre> <br>  Se obtivermos um mapa danificado, a execu√ß√£o de 10.000 itera√ß√µes n√£o levar√° muito tempo, porque muitas c√©lulas atingir√£o rapidamente a altura m√°xima, o que impedir√° o crescimento de novas √°reas. <br><br>  Mesmo depois de quebrar o ciclo, ainda temos o mapa certo.  Ele simplesmente n√£o tem a quantidade certa de sushi e n√£o parecer√° muito interessante.  Vamos exibir uma notifica√ß√£o sobre isso no console, informando o terreno restante que n√£o conseguimos gastar. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab5/87f/f4f/ab587ff4f560fe6c1c0d7d5a547ae2b7.jpg"></div><br>  <i>95% das terras com uma borda de cart√£o de 10 n√£o podiam gastar a quantia inteira.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Por que um cart√£o com falha ainda tem varia√ß√£o?</b> <div class="spoiler_text">  O litoral tem variabilidade, porque quando as alturas dentro da √°rea de cria√ß√£o se tornam muito altas, novas √°reas n√£o permitem que elas cres√ßam para fora.  O mesmo princ√≠pio n√£o permite que as parcelas se transformem em pequenas √°reas de terra, at√© atingirem a altura m√°xima e simplesmente desaparecerem.  Al√©m disso, a variabilidade aumenta ao diminuir as parcelas. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Particionando um cart√£o </h2><br>  Agora que temos a borda do mapa, basicamente dividimos o mapa em duas regi√µes separadas: a regi√£o da borda e a regi√£o em que os gr√°ficos foram criados.  Como apenas a regi√£o de cria√ß√£o √© importante para n√≥s, podemos considerar esse caso uma situa√ß√£o com uma regi√£o.  A regi√£o simplesmente n√£o cobre o mapa inteiro.  Mas se isso for imposs√≠vel, nada nos impede de dividir o mapa em v√°rias regi√µes desconectadas da cria√ß√£o de terras.  Isso permitir√° que as massas de terra se formem independentemente uma da outra, designando diferentes continentes. <br><br><h3>  Regi√£o do mapa </h3><br>  Vamos come√ßar descrevendo uma regi√£o do mapa como uma estrutura.  Isso simplificar√° nosso trabalho com v√°rias regi√µes.  Vamos criar uma estrutura <code>MapRegion</code> para isso, que simplesmente cont√©m os campos de borda da regi√£o.  Como n√£o usaremos essa estrutura fora do <code>HexMapGenerator</code> , podemos defini-la dentro desta classe como uma estrutura interna privada.  Em seguida, quatro campos inteiros podem ser substitu√≠dos por um campo <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int xMin, xMax, zMin, zMax; struct MapRegion { public int xMin, xMax, zMin, zMax; } MapRegion region;</span></span></code> </pre> <br>  Para que tudo funcione, precisamos adicionar o prefixo da <code>region.</code> aos campos m√≠nimo-m√°ximo no <code>GenerateMap</code> <code>region.</code>  . <br><br><pre> <code class="cs hljs"> region.xMin = mapBorderX; region.xMax = x - mapBorderX; region.zMin = mapBorderZ; region.zMax = z - mapBorderZ;</code> </pre> <br>  E tamb√©m no <code>GetRandomCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br><h3>  V√°rias regi√µes </h3><br>  Para oferecer suporte a v√°rias regi√µes, substitua um campo <code>MapRegion</code> lista de regi√µes. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// MapRegion region; List&lt;MapRegion&gt; regions;</span></span></code> </pre> <br>  Nesse momento, seria bom adicionar um m√©todo separado para criar regi√µes.  Ele deve criar a lista desejada ou limp√°-la, se ela j√° existir.  Depois disso, ele determinar√° uma regi√£o, como fizemos anteriormente, e a adicionar√° √† lista. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRegions</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regions == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { regions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MapRegion&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { regions.Clear(); } MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br>  Vamos chamar esse m√©todo no <code>GenerateMap</code> e n√£o criaremos a regi√£o diretamente. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// region.xMin = mapBorderX; // region.xMax = x - mapBorderX; // region.zMin = mapBorderZ; // region.zMax = z - mapBorderZ; CreateRegions(); CreateLand();</span></span></code> </pre> <br>  Para que <code>GetRandomCell</code> possa trabalhar com uma regi√£o arbitr√°ria, forne√ßa o par√¢metro <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MapRegion region</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br>  Agora os <code>SinkTerrain</code> e <code>SinkTerrain</code> devem passar a regi√£o correspondente para <code>GetRandomCell</code> .  Para fazer isso, cada um deles tamb√©m precisa de um par√¢metro de regi√£o. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); ‚Ä¶ }</code> </pre> <br>  O m√©todo <code>CreateLand</code> deve determinar para cada regi√£o aumentar ou diminuir as se√ß√µes.  Para equilibrar a terra entre as regi√µes, simplesmente percorreremos repetidamente a lista de regi√µes do ciclo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget, region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br>  No entanto, ainda precisamos fazer a redu√ß√£o das parcelas uniformemente distribu√≠das.  Isso pode ser feito ao decidir para todas as regi√µes se deve omiti-las. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if (Random.value &lt; sinkProbability) { if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } }</span></span></code> </pre> <br>  Finalmente, para usar exatamente toda a quantidade de terra, precisamos interromper o processo assim que a quantidade chegar a zero.  Isso pode acontecer em qualquer est√°gio do ciclo da regi√£o.  Portanto, movemos a verifica√ß√£o de soma zero para o loop interno.  De fato, s√≥ podemos realizar essa verifica√ß√£o depois de levantar o terreno, porque ao diminuir, o valor nunca √© gasto.  Se terminarmos, podemos sair imediatamente do m√©todo <code>CreateLand</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { for (int guard = 0; guard &lt; 10000; guard++) { bool sink = Random.value &lt; sinkProbability; for (int i = 0; i &lt; regions.Count; i++) { MapRegion region = regions[i]; int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); if (landBudget == 0) { return; } } } }</span></span></code> </pre> <br><h3>  Duas regi√µes </h3><br>  Embora agora tenhamos o apoio de v√°rias regi√µes, ainda pedimos apenas uma.  Vamos alterar o <code>CreateRegions</code> para que ele divida o mapa ao meio verticalmente.  Para fazer isso, <code>xMax</code> pela metade o valor <code>xMax</code> da regi√£o adicionada.  Em seguida, usamos o mesmo valor para <code>xMin</code> e novamente usamos o valor original para <code>xMax</code> , usando-o como a segunda regi√£o. <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br>  A gera√ß√£o de cart√µes nesta fase n√£o far√° nenhuma diferen√ßa.  Embora tenhamos identificado duas regi√µes, elas ocupam a mesma regi√£o que uma regi√£o antiga.  Para separ√°-los, voc√™ precisa deixar um espa√ßo vazio entre eles.  Isso pode ser feito adicionando um controle deslizante √† borda da regi√£o, usando o mesmo intervalo e valor padr√£o das bordas do mapa. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionBorder = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/cd2/cd0/9ffcd2cd0f4068caf622e433c503715d.png"></div><br>  <i>Controle deslizante de borda da regi√£o.</i> <br><br>  Como a terra pode ser formada em ambos os lados do espa√ßo entre as regi√µes, a probabilidade de criar pontes de terra nas bordas do mapa aumentar√°.  Para evitar isso, usamos a borda da regi√£o para definir uma zona livre de terra entre a linha divis√≥ria e a regi√£o na qual as parcelas podem come√ßar.  Isso significa que a dist√¢ncia entre regi√µes vizinhas √© duas vezes maior que o tamanho da fronteira da regi√£o. <br><br>  Para aplicar esse limite de regi√£o, subtraia-o do <code>xMax</code> primeira regi√£o e adicione a segunda regi√£o ao <code>xMin</code> . <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/1f6/476/1e51f6476894662d55f7ca9748dc7fa5.jpg"></div><br>  <i>O mapa √© dividido verticalmente em duas regi√µes.</i> <br><br>  Com as configura√ß√µes padr√£o, ser√£o criadas duas regi√µes visivelmente separadas; no entanto, como no caso de uma regi√£o e uma grande borda do mapa, n√£o temos garantia de receber exatamente duas massas de terra.  Na maioria das vezes, ser√£o dois grandes continentes, possivelmente com v√°rias ilhas.  Mas, √†s vezes, duas ou mais ilhas grandes podem ser criadas em uma regi√£o.  E, √†s vezes, dois continentes podem ser conectados por um istmo. <br><br>  Obviamente, tamb√©m podemos dividir o mapa horizontalmente, alterando as abordagens para medir X e Z. Vamos escolher aleatoriamente uma das duas orienta√ß√µes poss√≠veis. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/970/c91/f23970c91cdd9c539ebdc8c7fdbba05f.jpg"></div><br>  <i>Mapa dividido horizontalmente em duas regi√µes.</i> <br><br>  Como usamos um mapa amplo, regi√µes mais amplas e finas ser√£o criadas com separa√ß√£o horizontal.  Como resultado, √© mais prov√°vel que essas regi√µes formem v√°rias massas de terra divididas. <br><br><h3>  Quatro regi√µes </h3><br>  Vamos personalizar o n√∫mero de regi√µes, criar suporte de 1 a 4 regi√µes. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 4)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionCount = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/918/49e/2a4/91849e2a4ffe6091b8d4fdf0d78b0c45.png"></div><br>  <i>Controle deslizante para o n√∫mero de regi√µes.</i> <br><br>  Podemos usar a <code>switch</code> para selecionar a execu√ß√£o do c√≥digo de regi√£o correspondente.  Come√ßamos repetindo o c√≥digo de uma regi√£o, que ser√° usada por padr√£o, e deixamos o c√≥digo de duas regi√µes para o caso 2. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Qual √© a instru√ß√£o switch?</b> <div class="spoiler_text">  Essa √© uma alternativa para escrever uma sequ√™ncia de instru√ß√µes if-else-if-else.  A op√ß√£o √© aplicada √† vari√°vel e os r√≥tulos s√£o usados ‚Äã‚Äãpara indicar qual c√≥digo precisa ser executado.  H√° tamb√©m um r√≥tulo <code>default</code> , que √© usado como o √∫ltimo bloco <code>else</code> .  Cada op√ß√£o deve terminar com uma declara√ß√£o de <code>break</code> ou uma <code>return</code> . <br><br>  Para manter o bloco de <code>switch</code> leg√≠vel, geralmente √© melhor manter todos os casos curtos, idealmente com uma √∫nica instru√ß√£o ou chamada de m√©todo.  N√£o o farei como um exemplo de c√≥digo de regi√£o, mas se voc√™ deseja criar regi√µes mais interessantes, recomendo que voc√™ use m√©todos separados.  Por exemplo: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: CreateOneRegion(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: CreateTwoRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: CreateThreeRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: CreateFourRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> </div></div><br>  Tr√™s regi√µes s√£o semelhantes a duas, apenas ter√ßos s√£o usados ‚Äã‚Äãem vez da metade.  Nesse caso, a divis√£o horizontal criar√° regi√µes muito estreitas; portanto, criamos suporte apenas para a divis√£o vertical.  Observe que, como resultado, dobramos a √°rea de borda da regi√£o, portanto, o espa√ßo para a cria√ß√£o de novas se√ß√µes √© menor do que no caso de duas regi√µes. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/2e7/cc8/2342e7cc8cb524f4f9db803d5359a78e.jpg"></div><br>  <i>Tr√™s regi√µes</i> <br><br>  √â poss√≠vel criar quatro regi√µes combinando a separa√ß√£o horizontal e vertical e adicionando uma regi√£o a cada canto do mapa. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/551/b72/a0c/551b72a0ca2f12a5636828faa4c3febc.jpg"></div><br>  <i>Quatro regi√µes.</i> <br><br>  A abordagem usada aqui √© a maneira mais simples de dividir um mapa.  Ele gera aproximadamente as mesmas regi√µes por massa de terra e sua variabilidade √© controlada por outros par√¢metros de gera√ß√£o de mapas.  No entanto, sempre ser√° bastante √≥bvio que o cart√£o foi dividido em linhas retas.  Quanto mais controle precisamos, menos org√¢nico ser√° o resultado.  Portanto, isso √© normal se voc√™ precisar de regi√µes aproximadamente iguais para a jogabilidade.  Mas se voc√™ precisar da terra mais variada e ilimitada, precisar√° faz√™-la com a ajuda de uma regi√£o. <br><br>  Al√©m disso, existem outras maneiras de dividir o mapa.  N√£o podemos nos limitar apenas a linhas retas.  Nem precisamos usar regi√µes do mesmo tamanho, al√©m de cobrir o mapa inteiro com elas.  N√≥s podemos deixar buracos.  Voc√™ tamb√©m pode permitir interse√ß√µes de regi√µes ou alterar a distribui√ß√£o de terras entre regi√µes.  Voc√™ pode at√© definir seus pr√≥prios par√¢metros de gerador para cada regi√£o (embora isso seja mais complicado), por exemplo, para ter um grande continente e um arquip√©lago no mapa. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Eros√£o </h2><br>  At√© agora, todas as cartas que geramos pareciam rudes e quebradas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um al√≠vio real pode ser assim, mas com o tempo se torna cada vez mais suave, suas partes afiadas ficam embotadas devido √† eros√£o. </font><font style="vertical-align: inherit;">Para melhorar os mapas, podemos aplicar esse processo de eros√£o. </font><font style="vertical-align: inherit;">Faremos isso depois de criar terrenos acidentados, em um m√©todo separado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); SetTerrainType(); ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Percentagem de eros√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quanto mais o tempo passa, mais eros√£o aparece. </font><font style="vertical-align: inherit;">Portanto, queremos que a eros√£o n√£o seja permanente, mas personaliz√°vel. </font><font style="vertical-align: inherit;">No m√≠nimo, a eros√£o √© zero, o que corresponde aos mapas criados anteriormente. </font><font style="vertical-align: inherit;">Quando a eros√£o m√°xima √© abrangente, ou seja, a aplica√ß√£o posterior das for√ßas de eros√£o n√£o mudar√° mais o terreno. </font><font style="vertical-align: inherit;">Ou seja, o par√¢metro erosion deve ser uma porcentagem de 0 a 100 e, por padr√£o, usaremos 50.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erosionPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/efe/e5e/c4eefee5e18aeee36f16e6aee98a27fe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle deslizante de eros√£o.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Procurar c√©lulas destruidoras de eros√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A eros√£o torna o al√≠vio mais suave. No nosso caso, as √∫nicas partes afiadas s√£o as fal√©sias. Portanto, eles ser√£o o alvo do processo de eros√£o. Se existir um penhasco, a eros√£o deve reduzi-lo at√© que finalmente se transforme em um declive. N√£o suavizaremos as encostas, porque isso levar√° a um terreno chato. Para fazer isso, precisamos determinar quais c√©lulas est√£o no topo dos penhascos e diminuir sua altura. Estas ser√£o c√©lulas propensas √† eros√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos criar um m√©todo que determine se uma c√©lula pode ser propensa a eros√£o. </font><font style="vertical-align: inherit;">Ele determina isso verificando os vizinhos da c√©lula at√© encontrar uma diferen√ßa de altura suficientemente grande. </font><font style="vertical-align: inherit;">Como as fal√©sias exigem uma diferen√ßa de pelo menos um ou dois n√≠veis de altura, a c√©lula est√° sujeita a eros√£o se um ou mais de seus vizinhos estiver a pelo menos dois passos abaixo dela. </font><font style="vertical-align: inherit;">Se n√£o houver tal vizinho, a c√©lula n√£o poder√° sofrer eros√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsErodible</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar esse m√©todo </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para percorrer todas as c√©lulas e gravar todas as c√©lulas propensas √† eros√£o em uma lista tempor√°ria.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(cell)) { erodibleCells.Add(cell); } } ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de conhecer o n√∫mero total de c√©lulas propensas √† eros√£o, podemos usar a porcentagem de eros√£o para determinar o n√∫mero de c√©lulas propensas √† eros√£o restantes. </font><font style="vertical-align: inherit;">Por exemplo, se a porcentagem for 50, precisamos danificar as c√©lulas at√© que metade da quantidade original permane√ßa. </font><font style="vertical-align: inherit;">Se a porcentagem for 100, n√£o pararemos at√© destruirmos todas as c√©lulas propensas √† eros√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o devemos considerar apenas as c√©lulas propensas √† eros√£o da terra?</font></font></b> <div class="spoiler_text">     .    ,       ,     . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Redu√ß√£o de c√©lulas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos come√ßar com uma abordagem ing√™nua e supor que uma simples redu√ß√£o na altura das c√©lulas destru√≠das pela eros√£o deixar√° de ser mais propensa √† eros√£o. </font><font style="vertical-align: inherit;">Se isso fosse verdade, poder√≠amos simplesmente pegar c√©lulas aleat√≥rias da lista, reduzir sua altura e remov√™-las da lista. </font><font style="vertical-align: inherit;">Repetir√≠amos essa opera√ß√£o at√© atingirmos o n√∫mero desejado de c√©lulas suscet√≠veis √† eros√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (erodibleCells.Count &gt; targetErodibleCount) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, erodibleCells.Count); HexCell cell = erodibleCells[index]; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; erodibleCells.Remove(cell); } ListPool&lt;HexCell&gt;.Add(erodibleCells);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para impedir a pesquisa necess√°ria </font></font><code>erodibleCells.Remove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, substituiremos a c√©lula atual por √∫ltimo na lista e excluiremos o √∫ltimo elemento. </font><font style="vertical-align: inherit;">Ainda n√£o nos importamos com o pedido deles.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// erodibleCells.Remove(cell); erodibleCells[index] = erodibleCells[erodibleCells.Count - 1]; erodibleCells.RemoveAt(erodibleCells.Count - 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/050/66c/50e05066c444e6854c622b865fde2726.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/fca/6b4/14dfca6b41ce23cdeb3e5fc4d5307eba.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diminui√ß√£o ing√™nua de 0% e 100% de c√©lulas propensas √† eros√£o, mapa de sementes 1957632474.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rastreamento de eros√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossa abordagem ing√™nua nos permite aplicar eros√£o, mas n√£o no grau certo. </font><font style="vertical-align: inherit;">Isso acontece porque a c√©lula ap√≥s uma diminui√ß√£o na altura ainda pode permanecer propensa √† eros√£o. </font><font style="vertical-align: inherit;">Portanto, removeremos uma c√©lula da lista somente quando n√£o estiver mais sujeita a eros√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/0a9/779/2810a9779b056865ad4490f9b00fa50f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% de eros√£o, mantendo as c√©lulas propensas a eros√£o na lista. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, temos uma eros√£o muito mais forte, mas ao usar 100%, ainda n√£o nos livramos de todos os penhascos. </font><font style="vertical-align: inherit;">A raz√£o √© que, depois de reduzir a altura da c√©lula, um de seus vizinhos pode se tornar propenso a eros√£o. </font><font style="vertical-align: inherit;">Portanto, como resultado, podemos ter mais c√©lulas propensas √† eros√£o do que originalmente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de baixar a c√©lula, precisamos verificar todos os seus vizinhos. </font><font style="vertical-align: inherit;">Se agora eles est√£o propensos √† eros√£o, mas ainda n√£o est√£o na lista, √© necess√°rio adicion√°-los l√°.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/894/ed5/b2a894ed5274286b00046050963388f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as c√©lulas erodidas s√£o omitidas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Economizamos muita terra </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora o processo de eros√£o pode continuar at√© que todos os penhascos desapare√ßam. Isso afeta muito a terra. A maior parte da massa de terra desapareceu e temos muito menos do que a porcentagem de terra necess√°ria. Aconteceu porque estamos removendo terras do mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A verdadeira eros√£o n√£o destr√≥i a mat√©ria. Ela pega de um lugar e coloca em outro lugar. N√≥s podemos fazer o mesmo. Com uma diminui√ß√£o em uma c√©lula, devemos criar um de seus vizinhos. De fato, um n√≠vel de altura √© transferido para uma c√©lula inferior. Isso economiza a quantidade total de alturas do mapa, enquanto a suaviza.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para isso, precisamos decidir para onde transferir os produtos erosivos. </font><font style="vertical-align: inherit;">Este ser√° o nosso objetivo de eros√£o. </font><font style="vertical-align: inherit;">Vamos criar um m√©todo para determinar o ponto de destino de uma c√©lula a ser corro√≠da. </font><font style="vertical-align: inherit;">Como essa c√©lula cont√©m uma interrup√ß√£o, seria l√≥gico selecionar a c√©lula localizada nessa interrup√ß√£o como destino. </font><font style="vertical-align: inherit;">Mas uma c√©lula propensa √† eros√£o pode ter v√°rias quebras, portanto, verificamos todos os vizinhos e colocamos todos os candidatos em uma lista tempor√°ria, e depois escolhemos um deles aleatoriamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetErosionTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; candidates = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { candidates.Add(neighbor); } } HexCell target = candidates[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, candidates.Count)]; ListPool&lt;HexCell&gt;.Add(candidates); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√≥s definimos a c√©lula alvo imediatamente ap√≥s selecionar a c√©lula de eros√£o. </font><font style="vertical-align: inherit;">Ent√£o diminu√≠mos e aumentamos a altura das c√©lulas imediatamente uma ap√≥s a outra. </font><font style="vertical-align: inherit;">Nesse caso, a pr√≥pria c√©lula-alvo pode se tornar suscet√≠vel √† eros√£o, mas essa situa√ß√£o √© resolvida quando verificamos os vizinhos da nova c√©lula erodida.</font></font><br><br><pre> <code class="cs hljs"> HexCell cell = erodibleCells[index]; HexCell targetCell = GetErosionTarget(cell); cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; targetCell.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como elevamos a c√©lula alvo, parte dos vizinhos dessa c√©lula pode n√£o estar mais sujeita a eros√£o. </font><font style="vertical-align: inherit;">√â necess√°rio contorn√°-los e verificar se eles est√£o propensos √† eros√£o. </font><font style="vertical-align: inherit;">Caso contr√°rio, mas eles est√£o na lista, voc√™ precisar√° remov√™-los.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d71/84f/0b4/d7184f0b4a2dd34853b56e0024ef2b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% de eros√£o, mantendo a massa da terra. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, a eros√£o pode suavizar muito melhor o terreno, diminuindo algumas √°reas e elevando outras. </font><font style="vertical-align: inherit;">Como resultado, a massa de terra pode aumentar e diminuir. </font><font style="vertical-align: inherit;">Isso pode alterar a porcentagem de terra em v√°rios por cento em uma dire√ß√£o ou outra, mas raramente ocorrem desvios s√©rios. </font><font style="vertical-align: inherit;">Ou seja, quanto mais eros√£o aplicarmos, menos controle teremos sobre a porcentagem resultante de terra.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eros√£o acelerada </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora n√£o precisemos realmente nos preocupar com a efic√°cia do algoritmo de eros√£o, podemos fazer melhorias simples nele. </font><font style="vertical-align: inherit;">Primeiro, observe que verificamos explicitamente se a c√©lula que erodimos pode ser erodida. </font><font style="vertical-align: inherit;">Caso contr√°rio, ent√£o essencialmente o removemos da lista. </font><font style="vertical-align: inherit;">Portanto, voc√™ pode pular a verifica√ß√£o dessa c√©lula ao percorrer os vizinhos da c√©lula de destino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, precis√°vamos verificar os vizinhos da c√©lula de destino apenas quando havia um intervalo entre eles, mas agora isso n√£o √© necess√°rio. </font><font style="vertical-align: inherit;">Isso s√≥ acontece quando o vizinho est√° agora um passo mais alto que a c√©lula de destino. </font><font style="vertical-align: inherit;">Nesse caso, √© garantido que o vizinho esteja na lista; portanto, n√£o precisamos verificar isso, ou seja, podemos pular a pesquisa desnecess√°ria.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; neighbor.Elevation == targetCell.Elevation + <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !IsErodible(neighbor) <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em terceiro lugar, podemos usar um truque semelhante ao verificar os vizinhos de uma c√©lula propensa a eros√£o. </font><font style="vertical-align: inherit;">Se agora existe um penhasco entre eles, o vizinho est√° propenso √† eros√£o. </font><font style="vertical-align: inherit;">Para descobrir, n√£o precisamos ligar </font></font><code>IsErodible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor.Elevation == cell.Elevation + <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, ainda precisamos verificar se a c√©lula alvo √© suscet√≠vel √† eros√£o, mas o ciclo mostrado acima n√£o est√° mais fazendo isso. </font><font style="vertical-align: inherit;">Portanto, executamos isso explicitamente para a c√©lula de destino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(targetCell) &amp;&amp; !erodibleCells.Contains(targetCell)) { erodibleCells.Add(targetCell); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos aplicar a eros√£o com rapidez suficiente e com a porcentagem desejada em rela√ß√£o ao n√∫mero inicial de fal√©sias geradas. </font><font style="vertical-align: inherit;">Observe que, devido ao fato de termos mudado levemente o local onde a c√©lula de destino √© adicionada √† lista propensa √† eros√£o, o resultado foi ligeiramente alterado em rela√ß√£o ao resultado antes das otimiza√ß√µes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a0d/71e/4a6a0d71eea3d1ef119b2f4f984a9b99.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28d/979/289/28d9792899367fdccb50f36b79801935.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7af/921/6af/7af9216af64111dbe0c15898db4560ce.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31b/7d9/ae5/31b7d9ae505297269bbd5442fdff17c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25%, 50%, 75% e 100% de eros√£o. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe tamb√©m que, apesar da forma alterada da costa, a topologia n√£o mudou fundamentalmente. </font><font style="vertical-align: inherit;">As massas de terra geralmente permanecem conectadas ou separadas. </font><font style="vertical-align: inherit;">Somente pequenas ilhas podem se afogar completamente. </font><font style="vertical-align: inherit;">Os detalhes do relevo s√£o suavizados, mas as formas gerais permanecem as mesmas. </font><font style="vertical-align: inherit;">Uma articula√ß√£o estreita pode desaparecer ou crescer um pouco. </font><font style="vertical-align: inherit;">Um pequeno espa√ßo pode preencher ou expandir um pouco. </font><font style="vertical-align: inherit;">Portanto, a eros√£o n√£o ficar√° fortemente unida √†s regi√µes divididas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cd/c53/824/2cdc53824832438c924e2832d9759b06.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quatro regi√µes completamente erodidas ainda permanecem separadas. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 25: O Ciclo da √Ågua </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exibir dados brutos do mapa. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≥s formamos um clima de c√©lulas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crie uma simula√ß√£o parcial do ciclo da √°gua. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta parte, adicionaremos umidade √† terra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este tutorial foi criado no Unity 2017.3.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/fbe/dae/2aefbedae7b2c65cd86bbd2b4ccc3050.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos o ciclo da √°gua para determinar os biomas.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As nuvens </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© esse momento, o algoritmo de gera√ß√£o de mapas alterava apenas a altura da c√©lula. </font><font style="vertical-align: inherit;">A maior diferen√ßa entre as c√©lulas era se elas estavam acima ou abaixo da √°gua. </font><font style="vertical-align: inherit;">Embora possamos definir diferentes tipos de terreno, essa √© apenas uma visualiza√ß√£o simples da altura. </font><font style="vertical-align: inherit;">Ser√° melhor especificar os tipos de al√≠vio, dado o clima local. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O clima da Terra √© um sistema muito complexo. </font><font style="vertical-align: inherit;">Felizmente, n√£o precisamos criar simula√ß√µes clim√°ticas realistas. </font><font style="vertical-align: inherit;">Vamos precisar de algo que pare√ßa natural o suficiente. </font><font style="vertical-align: inherit;">O aspecto mais importante do clima √© o ciclo da √°gua, porque a flora e a fauna precisam de √°gua l√≠quida para sobreviver. </font><font style="vertical-align: inherit;">A temperatura tamb√©m √© muito importante, mas, por enquanto, nos concentramos na √°gua, essencialmente deixando a temperatura global constante e alterando apenas a umidade.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ciclo da √°gua descreve o movimento da √°gua no meio ambiente. </font><font style="vertical-align: inherit;">Simplificando, as lagoas evaporam, o que leva √† cria√ß√£o de nuvens que chovem, que novamente fluem para as lagoas. </font><font style="vertical-align: inherit;">Existem muitos outros aspectos no sistema, mas a simula√ß√£o dessas etapas j√° pode ser suficiente para criar uma distribui√ß√£o natural da √°gua no mapa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualiza√ß√£o de dados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de entrarmos nesta simula√ß√£o, ser√° √∫til ver diretamente os dados relevantes. </font><font style="vertical-align: inherit;">Para fazer isso, mudaremos o shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">N√≥s adicionamos uma propriedade selecion√°vel a ele, que pode ser alternada para o modo de visualiza√ß√£o de dados, que exibe dados brutos do mapa em vez das texturas de al√≠vio usuais. </font><font style="vertical-align: inherit;">Isso pode ser implementado usando uma propriedade float com um atributo comut√°vel que define a palavra-chave. </font><font style="vertical-align: inherit;">Por esse motivo, ele aparecer√° no inspetor de materiais como um sinalizador que controla a defini√ß√£o de uma palavra-chave. </font><font style="vertical-align: inherit;">O nome da propriedade em si n√£o √© importante, estamos interessados ‚Äã‚Äãapenas na palavra-chave. </font><font style="vertical-align: inherit;">Estamos usando </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHOW_MAP_DATA</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [Toggle(SHOW_MAP_DATA)] _ShowMapData (<span class="hljs-string"><span class="hljs-string">"Show Map Data"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/32b/3e0/45232b3e0a72da1320457492c006613c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alterne para exibir dados do mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione uma fun√ß√£o de sombreador para ativar o suporte a palavras-chave.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ GRID_ON #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> shader_feature SHOW_MAP_DATA</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos fazer com que ele exiba um √∫nico flutuador, como √© o caso dos demais dados de al√≠vio. </font><font style="vertical-align: inherit;">Para implementar isso, adicionaremos um </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo </font><font style="vertical-align: inherit;">√† estrutura </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando a palavra-chave for definida.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">struct</span></span> Input { <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> color : COLOR; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> worldPos; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> terrain; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> visibility; <span class="hljs-comment"><span class="hljs-comment">#if defined(SHOW_MAP_DATA) float mapData; #endif };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No programa de v√©rtices, usamos o canal Z dessas c√©lulas para preencher </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como sempre interpolado entre as c√©lulas.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inout appdata_full v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Input data</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(SHOW_MAP_DATA) data.mapData = cell0.z * v.color.x + cell1.z * v.color.y + cell2.z * v.color.z; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando voc√™ precisar exibir dados da c√©lula, use-os diretamente como um fragmento de albedo em vez da cor usual. </font><font style="vertical-align: inherit;">Multiplique-o pela grade para que a grade ainda esteja ativada ao renderizar os dados.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { ‚Ä¶ o.Albedo = c.rgb * grid * _Color * explored; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(SHOW_MAP_DATA) o.Albedo = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.mapData * grid; #endif ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para realmente transferir dados para um sombreador. </font><font style="vertical-align: inherit;">precisamos adicionar ao </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo que escreve algo no canal de dados de textura azul. </font><font style="vertical-align: inherit;">Os dados s√£o um √∫nico valor flutuante limitado a 0‚Äì1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">255f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span>); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, essa decis√£o afeta o sistema de pesquisa. </font><font style="vertical-align: inherit;">Um valor de dados de canal azul 255 √© usado para indicar que a visibilidade da c√©lula est√° em transi√ß√£o. </font><font style="vertical-align: inherit;">Para que esse sistema continue funcionando, precisamos usar o valor de byte 254 como m√°ximo. Observe que o movimento do destacamento apagar√° todos os dados do cart√£o, mas isso nos conv√©m, porque eles s√£o usados ‚Äã‚Äãpara a gera√ß√£o de cart√µes de depura√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">254f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">254</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um m√©todo com o mesmo nome e em </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele transferir√° a solicita√ß√£o para seus dados de sombreador.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { ShaderData.SetMapData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para verificar a opera√ß√£o do c√≥digo, altere-o </font></font><code>HexMapGenerator.SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele defina os dados de cada c√©lula do mapa. </font><font style="vertical-align: inherit;">Vamos visualizar a altura convertida de n√∫mero inteiro para flutuar no intervalo de 0 a 1. </font><font style="vertical-align: inherit;">Isso √© feito subtraindo a altura m√≠nima da altura da c√©lula, seguida pela divis√£o da altura m√°xima menos a m√≠nima. </font><font style="vertical-align: inherit;">Vamos fazer o ponto flutuante da divis√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ cell.SetMapData( (cell.Elevation - elevationMinimum) / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(elevationMaximum - elevationMinimum) ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos alternar entre o terreno normal e a visualiza√ß√£o de dados usando a </font><font style="vertical-align: inherit;">caixa de sele√ß√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mostrar dados do mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do ativo de material do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/577/473/f28/577473f28d08f986124e6459a13a3714.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/c8a/85a/d60c8a85ae315fd509a4f6451629d8dc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa 1208905299, terreno normal e visualiza√ß√£o de alturas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cria√ß√£o clim√°tica </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para simular o clima, precisamos rastrear dados clim√°ticos. </font><font style="vertical-align: inherit;">Como o mapa consiste em c√©lulas discretas, cada uma delas tem seu pr√≥prio clima local. </font><font style="vertical-align: inherit;">Crie uma estrutura </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para armazenar todos os dados relevantes. </font><font style="vertical-align: inherit;">Obviamente, voc√™ pode adicionar dados √†s pr√≥prias c√©lulas, mas n√≥s os usaremos apenas ao gerar o mapa. </font><font style="vertical-align: inherit;">Portanto, vamos salv√°-los separadamente. </font><font style="vertical-align: inherit;">Isso significa que podemos definir essa estrutura internamente </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como </font></font><code>MapRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Come√ßaremos rastreando apenas as nuvens, que podem ser implementadas usando um √∫nico campo flutuante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione uma lista para rastrear dados clim√°ticos para todas as c√©lulas. </font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora precisamos de um m√©todo para criar um mapa clim√°tico. </font><font style="vertical-align: inherit;">Deve come√ßar limpando a lista de zonas clim√°ticas e, em seguida, adicione um elemento para cada c√©lula. </font><font style="vertical-align: inherit;">Os dados clim√°ticos iniciais s√£o simplesmente zero, isso pode ser alcan√ßado usando um construtor padr√£o </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O clima deve ser criado ap√≥s a exposi√ß√£o √† eros√£o da terra antes de definir os tipos de relevo. </font><font style="vertical-align: inherit;">Na realidade, a eros√£o √© causada principalmente pelo movimento do ar e da √°gua, que fazem parte do clima, mas n√£o simularemos isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); SetTerrainType(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Altere </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que possamos ver dados da nuvem em vez da altura da c√©lula. </font><font style="vertical-align: inherit;">Inicialmente, parecer√° um cart√£o preto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ cell.SetMapData(climate[i].clouds); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mudan√ßa clim√°tica </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O primeiro passo na simula√ß√£o clim√°tica √© a evapora√ß√£o. </font><font style="vertical-align: inherit;">Quanta √°gua deve evaporar? </font><font style="vertical-align: inherit;">Vamos controlar esse valor usando o controle deslizante. </font><font style="vertical-align: inherit;">Um valor 0 significa que n√£o h√° evapora√ß√£o, 1 - evapora√ß√£o m√°xima. </font><font style="vertical-align: inherit;">Por padr√£o, usamos 0,5.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6af/d8e/ae8/6afd8eae8a1bbb6be361c29d32cc5b99.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle deslizante de evapora√ß√£o. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos criar outro m√©todo especificamente para moldar o clima de uma c√©lula. </font><font style="vertical-align: inherit;">Fornecemos o √≠ndice de c√©lulas como par√¢metro e o usamos para obter a c√©lula correspondente e seus dados clim√°ticos. </font><font style="vertical-align: inherit;">Se a c√©lula estiver submersa, estamos lidando com um reservat√≥rio que deve evaporar. </font><font style="vertical-align: inherit;">Transformamos imediatamente o vapor em nuvens (ignorando os pontos de condensa√ß√£o e condensa√ß√£o), para adicionar diretamente a evapora√ß√£o ao valor das nuvens celulares. </font><font style="vertical-align: inherit;">Quando terminar, copie os dados clim√°ticos de volta para a lista.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvolveClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { HexCell cell = grid.GetCell(cellIndex); ClimateData cellClimate = climate[cellIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } climate[cellIndex] = cellClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chame esse m√©todo para cada c√©lula </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas isso n√£o √© suficiente. </font><font style="vertical-align: inherit;">Para criar uma simula√ß√£o complexa, precisamos moldar o clima das c√©lulas v√°rias vezes. </font><font style="vertical-align: inherit;">Quanto mais fazemos isso, melhor ser√° o resultado. </font><font style="vertical-align: inherit;">Vamos apenas escolher um valor constante. </font><font style="vertical-align: inherit;">Eu uso 40 ciclos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como embora apenas aumentemos o valor das nuvens acima das c√©lulas inundadas com √°gua, como resultado, obtemos terra preta e reservat√≥rios brancos. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/e1c/5dc/3e7e1c5dc9ce75197a94e8ffcd6d8275.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evapora√ß√£o sobre a √°gua.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Espalhamento de nuvens </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As nuvens n√£o est√£o constantemente em um s√≥ lugar, especialmente quando mais e mais √°gua evapora. </font><font style="vertical-align: inherit;">A diferen√ßa de press√£o faz o ar se mover, que se manifesta na forma de vento, que tamb√©m faz as nuvens se moverem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se n√£o houver dire√ß√£o dominante do vento, em m√©dia as nuvens das c√©lulas se dispersar√£o uniformemente em todas as dire√ß√µes, aparecendo nas c√©lulas vizinhas. </font><font style="vertical-align: inherit;">Ao gerar novas nuvens no pr√≥ximo ciclo, vamos distribuir todas as nuvens da c√©lula em seus vizinhos. </font><font style="vertical-align: inherit;">Ou seja, cada vizinho recebe um sexto das nuvens de c√©lulas, ap√≥s o que h√° uma diminui√ß√£o local para zero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>; climate[cellIndex] = cellClimate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para realmente adicionar nuvens aos seus vizinhos, voc√™ precisa contorn√°-los em loop, obter os dados clim√°ticos, aumentar o valor das nuvens e copi√°-los de volta para a lista. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; climate[neighbor.Index] = neighborClimate; } cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6a/0e3/437/e6a0e34379d984582c020fde8f1db546.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuvens dispersas.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isso cria um mapa quase branco, porque a cada ciclo as c√©lulas subaqu√°ticas adicionam mais e mais nuvens ao clima global. Ap√≥s o primeiro ciclo, as c√©lulas terrestres pr√≥ximas √† √°gua tamb√©m ter√£o nuvens que precisam ser dispersas. Esse processo continua at√© que a maior parte do mapa esteja coberta de nuvens. No caso do mapa 1208905299 com os par√¢metros padr√£o, apenas a parte interna da grande massa de terra no nordeste permaneceu completamente descoberta.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que lagoas podem gerar um n√∫mero infinito de nuvens. </font><font style="vertical-align: inherit;">O n√≠vel da √°gua n√£o faz parte da simula√ß√£o clim√°tica. </font><font style="vertical-align: inherit;">Na realidade, os reservat√≥rios s√£o preservados apenas porque a √°gua flui de volta para eles aproximadamente √† taxa de evapora√ß√£o. </font><font style="vertical-align: inherit;">Ou seja, simulamos apenas um ciclo parcial da √°gua. </font><font style="vertical-align: inherit;">Isso √© normal, mas precisamos entender que quanto mais a simula√ß√£o ocorre, mais √°gua √© adicionada ao clima. </font><font style="vertical-align: inherit;">At√© agora, a perda de √°gua ocorre apenas nas bordas do mapa, onde nuvens dispersas s√£o perdidas devido √† falta de vizinhos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode ver a perda de √°gua na parte superior do mapa, especialmente nas c√©lulas no canto superior direito. </font><font style="vertical-align: inherit;">Na √∫ltima c√©lula, n√£o h√° nuvens, porque continua sendo a √∫ltima em que o clima √© formado. </font><font style="vertical-align: inherit;">Ela ainda n√£o recebeu nuvens de um vizinho.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O clima de todas as c√©lulas n√£o deveria se formar em paralelo?</font></font></b> <div class="spoiler_text"> ,        .    -              ,         .   40    . -      ,       . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Precipita√ß√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √°gua n√£o fica fria para sempre. Em algum momento, ela deve cair no ch√£o novamente. Isso geralmente acontece na forma de chuva, mas √†s vezes pode ser neve, granizo ou neve molhada. Tudo isso √© geralmente chamado de precipita√ß√£o. A magnitude e a taxa de desaparecimento das nuvens variam muito, mas apenas usamos uma taxa global de precipita√ß√£o personalizada. Um valor 0 significa que n√£o h√° precipita√ß√£o, um valor 1 significa que todas as nuvens desaparecem instantaneamente. O valor padr√£o √© 0,25. Isso significa que em cada ciclo um quarto das nuvens desaparecer√°.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitationFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/762/37d/f9076237d0673301af34c32f5cd6688a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle deslizante do coeficiente de precipita√ß√£o. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simularemos a precipita√ß√£o ap√≥s a evapora√ß√£o e antes da dispers√£o das nuvens. </font><font style="vertical-align: inherit;">Isso significa que parte da √°gua evaporada dos reservat√≥rios precipita imediatamente, diminuindo o n√∫mero de nuvens dispersas. </font><font style="vertical-align: inherit;">Sobre a terra, a precipita√ß√£o levar√° ao desaparecimento das nuvens.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e3/f11/46a/4e3f1146a761d1525e6a9349ff715bbb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuvens desaparecendo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, quando destru√≠mos 25% das nuvens em cada ciclo, a terra fica novamente quase negra. </font><font style="vertical-align: inherit;">As nuvens conseguem se mover para o interior apenas alguns passos, ap√≥s o que se tornam invis√≠veis. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Umidade </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora a chuva destrua as nuvens, elas n√£o devem remover a √°gua do clima. </font><font style="vertical-align: inherit;">Depois de cair no ch√£o, a √°gua √© salva, apenas em um estado diferente. </font><font style="vertical-align: inherit;">Pode existir de v√°rias formas, que geralmente consideraremos umidade.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rastreamento de umidade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos melhorar o modelo clim√°tico rastreando duas condi√ß√µes da √°gua: nuvens e umidade. </font><font style="vertical-align: inherit;">Para conseguir isso, adicionar um </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo </font></font><code>moisture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds, moisture; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em sua forma mais generalizada, a evapora√ß√£o √© o processo de convers√£o de umidade em nuvens, pelo menos em nosso modelo clim√°tico simples. </font><font style="vertical-align: inherit;">Isso significa que a evapora√ß√£o n√£o deve ser um valor constante, mas outro fator. </font><font style="vertical-align: inherit;">Portanto, realizamos a renomea√ß√£o de refatora√ß√£o </font></font><code>evaporation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>evaporationFactor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporationFactor = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando a c√©lula est√° submersa, simplesmente anunciamos que o n√≠vel de umidade √© 1. Isso significa que a evapora√ß√£o √© igual ao coeficiente de evapora√ß√£o. </font><font style="vertical-align: inherit;">Mas agora tamb√©m podemos obter evapora√ß√£o das c√©lulas de sushi. </font><font style="vertical-align: inherit;">Nesse caso, precisamos calcular a evapora√ß√£o, subtra√≠-la da umidade e adicionar o resultado √†s nuvens. </font><font style="vertical-align: inherit;">Depois disso, a precipita√ß√£o √© adicionada √† umidade.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; cellClimate.clouds += evaporationFactor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = cellClimate.moisture * evaporationFactor; cellClimate.moisture -= evaporation; cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como as nuvens agora s√£o suportadas pela evapora√ß√£o acima da terra, podemos mov√™-las para o interior. </font><font style="vertical-align: inherit;">Agora a maior parte da terra ficou cinza.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/94f/c71/a0b94fc71728a012254059d760bf47f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuvens com evapora√ß√£o de umidade. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos alter√°-lo </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para exibir umidade em vez de nuvens, porque vamos us√°-lo para determinar os tipos de relevo.</font></font><br><br><pre> <code class="cs hljs"> cell.SetMapData(climate[i].moisture);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cf/78f/d30/3cf78fd3099cf1b3a75befb8ebb0893d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exibi√ß√£o de umidade. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse ponto, a umidade parece bastante semelhante √†s nuvens (exceto que todas as c√©lulas subaqu√°ticas s√£o brancas), mas isso mudar√° em breve.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escoamento de chuva </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A evapora√ß√£o n√£o √© a √∫nica maneira de a umidade sair da c√©lula. </font><font style="vertical-align: inherit;">O ciclo da √°gua nos diz que a maior parte da umidade adicionada √† terra acaba de alguma forma na √°gua. </font><font style="vertical-align: inherit;">O processo mais not√°vel √© o fluxo de √°gua sobre a terra sob a influ√™ncia da gravidade. </font><font style="vertical-align: inherit;">N√£o simularemos rios reais, mas usaremos um coeficiente de escoamento de chuva personalizado. </font><font style="vertical-align: inherit;">Isso indicar√° a porcentagem de √°gua drenada para as √°reas mais baixas. </font><font style="vertical-align: inherit;">Vamos usar como padr√£o o estoque ser√° igual a 25%.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoffFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c85/e81/648/c85e8164833b60299f80bba99c11be81.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drene o controle deslizante.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s n√£o vamos gerar rios?</font></font></b> <div class="spoiler_text">          . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O escoamento da √°gua atua como uma dispers√£o de nuvens, mas com tr√™s diferen√ßas. Em primeiro lugar, nem toda a umidade √© removida da c√©lula. Em segundo lugar, ele carrega umidade, n√£o nuvens. Em terceiro lugar, desce, ou seja, apenas para vizinhos com uma altura mais baixa. O coeficiente de escoamento superficial descreve a quantidade de umidade que sairia da c√©lula se todos os vizinhos fossem mais baixos, mas geralmente s√£o menores. Isso significa que reduziremos a umidade da c√©lula somente quando encontrarmos um vizinho abaixo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a25/c41/00b/a25c4100bde5139415ebbf0a45068d0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drenagem da √°gua a uma altura mais baixa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, temos uma distribui√ß√£o mais diversificada de umidade, porque c√©lulas altas transmitem sua umidade para as mais baixas. </font><font style="vertical-align: inherit;">Tamb√©m vemos muito menos umidade nas c√©lulas costeiras, porque elas drenam a umidade para dentro das c√©lulas subaqu√°ticas. </font><font style="vertical-align: inherit;">Para enfraquecer esse efeito, tamb√©m precisamos usar o n√≠vel da √°gua para determinar se a c√©lula est√° mais baixa, ou seja, medir a altura aparente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/ee9/64d/651ee964da5a422bfaa94f27609a5dcd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use a altura vis√≠vel.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Infiltra√ß√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √°gua n√£o apenas flui para baixo, mas tamb√©m se espalha atrav√©s da topografia nivelada e √© absorvida pela terra adjacente aos corpos d'√°gua. </font><font style="vertical-align: inherit;">Esse efeito pode ter pouco efeito, mas √© √∫til para suavizar a distribui√ß√£o de umidade, ent√£o vamos adicion√°-lo √† simula√ß√£o. </font><font style="vertical-align: inherit;">Vamos criar seu pr√≥prio coeficiente personalizado, por padr√£o igual a 0,125.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepageFactor = <span class="hljs-number"><span class="hljs-number">0.125f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/855/b73/495855b73d4601ab3de00b3561285491.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle deslizante de vazamento. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A infiltra√ß√£o √© semelhante a um dreno, exceto que √© usada quando o vizinho tem a mesma altura vis√≠vel que a pr√≥pria c√©lula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepage = cellClimate.moisture * seepageFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= seepage; neighborClimate.moisture += seepage; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/7b2/b01/d397b2b01ad8e71137b9e5fa03fcf5a5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicionado um pouco de vazamento. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombras de chuva </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora j√° tenhamos criado uma simula√ß√£o digna do ciclo da √°gua, ele n√£o parece muito interessante, porque n√£o possui sombras de chuva, que demonstram claramente as diferen√ßas clim√°ticas. </font><font style="vertical-align: inherit;">Sombras de chuva s√£o √°reas em que h√° uma falta significativa de chuva em compara√ß√£o com as √°reas vizinhas. </font><font style="vertical-align: inherit;">Tais √°reas existem porque as montanhas impedem que as nuvens os alcancem. </font><font style="vertical-align: inherit;">Sua cria√ß√£o requer altas montanhas e uma dire√ß√£o dominante do vento.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O vento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos come√ßar adicionando uma dire√ß√£o dominante do vento √† simula√ß√£o. </font><font style="vertical-align: inherit;">Embora as dire√ß√µes dominantes do vento variem bastante na superf√≠cie da Terra, gerenciaremos com uma dire√ß√£o global personaliz√°vel do vento. </font><font style="vertical-align: inherit;">Vamos usar o noroeste por padr√£o. </font><font style="vertical-align: inherit;">Al√©m disso, vamos ajustar a for√ßa do vento de 1 a 10 com um valor padr√£o de 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection windDirection = HexDirection.NW; [Range(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> windStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/4a1/49c/f324a149c360bbfde72e98b4877afb37.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A dire√ß√£o e for√ßa do vento. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A for√ßa do vento dominante √© expressa em rela√ß√£o √† dispers√£o total das nuvens. </font><font style="vertical-align: inherit;">Se a for√ßa do vento for 1, a dispers√£o ser√° a mesma em todas as dire√ß√µes. </font><font style="vertical-align: inherit;">Quando √© 2, a dispers√£o √© duas mais alta na dire√ß√£o do vento do que em outras dire√ß√µes, e assim por diante. </font><font style="vertical-align: inherit;">Podemos fazer isso alterando o divisor na f√≥rmula de dispers√£o de nuvens. </font><font style="vertical-align: inherit;">Em vez de seis, ser√° igual a cinco mais energia e√≥lica.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, a dire√ß√£o do vento determina a dire√ß√£o a partir da qual o vento sopra. </font><font style="vertical-align: inherit;">Portanto, precisamos usar a dire√ß√£o oposta como a dire√ß√£o principal da dispers√£o.</font></font><br><br><pre> <code class="cs hljs"> HexDirection mainDispersalDirection = windDirection.Opposite(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos verificar se o vizinho est√° na dire√ß√£o principal da dispers√£o. </font><font style="vertical-align: inherit;">Nesse caso, devemos multiplicar a dispers√£o das nuvens pela for√ßa do vento.</font></font><br><br><pre> <code class="cs hljs"> ClimateData neighborClimate = climate[neighbor.Index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == mainDispersalDirection) { neighborClimate.clouds += cloudDispersal * windStrength; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { neighborClimate.clouds += cloudDispersal; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/874/2d5/e7e8742d53033ee4ee89f68e60871426.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vento noroeste, for√ßa 4.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O vento dominante acrescenta direcionalidade √† distribui√ß√£o de umidade sobre a terra. </font><font style="vertical-align: inherit;">Quanto mais forte o vento, mais poderoso o efeito se torna.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Altura absoluta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O segundo ingrediente para obter sombras de chuva s√£o as montanhas. N√£o temos uma classifica√ß√£o estrita do que √© uma montanha, assim como a natureza tamb√©m n√£o a possui. Somente a altura absoluta √© importante. De fato, quando o ar se move sobre a montanha, ele √© for√ßado a subir, √© resfriado e pode conter menos √°gua, o que leva √† precipita√ß√£o antes que o ar passe sobre a montanha. Como resultado, do outro lado, temos ar seco, ou seja, uma sombra da chuva.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais importante, quanto mais alto o ar sobe, menos √°gua ele pode conter. </font><font style="vertical-align: inherit;">Em nossa simula√ß√£o, podemos imaginar isso como uma restri√ß√£o for√ßada do valor m√°ximo de nuvem para cada c√©lula. </font><font style="vertical-align: inherit;">Quanto maior a altura vis√≠vel da c√©lula, menor ser√° esse m√°ximo. </font><font style="vertical-align: inherit;">A maneira mais f√°cil de fazer isso √© definir o m√°ximo como 1 menos a altura aparente, dividida pela altura m√°xima. </font><font style="vertical-align: inherit;">Mas, de fato, vamos dividir por um m√°ximo de menos 1. Isso permitir√° que uma pequena fra√ß√£o das nuvens ainda passe pelas c√©lulas mais altas. </font><font style="vertical-align: inherit;">Atribu√≠mos esse valor m√°ximo ap√≥s o c√°lculo da precipita√ß√£o e antes da dispers√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexDirection mainDispersalDirection = windDirection.Opposite();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se, como resultado, obtivermos mais nuvens do que aceit√°veis, simplesmente converteremos o excesso de nuvens em umidade. </font><font style="vertical-align: inherit;">De fato, √© assim que adicionamos precipita√ß√£o adicional, como acontece nas montanhas reais.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellClimate.clouds &gt; cloudMaximum) { cellClimate.moisture += cellClimate.clouds - cloudMaximum; cellClimate.clouds = cloudMaximum; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/998/c36/403998c36a6d85250f837766a4f33147.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sombras de chuva causadas por grandes altitudes. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≥s completamos a simula√ß√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta fase, j√° temos uma simula√ß√£o parcial de alta qualidade do ciclo da √°gua. </font><font style="vertical-align: inherit;">Vamos coloc√°-lo em ordem um pouco e depois aplic√°-lo para determinar o tipo de al√≠vio das c√©lulas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Computa√ß√£o paralela </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como mencionado anteriormente no spoiler, a ordem em que as c√©lulas s√£o formadas afeta o resultado da simula√ß√£o. </font><font style="vertical-align: inherit;">Idealmente, isso n√£o deveria ser e, em ess√™ncia, formamos todas as c√©lulas em paralelo. </font><font style="vertical-align: inherit;">Isso pode ser feito aplicando todas as mudan√ßas do est√°gio atual de forma√ß√£o √† segunda lista de clima </font></font><code>nextClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;(); List&lt;ClimateData&gt; nextClimate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limpe e inicialize esta lista, como todos os outros. </font><font style="vertical-align: inherit;">Em seguida, trocaremos listas em cada ciclo. </font><font style="vertical-align: inherit;">Nesse caso, a simula√ß√£o usar√° alternadamente as duas listas e aplicar√° os dados clim√°ticos atuais e futuros.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); nextClimate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(initialData); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } List&lt;ClimateData&gt; swap = climate; climate = nextClimate; nextClimate = swap; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando uma c√©lula afeta o clima de seu vizinho, devemos alterar os seguintes dados clim√°ticos, n√£o os atuais. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = nextClimate[neighbor.Index]; ‚Ä¶ nextClimate[neighbor.Index] = neighborClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E, em vez de copiar os seguintes dados clim√°ticos de volta √† lista clim√°tica atual, obtemos os seguintes dados clim√°ticos, adicionamos a umidade atual a eles e copiamos tudo para a pr√≥xima lista. </font><font style="vertical-align: inherit;">Depois disso, redefinimos os dados na lista atual para que sejam atualizados para o pr√≥ximo ciclo.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// cellClimate.clouds = 0f; ClimateData nextCellClimate = nextClimate[cellIndex]; nextCellClimate.moisture += cellClimate.moisture; nextClimate[cellIndex] = nextCellClimate; climate[cellIndex] = new ClimateData();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enquanto fazemos isso, vamos tamb√©m definir o n√≠vel de umidade para um m√°ximo de 1, para que as c√©lulas terrestres n√£o possam estar mais √∫midas do que debaixo d'√°gua. </font></font><br><br><pre> <code class="cs hljs"> nextCellClimate.moisture += cellClimate.moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextCellClimate.moisture &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { nextCellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } nextClimate[cellIndex] = nextCellClimate;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/709/87b/6a870987bfad51e91eaa1ff405be539d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computa√ß√£o paralela.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Humidade original </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√° uma chance de que a simula√ß√£o produza muita terra seca, especialmente com uma alta porcentagem de terra. </font><font style="vertical-align: inherit;">Para melhorar a imagem, podemos adicionar um n√≠vel de umidade inicial personalizado com um valor padr√£o de 0,1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startingMoisture = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/69b/3a2/db869b3a24627d695d9ec8bf2ba1f4ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acima est√° o controle deslizante da umidade original. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos esse valor para a umidade da lista clim√°tica inicial, mas n√£o para o seguinte.</font></font><br><br><pre> <code class="cs hljs"> ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); initialData.moisture = startingMoisture; ClimateData clearData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(clearData); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/138/649/a74138649fc141c088a631bce956a31a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com umidade original.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definindo biomas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclu√≠mos usando umidade em vez de altura para especificar o tipo de al√≠vio da c√©lula. </font><font style="vertical-align: inherit;">Vamos usar a neve para terra completamente seca; em regi√µes √°ridas, usamos neve; depois, h√° pedra, grama para umidade o suficiente e terra para c√©lulas subaqu√°ticas e saturadas de √°gua. </font><font style="vertical-align: inherit;">A maneira mais f√°cil √© usar cinco intervalos em incrementos de 0,2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.4f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.SetMapData(moisture); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/c53/e4f/123c53e4f3f79aa50437a553e0eb6761.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao usar uma distribui√ß√£o uniforme, o resultado n√£o √© muito bom e parece artificial. </font><font style="vertical-align: inherit;">√â melhor usar outros limites, por exemplo, 0,05, 0,12, 0,28 e 0,85.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.05f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.12f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.28f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.85f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/8cf/7c7/6ad8cf7c7becf357d16157ae28999a14.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomas modificados. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 26: biomas e rios </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criamos os rios provenientes de c√©lulas altas com umidade. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criamos um modelo simples de temperatura. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usamos a matriz do bioma para as c√©lulas e depois a alteramos. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta parte, suplementaremos o ciclo da √°gua com rios e temperatura, al√©m de atribuirmos biomas mais interessantes √†s c√©lulas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O tutorial foi criado usando o Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calor e √°gua animam o mapa.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gera√ß√£o de rio </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os rios s√£o uma conseq√º√™ncia do ciclo da √°gua. </font><font style="vertical-align: inherit;">De fato, eles s√£o formados por escoamentos que se rompem com a ajuda da eros√£o do canal. </font><font style="vertical-align: inherit;">Isso implica que voc√™ pode adicionar rios com base no valor dos drenos de c√©lulas. </font><font style="vertical-align: inherit;">No entanto, isso n√£o garante que obteremos algo que se assemelhe a rios reais. </font><font style="vertical-align: inherit;">Quando come√ßamos o rio, ele ter√° que fluir o mais longe poss√≠vel, potencialmente atrav√©s de muitas c√©lulas. </font><font style="vertical-align: inherit;">Isso n√£o √© consistente com a nossa simula√ß√£o do ciclo da √°gua, que processa as c√©lulas em paralelo. </font><font style="vertical-align: inherit;">Al√©m disso, geralmente √© necess√°rio o controle do n√∫mero de rios em um mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como os rios s√£o muito diferentes, n√≥s os geraremos separadamente. </font><font style="vertical-align: inherit;">Utilizamos os resultados da simula√ß√£o do ciclo da √°gua para determinar a localiza√ß√£o dos rios, mas os rios, por sua vez, n√£o afetar√£o a simula√ß√£o.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que o fluxo do rio √†s vezes est√° errado?</font></font></b> <div class="spoiler_text">    <code>TriangulateWaterShore</code>  ,    .      ,    .   ,    ,       .      ,  .    ,  ,       .         (¬´¬ª). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } ‚Ä¶ }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√©lulas de alta umidade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos nossos mapas, uma c√©lula pode ou n√£o ter um rio. Al√©m disso, eles podem ramificar ou conectar-se. Na realidade, os rios s√£o muito mais flex√≠veis, mas temos que conviver com essa aproxima√ß√£o, que cria apenas grandes rios. Mais importante, precisamos determinar a localiza√ß√£o do in√≠cio de um rio grande, que √© escolhido aleatoriamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como os rios precisam de √°gua, a fonte do rio deve estar em uma c√©lula com alta umidade. Mas isso n√£o √© suficiente. Os rios correm pelas encostas, ent√£o, idealmente, a fonte deve ter uma grande altura. Quanto maior a c√©lula acima do n√≠vel da √°gua, melhor candidata √© para o papel da fonte do rio. Podemos visualizar isso como dados do mapa dividindo a altura da c√©lula pela altura m√°xima. Para que o resultado seja obtido em rela√ß√£o ao n√≠vel da √°gua, vamos subtra√≠-lo de ambas as alturas antes de dividir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f9/d80/2de/6f9d802de155c2b1e051be5d360dc3c1.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/e8f/6a2/f5ce8f6a20d7336dc94b89812c123827.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umidade e altitude. N√∫mero grande do mapa 1208905299 com configura√ß√µes padr√£o.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os melhores candidatos s√£o aquelas c√©lulas que possuem alta umidade e alta altura. Podemos combinar esses crit√©rios multiplicando-os. O resultado ser√° o valor da aptid√£o ou do peso para as nascentes dos rios.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec2/31f/445/ec231f445d785c24c6cd9f191ed6c24a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesos para as fontes dos rios.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Idealmente, usar√≠amos esses pesos para rejeitar a sele√ß√£o aleat√≥ria da c√©lula de origem. Embora possamos criar uma lista com os pesos corretos e escolher uma op√ß√£o, essa √© uma abordagem n√£o trivial e atrasa o processo de gera√ß√£o. Uma classifica√ß√£o mais simples de signific√¢ncia dividida em quatro n√≠veis ser√° suficiente para n√≥s. Os primeiros candidatos ser√£o pesos com valores acima de 0,75. Bons candidatos t√™m pesos de 0,5. Os candidatos eleg√≠veis s√£o maiores que 0,25. Todas as outras c√©lulas s√£o descartadas. Vamos mostrar como fica graficamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">1f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(data);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/056/5ba/3b7/0565ba3b7a51499bfe1d389ecd270910.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Categorias de pesos das nascentes dos rios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com esse esquema de classifica√ß√£o, √© prov√°vel que obtenhamos rios com fontes nas √°reas mais altas e √∫midas do mapa. </font><font style="vertical-align: inherit;">No entanto, permanece a probabilidade de cria√ß√£o de rios em √°reas relativamente secas ou baixas, o que aumenta a variabilidade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um m√©todo </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que preencha uma lista de c√©lulas com base nesses crit√©rios. </font><font style="vertical-align: inherit;">As c√©lulas eleg√≠veis s√£o adicionadas a essa lista uma vez, as boas duas vezes e os principais candidatos quatro vezes. </font><font style="vertical-align: inherit;">As c√©lulas subaqu√°ticas s√£o sempre descartadas, portanto voc√™ n√£o pode v√™-las.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData data = climate[i]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = data.moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { riverOrigins.Add(cell); riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { riverOrigins.Add(cell); } } ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse m√©todo deve ser chamado depois </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que os dados de umidade estejam dispon√≠veis para n√≥s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); CreateRivers(); SetTerrainType(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ap√≥s concluir a classifica√ß√£o, voc√™ pode se livrar da visualiza√ß√£o de seus dados no mapa. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// float data = // moisture * (cell.Elevation - waterLevel) / // (elevationMaximum - waterLevel); // if (data &gt; 0.6f) { // cell.SetMapData(1f); // } // else if (data &gt; 0.4f) { // cell.SetMapData(0.5f); // } // else if (data &gt; 0.2f) { // cell.SetMapData(0.25f); // } } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pontos do rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quantos rios precisamos? </font><font style="vertical-align: inherit;">Este par√¢metro deve ser personaliz√°vel. </font><font style="vertical-align: inherit;">Como o comprimento dos rios varia, ser√° mais l√≥gico control√°-lo com a ajuda de pontos fluviais, que determinam o n√∫mero de c√©lulas terrestres nas quais os rios devem estar contidos. </font><font style="vertical-align: inherit;">Vamos express√°-los como uma porcentagem com um m√°ximo de 20% e um valor padr√£o de 10%. </font><font style="vertical-align: inherit;">Como a porcentagem de sushi, esse √© um valor-alvo, n√£o garantido. </font><font style="vertical-align: inherit;">Como resultado, podemos ter poucos candidatos ou rios muito curtos para cobrir a quantidade necess√°ria de terra. </font><font style="vertical-align: inherit;">√â por isso que a porcentagem m√°xima n√£o deve ser muito grande.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 20)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverPercentage = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/793/1c6/4cd/7931c64cd7bdffbb17f83a94aed1bbc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider percentual de rios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar os pontos do rio, expressos como o n√∫mero de c√©lulas, precisamos lembrar em quantas c√©lulas terrestres foram geradas </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount, landCells; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); landCells = landBudget; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); landCells -= landBudget; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√° dentro, o </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√∫mero de pontos do rio agora pode ser calculado da mesma maneira que fazemos </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, continuaremos a retirar e remover c√©lulas aleat√≥rias da lista original, enquanto ainda temos pontos e c√©lulas de origem. </font><font style="vertical-align: inherit;">Em caso de conclus√£o do n√∫mero de pontos, exibiremos um aviso no console.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up river budget."</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, adicionamos um m√©todo para criar rios diretamente. </font><font style="vertical-align: inherit;">Como par√¢metro, ele precisa de uma c√©lula inicial e, ap√≥s a conclus√£o, deve retornar o comprimento do rio. </font><font style="vertical-align: inherit;">Come√ßamos armazenando um m√©todo que retorna comprimento zero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos chamar esse m√©todo no final do ciclo que acabamos de adicionar </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, usando para reduzir o n√∫mero de pontos restantes. </font><font style="vertical-align: inherit;">Garantimos que um novo rio seja criado apenas se a c√©lula selecionada n√£o tiver um rio fluindo atrav√©s dele.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rios atuais </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â l√≥gico criar rios que correm para o mar ou outro corpo de √°gua. </font><font style="vertical-align: inherit;">Quando come√ßamos a partir da fonte, obtemos imediatamente o comprimento 1. Depois disso, selecionamos um vizinho aleat√≥rio e aumentamos o comprimento. </font><font style="vertical-align: inherit;">Continuamos a nos mover at√© chegarmos √† cela subaqu√°tica.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { HexDirection direction = (HexDirection)Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); cell.SetOutgoingRiver(direction); length += <span class="hljs-number"><span class="hljs-number">1</span></span>; cell = cell.GetNeighbor(direction); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/359/7cf/7a7/3597cf7a7ae263721b381534185e7645.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios aleat√≥rios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado de uma abordagem t√£o ing√™nua, obtemos fragmentos dispersos aleatoriamente, principalmente devido √† substitui√ß√£o de rios gerados anteriormente. </font><font style="vertical-align: inherit;">Isso pode at√© levar a erros, porque n√£o verificamos se o vizinho realmente existe. </font><font style="vertical-align: inherit;">Precisamos verificar todas as dire√ß√µes no loop e garantir que haja um vizinho l√°. </font><font style="vertical-align: inherit;">Se for, adicionamos essa dire√ß√£o √† lista de poss√≠veis dire√ß√µes de fluxo, mas apenas se o rio ainda n√£o fluir atrav√©s desse vizinho. </font><font style="vertical-align: inherit;">Em seguida, selecione um valor aleat√≥rio nesta lista.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexDirection&gt; flowDirections = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexDirection&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d); } HexDirection direction = <span class="hljs-comment"><span class="hljs-comment">// (HexDirection)Random.Range(0, 6); flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com essa nova abordagem, podemos ter zero dire√ß√µes de fluxo dispon√≠veis. </font><font style="vertical-align: inherit;">Quando isso acontece, o rio n√£o pode mais fluir mais e deve terminar. </font><font style="vertical-align: inherit;">Se neste momento o comprimento for 1, isso significa que n√£o podemos vazar da c√©lula original, ou seja, n√£o pode haver rio. </font><font style="vertical-align: inherit;">Nesse caso, o comprimento do rio √© zero.</font></font><br><br><pre> <code class="cs hljs"> flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/5bd/05d/e6f5bd05d8d5a976d6fff9fa14397a25.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios preservados.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atropelar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora salvamos os rios j√° criados, mas ainda podemos obter fragmentos isolados dos rios. </font><font style="vertical-align: inherit;">Isso acontece porque enquanto ignoramos as alturas. </font><font style="vertical-align: inherit;">Cada vez que for√ß√°vamos o rio a fluir a uma altura maior, </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interromp√≠amos essa tentativa, que provocava rupturas nos rios. </font><font style="vertical-align: inherit;">Portanto, tamb√©m precisamos pular as dire√ß√µes que causam o fluxo dos rios.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae6/cf7/696/ae6cf76968d64228e88378749939f1f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios descendo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, nos livramos de muitos fragmentos de rios, mas alguns ainda permanecem. </font><font style="vertical-align: inherit;">A partir deste momento, livrar-se dos rios mais feios se torna uma quest√£o de refinamento. </font><font style="vertical-align: inherit;">Para come√ßar, os rios preferem fluir o mais r√°pido poss√≠vel. </font><font style="vertical-align: inherit;">Eles n√£o escolher√£o necessariamente o caminho mais curto poss√≠vel, mas a probabilidade disso √© grande. </font><font style="vertical-align: inherit;">Para simular isso, adicionaremos as dire√ß√µes tr√™s vezes √† lista.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } flowDirections.Add(d);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evite curvas fechadas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m de fluir para baixo, a √°gua tamb√©m tem in√©rcia. </font><font style="vertical-align: inherit;">√â mais prov√°vel que um rio flua reto ou dobre um pouco do que fazer uma curva acentuada repentina. </font><font style="vertical-align: inherit;">Podemos adicionar essa distor√ß√£o rastreando a √∫ltima dire√ß√£o do rio. </font><font style="vertical-align: inherit;">Se a dire√ß√£o potencial da corrente n√£o se desviar muito dessa dire√ß√£o, adicione-a √† lista novamente. </font><font style="vertical-align: inherit;">Isso n√£o √© um problema para a fonte; portanto, sempre a adicionamos novamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; HexDirection direction = HexDirection.NE; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( length == <span class="hljs-number"><span class="hljs-number">1</span></span> || (d != direction.Next2() &amp;&amp; d != direction.Previous2()) ) { flowDirections.Add(d); } flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// HexDirection direction = direction = flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isso reduz muito a probabilidade de os ziguezagues dos rios parecerem feios. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/83b/ce7/67483bce79b287f3cc451e381dc686d2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menos curvas fechadas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conflu√™ncia do rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Äs vezes acontece que o rio flui pr√≥ximo √† fonte do rio criado anteriormente. </font><font style="vertical-align: inherit;">Se a fonte desse rio n√£o estiver em uma altitude mais alta, podemos decidir que o novo rio flui para o antigo. </font><font style="vertical-align: inherit;">Como resultado, temos um rio longo, e n√£o dois vizinhos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para fazer isso, deixaremos o vizinho passar apenas se houver um rio chegando ou se for a fonte do rio atual. </font><font style="vertical-align: inherit;">Depois de determinar que essa dire√ß√£o n√£o est√° voltada para cima, verificamos se h√° um rio de sa√≠da. </font><font style="vertical-align: inherit;">Se houver, ent√£o encontramos novamente o rio antigo. </font><font style="vertical-align: inherit;">Como isso acontece muito raramente, n√£o nos empenharemos em verificar outras fontes vizinhas e combinaremos imediatamente os rios.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor.HasRiver) { // continue; // } if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } if (neighbor.HasOutgoingRiver) { cell.SetOutgoingRiver(d); return length; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb3/820/ee6/bb3820ee6271b8bc7b32e901b39c906a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ba/d8f/08d/3bad8f08d23cfe3844ec259a1c2475d6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios antes e depois da piscina.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manter dist√¢ncia </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como os bons candidatos ao papel de origem geralmente s√£o agrupados, obteremos grupos de rios. </font><font style="vertical-align: inherit;">Al√©m disso, podemos ter rios que levam a fonte ao lado do reservat√≥rio, resultando em rios de comprimento 1. Podemos distribuir as fontes, descartando aquelas que est√£o nas proximidades do rio ou reservat√≥rio. </font><font style="vertical-align: inherit;">Fazemos isso ignorando os vizinhos da fonte selecionada em um loop interno </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se encontrarmos um vizinho que viola as regras, a fonte n√£o nos conv√©m e devemos ignor√°-lo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = origin.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; (neighbor.HasRiver || neighbor.IsUnderwater)) { isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isValidOrigin) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E embora os rios ainda fluam um ao lado do outro, eles tendem a cobrir uma √°rea maior. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/bed/3a6/887bed3a6032b4bea508ee6ceda4a228.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/b85/428/f53b85428840118895d74f62b1c2d1a6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sem dist√¢ncia e com ela.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terminamos o rio com um lago </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nem todos os rios chegam ao reservat√≥rio, alguns ficam presos nos vales ou s√£o bloqueados por outros rios. Este n√£o √© um problema espec√≠fico, porque geralmente os rios reais tamb√©m parecem desaparecer. Isso pode acontecer, por exemplo, se eles fluem no subsolo, dispersam em uma √°rea pantanosa ou secam. Nossos rios n√£o podem visualizar isso, ent√£o eles simplesmente terminam. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, podemos tentar minimizar o n√∫mero desses casos. Embora n√£o possamos unir os rios ou faz√™-los fluir, podemos faz√™-los terminar em lagos, o que geralmente √© encontrado na realidade e parece bom. Para isso</font></font><code>CreateRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve elevar o n√≠vel da √°gua na c√©lula se ficar preso. </font><font style="vertical-align: inherit;">A possibilidade disso depende da altura m√≠nima dos vizinhos desta c√©lula. </font><font style="vertical-align: inherit;">Portanto, para acompanhar isso ao estudar vizinhos, √© necess√°ria uma pequena altera√ß√£o no c√≥digo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minNeighborElevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { // continue; // } if (!neighbor) { continue; } if (neighbor.Elevation &lt; minNeighborElevation) { minNeighborElevation = neighbor.Elevation; } if (neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } ‚Ä¶ } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se estivermos presos, primeiro precisamos verificar se ainda estamos na fonte. </font><font style="vertical-align: inherit;">Se sim, basta cancelar o rio. </font><font style="vertical-align: inherit;">Caso contr√°rio, verificamos se todos os vizinhos s√£o pelo menos t√£o altos quanto a c√©lula atual. </font><font style="vertical-align: inherit;">Nesse caso, podemos elevar a √°gua para este n√≠vel. </font><font style="vertical-align: inherit;">Isso criar√° um lago a partir de uma c√©lula, a menos que a altura da c√©lula permane√ßa no mesmo n√≠vel. </font><font style="vertical-align: inherit;">Nesse caso, basta atribuir a altura um n√≠vel abaixo do n√≠vel da √°gua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// return length &gt; 1 ? length : 0; if (length == 1) { return 0; } if (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = minNeighborElevation; if (minNeighborElevation == cell.Elevation) { cell.Elevation = minNeighborElevation - 1; } } break; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/7da/964/d607da964da18b71cd022c997661695c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee8/ab1/000/ee8ab10002cd3e36cefbcfe3980a8fbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As extremidades dos rios sem lagos e com lagos. </font><font style="vertical-align: inherit;">Nesse caso, a porcentagem de rios √© 20.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Observe que agora podemos ter c√©lulas subaqu√°ticas acima do n√≠vel da √°gua usada para gerar o mapa. </font><font style="vertical-align: inherit;">Eles ir√£o indicar lagos acima do n√≠vel do mar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lagos adicionais </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m podemos criar lagos, mesmo que n√£o fiquemos presos. </font><font style="vertical-align: inherit;">Isso pode resultar em um rio entrando e saindo do lago. </font><font style="vertical-align: inherit;">Se n√£o estivermos presos, um lago poder√° ser criado elevando o n√≠vel da √°gua e a altura atual da c√©lula e reduzindo a altura da c√©lula. </font><font style="vertical-align: inherit;">Isso se aplica somente quando a altura m√≠nima do vizinho √© pelo menos igual √† altura da c√©lula atual. </font><font style="vertical-align: inherit;">Fazemos isso no final do ciclo do rio e antes de passar para a pr√≥xima c√©lula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell = cell.GetNeighbor(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/945/5bb/2b6/9455bb2b6547a8b1342e179f15eb5925.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f84/516/4b7/f845164b7a543b9549cd9f07d273e67f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sem lagos adicionais e com eles. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√°rios lagos s√£o lindos, mas sem limites, podemos criar muitos lagos. </font><font style="vertical-align: inherit;">Portanto, vamos adicionar uma probabilidade personalizada para lagos adicionais, com um valor padr√£o de 0,25.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> extraLakeProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ela controlar√° a probabilidade de gerar um lago adicional, se poss√≠vel. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( minNeighborElevation &gt;= cell.Elevation &amp;&amp; Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; extraLakeProbability ) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/d04/bc3/fa5d04bc3f7475ec2baab7b6e7dac38f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/bb4/364/118bb4364acb0646efb54a031d3ac356.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lagos adicionais.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que tal criar lagos com mais de uma c√©lula?</font></font></b> <div class="spoiler_text">     ,       ,  ,      .      .      :          .       ,       .  ,      ,     ,   . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2>  Temperatura </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √°gua √© apenas um dos fatores que podem determinar o bioma de uma c√©lula. </font><font style="vertical-align: inherit;">Outro fator importante √© a temperatura. </font><font style="vertical-align: inherit;">Embora possamos simular o fluxo e a difus√£o de temperaturas, como a simula√ß√£o da √°gua, para criar um clima interessante, precisamos apenas de um fator complexo. </font><font style="vertical-align: inherit;">Portanto, vamos manter a temperatura simples e configur√°-la para cada c√©lula.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temperatura e latitude </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maior influ√™ncia na temperatura √© a latitude. </font><font style="vertical-align: inherit;">Est√° quente no equador, frio nos p√≥los e h√° uma transi√ß√£o suave entre eles. </font><font style="vertical-align: inherit;">Vamos criar um m√©todo </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que retorne a temperatura de uma determinada c√©lula. </font><font style="vertical-align: inherit;">Para come√ßar, basta usar a coordenada Z da c√©lula dividida pela dimens√£o Z como latitude e, em seguida, usar esse valor como temperatura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> latitude; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definimos a temperatura </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a usamos como dados do mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); cell.SetMapData(temperature); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/789/7f6/334/7897f63347b08fdb02ee5794f3ab28e3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latitude como temperatura, hemisf√©rio sul. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos um gradiente linear de temperatura aumentando de baixo para cima. </font><font style="vertical-align: inherit;">Voc√™ pode us√°-lo para simular o hemisf√©rio sul, com um polo na parte inferior e um equador na parte superior. </font><font style="vertical-align: inherit;">Mas n√£o precisamos descrever o hemisf√©rio inteiro. </font><font style="vertical-align: inherit;">Com uma diferen√ßa de temperatura menor ou nenhuma diferen√ßa, podemos descrever uma √°rea menor. </font><font style="vertical-align: inherit;">Para fazer isso, tornaremos as temperaturas baixas e altas personaliz√°veis. </font><font style="vertical-align: inherit;">Definiremos essas temperaturas no intervalo de 0 a 1 e usaremos os valores extremos como valores padr√£o.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lowTemperature = <span class="hljs-number"><span class="hljs-number">0f</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highTemperature = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/8cf/805/3b18cf805a56a0dbbeabb03b69a00496.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle deslizante de temperatura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicamos a faixa de temperatura usando interpola√ß√£o linear, usando a latitude como interpolador. </font><font style="vertical-align: inherit;">Como expressamos latitude como um valor de 0 a 1, podemos us√°-lo </font></font><code>Mathf.LerpUnclamped</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que baixas temperaturas n√£o s√£o necessariamente mais baixas que altas. </font><font style="vertical-align: inherit;">Se desejar, voc√™ pode entreg√°-los.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hemisf√©rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos simular o hemisf√©rio sul e, possivelmente, o norte, se medirmos primeiro as temperaturas. </font><font style="vertical-align: inherit;">Mas √© muito mais conveniente usar uma op√ß√£o de configura√ß√£o separada para alternar entre hemisf√©rios. </font><font style="vertical-align: inherit;">Vamos criar uma enumera√ß√£o e um campo para ele. </font><font style="vertical-align: inherit;">Assim, tamb√©m adicionaremos a op√ß√£o de criar os dois hemisf√©rios, que √© aplic√°vel por padr√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HemisphereMode { Both, North, South } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HemisphereMode hemisphere;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/c67/03f/be8c6703f51cd7c62535a96a3035a284.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A escolha do hemisf√©rio. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se precisarmos do hemisf√©rio norte, podemos simplesmente inverter a latitude, subtraindo-a de 1. Para simular os dois hemisf√©rios, os p√≥los devem estar abaixo e acima do mapa, e o equador deve estar no meio. </font><font style="vertical-align: inherit;">Voc√™ pode fazer isso duplicando a latitude, enquanto o hemisf√©rio inferior ser√° processado corretamente e o superior ter√° uma latitude de 1 a 2. Para corrigir isso, subtra√≠mos a latitude de 2 quando exceder 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.Both) { latitude *= <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latitude &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { latitude = <span class="hljs-number"><span class="hljs-number">2f</span></span> - latitude; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.North) { latitude = <span class="hljs-number"><span class="hljs-number">1f</span></span> - latitude; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c7/871/ede/9c7871ede0c56a393bc603ec888c65bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambos os hemisf√©rios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale ressaltar que isso cria a possibilidade de criar um mapa ex√≥tico no qual o equador √© frio e os p√≥los s√£o quentes.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quanto mais alto o frio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m da latitude, a temperatura tamb√©m √© significativamente afetada pela altitude. </font><font style="vertical-align: inherit;">Em m√©dia, quanto mais alto subimos, mais frio fica. </font><font style="vertical-align: inherit;">Podemos transformar isso em um fator, como fizemos com os candidatos do rio. </font><font style="vertical-align: inherit;">Nesse caso, usamos a altura da c√©lula. </font><font style="vertical-align: inherit;">Al√©m disso, este indicador diminui com a altura, ou seja, igual a 1 menos a altura dividida pelo m√°ximo em rela√ß√£o ao n√≠vel da √°gua. </font><font style="vertical-align: inherit;">Para que o indicador no n√≠vel mais alto n√£o caia para zero, adicionamos ao divisor. </font><font style="vertical-align: inherit;">Em seguida, use este indicador para dimensionar a temperatura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75e/a24/550/75ea24550d4325e2af45a1a9627cc53c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A altura afeta a temperatura.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flutua√ß√µes de temperatura </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos tornar a simplicidade do gradiente de temperatura menos percept√≠vel adicionando flutua√ß√µes aleat√≥rias de temperatura. </font><font style="vertical-align: inherit;">Uma pequena chance de torn√°-lo mais realista, mas com muita flutua√ß√£o, eles parecer√£o arbitr√°rios. </font><font style="vertical-align: inherit;">Vamos personalizar o poder das flutua√ß√µes de temperatura e express√°-lo como o desvio m√°ximo de temperatura com um valor padr√£o de 0,1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperatureJitter = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/e21/83f/27de2183fc453ded3c2902d4705cd1eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle deslizante de flutua√ß√£o de temperatura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tais flutua√ß√µes devem ser suaves com pequenas altera√ß√µes locais. </font><font style="vertical-align: inherit;">Voc√™ pode usar nossa textura de ru√≠do para isso. </font><font style="vertical-align: inherit;">Vamos chamar </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e usar como argumento a posi√ß√£o da c√©lula, dimensionada em 0,1. </font><font style="vertical-align: inherit;">Vamos pegar o canal W, centraliz√°-lo e escal√°-lo pelo coeficiente de oscila√ß√£o. </font><font style="vertical-align: inherit;">Em seguida, adicionamos esse valor √† temperatura calculada anteriormente.</font></font><br><br><pre> <code class="cs hljs"> temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); temperature += (HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>).w * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/490/92c/2c8/49092c2c88aaad00d5c54835c6511a74.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/7d9/3cd/dac7d93cdb115574c748269ffebb3d8d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flutua√ß√µes de temperatura com valores de 0,1 e 1.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos adicionar uma ligeira variabilidade √†s flutua√ß√µes em cada mapa, escolhendo aleatoriamente entre os quatro canais de ru√≠do. </font><font style="vertical-align: inherit;">Defina o canal uma vez </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e depois indexe os canais de cores </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temperatureJitterChannel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitter = HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>)[temperatureJitterChannel]; temperature += (jitter * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/e82/084/30ce820847299346ec8dfaf2bb6cf1a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferentes flutua√ß√µes de temperatura com for√ßa m√°xima. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que temos dados sobre umidade e temperatura, podemos criar uma matriz de bioma. </font><font style="vertical-align: inherit;">Ao indexar essa matriz, podemos atribuir biomas a todas as c√©lulas, criando um cen√°rio mais complexo do que usar apenas uma dimens√£o de dados.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matriz de bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem muitos modelos clim√°ticos, mas n√£o os usaremos. Vamos simplificar, estamos interessados ‚Äã‚Äãapenas na l√≥gica. Seco significa deserto (frio ou quente), para isso usamos areia. Frio e molhado significa neve. Quente e √∫mido significa muita vegeta√ß√£o, ou seja, grama. Entre eles, teremos uma taiga ou tundra, que designaremos como uma textura acinzentada da terra. Uma matriz 4 √ó 4 ser√° suficiente para criar transi√ß√µes entre esses biomas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, atribu√≠mos tipos de eleva√ß√£o com base em cinco intervalos de umidade. Simplesmente baixamos a faixa mais seca para 0,05 e salvamos o resto. Para faixas de temperatura, usamos 0,1, 0,3, 0,6 e superior. Por conveni√™ncia, definiremos esses valores em matrizes est√°ticas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] temperatureBands = { <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] moistureBands = { <span class="hljs-number"><span class="hljs-number">0.12f</span></span>, <span class="hljs-number"><span class="hljs-number">0.28f</span></span>, <span class="hljs-number"><span class="hljs-number">0.85f</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora tenhamos especificado apenas o tipo de relevo com base no bioma, podemos us√°-lo para determinar outros par√¢metros. </font><font style="vertical-align: inherit;">Portanto, vamos definir em uma </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estrutura </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que descreve a configura√ß√£o de um bioma individual. </font><font style="vertical-align: inherit;">At√© o momento, ele cont√©m apenas o √≠ndice de resposta mais o m√©todo construtor correspondente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos essa estrutura para criar uma matriz est√°tica contendo dados da matriz. </font><font style="vertical-align: inherit;">Usamos a umidade como coordenada X e a temperatura como Y. Enchemos a linha com a temperatura mais baixa com neve, a segunda linha com tundra e as outras duas com grama. </font><font style="vertical-align: inherit;">Em seguida, substitu√≠mos a coluna mais seca pelo deserto, redefinindo a op√ß√£o de temperatura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/859/bd5/969859bd51e51cce1f7fe63d9eacd55a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matriz de biomas com √≠ndices de uma matriz unidimensional.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Defini√ß√£o de bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar as </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√©lulas </font><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">bioma, percorreremos as faixas de temperatura e umidade no ciclo para determinar os √≠ndices de matriz que precisamos. </font><font style="vertical-align: inherit;">N√≥s os usamos para obter o bioma desejado e especificar o tipo de topografia celular.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(temperature); float moisture = climate[i].moisture; if (!cell.IsUnderwater) { // if (moisture &lt; 0.05f) { // cell.TerrainTypeIndex = 4; // } // ‚Ä¶ // else { // cell.TerrainTypeIndex = 2; // } int t = 0; for (; t &lt; temperatureBands.Length; t++) { if (temperature &lt; temperatureBands[t]) { break; } } int m = 0; for (; m &lt; moistureBands.Length; m++) { if (moisture &lt; moistureBands[m]) { break; } } Biome cellBiome = biomes[t * 4 + m]; cell.TerrainTypeIndex = cellBiome.terrain; } else { cell.TerrainTypeIndex = 2; } } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00d/d32/4f5/00dd324f5b421811f49ca157e5217e43.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√≠vio baseado em uma matriz de bioma.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Configura√ß√£o do bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos ir al√©m dos biomas definidos na matriz. Por exemplo, na matriz, todos os biomas secos s√£o definidos como desertos de areia, mas nem todos os desertos secos s√£o preenchidos com areia. Existem muitos desertos rochosos que parecem muito diferentes. Portanto, vamos substituir algumas das c√©lulas do deserto por pedras. Faremos isso simplesmente com base na altura: a areia est√° em baixas altitudes e as rochas nuas geralmente s√£o encontradas acima. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que a areia vire pedra quando a altura da c√©lula estiver mais pr√≥xima da altura m√°xima do que do n√≠vel da √°gua. Esta √© a linha de altura dos desertos rochosos que podemos calcular no in√≠cio </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Quando encontramos uma c√©lula com areia e sua altura √© grande o suficiente, alteramos o relevo do bioma para pedra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rockDesertElevation = elevationMaximum - (elevationMaximum - waterLevel) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { ‚Ä¶ Biome cellBiome = biomes[t * <span class="hljs-number"><span class="hljs-number">4</span></span> + m]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } cell.TerrainTypeIndex = cellBiome.terrain; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/812/13e/1e481213eb2c9b5cf5216b9bfa9546aa.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Areia e desertos rochosos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra mudan√ßa baseada na altura √© for√ßar as c√©lulas na altura m√°xima a se transformarem em picos de neve, independentemente da temperatura, apenas se n√£o estiverem muito secas. </font><font style="vertical-align: inherit;">Isso aumentar√° a probabilidade de picos de neve perto do equador quente e √∫mido.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == elevationMaximum) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/06e/35b/9c406e35b681819072db7a3006151e6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bon√©s de neve na altura m√°xima.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plantas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos fazer biomas determinar o n√≠vel de c√©lulas vegetais. </font><font style="vertical-align: inherit;">Para fazer isso, adicione ao </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo de plantas e inclua-o no construtor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain, plant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> plant</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.plant = plant; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos biomas mais frios e secos, n√£o haver√° plantas. </font><font style="vertical-align: inherit;">Em todos os outros aspectos, quanto mais quente e √∫mido o clima, mais plantas. </font><font style="vertical-align: inherit;">A segunda coluna de umidade recebe apenas o primeiro n√≠vel de plantas para a linha mais quente, portanto [0, 0, 0, 1]. </font><font style="vertical-align: inherit;">A terceira coluna aumenta os n√≠veis em um, com exce√ß√£o da neve, ou seja, [0, 1, 1, 2]. </font><font style="vertical-align: inherit;">E a coluna mais √∫mida aumenta novamente, ou seja, [0, 2, 2, 3]. </font><font style="vertical-align: inherit;">Altere a matriz </font></font><code>biomes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adicionando a configura√ß√£o da planta a ela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f94/bad/c72/f94badc7211d1891415dda94019bf041.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matriz de biomas com n√≠veis de plantas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos definir o n√≠vel de plantas para a c√©lula.</font></font><br><br><pre> <code class="cs hljs"> cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/2c6/7f8/ed92c67f8322c4b0c9967c0f394507bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomas com plantas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As plantas agora parecem diferentes?</font></font></b> <div class="spoiler_text">       ,      .       (1, 2, 1)  (0.75, 1, 0.75).     (1.5, 3, 1.5)  (2, 1.5, 2).    ‚Äî (2, 4.5, 2)  (2.5, 3, 2.5). <br><br>        ,      : (13, 114, 0). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos mudar o n√≠vel de plantas para biomas. </font><font style="vertical-align: inherit;">Primeiro, precisamos garantir que eles n√£o apare√ßam no terreno nevado, que j√° poder√≠amos montar. </font><font style="vertical-align: inherit;">Em segundo lugar, vamos aumentar o n√≠vel de plantas ao longo dos rios, se ainda n√£o estiver no m√°ximo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">4</span></span>) { cellBiome.plant = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.plant &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; cell.HasRiver) { cellBiome.plant += <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/012/7e4/bd10127e45593cc5f8ce09faa783b10c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plantas modificadas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomas subaqu√°ticos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© aquele momento, ignor√°vamos completamente as c√©lulas subaqu√°ticas. </font><font style="vertical-align: inherit;">Vamos adicionar uma pequena varia√ß√£o a eles, e n√£o usaremos a textura da terra para todos eles. </font><font style="vertical-align: inherit;">Uma solu√ß√£o simples com base na altura j√° ser√° suficiente para criar uma imagem mais interessante. </font><font style="vertical-align: inherit;">Por exemplo, vamos usar grama para c√©lulas um passo abaixo do n√≠vel da √°gua. </font><font style="vertical-align: inherit;">Tamb√©m vamos usar grama para c√©lulas acima do n√≠vel da √°gua, isto √©, para lagos criados por rios. </font><font style="vertical-align: inherit;">C√©lulas com uma altura negativa s√£o √°reas do fundo do mar, ent√£o usamos pedras para elas. </font><font style="vertical-align: inherit;">Todas as outras c√©lulas permanecem em terra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= waterLevel) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a62/bb5/5c7/a62bb55c7e4023a4590dbfe73bafe10f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilidade subaqu√°tica.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos adicionar mais alguns detalhes para as c√©lulas subaqu√°ticas ao longo da costa. S√£o c√©lulas com pelo menos um vizinho acima da √°gua. Se essa c√©lula for rasa, criaremos uma praia. E se estiver pr√≥ximo ao penhasco, ser√° o detalhe visual dominante, e usaremos a pedra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar isso, verificaremos os vizinhos das c√©lulas localizadas um passo abaixo do n√≠vel da √°gua. Vamos contar o n√∫mero de conex√µes por fal√©sias e encostas com c√©lulas terrestres vizinhas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.WaterLevel; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { slopes += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cliffs += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos usar essas informa√ß√µes para classificar as c√©lulas. </font><font style="vertical-align: inherit;">Em primeiro lugar, se mais da metade dos vizinhos s√£o terrenos, ent√£o estamos lidando com um lago ou uma ba√≠a. </font><font style="vertical-align: inherit;">Para essas c√©lulas, usamos uma textura de grama. </font><font style="vertical-align: inherit;">Caso contr√°rio, se tivermos penhascos, usaremos pedra. </font><font style="vertical-align: inherit;">Caso contr√°rio, se tivermos declives, usaremos areia para criar uma praia. </font><font style="vertical-align: inherit;">A √∫nica op√ß√£o restante √© uma √°rea rasa ao largo da costa, para a qual ainda usamos grama.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs + slopes &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slopes &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/8d6/2ed/0eb8d62ed0ec66f7814bd839c9ca32fb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/976/0bc/e349760bc545e3063718b892a9ccbd89.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilidade da costa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como toque final, vamos verificar se n√£o temos c√©lulas subaqu√°ticas verdes na faixa de temperatura mais baixa. </font><font style="vertical-align: inherit;">Para essas c√©lulas, usamos a terra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrain == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; temperature &lt; temperatureBands[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tivemos a oportunidade de gerar cart√µes aleat√≥rios que parecem bastante interessantes e naturais, com muitas op√ß√µes de configura√ß√£o. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 27: dobrando um cart√£o </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dividimos os cart√µes em colunas que podem ser movidas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centralize o cart√£o na c√¢mera. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colapsamos tudo. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta √∫ltima parte, adicionaremos suporte para minimizar o mapa, conectando as bordas leste e oeste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O tutorial foi criado usando o Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/96a/49d/f2996a49dab361c70ce643cc9f2d648b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dobrar faz o mundo girar.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cart√µes dobr√°veis </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossos mapas podem ser usados ‚Äã‚Äãpara modelar √°reas de tamanhos diferentes, mas eles sempre est√£o limitados a uma forma retangular. Podemos criar um mapa de uma ilha ou de um continente inteiro, mas n√£o de todo o planeta. Os planetas s√£o esf√©ricos, eles n√£o t√™m limites r√≠gidos que impedem o movimento em sua superf√≠cie. Se voc√™ continuar se movendo em uma dire√ß√£o, mais cedo ou mais tarde retornar√° ao ponto de partida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o podemos envolver uma grade de hex√°gonos em torno de uma esfera; essa sobreposi√ß√£o √© imposs√≠vel. Nas melhores aproxima√ß√µes, √© utilizada a topologia icosa√©drica, na qual as doze c√©lulas devem ser pent√°gonos. No entanto, sem nenhuma distor√ß√£o ou exce√ß√£o, a malha pode ser enrolada ao redor do cilindro. Para fazer isso, basta conectar as bordas leste e oeste do mapa. Com exce√ß√£o da l√≥gica de empacotamento, tudo o resto permanece o mesmo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um cilindro √© uma aproxima√ß√£o aproximada de uma esfera, porque n√£o podemos modelar polos. </font><font style="vertical-align: inherit;">Mas isso n√£o impediu os desenvolvedores de muitos jogos de usar o leste para o oeste para modelar mapas do planeta. </font><font style="vertical-align: inherit;">As regi√µes polares simplesmente n√£o fazem parte da zona de jogo.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que tal virar para o norte e sul?</font></font></b> <div class="spoiler_text">          ,     .       ,    ,       .        -,            -.         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem duas maneiras de implementar a dobra cil√≠ndrica. </font><font style="vertical-align: inherit;">A primeira √© tornar o mapa cil√≠ndrico dobrando sua superf√≠cie e tudo o que est√° nele, de modo que as bordas leste e oeste estejam em contato. </font><font style="vertical-align: inherit;">Agora voc√™ jogar√° n√£o em uma superf√≠cie plana, mas em um cilindro real. </font><font style="vertical-align: inherit;">A segunda abordagem √© salvar um mapa plano e usar o teletransporte ou a duplica√ß√£o para recolher. </font><font style="vertical-align: inherit;">A maioria dos jogos usa a segunda abordagem, ent√£o vamos adot√°-la.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dobragem opcional </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A necessidade de recolher o mapa depende de sua escala - local ou planet√°ria. </font><font style="vertical-align: inherit;">Podemos usar o suporte de ambos, tornando a dobragem opcional. </font><font style="vertical-align: inherit;">Para fazer isso, adicione uma </font><font style="vertical-align: inherit;">nova op√ß√£o ao </font><font style="vertical-align: inherit;">menu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criar novo mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com o recolhimento ativado por padr√£o.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/17d/3ef/b0717d3ef8000555a454de943e4e387a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O menu do novo mapa com a op√ß√£o de recolher. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione ao </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo para rastrear a sele√ß√£o, bem como um m√©todo para alter√°-la. </font><font style="vertical-align: inherit;">Vamos fazer com que esse m√©todo seja chamado quando o estado do comutador for alterado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWrapping</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { wrapping = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando um novo mapa √© solicitado, passamos o valor da op√ß√£o minimizar. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z, wrapping); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z, wrapping); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Altere-o </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele aceite esse novo argumento e depois o passe para </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ grid.CreateMap(x, z, wrapping); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥digo&gt; O HexGrid deve saber se estamos recolhendo, portanto, adicione um campo a ele e </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defina-o. </font><font style="vertical-align: inherit;">Outras classes devem mudar sua l√≥gica, dependendo se a grade √© minimizada, para tornar o campo geral. </font><font style="vertical-align: inherit;">Al√©m disso, permite definir o valor padr√£o por meio do inspetor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCountX = <span class="hljs-number"><span class="hljs-number">20</span></span>, cellCountZ = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellCountX = x; cellCountZ = z; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; ‚Ä¶ }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamadas pr√≥prias </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em dois lugares. </font><font style="vertical-align: inherit;">Podemos simplesmente usar seu pr√≥prio campo para o argumento de recolhimento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ CreateMap(cellCountX, cellCountZ, wrapping); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d57/fc1/36ad57fc1ff8967bbd8282808f762241.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O interruptor de dobramento da grade est√° ativado por padr√£o.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salvando e carregando </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o dobramento est√° definido para cada cart√£o, ele deve ser salvo e carregado. </font><font style="vertical-align: inherit;">Isso significa que voc√™ precisa alterar o formato de salvamento de arquivo, para aumentar a vers√£o constantemente </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao salvar, </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basta escrever o valor da dobra booleana ap√≥s o tamanho do mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); writer.Write(wrapping); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao carregar, vamos l√™-lo apenas com a vers√£o correta do arquivo. </font><font style="vertical-align: inherit;">Se for diferente, esse √© um cart√£o antigo e n√£o deve ser minimizado. </font><font style="vertical-align: inherit;">Salve essas informa√ß√µes em uma vari√°vel local e compare-as com o estado atual da dobra. </font><font style="vertical-align: inherit;">Se for diferente, n√£o podemos reutilizar a topologia de mapa existente da mesma maneira que faria ao carregar um mapa com outros tamanhos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = header &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping != wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©tricas dobr√°veis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimizar o mapa exigir√° grandes altera√ß√µes na l√≥gica, por exemplo, ao calcular dist√¢ncias. </font><font style="vertical-align: inherit;">Portanto, eles podem tocar no c√≥digo que n√£o possui um link direto para a grade. </font><font style="vertical-align: inherit;">Em vez de passar essas informa√ß√µes como argumentos, vamos adicion√°-las </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Adicione um n√∫mero inteiro est√°tico que contenha o tamanho da dobra que corresponda √† largura do mapa. </font><font style="vertical-align: inherit;">Se for maior que zero, estamos lidando com um cart√£o dobr√°vel. </font><font style="vertical-align: inherit;">Para verificar isso, adicione uma propriedade.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Wrapping { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wrapSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos definir o tamanho da dobra para cada chamada </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como esses dados n√£o sobreviver√£o √† recompila√ß√£o no modo Play, n√≥s os definiremos </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ResetVisibility(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Largura da c√©lula </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao trabalhar com cart√µes dobr√°veis, geralmente precisamos lidar com as posi√ß√µes ao longo do eixo X, medidas na largura das c√©lulas. </font><font style="vertical-align: inherit;">Embora possa ser usado para isso </font></font><code>HexMetrics.innerRadius * 2f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seria mais conveniente se n√£o adicion√°ssemos multiplica√ß√£o sempre. </font><font style="vertical-align: inherit;">Ent√£o, vamos adicionar uma constante </font></font><code>HexMetrics.innerDiameter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerDiameter = innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J√° podemos usar o di√¢metro em tr√™s locais. </font><font style="vertical-align: inherit;">Em primeiro lugar, </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ao posicionar uma nova c√©lula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.innerDiameter; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limitando a posi√ß√£o da c√¢mera.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E tamb√©m na </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convers√£o de posi√ß√£o em coordenadas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / HexMetrics.innerDiameter; ‚Ä¶ }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centraliza√ß√£o do cart√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando o mapa n√£o entra em colapso, ele define claramente as bordas leste e oeste e, portanto, um claro centro horizontal. </font><font style="vertical-align: inherit;">Mas no caso de um cart√£o dobr√°vel, tudo √© diferente. </font><font style="vertical-align: inherit;">N√£o tem a borda oriental nem a ocidental, nem o centro. </font><font style="vertical-align: inherit;">Como alternativa, podemos assumir que o centro √© onde est√° a c√¢mera. </font><font style="vertical-align: inherit;">Isso ser√° √∫til porque queremos que o mapa esteja sempre centralizado em nosso ponto de vista. </font><font style="vertical-align: inherit;">Ent√£o, onde quer que estejamos, n√£o veremos as bordas leste ou oeste do mapa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colunas do fragmento do mapa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que a visualiza√ß√£o do mapa seja centralizada em rela√ß√£o √† c√¢mera, precisamos alterar o posicionamento dos elementos, dependendo do movimento da c√¢mera. Se ele se move para oeste, precisamos pegar o que est√° atualmente na borda da parte leste e mov√™-lo para a borda da parte ocidental. O mesmo se aplica √† dire√ß√£o oposta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealmente, assim que a c√¢mera se mover para a coluna vizinha de c√©lulas, devemos mover imediatamente a coluna mais distante para o outro lado. No entanto, n√£o precisamos ser t√£o precisos. Em vez disso, podemos transferir fragmentos inteiros do mapa. Isso nos permite mover partes do mapa sem precisar modificar as malhas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como estamos movendo colunas inteiras de fragmentos ao mesmo tempo, vamos agrup√°-los criando um objeto de coluna pai para cada grupo. </font><font style="vertical-align: inherit;">Adicione uma matriz para esses objetos </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e n√≥s a inicializaremos </font></font><code>CreateChunks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">N√≥s os usaremos apenas como cont√™ineres, portanto, precisamos rastrear o link para seus componentes </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como no caso de fragmentos, suas posi√ß√µes iniciais est√£o localizadas na origem local das coordenadas da grade.</font></font><br><br><pre> <code class="cs hljs"> Transform[] columns; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { columns = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Transform[chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { columns[x] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>).transform; columns[x].SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora, o fragmento deve se tornar filho da coluna correspondente, n√£o da grade. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(columns[x], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/415/920/bb2/415920bb2e4e2e002793aaebee8e04e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmentos agrupados em colunas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como agora todos os fragmentos se tornaram filhos das colunas, </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basta destruirmos diretamente todas as colunas, n√£o os fragmentos. </font><font style="vertical-align: inherit;">Ent√£o, vamos nos livrar dos fragmentos da filha.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columns != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { Destroy(columns[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colunas de teletransporte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione ao </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">novo m√©todo </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a posi√ß√£o X como par√¢metro. </font><font style="vertical-align: inherit;">Converta a posi√ß√£o no √≠ndice da coluna, dividindo-a pela largura do fragmento em unidades do Unity. </font><font style="vertical-align: inherit;">Este ser√° o √≠ndice da coluna na qual a c√¢mera est√° localizada atualmente, ou seja, ser√° a coluna central do mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basta mudar a visualiza√ß√£o do mapa apenas quando o √≠ndice da coluna central √© alterado. </font><font style="vertical-align: inherit;">Ent√£o, vamos acompanhar em campo. </font><font style="vertical-align: inherit;">Usamos o valor padr√£o -1 ao criar um mapa, para que novos mapas estejam sempre centralizados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centerColumnIndex == currentCenterColumnIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } currentCenterColumnIndex = centerColumnIndex; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que conhecemos o √≠ndice da coluna central, podemos determinar os √≠ndices m√≠nimo e m√°ximo, subtraindo e adicionando metade do n√∫mero de colunas. Como usamos valores inteiros, com um n√∫mero √≠mpar de colunas, isso funciona perfeitamente. No caso de um n√∫mero par, n√£o pode haver uma coluna perfeitamente centralizada; portanto, um dos √≠ndices estar√° um passo al√©m do necess√°rio. Isso cria um deslocamento de uma coluna na dire√ß√£o da extremidade mais distante do mapa, mas para n√≥s isso n√£o √© um problema.</font></font><br><br><pre> <code class="cs hljs"> currentCenterColumnIndex = centerColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que esses √≠ndices podem ser negativos ou maiores que o √≠ndice m√°ximo natural da coluna. </font><font style="vertical-align: inherit;">O m√≠nimo √© zero apenas quando a c√¢mera est√° perto do centro natural do mapa. </font><font style="vertical-align: inherit;">Nossa tarefa √© mover as colunas para que correspondam a esses √≠ndices relativos. </font><font style="vertical-align: inherit;">Isso pode ser feito alterando a coordenada X local de cada coluna no loop.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; Vector3 position; position.y = position.z = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; columns[i].localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para cada coluna, verificamos se o √≠ndice do √≠ndice m√≠nimo √© menor. </font><font style="vertical-align: inherit;">Nesse caso, est√° muito longe √† esquerda do centro. </font><font style="vertical-align: inherit;">Ele deve se teletransportar para o outro lado do mapa. </font><font style="vertical-align: inherit;">Isso pode ser feito tornando sua coordenada X igual √† largura do mapa. </font><font style="vertical-align: inherit;">Da mesma forma, se o √≠ndice da coluna for maior que o √≠ndice m√°ximo, ele estar√° muito distante √† direita do centro e dever√° se teletransportar para o outro lado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; minColumnIndex) { position.x = chunkCountX * (HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; maxColumnIndex) { position.x = chunkCountX * -(HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } columns[i].localPosition = position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimento da c√¢mera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mude </font></font><code>HexMapCamera.AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que, ao trabalhar com um cart√£o dobr√°vel, ele </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ligue </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primeiro, basta tornar o novo m√©todo uma </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duplicata </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas com a √∫nica diferen√ßa: no final, ele chamar√° </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transform.localPosition = grid.wrapping ? WrapPosition(position) : ClampPosition(position); } ‚Ä¶ <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); grid.CenterMap(position.x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mapa foi imediatamente centrado, chamar </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; ValidatePosition(); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mova para a esquerda e direita ao centralizar na c√¢mera. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora ainda restringamos o movimento da c√¢mera, o mapa agora tenta centralizar em rela√ß√£o √† c√¢mera, teleportando colunas de fragmentos do mapa, se necess√°rio. </font><font style="vertical-align: inherit;">Com um pequeno mapa e uma c√¢mera remota, isso √© claramente vis√≠vel, mas em um mapa grande, fragmentos teletransportados est√£o fora do alcance de visualiza√ß√£o da c√¢mera. </font><font style="vertical-align: inherit;">Obviamente, apenas as bordas leste e oeste do mapa s√£o percept√≠veis, porque ainda n√£o h√° triangula√ß√£o entre elas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Remover a restri√ß√£o da sua coordenada X, a fim de minimizar e de c√¢mara </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em vez disso, continuaremos aumentando a coordenada X pela largura do mapa, enquanto estiver abaixo de zero, e reduzindo-a enquanto for maior que a largura do mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// float xMax = (grid.cellCountX - 0.5f) * HexMetrics.innerDiameter; // position.x = Mathf.Clamp(position.x, 0f, xMax); float width = grid.cellCountX * HexMetrics.innerDiameter; while (position.x &lt; 0f) { position.x += width; } while (position.x &gt; width) { position.x -= width; } float zMax = (grid.cellCountZ - 1) * (1.5f * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, 0f, zMax); grid.CenterMap(position.x); return position; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A c√¢mera de rolagem se move ao longo do mapa.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texturas de Shader dobr√°veis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com exce√ß√£o do espa√ßo de triangula√ß√£o, minimizar a c√¢mera no modo de jogo deve ser impercept√≠vel. No entanto, quando isso acontece, uma altera√ß√£o visual ocorre na metade da topografia e na √°gua. Isso acontece porque usamos uma posi√ß√£o no mundo para provar essas texturas. Um teletransporte n√≠tido do fragmento altera a localiza√ß√£o das texturas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos resolver esse problema fazendo as texturas aparecerem em blocos que s√£o m√∫ltiplos do tamanho do fragmento. O tamanho do fragmento √© calculado a partir das constantes </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto, vamos criar o arquivo de inclus√£o do sombreador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexMetrics.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e colar as defini√ß√µes correspondentes nele. A escala b√°sica de ladrilhos √© calculada a partir do tamanho do fragmento e do raio externo da c√©lula. Se voc√™ usar outras m√©tricas, precisar√° modificar o arquivo de acordo.</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_TO_INNER 0.866025404 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_RADIUS 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHUNK_SIZE_X 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TILING_SCALE (1 / (CHUNK_SIZE_X * 2 * OUTER_RADIUS / OUTER_TO_INNER))</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso nos d√° uma escala de lado a lado de 0,00866025404. </font><font style="vertical-align: inherit;">Se usarmos um m√∫ltiplo inteiro desse valor, a texturiza√ß√£o n√£o ser√° afetada pelo teletransporte de fragmentos. </font><font style="vertical-align: inherit;">Al√©m disso, as texturas nas bordas leste e oeste do mapa se unir√£o perfeitamente depois que triangularmos corretamente sua conex√£o. </font><font style="vertical-align: inherit;">Usamos 0,02 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como a escala UV no shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Em vez disso, podemos usar a escala de mosaico dobrado, que √© 0,01732050808. </font><font style="vertical-align: inherit;">A escala √© obtida um pouco menos do que era e a escala da textura aumentou um pouco, mas visualmente √© invis√≠vel.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3( <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE), <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] ); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para ru√≠do UV, usamos uma escala de 0,025. </font><font style="vertical-align: inherit;">Em vez disso, voc√™ pode usar a escala de mosaico triplo. </font><font style="vertical-align: inherit;">Isso nos d√° 0,02598076212, que √© bem pr√≥ximo.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, em </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usamos 0,015 para espuma e 0,025 para ondas. </font><font style="vertical-align: inherit;">Aqui, podemos novamente substituir esses valores por uma escala de ladrilhos dobrada e triplicada.</font></font><br><br><pre> <code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"HexMetrics.cginc"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Foam (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { shore = <span class="hljs-keyword"><span class="hljs-keyword">sqrt</span></span>(shore) * <span class="hljs-number"><span class="hljs-number">0.9</span></span>; float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; float4 <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span> = tex2D(noiseTex, noiseUV * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE)); ‚Ä¶ } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; float4 noise1 = tex2D(noiseTex, uv1 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); float2 uv2 = worldXZ; uv2.x += _Time.y; float4 noise2 = tex2D(noiseTex, uv2 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); ‚Ä¶ }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A uni√£o do leste e oeste </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse est√°gio, a √∫nica evid√™ncia visual de minimizar o mapa √© um pequeno espa√ßo entre as colunas mais a leste e mais a oeste. </font><font style="vertical-align: inherit;">Essa lacuna ocorre porque ainda n√£o triangulamos as conex√µes de arestas e √¢ngulos entre c√©lulas em lados opostos do mapa sem dobrar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/85f/e79/24085fe7986100674854b9c9a79c349c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espa√ßo na borda.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vizinhos dobr√°veis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para triangular a conex√£o leste-oeste, precisamos tornar as c√©lulas dos lados opostos pr√≥ximas umas das outras. </font><font style="vertical-align: inherit;">At√© o momento, n√£o estamos fazendo isso, porque a </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conex√£o E - W √© estabelecida com a c√©lula anterior apenas se seu √≠ndice em X for maior que zero. </font><font style="vertical-align: inherit;">Para recolher essa conex√£o, precisamos conectar a √∫ltima c√©lula da linha com a primeira na mesma linha ao dobrar o mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping &amp;&amp; x == cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.E, cells[i - x]); } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tendo estabelecido a conex√£o dos vizinhos E - W, obtemos uma triangula√ß√£o parcial da lacuna. </font><font style="vertical-align: inherit;">A conex√£o das arestas n√£o √© ideal, porque a distor√ß√£o est√° oculta incorretamente. </font><font style="vertical-align: inherit;">N√≥s vamos lidar com isso mais tarde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/68a/6b6/ce568a6b639801e47804eb35a62493c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compostos E - W. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m precisamos recolher os links NE - SW. </font><font style="vertical-align: inherit;">Isso pode ser feito conectando a primeira c√©lula de cada linha par com as √∫ltimas c√©lulas da linha anterior. </font><font style="vertical-align: inherit;">Ser√° apenas a c√©lula anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor(HexDirection.SW, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/239/66f/c3c/23966fc3c616ea9338a3a14d187dcc7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conex√µes NE - SW. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, as conex√µes SE - NW s√£o estabelecidas no final de cada linha √≠mpar abaixo da primeira. </font><font style="vertical-align: inherit;">Essas c√©lulas devem estar conectadas √† primeira c√©lula da linha anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor( HexDirection.SE, cells[i - cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e8/df4/62e/3e8df462e076bbdf93396f6cec525cc4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compostos SE - NW.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dobragem de ru√≠do </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ocultar perfeitamente a lacuna, precisamos garantir que as bordas leste e oeste do mapa correspondam ao ru√≠do perfeitamente usado para distorcer as posi√ß√µes dos v√©rtices. </font><font style="vertical-align: inherit;">Podemos usar o mesmo truque usado para shaders, mas uma escala de ru√≠do de 0,003 foi usada para distor√ß√£o. </font><font style="vertical-align: inherit;">Para garantir a telha, √© necess√°rio aumentar significativamente a escala, o que levar√° a uma distor√ß√£o mais ca√≥tica dos v√©rtices. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma solu√ß√£o alternativa n√£o √© reduzir o ru√≠do, mas sim atenuar o ru√≠do nas bordas do mapa. </font><font style="vertical-align: inherit;">Se voc√™ realizar uma atenua√ß√£o suave ao longo da largura de uma c√©lula, a distor√ß√£o criar√° uma transi√ß√£o suave sem intervalos. </font><font style="vertical-align: inherit;">O ru√≠do nessa √°rea ser√° suavizado e, a uma longa dist√¢ncia, a altera√ß√£o parecer√° n√≠tida, mas isso n√£o √© t√£o √≥bvio ao usar uma leve distor√ß√£o dos v√©rtices.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E as flutua√ß√µes de temperatura?</font></font></b> <div class="spoiler_text">           .      ,      .         ,   .     ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se n√£o recolhermos o cart√£o, podemos conviver com uma </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√∫nica amostra. </font><font style="vertical-align: inherit;">Mas ao dobrar, √© necess√°rio adicionar atenua√ß√£o. </font><font style="vertical-align: inherit;">Portanto, antes de retornar a amostra, salve-a em uma vari√°vel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sample; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao minimizar, precisamos misturar com a segunda amostra. </font><font style="vertical-align: inherit;">Como realizaremos a transi√ß√£o na parte leste do mapa, a segunda amostra precisa ser movida para o oeste.</font></font><br><br><pre> <code class="cs hljs"> Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A atenua√ß√£o √© realizada usando interpola√ß√£o linear simples da parte oeste para a parte leste, ao longo da largura de uma c√©lula. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/84f/75d/c4e84f75dd0260efb18a9d3d66647c55.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mistura de ru√≠do, uma solu√ß√£o imperfeita.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como resultado, n√£o obtemos uma correspond√™ncia exata, porque algumas das c√©lulas no lado leste t√™m coordenadas X negativas. Para n√£o se aproximar dessa √°rea, vamos mover a regi√£o de transi√ß√£o para o oeste, metade da largura da c√©lula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) - <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/af4/1fb/04faf41fb669427487a2dbb6855cd5bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atenua√ß√£o correta.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edi√ß√£o de C√©lulas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que a triangula√ß√£o parece correta, vamos ter certeza de que podemos editar tudo no mapa e na costura da dobra. Como se v√™, em fragmentos teletransportados, as coordenadas s√£o err√¥neas e os pinc√©is grandes s√£o cortados por uma costura.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/18b/5ce/a1f18b5ce7b87b38a7a58d47e341d4f1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O pincel √© aparado.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para corrigir isso, precisamos relatar a </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dobra. Podemos fazer isso combinando a coordenada X no m√©todo construtor. Sabemos que a coordenada axial X √© obtida a partir da coordenada X do deslocamento, subtraindo metade da coordenada Z. Voc√™ pode usar essas informa√ß√µes para realizar a transforma√ß√£o inversa e verificar se a coordenada zero √© menor que zero. Nesse caso, temos a coordenada al√©m do lado leste do mapa desdobrado. Como em cada dire√ß√£o n√≥s teleportamos n√£o mais do que a metade do mapa, ser√° suficiente adicionarmos o tamanho da dobra a X uma vez. E quando a coordenada de deslocamento √© maior que o tamanho da dobra, precisamos realizar uma subtra√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oX = x + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &gt;= HexMetrics.wrapSize) { x -= HexMetrics.wrapSize; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Äs vezes, ao editar a parte inferior ou superior do mapa, recebo erros </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso acontece quando, devido √† distor√ß√£o dos v√©rtices, o cursor aparece na linha de c√©lulas fora do mapa. </font><font style="vertical-align: inherit;">Este √© um erro que ocorre porque n√£o combinamos as coordenadas </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o par√¢metro vetorial. </font><font style="vertical-align: inherit;">Isso pode ser corrigido aplicando um m√©todo </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com coordenadas como par√¢metros que realizar√£o as verifica√ß√µes necess√°rias.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-comment"><span class="hljs-comment">// int index = // coordinates.X + coordinates.Z * cellCountX + coordinates.Z / 2; // return cells[index]; return GetCell(coordinates); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dobragem costeira </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A triangula√ß√£o funciona bem para o terreno, mas ao longo da costura leste-oeste n√£o existem bordas da costa da √°gua. </font><font style="vertical-align: inherit;">Na verdade, eles s√£o, eles simplesmente n√£o entram em colapso. </font><font style="vertical-align: inherit;">Eles s√£o virados e esticados para o outro lado do mapa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/20a/ed3/6fe20aed3cb0dea0a9e47ef08caa10f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falta a borda da √°gua. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso acontece porque, ao triangular a √°gua da costa, usamos a posi√ß√£o de um vizinho. </font><font style="vertical-align: inherit;">Para consertar isso, precisamos determinar com o que estamos lidando, localizado no outro lado do cart√£o. </font><font style="vertical-align: inherit;">Para simplificar a tarefa, adicionaremos uma </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coluna de c√©lula </font><font style="vertical-align: inherit;">√† </font><font style="vertical-align: inherit;">propriedade do √≠ndice.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ColumnIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribua este √≠ndice a </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">√â simplesmente igual √† coordenada de deslocamento X dividida pelo tamanho do fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.Index = i; cell.ColumnIndex = x / HexMetrics.chunkSizeX; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determinar o que √© minimizado comparando o √≠ndice da coluna da c√©lula atual e seu vizinho. </font><font style="vertical-align: inherit;">Se o √≠ndice da coluna do vizinho for menor que um passo a menos, estaremos no lado oeste e o vizinho no lado leste. </font><font style="vertical-align: inherit;">Portanto, precisamos virar nosso vizinho para o oeste. </font><font style="vertical-align: inherit;">O mesmo e na dire√ß√£o oposta.</font></font><br><br><pre> <code class="cs hljs"> Vector3 center2 = neighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/308/3ec/f133083ec9172168e5302d737fd0ce27.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costelas da costa, mas sem cantos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por isso, cuidamos das costelas da costa, mas at√© agora n√£o lid√°vamos com cantos. </font><font style="vertical-align: inherit;">Precisamos fazer o mesmo com o pr√≥ximo vizinho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 center3 = nextNeighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; } Vector3 v3 = center3 + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/c0d/751/d02c0d7510fba8b3707b89f146b71837.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costa adequadamente reduzida.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gera√ß√£o de cart√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A op√ß√£o de conectar os lados leste e oeste afeta a gera√ß√£o de mapas. </font><font style="vertical-align: inherit;">Ao minimizar o mapa, o algoritmo de gera√ß√£o tamb√©m deve ser minimizado. </font><font style="vertical-align: inherit;">Isso levar√° √† cria√ß√£o de outro mapa, mas ao usar uma </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">borda de mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diferente de zero </font><em><font style="vertical-align: inherit;">X, a</font></em><font style="vertical-align: inherit;"> dobra n√£o √© √≥bvia.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/01f/f90/54001ff900386d5f389850de0a1d0034.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/428/859/ecb/428859ecb5c5bf9a68b277675110e44b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa grande 1208905299 com configura√ß√µes padr√£o. Com dobr√°vel e sem ele.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando minimizado n√£o faz sentido usar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o Map Border o X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mas n√£o podemos simplesmente nos livrar disso, porque ao mesmo tempo as regi√µes se fundem. Ao minimizar, podemos usar apenas um </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RegionBorder</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s mudamos </font></font><code>HexMapGenerator.CreateRegions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, substituindo em todos os casos </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Essa nova vari√°vel ser√° igual a ou </font></font><code>regionBorder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dependendo do valor da op√ß√£o de recolhimento. Abaixo, mostrei as altera√ß√µes apenas no primeiro caso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> borderX = grid.wrapping ? regionBorder : mapBorderX; MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao mesmo tempo, as regi√µes permanecem separadas, mas isso √© necess√°rio apenas se houver regi√µes diferentes nos lados leste e oeste do mapa. </font><font style="vertical-align: inherit;">Existem dois casos em que isso n√£o √© respeitado. </font><font style="vertical-align: inherit;">A primeira √© quando temos apenas uma regi√£o. </font><font style="vertical-align: inherit;">A segunda √© quando h√° duas regi√µes dividindo o mapa horizontalmente. </font><font style="vertical-align: inherit;">Nesses casos, podemos atribuir um </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor zero, o que permitir√° que as massas de terra atravessem a costura leste-oeste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/4d4/c9e/db84d4c9e40c9e35ad29af69314f73e1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma regi√£o est√° entrando em colapso. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä primeira vista, parece que tudo funciona corretamente, mas h√° realmente uma lacuna ao longo da costura. </font><font style="vertical-align: inherit;">Isso se torna mais percept√≠vel se voc√™ definir a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Porcentagem de eros√£o para</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zero.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a4e/572/ef5a4e5722dbbb8af91e770220d7d141.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/f75/fce/6b3f75fce35d6be9c8a66c445c4dc9cd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando a eros√£o √© desativada, uma costura no relevo se torna percept√≠vel.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A diferen√ßa ocorre porque a costura impede o crescimento de fragmentos de al√≠vio. Para determinar o que √© adicionado primeiro, √© usada a dist√¢ncia da c√©lula ao centro do fragmento, e as c√©lulas do outro lado do mapa podem estar muito distantes, portanto quase nunca s√£o ativadas. Claro, isso est√° errado. Precisamos ter certeza de que </font></font><code>HexCoordinates.DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conhecemos o mapa minimizado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculamos a dist√¢ncia entre </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, somando as dist√¢ncias absolutas ao longo de cada um dos tr√™s eixos e reduzindo pela metade o resultado. A dist√¢ncia ao longo de Z √© sempre verdadeira, mas dobrar ao longo pode afetar as dist√¢ncias X e Y. Ent√£o, vamos come√ßar com um c√°lculo separado de X + Y.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return // ((x &lt; other.x ? other.x - x : x - other.x) + // (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + // (z &lt; other.z ? other.z - z : z - other.z)) / 2; int xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); return (xy + (z &lt; other.z ? other.z - z : z - other.z)) / 2; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determinar se a dobra cria uma dist√¢ncia menor para c√©lulas arbitr√°rias n√£o √© uma tarefa f√°cil, ent√£o vamos calcular X + Y para os casos em que estamos dobrando outra coordenada para o lado oeste. </font><font style="vertical-align: inherit;">Se o valor for menor que o X + Y original, use-o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se isso n√£o levar a uma dist√¢ncia menor, √© poss√≠vel diminuir a velocidade na outra dire√ß√£o, para que possamos verificar. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other.x -= <span class="hljs-number"><span class="hljs-number">2</span></span> * HexMetrics.wrapSize; xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora sempre obtemos a menor dist√¢ncia no mapa dobr√°vel. </font><font style="vertical-align: inherit;">Fragmentos de terreno n√£o s√£o mais bloqueados por uma costura, o que permite que as massas de terra se enrolem.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/fb7/3b8/65cfb73b8107d7744ff8cdcabaf48083.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/149/e6f/717/149e6f717defe9288565f37f7efcdf56.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√≠vio corretamente dobr√°vel, sem eros√£o e eros√£o. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viajando pelo mundo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depois de considerar a gera√ß√£o e triangula√ß√£o de mapas, passemos agora a verificar esquadr√µes, explora√ß√£o e visibilidade. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Costura de teste </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O primeiro obst√°culo que encontramos ao mover um esquadr√£o pelo mundo √© a borda do mapa, que n√£o pode ser explorada. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/4f4/748/4524f4748d2c4e3cb983ec5ecbf064c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A costura do cart√£o n√£o pode ser examinada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As c√©lulas ao longo da borda do mapa s√£o inexploradas para ocultar a conclus√£o abrupta do mapa. </font><font style="vertical-align: inherit;">Mas quando o mapa √© minimizado, apenas as c√©lulas norte e sul devem ser marcadas, mas n√£o o leste e o oeste. </font><font style="vertical-align: inherit;">Mude </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para levar isso em considera√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.Explorable = z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilidade dos recursos de relevo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos verificar se a visibilidade funciona ao longo da costura. </font><font style="vertical-align: inherit;">Funciona para terrenos, mas n√£o para objetos de terrenos. </font><font style="vertical-align: inherit;">Parece que objetos em colapso obt√™m a visibilidade da √∫ltima c√©lula que n√£o foi recolhida.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/ac1/811/631ac18111ba1eb8dfcf74a39fb2ffbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilidade incorreta dos objetos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso acontece porque o modo de </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fixa√ß√£o √© definido </font><font style="vertical-align: inherit;">para o modo de dobra de textura usado </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para resolver o problema, basta alterar o modo de fixa√ß√£o para repetir. </font><font style="vertical-align: inherit;">Mas precisamos fazer isso apenas para as coordenadas de U, portanto </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, definiremos </font></font><code>wrapModeU</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isso </font></font><code>wrapModeV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separadamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; <span class="hljs-comment"><span class="hljs-comment">// cellTexture.wrapMode = TextureWrapMode.Clamp; cellTexture.wrapModeU = TextureWrapMode.Repeat; cellTexture.wrapModeV = TextureWrapMode.Clamp; Shader.SetGlobalTexture("_HexCellData", cellTexture); } ‚Ä¶ }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esquadr√µes e Colunas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro problema √© que as unidades ainda n√£o est√£o desmoronando. </font><font style="vertical-align: inherit;">Depois de mover a coluna em que est√£o localizadas, as unidades permanecem no mesmo local.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/29b/827/c5029b8273d7b53a3ddac2da03d9987f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A unidade n√£o √© transferida e est√° do lado errado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse problema pode ser resolvido transformando os esquadr√µes em elementos filhos de colunas, como fizemos com os fragmentos. </font><font style="vertical-align: inherit;">Primeiro, n√£o os tornaremos os filhos imediatos da rede </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// unit.transform.SetParent(transform, false); unit.Location = location; unit.Orientation = orientation; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como as unidades est√£o se movendo, elas podem aparecer em outra coluna, ou seja, ser√° necess√°rio alterar seus pais. </font><font style="vertical-align: inherit;">Para tornar isso poss√≠vel, adicionamos ao </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo geral </font></font><code>MakeChildOfColumn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, como par√¢metros, passamos a ele o componente do </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento filho e o √≠ndice da coluna.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeChildOfColumn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> columnIndex</span></span></span><span class="hljs-function">)</span></span> { child.SetParent(columns[columnIndex], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos chamar esse m√©todo quando a propriedade estiver configurada </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ Grid.MakeChildOfColumn(transform, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ColumnIndex); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso resolve o problema de criar unidades. </font><font style="vertical-align: inherit;">Mas tamb√©m precisamos faz√™-los mover para a coluna desejada ao se mover. </font><font style="vertical-align: inherit;">Para fazer isso, voc√™ precisa acompanhar </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a coluna atual </font><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">√≠ndice. </font><font style="vertical-align: inherit;">No in√≠cio desse m√©todo, este √© o √≠ndice da coluna da c√©lula no in√≠cio do caminho, ou o atual se a movimenta√ß√£o foi interrompida pela recompila√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Grid.DecreaseVisibility( // currentTravelLocation ? currentTravelLocation : pathToTravel[0], // VisionRange // ); if (!currentTravelLocation) { currentTravelLocation = pathToTravel[0]; } Grid.DecreaseVisibility(currentTravelLocation, VisionRange); int currentColumn = currentTravelLocation.ColumnIndex; ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durante cada itera√ß√£o da movimenta√ß√£o, verificaremos se o √≠ndice da pr√≥xima coluna √© diferente e, se for, mudaremos o pai da ordem. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { ‚Ä¶ Grid.IncreaseVisibility(pathToTravel[i], VisionRange); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentColumn != nextColumn) { Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso permitir√° que as unidades se movam de maneira semelhante aos fragmentos. </font><font style="vertical-align: inherit;">No entanto, ao se mover pela costura do cart√£o, as unidades ainda n√£o entram em colapso. </font><font style="vertical-align: inherit;">Em vez disso, eles de repente come√ßam a se mover na dire√ß√£o errada. </font><font style="vertical-align: inherit;">Isso acontece independentemente da localiza√ß√£o da costura, mas mais notavelmente quando eles pulam o mapa inteiro.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corridas de cavalos pelo mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui podemos usar a mesma abordagem usada para a costa, s√≥ que desta vez faremos a curva pela qual o desapego se move. </font><font style="vertical-align: inherit;">Se a pr√≥xima coluna for virada para leste, teleportaremos a curva tamb√©m para leste, da mesma forma para a outra dire√ß√£o. </font><font style="vertical-align: inherit;">Voc√™ precisa alterar os pontos de controle da curva </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o que tamb√©m afetar√° o ponto de controle </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// c = (b + currentTravelLocation.Position) * 0.5f; // Grid.IncreaseVisibility(pathToTravel[i], VisionRange); int nextColumn = currentTravelLocation.ColumnIndex; if (currentColumn != nextColumn) { if (nextColumn &lt; currentColumn - 1) { ax -= HexMetrics.innerDiameter * HexMetrics.wrapSize; bx -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } else if (nextColumn &gt; currentColumn + 1) { ax += HexMetrics.innerDiameter * HexMetrics.wrapSize; bx += HexMetrics.innerDiameter * HexMetrics.wrapSize; } Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } c = (b + currentTravelLocation.Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], VisionRange); ‚Ä¶ }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movimento com dobradura.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A √∫ltima coisa a fazer √© mudar o turno inicial do esquadr√£o quando ele olha para a primeira c√©lula na qual se mover√°. Se esta c√©lula estiver do outro lado da costura leste-oeste, a unidade olhar√° na dire√ß√£o errada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao minimizar um mapa, h√° duas maneiras de observar um ponto que n√£o est√° exatamente no norte ou no sul. Voc√™ pode olhar para o leste ou oeste. Ser√° l√≥gico olhar na dire√ß√£o correspondente √† dist√¢ncia mais pr√≥xima do ponto, porque tamb√©m √© a dire√ß√£o do movimento, ent√£o vamos us√°-lo </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao minimizar, verificaremos a dist√¢ncia relativa ao longo do eixo X. Se for menor que a metade negativa da largura do mapa, devemos olhar para o oeste, o que pode ser feito girando o ponto para o oeste. </font><font style="vertical-align: inherit;">Caso contr√°rio, se a dist√¢ncia for mais da metade da largura do mapa, devemos entrar em colapso para o leste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDistance = point.x - transform.localPosition.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &lt; -HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x += HexMetrics.innerDiameter * HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &gt; HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, temos um mapa minimizado totalmente funcional. </font><font style="vertical-align: inherit;">E isso conclui a s√©rie de tutoriais em mapas hexagonais. </font><font style="vertical-align: inherit;">Como mencionado nas se√ß√µes anteriores, outros t√≥picos podem ser considerados, mas n√£o s√£o espec√≠ficos para mapas hexagonais. </font><font style="vertical-align: inherit;">Talvez eu os considere em futuras s√©ries de tutoriais.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baixei o √∫ltimo pacote e recebo erros de turnos no modo Play</font></font></b> <div class="spoiler_text">  ,       <em>Rotation</em> .    .  .   5. </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baixei o √∫ltimo pacote e os gr√°ficos n√£o s√£o t√£o bonitos quanto nas capturas de tela</font></font></b> <div class="spoiler_text">        . -    . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baixei o √∫ltimo pacote e ele gera constantemente o mesmo cart√£o</font></font></b> <div class="spoiler_text">      seed (1208905299),      .    ,  <em>Use Fixed Seed</em> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427567/">https://habr.com/ru/post/pt427567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427555/index.html">Animais que os humanos aprenderam a rastrear usando a tecnologia de reconhecimento facial</a></li>
<li><a href="../pt427557/index.html">Resumo dos eventos de TI em novembro (primeira parte)</a></li>
<li><a href="../pt427561/index.html">Direito de reparo: os primeiros passos na dire√ß√£o certa da Motorola</a></li>
<li><a href="../pt427563/index.html">Padr√£o SNI criptografado implementado no Firefox Nightly</a></li>
<li><a href="../pt427565/index.html">‚ÄúMinha conquista foi que geralmente voltei √† profiss√£o‚Äù - 10 perguntas ao programador, edi√ß√£o 10</a></li>
<li><a href="../pt427569/index.html">Ajuste o OpenStack sob alta carga</a></li>
<li><a href="../pt427571/index.html">A uni√£o do R e do PostgreSQL. Analisamos o trabalho dos aeroportos, calculamos pens√µes</a></li>
<li><a href="../pt427573/index.html">Candy or Life: Halloween como uma raz√£o para atrair seu filho para a ci√™ncia</a></li>
<li><a href="../pt427575/index.html">Por que o Wi-Fi n√£o funcionar√° conforme o planejado e por que saber qual telefone o funcion√°rio usa</a></li>
<li><a href="../pt427577/index.html">Aprendizado de m√°quina versus an√°lise de assinatura ao detectar ataques em um aplicativo Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>