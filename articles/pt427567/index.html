<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏼 👳🏿 🧓🏽 Mapas hexagonais no Unity: ciclo da água, erosão, biomas, mapa cilíndrico 👦🏽 🏇🏾 👩🏼‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes 1-3: malha, cores e altura das células 

 Partes 4-7: solavancos, rios e estradas 

 Peças 8-11: água, formas terrestres e muralhas 

 Peças 12...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas hexagonais no Unity: ciclo da água, erosão, biomas, mapa cilíndrico</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427567/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 1-3: malha, cores e altura das células</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 4-7: solavancos, rios e estradas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Peças 8-11: água, formas terrestres e muralhas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Peças 12-15: salvar e carregar, texturas, distâncias</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 16-19: encontrando o caminho, esquadrões de jogadores, animações</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 20-23: Nevoeiro da Guerra, Pesquisa de Mapas, Geração de Procedimentos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 24-27: ciclo da água, erosão, biomas, mapa cilíndrico</a> <br><br><h1>  Parte 24: regiões e erosão </h1><br><ul><li>  Adicione uma borda de água ao redor do mapa. </li><li>  Dividimos o mapa em várias regiões. </li><li>  Usamos a erosão para cortar falésias. </li><li>  Nós movemos a terra para suavizar o alívio. </li></ul><br>  Na parte anterior, lançamos as bases para a geração de mapas procedurais.  Desta vez, limitaremos os locais de possível ocorrência de terra e agiremos sobre ela com erosão. <br><br>  Este tutorial foi criado no Unity 2017.1.0. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/6a5/30c/5ac6a530cef3718f9031abe862364093.jpg"></div><br>  <i>Separe e alise a terra.</i> <br><a name="habracut"></a><br><h2>  Borda do mapa </h2><br>  Como aumentamos as áreas de terra aleatoriamente, pode acontecer que a terra toque a borda do mapa.  Isso pode ser indesejável.  O mapa de água limitada contém uma barreira natural que impede que os jogadores se aproximem da borda.  Portanto, seria bom se proibíssemos que a terra subisse acima do nível da água perto da borda do mapa. <br><br><h3>  Tamanho da borda </h3><br>  Quão perto o terreno deve estar da borda do mapa?  Não há resposta certa para essa pergunta, portanto, tornaremos esse parâmetro personalizável.  Adicionaremos dois controles deslizantes ao componente <code>HexMapGenerator</code> , um para bordas ao longo das bordas ao longo do eixo X e outro para bordas ao longo do eixo Z. Assim, podemos usar uma borda mais larga em uma das dimensões ou até criar uma borda em apenas uma dimensão.  Vamos usar um intervalo de 0 a 10 com um valor padrão de 5. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderX = <span class="hljs-number"><span class="hljs-number">5</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/8ab/c74/6948abc743e881596bdea5656e562943.png"></div><br>  <i>Controles deslizantes de bordas.</i> <br><br><h3>  Limitamos os centros de áreas terrestres </h3><br>  Sem bordas, todas as células são válidas.  Quando existem limites, as coordenadas de deslocamento mínimas permitidas aumentam e as coordenadas máximas permitidas diminuem.  Como para gerar os gráficos, precisaremos conhecer o intervalo permitido, vamos controlá-lo usando quatro campos inteiros. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xMin, xMax, zMin, zMax;</code> </pre> <br>  Inicializamos as restrições no <code>GenerateMap</code> antes de criar o sushi.  Usamos esses valores como parâmetros para chamadas <code>Random.Range</code> , para que os altos sejam realmente excepcionais.  Sem uma borda, eles são iguais ao número de células de medição, portanto, não menos 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } xMin = mapBorderX; xMax = x - mapBorderX; zMin = mapBorderZ; zMax = z - mapBorderZ; CreateLand(); … }</code> </pre> <br>  Não proibiremos estritamente a aparência de terras além da fronteira, porque isso criaria bordas bem cortadas.  Em vez disso, limitaremos apenas as células usadas para iniciar a geração de plotagens.  Ou seja, os centros aproximados dos locais serão limitados, mas partes dos locais poderão ir além da área de fronteira.  Isso pode ser feito modificando <code>GetRandomCell</code> para selecionar uma célula no intervalo de compensações permitidas. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return grid.GetCell(Random.Range(0, cellCount)); return grid.GetCell(Random.Range(xMin, xMax), Random.Range(zMin, zMax)); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/bbf/24b/7a8bbf24b1d46d9b97e8e9c01652fdfd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/0cf/aa2/a310cfaa2bec1cbe019a08c14218c7fd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f1/799/f50/7f1799f5058c0d1e435bfc3c42133b9c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/c4b/1b7/93ac4b1b771eaa896b6c494b69c18b92.jpg"></div><br>  <i>As bordas do mapa são 0 × 0, 5 × 5, 10 × 10 e 0 × 10.</i> <br><br>  Quando todos os parâmetros do mapa são definidos com seus valores padrão, uma borda do tamanho 5 protege de maneira confiável a borda do mapa do contato com a terra.  No entanto, isso não é garantido.  Às vezes, a terra pode chegar perto da borda e, às vezes, tocá-la em vários lugares. <br><br>  A probabilidade de a terra cruzar toda a borda depende do tamanho da borda e do tamanho máximo do site.  Sem hesitar, as seções permanecem hexágonos.  Hexágono completo com raio <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.049ex" height="1.455ex" viewBox="0 -520.7 451.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> r </script>  contém <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.32ex" height="2.539ex" viewBox="0 -935.7 5304.3 1093.4" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="1628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-33" x="2628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="3129" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="3803" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="4803" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 3r ^ 2 + 3r + 1 </script>  células.  Se houver hexágonos com um raio igual ao tamanho da borda, eles poderão cruzá-lo.  Um hexágono completo com um raio de 5 contém 91 células.  Como, por padrão, o máximo é de 100 células por seção, isso significa que o terreno poderá estabelecer uma ponte entre 5 células, especialmente se houver vibrações.  Para impedir que isso aconteça, reduza o tamanho máximo da plotagem ou aumente o tamanho da borda. <br><br><div class="spoiler">  <b class="spoiler_title">Como é derivada a fórmula para o número de células na região hexagonal?</b> <div class="spoiler_text">  Com um raio de 0, estamos lidando com uma única célula.  Veio de 1. Com um raio de 1 em torno do centro, existem seis células adicionais, ou seja <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.165ex" height="2.211ex" viewBox="0 -772.3 2223.9 952" role="img" focusable="false" style="vertical-align: -0.417ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="722" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="1723" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> 6 + 1 </script>  .  Essas seis células podem ser consideradas as extremidades de seis triângulos tocando o centro.  Com um raio de 2, uma segunda linha é adicionada a esses triângulos, ou seja, mais duas células são obtidas no triângulo e, no total, <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.14ex" height="2.762ex" viewBox="0 -831.5 5226.9 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="3113" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="3725" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="4726" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> 6 (1 + 2) + 1 </script>  .  Com um raio de 3, uma terceira linha é adicionada, ou seja, mais três células por triângulo e no total <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.143ex" height="2.762ex" viewBox="0 -831.5 6950.3 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="3336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-33" x="4336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="4837" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="5449" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="6449" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-5"> 6 (1 + 2 + 3) + 1 </script>  .  E assim por diante  Ou seja, em termos gerais, a fórmula parece <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mi>o</mi><mi>m</mi><msub><mi>a</mi><mo stretchy=&quot;false&quot;>(</mo></msub><mi>i</mi><mo>=</mo><mn>1</mn><msup><mo stretchy=&quot;false&quot;>)</mo><mi>r</mi></msup><mi>i</mi><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="74.787ex" height="3.312ex" viewBox="0 -950 32199.9 1426" role="img" focusable="false" style="vertical-align: -1.106ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-73" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-6F" x="1359" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-6D" x="1845" y="0"></use><g transform="translate(2723,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="748" y="-264"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-69" x="3628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-3D" x="4251" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="5307" y="0"></use><g transform="translate(5808,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-69" x="6617" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="6962" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="7574" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="8575" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-3D" x="9353" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-36" x="10409" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="10910" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="11299" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="11689" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="12140" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="12530" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="13203" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="14204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="14705" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="15094" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2F" x="15484" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-32" x="15984" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="16485" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="17096" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="18097" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-3D" x="18875" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-33" x="19932" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="20432" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-28" x="20884" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="21273" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="21947" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="22948" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-29" x="23448" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="24060" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="25061" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-3D" x="25839" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-33" x="26895" y="0"></use><g transform="translate(27396,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="28523" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-33" x="29524" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMATHI-72" x="30024" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-2B" x="30698" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhTLjmJNm2ouKWGpzMWs62OqCso0A#MJMAIN-31" x="31699" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mi>s</mi><mi>o</mi><mi>m</mi><msub><mi>a</mi><mo stretchy="false">(</mo></msub><mi>i</mi><mo>=</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>r</mi></msup><mi>i</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mi>r</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-6"> 6 (soma_ (i = 1) ^ r i) +1 = 6 ((r (r + 1)) / 2) +1 = 3r (r + 1) + 1 = 3r ^ 2 + 3r + 1 </script>  . </div></div><br>  Para ver isso mais claramente, podemos definir o tamanho da borda como 200. Como um hexágono completo com um raio de 8 contém 217 células, é provável que o terreno toque a borda do mapa.  Pelo menos se você usar o valor padrão do tamanho da borda (5).  Se você aumentar a borda para 10, a probabilidade diminuirá bastante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/75d/eb0/74b75deb060d9bdae2f74c1db4de287e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffa/7ce/e96/ffa7cee967f81ba9fe4ddc6718519d9a.jpg"></div><br>  <i>O terreno tem um tamanho constante de 200, as bordas do mapa são 5 e 10.</i> <br><br><h3>  Pangea </h3><br>  Observe que, quando você aumenta a borda do mapa e mantém a mesma porcentagem de terra, forçamos a terra a formar uma área menor.  Como resultado disso, é muito provável que um mapa grande, por padrão, crie uma única grande massa de terra - o supercontinente Pangea - possivelmente com várias pequenas ilhas.  Com um aumento no tamanho da fronteira, a probabilidade disso aumenta e, em certos valores, estamos quase garantidos para obter um supercontinente.  No entanto, quando a porcentagem de terra é muito grande, a maioria das áreas disponíveis é preenchida e, como resultado, obtemos uma massa quase retangular de terra.  Para impedir que isso aconteça, você precisa reduzir a porcentagem de terra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/d84/209/e1bd8420915ccc74cd3470409b9a4236.jpg"></div><br>  <i>Sushi de 40% com uma borda de cartão de 10.</i> <br><br><div class="spoiler">  <b class="spoiler_title">De onde veio o nome Pangea?</b> <div class="spoiler_text">  Esse era o nome do último supercontinente conhecido que existia na Terra há muitos anos.  O nome é composto pelas palavras gregas pan e Gaia, que significam algo como "toda a natureza" ou "toda a terra". </div></div><br><br><h3>  Protegemos de cartões impossíveis </h3><br>  Geramos a quantidade certa de terra simplesmente continuando a elevar a terra até atingirmos a massa desejada.  Isso funciona porque, mais cedo ou mais tarde, elevaremos cada célula no nível da água.  No entanto, ao usar a borda do mapa, não podemos alcançar todas as células.  Quando uma porcentagem muito alta de terra é necessária, isso leva a inúmeras tentativas e falhas do gerador para elevar mais terra e fica preso em um ciclo sem fim.  Nesse caso, o aplicativo irá congelar, mas isso não deve acontecer. <br><br>  Não podemos encontrar com segurança configurações impossíveis com antecedência, mas podemos nos proteger de ciclos intermináveis.  Simplesmente rastrearemos o número de ciclos executados no <code>CreateLand</code> .  Se houver muitas iterações, provavelmente estamos travados e devemos parar. <br><br>  Para um mapa grande, mil iterações parecem aceitáveis ​​e dez mil iterações já parecem absurdas.  Então, vamos usar esse valor como um ponto de terminação. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// while (landBudget &gt; 0) { for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); … } }</span></span></code> </pre> <br>  Se obtivermos um mapa danificado, a execução de 10.000 iterações não levará muito tempo, porque muitas células atingirão rapidamente a altura máxima, o que impedirá o crescimento de novas áreas. <br><br>  Mesmo depois de quebrar o ciclo, ainda temos o mapa certo.  Ele simplesmente não tem a quantidade certa de sushi e não parecerá muito interessante.  Vamos exibir uma notificação sobre isso no console, informando o terreno restante que não conseguimos gastar. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab5/87f/f4f/ab587ff4f560fe6c1c0d7d5a547ae2b7.jpg"></div><br>  <i>95% das terras com uma borda de cartão de 10 não podiam gastar a quantia inteira.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Por que um cartão com falha ainda tem variação?</b> <div class="spoiler_text">  O litoral tem variabilidade, porque quando as alturas dentro da área de criação se tornam muito altas, novas áreas não permitem que elas cresçam para fora.  O mesmo princípio não permite que as parcelas se transformem em pequenas áreas de terra, até atingirem a altura máxima e simplesmente desaparecerem.  Além disso, a variabilidade aumenta ao diminuir as parcelas. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Particionando um cartão </h2><br>  Agora que temos a borda do mapa, basicamente dividimos o mapa em duas regiões separadas: a região da borda e a região em que os gráficos foram criados.  Como apenas a região de criação é importante para nós, podemos considerar esse caso uma situação com uma região.  A região simplesmente não cobre o mapa inteiro.  Mas se isso for impossível, nada nos impede de dividir o mapa em várias regiões desconectadas da criação de terras.  Isso permitirá que as massas de terra se formem independentemente uma da outra, designando diferentes continentes. <br><br><h3>  Região do mapa </h3><br>  Vamos começar descrevendo uma região do mapa como uma estrutura.  Isso simplificará nosso trabalho com várias regiões.  Vamos criar uma estrutura <code>MapRegion</code> para isso, que simplesmente contém os campos de borda da região.  Como não usaremos essa estrutura fora do <code>HexMapGenerator</code> , podemos defini-la dentro desta classe como uma estrutura interna privada.  Em seguida, quatro campos inteiros podem ser substituídos por um campo <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int xMin, xMax, zMin, zMax; struct MapRegion { public int xMin, xMax, zMin, zMax; } MapRegion region;</span></span></code> </pre> <br>  Para que tudo funcione, precisamos adicionar o prefixo da <code>region.</code> aos campos mínimo-máximo no <code>GenerateMap</code> <code>region.</code>  . <br><br><pre> <code class="cs hljs"> region.xMin = mapBorderX; region.xMax = x - mapBorderX; region.zMin = mapBorderZ; region.zMax = z - mapBorderZ;</code> </pre> <br>  E também no <code>GetRandomCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br><h3>  Várias regiões </h3><br>  Para oferecer suporte a várias regiões, substitua um campo <code>MapRegion</code> lista de regiões. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// MapRegion region; List&lt;MapRegion&gt; regions;</span></span></code> </pre> <br>  Nesse momento, seria bom adicionar um método separado para criar regiões.  Ele deve criar a lista desejada ou limpá-la, se ela já existir.  Depois disso, ele determinará uma região, como fizemos anteriormente, e a adicionará à lista. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRegions</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regions == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { regions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MapRegion&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { regions.Clear(); } MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br>  Vamos chamar esse método no <code>GenerateMap</code> e não criaremos a região diretamente. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// region.xMin = mapBorderX; // region.xMax = x - mapBorderX; // region.zMin = mapBorderZ; // region.zMax = z - mapBorderZ; CreateRegions(); CreateLand();</span></span></code> </pre> <br>  Para que <code>GetRandomCell</code> possa trabalhar com uma região arbitrária, forneça o parâmetro <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MapRegion region</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br>  Agora os <code>SinkTerrain</code> e <code>SinkTerrain</code> devem passar a região correspondente para <code>GetRandomCell</code> .  Para fazer isso, cada um deles também precisa de um parâmetro de região. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); … }</code> </pre> <br>  O método <code>CreateLand</code> deve determinar para cada região aumentar ou diminuir as seções.  Para equilibrar a terra entre as regiões, simplesmente percorreremos repetidamente a lista de regiões do ciclo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget, region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br>  No entanto, ainda precisamos fazer a redução das parcelas uniformemente distribuídas.  Isso pode ser feito ao decidir para todas as regiões se deve omiti-las. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if (Random.value &lt; sinkProbability) { if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } }</span></span></code> </pre> <br>  Finalmente, para usar exatamente toda a quantidade de terra, precisamos interromper o processo assim que a quantidade chegar a zero.  Isso pode acontecer em qualquer estágio do ciclo da região.  Portanto, movemos a verificação de soma zero para o loop interno.  De fato, só podemos realizar essa verificação depois de levantar o terreno, porque ao diminuir, o valor nunca é gasto.  Se terminarmos, podemos sair imediatamente do método <code>CreateLand</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { for (int guard = 0; guard &lt; 10000; guard++) { bool sink = Random.value &lt; sinkProbability; for (int i = 0; i &lt; regions.Count; i++) { MapRegion region = regions[i]; int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); if (landBudget == 0) { return; } } } }</span></span></code> </pre> <br><h3>  Duas regiões </h3><br>  Embora agora tenhamos o apoio de várias regiões, ainda pedimos apenas uma.  Vamos alterar o <code>CreateRegions</code> para que ele divida o mapa ao meio verticalmente.  Para fazer isso, <code>xMax</code> pela metade o valor <code>xMax</code> da região adicionada.  Em seguida, usamos o mesmo valor para <code>xMin</code> e novamente usamos o valor original para <code>xMax</code> , usando-o como a segunda região. <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br>  A geração de cartões nesta fase não fará nenhuma diferença.  Embora tenhamos identificado duas regiões, elas ocupam a mesma região que uma região antiga.  Para separá-los, você precisa deixar um espaço vazio entre eles.  Isso pode ser feito adicionando um controle deslizante à borda da região, usando o mesmo intervalo e valor padrão das bordas do mapa. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionBorder = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/cd2/cd0/9ffcd2cd0f4068caf622e433c503715d.png"></div><br>  <i>Controle deslizante de borda da região.</i> <br><br>  Como a terra pode ser formada em ambos os lados do espaço entre as regiões, a probabilidade de criar pontes de terra nas bordas do mapa aumentará.  Para evitar isso, usamos a borda da região para definir uma zona livre de terra entre a linha divisória e a região na qual as parcelas podem começar.  Isso significa que a distância entre regiões vizinhas é duas vezes maior que o tamanho da fronteira da região. <br><br>  Para aplicar esse limite de região, subtraia-o do <code>xMax</code> primeira região e adicione a segunda região ao <code>xMin</code> . <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/1f6/476/1e51f6476894662d55f7ca9748dc7fa5.jpg"></div><br>  <i>O mapa é dividido verticalmente em duas regiões.</i> <br><br>  Com as configurações padrão, serão criadas duas regiões visivelmente separadas; no entanto, como no caso de uma região e uma grande borda do mapa, não temos garantia de receber exatamente duas massas de terra.  Na maioria das vezes, serão dois grandes continentes, possivelmente com várias ilhas.  Mas, às vezes, duas ou mais ilhas grandes podem ser criadas em uma região.  E, às vezes, dois continentes podem ser conectados por um istmo. <br><br>  Obviamente, também podemos dividir o mapa horizontalmente, alterando as abordagens para medir X e Z. Vamos escolher aleatoriamente uma das duas orientações possíveis. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/970/c91/f23970c91cdd9c539ebdc8c7fdbba05f.jpg"></div><br>  <i>Mapa dividido horizontalmente em duas regiões.</i> <br><br>  Como usamos um mapa amplo, regiões mais amplas e finas serão criadas com separação horizontal.  Como resultado, é mais provável que essas regiões formem várias massas de terra divididas. <br><br><h3>  Quatro regiões </h3><br>  Vamos personalizar o número de regiões, criar suporte de 1 a 4 regiões. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 4)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionCount = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/918/49e/2a4/91849e2a4ffe6091b8d4fdf0d78b0c45.png"></div><br>  <i>Controle deslizante para o número de regiões.</i> <br><br>  Podemos usar a <code>switch</code> para selecionar a execução do código de região correspondente.  Começamos repetindo o código de uma região, que será usada por padrão, e deixamos o código de duas regiões para o caso 2. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Qual é a instrução switch?</b> <div class="spoiler_text">  Essa é uma alternativa para escrever uma sequência de instruções if-else-if-else.  A opção é aplicada à variável e os rótulos são usados ​​para indicar qual código precisa ser executado.  Há também um rótulo <code>default</code> , que é usado como o último bloco <code>else</code> .  Cada opção deve terminar com uma declaração de <code>break</code> ou uma <code>return</code> . <br><br>  Para manter o bloco de <code>switch</code> legível, geralmente é melhor manter todos os casos curtos, idealmente com uma única instrução ou chamada de método.  Não o farei como um exemplo de código de região, mas se você deseja criar regiões mais interessantes, recomendo que você use métodos separados.  Por exemplo: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: CreateOneRegion(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: CreateTwoRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: CreateThreeRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: CreateFourRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> </div></div><br>  Três regiões são semelhantes a duas, apenas terços são usados ​​em vez da metade.  Nesse caso, a divisão horizontal criará regiões muito estreitas; portanto, criamos suporte apenas para a divisão vertical.  Observe que, como resultado, dobramos a área de borda da região, portanto, o espaço para a criação de novas seções é menor do que no caso de duas regiões. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: … <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: … <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/2e7/cc8/2342e7cc8cb524f4f9db803d5359a78e.jpg"></div><br>  <i>Três regiões</i> <br><br>  É possível criar quatro regiões combinando a separação horizontal e vertical e adicionando uma região a cada canto do mapa. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { … <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/551/b72/a0c/551b72a0ca2f12a5636828faa4c3febc.jpg"></div><br>  <i>Quatro regiões.</i> <br><br>  A abordagem usada aqui é a maneira mais simples de dividir um mapa.  Ele gera aproximadamente as mesmas regiões por massa de terra e sua variabilidade é controlada por outros parâmetros de geração de mapas.  No entanto, sempre será bastante óbvio que o cartão foi dividido em linhas retas.  Quanto mais controle precisamos, menos orgânico será o resultado.  Portanto, isso é normal se você precisar de regiões aproximadamente iguais para a jogabilidade.  Mas se você precisar da terra mais variada e ilimitada, precisará fazê-la com a ajuda de uma região. <br><br>  Além disso, existem outras maneiras de dividir o mapa.  Não podemos nos limitar apenas a linhas retas.  Nem precisamos usar regiões do mesmo tamanho, além de cobrir o mapa inteiro com elas.  Nós podemos deixar buracos.  Você também pode permitir interseções de regiões ou alterar a distribuição de terras entre regiões.  Você pode até definir seus próprios parâmetros de gerador para cada região (embora isso seja mais complicado), por exemplo, para ter um grande continente e um arquipélago no mapa. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Erosão </h2><br>  Até agora, todas as cartas que geramos pareciam rudes e quebradas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um alívio real pode ser assim, mas com o tempo se torna cada vez mais suave, suas partes afiadas ficam embotadas devido à erosão. </font><font style="vertical-align: inherit;">Para melhorar os mapas, podemos aplicar esse processo de erosão. </font><font style="vertical-align: inherit;">Faremos isso depois de criar terrenos acidentados, em um método separado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); SetTerrainType(); … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Percentagem de erosão </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quanto mais o tempo passa, mais erosão aparece. </font><font style="vertical-align: inherit;">Portanto, queremos que a erosão não seja permanente, mas personalizável. </font><font style="vertical-align: inherit;">No mínimo, a erosão é zero, o que corresponde aos mapas criados anteriormente. </font><font style="vertical-align: inherit;">Quando a erosão máxima é abrangente, ou seja, a aplicação posterior das forças de erosão não mudará mais o terreno. </font><font style="vertical-align: inherit;">Ou seja, o parâmetro erosion deve ser uma porcentagem de 0 a 100 e, por padrão, usaremos 50.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erosionPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/efe/e5e/c4eefee5e18aeee36f16e6aee98a27fe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle deslizante de erosão.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Procurar células destruidoras de erosão </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A erosão torna o alívio mais suave. No nosso caso, as únicas partes afiadas são as falésias. Portanto, eles serão o alvo do processo de erosão. Se existir um penhasco, a erosão deve reduzi-lo até que finalmente se transforme em um declive. Não suavizaremos as encostas, porque isso levará a um terreno chato. Para fazer isso, precisamos determinar quais células estão no topo dos penhascos e diminuir sua altura. Estas serão células propensas à erosão.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos criar um método que determine se uma célula pode ser propensa a erosão. </font><font style="vertical-align: inherit;">Ele determina isso verificando os vizinhos da célula até encontrar uma diferença de altura suficientemente grande. </font><font style="vertical-align: inherit;">Como as falésias exigem uma diferença de pelo menos um ou dois níveis de altura, a célula está sujeita a erosão se um ou mais de seus vizinhos estiver a pelo menos dois passos abaixo dela. </font><font style="vertical-align: inherit;">Se não houver tal vizinho, a célula não poderá sofrer erosão.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsErodible</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar esse método </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para percorrer todas as células e gravar todas as células propensas à erosão em uma lista temporária.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(cell)) { erodibleCells.Add(cell); } } ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de conhecer o número total de células propensas à erosão, podemos usar a porcentagem de erosão para determinar o número de células propensas à erosão restantes. </font><font style="vertical-align: inherit;">Por exemplo, se a porcentagem for 50, precisamos danificar as células até que metade da quantidade original permaneça. </font><font style="vertical-align: inherit;">Se a porcentagem for 100, não pararemos até destruirmos todas as células propensas à erosão.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não devemos considerar apenas as células propensas à erosão da terra?</font></font></b> <div class="spoiler_text">     .    ,       ,     . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Redução de células </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos começar com uma abordagem ingênua e supor que uma simples redução na altura das células destruídas pela erosão deixará de ser mais propensa à erosão. </font><font style="vertical-align: inherit;">Se isso fosse verdade, poderíamos simplesmente pegar células aleatórias da lista, reduzir sua altura e removê-las da lista. </font><font style="vertical-align: inherit;">Repetiríamos essa operação até atingirmos o número desejado de células suscetíveis à erosão.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (erodibleCells.Count &gt; targetErodibleCount) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, erodibleCells.Count); HexCell cell = erodibleCells[index]; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; erodibleCells.Remove(cell); } ListPool&lt;HexCell&gt;.Add(erodibleCells);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para impedir a pesquisa necessária </font></font><code>erodibleCells.Remove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, substituiremos a célula atual por último na lista e excluiremos o último elemento. </font><font style="vertical-align: inherit;">Ainda não nos importamos com o pedido deles.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// erodibleCells.Remove(cell); erodibleCells[index] = erodibleCells[erodibleCells.Count - 1]; erodibleCells.RemoveAt(erodibleCells.Count - 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/050/66c/50e05066c444e6854c622b865fde2726.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/fca/6b4/14dfca6b41ce23cdeb3e5fc4d5307eba.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diminuição ingênua de 0% e 100% de células propensas à erosão, mapa de sementes 1957632474.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rastreamento de erosão </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossa abordagem ingênua nos permite aplicar erosão, mas não no grau certo. </font><font style="vertical-align: inherit;">Isso acontece porque a célula após uma diminuição na altura ainda pode permanecer propensa à erosão. </font><font style="vertical-align: inherit;">Portanto, removeremos uma célula da lista somente quando não estiver mais sujeita a erosão.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/0a9/779/2810a9779b056865ad4490f9b00fa50f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% de erosão, mantendo as células propensas a erosão na lista. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, temos uma erosão muito mais forte, mas ao usar 100%, ainda não nos livramos de todos os penhascos. </font><font style="vertical-align: inherit;">A razão é que, depois de reduzir a altura da célula, um de seus vizinhos pode se tornar propenso a erosão. </font><font style="vertical-align: inherit;">Portanto, como resultado, podemos ter mais células propensas à erosão do que originalmente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de baixar a célula, precisamos verificar todos os seus vizinhos. </font><font style="vertical-align: inherit;">Se agora eles estão propensos à erosão, mas ainda não estão na lista, é necessário adicioná-los lá.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/894/ed5/b2a894ed5274286b00046050963388f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as células erodidas são omitidas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Economizamos muita terra </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora o processo de erosão pode continuar até que todos os penhascos desapareçam. Isso afeta muito a terra. A maior parte da massa de terra desapareceu e temos muito menos do que a porcentagem de terra necessária. Aconteceu porque estamos removendo terras do mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A verdadeira erosão não destrói a matéria. Ela pega de um lugar e coloca em outro lugar. Nós podemos fazer o mesmo. Com uma diminuição em uma célula, devemos criar um de seus vizinhos. De fato, um nível de altura é transferido para uma célula inferior. Isso economiza a quantidade total de alturas do mapa, enquanto a suaviza.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para isso, precisamos decidir para onde transferir os produtos erosivos. </font><font style="vertical-align: inherit;">Este será o nosso objetivo de erosão. </font><font style="vertical-align: inherit;">Vamos criar um método para determinar o ponto de destino de uma célula a ser corroída. </font><font style="vertical-align: inherit;">Como essa célula contém uma interrupção, seria lógico selecionar a célula localizada nessa interrupção como destino. </font><font style="vertical-align: inherit;">Mas uma célula propensa à erosão pode ter várias quebras, portanto, verificamos todos os vizinhos e colocamos todos os candidatos em uma lista temporária, e depois escolhemos um deles aleatoriamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetErosionTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; candidates = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { candidates.Add(neighbor); } } HexCell target = candidates[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, candidates.Count)]; ListPool&lt;HexCell&gt;.Add(candidates); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nós definimos a célula alvo imediatamente após selecionar a célula de erosão. </font><font style="vertical-align: inherit;">Então diminuímos e aumentamos a altura das células imediatamente uma após a outra. </font><font style="vertical-align: inherit;">Nesse caso, a própria célula-alvo pode se tornar suscetível à erosão, mas essa situação é resolvida quando verificamos os vizinhos da nova célula erodida.</font></font><br><br><pre> <code class="cs hljs"> HexCell cell = erodibleCells[index]; HexCell targetCell = GetErosionTarget(cell); cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; targetCell.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como elevamos a célula alvo, parte dos vizinhos dessa célula pode não estar mais sujeita a erosão. </font><font style="vertical-align: inherit;">É necessário contorná-los e verificar se eles estão propensos à erosão. </font><font style="vertical-align: inherit;">Caso contrário, mas eles estão na lista, você precisará removê-los.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); … } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d71/84f/0b4/d7184f0b4a2dd34853b56e0024ef2b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% de erosão, mantendo a massa da terra. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, a erosão pode suavizar muito melhor o terreno, diminuindo algumas áreas e elevando outras. </font><font style="vertical-align: inherit;">Como resultado, a massa de terra pode aumentar e diminuir. </font><font style="vertical-align: inherit;">Isso pode alterar a porcentagem de terra em vários por cento em uma direção ou outra, mas raramente ocorrem desvios sérios. </font><font style="vertical-align: inherit;">Ou seja, quanto mais erosão aplicarmos, menos controle teremos sobre a porcentagem resultante de terra.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erosão acelerada </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora não precisemos realmente nos preocupar com a eficácia do algoritmo de erosão, podemos fazer melhorias simples nele. </font><font style="vertical-align: inherit;">Primeiro, observe que verificamos explicitamente se a célula que erodimos pode ser erodida. </font><font style="vertical-align: inherit;">Caso contrário, então essencialmente o removemos da lista. </font><font style="vertical-align: inherit;">Portanto, você pode pular a verificação dessa célula ao percorrer os vizinhos da célula de destino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, precisávamos verificar os vizinhos da célula de destino apenas quando havia um intervalo entre eles, mas agora isso não é necessário. </font><font style="vertical-align: inherit;">Isso só acontece quando o vizinho está agora um passo mais alto que a célula de destino. </font><font style="vertical-align: inherit;">Nesse caso, é garantido que o vizinho esteja na lista; portanto, não precisamos verificar isso, ou seja, podemos pular a pesquisa desnecessária.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; neighbor.Elevation == targetCell.Elevation + <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !IsErodible(neighbor) <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em terceiro lugar, podemos usar um truque semelhante ao verificar os vizinhos de uma célula propensa a erosão. </font><font style="vertical-align: inherit;">Se agora existe um penhasco entre eles, o vizinho está propenso à erosão. </font><font style="vertical-align: inherit;">Para descobrir, não precisamos ligar </font></font><code>IsErodible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor.Elevation == cell.Elevation + <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, ainda precisamos verificar se a célula alvo é suscetível à erosão, mas o ciclo mostrado acima não está mais fazendo isso. </font><font style="vertical-align: inherit;">Portanto, executamos isso explicitamente para a célula de destino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(targetCell) &amp;&amp; !erodibleCells.Contains(targetCell)) { erodibleCells.Add(targetCell); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos aplicar a erosão com rapidez suficiente e com a porcentagem desejada em relação ao número inicial de falésias geradas. </font><font style="vertical-align: inherit;">Observe que, devido ao fato de termos mudado levemente o local onde a célula de destino é adicionada à lista propensa à erosão, o resultado foi ligeiramente alterado em relação ao resultado antes das otimizações.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a0d/71e/4a6a0d71eea3d1ef119b2f4f984a9b99.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28d/979/289/28d9792899367fdccb50f36b79801935.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7af/921/6af/7af9216af64111dbe0c15898db4560ce.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31b/7d9/ae5/31b7d9ae505297269bbd5442fdff17c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25%, 50%, 75% e 100% de erosão. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe também que, apesar da forma alterada da costa, a topologia não mudou fundamentalmente. </font><font style="vertical-align: inherit;">As massas de terra geralmente permanecem conectadas ou separadas. </font><font style="vertical-align: inherit;">Somente pequenas ilhas podem se afogar completamente. </font><font style="vertical-align: inherit;">Os detalhes do relevo são suavizados, mas as formas gerais permanecem as mesmas. </font><font style="vertical-align: inherit;">Uma articulação estreita pode desaparecer ou crescer um pouco. </font><font style="vertical-align: inherit;">Um pequeno espaço pode preencher ou expandir um pouco. </font><font style="vertical-align: inherit;">Portanto, a erosão não ficará fortemente unida às regiões divididas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cd/c53/824/2cdc53824832438c924e2832d9759b06.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quatro regiões completamente erodidas ainda permanecem separadas. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 25: O Ciclo da Água </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exibir dados brutos do mapa. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nós formamos um clima de células. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crie uma simulação parcial do ciclo da água. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta parte, adicionaremos umidade à terra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este tutorial foi criado no Unity 2017.3.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/fbe/dae/2aefbedae7b2c65cd86bbd2b4ccc3050.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos o ciclo da água para determinar os biomas.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As nuvens </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Até esse momento, o algoritmo de geração de mapas alterava apenas a altura da célula. </font><font style="vertical-align: inherit;">A maior diferença entre as células era se elas estavam acima ou abaixo da água. </font><font style="vertical-align: inherit;">Embora possamos definir diferentes tipos de terreno, essa é apenas uma visualização simples da altura. </font><font style="vertical-align: inherit;">Será melhor especificar os tipos de alívio, dado o clima local. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O clima da Terra é um sistema muito complexo. </font><font style="vertical-align: inherit;">Felizmente, não precisamos criar simulações climáticas realistas. </font><font style="vertical-align: inherit;">Vamos precisar de algo que pareça natural o suficiente. </font><font style="vertical-align: inherit;">O aspecto mais importante do clima é o ciclo da água, porque a flora e a fauna precisam de água líquida para sobreviver. </font><font style="vertical-align: inherit;">A temperatura também é muito importante, mas, por enquanto, nos concentramos na água, essencialmente deixando a temperatura global constante e alterando apenas a umidade.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ciclo da água descreve o movimento da água no meio ambiente. </font><font style="vertical-align: inherit;">Simplificando, as lagoas evaporam, o que leva à criação de nuvens que chovem, que novamente fluem para as lagoas. </font><font style="vertical-align: inherit;">Existem muitos outros aspectos no sistema, mas a simulação dessas etapas já pode ser suficiente para criar uma distribuição natural da água no mapa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualização de dados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de entrarmos nesta simulação, será útil ver diretamente os dados relevantes. </font><font style="vertical-align: inherit;">Para fazer isso, mudaremos o shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nós adicionamos uma propriedade selecionável a ele, que pode ser alternada para o modo de visualização de dados, que exibe dados brutos do mapa em vez das texturas de alívio usuais. </font><font style="vertical-align: inherit;">Isso pode ser implementado usando uma propriedade float com um atributo comutável que define a palavra-chave. </font><font style="vertical-align: inherit;">Por esse motivo, ele aparecerá no inspetor de materiais como um sinalizador que controla a definição de uma palavra-chave. </font><font style="vertical-align: inherit;">O nome da propriedade em si não é importante, estamos interessados ​​apenas na palavra-chave. </font><font style="vertical-align: inherit;">Estamos usando </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHOW_MAP_DATA</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [Toggle(SHOW_MAP_DATA)] _ShowMapData (<span class="hljs-string"><span class="hljs-string">"Show Map Data"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/32b/3e0/45232b3e0a72da1320457492c006613c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alterne para exibir dados do mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione uma função de sombreador para ativar o suporte a palavras-chave.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ GRID_ON #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> shader_feature SHOW_MAP_DATA</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos fazer com que ele exiba um único flutuador, como é o caso dos demais dados de alívio. </font><font style="vertical-align: inherit;">Para implementar isso, adicionaremos um </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo </font><font style="vertical-align: inherit;">à estrutura </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando a palavra-chave for definida.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">struct</span></span> Input { <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> color : COLOR; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> worldPos; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> terrain; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> visibility; <span class="hljs-comment"><span class="hljs-comment">#if defined(SHOW_MAP_DATA) float mapData; #endif };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No programa de vértices, usamos o canal Z dessas células para preencher </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como sempre interpolado entre as células.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inout appdata_full v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Input data</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(SHOW_MAP_DATA) data.mapData = cell0.z * v.color.x + cell1.z * v.color.y + cell2.z * v.color.z; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando você precisar exibir dados da célula, use-os diretamente como um fragmento de albedo em vez da cor usual. </font><font style="vertical-align: inherit;">Multiplique-o pela grade para que a grade ainda esteja ativada ao renderizar os dados.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … o.Albedo = c.rgb * grid * _Color * explored; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(SHOW_MAP_DATA) o.Albedo = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.mapData * grid; #endif … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para realmente transferir dados para um sombreador. </font><font style="vertical-align: inherit;">precisamos adicionar ao </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método que escreve algo no canal de dados de textura azul. </font><font style="vertical-align: inherit;">Os dados são um único valor flutuante limitado a 0–1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">255f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span>); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, essa decisão afeta o sistema de pesquisa. </font><font style="vertical-align: inherit;">Um valor de dados de canal azul 255 é usado para indicar que a visibilidade da célula está em transição. </font><font style="vertical-align: inherit;">Para que esse sistema continue funcionando, precisamos usar o valor de byte 254 como máximo. Observe que o movimento do destacamento apagará todos os dados do cartão, mas isso nos convém, porque eles são usados ​​para a geração de cartões de depuração.</font></font><br><br><pre> <code class="cs hljs"> cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">254f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">254</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um método com o mesmo nome e em </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele transferirá a solicitação para seus dados de sombreador.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { ShaderData.SetMapData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para verificar a operação do código, altere-o </font></font><code>HexMapGenerator.SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele defina os dados de cada célula do mapa. </font><font style="vertical-align: inherit;">Vamos visualizar a altura convertida de número inteiro para flutuar no intervalo de 0 a 1. </font><font style="vertical-align: inherit;">Isso é feito subtraindo a altura mínima da altura da célula, seguida pela divisão da altura máxima menos a mínima. </font><font style="vertical-align: inherit;">Vamos fazer o ponto flutuante da divisão.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … cell.SetMapData( (cell.Elevation - elevationMinimum) / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(elevationMaximum - elevationMinimum) ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos alternar entre o terreno normal e a visualização de dados usando a </font><font style="vertical-align: inherit;">caixa de seleção </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mostrar dados do mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do ativo de material do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/577/473/f28/577473f28d08f986124e6459a13a3714.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/c8a/85a/d60c8a85ae315fd509a4f6451629d8dc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa 1208905299, terreno normal e visualização de alturas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criação climática </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para simular o clima, precisamos rastrear dados climáticos. </font><font style="vertical-align: inherit;">Como o mapa consiste em células discretas, cada uma delas tem seu próprio clima local. </font><font style="vertical-align: inherit;">Crie uma estrutura </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para armazenar todos os dados relevantes. </font><font style="vertical-align: inherit;">Obviamente, você pode adicionar dados às próprias células, mas nós os usaremos apenas ao gerar o mapa. </font><font style="vertical-align: inherit;">Portanto, vamos salvá-los separadamente. </font><font style="vertical-align: inherit;">Isso significa que podemos definir essa estrutura internamente </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como </font></font><code>MapRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Começaremos rastreando apenas as nuvens, que podem ser implementadas usando um único campo flutuante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione uma lista para rastrear dados climáticos para todas as células. </font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora precisamos de um método para criar um mapa climático. </font><font style="vertical-align: inherit;">Deve começar limpando a lista de zonas climáticas e, em seguida, adicione um elemento para cada célula. </font><font style="vertical-align: inherit;">Os dados climáticos iniciais são simplesmente zero, isso pode ser alcançado usando um construtor padrão </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O clima deve ser criado após a exposição à erosão da terra antes de definir os tipos de relevo. </font><font style="vertical-align: inherit;">Na realidade, a erosão é causada principalmente pelo movimento do ar e da água, que fazem parte do clima, mas não simularemos isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Altere </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que possamos ver dados da nuvem em vez da altura da célula. </font><font style="vertical-align: inherit;">Inicialmente, parecerá um cartão preto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … cell.SetMapData(climate[i].clouds); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mudança climática </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O primeiro passo na simulação climática é a evaporação. </font><font style="vertical-align: inherit;">Quanta água deve evaporar? </font><font style="vertical-align: inherit;">Vamos controlar esse valor usando o controle deslizante. </font><font style="vertical-align: inherit;">Um valor 0 significa que não há evaporação, 1 - evaporação máxima. </font><font style="vertical-align: inherit;">Por padrão, usamos 0,5.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6af/d8e/ae8/6afd8eae8a1bbb6be361c29d32cc5b99.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle deslizante de evaporação. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos criar outro método especificamente para moldar o clima de uma célula. </font><font style="vertical-align: inherit;">Fornecemos o índice de células como parâmetro e o usamos para obter a célula correspondente e seus dados climáticos. </font><font style="vertical-align: inherit;">Se a célula estiver submersa, estamos lidando com um reservatório que deve evaporar. </font><font style="vertical-align: inherit;">Transformamos imediatamente o vapor em nuvens (ignorando os pontos de condensação e condensação), para adicionar diretamente a evaporação ao valor das nuvens celulares. </font><font style="vertical-align: inherit;">Quando terminar, copie os dados climáticos de volta para a lista.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvolveClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { HexCell cell = grid.GetCell(cellIndex); ClimateData cellClimate = climate[cellIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } climate[cellIndex] = cellClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chame esse método para cada célula </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas isso não é suficiente. </font><font style="vertical-align: inherit;">Para criar uma simulação complexa, precisamos moldar o clima das células várias vezes. </font><font style="vertical-align: inherit;">Quanto mais fazemos isso, melhor será o resultado. </font><font style="vertical-align: inherit;">Vamos apenas escolher um valor constante. </font><font style="vertical-align: inherit;">Eu uso 40 ciclos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como embora apenas aumentemos o valor das nuvens acima das células inundadas com água, como resultado, obtemos terra preta e reservatórios brancos. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/e1c/5dc/3e7e1c5dc9ce75197a94e8ffcd6d8275.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evaporação sobre a água.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Espalhamento de nuvens </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As nuvens não estão constantemente em um só lugar, especialmente quando mais e mais água evapora. </font><font style="vertical-align: inherit;">A diferença de pressão faz o ar se mover, que se manifesta na forma de vento, que também faz as nuvens se moverem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se não houver direção dominante do vento, em média as nuvens das células se dispersarão uniformemente em todas as direções, aparecendo nas células vizinhas. </font><font style="vertical-align: inherit;">Ao gerar novas nuvens no próximo ciclo, vamos distribuir todas as nuvens da célula em seus vizinhos. </font><font style="vertical-align: inherit;">Ou seja, cada vizinho recebe um sexto das nuvens de células, após o que há uma diminuição local para zero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>; climate[cellIndex] = cellClimate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para realmente adicionar nuvens aos seus vizinhos, você precisa contorná-los em loop, obter os dados climáticos, aumentar o valor das nuvens e copiá-los de volta para a lista. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; climate[neighbor.Index] = neighborClimate; } cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6a/0e3/437/e6a0e34379d984582c020fde8f1db546.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuvens dispersas.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isso cria um mapa quase branco, porque a cada ciclo as células subaquáticas adicionam mais e mais nuvens ao clima global. Após o primeiro ciclo, as células terrestres próximas à água também terão nuvens que precisam ser dispersas. Esse processo continua até que a maior parte do mapa esteja coberta de nuvens. No caso do mapa 1208905299 com os parâmetros padrão, apenas a parte interna da grande massa de terra no nordeste permaneceu completamente descoberta.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que lagoas podem gerar um número infinito de nuvens. </font><font style="vertical-align: inherit;">O nível da água não faz parte da simulação climática. </font><font style="vertical-align: inherit;">Na realidade, os reservatórios são preservados apenas porque a água flui de volta para eles aproximadamente à taxa de evaporação. </font><font style="vertical-align: inherit;">Ou seja, simulamos apenas um ciclo parcial da água. </font><font style="vertical-align: inherit;">Isso é normal, mas precisamos entender que quanto mais a simulação ocorre, mais água é adicionada ao clima. </font><font style="vertical-align: inherit;">Até agora, a perda de água ocorre apenas nas bordas do mapa, onde nuvens dispersas são perdidas devido à falta de vizinhos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode ver a perda de água na parte superior do mapa, especialmente nas células no canto superior direito. </font><font style="vertical-align: inherit;">Na última célula, não há nuvens, porque continua sendo a última em que o clima é formado. </font><font style="vertical-align: inherit;">Ela ainda não recebeu nuvens de um vizinho.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O clima de todas as células não deveria se formar em paralelo?</font></font></b> <div class="spoiler_text"> ,        .    -              ,         .   40    . -      ,       . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Precipitação </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A água não fica fria para sempre. Em algum momento, ela deve cair no chão novamente. Isso geralmente acontece na forma de chuva, mas às vezes pode ser neve, granizo ou neve molhada. Tudo isso é geralmente chamado de precipitação. A magnitude e a taxa de desaparecimento das nuvens variam muito, mas apenas usamos uma taxa global de precipitação personalizada. Um valor 0 significa que não há precipitação, um valor 1 significa que todas as nuvens desaparecem instantaneamente. O valor padrão é 0,25. Isso significa que em cada ciclo um quarto das nuvens desaparecerá.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitationFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/762/37d/f9076237d0673301af34c32f5cd6688a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle deslizante do coeficiente de precipitação. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simularemos a precipitação após a evaporação e antes da dispersão das nuvens. </font><font style="vertical-align: inherit;">Isso significa que parte da água evaporada dos reservatórios precipita imediatamente, diminuindo o número de nuvens dispersas. </font><font style="vertical-align: inherit;">Sobre a terra, a precipitação levará ao desaparecimento das nuvens.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e3/f11/46a/4e3f1146a761d1525e6a9349ff715bbb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuvens desaparecendo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, quando destruímos 25% das nuvens em cada ciclo, a terra fica novamente quase negra. </font><font style="vertical-align: inherit;">As nuvens conseguem se mover para o interior apenas alguns passos, após o que se tornam invisíveis. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Umidade </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora a chuva destrua as nuvens, elas não devem remover a água do clima. </font><font style="vertical-align: inherit;">Depois de cair no chão, a água é salva, apenas em um estado diferente. </font><font style="vertical-align: inherit;">Pode existir de várias formas, que geralmente consideraremos umidade.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rastreamento de umidade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos melhorar o modelo climático rastreando duas condições da água: nuvens e umidade. </font><font style="vertical-align: inherit;">Para conseguir isso, adicionar um </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo </font></font><code>moisture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds, moisture; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em sua forma mais generalizada, a evaporação é o processo de conversão de umidade em nuvens, pelo menos em nosso modelo climático simples. </font><font style="vertical-align: inherit;">Isso significa que a evaporação não deve ser um valor constante, mas outro fator. </font><font style="vertical-align: inherit;">Portanto, realizamos a renomeação de refatoração </font></font><code>evaporation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>evaporationFactor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporationFactor = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando a célula está submersa, simplesmente anunciamos que o nível de umidade é 1. Isso significa que a evaporação é igual ao coeficiente de evaporação. </font><font style="vertical-align: inherit;">Mas agora também podemos obter evaporação das células de sushi. </font><font style="vertical-align: inherit;">Nesse caso, precisamos calcular a evaporação, subtraí-la da umidade e adicionar o resultado às nuvens. </font><font style="vertical-align: inherit;">Depois disso, a precipitação é adicionada à umidade.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; cellClimate.clouds += evaporationFactor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = cellClimate.moisture * evaporationFactor; cellClimate.moisture -= evaporation; cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como as nuvens agora são suportadas pela evaporação acima da terra, podemos movê-las para o interior. </font><font style="vertical-align: inherit;">Agora a maior parte da terra ficou cinza.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/94f/c71/a0b94fc71728a012254059d760bf47f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuvens com evaporação de umidade. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos alterá-lo </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para exibir umidade em vez de nuvens, porque vamos usá-lo para determinar os tipos de relevo.</font></font><br><br><pre> <code class="cs hljs"> cell.SetMapData(climate[i].moisture);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cf/78f/d30/3cf78fd3099cf1b3a75befb8ebb0893d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exibição de umidade. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse ponto, a umidade parece bastante semelhante às nuvens (exceto que todas as células subaquáticas são brancas), mas isso mudará em breve.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escoamento de chuva </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A evaporação não é a única maneira de a umidade sair da célula. </font><font style="vertical-align: inherit;">O ciclo da água nos diz que a maior parte da umidade adicionada à terra acaba de alguma forma na água. </font><font style="vertical-align: inherit;">O processo mais notável é o fluxo de água sobre a terra sob a influência da gravidade. </font><font style="vertical-align: inherit;">Não simularemos rios reais, mas usaremos um coeficiente de escoamento de chuva personalizado. </font><font style="vertical-align: inherit;">Isso indicará a porcentagem de água drenada para as áreas mais baixas. </font><font style="vertical-align: inherit;">Vamos usar como padrão o estoque será igual a 25%.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoffFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c85/e81/648/c85e8164833b60299f80bba99c11be81.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drene o controle deslizante.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nós não vamos gerar rios?</font></font></b> <div class="spoiler_text">          . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O escoamento da água atua como uma dispersão de nuvens, mas com três diferenças. Em primeiro lugar, nem toda a umidade é removida da célula. Em segundo lugar, ele carrega umidade, não nuvens. Em terceiro lugar, desce, ou seja, apenas para vizinhos com uma altura mais baixa. O coeficiente de escoamento superficial descreve a quantidade de umidade que sairia da célula se todos os vizinhos fossem mais baixos, mas geralmente são menores. Isso significa que reduziremos a umidade da célula somente quando encontrarmos um vizinho abaixo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a25/c41/00b/a25c4100bde5139415ebbf0a45068d0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drenagem da água a uma altura mais baixa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, temos uma distribuição mais diversificada de umidade, porque células altas transmitem sua umidade para as mais baixas. </font><font style="vertical-align: inherit;">Também vemos muito menos umidade nas células costeiras, porque elas drenam a umidade para dentro das células subaquáticas. </font><font style="vertical-align: inherit;">Para enfraquecer esse efeito, também precisamos usar o nível da água para determinar se a célula está mais baixa, ou seja, medir a altura aparente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/ee9/64d/651ee964da5a422bfaa94f27609a5dcd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use a altura visível.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Infiltração </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A água não apenas flui para baixo, mas também se espalha através da topografia nivelada e é absorvida pela terra adjacente aos corpos d'água. </font><font style="vertical-align: inherit;">Esse efeito pode ter pouco efeito, mas é útil para suavizar a distribuição de umidade, então vamos adicioná-lo à simulação. </font><font style="vertical-align: inherit;">Vamos criar seu próprio coeficiente personalizado, por padrão igual a 0,125.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepageFactor = <span class="hljs-number"><span class="hljs-number">0.125f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/855/b73/495855b73d4601ab3de00b3561285491.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle deslizante de vazamento. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A infiltração é semelhante a um dreno, exceto que é usada quando o vizinho tem a mesma altura visível que a própria célula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepage = cellClimate.moisture * seepageFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= seepage; neighborClimate.moisture += seepage; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/7b2/b01/d397b2b01ad8e71137b9e5fa03fcf5a5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicionado um pouco de vazamento. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombras de chuva </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora já tenhamos criado uma simulação digna do ciclo da água, ele não parece muito interessante, porque não possui sombras de chuva, que demonstram claramente as diferenças climáticas. </font><font style="vertical-align: inherit;">Sombras de chuva são áreas em que há uma falta significativa de chuva em comparação com as áreas vizinhas. </font><font style="vertical-align: inherit;">Tais áreas existem porque as montanhas impedem que as nuvens os alcancem. </font><font style="vertical-align: inherit;">Sua criação requer altas montanhas e uma direção dominante do vento.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O vento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos começar adicionando uma direção dominante do vento à simulação. </font><font style="vertical-align: inherit;">Embora as direções dominantes do vento variem bastante na superfície da Terra, gerenciaremos com uma direção global personalizável do vento. </font><font style="vertical-align: inherit;">Vamos usar o noroeste por padrão. </font><font style="vertical-align: inherit;">Além disso, vamos ajustar a força do vento de 1 a 10 com um valor padrão de 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection windDirection = HexDirection.NW; [Range(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> windStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/4a1/49c/f324a149c360bbfde72e98b4877afb37.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A direção e força do vento. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A força do vento dominante é expressa em relação à dispersão total das nuvens. </font><font style="vertical-align: inherit;">Se a força do vento for 1, a dispersão será a mesma em todas as direções. </font><font style="vertical-align: inherit;">Quando é 2, a dispersão é duas mais alta na direção do vento do que em outras direções, e assim por diante. </font><font style="vertical-align: inherit;">Podemos fazer isso alterando o divisor na fórmula de dispersão de nuvens. </font><font style="vertical-align: inherit;">Em vez de seis, será igual a cinco mais energia eólica.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além disso, a direção do vento determina a direção a partir da qual o vento sopra. </font><font style="vertical-align: inherit;">Portanto, precisamos usar a direção oposta como a direção principal da dispersão.</font></font><br><br><pre> <code class="cs hljs"> HexDirection mainDispersalDirection = windDirection.Opposite(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos verificar se o vizinho está na direção principal da dispersão. </font><font style="vertical-align: inherit;">Nesse caso, devemos multiplicar a dispersão das nuvens pela força do vento.</font></font><br><br><pre> <code class="cs hljs"> ClimateData neighborClimate = climate[neighbor.Index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == mainDispersalDirection) { neighborClimate.clouds += cloudDispersal * windStrength; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { neighborClimate.clouds += cloudDispersal; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/874/2d5/e7e8742d53033ee4ee89f68e60871426.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vento noroeste, força 4.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O vento dominante acrescenta direcionalidade à distribuição de umidade sobre a terra. </font><font style="vertical-align: inherit;">Quanto mais forte o vento, mais poderoso o efeito se torna.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Altura absoluta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O segundo ingrediente para obter sombras de chuva são as montanhas. Não temos uma classificação estrita do que é uma montanha, assim como a natureza também não a possui. Somente a altura absoluta é importante. De fato, quando o ar se move sobre a montanha, ele é forçado a subir, é resfriado e pode conter menos água, o que leva à precipitação antes que o ar passe sobre a montanha. Como resultado, do outro lado, temos ar seco, ou seja, uma sombra da chuva.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais importante, quanto mais alto o ar sobe, menos água ele pode conter. </font><font style="vertical-align: inherit;">Em nossa simulação, podemos imaginar isso como uma restrição forçada do valor máximo de nuvem para cada célula. </font><font style="vertical-align: inherit;">Quanto maior a altura visível da célula, menor será esse máximo. </font><font style="vertical-align: inherit;">A maneira mais fácil de fazer isso é definir o máximo como 1 menos a altura aparente, dividida pela altura máxima. </font><font style="vertical-align: inherit;">Mas, de fato, vamos dividir por um máximo de menos 1. Isso permitirá que uma pequena fração das nuvens ainda passe pelas células mais altas. </font><font style="vertical-align: inherit;">Atribuímos esse valor máximo após o cálculo da precipitação e antes da dispersão.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexDirection mainDispersalDirection = windDirection.Opposite();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se, como resultado, obtivermos mais nuvens do que aceitáveis, simplesmente converteremos o excesso de nuvens em umidade. </font><font style="vertical-align: inherit;">De fato, é assim que adicionamos precipitação adicional, como acontece nas montanhas reais.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellClimate.clouds &gt; cloudMaximum) { cellClimate.moisture += cellClimate.clouds - cloudMaximum; cellClimate.clouds = cloudMaximum; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/998/c36/403998c36a6d85250f837766a4f33147.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sombras de chuva causadas por grandes altitudes. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nós completamos a simulação </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta fase, já temos uma simulação parcial de alta qualidade do ciclo da água. </font><font style="vertical-align: inherit;">Vamos colocá-lo em ordem um pouco e depois aplicá-lo para determinar o tipo de alívio das células.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Computação paralela </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como mencionado anteriormente no spoiler, a ordem em que as células são formadas afeta o resultado da simulação. </font><font style="vertical-align: inherit;">Idealmente, isso não deveria ser e, em essência, formamos todas as células em paralelo. </font><font style="vertical-align: inherit;">Isso pode ser feito aplicando todas as mudanças do estágio atual de formação à segunda lista de clima </font></font><code>nextClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;(); List&lt;ClimateData&gt; nextClimate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limpe e inicialize esta lista, como todos os outros. </font><font style="vertical-align: inherit;">Em seguida, trocaremos listas em cada ciclo. </font><font style="vertical-align: inherit;">Nesse caso, a simulação usará alternadamente as duas listas e aplicará os dados climáticos atuais e futuros.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); nextClimate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(initialData); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } List&lt;ClimateData&gt; swap = climate; climate = nextClimate; nextClimate = swap; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando uma célula afeta o clima de seu vizinho, devemos alterar os seguintes dados climáticos, não os atuais. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = nextClimate[neighbor.Index]; … nextClimate[neighbor.Index] = neighborClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E, em vez de copiar os seguintes dados climáticos de volta à lista climática atual, obtemos os seguintes dados climáticos, adicionamos a umidade atual a eles e copiamos tudo para a próxima lista. </font><font style="vertical-align: inherit;">Depois disso, redefinimos os dados na lista atual para que sejam atualizados para o próximo ciclo.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// cellClimate.clouds = 0f; ClimateData nextCellClimate = nextClimate[cellIndex]; nextCellClimate.moisture += cellClimate.moisture; nextClimate[cellIndex] = nextCellClimate; climate[cellIndex] = new ClimateData();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enquanto fazemos isso, vamos também definir o nível de umidade para um máximo de 1, para que as células terrestres não possam estar mais úmidas do que debaixo d'água. </font></font><br><br><pre> <code class="cs hljs"> nextCellClimate.moisture += cellClimate.moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextCellClimate.moisture &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { nextCellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } nextClimate[cellIndex] = nextCellClimate;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/709/87b/6a870987bfad51e91eaa1ff405be539d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computação paralela.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Humidade original </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Há uma chance de que a simulação produza muita terra seca, especialmente com uma alta porcentagem de terra. </font><font style="vertical-align: inherit;">Para melhorar a imagem, podemos adicionar um nível de umidade inicial personalizado com um valor padrão de 0,1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startingMoisture = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/69b/3a2/db869b3a24627d695d9ec8bf2ba1f4ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acima está o controle deslizante da umidade original. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos esse valor para a umidade da lista climática inicial, mas não para o seguinte.</font></font><br><br><pre> <code class="cs hljs"> ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); initialData.moisture = startingMoisture; ClimateData clearData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(clearData); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/138/649/a74138649fc141c088a631bce956a31a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com umidade original.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definindo biomas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concluímos usando umidade em vez de altura para especificar o tipo de alívio da célula. </font><font style="vertical-align: inherit;">Vamos usar a neve para terra completamente seca; em regiões áridas, usamos neve; depois, há pedra, grama para umidade o suficiente e terra para células subaquáticas e saturadas de água. </font><font style="vertical-align: inherit;">A maneira mais fácil é usar cinco intervalos em incrementos de 0,2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.4f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.SetMapData(moisture); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/c53/e4f/123c53e4f3f79aa50437a553e0eb6761.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao usar uma distribuição uniforme, o resultado não é muito bom e parece artificial. </font><font style="vertical-align: inherit;">É melhor usar outros limites, por exemplo, 0,05, 0,12, 0,28 e 0,85.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.05f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.12f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.28f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.85f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/8cf/7c7/6ad8cf7c7becf357d16157ae28999a14.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomas modificados. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 26: biomas e rios </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criamos os rios provenientes de células altas com umidade. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criamos um modelo simples de temperatura. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usamos a matriz do bioma para as células e depois a alteramos. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta parte, suplementaremos o ciclo da água com rios e temperatura, além de atribuirmos biomas mais interessantes às células. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O tutorial foi criado usando o Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calor e água animam o mapa.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geração de rio </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os rios são uma conseqüência do ciclo da água. </font><font style="vertical-align: inherit;">De fato, eles são formados por escoamentos que se rompem com a ajuda da erosão do canal. </font><font style="vertical-align: inherit;">Isso implica que você pode adicionar rios com base no valor dos drenos de células. </font><font style="vertical-align: inherit;">No entanto, isso não garante que obteremos algo que se assemelhe a rios reais. </font><font style="vertical-align: inherit;">Quando começamos o rio, ele terá que fluir o mais longe possível, potencialmente através de muitas células. </font><font style="vertical-align: inherit;">Isso não é consistente com a nossa simulação do ciclo da água, que processa as células em paralelo. </font><font style="vertical-align: inherit;">Além disso, geralmente é necessário o controle do número de rios em um mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como os rios são muito diferentes, nós os geraremos separadamente. </font><font style="vertical-align: inherit;">Utilizamos os resultados da simulação do ciclo da água para determinar a localização dos rios, mas os rios, por sua vez, não afetarão a simulação.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que o fluxo do rio às vezes está errado?</font></font></b> <div class="spoiler_text">    <code>TriangulateWaterShore</code>  ,    .      ,    .   ,    ,       .      ,  .    ,  ,       .         («»). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } … }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Células de alta umidade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos nossos mapas, uma célula pode ou não ter um rio. Além disso, eles podem ramificar ou conectar-se. Na realidade, os rios são muito mais flexíveis, mas temos que conviver com essa aproximação, que cria apenas grandes rios. Mais importante, precisamos determinar a localização do início de um rio grande, que é escolhido aleatoriamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como os rios precisam de água, a fonte do rio deve estar em uma célula com alta umidade. Mas isso não é suficiente. Os rios correm pelas encostas, então, idealmente, a fonte deve ter uma grande altura. Quanto maior a célula acima do nível da água, melhor candidata é para o papel da fonte do rio. Podemos visualizar isso como dados do mapa dividindo a altura da célula pela altura máxima. Para que o resultado seja obtido em relação ao nível da água, vamos subtraí-lo de ambas as alturas antes de dividir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f9/d80/2de/6f9d802de155c2b1e051be5d360dc3c1.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/e8f/6a2/f5ce8f6a20d7336dc94b89812c123827.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umidade e altitude. Número grande do mapa 1208905299 com configurações padrão.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os melhores candidatos são aquelas células que possuem alta umidade e alta altura. Podemos combinar esses critérios multiplicando-os. O resultado será o valor da aptidão ou do peso para as nascentes dos rios.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec2/31f/445/ec231f445d785c24c6cd9f191ed6c24a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesos para as fontes dos rios.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Idealmente, usaríamos esses pesos para rejeitar a seleção aleatória da célula de origem. Embora possamos criar uma lista com os pesos corretos e escolher uma opção, essa é uma abordagem não trivial e atrasa o processo de geração. Uma classificação mais simples de significância dividida em quatro níveis será suficiente para nós. Os primeiros candidatos serão pesos com valores acima de 0,75. Bons candidatos têm pesos de 0,5. Os candidatos elegíveis são maiores que 0,25. Todas as outras células são descartadas. Vamos mostrar como fica graficamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">1f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(data);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/056/5ba/3b7/0565ba3b7a51499bfe1d389ecd270910.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Categorias de pesos das nascentes dos rios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com esse esquema de classificação, é provável que obtenhamos rios com fontes nas áreas mais altas e úmidas do mapa. </font><font style="vertical-align: inherit;">No entanto, permanece a probabilidade de criação de rios em áreas relativamente secas ou baixas, o que aumenta a variabilidade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um método </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que preencha uma lista de células com base nesses critérios. </font><font style="vertical-align: inherit;">As células elegíveis são adicionadas a essa lista uma vez, as boas duas vezes e os principais candidatos quatro vezes. </font><font style="vertical-align: inherit;">As células subaquáticas são sempre descartadas, portanto você não pode vê-las.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData data = climate[i]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = data.moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { riverOrigins.Add(cell); riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { riverOrigins.Add(cell); } } ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse método deve ser chamado depois </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que os dados de umidade estejam disponíveis para nós.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); CreateRivers(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Após concluir a classificação, você pode se livrar da visualização de seus dados no mapa. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-comment"><span class="hljs-comment">// float data = // moisture * (cell.Elevation - waterLevel) / // (elevationMaximum - waterLevel); // if (data &gt; 0.6f) { // cell.SetMapData(1f); // } // else if (data &gt; 0.4f) { // cell.SetMapData(0.5f); // } // else if (data &gt; 0.2f) { // cell.SetMapData(0.25f); // } } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pontos do rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quantos rios precisamos? </font><font style="vertical-align: inherit;">Este parâmetro deve ser personalizável. </font><font style="vertical-align: inherit;">Como o comprimento dos rios varia, será mais lógico controlá-lo com a ajuda de pontos fluviais, que determinam o número de células terrestres nas quais os rios devem estar contidos. </font><font style="vertical-align: inherit;">Vamos expressá-los como uma porcentagem com um máximo de 20% e um valor padrão de 10%. </font><font style="vertical-align: inherit;">Como a porcentagem de sushi, esse é um valor-alvo, não garantido. </font><font style="vertical-align: inherit;">Como resultado, podemos ter poucos candidatos ou rios muito curtos para cobrir a quantidade necessária de terra. </font><font style="vertical-align: inherit;">É por isso que a porcentagem máxima não deve ser muito grande.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 20)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverPercentage = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/793/1c6/4cd/7931c64cd7bdffbb17f83a94aed1bbc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider percentual de rios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar os pontos do rio, expressos como o número de células, precisamos lembrar em quantas células terrestres foram geradas </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount, landCells; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); landCells = landBudget; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); landCells -= landBudget; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lá dentro, o </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">número de pontos do rio agora pode ser calculado da mesma maneira que fazemos </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além disso, continuaremos a retirar e remover células aleatórias da lista original, enquanto ainda temos pontos e células de origem. </font><font style="vertical-align: inherit;">Em caso de conclusão do número de pontos, exibiremos um aviso no console.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up river budget."</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além disso, adicionamos um método para criar rios diretamente. </font><font style="vertical-align: inherit;">Como parâmetro, ele precisa de uma célula inicial e, após a conclusão, deve retornar o comprimento do rio. </font><font style="vertical-align: inherit;">Começamos armazenando um método que retorna comprimento zero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos chamar esse método no final do ciclo que acabamos de adicionar </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, usando para reduzir o número de pontos restantes. </font><font style="vertical-align: inherit;">Garantimos que um novo rio seja criado apenas se a célula selecionada não tiver um rio fluindo através dele.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rios atuais </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É lógico criar rios que correm para o mar ou outro corpo de água. </font><font style="vertical-align: inherit;">Quando começamos a partir da fonte, obtemos imediatamente o comprimento 1. Depois disso, selecionamos um vizinho aleatório e aumentamos o comprimento. </font><font style="vertical-align: inherit;">Continuamos a nos mover até chegarmos à cela subaquática.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { HexDirection direction = (HexDirection)Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); cell.SetOutgoingRiver(direction); length += <span class="hljs-number"><span class="hljs-number">1</span></span>; cell = cell.GetNeighbor(direction); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/359/7cf/7a7/3597cf7a7ae263721b381534185e7645.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios aleatórios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado de uma abordagem tão ingênua, obtemos fragmentos dispersos aleatoriamente, principalmente devido à substituição de rios gerados anteriormente. </font><font style="vertical-align: inherit;">Isso pode até levar a erros, porque não verificamos se o vizinho realmente existe. </font><font style="vertical-align: inherit;">Precisamos verificar todas as direções no loop e garantir que haja um vizinho lá. </font><font style="vertical-align: inherit;">Se for, adicionamos essa direção à lista de possíveis direções de fluxo, mas apenas se o rio ainda não fluir através desse vizinho. </font><font style="vertical-align: inherit;">Em seguida, selecione um valor aleatório nesta lista.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexDirection&gt; flowDirections = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexDirection&gt;(); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d); } HexDirection direction = <span class="hljs-comment"><span class="hljs-comment">// (HexDirection)Random.Range(0, 6); flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com essa nova abordagem, podemos ter zero direções de fluxo disponíveis. </font><font style="vertical-align: inherit;">Quando isso acontece, o rio não pode mais fluir mais e deve terminar. </font><font style="vertical-align: inherit;">Se neste momento o comprimento for 1, isso significa que não podemos vazar da célula original, ou seja, não pode haver rio. </font><font style="vertical-align: inherit;">Nesse caso, o comprimento do rio é zero.</font></font><br><br><pre> <code class="cs hljs"> flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/5bd/05d/e6f5bd05d8d5a976d6fff9fa14397a25.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios preservados.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atropelar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora salvamos os rios já criados, mas ainda podemos obter fragmentos isolados dos rios. </font><font style="vertical-align: inherit;">Isso acontece porque enquanto ignoramos as alturas. </font><font style="vertical-align: inherit;">Cada vez que forçávamos o rio a fluir a uma altura maior, </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interrompíamos essa tentativa, que provocava rupturas nos rios. </font><font style="vertical-align: inherit;">Portanto, também precisamos pular as direções que causam o fluxo dos rios.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae6/cf7/696/ae6cf76968d64228e88378749939f1f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios descendo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Então, nos livramos de muitos fragmentos de rios, mas alguns ainda permanecem. </font><font style="vertical-align: inherit;">A partir deste momento, livrar-se dos rios mais feios se torna uma questão de refinamento. </font><font style="vertical-align: inherit;">Para começar, os rios preferem fluir o mais rápido possível. </font><font style="vertical-align: inherit;">Eles não escolherão necessariamente o caminho mais curto possível, mas a probabilidade disso é grande. </font><font style="vertical-align: inherit;">Para simular isso, adicionaremos as direções três vezes à lista.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } flowDirections.Add(d);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evite curvas fechadas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além de fluir para baixo, a água também tem inércia. </font><font style="vertical-align: inherit;">É mais provável que um rio flua reto ou dobre um pouco do que fazer uma curva acentuada repentina. </font><font style="vertical-align: inherit;">Podemos adicionar essa distorção rastreando a última direção do rio. </font><font style="vertical-align: inherit;">Se a direção potencial da corrente não se desviar muito dessa direção, adicione-a à lista novamente. </font><font style="vertical-align: inherit;">Isso não é um problema para a fonte; portanto, sempre a adicionamos novamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; HexDirection direction = HexDirection.NE; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( length == <span class="hljs-number"><span class="hljs-number">1</span></span> || (d != direction.Next2() &amp;&amp; d != direction.Previous2()) ) { flowDirections.Add(d); } flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// HexDirection direction = direction = flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isso reduz muito a probabilidade de os ziguezagues dos rios parecerem feios. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/83b/ce7/67483bce79b287f3cc451e381dc686d2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menos curvas fechadas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Confluência do rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Às vezes acontece que o rio flui próximo à fonte do rio criado anteriormente. </font><font style="vertical-align: inherit;">Se a fonte desse rio não estiver em uma altitude mais alta, podemos decidir que o novo rio flui para o antigo. </font><font style="vertical-align: inherit;">Como resultado, temos um rio longo, e não dois vizinhos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para fazer isso, deixaremos o vizinho passar apenas se houver um rio chegando ou se for a fonte do rio atual. </font><font style="vertical-align: inherit;">Depois de determinar que essa direção não está voltada para cima, verificamos se há um rio de saída. </font><font style="vertical-align: inherit;">Se houver, então encontramos novamente o rio antigo. </font><font style="vertical-align: inherit;">Como isso acontece muito raramente, não nos empenharemos em verificar outras fontes vizinhas e combinaremos imediatamente os rios.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor.HasRiver) { // continue; // } if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } if (neighbor.HasOutgoingRiver) { cell.SetOutgoingRiver(d); return length; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb3/820/ee6/bb3820ee6271b8bc7b32e901b39c906a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ba/d8f/08d/3bad8f08d23cfe3844ec259a1c2475d6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios antes e depois da piscina.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manter distância </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como os bons candidatos ao papel de origem geralmente são agrupados, obteremos grupos de rios. </font><font style="vertical-align: inherit;">Além disso, podemos ter rios que levam a fonte ao lado do reservatório, resultando em rios de comprimento 1. Podemos distribuir as fontes, descartando aquelas que estão nas proximidades do rio ou reservatório. </font><font style="vertical-align: inherit;">Fazemos isso ignorando os vizinhos da fonte selecionada em um loop interno </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se encontrarmos um vizinho que viola as regras, a fonte não nos convém e devemos ignorá-lo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = origin.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; (neighbor.HasRiver || neighbor.IsUnderwater)) { isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isValidOrigin) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E embora os rios ainda fluam um ao lado do outro, eles tendem a cobrir uma área maior. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/bed/3a6/887bed3a6032b4bea508ee6ceda4a228.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/b85/428/f53b85428840118895d74f62b1c2d1a6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sem distância e com ela.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terminamos o rio com um lago </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nem todos os rios chegam ao reservatório, alguns ficam presos nos vales ou são bloqueados por outros rios. Este não é um problema específico, porque geralmente os rios reais também parecem desaparecer. Isso pode acontecer, por exemplo, se eles fluem no subsolo, dispersam em uma área pantanosa ou secam. Nossos rios não podem visualizar isso, então eles simplesmente terminam. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, podemos tentar minimizar o número desses casos. Embora não possamos unir os rios ou fazê-los fluir, podemos fazê-los terminar em lagos, o que geralmente é encontrado na realidade e parece bom. Para isso</font></font><code>CreateRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve elevar o nível da água na célula se ficar preso. </font><font style="vertical-align: inherit;">A possibilidade disso depende da altura mínima dos vizinhos desta célula. </font><font style="vertical-align: inherit;">Portanto, para acompanhar isso ao estudar vizinhos, é necessária uma pequena alteração no código.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minNeighborElevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { // continue; // } if (!neighbor) { continue; } if (neighbor.Elevation &lt; minNeighborElevation) { minNeighborElevation = neighbor.Elevation; } if (neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } … } … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se estivermos presos, primeiro precisamos verificar se ainda estamos na fonte. </font><font style="vertical-align: inherit;">Se sim, basta cancelar o rio. </font><font style="vertical-align: inherit;">Caso contrário, verificamos se todos os vizinhos são pelo menos tão altos quanto a célula atual. </font><font style="vertical-align: inherit;">Nesse caso, podemos elevar a água para este nível. </font><font style="vertical-align: inherit;">Isso criará um lago a partir de uma célula, a menos que a altura da célula permaneça no mesmo nível. </font><font style="vertical-align: inherit;">Nesse caso, basta atribuir a altura um nível abaixo do nível da água.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// return length &gt; 1 ? length : 0; if (length == 1) { return 0; } if (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = minNeighborElevation; if (minNeighborElevation == cell.Elevation) { cell.Elevation = minNeighborElevation - 1; } } break; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/7da/964/d607da964da18b71cd022c997661695c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee8/ab1/000/ee8ab10002cd3e36cefbcfe3980a8fbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As extremidades dos rios sem lagos e com lagos. </font><font style="vertical-align: inherit;">Nesse caso, a porcentagem de rios é 20.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Observe que agora podemos ter células subaquáticas acima do nível da água usada para gerar o mapa. </font><font style="vertical-align: inherit;">Eles irão indicar lagos acima do nível do mar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lagos adicionais </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Também podemos criar lagos, mesmo que não fiquemos presos. </font><font style="vertical-align: inherit;">Isso pode resultar em um rio entrando e saindo do lago. </font><font style="vertical-align: inherit;">Se não estivermos presos, um lago poderá ser criado elevando o nível da água e a altura atual da célula e reduzindo a altura da célula. </font><font style="vertical-align: inherit;">Isso se aplica somente quando a altura mínima do vizinho é pelo menos igual à altura da célula atual. </font><font style="vertical-align: inherit;">Fazemos isso no final do ciclo do rio e antes de passar para a próxima célula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell = cell.GetNeighbor(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/945/5bb/2b6/9455bb2b6547a8b1342e179f15eb5925.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f84/516/4b7/f845164b7a543b9549cd9f07d273e67f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sem lagos adicionais e com eles. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vários lagos são lindos, mas sem limites, podemos criar muitos lagos. </font><font style="vertical-align: inherit;">Portanto, vamos adicionar uma probabilidade personalizada para lagos adicionais, com um valor padrão de 0,25.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> extraLakeProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ela controlará a probabilidade de gerar um lago adicional, se possível. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( minNeighborElevation &gt;= cell.Elevation &amp;&amp; Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; extraLakeProbability ) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/d04/bc3/fa5d04bc3f7475ec2baab7b6e7dac38f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/bb4/364/118bb4364acb0646efb54a031d3ac356.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lagos adicionais.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que tal criar lagos com mais de uma célula?</font></font></b> <div class="spoiler_text">     ,       ,  ,      .      .      :          .       ,       .  ,      ,     ,   . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2>  Temperatura </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A água é apenas um dos fatores que podem determinar o bioma de uma célula. </font><font style="vertical-align: inherit;">Outro fator importante é a temperatura. </font><font style="vertical-align: inherit;">Embora possamos simular o fluxo e a difusão de temperaturas, como a simulação da água, para criar um clima interessante, precisamos apenas de um fator complexo. </font><font style="vertical-align: inherit;">Portanto, vamos manter a temperatura simples e configurá-la para cada célula.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temperatura e latitude </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maior influência na temperatura é a latitude. </font><font style="vertical-align: inherit;">Está quente no equador, frio nos pólos e há uma transição suave entre eles. </font><font style="vertical-align: inherit;">Vamos criar um método </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que retorne a temperatura de uma determinada célula. </font><font style="vertical-align: inherit;">Para começar, basta usar a coordenada Z da célula dividida pela dimensão Z como latitude e, em seguida, usar esse valor como temperatura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> latitude; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definimos a temperatura </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a usamos como dados do mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); cell.SetMapData(temperature); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/789/7f6/334/7897f63347b08fdb02ee5794f3ab28e3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latitude como temperatura, hemisfério sul. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos um gradiente linear de temperatura aumentando de baixo para cima. </font><font style="vertical-align: inherit;">Você pode usá-lo para simular o hemisfério sul, com um polo na parte inferior e um equador na parte superior. </font><font style="vertical-align: inherit;">Mas não precisamos descrever o hemisfério inteiro. </font><font style="vertical-align: inherit;">Com uma diferença de temperatura menor ou nenhuma diferença, podemos descrever uma área menor. </font><font style="vertical-align: inherit;">Para fazer isso, tornaremos as temperaturas baixas e altas personalizáveis. </font><font style="vertical-align: inherit;">Definiremos essas temperaturas no intervalo de 0 a 1 e usaremos os valores extremos como valores padrão.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lowTemperature = <span class="hljs-number"><span class="hljs-number">0f</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highTemperature = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/8cf/805/3b18cf805a56a0dbbeabb03b69a00496.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle deslizante de temperatura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicamos a faixa de temperatura usando interpolação linear, usando a latitude como interpolador. </font><font style="vertical-align: inherit;">Como expressamos latitude como um valor de 0 a 1, podemos usá-lo </font></font><code>Mathf.LerpUnclamped</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que baixas temperaturas não são necessariamente mais baixas que altas. </font><font style="vertical-align: inherit;">Se desejar, você pode entregá-los.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hemisfério </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos simular o hemisfério sul e, possivelmente, o norte, se medirmos primeiro as temperaturas. </font><font style="vertical-align: inherit;">Mas é muito mais conveniente usar uma opção de configuração separada para alternar entre hemisférios. </font><font style="vertical-align: inherit;">Vamos criar uma enumeração e um campo para ele. </font><font style="vertical-align: inherit;">Assim, também adicionaremos a opção de criar os dois hemisférios, que é aplicável por padrão.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HemisphereMode { Both, North, South } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HemisphereMode hemisphere;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/c67/03f/be8c6703f51cd7c62535a96a3035a284.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A escolha do hemisfério. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se precisarmos do hemisfério norte, podemos simplesmente inverter a latitude, subtraindo-a de 1. Para simular os dois hemisférios, os pólos devem estar abaixo e acima do mapa, e o equador deve estar no meio. </font><font style="vertical-align: inherit;">Você pode fazer isso duplicando a latitude, enquanto o hemisfério inferior será processado corretamente e o superior terá uma latitude de 1 a 2. Para corrigir isso, subtraímos a latitude de 2 quando exceder 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.Both) { latitude *= <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latitude &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { latitude = <span class="hljs-number"><span class="hljs-number">2f</span></span> - latitude; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.North) { latitude = <span class="hljs-number"><span class="hljs-number">1f</span></span> - latitude; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c7/871/ede/9c7871ede0c56a393bc603ec888c65bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambos os hemisférios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale ressaltar que isso cria a possibilidade de criar um mapa exótico no qual o equador é frio e os pólos são quentes.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quanto mais alto o frio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além da latitude, a temperatura também é significativamente afetada pela altitude. </font><font style="vertical-align: inherit;">Em média, quanto mais alto subimos, mais frio fica. </font><font style="vertical-align: inherit;">Podemos transformar isso em um fator, como fizemos com os candidatos do rio. </font><font style="vertical-align: inherit;">Nesse caso, usamos a altura da célula. </font><font style="vertical-align: inherit;">Além disso, este indicador diminui com a altura, ou seja, igual a 1 menos a altura dividida pelo máximo em relação ao nível da água. </font><font style="vertical-align: inherit;">Para que o indicador no nível mais alto não caia para zero, adicionamos ao divisor. </font><font style="vertical-align: inherit;">Em seguida, use este indicador para dimensionar a temperatura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75e/a24/550/75ea24550d4325e2af45a1a9627cc53c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A altura afeta a temperatura.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flutuações de temperatura </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos tornar a simplicidade do gradiente de temperatura menos perceptível adicionando flutuações aleatórias de temperatura. </font><font style="vertical-align: inherit;">Uma pequena chance de torná-lo mais realista, mas com muita flutuação, eles parecerão arbitrários. </font><font style="vertical-align: inherit;">Vamos personalizar o poder das flutuações de temperatura e expressá-lo como o desvio máximo de temperatura com um valor padrão de 0,1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperatureJitter = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/e21/83f/27de2183fc453ded3c2902d4705cd1eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle deslizante de flutuação de temperatura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tais flutuações devem ser suaves com pequenas alterações locais. </font><font style="vertical-align: inherit;">Você pode usar nossa textura de ruído para isso. </font><font style="vertical-align: inherit;">Vamos chamar </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e usar como argumento a posição da célula, dimensionada em 0,1. </font><font style="vertical-align: inherit;">Vamos pegar o canal W, centralizá-lo e escalá-lo pelo coeficiente de oscilação. </font><font style="vertical-align: inherit;">Em seguida, adicionamos esse valor à temperatura calculada anteriormente.</font></font><br><br><pre> <code class="cs hljs"> temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); temperature += (HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>).w * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/490/92c/2c8/49092c2c88aaad00d5c54835c6511a74.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/7d9/3cd/dac7d93cdb115574c748269ffebb3d8d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flutuações de temperatura com valores de 0,1 e 1.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos adicionar uma ligeira variabilidade às flutuações em cada mapa, escolhendo aleatoriamente entre os quatro canais de ruído. </font><font style="vertical-align: inherit;">Defina o canal uma vez </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e depois indexe os canais de cores </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temperatureJitterChannel; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitter = HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>)[temperatureJitterChannel]; temperature += (jitter * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/e82/084/30ce820847299346ec8dfaf2bb6cf1a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferentes flutuações de temperatura com força máxima. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que temos dados sobre umidade e temperatura, podemos criar uma matriz de bioma. </font><font style="vertical-align: inherit;">Ao indexar essa matriz, podemos atribuir biomas a todas as células, criando um cenário mais complexo do que usar apenas uma dimensão de dados.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matriz de bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem muitos modelos climáticos, mas não os usaremos. Vamos simplificar, estamos interessados ​​apenas na lógica. Seco significa deserto (frio ou quente), para isso usamos areia. Frio e molhado significa neve. Quente e úmido significa muita vegetação, ou seja, grama. Entre eles, teremos uma taiga ou tundra, que designaremos como uma textura acinzentada da terra. Uma matriz 4 × 4 será suficiente para criar transições entre esses biomas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, atribuímos tipos de elevação com base em cinco intervalos de umidade. Simplesmente baixamos a faixa mais seca para 0,05 e salvamos o resto. Para faixas de temperatura, usamos 0,1, 0,3, 0,6 e superior. Por conveniência, definiremos esses valores em matrizes estáticas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] temperatureBands = { <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] moistureBands = { <span class="hljs-number"><span class="hljs-number">0.12f</span></span>, <span class="hljs-number"><span class="hljs-number">0.28f</span></span>, <span class="hljs-number"><span class="hljs-number">0.85f</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora tenhamos especificado apenas o tipo de relevo com base no bioma, podemos usá-lo para determinar outros parâmetros. </font><font style="vertical-align: inherit;">Portanto, vamos definir em uma </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estrutura </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que descreve a configuração de um bioma individual. </font><font style="vertical-align: inherit;">Até o momento, ele contém apenas o índice de resposta mais o método construtor correspondente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos essa estrutura para criar uma matriz estática contendo dados da matriz. </font><font style="vertical-align: inherit;">Usamos a umidade como coordenada X e a temperatura como Y. Enchemos a linha com a temperatura mais baixa com neve, a segunda linha com tundra e as outras duas com grama. </font><font style="vertical-align: inherit;">Em seguida, substituímos a coluna mais seca pelo deserto, redefinindo a opção de temperatura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/859/bd5/969859bd51e51cce1f7fe63d9eacd55a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matriz de biomas com índices de uma matriz unidimensional.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definição de bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar as </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">células </font><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">bioma, percorreremos as faixas de temperatura e umidade no ciclo para determinar os índices de matriz que precisamos. </font><font style="vertical-align: inherit;">Nós os usamos para obter o bioma desejado e especificar o tipo de topografia celular.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(temperature); float moisture = climate[i].moisture; if (!cell.IsUnderwater) { // if (moisture &lt; 0.05f) { // cell.TerrainTypeIndex = 4; // } // … // else { // cell.TerrainTypeIndex = 2; // } int t = 0; for (; t &lt; temperatureBands.Length; t++) { if (temperature &lt; temperatureBands[t]) { break; } } int m = 0; for (; m &lt; moistureBands.Length; m++) { if (moisture &lt; moistureBands[m]) { break; } } Biome cellBiome = biomes[t * 4 + m]; cell.TerrainTypeIndex = cellBiome.terrain; } else { cell.TerrainTypeIndex = 2; } } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00d/d32/4f5/00dd324f5b421811f49ca157e5217e43.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alívio baseado em uma matriz de bioma.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Configuração do bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos ir além dos biomas definidos na matriz. Por exemplo, na matriz, todos os biomas secos são definidos como desertos de areia, mas nem todos os desertos secos são preenchidos com areia. Existem muitos desertos rochosos que parecem muito diferentes. Portanto, vamos substituir algumas das células do deserto por pedras. Faremos isso simplesmente com base na altura: a areia está em baixas altitudes e as rochas nuas geralmente são encontradas acima. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que a areia vire pedra quando a altura da célula estiver mais próxima da altura máxima do que do nível da água. Esta é a linha de altura dos desertos rochosos que podemos calcular no início </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Quando encontramos uma célula com areia e sua altura é grande o suficiente, alteramos o relevo do bioma para pedra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rockDesertElevation = elevationMaximum - (elevationMaximum - waterLevel) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { … Biome cellBiome = biomes[t * <span class="hljs-number"><span class="hljs-number">4</span></span> + m]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } cell.TerrainTypeIndex = cellBiome.terrain; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/812/13e/1e481213eb2c9b5cf5216b9bfa9546aa.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Areia e desertos rochosos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra mudança baseada na altura é forçar as células na altura máxima a se transformarem em picos de neve, independentemente da temperatura, apenas se não estiverem muito secas. </font><font style="vertical-align: inherit;">Isso aumentará a probabilidade de picos de neve perto do equador quente e úmido.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == elevationMaximum) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/06e/35b/9c406e35b681819072db7a3006151e6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonés de neve na altura máxima.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plantas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos fazer biomas determinar o nível de células vegetais. </font><font style="vertical-align: inherit;">Para fazer isso, adicione ao </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo de plantas e inclua-o no construtor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain, plant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> plant</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.plant = plant; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos biomas mais frios e secos, não haverá plantas. </font><font style="vertical-align: inherit;">Em todos os outros aspectos, quanto mais quente e úmido o clima, mais plantas. </font><font style="vertical-align: inherit;">A segunda coluna de umidade recebe apenas o primeiro nível de plantas para a linha mais quente, portanto [0, 0, 0, 1]. </font><font style="vertical-align: inherit;">A terceira coluna aumenta os níveis em um, com exceção da neve, ou seja, [0, 1, 1, 2]. </font><font style="vertical-align: inherit;">E a coluna mais úmida aumenta novamente, ou seja, [0, 2, 2, 3]. </font><font style="vertical-align: inherit;">Altere a matriz </font></font><code>biomes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adicionando a configuração da planta a ela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f94/bad/c72/f94badc7211d1891415dda94019bf041.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matriz de biomas com níveis de plantas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos definir o nível de plantas para a célula.</font></font><br><br><pre> <code class="cs hljs"> cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/2c6/7f8/ed92c67f8322c4b0c9967c0f394507bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomas com plantas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As plantas agora parecem diferentes?</font></font></b> <div class="spoiler_text">       ,      .       (1, 2, 1)  (0.75, 1, 0.75).     (1.5, 3, 1.5)  (2, 1.5, 2).    — (2, 4.5, 2)  (2.5, 3, 2.5). <br><br>        ,      : (13, 114, 0). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos mudar o nível de plantas para biomas. </font><font style="vertical-align: inherit;">Primeiro, precisamos garantir que eles não apareçam no terreno nevado, que já poderíamos montar. </font><font style="vertical-align: inherit;">Em segundo lugar, vamos aumentar o nível de plantas ao longo dos rios, se ainda não estiver no máximo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">4</span></span>) { cellBiome.plant = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.plant &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; cell.HasRiver) { cellBiome.plant += <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/012/7e4/bd10127e45593cc5f8ce09faa783b10c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plantas modificadas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomas subaquáticos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Até aquele momento, ignorávamos completamente as células subaquáticas. </font><font style="vertical-align: inherit;">Vamos adicionar uma pequena variação a eles, e não usaremos a textura da terra para todos eles. </font><font style="vertical-align: inherit;">Uma solução simples com base na altura já será suficiente para criar uma imagem mais interessante. </font><font style="vertical-align: inherit;">Por exemplo, vamos usar grama para células um passo abaixo do nível da água. </font><font style="vertical-align: inherit;">Também vamos usar grama para células acima do nível da água, isto é, para lagos criados por rios. </font><font style="vertical-align: inherit;">Células com uma altura negativa são áreas do fundo do mar, então usamos pedras para elas. </font><font style="vertical-align: inherit;">Todas as outras células permanecem em terra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= waterLevel) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a62/bb5/5c7/a62bb55c7e4023a4590dbfe73bafe10f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilidade subaquática.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos adicionar mais alguns detalhes para as células subaquáticas ao longo da costa. São células com pelo menos um vizinho acima da água. Se essa célula for rasa, criaremos uma praia. E se estiver próximo ao penhasco, será o detalhe visual dominante, e usaremos a pedra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar isso, verificaremos os vizinhos das células localizadas um passo abaixo do nível da água. Vamos contar o número de conexões por falésias e encostas com células terrestres vizinhas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.WaterLevel; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { slopes += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cliffs += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos usar essas informações para classificar as células. </font><font style="vertical-align: inherit;">Em primeiro lugar, se mais da metade dos vizinhos são terrenos, então estamos lidando com um lago ou uma baía. </font><font style="vertical-align: inherit;">Para essas células, usamos uma textura de grama. </font><font style="vertical-align: inherit;">Caso contrário, se tivermos penhascos, usaremos pedra. </font><font style="vertical-align: inherit;">Caso contrário, se tivermos declives, usaremos areia para criar uma praia. </font><font style="vertical-align: inherit;">A única opção restante é uma área rasa ao largo da costa, para a qual ainda usamos grama.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs + slopes &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slopes &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/8d6/2ed/0eb8d62ed0ec66f7814bd839c9ca32fb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/976/0bc/e349760bc545e3063718b892a9ccbd89.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilidade da costa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como toque final, vamos verificar se não temos células subaquáticas verdes na faixa de temperatura mais baixa. </font><font style="vertical-align: inherit;">Para essas células, usamos a terra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrain == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; temperature &lt; temperatureBands[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tivemos a oportunidade de gerar cartões aleatórios que parecem bastante interessantes e naturais, com muitas opções de configuração. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 27: dobrando um cartão </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dividimos os cartões em colunas que podem ser movidas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centralize o cartão na câmera. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colapsamos tudo. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta última parte, adicionaremos suporte para minimizar o mapa, conectando as bordas leste e oeste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O tutorial foi criado usando o Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/96a/49d/f2996a49dab361c70ce643cc9f2d648b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dobrar faz o mundo girar.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cartões dobráveis </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossos mapas podem ser usados ​​para modelar áreas de tamanhos diferentes, mas eles sempre estão limitados a uma forma retangular. Podemos criar um mapa de uma ilha ou de um continente inteiro, mas não de todo o planeta. Os planetas são esféricos, eles não têm limites rígidos que impedem o movimento em sua superfície. Se você continuar se movendo em uma direção, mais cedo ou mais tarde retornará ao ponto de partida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não podemos envolver uma grade de hexágonos em torno de uma esfera; essa sobreposição é impossível. Nas melhores aproximações, é utilizada a topologia icosaédrica, na qual as doze células devem ser pentágonos. No entanto, sem nenhuma distorção ou exceção, a malha pode ser enrolada ao redor do cilindro. Para fazer isso, basta conectar as bordas leste e oeste do mapa. Com exceção da lógica de empacotamento, tudo o resto permanece o mesmo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um cilindro é uma aproximação aproximada de uma esfera, porque não podemos modelar polos. </font><font style="vertical-align: inherit;">Mas isso não impediu os desenvolvedores de muitos jogos de usar o leste para o oeste para modelar mapas do planeta. </font><font style="vertical-align: inherit;">As regiões polares simplesmente não fazem parte da zona de jogo.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que tal virar para o norte e sul?</font></font></b> <div class="spoiler_text">          ,     .       ,    ,       .        -,            -.         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem duas maneiras de implementar a dobra cilíndrica. </font><font style="vertical-align: inherit;">A primeira é tornar o mapa cilíndrico dobrando sua superfície e tudo o que está nele, de modo que as bordas leste e oeste estejam em contato. </font><font style="vertical-align: inherit;">Agora você jogará não em uma superfície plana, mas em um cilindro real. </font><font style="vertical-align: inherit;">A segunda abordagem é salvar um mapa plano e usar o teletransporte ou a duplicação para recolher. </font><font style="vertical-align: inherit;">A maioria dos jogos usa a segunda abordagem, então vamos adotá-la.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dobragem opcional </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A necessidade de recolher o mapa depende de sua escala - local ou planetária. </font><font style="vertical-align: inherit;">Podemos usar o suporte de ambos, tornando a dobragem opcional. </font><font style="vertical-align: inherit;">Para fazer isso, adicione uma </font><font style="vertical-align: inherit;">nova opção ao </font><font style="vertical-align: inherit;">menu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criar novo mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com o recolhimento ativado por padrão.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/17d/3ef/b0717d3ef8000555a454de943e4e387a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O menu do novo mapa com a opção de recolher. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione ao </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo para rastrear a seleção, bem como um método para alterá-la. </font><font style="vertical-align: inherit;">Vamos fazer com que esse método seja chamado quando o estado do comutador for alterado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWrapping</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { wrapping = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando um novo mapa é solicitado, passamos o valor da opção minimizar. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z, wrapping); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z, wrapping); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Altere-o </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele aceite esse novo argumento e depois o passe para </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … grid.CreateMap(x, z, wrapping); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">código&gt; O HexGrid deve saber se estamos recolhendo, portanto, adicione um campo a ele e </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defina-o. </font><font style="vertical-align: inherit;">Outras classes devem mudar sua lógica, dependendo se a grade é minimizada, para tornar o campo geral. </font><font style="vertical-align: inherit;">Além disso, permite definir o valor padrão por meio do inspetor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCountX = <span class="hljs-number"><span class="hljs-number">20</span></span>, cellCountZ = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … cellCountX = x; cellCountZ = z; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; … }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamadas próprias </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em dois lugares. </font><font style="vertical-align: inherit;">Podemos simplesmente usar seu próprio campo para o argumento de recolhimento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … CreateMap(cellCountX, cellCountZ, wrapping); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d57/fc1/36ad57fc1ff8967bbd8282808f762241.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O interruptor de dobramento da grade está ativado por padrão.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salvando e carregando </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o dobramento está definido para cada cartão, ele deve ser salvo e carregado. </font><font style="vertical-align: inherit;">Isso significa que você precisa alterar o formato de salvamento de arquivo, para aumentar a versão constantemente </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao salvar, </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basta escrever o valor da dobra booleana após o tamanho do mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); writer.Write(wrapping); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao carregar, vamos lê-lo apenas com a versão correta do arquivo. </font><font style="vertical-align: inherit;">Se for diferente, esse é um cartão antigo e não deve ser minimizado. </font><font style="vertical-align: inherit;">Salve essas informações em uma variável local e compare-as com o estado atual da dobra. </font><font style="vertical-align: inherit;">Se for diferente, não podemos reutilizar a topologia de mapa existente da mesma maneira que faria ao carregar um mapa com outros tamanhos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = header &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping != wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Métricas dobráveis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimizar o mapa exigirá grandes alterações na lógica, por exemplo, ao calcular distâncias. </font><font style="vertical-align: inherit;">Portanto, eles podem tocar no código que não possui um link direto para a grade. </font><font style="vertical-align: inherit;">Em vez de passar essas informações como argumentos, vamos adicioná-las </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Adicione um número inteiro estático que contenha o tamanho da dobra que corresponda à largura do mapa. </font><font style="vertical-align: inherit;">Se for maior que zero, estamos lidando com um cartão dobrável. </font><font style="vertical-align: inherit;">Para verificar isso, adicione uma propriedade.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Wrapping { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wrapSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos definir o tamanho da dobra para cada chamada </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como esses dados não sobreviverão à recompilação no modo Play, nós os definiremos </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ResetVisibility(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Largura da célula </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao trabalhar com cartões dobráveis, geralmente precisamos lidar com as posições ao longo do eixo X, medidas na largura das células. </font><font style="vertical-align: inherit;">Embora possa ser usado para isso </font></font><code>HexMetrics.innerRadius * 2f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seria mais conveniente se não adicionássemos multiplicação sempre. </font><font style="vertical-align: inherit;">Então, vamos adicionar uma constante </font></font><code>HexMetrics.innerDiameter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerDiameter = innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Já podemos usar o diâmetro em três locais. </font><font style="vertical-align: inherit;">Em primeiro lugar, </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ao posicionar uma nova célula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.innerDiameter; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limitando a posição da câmera.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E também na </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conversão de posição em coordenadas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / HexMetrics.innerDiameter; … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centralização do cartão </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando o mapa não entra em colapso, ele define claramente as bordas leste e oeste e, portanto, um claro centro horizontal. </font><font style="vertical-align: inherit;">Mas no caso de um cartão dobrável, tudo é diferente. </font><font style="vertical-align: inherit;">Não tem a borda oriental nem a ocidental, nem o centro. </font><font style="vertical-align: inherit;">Como alternativa, podemos assumir que o centro é onde está a câmera. </font><font style="vertical-align: inherit;">Isso será útil porque queremos que o mapa esteja sempre centralizado em nosso ponto de vista. </font><font style="vertical-align: inherit;">Então, onde quer que estejamos, não veremos as bordas leste ou oeste do mapa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colunas do fragmento do mapa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que a visualização do mapa seja centralizada em relação à câmera, precisamos alterar o posicionamento dos elementos, dependendo do movimento da câmera. Se ele se move para oeste, precisamos pegar o que está atualmente na borda da parte leste e movê-lo para a borda da parte ocidental. O mesmo se aplica à direção oposta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealmente, assim que a câmera se mover para a coluna vizinha de células, devemos mover imediatamente a coluna mais distante para o outro lado. No entanto, não precisamos ser tão precisos. Em vez disso, podemos transferir fragmentos inteiros do mapa. Isso nos permite mover partes do mapa sem precisar modificar as malhas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como estamos movendo colunas inteiras de fragmentos ao mesmo tempo, vamos agrupá-los criando um objeto de coluna pai para cada grupo. </font><font style="vertical-align: inherit;">Adicione uma matriz para esses objetos </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e nós a inicializaremos </font></font><code>CreateChunks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nós os usaremos apenas como contêineres, portanto, precisamos rastrear o link para seus componentes </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como no caso de fragmentos, suas posições iniciais estão localizadas na origem local das coordenadas da grade.</font></font><br><br><pre> <code class="cs hljs"> Transform[] columns; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { columns = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Transform[chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { columns[x] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>).transform; columns[x].SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora, o fragmento deve se tornar filho da coluna correspondente, não da grade. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(columns[x], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/415/920/bb2/415920bb2e4e2e002793aaebee8e04e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmentos agrupados em colunas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como agora todos os fragmentos se tornaram filhos das colunas, </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basta destruirmos diretamente todas as colunas, não os fragmentos. </font><font style="vertical-align: inherit;">Então, vamos nos livrar dos fragmentos da filha.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columns != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { Destroy(columns[i].gameObject); } } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colunas de teletransporte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione ao </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">novo método </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a posição X como parâmetro. </font><font style="vertical-align: inherit;">Converta a posição no índice da coluna, dividindo-a pela largura do fragmento em unidades do Unity. </font><font style="vertical-align: inherit;">Este será o índice da coluna na qual a câmera está localizada atualmente, ou seja, será a coluna central do mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basta mudar a visualização do mapa apenas quando o índice da coluna central é alterado. </font><font style="vertical-align: inherit;">Então, vamos acompanhar em campo. </font><font style="vertical-align: inherit;">Usamos o valor padrão -1 ao criar um mapa, para que novos mapas estejam sempre centralizados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centerColumnIndex == currentCenterColumnIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } currentCenterColumnIndex = centerColumnIndex; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que conhecemos o índice da coluna central, podemos determinar os índices mínimo e máximo, subtraindo e adicionando metade do número de colunas. Como usamos valores inteiros, com um número ímpar de colunas, isso funciona perfeitamente. No caso de um número par, não pode haver uma coluna perfeitamente centralizada; portanto, um dos índices estará um passo além do necessário. Isso cria um deslocamento de uma coluna na direção da extremidade mais distante do mapa, mas para nós isso não é um problema.</font></font><br><br><pre> <code class="cs hljs"> currentCenterColumnIndex = centerColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que esses índices podem ser negativos ou maiores que o índice máximo natural da coluna. </font><font style="vertical-align: inherit;">O mínimo é zero apenas quando a câmera está perto do centro natural do mapa. </font><font style="vertical-align: inherit;">Nossa tarefa é mover as colunas para que correspondam a esses índices relativos. </font><font style="vertical-align: inherit;">Isso pode ser feito alterando a coordenada X local de cada coluna no loop.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; Vector3 position; position.y = position.z = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; columns[i].localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para cada coluna, verificamos se o índice do índice mínimo é menor. </font><font style="vertical-align: inherit;">Nesse caso, está muito longe à esquerda do centro. </font><font style="vertical-align: inherit;">Ele deve se teletransportar para o outro lado do mapa. </font><font style="vertical-align: inherit;">Isso pode ser feito tornando sua coordenada X igual à largura do mapa. </font><font style="vertical-align: inherit;">Da mesma forma, se o índice da coluna for maior que o índice máximo, ele estará muito distante à direita do centro e deverá se teletransportar para o outro lado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; minColumnIndex) { position.x = chunkCountX * (HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; maxColumnIndex) { position.x = chunkCountX * -(HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } columns[i].localPosition = position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimento da câmera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mude </font></font><code>HexMapCamera.AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que, ao trabalhar com um cartão dobrável, ele </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ligue </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primeiro, basta tornar o novo método uma </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duplicata </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas com a única diferença: no final, ele chamará </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { … transform.localPosition = grid.wrapping ? WrapPosition(position) : ClampPosition(position); } … <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); grid.CenterMap(position.x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mapa foi imediatamente centrado, chamar </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; ValidatePosition(); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mova para a esquerda e direita ao centralizar na câmera. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora ainda restringamos o movimento da câmera, o mapa agora tenta centralizar em relação à câmera, teleportando colunas de fragmentos do mapa, se necessário. </font><font style="vertical-align: inherit;">Com um pequeno mapa e uma câmera remota, isso é claramente visível, mas em um mapa grande, fragmentos teletransportados estão fora do alcance de visualização da câmera. </font><font style="vertical-align: inherit;">Obviamente, apenas as bordas leste e oeste do mapa são perceptíveis, porque ainda não há triangulação entre elas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Remover a restrição da sua coordenada X, a fim de minimizar e de câmara </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em vez disso, continuaremos aumentando a coordenada X pela largura do mapa, enquanto estiver abaixo de zero, e reduzindo-a enquanto for maior que a largura do mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// float xMax = (grid.cellCountX - 0.5f) * HexMetrics.innerDiameter; // position.x = Mathf.Clamp(position.x, 0f, xMax); float width = grid.cellCountX * HexMetrics.innerDiameter; while (position.x &lt; 0f) { position.x += width; } while (position.x &gt; width) { position.x -= width; } float zMax = (grid.cellCountZ - 1) * (1.5f * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, 0f, zMax); grid.CenterMap(position.x); return position; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A câmera de rolagem se move ao longo do mapa.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texturas de Shader dobráveis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com exceção do espaço de triangulação, minimizar a câmera no modo de jogo deve ser imperceptível. No entanto, quando isso acontece, uma alteração visual ocorre na metade da topografia e na água. Isso acontece porque usamos uma posição no mundo para provar essas texturas. Um teletransporte nítido do fragmento altera a localização das texturas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos resolver esse problema fazendo as texturas aparecerem em blocos que são múltiplos do tamanho do fragmento. O tamanho do fragmento é calculado a partir das constantes </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto, vamos criar o arquivo de inclusão do sombreador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexMetrics.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e colar as definições correspondentes nele. A escala básica de ladrilhos é calculada a partir do tamanho do fragmento e do raio externo da célula. Se você usar outras métricas, precisará modificar o arquivo de acordo.</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_TO_INNER 0.866025404 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_RADIUS 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHUNK_SIZE_X 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TILING_SCALE (1 / (CHUNK_SIZE_X * 2 * OUTER_RADIUS / OUTER_TO_INNER))</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso nos dá uma escala de lado a lado de 0,00866025404. </font><font style="vertical-align: inherit;">Se usarmos um múltiplo inteiro desse valor, a texturização não será afetada pelo teletransporte de fragmentos. </font><font style="vertical-align: inherit;">Além disso, as texturas nas bordas leste e oeste do mapa se unirão perfeitamente depois que triangularmos corretamente sua conexão. </font><font style="vertical-align: inherit;">Usamos 0,02 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como a escala UV no shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Em vez disso, podemos usar a escala de mosaico dobrado, que é 0,01732050808. </font><font style="vertical-align: inherit;">A escala é obtida um pouco menos do que era e a escala da textura aumentou um pouco, mas visualmente é invisível.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" … <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3( <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE), <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] ); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para ruído UV, usamos uma escala de 0,025. </font><font style="vertical-align: inherit;">Em vez disso, você pode usar a escala de mosaico triplo. </font><font style="vertical-align: inherit;">Isso nos dá 0,02598076212, que é bem próximo.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, em </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usamos 0,015 para espuma e 0,025 para ondas. </font><font style="vertical-align: inherit;">Aqui, podemos novamente substituir esses valores por uma escala de ladrilhos dobrada e triplicada.</font></font><br><br><pre> <code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"HexMetrics.cginc"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Foam (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { shore = <span class="hljs-keyword"><span class="hljs-keyword">sqrt</span></span>(shore) * <span class="hljs-number"><span class="hljs-number">0.9</span></span>; float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; float4 <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span> = tex2D(noiseTex, noiseUV * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE)); … } … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; float4 noise1 = tex2D(noiseTex, uv1 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); float2 uv2 = worldXZ; uv2.x += _Time.y; float4 noise2 = tex2D(noiseTex, uv2 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A união do leste e oeste </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse estágio, a única evidência visual de minimizar o mapa é um pequeno espaço entre as colunas mais a leste e mais a oeste. </font><font style="vertical-align: inherit;">Essa lacuna ocorre porque ainda não triangulamos as conexões de arestas e ângulos entre células em lados opostos do mapa sem dobrar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/85f/e79/24085fe7986100674854b9c9a79c349c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espaço na borda.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vizinhos dobráveis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para triangular a conexão leste-oeste, precisamos tornar as células dos lados opostos próximas umas das outras. </font><font style="vertical-align: inherit;">Até o momento, não estamos fazendo isso, porque a </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conexão E - W é estabelecida com a célula anterior apenas se seu índice em X for maior que zero. </font><font style="vertical-align: inherit;">Para recolher essa conexão, precisamos conectar a última célula da linha com a primeira na mesma linha ao dobrar o mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping &amp;&amp; x == cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.E, cells[i - x]); } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tendo estabelecido a conexão dos vizinhos E - W, obtemos uma triangulação parcial da lacuna. </font><font style="vertical-align: inherit;">A conexão das arestas não é ideal, porque a distorção está oculta incorretamente. </font><font style="vertical-align: inherit;">Nós vamos lidar com isso mais tarde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/68a/6b6/ce568a6b639801e47804eb35a62493c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compostos E - W. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Também precisamos recolher os links NE - SW. </font><font style="vertical-align: inherit;">Isso pode ser feito conectando a primeira célula de cada linha par com as últimas células da linha anterior. </font><font style="vertical-align: inherit;">Será apenas a célula anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor(HexDirection.SW, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/239/66f/c3c/23966fc3c616ea9338a3a14d187dcc7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conexões NE - SW. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, as conexões SE - NW são estabelecidas no final de cada linha ímpar abaixo da primeira. </font><font style="vertical-align: inherit;">Essas células devem estar conectadas à primeira célula da linha anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor( HexDirection.SE, cells[i - cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e8/df4/62e/3e8df462e076bbdf93396f6cec525cc4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compostos SE - NW.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dobragem de ruído </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ocultar perfeitamente a lacuna, precisamos garantir que as bordas leste e oeste do mapa correspondam ao ruído perfeitamente usado para distorcer as posições dos vértices. </font><font style="vertical-align: inherit;">Podemos usar o mesmo truque usado para shaders, mas uma escala de ruído de 0,003 foi usada para distorção. </font><font style="vertical-align: inherit;">Para garantir a telha, é necessário aumentar significativamente a escala, o que levará a uma distorção mais caótica dos vértices. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma solução alternativa não é reduzir o ruído, mas sim atenuar o ruído nas bordas do mapa. </font><font style="vertical-align: inherit;">Se você realizar uma atenuação suave ao longo da largura de uma célula, a distorção criará uma transição suave sem intervalos. </font><font style="vertical-align: inherit;">O ruído nessa área será suavizado e, a uma longa distância, a alteração parecerá nítida, mas isso não é tão óbvio ao usar uma leve distorção dos vértices.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E as flutuações de temperatura?</font></font></b> <div class="spoiler_text">           .      ,      .         ,   .     ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se não recolhermos o cartão, podemos conviver com uma </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">única amostra. </font><font style="vertical-align: inherit;">Mas ao dobrar, é necessário adicionar atenuação. </font><font style="vertical-align: inherit;">Portanto, antes de retornar a amostra, salve-a em uma variável.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sample; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao minimizar, precisamos misturar com a segunda amostra. </font><font style="vertical-align: inherit;">Como realizaremos a transição na parte leste do mapa, a segunda amostra precisa ser movida para o oeste.</font></font><br><br><pre> <code class="cs hljs"> Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A atenuação é realizada usando interpolação linear simples da parte oeste para a parte leste, ao longo da largura de uma célula. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/84f/75d/c4e84f75dd0260efb18a9d3d66647c55.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mistura de ruído, uma solução imperfeita.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como resultado, não obtemos uma correspondência exata, porque algumas das células no lado leste têm coordenadas X negativas. Para não se aproximar dessa área, vamos mover a região de transição para o oeste, metade da largura da célula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) - <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/af4/1fb/04faf41fb669427487a2dbb6855cd5bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atenuação correta.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edição de Células </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que a triangulação parece correta, vamos ter certeza de que podemos editar tudo no mapa e na costura da dobra. Como se vê, em fragmentos teletransportados, as coordenadas são errôneas e os pincéis grandes são cortados por uma costura.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/18b/5ce/a1f18b5ce7b87b38a7a58d47e341d4f1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O pincel é aparado.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para corrigir isso, precisamos relatar a </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dobra. Podemos fazer isso combinando a coordenada X no método construtor. Sabemos que a coordenada axial X é obtida a partir da coordenada X do deslocamento, subtraindo metade da coordenada Z. Você pode usar essas informações para realizar a transformação inversa e verificar se a coordenada zero é menor que zero. Nesse caso, temos a coordenada além do lado leste do mapa desdobrado. Como em cada direção nós teleportamos não mais do que a metade do mapa, será suficiente adicionarmos o tamanho da dobra a X uma vez. E quando a coordenada de deslocamento é maior que o tamanho da dobra, precisamos realizar uma subtração.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oX = x + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &gt;= HexMetrics.wrapSize) { x -= HexMetrics.wrapSize; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Às vezes, ao editar a parte inferior ou superior do mapa, recebo erros </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso acontece quando, devido à distorção dos vértices, o cursor aparece na linha de células fora do mapa. </font><font style="vertical-align: inherit;">Este é um erro que ocorre porque não combinamos as coordenadas </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o parâmetro vetorial. </font><font style="vertical-align: inherit;">Isso pode ser corrigido aplicando um método </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com coordenadas como parâmetros que realizarão as verificações necessárias.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-comment"><span class="hljs-comment">// int index = // coordinates.X + coordinates.Z * cellCountX + coordinates.Z / 2; // return cells[index]; return GetCell(coordinates); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dobragem costeira </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A triangulação funciona bem para o terreno, mas ao longo da costura leste-oeste não existem bordas da costa da água. </font><font style="vertical-align: inherit;">Na verdade, eles são, eles simplesmente não entram em colapso. </font><font style="vertical-align: inherit;">Eles são virados e esticados para o outro lado do mapa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/20a/ed3/6fe20aed3cb0dea0a9e47ef08caa10f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falta a borda da água. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso acontece porque, ao triangular a água da costa, usamos a posição de um vizinho. </font><font style="vertical-align: inherit;">Para consertar isso, precisamos determinar com o que estamos lidando, localizado no outro lado do cartão. </font><font style="vertical-align: inherit;">Para simplificar a tarefa, adicionaremos uma </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coluna de célula </font><font style="vertical-align: inherit;">à </font><font style="vertical-align: inherit;">propriedade do índice.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ColumnIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribua este índice a </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">É simplesmente igual à coordenada de deslocamento X dividida pelo tamanho do fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.Index = i; cell.ColumnIndex = x / HexMetrics.chunkSizeX; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determinar o que é minimizado comparando o índice da coluna da célula atual e seu vizinho. </font><font style="vertical-align: inherit;">Se o índice da coluna do vizinho for menor que um passo a menos, estaremos no lado oeste e o vizinho no lado leste. </font><font style="vertical-align: inherit;">Portanto, precisamos virar nosso vizinho para o oeste. </font><font style="vertical-align: inherit;">O mesmo e na direção oposta.</font></font><br><br><pre> <code class="cs hljs"> Vector3 center2 = neighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/308/3ec/f133083ec9172168e5302d737fd0ce27.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costelas da costa, mas sem cantos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por isso, cuidamos das costelas da costa, mas até agora não lidávamos com cantos. </font><font style="vertical-align: inherit;">Precisamos fazer o mesmo com o próximo vizinho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 center3 = nextNeighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; } Vector3 v3 = center3 + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/c0d/751/d02c0d7510fba8b3707b89f146b71837.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costa adequadamente reduzida.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geração de cartão </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A opção de conectar os lados leste e oeste afeta a geração de mapas. </font><font style="vertical-align: inherit;">Ao minimizar o mapa, o algoritmo de geração também deve ser minimizado. </font><font style="vertical-align: inherit;">Isso levará à criação de outro mapa, mas ao usar uma </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">borda de mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diferente de zero </font><em><font style="vertical-align: inherit;">X, a</font></em><font style="vertical-align: inherit;"> dobra não é óbvia.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/01f/f90/54001ff900386d5f389850de0a1d0034.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/428/859/ecb/428859ecb5c5bf9a68b277675110e44b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa grande 1208905299 com configurações padrão. Com dobrável e sem ele.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando minimizado não faz sentido usar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o Map Border o X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mas não podemos simplesmente nos livrar disso, porque ao mesmo tempo as regiões se fundem. Ao minimizar, podemos usar apenas um </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RegionBorder</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nós mudamos </font></font><code>HexMapGenerator.CreateRegions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, substituindo em todos os casos </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Essa nova variável será igual a ou </font></font><code>regionBorder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dependendo do valor da opção de recolhimento. Abaixo, mostrei as alterações apenas no primeiro caso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> borderX = grid.wrapping ? regionBorder : mapBorderX; MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao mesmo tempo, as regiões permanecem separadas, mas isso é necessário apenas se houver regiões diferentes nos lados leste e oeste do mapa. </font><font style="vertical-align: inherit;">Existem dois casos em que isso não é respeitado. </font><font style="vertical-align: inherit;">A primeira é quando temos apenas uma região. </font><font style="vertical-align: inherit;">A segunda é quando há duas regiões dividindo o mapa horizontalmente. </font><font style="vertical-align: inherit;">Nesses casos, podemos atribuir um </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor zero, o que permitirá que as massas de terra atravessem a costura leste-oeste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/4d4/c9e/db84d4c9e40c9e35ad29af69314f73e1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma região está entrando em colapso. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À primeira vista, parece que tudo funciona corretamente, mas há realmente uma lacuna ao longo da costura. </font><font style="vertical-align: inherit;">Isso se torna mais perceptível se você definir a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Porcentagem de erosão para</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zero.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a4e/572/ef5a4e5722dbbb8af91e770220d7d141.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/f75/fce/6b3f75fce35d6be9c8a66c445c4dc9cd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando a erosão é desativada, uma costura no relevo se torna perceptível.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A diferença ocorre porque a costura impede o crescimento de fragmentos de alívio. Para determinar o que é adicionado primeiro, é usada a distância da célula ao centro do fragmento, e as células do outro lado do mapa podem estar muito distantes, portanto quase nunca são ativadas. Claro, isso está errado. Precisamos ter certeza de que </font></font><code>HexCoordinates.DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conhecemos o mapa minimizado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculamos a distância entre </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, somando as distâncias absolutas ao longo de cada um dos três eixos e reduzindo pela metade o resultado. A distância ao longo de Z é sempre verdadeira, mas dobrar ao longo pode afetar as distâncias X e Y. Então, vamos começar com um cálculo separado de X + Y.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return // ((x &lt; other.x ? other.x - x : x - other.x) + // (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + // (z &lt; other.z ? other.z - z : z - other.z)) / 2; int xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); return (xy + (z &lt; other.z ? other.z - z : z - other.z)) / 2; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determinar se a dobra cria uma distância menor para células arbitrárias não é uma tarefa fácil, então vamos calcular X + Y para os casos em que estamos dobrando outra coordenada para o lado oeste. </font><font style="vertical-align: inherit;">Se o valor for menor que o X + Y original, use-o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se isso não levar a uma distância menor, é possível diminuir a velocidade na outra direção, para que possamos verificar. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other.x -= <span class="hljs-number"><span class="hljs-number">2</span></span> * HexMetrics.wrapSize; xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora sempre obtemos a menor distância no mapa dobrável. </font><font style="vertical-align: inherit;">Fragmentos de terreno não são mais bloqueados por uma costura, o que permite que as massas de terra se enrolem.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/fb7/3b8/65cfb73b8107d7744ff8cdcabaf48083.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/149/e6f/717/149e6f717defe9288565f37f7efcdf56.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alívio corretamente dobrável, sem erosão e erosão. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viajando pelo mundo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depois de considerar a geração e triangulação de mapas, passemos agora a verificar esquadrões, exploração e visibilidade. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Costura de teste </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O primeiro obstáculo que encontramos ao mover um esquadrão pelo mundo é a borda do mapa, que não pode ser explorada. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/4f4/748/4524f4748d2c4e3cb983ec5ecbf064c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A costura do cartão não pode ser examinada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As células ao longo da borda do mapa são inexploradas para ocultar a conclusão abrupta do mapa. </font><font style="vertical-align: inherit;">Mas quando o mapa é minimizado, apenas as células norte e sul devem ser marcadas, mas não o leste e o oeste. </font><font style="vertical-align: inherit;">Mude </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para levar isso em consideração.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.Explorable = z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilidade dos recursos de relevo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos verificar se a visibilidade funciona ao longo da costura. </font><font style="vertical-align: inherit;">Funciona para terrenos, mas não para objetos de terrenos. </font><font style="vertical-align: inherit;">Parece que objetos em colapso obtêm a visibilidade da última célula que não foi recolhida.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/ac1/811/631ac18111ba1eb8dfcf74a39fb2ffbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilidade incorreta dos objetos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso acontece porque o modo de </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fixação é definido </font><font style="vertical-align: inherit;">para o modo de dobra de textura usado </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para resolver o problema, basta alterar o modo de fixação para repetir. </font><font style="vertical-align: inherit;">Mas precisamos fazer isso apenas para as coordenadas de U, portanto </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, definiremos </font></font><code>wrapModeU</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isso </font></font><code>wrapModeV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separadamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; <span class="hljs-comment"><span class="hljs-comment">// cellTexture.wrapMode = TextureWrapMode.Clamp; cellTexture.wrapModeU = TextureWrapMode.Repeat; cellTexture.wrapModeV = TextureWrapMode.Clamp; Shader.SetGlobalTexture("_HexCellData", cellTexture); } … }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esquadrões e Colunas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro problema é que as unidades ainda não estão desmoronando. </font><font style="vertical-align: inherit;">Depois de mover a coluna em que estão localizadas, as unidades permanecem no mesmo local.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/29b/827/c5029b8273d7b53a3ddac2da03d9987f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A unidade não é transferida e está do lado errado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse problema pode ser resolvido transformando os esquadrões em elementos filhos de colunas, como fizemos com os fragmentos. </font><font style="vertical-align: inherit;">Primeiro, não os tornaremos os filhos imediatos da rede </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// unit.transform.SetParent(transform, false); unit.Location = location; unit.Orientation = orientation; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como as unidades estão se movendo, elas podem aparecer em outra coluna, ou seja, será necessário alterar seus pais. </font><font style="vertical-align: inherit;">Para tornar isso possível, adicionamos ao </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método geral </font></font><code>MakeChildOfColumn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, como parâmetros, passamos a ele o componente do </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento filho e o índice da coluna.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeChildOfColumn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> columnIndex</span></span></span><span class="hljs-function">)</span></span> { child.SetParent(columns[columnIndex], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos chamar esse método quando a propriedade estiver configurada </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … Grid.MakeChildOfColumn(transform, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ColumnIndex); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso resolve o problema de criar unidades. </font><font style="vertical-align: inherit;">Mas também precisamos fazê-los mover para a coluna desejada ao se mover. </font><font style="vertical-align: inherit;">Para fazer isso, você precisa acompanhar </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a coluna atual </font><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">índice. </font><font style="vertical-align: inherit;">No início desse método, este é o índice da coluna da célula no início do caminho, ou o atual se a movimentação foi interrompida pela recompilação.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Grid.DecreaseVisibility( // currentTravelLocation ? currentTravelLocation : pathToTravel[0], // VisionRange // ); if (!currentTravelLocation) { currentTravelLocation = pathToTravel[0]; } Grid.DecreaseVisibility(currentTravelLocation, VisionRange); int currentColumn = currentTravelLocation.ColumnIndex; … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durante cada iteração da movimentação, verificaremos se o índice da próxima coluna é diferente e, se for, mudaremos o pai da ordem. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { … Grid.IncreaseVisibility(pathToTravel[i], VisionRange); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentColumn != nextColumn) { Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso permitirá que as unidades se movam de maneira semelhante aos fragmentos. </font><font style="vertical-align: inherit;">No entanto, ao se mover pela costura do cartão, as unidades ainda não entram em colapso. </font><font style="vertical-align: inherit;">Em vez disso, eles de repente começam a se mover na direção errada. </font><font style="vertical-align: inherit;">Isso acontece independentemente da localização da costura, mas mais notavelmente quando eles pulam o mapa inteiro.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corridas de cavalos pelo mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui podemos usar a mesma abordagem usada para a costa, só que desta vez faremos a curva pela qual o desapego se move. </font><font style="vertical-align: inherit;">Se a próxima coluna for virada para leste, teleportaremos a curva também para leste, da mesma forma para a outra direção. </font><font style="vertical-align: inherit;">Você precisa alterar os pontos de controle da curva </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o que também afetará o ponto de controle </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// c = (b + currentTravelLocation.Position) * 0.5f; // Grid.IncreaseVisibility(pathToTravel[i], VisionRange); int nextColumn = currentTravelLocation.ColumnIndex; if (currentColumn != nextColumn) { if (nextColumn &lt; currentColumn - 1) { ax -= HexMetrics.innerDiameter * HexMetrics.wrapSize; bx -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } else if (nextColumn &gt; currentColumn + 1) { ax += HexMetrics.innerDiameter * HexMetrics.wrapSize; bx += HexMetrics.innerDiameter * HexMetrics.wrapSize; } Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } c = (b + currentTravelLocation.Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], VisionRange); … }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movimento com dobradura.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A última coisa a fazer é mudar o turno inicial do esquadrão quando ele olha para a primeira célula na qual se moverá. Se esta célula estiver do outro lado da costura leste-oeste, a unidade olhará na direção errada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao minimizar um mapa, há duas maneiras de observar um ponto que não está exatamente no norte ou no sul. Você pode olhar para o leste ou oeste. Será lógico olhar na direção correspondente à distância mais próxima do ponto, porque também é a direção do movimento, então vamos usá-lo </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao minimizar, verificaremos a distância relativa ao longo do eixo X. Se for menor que a metade negativa da largura do mapa, devemos olhar para o oeste, o que pode ser feito girando o ponto para o oeste. </font><font style="vertical-align: inherit;">Caso contrário, se a distância for mais da metade da largura do mapa, devemos entrar em colapso para o leste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDistance = point.x - transform.localPosition.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &lt; -HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x += HexMetrics.innerDiameter * HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &gt; HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, temos um mapa minimizado totalmente funcional. </font><font style="vertical-align: inherit;">E isso conclui a série de tutoriais em mapas hexagonais. </font><font style="vertical-align: inherit;">Como mencionado nas seções anteriores, outros tópicos podem ser considerados, mas não são específicos para mapas hexagonais. </font><font style="vertical-align: inherit;">Talvez eu os considere em futuras séries de tutoriais.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baixei o último pacote e recebo erros de turnos no modo Play</font></font></b> <div class="spoiler_text">  ,       <em>Rotation</em> .    .  .   5. </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baixei o último pacote e os gráficos não são tão bonitos quanto nas capturas de tela</font></font></b> <div class="spoiler_text">        . -    . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baixei o último pacote e ele gera constantemente o mesmo cartão</font></font></b> <div class="spoiler_text">      seed (1208905299),      .    ,  <em>Use Fixed Seed</em> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427567/">https://habr.com/ru/post/pt427567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427555/index.html">Animais que os humanos aprenderam a rastrear usando a tecnologia de reconhecimento facial</a></li>
<li><a href="../pt427557/index.html">Resumo dos eventos de TI em novembro (primeira parte)</a></li>
<li><a href="../pt427561/index.html">Direito de reparo: os primeiros passos na direção certa da Motorola</a></li>
<li><a href="../pt427563/index.html">Padrão SNI criptografado implementado no Firefox Nightly</a></li>
<li><a href="../pt427565/index.html">“Minha conquista foi que geralmente voltei à profissão” - 10 perguntas ao programador, edição 10</a></li>
<li><a href="../pt427569/index.html">Ajuste o OpenStack sob alta carga</a></li>
<li><a href="../pt427571/index.html">A união do R e do PostgreSQL. Analisamos o trabalho dos aeroportos, calculamos pensões</a></li>
<li><a href="../pt427573/index.html">Candy or Life: Halloween como uma razão para atrair seu filho para a ciência</a></li>
<li><a href="../pt427575/index.html">Por que o Wi-Fi não funcionará conforme o planejado e por que saber qual telefone o funcionário usa</a></li>
<li><a href="../pt427577/index.html">Aprendizado de máquina versus análise de assinatura ao detectar ataques em um aplicativo Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>