<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游도 游 游볜 Agujeros moleculares en JavaScript 游븾游 游 游녪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les presento la traducci칩n del art칤culo "Wormholes in JavaScript" de Mathius Buus. 





 Las computadoras son m치quinas interesantes. En te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Agujeros moleculares en JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428201/"><p>  Hola Habr!  Les presento la traducci칩n del art칤culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Wormholes in JavaScript"</a> de Mathius Buus. </p><br><p><img src="https://habrastorage.org/webt/ak/t9/k_/akt9k_w0hs5lodk-p8ezfr4f6pk.jpeg"></p><br><p>  Las computadoras son m치quinas interesantes.  En teor칤a, nos parecen matem치ticos mec치nicos ideales que trabajan con n칰meros y realizan bien las operaciones de suma, multiplicaci칩n y resta. </p><br><p>  Sin embargo, tal abstracci칩n es bastante enga침osa.  Nos aleja de la comprensi칩n de que una computadora procesa diferentes operaciones matem치ticas a diferentes velocidades.  Si escribe en JavaScript (o en cualquier otro idioma) y le preocupa el rendimiento de los algoritmos que escribi칩, es muy importante comprender c칩mo funcionan las computadoras bajo el cap칩. </p><br><p> Si sabemos de lo que es capaz la computadora, podemos usar los caminos m치s cortos o agujeros de gusano para hacer que nuestros programas sean mucho m치s r치pidos de lo que esper치bamos. </p><a name="habracut"></a><br><h2 id="krotovaya-nora-v-operacii-polucheniya-ostatka-ot-deleniya">  Wormhole en la operaci칩n de obtener el resto de la divisi칩n </h2><br><p>  쯈u칠 significa exactamente esto?  Veamos un ejemplo: imagine que queremos implementar una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lista de anillo</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una lista de anillo</a> es una lista de tama침o fijo en la que las inserciones m치s grandes que el tama침o de la lista se mueven a la parte superior de la lista y en un c칤rculo.  Las listas de llamadas son muy convenientes para muchas cosas, como la recopilaci칩n de estad칤sticas para intervalos de tiempo espec칤ficos, el almacenamiento en b칰fer de datos y m치s, pero observe esta implementaci칩n: </p><br><pre><code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>(<span class="hljs-number"><span class="hljs-number">15000</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  % -   ,     //        //    ,     i    list[i % list.length] = item }</span></span></code> </pre> <br><p>  쯈u칠 tan r치pido se ejecuta este c칩digo?  Hagamos una prueba de velocidad simple </p><br><pre> <code class="hljs matlab">console.time() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">1e9</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { set(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) } console.timeEnd()</code> </pre><br><p>  En mi computadora, tard칩 ~ 4 segundos para mil millones de insertos.  No esta mal. </p><br><p>  Sin embargo, apliquemos un agujero de gusano computacional y cambiemos el tama침o de la matriz a un n칰mero m치gico: </p><br><pre> <code class="hljs powershell">//     <span class="hljs-number"><span class="hljs-number">15000</span></span>  <span class="hljs-number"><span class="hljs-number">16384</span></span> const list = new Array(<span class="hljs-number"><span class="hljs-number">16384</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, item)</span></span></span></span> { //  % -   ,     //        //    ,     i    list[<span class="hljs-type"><span class="hljs-type">i</span></span> % <span class="hljs-type"><span class="hljs-type">list.length</span></span>] = item }</code> </pre><br><p>  Intentemos ejecutar la prueba de rendimiento nuevamente.  En mi computadora, la prueba se complet칩 en ~ 1.5 segundos.  M치s del doble de aumento debido al simple cambio de tama침o.  Para entender por qu칠 sucede esto, debemos entender lo siguiente, debajo del cap칩, la computadora funciona con n칰meros con base 2. Es importante saber si obtenemos el resto de la divisi칩n (% de operaci칩n).  Tal c치lculo es mucho m치s simple si el n칰mero es m칰ltiplo de 2 (2 ^ n) b 16384 es 2 ^ 14. De hecho, la computadora mira el n칰mero en forma binaria y simplemente toma los 칰ltimos n bits. </p><br><p>  Por ejemplo: 쯤u칠 suceder치 cuando se realice dicha operaci칩n 353 500% 16 384?  353 500 en representaci칩n binaria se ver치 como 1010110010011011100. Desde 16384 == 2 ^ 14 - necesitamos tomar los 칰ltimos 14 bits - 10101 (10010011011100) o 9 346. </p><br><p>  Podemos usar este conocimiento en relaci칩n con otro agujero de gusano.  Para una computadora, es muy simple y r치pido tomar los 칰ltimos n bits.  De hecho, solo es necesario producir binario y (operaci칩n &amp;) con el n칰mero (2 ^ n) - 1 </p><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>(<span class="hljs-number"><span class="hljs-number">16384</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    &amp;( )  %    2 ^ n list[i &amp; (list.length - 1)] = i }</span></span></code> </pre> <br><p>  Al ejecutar la prueba de rendimiento nuevamente en mi computadora, veremos que el tiempo de ejecuci칩n disminuir치 a ~ 1s o habr치 un aumento de cuatro veces en el rendimiento en comparaci칩n con la primera ejecuci칩n.  Y todo esto debido a la comprensi칩n de c칩mo funciona la computadora. </p><br><p>  Los compiladores inteligentes o m치quinas virtuales pueden hacer este tipo de optimizaci칩n al convertir la operaci칩n de obtener el resto detr치s de escena en una operaci칩n bit a bit y viceversa.  De hecho, la 칰ltima VM V8 Javascript (no implementada en NodeJS) hace exactamente eso. </p><br><h2 id="chislovye-krotovye-nory">  Agujero de gusano num칠rico </h2><br><p>  Otro molehill 칰til es comprender c칩mo funciona la lectura y escritura de n칰meros.  Recuerdas c칩mo usamos computadoras de 32 bits y c칩mo obtuvimos 64 bits?  Y hasta 32 bits ten칤amos 16 bits.  쯈u칠 significa exactamente esto?  Por lo general, pensamos de esta manera: cu치nta RAM tenemos en la computadora.  2 ^ 32 = 4294967296 o 4 GB, lo que significa que solo podemos acceder a 4 GB de memoria en una computadora de 32 bits.  Cuando escribimos un programa JS, generalmente no necesitamos pensar en ello, porque generalmente no usamos tanta memoria. </p><br><p>  Sin embargo, es muy importante comprender la diferencia entre las computadoras de 32 bits y las de 64 bits.  Dado que los procesadores recibieron registros de 64 bits en computadoras de 64 bits, las operaciones se han vuelto 2 veces m치s r치pidas que en computadoras de 32 bits, donde solo ten칤a registros de 32 bits. </p><br><p>  쮺칩mo podemos usar la informaci칩n sobre este agujero de gusano? <br>  Escribamos un programa simple que copie un Uint8Array a otro.  Si no est치 familiarizado con Unit8Arrays, son muy similares a los Buffers en NodeJS, o simplemente "limpian" la memoria. </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input, output)</span></span></span></span> { //    <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length &lt;= <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.length <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length; i++) { //   <span class="hljs-number"><span class="hljs-number">8</span></span>-  (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>[i] = <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>[i] } }</code> </pre> <br><p>  Nuevamente, midamos la velocidad ejecutando una prueba de rendimiento. </p><br><pre> <code class="hljs pgsql">//    <span class="hljs-number"><span class="hljs-number">1</span></span>MB Uint8Arrays     const input = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Uint8Array(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) const output = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Uint8Array(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) console.time() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1e4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output) } console.timeEnd()</code> </pre><br><p>  En mi computadora, el programa se complet칩 en ~ 7.5 segundos.  쮺칩mo podemos usar un agujero de gusano para acelerar?  Usando Uint8Array solo copiamos 8 bits a la vez, pero al tener una computadora de 64 bits podemos copiar 64 bits de informaci칩n al mismo tiempo.  Podemos hacer esto en JavaScript convirtiendo nuestro Uint8Array en un Float64Array antes de copiar, lo que no nos costar치 nada. </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input, output)</span></span></span></span> { //    <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length &lt;= <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.length //       <span class="hljs-number"><span class="hljs-number">64</span></span>-  //        , //      <span class="hljs-number"><span class="hljs-number">64</span></span>-  //  BigInts   JavaScript,    BigInt64Array. const input64 = new Float64Array(<span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.buffer, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.byteOffset, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length / <span class="hljs-number"><span class="hljs-number">8</span></span>) const output64 = new Float64Array(<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.buffer, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.byteOffset, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.length / <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; input64.length; i++) { //   <span class="hljs-number"><span class="hljs-number">64</span></span>-  output64[i] = input64[i] } }</code> </pre><br><p>  Al ejecutar nuevamente las pruebas de rendimiento, obtenemos un tiempo de ejecuci칩n de 1 segundo, lo que da un aumento de 8 veces en la velocidad. </p><br><p>  Para copiar, una soluci칩n aceptable ser칤a usar el m칠todo array.set (otherArray) para Uint8Array, que nos da copia en c칩digo nativo, que es mucho m치s r치pido que cualquier otro agujero de gusano.  Como referencia, esto dar치 un resultado de ~ 0.2 segundos de ejecuci칩n en nuestra prueba en mi computadora, que es 5 veces m치s r치pido que la soluci칩n anterior. </p><br><h2 id="galaktika-javascript-polna-krotovyh-nor">  Una galaxia de JavaScript est치 llena de agujeros de gusano </h2><br><p>  Usar los agujeros de gusano anteriores te ayudar치 a hacer toneladas de algoritmos del mundo real mucho m치s r치pido.  Hay muchos m치s de esos agujeros de gusano.  Mi favorito es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Math.clz32</a> , un m칠todo que devuelve el n칰mero de cero bits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">iniciales</a> en una representaci칩n binaria de 32 bits de un n칰mero.  Podemos usar este m칠todo para muchos algoritmos interesantes.  Lo us칠 para acelerar la implementaci칩n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">campos</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bits</a> 4 veces, lo que condujo a una disminuci칩n del consumo de memoria en 4 veces y me permiti칩 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ordenar los n칰meros</a> en algunas situaciones mucho m치s r치pido. </p><br><p>  Comprender los principios b치sicos de la computadora le permite escribir los programas m치s r치pidos que necesitamos.  Este conocimiento es importante incluso cuando escribe en un lenguaje de alto nivel como JavaScript. </p><br><p>  <strong>PD:</strong> </p><br><p>  Un agradecimiento especial por la ayuda en traducir y actualizar la traducci칩n a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Olga Pereverzeva</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428201/">https://habr.com/ru/post/es428201/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428187/index.html">C칩mo escribir una extensi칩n para GNOME Shell: modo No molestar</a></li>
<li><a href="../es428189/index.html">쯈ui칠n es un palad칤n?</a></li>
<li><a href="../es428191/index.html">쯈u칠 debemos organizar para un hackathon o c칩mo realizamos un hackathon interno?</a></li>
<li><a href="../es428193/index.html">Sobre ir de gira</a></li>
<li><a href="../es428197/index.html">Finanzas personales efectivas. Nivel 1</a></li>
<li><a href="../es428203/index.html">Observamos los gr치ficos: estimaciones y pron칩sticos para el mercado de computaci칩n en la nube, datos en 2018</a></li>
<li><a href="../es428205/index.html">Lifehacks NaviHaka</a></li>
<li><a href="../es428209/index.html">Libro de cocina del desarrollador: recetas de dise침o impulsado por dominio (Parte 2, estructura e interacci칩n)</a></li>
<li><a href="../es428211/index.html">El libro "Arquitectura evolutiva. Apoyo al cambio continuo "</a></li>
<li><a href="../es428213/index.html">C칩mo interpretar predicciones de modelos en SHAP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>