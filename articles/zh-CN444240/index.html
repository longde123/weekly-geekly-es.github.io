<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏾 👋🏻 👨🏽‍🤝‍👨🏼 Spring Data JPA：带文件 🚸 👨‍👩‍👦‍👦 🤚🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="问候，这是有关Spring Data JPA的第二篇文章。 第一部分完全专注于水下耙，以及经验丰富的耙的技巧。 在这一部分中，我们将讨论如何根据您的需求优化框架。 此处描述的所有示例均可用。 
 计数 


 让我们从一个简单而同时又常见的任务开始：加载实体时，有必要有选择地下载其“女儿”。 考虑一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spring Data JPA：带文件</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444240/"><p>问候，这是有关Spring Data JPA的第二篇文章。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a>完全专注于水下耙，以及经验丰富的耙的技巧。 在这一部分中，我们将讨论如何根据您的需求优化框架。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>描述的所有示例均可用。 </p><a name="habracut"></a><br><h4 id="grafy"> 计数 </h4><br><p> 让我们从一个简单而同时又常见的任务开始：加载实体时，有必要有选择地下载其“女儿”。 考虑一个简单的例子： </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"parent_id"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span>(fetch = FetchType.LAZY, cascade = CascadeType.ALL) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Parent parent; } <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; }</code> </pre> <br><p> 在我们的示例中，子实体是懒惰的：我们不想在接收<code>Child</code>时加载不必要的数据（并在SQL查询中联接另一个表）。 但是在某些情况下，在我们的应用程序中我们肯定知道我们将同时需要孩子和他的父母。 如果您让实体懒惰，我们将收到2个单独的请求。 如果您通过删除<code>FetchType.LAZY</code>应用快速加载，则两个实体将始终在第一个请求时加载（我们不希望这样做）。 </p><br><p>  JPQL提供了一个很好的解决方案-这是<code>fetch</code>关键字： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c join fetch c.parent where c.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-function">Child </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByIdFetchParent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>; }</code> </pre> <br><p> 该请求简单明了，但有缺点： </p><br><ul><li>  <code>JpaRepository::findById</code>添加显式加载，我们实际上复制了<code>JpaRepository::findById</code>的逻辑 </li><li> 在应用程序启动时<code>@Query</code>检查使用<code>@Query</code>描述的每个查询，这需要解析查询，检查参数等。（请参阅<a href="">org.springframework.data.jpa.repository.query.SimpleJpaQuery :: validateQuery</a> ）。 所有这些都是需要时间和记忆的工作。 </li><li> 在具有数十个存储库和交织的实体（有时有十二个“女儿”）的大型项目中使用这种方法将导致组合爆炸。 </li></ul><br><p> 关键在于我们的援助： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraphs</span></span>(value = { <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraph</span></span>( name = Child.PARENT, attributeNodes = <span class="hljs-meta"><span class="hljs-meta">@NamedAttributeNode</span></span>(<span class="hljs-string"><span class="hljs-string">"parent"</span></span>) ) }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String PARENT = <span class="hljs-string"><span class="hljs-string">"Child[parent]"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"parent_id"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span>(fetch = FetchType.LAZY, cascade = CascadeType.ALL) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Parent parent; }</code> </pre> <br><p> 该图本身很容易描述；使用时会遇到困难。  Spring Data JPA在其页面上建议这样做（适用于我们的案例）： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupInfo</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@EntityGraph</span></span>(value = Child.PARENT) <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c where c.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-function">Child </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByIdFetchParent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>; }</code> </pre> <br><p> 在这里，我们看到了所有相同的问题（除了书面请求变得更加简单）。 您可以在微调的帮助下一口气结束它们。 创建您自己的接口，我们将使用它来构建存储库，而不是使用盒装的<code>JpaRepository</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NoRepositoryBean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id, String graphName)</span></span></span></span>; }</code> </pre> <br><p> 现在执行： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJpaRepositoryImpl</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleJpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> JpaEntityInformation&lt;T, ?&gt; entityInfo; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> EntityManager entityManager; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseJpaRepositoryImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JpaEntityInformation&lt;T, ?&gt; ei, EntityManager em)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(ei, em); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entityInfo = ei; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entityManager = em; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id, String graphName)</span></span></span><span class="hljs-function"> </span></span>{ Assert.notNull(id, <span class="hljs-string"><span class="hljs-string">"The given id must not be null!"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  EntityGraph&lt;?&gt; graph = entityManager.getEntityGraph(graphName); Map&lt;String, Object&gt; hints = singletonMap(QueryHints.HINT_LOADGRAPH, graph); return entityManager.find(getDomainClass(), id, hints); }</span></span></code> </pre> <br><p> 现在，Spring不得不使用<code>BaseJpaRepositoryImpl</code>作为应用程序所有存储库的基础： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@EnableJpaRepositories</span></span>(repositoryBaseClass = BaseJpaRepositoryImpl.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppConfig</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p> 现在，从<code>BaseJpaRepository</code>继承的所有存储库中都可以使用我们的方法。 </p><br><p> 这种方法有一个缺点，那就是可以放一个非常肥的猪。 </p><br><div class="spoiler">  <b class="spoiler_title">试着为自己思考</b> <div class="spoiler_text"><p> 问题在于，Hibernate（至少在编写本文时）与图的名称和图本身不匹配。 因此，当我们执行类似的操作时，可能会出现运行时错误 </p><br><pre> <code class="java hljs">Optional&lt;MyEntity&gt; entity = repository.findById(id, NON_EXISTING_GRAPH);</code> </pre> </div></div><br><p> 您可以使用测试来检查解决方案的运行状况： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Sql</span></span>(<span class="hljs-string"><span class="hljs-string">"/ChildRepositoryGraphTest.sql"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryGraphTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestBase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Long childId = <span class="hljs-number"><span class="hljs-number">1L</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGraph_expectFieldInitialized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Child child1 = childRepository.findOne(childId, Child.PARENT); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> initialized = Hibernate.isInitialized(child1.getParent()); assertTrue(initialized); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGraph_expectFieldNotInitialized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Child child1 = childRepository .findById(childId) .orElseThrow(NullPointerException::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> initialized = Hibernate.isInitialized(child1.getParent()); assertFalse(initialized); } }</code> </pre> <br><h4 id="kogda-derevya-byli-bolshimi"> 树木大的时候 </h4><br><p> 而且我们很小，没有经验，我们经常不得不看下面的代码： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;DailyRecord&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findBetweenDates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date from, Date to)</span></span></span><span class="hljs-function"> </span></span>{ StringBuilder query = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"from Record "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { query.append(<span class="hljs-string"><span class="hljs-string">" where date &gt;="</span></span>).append(format(from)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (to != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { query.append(<span class="hljs-string"><span class="hljs-string">" where date &lt;= "</span></span> + format(to) + <span class="hljs-string"><span class="hljs-string">" "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { query.append(<span class="hljs-string"><span class="hljs-string">" and date &lt;= "</span></span> + format(to) + <span class="hljs-string"><span class="hljs-string">" "</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.createQuery(query.toString(), DailyRecord.class).getResultList(); }</code> </pre> <br><p> 此代码逐段收集请求。 这种方法的缺点很明显： </p><br><ul><li> 与你的手有很大关系 </li><li> 有手工工作的地方-有错误 </li><li> 不突出显示语法（运行时会弹出打字错误） </li><li> 扩展和维护代码非常困难 </li></ul><br><p> 不久之后，出现了Criteria API，这使我们可以将上面的代码压缩一点： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;DailyRecord&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findBetweenDates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date from, Date to)</span></span></span><span class="hljs-function"> </span></span>{ Criteria criteria = em .unwrap(Session.class) .createCriteria(DailyRecord.class); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { criteria.add(Expression.ge(<span class="hljs-string"><span class="hljs-string">"date"</span></span>, from)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (to != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { criteria.add(Expression.le(<span class="hljs-string"><span class="hljs-string">"date"</span></span>, to)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> criteria.list(); }</code> </pre> <br><p> 使用条件有几个优点： </p><br><ul><li> 使用元模型代替“日期”等“有线”值的能力 </li><li> 构造请求时出现的一些错误是编译错误，即在编写时已经检测到它们 </li><li> 与愚蠢的粘贴字符串相比，该代码更短，更易于理解 </li></ul><br><p> 也有缺点： </p><br><ul><li> 代码很复杂，足以理解 </li><li> 要学习如何编写此类查询，您需要付出很多努力（我记得我第一次不得不在此类查询中进行纠错时遇到的最大痛苦，有时包括100-150行，带有分支等） </li><li> 复杂的查询相当麻烦（距离限制不超过50行） </li></ul><br><p> 我想轻松愉快地开发它，所以我不喜欢这两种方法。 </p><br><p> 让我们转到我们已经检查过的实体： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"parent_id"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span>(fetch = FetchType.LAZY, cascade = CascadeType.ALL) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Parent parent; <span class="hljs-comment"><span class="hljs-comment">//... @OneToMany(mappedBy = "owner", cascade = CascadeType.ALL) @LazyCollection(value = LazyCollectionOption.EXTRA) private List&lt;Toy&gt; toys = new ArrayList&lt;&gt;(); }</span></span></code> </pre> <br><p> 我希望能够以不同的模式（及其组合）加载实体： </p><br><ul><li> 加载（或不加载）父级 </li><li> 加载（或不加载）玩具 </li><li> 按年龄分类儿童 </li></ul><br><p> 如果您直接解决此问题，即通过编写许多与所选加载模式相对应的查询，那么很快就会导致组合爆炸： </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c join fetch c.parent order by c.age"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithParentOrderByAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c join fetch c.toys order by c.age"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithToysOrderByAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c join fetch c.parent join fetch c.toys"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithParentAndToys</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//...</span></span></code> </pre> <br><p> 有一个简单而优雅的方法可以解决此问题：SQL / HQL和模板引擎的组合。 我的项目中使用了“ Freemarker”，尽管可以使用其他解决方案（“ Timlif”，“ Mustash”等）。 </p><br><p> 让我们开始创建。 首先，我们需要在一个接收扩展名<code>*.hql.ftl</code>或<code>*.sql.ftl</code> （如果使用“纯” SQL）的文件中描述查询： </p><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#* @vtlvariable name="fetchParent" type="java.lang.Boolean" *# #* @vtlvariable name="fetchToys" type="java.lang.Boolean" *# #* @vtlvariable name="orderByAge" type="java.lang.Boolean" *# select child from Child child #if($fetchParent) left join fetch child.parent #end #if($fetchToys) left join fetch child.toys #end #if($orderByAge) order by child.age #end</span></span></code> </pre> <br><p> 现在您需要一个处理程序： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateParser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Configuration configuration; <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String templateName, Map&lt;String, Object&gt; params)</span></span></span></span>{ Template template = configuration.getTemplate(templateName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FreeMarkerTemplateUtils.processTemplateIntoString(template, params); } }</code> </pre> <br><p> 没什么复杂的。 进入存储库。 显然，继承<code>JpaRepository</code>的接口不适合我们。 而是利用这个机会来创建自己的存储库： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fetchParent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fetchToys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span></span>; } <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseDao</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TemplateParser templateParser; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fetchParent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fetchToys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; params = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); params.put(<span class="hljs-string"><span class="hljs-string">"fetchParent"</span></span>, fetchParent); params.put(<span class="hljs-string"><span class="hljs-string">"fetchToys"</span></span>, fetchToys); params.put(<span class="hljs-string"><span class="hljs-string">"orderByAge"</span></span>, orderByAge); String query = templateParser.prepareQuery(BASE_CHILD_TEMPLATE.name, params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.createQuery(query, Child.class).getResultList(); } <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RepositoryTemplates { BASE_CHILD_TEMPLATE(<span class="hljs-string"><span class="hljs-string">"BaseChildTemplate.hql.ftl"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; } }</code> </pre> <br><p> 为了使<code>findUsingTemplate</code>方法可从<code>ChildRepository</code>访问<code>ChildRepository</code>您需要执行以下操作： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">与名称相关的重要功能</b> <div class="spoiler_text"><p>  Spring将仅使用正确的名称将我们的类和接口绑定在一起： </p><br><ul><li> 子存储库 </li><li>  ChildRepository <strong>自定义</strong> </li><li>  ChildRepository <strong>Impl</strong> </li></ul><br><p> 请记住这一点，因为如果名称中有错误，将引发难以理解的异常，无法从中理解错误原因。 </p></div></div><br><p> 现在，使用这种方法可以解决更复杂的问题。 假设我们需要根据用户选择的特征进行选择。 换句话说，如果用户未指定日期“从”和“到”，那么将没有时间过滤。 如果仅指定日期“ from”或仅日期“ to”，则过滤将是单向的。 如果同时指定了两个日期，则只有指定日期之间的记录才属于选择范围： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequestDto</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LocalDate from; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LocalDate to; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasDateFrom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> from != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasDateTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> to != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChildRequest request)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; params = singletonMap(<span class="hljs-string"><span class="hljs-string">"request"</span></span>, request); String query = templateParser.prepareQuery(TEMPLATE.name, params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.createQuery(query, Child.class).getResultList(); }</code> </pre> <br><p> 现在是模板： </p><br><pre> <code class="sql hljs">&lt;<span class="hljs-comment"><span class="hljs-comment">#-- @ftlvariable name="request" type="...RequestDto" --&gt; select child from Child child &lt;#if request.hasDateFrom() &amp;&amp; request.hasDateTo()&gt; where child.birthDate &gt;= :dateFrom and child.birthDate &lt;= :dateTo &lt;#elseif request.hasDateFrom()&gt; where child.birthDate &gt;= :dateFrom &lt;#elseif request.hasDateTo()&gt; where child.birthDate &lt;= :dateTo &lt;/#if&gt;</span></span></code> </pre> <br><h4 id="orakl-i-nvl">  Oracle和NVL </h4><br><p> 考虑本质： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DailyRecord</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String currency; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"record_rate"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigDecimal rate; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"fixed_rate"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigDecimal fxRate; <span class="hljs-meta"><span class="hljs-meta">@Setter</span></span>(value = AccessLevel.PRIVATE) <span class="hljs-meta"><span class="hljs-meta">@Formula</span></span>(<span class="hljs-string"><span class="hljs-string">"select avg(r.record_rate) from daily_record r where r.currency = currency"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigDecimal avgRate; }</code> </pre> <br><p> 该实体用于查询（DBMS，我们记得有Oracle）： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select nvl(record.fxRate, record.avgRate) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from DailyRecord record "</span></span> + <span class="hljs-string"><span class="hljs-string">"where record.currency = :currency"</span></span>) <span class="hljs-function"><span class="hljs-function">BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findRateByCurrency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"currency"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String currency)</span></span>;</code> </pre> <br><p> 这是一个有效的请求。 但是它有一个小问题，SQL专家可能会指出。 事实是Oracle中的<code>nvl</code>并不懒惰。 换句话说，当我们调用<code>findRateByCurrency</code>方法时， <code>findRateByCurrency</code>日志将<code>findRateByCurrency</code> </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> nvl( dr.fixed_rate, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(r.record_rate) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record r <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r.currency = dr.currency ) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record dr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dr.currency = ?</code> </pre> <br><p> 即使存在<code>dr.fixed_rate</code>值，DBMS仍会计算<code>nvl</code>第二个表达式返回的值。 </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(r.record_rate) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record r <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r.currency = dr.currency)</code> </pre> <br><p> 读者可能已经知道如何避免不必要的请求权重：当然，这是关键字<code>coalesce</code> ，它与<code>nvl</code>懒惰性，并且可以接受两个以上的表达式，因此具有优势。 让我们更正我们的请求： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select coalesce(record.fxRate, record.avgRate) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from DailyRecord record "</span></span> + <span class="hljs-string"><span class="hljs-string">"where record.currency = :currency"</span></span>) <span class="hljs-function"><span class="hljs-function">BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findRateByCurrency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"currency"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String currency)</span></span>;</code> </pre> <br><p> 然后，正如他们所说，突然之间： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> nvl(dr.fixed_rate, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(r.record_rate) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record r <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r.currency = dr.currency) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record dr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dr.currency = ?</code> </pre> <br><p> 要求保持不变。 那是因为盒子里的甲骨文方言变成了<code>nvl</code>链。 </p><br><div class="spoiler">  <b class="spoiler_title">备注</b> <div class="spoiler_text"><p> 如果要重现此行为，请删除<a href="">CustomOracleDialect</a>类的构造函数中的第二行，然后运行<code>DailyRecordRepositoryTest::findRateByCurrency</code> </p></div></div><br><p> 要避免这种情况，您需要创建自己的方言并在应用程序中使用它： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomOracleDialect</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Oracle12cDialect</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomOracleDialect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); registerFunction(<span class="hljs-string"><span class="hljs-string">"coalesce"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardSQLFunction(<span class="hljs-string"><span class="hljs-string">"coalesce"</span></span>)); } }</code> </pre> <br><p> 是的，就是这么简单。 现在，将创建的方言绑定到应用程序： </p><br><pre> <code class="plaintext hljs">spring: jpa: database-platform: com.luxoft.logeek.config.CustomOracleDialect</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">另一种（不建议使用的）方式：</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">spring: jpa: properties: hibernate.dialect: com.luxoft.logeek.config.CustomOracleDialect</code> </pre> </div></div><br><p> 重复执行该请求将使梦ko以求的koalesk： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(dr.fixed_rate, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(r.record_rate) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record r <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r.currency = dr.currency) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record dr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dr.currency = ?</code> </pre> <br><h4 id="orakl-i-postranichnye-zaprosy">  Oracle和页面请求 </h4><br><p> 通常，方言的完成为查询操作提供了丰富的机会。 通常，在开发应用程序和网络界面时，会遇到分页上传数据的任务。 换句话说，我们在数据库中有数十万条记录，但是它们以每页10/50/100条记录的包的形式显示。 开箱即用的Spring Date为开发人员提供了类似的功能： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select new com.luxoft.logeek.data.BriefChildData("</span></span> + <span class="hljs-string"><span class="hljs-string">"c.id, "</span></span> + <span class="hljs-string"><span class="hljs-string">"c.age "</span></span> + <span class="hljs-string"><span class="hljs-string">") from Child c "</span></span> + <span class="hljs-string"><span class="hljs-string">" join c.parent p "</span></span> + <span class="hljs-string"><span class="hljs-string">"where p.name = ''"</span></span>) <span class="hljs-function"><span class="hljs-function">Page&lt;BriefChildData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">browse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pageable pageable)</span></span></span></span>;</code> </pre> <br><p> 这种方法有一个很大的缺点，即执行两个查询，第一个查询获取数据，第二个查询确定数据库中它们的总数（这对于显示<code>Page</code>对象中的数据总量是必需的）。 在我们的例子中，对此方法的调用给出了以下请求（使用p6spy进行记录）： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c.id, c.age <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">child</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.parent_id = p.id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.name = <span class="hljs-string"><span class="hljs-string">''</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(c.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">child</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.parent_id = p.id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.name = <span class="hljs-string"><span class="hljs-string">''</span></span></code> </pre> <br><p> 如果查询很繁琐（许多表由不可索引的列连接，只有很多连接，困难的选择条件等），那么这可能会成为问题。 但是由于我们拥有Oracle，因此使用rownum伪列可以通过一个请求获得请求。 </p><br><p> 为此，我们需要完成方言，并描述用于计数所有记录的函数： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomOracleDialect</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Oracle12cDialect</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomOracleDialect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); registerFunction(<span class="hljs-string"><span class="hljs-string">"coalesce"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardSQLFunction(<span class="hljs-string"><span class="hljs-string">"coalesce"</span></span>)); registerFunction(<span class="hljs-string"><span class="hljs-string">"total_count"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TotalCountFunc()); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TotalCountFunc</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SQLFunction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasArguments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasParenthesesIfNoArguments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReturnType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type type, Mapping mapping)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StandardBasicTypes.LONG; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type type, List arguments, SessionFactoryImplementor factory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arguments.size() != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Only 1 argument acceptable"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">" count("</span></span> + arguments.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) + <span class="hljs-string"><span class="hljs-string">") over () "</span></span>; } }</code> </pre> <br><p> 现在编写一个新查询（在<code>ChildRepositoryImpl</code>类中）： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Page&lt;BriefChildData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">browseWithTotalCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pageable pageable)</span></span></span><span class="hljs-function"> </span></span>{ String query = <span class="hljs-string"><span class="hljs-string">"select "</span></span> + <span class="hljs-string"><span class="hljs-string">" c.id as id,"</span></span> + <span class="hljs-string"><span class="hljs-string">" c.age as age, "</span></span> + <span class="hljs-string"><span class="hljs-string">" total_count(c.id) as totalCount"</span></span> + <span class="hljs-string"><span class="hljs-string">" from Child c "</span></span> + <span class="hljs-string"><span class="hljs-string">"join c.parent p "</span></span> + <span class="hljs-string"><span class="hljs-string">"where p.name = ''"</span></span>; List&lt;BriefChildData&gt; list = em.unwrap(Session.class) .createQuery(query) .setFirstResult((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) pageable.getOffset()) .setMaxResults(pageable.getPageSize()) .setResultTransformer(Transformers.aliasToBean(BriefChildData.class)) .getResultList(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PageImpl(Collections.emptyList()); } <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> totalCount = list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).getTotalCount(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PageImpl&lt;&gt;(list, pageable, totalCount); }</code> </pre> <br><p> 调用此代码时，将执行一个请求 </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c.id, c.age, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(c.id) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> () <span class="hljs-comment"><span class="hljs-comment">-- &lt;----- from child c inner join parent p on c.parent_id = p.id where p.name = '') where rownum &lt;= 3</span></span></code> </pre> <br><p> 在<code>count(c.id) over ()</code>使用表达式<code>count(c.id) over ()</code>您可以获取数据总量，并从数据类中获取数据，以传递给<code>PageImpl</code>构造函数。 有一种方法可以更优雅地完成它，而无需在数据类中添加另一个字段，而要考虑它是一项功课：)您可以使用<a href="">ProjectionVsDataTest</a>测试来测试解决方案。 </p><br><h4 id="podvodnye-kamni-kastomizacii"> 定制的陷阱 </h4><br><p> 我们在Oracle和Spring Date上有一个很棒的项目。 我们的任务是提高此类代码的性能： </p><br><pre> <code class="java hljs">List&lt;Long&gt; ids = getIds(); ids.stream() .map(repository::findById) .filter(Optional::isPresent) .map(Optional::get) .forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::sendToSchool);</code> </pre> <br><p> 缺点在于表面上：数据库查询的数量等于唯一键的数量。 有一种克服此困难的已知方法： </p><br><pre> <code class="java hljs">List&lt;Long&gt; ids = getIds(); repository .findAllById(ids) .forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::sendToSchool);</code> </pre> <br><p> 多次采样的优势是显而易见的：如果早些时候，我们有许多类似形式的查询 </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p> 那么现在他们已经崩溃了 </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, ... )</code> </pre> <br><p> 它似乎更容易变得更好。 该项目不断发展，发展，数据成倍增长，一旦不可避免，该项目就将出现： </p><br><div class="spoiler">  <b class="spoiler_title">晴间的Aki雷声</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">ERROR - ORA-01795: maximum number of expressions in a list is 1000</code> </pre> </div></div><br><p> 我们需要再次寻找出路（不要返回到旧版本）。 由于Oracle不允许他提供超过1000个键，因此您可以将整个数据集划分为不超过1000个相等的份额，并执行多个查询： </p><br><pre> <code class="java hljs">List&lt;List&lt;Long&gt;&gt; idChunks = cgccLists.partition(ids, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//* idChunks.forEach(idChunk -&gt; repository.findAllById(idChunk).forEach(this::sendToSchool) ); //* cgccLists = com.google.common.collect.Lists</span></span></code> </pre> <br><p> 此方法有效，但闻起来有点（是吗？）：如果您在其他地方遇到此类困难，则必须围护同一花园。 让我们尝试更优雅地解决问题，即<code>BaseJpaRepositoryImpl</code> 。 最简单的方法是将上述逻辑向内传递，对用户隐藏： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ Assert.notNull(ids, <span class="hljs-string"><span class="hljs-string">"The given Iterable of Id's must not be null!"</span></span>); Set&lt;ID&gt; idsCopy = Sets.newHashSet(ids); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idsCopy.size() &lt;= OracleConstants.MAX_IN_COUNT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.findAllById(ids); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findAll(idsCopy); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;ID&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;List&lt;ID&gt;&gt; idChunks = Lists.partition(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(ids), <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> idChunks .stream() .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::findAllById) .flatMap(List::stream) .collect(Collectors.toList()); }</code> </pre> <br><p> 情况变得越来越好：首先，我们从基础结构层清除了工作代码，其次，我们将解决方案的范围扩展到了所有扩展<code>BaseJpaRepository</code>项目存储库。 也有缺点。 主要的是几个请求而不是一个请求，还有（来自主要请求的词干）-需要过滤键，因为如果不这样做，那么相同的键可能会出现在不同的<code>idChunks</code> 。 反过来，这意味着同一实体将被两次包含在列表中，因此将被处理两次。 我们不需要这个，因此这是另一个更复杂的解决方案： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ Assert.notNull(ids, <span class="hljs-string"><span class="hljs-string">"The given Iterable of Id's must not be null!"</span></span>); ArrayList&lt;ID&gt; idsCopy = Lists.newArrayList(ids); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idsCopy.size() &lt;= OracleConstants.MAX_IN_COUNT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.findAllById(ids); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findAll(idsCopy); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArrayList&lt;ID&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ CriteriaBuilder cb = entityManager.getCriteriaBuilder(); CriteriaQuery&lt;T&gt; query = cb.createQuery(getDomainClass()); Root&lt;T&gt; from = query.from(getDomainClass()); Predicate predicate = toPredicate(cb, ids, from); query = query.select(from).where(predicate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entityManager.createQuery(query).getResultList(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Predicate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toPredicate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CriteriaBuilder cb, ArrayList&lt;ID&gt; ids, Root&lt;T&gt; root)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;List&lt;ID&gt;&gt; chunks = Lists.partition(ids, OracleConstants.MAX_IN_COUNT); SingularAttribute&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T, ?&gt; id = entityInfo.getIdAttribute(); Predicate[] predicates = chunks.stream() .map(chunk -&gt; root.get(id).in(chunk)) .toArray(Predicate[]::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb.or(predicates); }</code> </pre> <br><p> 它使用Criteria API，这使得构建一个最终查询形式成为可能。 </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ... , <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> p.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1001</span></span>, ... , <span class="hljs-number"><span class="hljs-number">2000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> p.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">2001</span></span>, ... , <span class="hljs-number"><span class="hljs-number">3000</span></span>)</code> </pre> <br><p> 有一个微妙之处：由于条件繁琐，类似的请求可以比平常执行更长的时间，因此第一种方法可能（有时）是更可取的。 </p><br><p> 就这样，我希望这些示例对您有用，并且对日常开发有用。 欢迎评论和添加。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444240/">https://habr.com/ru/post/zh-CN444240/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444226/index.html">@Pythonetc编译2019年2月</a></li>
<li><a href="../zh-CN444228/index.html">我的电报频道@pythonetc的提示和技巧，2019年2月</a></li>
<li><a href="../zh-CN444230/index.html">国家互联网：中国远程VPN的故事</a></li>
<li><a href="../zh-CN444234/index.html">DeepMind和Google：控制强大AI的战斗</a></li>
<li><a href="../zh-CN444238/index.html">一键拒绝，或者设计师如何获得理想的工作</a></li>
<li><a href="../zh-CN444242/index.html">使用PVS-Studio分析仪检查FreeRDP</a></li>
<li><a href="../zh-CN444244/index.html">穿越时空</a></li>
<li><a href="../zh-CN444246/index.html">使用PVS-Studio检查FreeRDP</a></li>
<li><a href="../zh-CN444248/index.html">浏览器中的无头测试。 利弊</a></li>
<li><a href="../zh-CN444250/index.html">人们是否不准备接受比特币或大规模采用比特币？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>