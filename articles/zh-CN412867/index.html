<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏾 🤾🏾 📸 如何通过GCC编译器编译DOS COM文件 👨‍👨‍👦‍👦 🧙🏾 🤶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="文章于2014年12月9日发布 
 2018年更新：RenéRebe根据本文制作了一个有趣的视频 （ 第2部分 ） 

 上周末我参加了Ludum Dare＃31 。 但是甚至在会议宣布之前，由于我最近的爱好，我想在DOS下制作一款老式游戏。 目标平台是DOSBox。 尽管所有现代x86处理器都与旧...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何通过GCC编译器编译DOS COM文件</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412867/"> <font color="gray">文章于2014年12月9日发布</font> <br>  <i>2018年更新：RenéRebe根据本文制作了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有趣的视频</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分</a> ）</i> <br><br> 上周末我参加了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ludum Dare＃31</a> 。 但是甚至在会议宣布之前，由于我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最近的爱好，</a>我想在DOS下制作一款老式游戏。 目标平台是DOSBox。 尽管所有现代x86处理器都与旧的处理器（最多16位8086）完全向后兼容，但这是运行DOS应用程序的最实用方法。 <br><br> 我在会议上成功创建并展示了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DOS Defender</a>游戏。 该程序在32位80386的实模式下工作。所有资源都内置在可执行的COM文件中，没有任何外部依赖关系，因此整个游戏都打包为10 KB二进制文件。 <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/skeeto/dosdefender-ld31</a> </li><li>  <a href="">DOSDEF.COM</a> （10 KB，v1.1.0，在DOSBox中工作） </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ay/na/qs/aynaqsaenvt32x5oa8y7z4fmnfy.gif"></div><a name="habracut"></a><br> 您需要操纵杆或游戏板才能玩。 为了演示起见，我在Ludum Dare的发行版中包含了鼠标支持，但是由于效果不佳而将其删除。 <br><br> 技术上最有趣的部分是， <b><i>无需</i> DOS开发工具即可创建游戏</b> ！ 我只使用了常规的Linux C编译器（gcc）。 实际上，您甚至无法为DOS构建DOS Defender。 我仅将DOS视为嵌入式平台，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DOS至今仍然存在</a>的唯一形式。 与DOSBox和DOSEMU一起使用，这是一组相当方便的工具。 <br><br> 如果您只对开发的实际部分感兴趣，请转到“在GCC上作弊”部分，我们将在此使用GCC Linux编写DOS COM程序“ Hello，World”。 <br><br><h1> 寻找合适的工具 </h1><br> 当我开始这个项目时，我没有想到GCC。 实际上，当我发现Debian的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bcc</a>软件包（Bruce的C编译器）时，我就这样走了，该软件包收集了8086的16位二进制文​​件。该软件包用于编译x86引导加载程序和其他内容，但是bcc也可用于编译DOS COM文件。 它使我感兴趣。 <br><br> 供参考：1978年发布了Intel 8086 16位微处理器。 它没有现代处理器的怪异功能：没有内存保护，没有浮点指令以及只有1 MB的可寻址RAM。 四十年前，所有现代x86台式机和笔记本电脑仍可以假装为8086的16位处理器，但寻址方式和所有功能都相同。 这是一个相当向后的兼容性。 这种功能称为<i>实模式</i> 。 这是所有x86计算机引导的模式。 现代操作系统通过虚拟寻址和安全的多任务处理立即切换到<i>保护模式</i> 。  DOS没有这样做。 <br><br> 不幸的是，bcc不是ANSI C编译器，它支持K＆R C的子集以及内置的x86汇编代码。 与其他8086 C编译器不同，它没有“远”或“长”指针的概念，因此需要内置的汇编代码来访问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他内存段</a> （VGA，时钟等）。 注意：这些“长指针” 8086的剩余部分仍保留在Win32 API中： <code>LPSTR</code> ， <code>LPWORD</code> ， <code>LPDWORD</code>等。该内置汇编程序甚至与内置汇编程序GCC并没有紧密的比较。 在汇编器中，您需要从堆栈中手动加载变量，并且由于bcc支持两种不同的调用约定，因此代码中的变量应根据一种或另一种约定进行硬编码。 <br><br> 考虑到这些限制，我决定寻找替代方案。 <br><br><h1>  DJGPP </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DJGPP</a> -DOS下的GCC端口。 一个非常令人印象深刻的项目，可以在DOS下传输几乎整个POSIX。 在DJGPP上制作了许多DOS移植程序。 但是他只为保护模式创建32位程序。 如果在保护模式下，您需要使用硬件（例如VGA），则程序会向<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DOS保护模式接口</a> （DPMI）的服务发出请求。 如果我选择了DJGPP，则不可能将自己局限于单个独立的二进制文件，因为我必须拥有DPMI服务器。 对DPMI的要求也会降低性能。 <br><br> 至少可以说，很难获得DJGPP的必要工具。 幸运的是，我找到了一个有用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">build-djgpp</a>项目，该项目可以至少在Linux上运行所有内容。 <br><br> 要么是一个严重的错误，要么是官方DJGPP二进制文件<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">再次</a>被<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">病毒感染</a> ，但是当我在DOSBox中启动程序时，错误“ Not COFF：检查病毒”不断出现。 为了进一步验证病毒不在我自己的计算机上，我在Raspberry Pi上设置了DJGPP环境，该环境充当无尘室。 此基于ARM的设备不能感染x86病毒。 仍然出现相同的问题，并且机器之间的所有二进制哈希都是相同的，所以这不是我的错。 <br><br> 因此，鉴于此和DPMI问题，我开始进一步寻找。 <br><br><h1> 愚弄gcc </h1><br> 我最终决定解决的问题是“欺骗” GCC以实模式构建DOS COM文件的棘手技巧。 这个技巧最多可以达到80386（通常是您所需要的）。  80386处理器于1985年推出，成为第一个32位x86微处理器。 即使在x86-64环境下，GCC仍然遵守这套说明。 不幸的是，GCC无法以任何方式生成16位代码，因此我不得不放弃最初为8086制作游戏的目标。 但是，这并不重要，因为目标DOSBox平台本质上是80386仿真器。 <br><br> 从理论上讲，该技巧也应在MinGW编译器中起作用，但是存在一个长期存在的错误，导致其无法正常工作（“无法对非PE输出文件执行PE操作”）。 但是，可以绕过它，而我自己做的：您应该删除<code>OUTPUT_FORMAT</code>指令，并添加一个额外的<code>objcopy</code>步骤（ <code>objcopy -O binary</code> ）。 <br><br><h3> 在DOS上的Hello World </h3><br> 为了演示，我们将在Linux上使用GCC创建DOS COM程序“ Hello，World”。 <br><br> 这种方法有一个主要的重大障碍： <b>将没有标准库</b> 。 这就像从头开始编写操作系统，但DOS提供了一些服务。 那意味着没有<code>printf()</code>之类的东西。 相反，我们要求DOS将字符串打印到控制台。 创建DOS请求需要中断，这意味着内联汇编代码！ <br><br>  DOS有9个中断：0x20、0x21、0x22、0x23、0x24、0x25、0x26、0x27、0x2F。 让我们感兴趣的最重要的东西是0x21，函数0x09（打印一行）。 在DOS和BIOS之间， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有数千种以此模式命名的功能</a> 。 我将不尝试解释x86汇编程序，但简而言之，功能编号卡在了<code>ah</code>寄存器中-并触发了0x21中断。 函数0x09还带有一个参数-指向要打印的行的指针，该指针在<code>dx</code>和<code>ds</code>寄存器中传递。 <br><br> 这是GCC内联汇编程序的<code>print()</code>函数。 传递给此函数的行必须以$字符结尾。 怎么了 因为DOS。 <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mov $0x09, %%ah\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"int $0x21\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no output */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"d"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">) : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ah"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; }</code> </pre> <br> 该代码被声明为<code>volatile</code>因为它具有副作用（行打印）。 对于GCC，汇编器代码是不透明的，优化器依赖于输出/输入/缓冲限制（最后三行）。 对于此类DOS程序，任何内置的汇编程序都会有副作用。 这是因为编写它不是为了优化，而是为了访问硬件资源和DOS-简单C语言无法访问的东西。 <br><br> 您还必须注意调用语句，因为GCC不知道<code>string</code>指向的内存曾经被读取过。 支持该字符串的数组也可能必须声明为<code>volatile</code> 。 所有这些都预示着不可避免的事情：在这种环境中的任何动作都将与优化器进行无休止的斗争。 并非所有这些战斗都能获胜。 <br><br> 现在到主要功能。 它的名称原则上并不重要，但我避免将其命名为<code>main()</code> ，因为MinGW对于如何具体处理此类字符有一个有趣的想法，即使他们要求他不要。 <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dosmain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { print(<span class="hljs-string"><span class="hljs-string">"Hello, World!\n$"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  COM文件的大小限制为65279字节。 这是因为x86内存段为64 KB，而DOS只是将COM文件下载到0x0100段地址并执行。 没有标题，只有干净的二进制文件。 由于COM程序原则上不能有很大的大小，因此不应该出现实际的布局（独立式），因此整个程序被编译为单个翻译单元。 这将是一个带有一堆参数的GCC调用。 <br><br><h3> 编译器选项 </h3><br> 这是主要的编译器选项。 <br><br> <code>-std=gnu99 -Os -nostdlib -m32 -march=i386 -ffreestanding</code> <br> <br> 由于未使用标准库，因此gnu99和c99之间的唯一区别是禁用的trigraph（应如此），并且内置汇编程序可以<code>asm</code>代替<code>__asm__</code>编写。 这不是牛顿的垃圾箱。 该项目将与GCC紧密相关，以至于我仍然不关心GCC的扩展。 <br><br>  <code>-Os</code>选项尽可能减少编译结果。 因此，该程序将运行得更快。 注意DOSBox的重要性，因为默认仿真器像80年代的机器一样运行缓慢。 我想适应这个限制。 如果优化器引起问题，请临时<code>-O0</code>以确定您的错误或优化器在此处。 <br><br> 如您所见，优化器不了解该程序将在具有相应寻址限制的实模式下运行。  <b>它执行各种无效的优化，破坏您完全有效的程序。</b> 这不是GCC错误，因为我们自己在这里做疯狂的事情。 我不得不重做几次代码，以防止优化程序破坏程序。 例如，我们必须避免从函数返回复杂的结构，因为它们有时会充满垃圾。 真正的危险是，将来的GCC版本将变得更加智能，并且将破坏更多的代码。 这是你朋友<code>volatile</code> 。 <br><br> 下一个参数是<code>-nostdlib</code> ，因为我们将无法甚至静态地链接到任何有效的库。 <br><br> 参数<code>-m32-march=i386</code>编译器发出代码80386。如果我为现代计算机编写了引导加载程序，则80686的视线也将是正常的，但DOSBox为80386。 <br><br>  <code>-ffreestanding</code>变量要求GCC不要发布访问内置标准库的帮助程序功能的代码。 有时，它会生成用于调用内置函数的代码，而不是实际工作的代码，尤其是使用数学运算符时。 我遇到了密件抄送的主要问题之一，该行为无法禁用。 编写引导加载程序和OS内核时，最常使用此选项。 现在是dos dos .com文件。 <br><br><h3> 链接器选项 </h3><br>  <code>-Wl</code>用于将参数传递给链接器（ <code>ld</code> ）。 我们之所以需要这样做，是因为我们在一次致电GCC的过程中做了一切。 <br><br><pre> <code class="hljs powershell"><span class="hljs-literal"><span class="hljs-literal">-Wl</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-nmagic</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-script</span></span>=com.ld</code> </pre> <br>  <code>--nmagic</code>禁用节页面对齐。 首先，我们不需要它。 其次，它浪费了宝贵的空间。 在我的测试中，这似乎不是必需的措施，但以防万一，我保留了此选项。 <br><br>  <code>--script</code>参数指示我们要使用特殊的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接描述文件</a> 。 这使您可以准确地放置程序的各个部分（ <code>text</code> ， <code>data</code> ， <code>bss</code> ， <code>rodata</code> ）。 这是<code>com.ld</code>脚本。 <br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">OUTPUT_FORMAT</span></span>(binary) <span class="hljs-type"><span class="hljs-type">SECTIONS</span></span> { . = <span class="hljs-number"><span class="hljs-number">0x0100</span></span>; .text : { *(.text); } .<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> : { *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">); *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bss</span></span></span><span class="hljs-class">); *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rodata</span></span></span><span class="hljs-class">); } _heap = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ALIGN</span></span></span><span class="hljs-class">(4); }</span></span></code> </pre> <br>  <code>OUTPUT_FORMAT(binary)</code>告诉您不要将其放入ELF文件（或PE等）中。 链接器应只重置干净代码。  COM文件只是干净的代码，也就是说，我们将命令提供给链接器以创建一个COM文件！ <br><br> 我说过COM文件已上传到<code>0x0100</code> 。 第四行将二进制文件移到那里。  COM文件的第一个字节仍然是代码的第一个字节，但是将从该内存偏移量启动。 <br><br> 然后所有部分都将遵循： <code>text</code> （程序）， <code>data</code> （静态数据）， <code>bss</code> （初始化为零的数据）， <code>rodata</code> （字符串）。 最后，我用<code>_heap</code>符号标记二进制文件的<code>_heap</code> 。 当我们完成“ Hello，World”后，在编写<code>sbrk()</code>时，这<code>sbrk()</code>用场。 我指示将<code>_heap</code>与4个字节对齐。 <br><br> 快完成了 <br><br><h3> 程序启动 </h3><br> 链接程序通常知道我们的入口点（ <code>main</code> ）并为我们设置了入口点。 但是，由于我们要求“二进制”问题，因此我们必须自己弄清楚。 如果第一个运行<code>print()</code>函数，则程序将从其启动，这是错误的。 该程序需要一个小标题才能开始。 <br><br> 链接描述文件中有一个用于此类情况的<code>STARTUP</code>选项，但为简单起见，我们将在程序中直接实现它。 通常，将这些东西称为<code>crt0.o</code>或<code>Boot.o</code> ，以防您在某个地方<code>Boot.o</code>它们。 我们的代码<i>必须</i>从内置的汇编程序开始，然后再包含任何包含物等。  DOS将为我们完成大部分安装，我们只需要转到入口点即可。 <br><br><pre> <code class="hljs perl">asm (<span class="hljs-string"><span class="hljs-string">".code16gcc\n"</span></span> <span class="hljs-string"><span class="hljs-string">"call dosmain\n"</span></span> <span class="hljs-string"><span class="hljs-string">"mov $0x4C, %ah\n"</span></span> <span class="hljs-string"><span class="hljs-string">"int $0x21\n"</span></span>);</code> </pre> <br>  <code>.code16gcc</code>告诉汇编程序我们将在实模式下工作，这样它将进行正确的配置。 尽管有名称，但它<i>不会</i>产生16位代码！ 首先， <code>dosmain</code>我们先前编写的<code>dosmain</code>函数。 然后，他使用0x4C函数（“返回代码结尾”）告诉DOS，我们将退出代码传递给1字节的<code>al</code>寄存器（已由<code>dosmain</code>函数设置）来完成操作。 因为没有输入和输出，所以此内置汇编程序自动<code>volatile</code> 。 <br><br><h3> 一起 </h3><br> 这是C语言中的整个程序。 <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> (<span class="hljs-string"><span class="hljs-string">".code16gcc\n"</span></span> <span class="hljs-string"><span class="hljs-string">"call dosmain\n"</span></span> <span class="hljs-string"><span class="hljs-string">"mov $0x4C,%ah\n"</span></span> <span class="hljs-string"><span class="hljs-string">"int $0x21\n"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mov $0x09, %%ah\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"int $0x21\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no output */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"d"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">) : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ah"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dosmain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ print(<span class="hljs-string"><span class="hljs-string">"Hello, World!\n$"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br> 我不会重复<code>com.ld</code> 这是海湾合作委员会的挑战。 <br><br><pre> <code class="hljs powershell">gcc <span class="hljs-literal"><span class="hljs-literal">-std</span></span>=gnu99 <span class="hljs-literal"><span class="hljs-literal">-Os</span></span> <span class="hljs-literal"><span class="hljs-literal">-nostdlib</span></span> <span class="hljs-literal"><span class="hljs-literal">-m32</span></span> <span class="hljs-literal"><span class="hljs-literal">-march</span></span>=i386 <span class="hljs-literal"><span class="hljs-literal">-ffreestanding</span></span> \ <span class="hljs-literal"><span class="hljs-literal">-o</span></span> hello.com <span class="hljs-literal"><span class="hljs-literal">-Wl</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-nmagic</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-script</span></span>=com.ld hello.c</code> </pre> <br> 以及他在DOSBox中的测试： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c5/478/358/4c5478358be0cdd9cc05eafd66bd44d2.png"><br><br> 然后，如果您想要精美的图形，唯一的问题是调用中断并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">写入VGA内存</a> 。 如果要声音，请使用PC扬声器中断。 我还没有弄清楚如何调用Sound Blaster。 从那一刻起，DOS Defender就长大了。 <br><br><h1> 内存分配 </h1><br> 要涵盖另一个主题，请记住<code>_heap</code>吗？ 我们可以使用它来实现<code>sbrk()</code>并在程序的主要部分中动态分配内存。 这是一个实模式，没有虚拟内存，因此我们可以写入我们可以随时访问的任何内存。 有些区域是为设备保留的（例如，较低和较高的内存）。 因此，没有<i>真正</i>需要使用sbrk（），但是尝试很有趣。 <br><br> 像在x86上一样，程序和分区位于较低的内存（在这种情况下为0x0100），而堆栈在较高的内存（在我们的情况下为0xffff区域）中。 在类Unix系统上， <code>malloc()</code>返回的<code>malloc()</code>来自两个地方： <code>sbrk()</code>和<code>mmap()</code> 。  <code>sbrk()</code>作用是在程序/数据段的上方分配内存，将其“向上”递增到堆栈。 每次对<code>sbrk()</code>调用都会增加此空间（或使其完全相同）。 该内存将由<code>malloc()</code>等管理。 <br><br> 这是在COM程序中实现<code>sbrk()</code>的方法。 请注意，您需要定义自己的<code>size_t</code> ，因为我们没有标准库。 <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _heap; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *hbreak = &amp;_heap; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sbrk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = hbreak; hbreak += size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; }</code> </pre> <br> 它只是将指针设置为<code>_heap</code>并根据需要<code>_heap</code>进行递增。 稍微聪明一点的<code>sbrk()</code>也要小心对齐。 <br><br>  DOS Defender的创建过程中发生了一件有趣的事情。 我（错误地）认为<code>sbrk()</code>中的内存<code>sbrk()</code>重置。 所以是在第一场比赛之后。 但是，DOS不会在程序之间重置此内存。 当我再次开始游戏时， <i>它会一直停在我停止的地方</i> ，因为将具有相同内容的相同数据结构加载到位。 很酷的巧合！ 这是使该嵌入式平台变得有趣的部分原因。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN412867/">https://habr.com/ru/post/zh-CN412867/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN412855/index.html">CSRF漏洞仍然相关</a></li>
<li><a href="../zh-CN412859/index.html">Windows中的两因素身份验证和无证书颁发机构和域的数据加密</a></li>
<li><a href="../zh-CN412861/index.html">为假人创建用户路径图</a></li>
<li><a href="../zh-CN412863/index.html">Dialogflower-适用于Yandex Alice的Google Dialogflow</a></li>
<li><a href="../zh-CN412865/index.html">如何在Sony Xperia XZ2中拍摄运动眼相机</a></li>
<li><a href="../zh-CN412869/index.html">组织工程与再生医学专家Tal Tal Dvir教授访谈</a></li>
<li><a href="../zh-CN412871/index.html">Eclair-Java Spring声明式日志记录库</a></li>
<li><a href="../zh-CN412873/index.html">普通笔记本扬声器发出的声音损坏了硬盘</a></li>
<li><a href="../zh-CN412877/index.html">钌（Ru）-在室温下具有铁磁性的第四种元素</a></li>
<li><a href="../zh-CN412879/index.html">第24期：IT培训-领先公司的当前问题和挑战</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>