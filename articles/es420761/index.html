<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔡 📚 👧🏼 TypeScript 3.0 🙎 😨 😗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TypeScript 3.0! Sí, salió, y realmente tiene muchas innovaciones. Debajo del corte, encontrará una descripción detallada de todas las últimas innovaci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TypeScript 3.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/420761/">  TypeScript 3.0!  Sí, salió, y realmente tiene muchas innovaciones.  Debajo del corte, encontrará una descripción detallada de todas las últimas innovaciones, incluido el modo de compilación, un nuevo tipo desconocido, cambios significativos en la API, mejoras de rendimiento y mucho más.  Únete ahora! <br><br><img src="https://habrastorage.org/webt/xl/ep/xt/xlepxtzys_k0mqm0crbje5aekvu.jpeg"><a name="habracut"></a><br><br>  ¡TypeScript 3.0 lanzado!  Un nuevo hito ha comenzado en el camino hacia el desarrollo de TypeScript, un asistente para todos los usuarios de JavaScript. <br><br>  Si no está familiarizado con TypeScript, ¡no es demasiado tarde para aprenderlo ahora!  TypeScript es una extensión de JavaScript diseñada para su uso en la versión moderna de este lenguaje de tipos estáticos.  El compilador TypeScript lee el código TypeScript que contiene, en particular, declaraciones de tipo y anotaciones de tipo, y produce un código JavaScript limpio y fácil de leer en el que estas construcciones se transforman y eliminan.  El código resultante se ejecuta en cualquier entorno de tiempo de ejecución que cumpla con el estándar ECMAScript, por ejemplo, en su navegador favorito o en la plataforma del servidor Node.js. <br><br>  El uso de dicho entorno significa que el código se analizará en busca de errores o errores tipográficos antes de que los usuarios lo inicien, pero sus ventajas no se limitan a esto.  Con toda esta información y resultados de análisis, TimeScript mejora la usabilidad al proporcionar herramientas de navegación y finalización de código automáticas como Buscar todas las referencias, Ir a definición y Cambiar nombre en su editor favorito. . <br><br>  Para comenzar con el idioma y obtener más información, siga el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> .  Si desea probar TypeScript 3.0 ahora mismo, puede descargarlo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NuGet</a> o npm escribiendo <br><br><pre><code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> -g typescript</code> </pre> <br>  Además, el soporte está disponible en los siguientes editores: <br><br><ul><li>  <a href="">Visual Studio 2017</a> (versión 15.2 y posterior); </li><li>  <a href="">Visual Studio 2015</a> (se requiere la actualización 3); </li><li>  Visual Studio Code ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">necesita instalar una versión preliminar</a> , mientras que esta característica no es compatible en el principal); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sublime Text 3 en el sitio web PackageControl</a> . </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otros editores</a> se actualizan de acuerdo con su propia programación, pero pronto todos tendrán un excelente soporte de TypeScript. <br><br><h2>  Descripción general de la versión 3.0 </h2><br>  Después del lanzamiento de TypeScript 2.0, brindamos una breve descripción de la contribución de las versiones anteriores a su estado actual.  Entre los lanzamientos de TypeScript 1.0 y 2.0, el lenguaje incluye tipos de unión, protectores de tipos, soporte para el estándar ECMAScript moderno, alias de tipo, soporte JSX, <code>this</code> tipo literal y polimórfico.  Si incluye tipos TypeScript 2.0 que no son nulos, análisis del flujo de control, soporte para uniones etiquetadas, este tipo y un modelo simplificado para recibir archivos <code>.d.ts</code> , podemos decir que este período determinó completamente los conceptos básicos. Trabajo tipográfico. <br><br>  Entonces, ¿qué se ha hecho desde entonces?  ¿Qué nos llevó a TypeScript 3.0, además de las nuevas características del estándar ECMAScript, como las funciones <code>async</code> / en <code>await</code> , los generadores y el operador rest / spread? <br><br>  TypeScript 2.1 se convirtió en la versión fundamental, que introdujo un modelo de metaprogramación estática en JavaScript.  Solicitud de clave ( <code>keyof</code> ), acceso al índice ( <code>T[K]</code> ) y tipos de objetos mapeados ( <code>{ [K in keyof T]: } T[K]}</code> ): esta es una lista de herramientas que se utilizaron para modelar de manera más efectiva las bibliotecas React, Ember, Lodash y otros. <br><br>  Las versiones de TypeScript 2.2 y 2.3 introdujeron soporte para plantillas de clase mixin, el tipo de <code>object</code> (que representa un objeto que no es primitivo) y valores predeterminados para tipos genéricos.  Estas características se han utilizado en varios proyectos, como Angular Material y Polymer.  Además, TypeScript 2.3 introdujo la capacidad de ajustar <code>this</code> tipos, permitiendo que el lenguaje funcione bien con bibliotecas como Vue, y se <code>checkJs</code> indicador <code>checkJs</code> para permitir que los tipos se verifiquen en archivos JavaScript. <br><br>  TypeScript 2.4 y 2.6 continúan la historia de aumentar la severidad de la verificación de tipos de funciones, asociada con algunas de las revisiones más antiguas de nuestro sistema de tipos.  Se <code>--strictFunctionTypes</code> el <code>--strictFunctionTypes</code> , forzando la contravarianza de los parámetros.  En la versión 2.7, la tendencia hacia el rigor ha persistido y se ha expresado en la validación en clases que usan el indicador <code>--strictPropertyInitialization</code> . <br><br>  TypeScript 2.8 introduce tipos condicionales, una poderosa herramienta para expresar estáticamente decisiones basadas en tipos, y la versión 2.9 generaliza la clave del operador y simplifica la importación de tipos. <br><br>  ¡Y eso nos lleva a TypeScript 3.0!  A pesar del nuevo número entero en el número, poco ha cambiado en la versión 3.0 (lo que implica una actualización muy fácil).  Presenta una nueva forma flexible y escalable de estructurar proyectos, un nuevo y poderoso soporte para trabajar con listas de parámetros, nuevos tipos para proporcionar verificaciones explícitas, soporte mejorado de JSX, diagnóstico de errores significativamente más fácil de usar y mucho más. <br><br><h2>  Que hay de nuevo </h2><br><ul><li>  Enlaces de proyectos <br><ul><li>  <code>--build</code> Modo de <code>--build</code> </li><li>  Gestión de estructura de salida </li><li>  Planes futuros </li></ul></li><li>  Recuperando y distribuyendo listas de parámetros usando tuplas </li><li>  Nuevas características de tipo Tuple </li><li>  Tipo <code>unknown</code> </li><li>  Diagnóstico de errores y entorno de usuario mejorados <br><ul><li>  Rangos de error asociados </li><li>  Diagnóstico mejorado y manejo de errores </li></ul></li><li>  Soporte para la propiedad <code>defaultProps</code> en JSX </li><li>  Directivas <code>/// &lt;reference lib="..." /&gt;</code> </li><li>  Mejorando la velocidad del editor <br><ul><li>  Refactorización de declaraciones de importación con nombre </li><li>  Fin de etiqueta final y marco de contorno </li><li>  Soluciones rápidas para código inalcanzable y etiquetas no utilizadas </li></ul></li><li>  Cambios críticos <br><ul><li>  <code>unknown</code> es un nombre de tipo reservado </li><li>  Cambios críticos de API </li></ul></li></ul><br><h2>  Enlaces de proyectos </h2><br>  Muy a menudo, para construir una biblioteca o aplicación, debe seguir varios pasos.  Suponga que su base de código contiene los directorios <code>src</code> y <code>test</code> .  Suponga que tiene una carpeta de <code>client</code> donde se almacena el código de la parte del cliente de la aplicación, y una carpeta de servidor que contiene el código de parte del servidor en la plataforma Node.js, y cada uno de ellos toma parte del código de la carpeta <code>shared</code> .  Quizás esté utilizando el llamado "repositorio único" y tenga muchos proyectos que dependen mucho entre sí. <br><br>  Una de las características más importantes en las que trabajamos al lanzar TypeScript 3.0 se denominó "enlaces de proyecto" y está diseñada para simplificar el trabajo con dichos scripts. <br><br>  Gracias a los enlaces de proyectos, algunos proyectos de TypeScript pueden depender de otros.  En particular, los archivos <code>tsconfig.json</code> pueden hacer referencia a otros archivos <code>tsconfig.json</code> .  La definición de estas dependencias facilita la división del código en proyectos más pequeños, porque el compilador TypeScript (y sus herramientas) tienen la oportunidad de comprender el orden de ensamblaje y la estructura de la salida.  Esto significa que el ensamblaje es más rápido y se realiza de forma incremental (en etapas), se admite la navegación transparente, la edición y la refactorización para varios proyectos.  Dado que TypeScript 3.0 sienta las bases para el proyecto y proporciona una API, cualquier herramienta de compilación debería poder proporcionar esto. <br><br><h4>  ¿Cómo se ve? </h4><br>  Aquí hay un archivo <code>tsconfig.json</code> que contiene enlaces a proyectos como un ejemplo simple. <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ ./src</span></span><span class="hljs-regexp"><span class="hljs-regexp">/bar/tsconfig</span></span>.json { <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> project references. <span class="hljs-string"><span class="hljs-string">"composite"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"declaration"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Other options... <span class="hljs-string"><span class="hljs-string">"outDir"</span></span>: <span class="hljs-string"><span class="hljs-string">"../../lib/bar"</span></span>, <span class="hljs-string"><span class="hljs-string">"strict"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"esnext"</span></span>, <span class="hljs-string"><span class="hljs-string">"moduleResolution"</span></span>: <span class="hljs-string"><span class="hljs-string">"node"</span></span>, }, <span class="hljs-string"><span class="hljs-string">"references"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"../foo"</span></span> } ] }</code> </pre> <br>  Tiene dos nuevos campos: <code>composite</code> y <code>references</code> . <br><br>  El campo de <code>references</code> simplemente apunta a otros archivos <code>tsconfig.json</code> (o las carpetas en las que están contenidos).  Cada enlace aquí es simplemente un objeto con un campo de <code>path</code> ("ruta") y le dice al compilador de TypeScript que para construir este proyecto, primero debe construir otro proyecto al que se refiere. <br><br>  Aparentemente, el campo <code>composite</code> tiene la misma importancia.  El campo <code>composite</code> garantiza que ciertos parámetros estén habilitados para permitir que cualquier proyecto que dependa de esto lo haga referencia e lo incluya en compilaciones incrementales.  La capacidad de construir de forma inteligente e incremental es importante, ya que una de las principales razones por las que puede abandonar un proyecto es la velocidad de construcción. <br><br>  Por ejemplo, si el proyecto <code>front-end</code> depende del proyecto <code>shared</code> y del núcleo, entonces nuestras API relacionadas con los enlaces del proyecto ayudarán a identificar cambios en el núcleo, pero solo se recopilarán de nuevo si los tipos producidos por el proyecto <code>core</code> han cambiado (es decir, archivos <code>.d.ts</code> ).  Esto significa que un cambio en el núcleo no implica un reensamblaje global de todos los proyectos.  Por esta razón, establecer el indicador <code>composite</code> también provoca la configuración del indicador de <code>declaration</code> . <br><br><h4>  - Modo de construcción </h4><br>  TypeScript 3.0 introducirá un conjunto de API para referencias de proyectos para que otras herramientas puedan proporcionar este método de construcción incremental rápido.  En particular, el complemento gulp-typescript ya usa estas API.  Por lo tanto, los enlaces posteriores a los proyectos se integrarán con los orquestadores de ensamblaje que elija. <br><br>  Sin embargo, para muchas aplicaciones y bibliotecas simples, es aconsejable no usar herramientas externas.  Esta es la razón por la cual el comando tsc ahora establece una nueva bandera <code>--build</code> . <br><br>  El <code>tsc --build</code> (o su alias, <code>tsc -b</code> ) toma un conjunto de proyectos y los construye, así como también proyectos dependientes.  Cuando se usa el nuevo modo de construcción, en primer lugar, se debe establecer el indicador <code>--build</code> , y se puede combinar con algunos otros indicadores: <br><ul><li>  <code>--verbose</code> : muestra cada paso requerido por el proceso de construcción. </li><li>  <code>--dry</code> : <code>--dry</code> sin generar archivos de salida (útil junto con la opción <code>--verbose</code> ). </li><li>  <code>–clean</code> : <code>–clean</code> eliminar archivos de salida que coinciden con la entrada especificada. </li><li>  <code>--force</code> : <code>--force</code> compilación completa y no incremental del proyecto. </li></ul><br><h4>  Gestión de estructura de salida </h4><br>  Una ventaja sutil pero increíblemente útil de las referencias de proyectos es la capacidad lógica de asignar archivos de entrada a los archivos de salida correspondientes. <br><br>  Si alguna vez ha intentado separar las partes cliente y servidor de la aplicación, es posible que tenga problemas para administrar la estructura de salida. <br><br>  Por ejemplo, si tanto client / index.ts como server / index.ts se refieren a shared / index.ts para los siguientes proyectos: <br><br><img src="https://habrastorage.org/webt/sb/wy/z4/sbwyz4hbixbmi8mnvek370pitvw.png"><br><br>  ... cuando intentamos construir proyectos de cliente y servidor, obtenemos ... <br><br><img src="https://habrastorage.org/webt/yk/rb/ft/ykrbftrbeb_l6ca3j75g95vtdnu.png"><br><br>  ... no ... <br><br><img src="https://habrastorage.org/webt/t3/oa/g0/t3oag0vxnflnjvvb8dqlcdgbfds.png"><br><br>  Tenga en cuenta que después de la compilación, recibimos copias de la carpeta compartida tanto en el cliente como en el servidor.  Dedicamos más tiempo a construir el ensamblado compartido dos veces y agregamos un nivel indeseable de anidamiento a lib / client / client y lib / server / server. <br><br>  El problema es que TypeScript busca ansiosamente archivos .ts e intenta incluirlos en esta compilación.  Idealmente, TypeScript debería haber entendido que estos archivos no deberían participar en el ensamblaje en la misma compilación y, en su lugar, ir a los archivos .d.ts para obtener información sobre el tipo. <br><br>  La creación del archivo tsconfig.json para shared produce exactamente este resultado.  Señala al compilador TypeScript: <br><br><ol><li>  que el proyecto compartido debe construirse independientemente </li><li>  y que al importar desde ../shared debemos buscar archivos .d.ts en su directorio de salida. </li></ol><br>  Esto evita ejecutar un ensamblaje doble, además de incluir accidentalmente todo el contenido compartido. <br><br><h4>  Planes futuros </h4><br>  Para obtener una comprensión más profunda de los enlaces de diseño y las posibilidades de su uso, lea sobre ellos con más detalle en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rastreador de esta versión</a> .  En un futuro cercano, prepararemos la documentación sobre los enlaces del proyecto y el modo de construcción. <br><br>  Nos esforzamos para que los autores de otras herramientas de programación puedan mantener referencias a proyectos y continuar mejorando el entorno de edición con respecto a esta función.  Tenemos la intención de asegurarnos de que trabajar con enlaces de proyectos funcione tan bien como desarrollar código con un solo archivo tsconfig.json.  Si eventualmente comienza a usar enlaces de proyectos, le agradeceremos sus comentarios. <br><br><h2>  Recuperando y distribuyendo listas de parámetros usando tuplas </h2><br>  A menudo damos esto por sentado, pero JavaScript nos permite considerar las listas de parámetros como valores de primera clase, ya sea utilizando argumentos o parámetros de tipo rest (por ejemplo ... rest). <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...args</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args); }</code> </pre> <br>  Tenga en cuenta que call funciona para funciones con cualquier número de parámetros.  A diferencia de otros lenguajes, JavaScript no nos obliga a definir call0, call1, call2, etc. de la siguiente manera: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, param1)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">param</span></span>1); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, param1, param2)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">param</span></span>1, <span class="hljs-keyword"><span class="hljs-keyword">param</span></span>2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, param1, param2, param3)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">param</span></span>1, <span class="hljs-keyword"><span class="hljs-keyword">param</span></span>2, <span class="hljs-keyword"><span class="hljs-keyword">param</span></span>3); }</code> </pre> <br>  Desafortunadamente, durante algún tiempo no hubo una buena manera de expresar esto en TypeScript sin declarar un número finito de sobrecargas: <br><br><pre> <code class="hljs powershell">// TODO (billg): <span class="hljs-number"><span class="hljs-number">5</span></span> overloads should *probably* be enough <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> anybody? <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T3</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T4</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (param1: T1, param2: T2, param3: T3, param4: T4)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param1</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param2</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param3</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T3</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param4</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T4</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T3</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (param1: T1, param2: T2, param3: T3)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param1</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param2</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param3</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T3</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (param1: T1, param2: T2)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param1</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param2</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (param1: T1)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param1</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: ()</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param1</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (...args: any[])</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">, ...</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">[])</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args); }</code> </pre> <br>  Uf!  ¡Otra muerte con mil sobrecargas!  O al menos tantas sobrecargas como necesiten los usuarios. <br><br>  TypeScript 3.0 le permite simular mejor tales escenarios, ya que ahora los parámetros del tipo de resto pueden ser universales, y su tipo se define como una tupla.  En lugar de declarar cada una de estas sobrecargas, decimos que el parámetro rest ... args de la función fn debería ser un parámetro de tipo que extienda la matriz, y luego reutilizarlo para el parámetro ... args que pasa la función de llamada: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">[], </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (...args: TS)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, ...</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args); }</code> </pre> <br>  Cuando llamamos a la función de llamada, TypeScript intenta extraer una lista de parámetros de lo que pasamos a fn y convertirla en una tupla: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: number, y: string)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x + y).toLowerCase(); } // The `TS` type <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> is inferred as `[number, string]` call(foo, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>);</code> </pre> <br>  Cuando TypeScript define TS como [número, cadena], y terminamos de reutilizar TS en el parámetro rest de la función de llamada, la instancia de la función se ve así: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (...args: [number, string])</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function">, ...</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-function">: [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function">]): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br>  ¡Y en TypeScript 3.0, cuando se usa una tupla en reposo, el parámetro se minimiza al resto de la lista de parámetros!  La instancia anterior se reduce a parámetros simples sin tuplas: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (arg1: number, arg2: string)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arg1</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arg2</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br>  Entonces, además de detectar errores de conversión de tipo al pasar argumentos no válidos: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">[], </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (...args: TS)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, ...</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args); } call((x: number, y: string) =&gt; y, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>); // ~~~~~~~ // Error! `string` isn<span class="hljs-string"><span class="hljs-string">'t assignable to `number`!</span></span></code> </pre> <br>  ... y escriba la definición de otros argumentos: <br><br><pre> <code class="hljs ruby">call((x, y) =&gt; { <span class="hljs-regexp"><span class="hljs-regexp">/* .... */</span></span> }, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ^ ^ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">`x`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">`y`</span></span> have their types inferred as <span class="hljs-string"><span class="hljs-string">`string`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">`number`</span></span> respectively.</code> </pre> <br>  ... también podemos ver los tipos de tuplas que estas funciones definen desde el exterior: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tuple</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">[]&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...xs: TS)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xs; } let x = tuple(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>); // has type `[number, number, string]`</code> </pre> <br>  Pero presta atención a una advertencia.  Para hacer todo este trabajo, tuvimos que ampliar las capacidades de las tuplas ... <br><br><h4>  Nuevas características de tipo Tuple </h4><br>  Para modelar la lista de parámetros como una tupla (como acabamos de comentar), tuvimos que repensar un poco los tipos de tupla.  Antes del lanzamiento de TypeScript 3.0, lo mejor que se podía modelar usando tuplas era el orden y la longitud del conjunto de parámetros. <br><br>  Sin embargo, las listas de parámetros no son solo listas de tipos ordenados.  Por ejemplo, los parámetros al final pueden ser opcionales: <br><br><pre> <code class="hljs powershell">// Both `y` and `z` are optional here. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: boolean, y = 100, z?: string)</span></span></span></span> { // ... } foo(true); foo(true, undefined, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>); foo(true, <span class="hljs-number"><span class="hljs-number">200</span></span>);</code> </pre> <br>  El último parámetro puede ser un parámetro de reposo. <br><br><pre> <code class="hljs powershell">// `rest` accepts any number of strings - even none! <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...rest: string[])</span></span></span></span> { // ... } foo(); foo(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); foo(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>);</code> </pre> <br>  Y finalmente, hay una propiedad bastante interesante de las listas de parámetros: pueden estar vacías: <br><br><pre> <code class="hljs powershell">// Accepts no parameters. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { // ... } foo();</code> </pre> <br>  Por lo tanto, para que las tuplas se correspondan con las listas de parámetros, necesitamos simular cada uno de estos escenarios. <br><br>  En primer lugar, ahora al final de la tupla puede haber elementos opcionales: <br><br><pre> <code class="hljs powershell">/** * <span class="hljs-number"><span class="hljs-number">2</span></span>D, or potentially <span class="hljs-number"><span class="hljs-number">3</span></span>D, coordinate. */ type Coordinate = [<span class="hljs-type"><span class="hljs-type">number</span></span>, <span class="hljs-type"><span class="hljs-type">number</span></span>, <span class="hljs-type"><span class="hljs-type">number</span></span>?];</code> </pre> <br>  El tipo Coordinate crea una tupla con una propiedad opcional llamada 2: ¡un elemento con índice 2 puede no estar definido!  Curiosamente, dado que las tuplas usan un tipo literal numérico para su propiedad de longitud, la propiedad de longitud de la tupla Coodinate es de tipo 2 |  3) <br><br>  En segundo lugar, el elemento de descanso ahora puede estar presente al final de la tupla. <br><br><pre> <code class="hljs powershell">type OneNumberAndSomeStrings = [<span class="hljs-type"><span class="hljs-type">number</span></span>, <span class="hljs-type"><span class="hljs-type">...string</span></span>[]];</code> </pre> <br>  Gracias a los elementos de descanso, las tuplas exhiben un comportamiento "ilimitado desde el final" muy interesante.  El ejemplo anterior de tipo OneNumberAndSomeStrings requiere que el tipo de su primera propiedad sea número, y se permiten una o más propiedades de tipo cadena.  La indexación de este tipo de tupla con un número de número arbitrario devuelve la cadena de tipo |  número, porque el valor del índice es desconocido.  De manera similar, dado que la longitud de la tupla es desconocida, el valor de la propiedad de longitud es simplemente número. <br><br>  Cabe señalar que, en ausencia de otros elementos, el elemento de descanso en la tupla es idéntico a sí mismo: <br><br><pre> <code class="hljs powershell">type Foo = [<span class="hljs-type"><span class="hljs-type">...number</span></span>[]]; // Equivalent to `number[]`.</code> </pre> <br>  ¡Finalmente, las tuplas ahora pueden estar vacías!  Aunque esto no es muy útil cuando se usa fuera de las listas de parámetros, un tipo de tupla vacío se puede definir como []: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyTuple</span></span></span><span class="hljs-class"> </span></span>= [];</code> </pre> <br>  Como es de esperar, una tupla vacía tiene una propiedad de longitud de 0, y la indexación con número devuelve el tipo nunca. <br><br><h2>  Diagnóstico de errores y entorno de usuario mejorados </h2><br>  Con el tiempo, recibimos más y más solicitudes de miembros de nuestra comunidad con respecto a la mejora de los mensajes de error.  Aunque este trabajo está lejos de estar completo, nos enteramos de usted e hicimos una serie de mejoras en la versión TypeScript 3.0. <br><br><h4>  Rangos de error asociados </h4><br>  En parte, el objetivo de un buen mensaje de error es indicar al usuario cómo corregirlo o, en primer lugar, dejar claro por qué apareció este mensaje.  En la mayoría de los casos, contiene mucha información o indica varias razones para que ocurra.  A partir de un análisis de estas razones, podemos concluir que los errores resultan de diferentes partes del código. <br><br>  Los rangos de error asociados son una nueva forma de proporcionar esta información a los usuarios.  En TypeScript 3.0, los mensajes de error pueden generar mensajes en otra parte del código para que los usuarios puedan descubrir la causa y el efecto del error. <br><br><img src="https://habrastorage.org/webt/ha/-n/h4/ha-nh4ttnfnexzsg-rj47jiu7cu.png"><br><br>  En cierto sentido, los mensajes de error relacionados no solo pueden dar una explicación al usuario, sino que también indican la ruta al lugar donde todo salió mal. <br><br><img src="https://habrastorage.org/webt/bf/sg/ws/bfsgws4xoje8i7_mxqpoari_wfw.png"><br><br>  ¡Estos intervalos también aparecerán en modo terminal cuando ejecute el comando tsc con el modo --pretty habilitado, aunque todavía estamos trabajando para mejorar la interfaz de usuario y considerar sus comentarios! <br><br><h4>  Diagnóstico mejorado y manejo de errores </h4><br>  Al prepararnos para el lanzamiento de TypeScript 2.9, comenzamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">a prestar más atención</a> a los mensajes de error, y en el lanzamiento 3.0 realmente intentamos resolver las tareas principales que nos permitirían realizar un diagnóstico de errores inteligente, claro y preciso.  Esto incluye, en particular, la selección de tipos apropiados en caso de inconsistencias en los tipos de asociación y la salida directa a la fuente del error para ciertos tipos de mensajes. <br><br>  Creemos que nuestros esfuerzos se han justificado y, como resultado, recibirá mensajes de error más cortos y claros. <br><br><img src="https://habrastorage.org/webt/rn/fj/1a/rnfj1aowq5j-myv-1qjvdeowpui.png"><br><br><img src="https://habrastorage.org/webt/5l/tk/zu/5ltkzun56pppzlksb88k_zapume.png"><br><br><h2>  Tipo desconocido </h2><br>  El tipo any es cualquier tipo en TypeScript que sea adecuado para cualquier cosa.  Como cubre los tipos de todos los valores posibles, no nos obliga a hacer ninguna verificación antes de intentar llamar, construir o acceder a sus propiedades.  También le permite asignar valores de tipo any a variables que esperan valores de cualquier otro tipo. <br><br>  Esta característica es generalmente útil, pero no puede proporcionar suficiente rigor. <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">let</span></span> foo: any = <span class="hljs-number"><span class="hljs-number">10</span></span>; // <span class="hljs-type"><span class="hljs-type">All</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> these will throw errors, but <span class="hljs-type"><span class="hljs-type">TypeScript</span></span> // won't complain since `foo` has the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> `any`. foo.x.prop; foo.y.prop; foo.z.prop; foo(); new foo(); upperCase(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">); foo `hello world!`; function upperCase(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">toUpperCase</span></span></span><span class="hljs-class">(); }</span></span></code> </pre> <br>  A veces, en TypeScript, desea describir un tipo que no es adecuado para nada.  Esto es útil para una API que quiere señalar: "Puede ser cualquier valor, por lo que debe hacer algunas comprobaciones antes de usarlo".  Y los usuarios se ven obligados a analizar los valores de retorno por razones de seguridad. <br><br>  TypeScript 3.0 introduce un nuevo tipo llamado desconocido, que hace exactamente eso.   any,  unknown   , ,    any,  unknown          .         unknown,      . <br><br>       unknown  any,     foo   : <br><br><pre> <code class="hljs powershell">let foo: unknown = <span class="hljs-number"><span class="hljs-number">10</span></span>; // Since `foo` has type `unknown`, TypeScript // errors on each of these locations. foo.x.prop; foo.y.prop; foo.z.prop; foo(); new foo(); upperCase(foo); foo `hello world!`; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upperCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: string)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.toUpperCase(); }</code> </pre> <br>       ,           ,    ,   . <br><br><pre> <code class="hljs lua">let foo: unknown = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasXYZ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj: any)</span></span></span></span>: obj is { x: any, y: any, z: any } { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!obj &amp;&amp; typeof obj === <span class="hljs-string"><span class="hljs-string">"object"</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">"x"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj &amp;&amp; <span class="hljs-string"><span class="hljs-string">"y"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj &amp;&amp; <span class="hljs-string"><span class="hljs-string">"z"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj } // Using a user-defined <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> guard... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasXYZ(foo)) { // ...we<span class="hljs-string"><span class="hljs-string">'re allowed to access certain properties again. foo.x.prop; foo.y.prop; foo.z.prop; } // We can also just convince TypeScript we know what we'</span></span>re doing // by using a <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> assertion. upperCase(foo as <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upperCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: string)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.toUpperCase(); }</code> </pre> <br> :  ,    ,   ,  {} | null | undefined,   unknown           ,       : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Arrayify&lt;T&gt; = T extends <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;T&gt; : never; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> A = Arrayify&lt;{} | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> | undefined&gt;; // <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>[] | undefined[] | {}[] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> B = Arrayify&lt;<span class="hljs-type"><span class="hljs-type">unknown</span></span>&gt;; // <span class="hljs-type"><span class="hljs-type">unknown</span></span>[]</code> </pre> <br><h2>  defaultProps  JSX </h2><br> <i> :  .d.ts  React    , ,     .</i> <br><br>   -     TypeScript/JavaScript   ,   ,         .           ,     .       ,      . <br><br><pre> <code class="hljs julia"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> loudlyGreet(name = <span class="hljs-string"><span class="hljs-string">"world"</span></span>) { // Thanks to the default initializer, <span class="hljs-string"><span class="hljs-string">`name`</span></span> will always have <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">`string`</span></span> internally. // We don't have to check <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">`undefined`</span></span> here. console.log(<span class="hljs-string"><span class="hljs-string">"HELLO"</span></span>, name.toUpperCase()); } // Externally, <span class="hljs-string"><span class="hljs-string">`name`</span></span> is optional, and we can potentially pass <span class="hljs-string"><span class="hljs-string">`undefined`</span></span> or omit it entirely. loudlyGreet(); loudlyGreet(undefined);</code> </pre> <br>   React         (props).        React  ,  defaultProps,      props. <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span> non-TypeScript JSX file <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "react"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "react-dom"; export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Greet extends React.Component { render() { const { <span class="hljs-type"><span class="hljs-type">name</span></span> } = this.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt;Hello ${<span class="hljs-type"><span class="hljs-type">name</span></span>.toUpperCase()}!&lt;/div&gt;; } static defaultProps = { <span class="hljs-type"><span class="hljs-type">name</span></span>: "world", }; } // <span class="hljs-keyword"><span class="hljs-keyword">Notice</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> `<span class="hljs-type"><span class="hljs-type">name</span></span>` <span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> was specified! // vvvvvvvvv const result = ReactDOM.renderToString(&lt;Greet /&gt;); console.log(result);</code> </pre> <br>  ,   &lt;Greet /&gt;    name.    Greet,  name    «world»,    : Hello world!. <br><br>  , TypeScript  ,  defaultProps  -    JSX.                render: <br><br><pre> <code class="hljs scala">export interface <span class="hljs-type"><span class="hljs-type">Props</span></span> { name?: string } export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component&lt;Props&gt;</span></span></span><span class="hljs-class"> </span></span>{ render() { const { name } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-comment"><span class="hljs-comment">// Notice the `!` ------v return &lt;div&gt;Hello ${name!.toUpperCase()}!&lt;/div&gt;; } static defaultProps = { name: "world"} }</span></span></code> </pre> <br>      ,       . <br><br>    TypeScript 3.0        JSX,  LibraryManagedAttributes.    ,     ,   TypeScript,     JSX.  ,    ,      React  defaultProps ,   ,  propTypes. <br><br><pre> <code class="hljs scala">export interface <span class="hljs-type"><span class="hljs-type">Props</span></span> { name: string } export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component&lt;Props&gt;</span></span></span><span class="hljs-class"> </span></span>{ render() { const { name } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt;<span class="hljs-type"><span class="hljs-type">Hello</span></span> ${name.toUpperCase()}!&lt;/div&gt;; } static defaultProps = { name: <span class="hljs-string"><span class="hljs-string">"world"</span></span>} } <span class="hljs-comment"><span class="hljs-comment">// Type-checks! No type assertions needed! let el = &lt;Greet /&gt;</span></span></code> </pre> <br>   ,   .  defaultProps,         Partial ,  -   (stateless function components, SFC),   defaultProps   Partial ,    .           defaultProps    (.  )       SFC   ES2015: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"world"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }: Props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello ${name.toUpperCase()}!</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; }</code> </pre> <br>  ,   .      TypeScript,   .d.ts   DefinitelyTyped      ,  ,  @types/react     .          DefinitelyTyped,        . <br><br><h2>  /// &lt;reference lib="..." /&gt; </h2><br>   ,     ,   ,   (polyfills) — ,     API    ,      ( .d.ts),        API.   ,               TypeScript  lib.d.ts      ,   --lib  --target. ,    core-js       lib.es2015.d.ts. <br><br>     TypeScript 3.0 ,      API,   ,     : /// &lt;reference lib="..." /&gt;. <br><br> ,    Promise  ES2015      <br><br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;reference lib="es2015.promise" /&gt;</span></span></span><span class="hljs-comment"> export {};</span></span></code> </pre> <br>    ,    TypeScript 3.0    ,      lib.es2015.promise.d.ts,    ,  Promise . <br><br><h4>      </h4><br> ,      ,  TypeScript  ,          .        TypeScript  JavaScript   ,   Visual Studio, Visual Studio Code        TypeScript.   ,    ,    ,  Go to Definition («  »)       . TypeScript 3.0    . <br><br><h4>     </h4><br>       ,    ,  . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dependency <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "./dependency"; // look at <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> this repetition! dependency.foo(); dependency.bar(); dependency.baz();</code> </pre> <br>   ,       ,   ,          ,   . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { foo, bar, baz } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./dependency"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// way lower in the file... foo(); bar(); baz();</span></span></code> </pre> <br>   ,      ,      . TypeScript 3.0   ,       . <br><br><img src="https://habrastorage.org/webt/-z/t2/fg/-zt2fg-ailzlgreoxw8jonn_b8m.png"><br><br><h4>        </h4><br>    TypeScript    ,      JSX: <br><br><ul><li>    JSX; </li><li>       JSX. </li></ul><br><img src="https://habrastorage.org/webt/6d/gv/nr/6dgvnrwu7ivqadbw5yillk1kroo.png"><br><br><h4>         </h4><br> TypeScript      —   ,    . <br><br><h2>   </h2><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> API</a> . <br><br>  ,   TypeScript 3    ,    .       ,       API     . <br><br><h4> unknown —    </h4><br>  unknown —   ,        ,   ,    . <br><br><h4>    API </h4><br><ul><li>    LanguageService#getSourceFile  ,        . . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">#24540</a> . </li><li>   TypeChecker#getSymbolDisplayBuilder       . . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">#25331</a> .     emitter ( )  node builder. </li><li>   escapeIdentifier  unescapeIdentifier  .     API   ,        .   ,       ,      .           escapeLeadingUnderscores  unescapeLeadingUnderscores,     ,    (      «»  __String  string   ). </li><li>  TypeChecker#getSuggestionForNonexistentProperty, TypeChecker#getSuggestionForNonexistentSymbol  TypeChecker#getSuggestionForNonexistentModule  ,         API. . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">#25520</a> . </li></ul><br><h2>  Perspectivas </h2><br>    TypeScript  .     ,        ,  ,  DefinitelyTyped   ,       .     ,            . <br><br>           ,         TypeScript ( ,   ).       ,   ,           JavaScript.      ,      TypeScript,       . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   ,      ,     ,     ,   , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> Twitter</a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> .     . <br><br> ,          TypeScript, !         .    ,  ,       TypeScript   ,  . <br><br>   ! <br>  TypeScript </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420761/">https://habr.com/ru/post/es420761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420739/index.html">La caja todavía está en el mango: por qué en 2018 todavía necesitas aprender idiomas tú mismo</a></li>
<li><a href="../es420741/index.html">Hoja de trucos para programadores o "buscaremos en Google"</a></li>
<li><a href="../es420749/index.html">GitLab para Proyecto de Entrega Continua en Tecnologías InterSystems: Contenedores</a></li>
<li><a href="../es420753/index.html">Frontend de microservicios: un enfoque moderno para la separación del frente</a></li>
<li><a href="../es420757/index.html">Concurso de programación: Comercio (Resultados)</a></li>
<li><a href="../es420763/index.html">KDD 2018, día dos, talleres</a></li>
<li><a href="../es420765/index.html">Impresiones de Gemini PDA. ¿Cosechadora de doble arranque de bolsillo o juguete inútil?</a></li>
<li><a href="../es420767/index.html">Rostelecom exige que el Sputnik sea declarado en quiebra</a></li>
<li><a href="../es420769/index.html">Looking.House: más de 150 puntos de Looking Glass en un solo sitio</a></li>
<li><a href="../es420775/index.html">Juego propio en 72 horas: rastrillo, muletas y alpacas.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>