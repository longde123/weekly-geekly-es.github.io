<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö• üòú üçã Ist die Verwendung von BSP in Doom wirklich ein genialer Schritt? üßöüèΩ üç± ‚óΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Gipfel der Technologie der Zeit. 

 1993 ver√∂ffentlichte id Software Doom , einen Ego-Shooter, der sich schnell zu einem Ph√§nomen entwickelte. Heu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ist die Verwendung von BSP in Doom wirklich ein genialer Schritt?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482614/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/268/1a6/7cd/2681a67cd1d82d83879143c036a95ca4.jpg"></div><br>  <i>Der Gipfel der Technologie der Zeit.</i> <br><br>  1993 ver√∂ffentlichte id Software <em>Doom</em> , einen Ego-Shooter, der sich schnell zu einem Ph√§nomen entwickelte.  Heute wird angenommen, dass dies eines der Spiele ist, die den gr√∂√üten Einfluss in der Geschichte hatten. <br><br>  Zehn Jahre nach der Ver√∂ffentlichung von <em>Doom</em> ver√∂ffentlichte der Journalist David Kouchner 2003 ein id-Software-Buch mit dem Titel <a rel="nofollow" href="https://www.amazon.com/dp/0812972155/%3Ftag%3Darstech20-20"><em>Masters of Doom</em></a> , das seitdem eine kanonische Beschreibung des <em>Doom-</em> Erstellungsprozesses darstellt.  Ich habe <em>Masters of Doom vor ein</em> paar Jahren gelesen und erinnere mich fast an nichts, aber eine Geschichte aus einem Buch √ºber den Hauptprogrammierer John Carmack ist mir in Erinnerung geblieben.  Meine Beschreibung wird nicht ganz zutreffend sein (siehe unten f√ºr weitere Details), aber kurz gesagt, in der fr√ºhen Phase der <em>Doom-</em> Entwicklung stellte Carmack fest, dass der 3D-Renderer, den er f√ºr das Spiel geschrieben hatte, beim Rendern bestimmter Ebenen langsamer wurde.  Dies war inakzeptabel, da <em>Doom</em> ein aktives und sogar hektisches Spiel werden musste.  Carmack erkannte, dass das Renderer-Problem so grundlegend war, dass er nach einem optimaleren Rendering-Algorithmus suchen musste, und begann, Forschungsartikel zu lesen.  Infolgedessen implementierte er eine Technik namens BSP (Binary Space Partitioning), die zuvor noch nie in Videospielen verwendet wurde, und beschleunigte damit die <em>Doom-</em> Engine erheblich. <br><br>  Diese Geschichte, wie Carmack die neuesten wissenschaftlichen Erkenntnisse auf Videospiele √ºbertragen hat, hat mich immer beeindruckt.  Meiner Meinung nach wurde Carmack so zu einer legend√§ren Figur.  Er verdient es aus vielen Gr√ºnden, als archetypischer brillanter Videospiel-Programmierer bekannt zu sein, aber als wichtigster erinnere ich mich immer an die Episode mit dem Lesen von wissenschaftlichen Artikeln und der bin√§ren Aufteilung des Raums. <br><a name="habracut"></a><br>  Offensichtlich ist diese Geschichte beeindruckend, denn der Begriff ‚Äûbin√§re Raumteilung‚Äú scheint nicht nur f√ºr die Implementierung, sondern auch f√ºr das Verst√§ndnis etwas kompliziert zu sein.  Lange Zeit ging ich davon aus, dass Carmack einen intellektuellen Sprung nach vorne gemacht hatte, aber da ich nicht wusste, was eine bin√§re Raumaufteilung ist und wie neu diese Technik war, als Carmack sich entschied, sie zu verwenden, war ich mir nicht ganz sicher.  Wie genial war das Hinzuf√ºgen einer bin√§ren Raumpartition zu <em>Doom</em> auf einer Skala von Homer Simpson bis Albert Einstein? <br><br>  Ich fragte mich auch, woher die BSP kam und wie die Idee zu Carmack kam.  Daher wird dieser Beitrag nicht nur John Carmack und <em>Doom gewidmet</em> , sondern auch der Geschichte der Datenstruktur des "Binary Space Partition Tree" (oder BSP-Baums).  Es stellte sich heraus, dass der BSP-Baum, wie viele andere Aspekte der Computerwissenschaften, aus Forschungen f√ºr das Milit√§r stammt. <br><br>  Ja, das stimmt: E1M1, das erste <em>Doom-</em> Level, ist dank der US Air Force erschienen. <br><br><h2>  VSD-Aufgabe </h2><br>  Der BSP-Baum ist eine L√∂sung f√ºr eine der schwierigsten Aufgaben in der Computergrafik.  Um eine dreidimensionale Szene zu rendern, muss der Renderer bestimmen, was vom aktuellen Punkt aus sichtbar und was nicht sichtbar ist.  Dies ist nicht besonders schwierig, wenn Sie viel Zeit haben. Eine sich selbst respektierende Echtzeit-Game-Engine sollte jedoch mindestens 30 Mal pro Sekunde die sichtbaren und unsichtbaren Teile der Welt bestimmen. <br><br>  Diese Aufgabe wird h√§ufig als VSD-Aufgabe (Visible Surface Determination) bezeichnet.  Der Programmierer Michael Abrash, der mit Carmack on <em>Quake</em> (dem n√§chsten id-Software-Spiel nach <em>Doom</em> ) zusammengearbeitet hat, schrieb in seinem ber√ºhmten Buch <a href="http://www.jagregory.com/abrash-black-book/"><em>Graphics Programming Black Book</em></a> √ºber die VSD-Aufgabe: <br><br><blockquote>  Ich m√∂chte √ºber die meiner Meinung nach schwierigste Aufgabe der 3D-Grafik sprechen: das Bestimmen der sichtbaren Fl√§chen (Zeichnen der gew√ºnschten Fl√§che in jedem Pixel) und deren enger Verwandter - die Aufgabe des Keulens (so schnell wie m√∂glich unsichtbare Polygone werfen, um die Bestimmung der sichtbaren Fl√§chen zu beschleunigen).  Der K√ºrze halber bezeichne ich mit der Abk√ºrzung VSD sowohl die Definition von sichtbaren Oberfl√§chen als auch das Beschneiden. <br><br>  Warum halte ich VSD f√ºr die schwierigste 3D-Aufgabe?  Obwohl Rasterungsprobleme wie die Texturabbildung ebenfalls erstaunliche und wichtige Aufgaben sind, handelt es sich hierbei um Aufgaben von relativ begrenztem Umfang, deren L√∂sung sich auf das Auftreten von 3D-Beschleunigern auf Ger√§ten verlagert.  Au√üerdem skalieren sie nur, wenn die Bildschirmaufl√∂sung erh√∂ht wird, was durchaus ertr√§glich ist. <br><br>  Im Gegensatz dazu ist VSD eine unbegrenzte Aufgabe, und jetzt werden Dutzende von L√∂sungen verwendet, um sie zu l√∂sen.  Noch wichtiger ist, dass die naive Leistung von VSD direkt mit der Komplexit√§t der Szene skaliert, die normalerweise als quadratische oder kubische Funktion zunimmt, sodass sie schnell zum begrenzenden Faktor f√ºr die Wiedergabe realistischer Welten wird. </blockquote><br>  Abrash schrieb √ºber die Komplexit√§t des VSD-Problems in den sp√§ten 90ern, ein paar Jahre nachdem <em>Doom</em> bewiesen hatte, dass normale Leute in der Lage sein m√∂chten, grafisch anspruchsvolle Spiele auf ihren Heimcomputern zu spielen.  In den fr√ºhen 90er Jahren, als id Software gerade mit der Ver√∂ffentlichung von Spielen begann, mussten sie effektiv auf ungeeigneten Computern arbeiten: Heimcomputer wurden f√ºr die Arbeit mit Text, Tabellenkalkulationen und √§hnlichen Anwendungen entwickelt.  Um dieses Ziel zu erreichen, musste sich das Unternehmen der Fiktion n√§hern, insbesondere im Fall mehrerer 3D-Spiele, die von id Software vor <em>Doom ver√∂ffentlicht wurden</em> .  In diesen Spielen wurde das Design aller Level so eingeschr√§nkt, dass die L√∂sung des VSD-Problems vereinfacht wurde. <br><br>  Zum Beispiel bestand in <em>Wolfenstein 3D</em> , dem Spiel, das id Software kurz vor <em>Doom herausbrachte</em> , jede Ebene aus W√§nden, die entlang der Achsen ausgerichtet waren.  Mit anderen Worten, im Wolfenstein-Universum k√∂nnte es Nord- / S√ºdw√§nde oder Ost- / Westw√§nde geben, und keine anderen.  Dar√ºber hinaus k√∂nnen W√§nde in festen Abst√§nden im Raster platziert werden. Alle Korridore haben eine Breite von entweder einer oder zwei Rasterzellen usw., jedoch niemals von 2,5 Zellen.  Obwohl dies bedeutete, dass das Team von id Software nahezu gleich aussehende Ebenen erstellen konnte, machte es diese Einschr√§nkung Carmack sehr leicht, einen Renderer f√ºr <em>Wolfenstein</em> zu schreiben. <br><br>  <em>Der Wolfenstein-</em> Renderer l√∂ste das Problem der VSD, indem er Strahlen (Ray Marching) vom Bildschirm in die virtuelle Welt bewegte.  Ray-Renderer sind in der Regel Raycasting-Renderer - sie sind h√§ufig langsam, da zur L√∂sung des VSD-Problems in Raycaster der erste Schnittpunkt zwischen dem Strahl und einem Objekt auf der Welt gesucht werden muss, der viel Rechenaufwand erfordert.  Da jedoch alle W√§nde in <em>Wolfenstein</em> mit einem Gitter ausgekleidet sind, sind die Gitterlinien die einzigen Stellen, an denen ein Balken die Wand √ºberqueren kann.  Daher reicht es aus, wenn der Renderer jeden dieser Schnittpunkte √ºberpr√ºft.  Wenn der Renderer zun√§chst den Schnittpunkt √ºberpr√ºft, der dem Ansichtspunkt des Players am n√§chsten liegt, dann den zweiten in der N√§he usw. und endet, wenn er auf die erste Wand trifft, ist das VSD-Problem auf die trivialste Weise gel√∂st.  Der Strahl bewegte sich einfach von jedem Pixel vorw√§rts, bis er auf etwas stie√ü, was in Bezug auf die Prozessortaktraten sehr kosteng√ºnstig ist.  Und da alle W√§nde die gleiche H√∂he haben, reicht es aus, dass wir f√ºr jede Pixelspalte Strahlen aussenden. <br><br>  Diese Vereinfachung des Renderns machte <em>Wolfenstein</em> schnell genug, um auf schwachen Heim-PCs jener Zeit zu arbeiten, als es noch keine speziellen Grafikkarten gab.  Ein solcher Ansatz w√ºrde in <em>Doom</em> jedoch nicht funktionieren, da das ID-Team beschlossen hat, dass es in seinem neuen Spiel so neue Elemente wie diagonale W√§nde, Treppen und Decken mit unterschiedlichen H√∂hen geben wird.  Ray Marschieren war nicht mehr geeignet, also schrieb Carmack eine andere Art von Renderer.  Der <em>Wolfenstein-</em> Renderer, bei dem der Strahl f√ºr jede Pixelspalte verwendet wurde, wurde vom Bild abgesto√üen, und der <em>Doom-</em> Renderer sollte von Objekten abgesto√üen werden.  Dies bedeutete, dass der <em>Doom-</em> Renderer, anstatt die Bildschirmpixel zu durchlaufen und ihre Farbe zu bestimmen, √ºber Objekte in der Szene iterieren und diese nacheinander auf den Bildschirm projizieren musste. <br><br>  In einem solchen Renderer besteht eine einfache M√∂glichkeit, das VSD-Problem zu l√∂sen, in der Verwendung eines Z-Puffers.  Jedes Mal, wenn wir ein Objekt auf den Bildschirm projizieren, wird f√ºr jedes Pixel, das wir zeichnen m√∂chten, eine √úberpr√ºfung durchgef√ºhrt.  Befindet sich der zu zeichnende Teil des Objekts n√§her am Player als das bereits im Pixel gezeichnete Objekt, k√∂nnen wir seine Informationen umschreiben.  Andernfalls m√ºssen Sie das Pixel unver√§ndert lassen.  Dieser Ansatz ist einfach, aber der Z-Buffer ben√∂tigt viel Speicher und der Renderer kann immer noch eine Reihe von Prozessortakten f√ºr die Projektion von Ebenengeometrien ausgeben, die der Player nicht sieht. <br><br>  Anfang der neunziger Jahre hatte die Z-Buffer-L√∂sung einen weiteren Nachteil: Auf IBM-kompatiblen PCs mit einem Videoadaptersystem namens VGA war das Schreiben in den Ausgabebildpuffer ein kostspieliger Vorgang.  Die f√ºr das Rendern von Pixeln aufgewendete Zeit, die dann einfach √ºberschrieben wird, hat die Leistung des Renderers erheblich verringert. <br><br>  Da das Schreiben in den Einzelbildpuffer so teuer war, bestand der ideale Renderer darin, zun√§chst die Objekte zu zeichnen, die dem Player am n√§chsten lagen, dann die Objekte unmittelbar dahinter usw., bis das Schreiben in jedes Pixel des Bildschirms abgeschlossen war.  Zu diesem Zeitpunkt h√§tte der Renderer verstehen m√ºssen, dass es Zeit zum Anhalten war, und so die Zeit sparen m√ºssen, die er zum Erkunden entfernter Objekte aufwenden konnte, die der Player nicht sah.  Die Anordnung von Szenenobjekten auf diese Weise, von der n√§chstgelegenen bis zur am weitesten entfernten, ist jedoch gleichbedeutend mit der L√∂sung des VSD-Problems.  Die Frage stellt sich erneut vor uns: Was kann ein Spieler sehen? <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HQYsFshbkYw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Zun√§chst versuchte Carmack, dieses Problem zu l√∂sen, indem er sich auf das <em>Doom-</em> Level-Schema st√ºtzte.  Sein Renderer zeichnete zun√§chst die W√§nde des Raums, in dem sich der Player befindet, und ging dann in benachbarte R√§ume √ºber, um W√§nde in diesen R√§umen zu zeichnen, die vom aktuellen Raum aus sichtbar sein k√∂nnten.  Wenn jeder Raum konvex w√§re, w√ºrde dies das VSD-Problem l√∂sen.  Nicht konvexe R√§ume k√∂nnten in konvexe ‚ÄûSektoren‚Äú unterteilt werden.  Wie diese Rendering-Technik wie eine starke Verlangsamung ausgesehen haben k√∂nnte, <a href="https://youtu.be/HQYsFshbkYw%3Ft%3D822">zeigt das oben gezeigte Video</a> , in dem ein YouTuber-Benutzer mit dem Spitznamen Bisqwit seinen eigenen Renderer demonstriert, der nach demselben allgemeinen Algorithmus arbeitet.  Dieser Algorithmus wurde erfolgreich im Duke Nukem 3D-Spiel verwendet, das drei Jahre nach <em>Doom ver√∂ffentlicht wurde</em> , als die Prozessoren leistungsf√§higer wurden.  Zu dieser Zeit hatte der <em>Doom-</em> Renderer, der diesen Algorithmus verwendete, 1993 Probleme mit komplexen Ebenen.  Dies war besonders offensichtlich, als die Sektoren ineinander gebaut wurden, und dies war die einzige M√∂glichkeit, zum Beispiel eine Wendeltreppe zu schaffen.  Wendeltreppen erforderten mehrere rekursive Abfahrten in den bereits eingezeichneten Bereich, was die Motordrehzahl drastisch verringerte. <br><br>  Etwa zur gleichen Zeit, als das ID-Team feststellte, dass die <em>Doom-</em> Engine m√∂glicherweise zu langsam ist, wurde ID-Software aufgefordert, <em>Wolfenstein 3D</em> auf Super Nintendo zu portieren.  SNES war sogar noch leistungsschw√§cher als die IBM-kompatiblen PCs der damaligen Zeit, und es stellte sich heraus, dass der <em>Wolfenstein-</em> Renderer mit Ray-Marching-Technologie trotz seiner Einfachheit nicht mit Super-Nintendo-Ger√§ten mit ausreichender Geschwindigkeit lief.  Aus diesem Grund suchte Carmack nach einem besseren Algorithmus.  Tats√§chlich untersuchte und implementierte Carmack f√ºr <em>Wolfensteins</em> Super-Nintendo-Port zun√§chst die Partitionierung des bin√§ren Raums.  In <em>Wolfenstein war</em> es ziemlich einfach, weil alle W√§nde parallel zu den Achsen waren;  <em>Untergang macht</em> es schwerer.  Aber Carmack erkannte, dass BSP-B√§ume auch in <em>Doom</em> Geschwindigkeitsprobleme l√∂sen w√ºrden. <br><br><h2>  Bin√§re Raumaufteilung </h2><br>  Die Bin√§rraumpartitionierung vereinfacht die L√∂sung des VSD-Problems, indem die 3D-Szene vorab aufgeteilt wird.  Im Moment reicht es f√ºr Sie, um zu verstehen, warum Partitionierung n√ºtzlich ist: Wenn Sie eine Linie (die eigentlich eine Ebene in 3D ist) durch die gesamte Szene ziehen und wissen, auf welcher Seite der Linie sich der Player oder die Kamera befindet, wissen wir auch, dass nichts ist Die andere Seite der Linie kann keine Objekte von der Seite der Linie abhalten, an der sich die Kamera befindet.  Wenn Sie den Vorgang mehrmals wiederholen, erhalten Sie eine 3D-Szene, die in viele Abschnitte unterteilt ist.  Dies ist keine Verbesserung gegen√ºber der urspr√ºnglichen Szene, au√üer dass wir jetzt mehr dar√ºber wissen, wie sich verschiedene Teile der Szene √ºberlappen k√∂nnen. <br><br>  Die ersten, die √ºber diese Einteilung der 3D-Szene berichteten, waren Forscher, die f√ºr die US Air Force herausfinden wollten, ob Computergrafiken f√ºr den Einsatz in Flugsimulatoren progressiv genug sind.  Ihre Ergebnisse ver√∂ffentlichten sie 1969 in einem Bericht mit dem Titel "Forschung zur Verwendung computergenerierter Bilder in der visuellen Simulation".  Der Bericht kam zu dem Schluss, dass Computergrafiken zur Ausbildung von Piloten verwendet werden k√∂nnen.  Gleichzeitig warnten die Forscher, dass die Implementierung des Systems durch die Aufgabe des VSD erschwert w√ºrde: <br><br><blockquote>  Eine der wichtigsten Aufgaben, die bei der Berechnung von Bildern in Echtzeit gel√∂st werden muss, ist die Priorit√§tsaufgabe oder versteckte Linien.  In unserer allt√§glichen visuellen Wahrnehmung der Welt um uns herum l√∂st die Natur dieses Problem mit trivialer Einfachheit.  Der Punkt eines undurchsichtigen Objekts √ºberlappt alle anderen Punkte, die entlang derselben Sichtlinie liegen und weiter entfernt sind.  Im Falle eines Computers ist diese Aufgabe sehr schwierig.  Der zur Bestimmung der Priorit√§t erforderliche Rechenaufwand nimmt im Allgemeinen mit zunehmender Komplexit√§t der Umgebung exponentiell zu und √ºbersteigt bald den Rechenaufwand, der mit der Suche nach Bildern von Objekten unter Ber√ºcksichtigung der Perspektive verbunden ist. </blockquote><br>  Eine von diesen Forschern erw√§hnte L√∂sung, von der sie sagten, dass sie zuvor in einem NASA-Projekt verwendet wurde, basiert auf der Schaffung einer sogenannten ‚Äû√úberlappungsmatrix‚Äú.  Die Forscher weisen darauf hin, dass eine Ebene, die eine Szene in zwei Teile unterteilt, verwendet werden kann, um "etwaige Priorit√§tenkonflikte" zwischen Objekten auf gegen√ºberliegenden Seiten der Ebene aufzul√∂sen.  Im Allgemeinen m√ºssen Sie diese Ebenen m√∂glicherweise explizit zur Szene hinzuf√ºgen. Bei einer bestimmten Struktur der Geometrie k√∂nnen Sie sich jedoch auf die vorhandenen Fl√§chen der Objekte verlassen.  Die Forscher demonstrieren das folgende Beispiel, in dem <em>p1</em> , <em>p2</em> und <em>p3</em> Oberfl√§chen teilen.  Befindet sich der Blickpunkt der Kamera auf der Vorderseite oder der ‚Äûwahren‚Äú Seite einer dieser Ebenen, ist <em>pi</em> 1. Die Matrix zeigt die Beziehung zwischen den drei Objekten in Abh√§ngigkeit von den drei Trennebenen und der Position des Blickpunkts der Kamera. Wenn Objekt <em>ai</em> Objekt <em>aj</em> √ºberlappt, dann Das Element <em>aij der</em> Matrix ist gleich 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/7b5/fda/d247b5fdab1c47b5772d3a3c922c1664.png"></div><br>  Forscher haben vorgeschlagen, diese Matrix in Hardware zu implementieren und sie in jedem Frame neu zu berechnen.  Tats√§chlich sollte die Matrix als gro√üer Schalter oder als eine Art eingebauter Z-Puffer fungieren.  Beim Rendern des aktuellen Objekts wird das Video nicht f√ºr Teile des Objekts ausgegeben, wenn sich 1 in der Objektspalte befindet, sondern das entsprechende Zeilenobjekt wird gezeichnet. <br><br>  Ein schwerwiegender Nachteil dieses Ansatzes besteht darin, dass eine Matrix der Gr√∂√üe <em>n <sup>2</sup></em> ben√∂tigt wird, um eine Szene mit <em>n</em> Objekten zu beschreiben.  Die Forscher beschlossen daher zu pr√ºfen, ob es m√∂glich ist, die √úberlappungsmatrix in Form einer ‚ÄûPriorit√§tenliste‚Äú darzustellen, die nur eine Gr√∂√üe von <em>n hat,</em> und die Reihenfolge anzugeben, in der Objekte gezeichnet werden sollen.  Sie stellten sofort fest, dass in bestimmten Szenen, beispielsweise in der oben gezeigten, die Reihenfolge nicht vollst√§ndig festgelegt werden kann (da es einen √úberlappungszyklus gibt), weshalb sie der mathematischen Definition von ‚Äûrichtigen‚Äú und ‚Äûfalschen‚Äú Szenen viel Zeit widmeten.  Am Ende kamen sie zu dem Schluss, dass zumindest f√ºr die ‚Äûrichtigen‚Äú Szenen (und der Szenendesigner kann leicht die ‚Äûfalschen‚Äú F√§lle vermeiden) eine Priorit√§tenliste erstellt werden kann.  Sie √ºberlie√üen die Listenerstellung jedoch dem Leser als √úbung.  Es scheint, dass der Hauptbeitrag dieser Arbeit von 1969 darin besteht, zumindest <em>theoretisch</em> die M√∂glichkeit aufzuzeigen, Teilungsebenen zu verwenden, um Objekte in der Szene anzuordnen. <br><br>  Und nur in einem Artikel von 1980 mit dem Titel ‚Äû√úber die Erzeugung sichtbarer Oberfl√§chen durch A-Priori-Baumstrukturen‚Äú wurde ein spezifischer Algorithmus daf√ºr demonstriert.  In diesem Artikel, der von Henry Fuchs, Zvi Kedem und Bruce Naylor verfasst wurde, wurde der BSP-Baum erstmals beschrieben.  Die Autoren sagen, ihre neue Datenstruktur sei "eine L√∂sung, ein alternativer Ansatz, der erstmals vor zehn Jahren verwendet wurde, aber aufgrund einiger weniger verbreiteter Schwierigkeiten" - und reagieren auf die Entscheidung, die sie 1969 in der Arbeit f√ºr die US-Luftwaffe getroffen haben.  Nachdem Sie einen BSP-Baum erstellt haben, k√∂nnen Sie auf einfache Weise Objekte mit Priorit√§t in der Szene organisieren. <br><br>  Fuchs, Kedem und Naylor lieferten eine ziemlich klare Beschreibung der Funktionsweise des BSP-Baums, aber ich werde versuchen, eine weniger formelle, aber kurze Beschreibung zu geben. <br><br>  Wir beginnen mit der Auswahl eines Polygons in der Szene und machen die Ebene, in der das Polygon liegt, zu einer Teilungsebene.  Dieses einzelne Polygon wird auch zum Wurzelknoten des Baums.  Die verbleibenden Polygone der Szene befinden sich auf der einen oder anderen Seite der Wurzelteilungsebene.  Polygone auf der "vorderen" Seite oder im "vorderen" Halbraum der Ebene erscheinen im linken Teilbaum des Wurzelknotens und Polygone auf der "hinteren" Seite oder im "hinteren" Halbraum der Ebene erscheinen im rechten Teilbaum.  Anschlie√üend wiederholen wir diesen Vorgang rekursiv und w√§hlen Polygone aus den linken und rechten Teilb√§umen als neue Trennfl√§chen f√ºr ihre eigenen Halbr√§ume aus, die weitere Halbr√§ume und Teilb√§ume erzeugen.  Der Prozess endet, wenn die Polygone enden. <br><br>  Nehmen wir an, wir m√∂chten die Geometrie der Szene von hinten nach vorne rendern. (  ¬´ ¬ª,   ,         ,    ,   .)   ,       BSP-;   ,      ,    ,      ‚Äî            .             ¬´¬ª  ,     ,     ¬´¬ª  . ¬´¬ª  ¬´¬ª      .    VSD,  ,      ,             . <br><br>        BSP-,   2D-.  2D      ,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f72/00b/aac/f7200baac3a914eb6fe62ca131b1e3cc.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/564/e28/9bf/564e289bf6d44182b3db68c8ad7178c0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/07a/f5a/63807af5af2f3bfa8c7ec73a81c36035.png"></div><br>    BSP-,  ,       ‚Äî  ,       .   ,   BSP-           . BSP-  ,     .   BSP-        ‚Äî         ,     . <br><br> ,    ,       ¬´¬ª BSP-.  BSP-   ,        .     ,      ,   ,    BSP ,       ,       ,   ‚Äî  .    ,   BSP-      . <br><br>  ,     1980 ,         1993  ¬´Constructing Good Partitioning Trees¬ª.       id Software  ,      ,   ,    BSP-  <em>Doom</em> . <br><br><h2> BSP-  <em>Doom</em> </h2><br> ,      <em>Doom</em>        ,      ,   ,   . BSP-       ,            ( ),    . <br><br>  ¬´ BSP-  <em>Doom</em> ¬ª      BSP-    <em>Doom</em> .     <em>Doom</em>     BSP-.    ,            11      <em>Doom</em> .       - ,    BSP        ¬´¬ª BSP-.          ,       ,   ,   BSP-  .  BSP-       ,      . <br><br>       BSP-,    1980 :   <em>Doom</em>   BSP-              ,   .   1980  ,    ,  BSP-          ,         ,      IBM- PC.   <em>Doom</em>       ,    .        BSP-,            .         ,  <em>Doom</em>     z-,      z-,      .   ,     ,    ,         .  <em>Doom</em>      z-,   <em>Doom</em> ,  ,     .       ,    <em>Doom</em>     :    ,      ,     ,     ,  , ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/23c/5de/a7423c5dead349917bd826ee3efa70b9.png"></div><br> <i><em>Doom II</em> ,   ,    .</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/82b/b4a/3a782bb4a5a2c4a44e5821c897239533.png"></div><br> <i>      .</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d0/0e4/443/3d00e4443a7e46c3418e11dac4eec839.png"></div><br> <em>    Quake</em> <br><br>     ‚Äî     <em>Doom</em>    ,    BSP-.   <em>Doom</em>     BSP-,    ; BSP-     .   <em>Doom</em>     ,  (        )  ,     .      ,       .     ,     BSP-,      ,  ,     . <br><br>  BSP-  <em>Doom</em>   . ,     ,  ,      BSP-.      <em></em> ? <br><br>  <a href="http://fabiensanglard.net/gebbdoom/">      <em>Doom</em></a>     , ,     ¬´Constructing Good Partitioning Trees¬ª      BSP-     3D-.   ,  ,         <em>Doom</em> ,    .     ,   ,     BSP-      ,    -       .       <em>Masters of Doom</em> :  ,        : ¬´    BSP-      3D-,     ?¬ª <br><br>     BSP-.      ,        ,     <em>  </em> ,         .        1980 . ,      ,  BSP-      ,             .       , BSP-     . ,        .                        1/30 . <br><br>         BSP-     . , ,  BSP-    ,    ‚Äî   .           ,   .  <a href="https://en.wikipedia.org/wiki/Binary_space_partitioning">   BSP-</a> ,      1991    ,     1990  <em>Computer Graphics: Principles and Practice</em> .      ,    .   1991           BSP-,       ,    <em>Doom</em> ,     ¬´ z-¬ª,        .      BSP-,        . (         1990 .)  <em>Computer Graphics: Principles and Practice</em>      ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6f/134/2a9/b6f1342a90a1ce11fafca1f265f65fda.png"></div><br> <i>    E1M1: Hangar.</i> <br><br>     ,      ‚Äî ¬´      ,     ,        ?¬ª ‚Äî   ,  ,  BSP- ‚Äî        .    ,    ,    ,  BSP-      ,       ,     . ,  ,    ,   <em>Doom</em>  ,    .       ,  ,        <em>Doom</em> ( <em>Game Engine Black Book: DOOM</em> ) ‚Äî           .    ,   VSD      ,         <em>Doom</em> .    ,   ,     ,   ,   .             . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482614/">https://habr.com/ru/post/de482614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482598/index.html">Gef√§lschte Fotos der Dyatlov-Gruppe</a></li>
<li><a href="../de482604/index.html">5 Charaktere der 1920er Jahre, die nach 100 Jahren in die Wolken aufstiegen</a></li>
<li><a href="../de482608/index.html">AMA mit Habr # 15. Neues Jahr und die k√ºrzeste Ver√∂ffentlichung! Chat</a></li>
<li><a href="../de482610/index.html">Starten Sie das transflektive TFT-Display auf der SSD1283A mit STM32</a></li>
<li><a href="../de482612/index.html">Touching Engineering Busi-Board, Neujahr und Freiwillige</a></li>
<li><a href="../de482616/index.html">Foreve Elon 2019/2020 (NY2020 Online-Meeting)</a></li>
<li><a href="../de482620/index.html">Slurm: Habr, sch√∂ne Ferien ...</a></li>
<li><a href="../de482626/index.html">√úberwachen von Anwendungen mit Logger.Backends</a></li>
<li><a href="../de482628/index.html">Schau "Kleine gr√ºne Spinne der Zeit"</a></li>
<li><a href="../de482634/index.html">Aber das Wesentliche ist etwas, oder das Minimieren des Quellcodes ist einfacher als es sich anh√∂rt.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>