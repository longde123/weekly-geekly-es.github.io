<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš¥ ğŸ˜œ ğŸ‹ Ist die Verwendung von BSP in Doom wirklich ein genialer Schritt? ğŸ§šğŸ½ ğŸ± â—½ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Gipfel der Technologie der Zeit. 

 1993 verÃ¶ffentlichte id Software Doom , einen Ego-Shooter, der sich schnell zu einem PhÃ¤nomen entwickelte. Heu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ist die Verwendung von BSP in Doom wirklich ein genialer Schritt?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482614/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/268/1a6/7cd/2681a67cd1d82d83879143c036a95ca4.jpg"></div><br>  <i>Der Gipfel der Technologie der Zeit.</i> <br><br>  1993 verÃ¶ffentlichte id Software <em>Doom</em> , einen Ego-Shooter, der sich schnell zu einem PhÃ¤nomen entwickelte.  Heute wird angenommen, dass dies eines der Spiele ist, die den grÃ¶ÃŸten Einfluss in der Geschichte hatten. <br><br>  Zehn Jahre nach der VerÃ¶ffentlichung von <em>Doom</em> verÃ¶ffentlichte der Journalist David Kouchner 2003 ein id-Software-Buch mit dem Titel <a rel="nofollow" href="https://www.amazon.com/dp/0812972155/%3Ftag%3Darstech20-20"><em>Masters of Doom</em></a> , das seitdem eine kanonische Beschreibung des <em>Doom-</em> Erstellungsprozesses darstellt.  Ich habe <em>Masters of Doom vor ein</em> paar Jahren gelesen und erinnere mich fast an nichts, aber eine Geschichte aus einem Buch Ã¼ber den Hauptprogrammierer John Carmack ist mir in Erinnerung geblieben.  Meine Beschreibung wird nicht ganz zutreffend sein (siehe unten fÃ¼r weitere Details), aber kurz gesagt, in der frÃ¼hen Phase der <em>Doom-</em> Entwicklung stellte Carmack fest, dass der 3D-Renderer, den er fÃ¼r das Spiel geschrieben hatte, beim Rendern bestimmter Ebenen langsamer wurde.  Dies war inakzeptabel, da <em>Doom</em> ein aktives und sogar hektisches Spiel werden musste.  Carmack erkannte, dass das Renderer-Problem so grundlegend war, dass er nach einem optimaleren Rendering-Algorithmus suchen musste, und begann, Forschungsartikel zu lesen.  Infolgedessen implementierte er eine Technik namens BSP (Binary Space Partitioning), die zuvor noch nie in Videospielen verwendet wurde, und beschleunigte damit die <em>Doom-</em> Engine erheblich. <br><br>  Diese Geschichte, wie Carmack die neuesten wissenschaftlichen Erkenntnisse auf Videospiele Ã¼bertragen hat, hat mich immer beeindruckt.  Meiner Meinung nach wurde Carmack so zu einer legendÃ¤ren Figur.  Er verdient es aus vielen GrÃ¼nden, als archetypischer brillanter Videospiel-Programmierer bekannt zu sein, aber als wichtigster erinnere ich mich immer an die Episode mit dem Lesen von wissenschaftlichen Artikeln und der binÃ¤ren Aufteilung des Raums. <br><a name="habracut"></a><br>  Offensichtlich ist diese Geschichte beeindruckend, denn der Begriff â€binÃ¤re Raumteilungâ€œ scheint nicht nur fÃ¼r die Implementierung, sondern auch fÃ¼r das VerstÃ¤ndnis etwas kompliziert zu sein.  Lange Zeit ging ich davon aus, dass Carmack einen intellektuellen Sprung nach vorne gemacht hatte, aber da ich nicht wusste, was eine binÃ¤re Raumaufteilung ist und wie neu diese Technik war, als Carmack sich entschied, sie zu verwenden, war ich mir nicht ganz sicher.  Wie genial war das HinzufÃ¼gen einer binÃ¤ren Raumpartition zu <em>Doom</em> auf einer Skala von Homer Simpson bis Albert Einstein? <br><br>  Ich fragte mich auch, woher die BSP kam und wie die Idee zu Carmack kam.  Daher wird dieser Beitrag nicht nur John Carmack und <em>Doom gewidmet</em> , sondern auch der Geschichte der Datenstruktur des "Binary Space Partition Tree" (oder BSP-Baums).  Es stellte sich heraus, dass der BSP-Baum, wie viele andere Aspekte der Computerwissenschaften, aus Forschungen fÃ¼r das MilitÃ¤r stammt. <br><br>  Ja, das stimmt: E1M1, das erste <em>Doom-</em> Level, ist dank der US Air Force erschienen. <br><br><h2>  VSD-Aufgabe </h2><br>  Der BSP-Baum ist eine LÃ¶sung fÃ¼r eine der schwierigsten Aufgaben in der Computergrafik.  Um eine dreidimensionale Szene zu rendern, muss der Renderer bestimmen, was vom aktuellen Punkt aus sichtbar und was nicht sichtbar ist.  Dies ist nicht besonders schwierig, wenn Sie viel Zeit haben. Eine sich selbst respektierende Echtzeit-Game-Engine sollte jedoch mindestens 30 Mal pro Sekunde die sichtbaren und unsichtbaren Teile der Welt bestimmen. <br><br>  Diese Aufgabe wird hÃ¤ufig als VSD-Aufgabe (Visible Surface Determination) bezeichnet.  Der Programmierer Michael Abrash, der mit Carmack on <em>Quake</em> (dem nÃ¤chsten id-Software-Spiel nach <em>Doom</em> ) zusammengearbeitet hat, schrieb in seinem berÃ¼hmten Buch <a href="http://www.jagregory.com/abrash-black-book/"><em>Graphics Programming Black Book</em></a> Ã¼ber die VSD-Aufgabe: <br><br><blockquote>  Ich mÃ¶chte Ã¼ber die meiner Meinung nach schwierigste Aufgabe der 3D-Grafik sprechen: das Bestimmen der sichtbaren FlÃ¤chen (Zeichnen der gewÃ¼nschten FlÃ¤che in jedem Pixel) und deren enger Verwandter - die Aufgabe des Keulens (so schnell wie mÃ¶glich unsichtbare Polygone werfen, um die Bestimmung der sichtbaren FlÃ¤chen zu beschleunigen).  Der KÃ¼rze halber bezeichne ich mit der AbkÃ¼rzung VSD sowohl die Definition von sichtbaren OberflÃ¤chen als auch das Beschneiden. <br><br>  Warum halte ich VSD fÃ¼r die schwierigste 3D-Aufgabe?  Obwohl Rasterungsprobleme wie die Texturabbildung ebenfalls erstaunliche und wichtige Aufgaben sind, handelt es sich hierbei um Aufgaben von relativ begrenztem Umfang, deren LÃ¶sung sich auf das Auftreten von 3D-Beschleunigern auf GerÃ¤ten verlagert.  AuÃŸerdem skalieren sie nur, wenn die BildschirmauflÃ¶sung erhÃ¶ht wird, was durchaus ertrÃ¤glich ist. <br><br>  Im Gegensatz dazu ist VSD eine unbegrenzte Aufgabe, und jetzt werden Dutzende von LÃ¶sungen verwendet, um sie zu lÃ¶sen.  Noch wichtiger ist, dass die naive Leistung von VSD direkt mit der KomplexitÃ¤t der Szene skaliert, die normalerweise als quadratische oder kubische Funktion zunimmt, sodass sie schnell zum begrenzenden Faktor fÃ¼r die Wiedergabe realistischer Welten wird. </blockquote><br>  Abrash schrieb Ã¼ber die KomplexitÃ¤t des VSD-Problems in den spÃ¤ten 90ern, ein paar Jahre nachdem <em>Doom</em> bewiesen hatte, dass normale Leute in der Lage sein mÃ¶chten, grafisch anspruchsvolle Spiele auf ihren Heimcomputern zu spielen.  In den frÃ¼hen 90er Jahren, als id Software gerade mit der VerÃ¶ffentlichung von Spielen begann, mussten sie effektiv auf ungeeigneten Computern arbeiten: Heimcomputer wurden fÃ¼r die Arbeit mit Text, Tabellenkalkulationen und Ã¤hnlichen Anwendungen entwickelt.  Um dieses Ziel zu erreichen, musste sich das Unternehmen der Fiktion nÃ¤hern, insbesondere im Fall mehrerer 3D-Spiele, die von id Software vor <em>Doom verÃ¶ffentlicht wurden</em> .  In diesen Spielen wurde das Design aller Level so eingeschrÃ¤nkt, dass die LÃ¶sung des VSD-Problems vereinfacht wurde. <br><br>  Zum Beispiel bestand in <em>Wolfenstein 3D</em> , dem Spiel, das id Software kurz vor <em>Doom herausbrachte</em> , jede Ebene aus WÃ¤nden, die entlang der Achsen ausgerichtet waren.  Mit anderen Worten, im Wolfenstein-Universum kÃ¶nnte es Nord- / SÃ¼dwÃ¤nde oder Ost- / WestwÃ¤nde geben, und keine anderen.  DarÃ¼ber hinaus kÃ¶nnen WÃ¤nde in festen AbstÃ¤nden im Raster platziert werden. Alle Korridore haben eine Breite von entweder einer oder zwei Rasterzellen usw., jedoch niemals von 2,5 Zellen.  Obwohl dies bedeutete, dass das Team von id Software nahezu gleich aussehende Ebenen erstellen konnte, machte es diese EinschrÃ¤nkung Carmack sehr leicht, einen Renderer fÃ¼r <em>Wolfenstein</em> zu schreiben. <br><br>  <em>Der Wolfenstein-</em> Renderer lÃ¶ste das Problem der VSD, indem er Strahlen (Ray Marching) vom Bildschirm in die virtuelle Welt bewegte.  Ray-Renderer sind in der Regel Raycasting-Renderer - sie sind hÃ¤ufig langsam, da zur LÃ¶sung des VSD-Problems in Raycaster der erste Schnittpunkt zwischen dem Strahl und einem Objekt auf der Welt gesucht werden muss, der viel Rechenaufwand erfordert.  Da jedoch alle WÃ¤nde in <em>Wolfenstein</em> mit einem Gitter ausgekleidet sind, sind die Gitterlinien die einzigen Stellen, an denen ein Balken die Wand Ã¼berqueren kann.  Daher reicht es aus, wenn der Renderer jeden dieser Schnittpunkte Ã¼berprÃ¼ft.  Wenn der Renderer zunÃ¤chst den Schnittpunkt Ã¼berprÃ¼ft, der dem Ansichtspunkt des Players am nÃ¤chsten liegt, dann den zweiten in der NÃ¤he usw. und endet, wenn er auf die erste Wand trifft, ist das VSD-Problem auf die trivialste Weise gelÃ¶st.  Der Strahl bewegte sich einfach von jedem Pixel vorwÃ¤rts, bis er auf etwas stieÃŸ, was in Bezug auf die Prozessortaktraten sehr kostengÃ¼nstig ist.  Und da alle WÃ¤nde die gleiche HÃ¶he haben, reicht es aus, dass wir fÃ¼r jede Pixelspalte Strahlen aussenden. <br><br>  Diese Vereinfachung des Renderns machte <em>Wolfenstein</em> schnell genug, um auf schwachen Heim-PCs jener Zeit zu arbeiten, als es noch keine speziellen Grafikkarten gab.  Ein solcher Ansatz wÃ¼rde in <em>Doom</em> jedoch nicht funktionieren, da das ID-Team beschlossen hat, dass es in seinem neuen Spiel so neue Elemente wie diagonale WÃ¤nde, Treppen und Decken mit unterschiedlichen HÃ¶hen geben wird.  Ray Marschieren war nicht mehr geeignet, also schrieb Carmack eine andere Art von Renderer.  Der <em>Wolfenstein-</em> Renderer, bei dem der Strahl fÃ¼r jede Pixelspalte verwendet wurde, wurde vom Bild abgestoÃŸen, und der <em>Doom-</em> Renderer sollte von Objekten abgestoÃŸen werden.  Dies bedeutete, dass der <em>Doom-</em> Renderer, anstatt die Bildschirmpixel zu durchlaufen und ihre Farbe zu bestimmen, Ã¼ber Objekte in der Szene iterieren und diese nacheinander auf den Bildschirm projizieren musste. <br><br>  In einem solchen Renderer besteht eine einfache MÃ¶glichkeit, das VSD-Problem zu lÃ¶sen, in der Verwendung eines Z-Puffers.  Jedes Mal, wenn wir ein Objekt auf den Bildschirm projizieren, wird fÃ¼r jedes Pixel, das wir zeichnen mÃ¶chten, eine ÃœberprÃ¼fung durchgefÃ¼hrt.  Befindet sich der zu zeichnende Teil des Objekts nÃ¤her am Player als das bereits im Pixel gezeichnete Objekt, kÃ¶nnen wir seine Informationen umschreiben.  Andernfalls mÃ¼ssen Sie das Pixel unverÃ¤ndert lassen.  Dieser Ansatz ist einfach, aber der Z-Buffer benÃ¶tigt viel Speicher und der Renderer kann immer noch eine Reihe von Prozessortakten fÃ¼r die Projektion von Ebenengeometrien ausgeben, die der Player nicht sieht. <br><br>  Anfang der neunziger Jahre hatte die Z-Buffer-LÃ¶sung einen weiteren Nachteil: Auf IBM-kompatiblen PCs mit einem Videoadaptersystem namens VGA war das Schreiben in den Ausgabebildpuffer ein kostspieliger Vorgang.  Die fÃ¼r das Rendern von Pixeln aufgewendete Zeit, die dann einfach Ã¼berschrieben wird, hat die Leistung des Renderers erheblich verringert. <br><br>  Da das Schreiben in den Einzelbildpuffer so teuer war, bestand der ideale Renderer darin, zunÃ¤chst die Objekte zu zeichnen, die dem Player am nÃ¤chsten lagen, dann die Objekte unmittelbar dahinter usw., bis das Schreiben in jedes Pixel des Bildschirms abgeschlossen war.  Zu diesem Zeitpunkt hÃ¤tte der Renderer verstehen mÃ¼ssen, dass es Zeit zum Anhalten war, und so die Zeit sparen mÃ¼ssen, die er zum Erkunden entfernter Objekte aufwenden konnte, die der Player nicht sah.  Die Anordnung von Szenenobjekten auf diese Weise, von der nÃ¤chstgelegenen bis zur am weitesten entfernten, ist jedoch gleichbedeutend mit der LÃ¶sung des VSD-Problems.  Die Frage stellt sich erneut vor uns: Was kann ein Spieler sehen? <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HQYsFshbkYw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  ZunÃ¤chst versuchte Carmack, dieses Problem zu lÃ¶sen, indem er sich auf das <em>Doom-</em> Level-Schema stÃ¼tzte.  Sein Renderer zeichnete zunÃ¤chst die WÃ¤nde des Raums, in dem sich der Player befindet, und ging dann in benachbarte RÃ¤ume Ã¼ber, um WÃ¤nde in diesen RÃ¤umen zu zeichnen, die vom aktuellen Raum aus sichtbar sein kÃ¶nnten.  Wenn jeder Raum konvex wÃ¤re, wÃ¼rde dies das VSD-Problem lÃ¶sen.  Nicht konvexe RÃ¤ume kÃ¶nnten in konvexe â€Sektorenâ€œ unterteilt werden.  Wie diese Rendering-Technik wie eine starke Verlangsamung ausgesehen haben kÃ¶nnte, <a href="https://youtu.be/HQYsFshbkYw%3Ft%3D822">zeigt das oben gezeigte Video</a> , in dem ein YouTuber-Benutzer mit dem Spitznamen Bisqwit seinen eigenen Renderer demonstriert, der nach demselben allgemeinen Algorithmus arbeitet.  Dieser Algorithmus wurde erfolgreich im Duke Nukem 3D-Spiel verwendet, das drei Jahre nach <em>Doom verÃ¶ffentlicht wurde</em> , als die Prozessoren leistungsfÃ¤higer wurden.  Zu dieser Zeit hatte der <em>Doom-</em> Renderer, der diesen Algorithmus verwendete, 1993 Probleme mit komplexen Ebenen.  Dies war besonders offensichtlich, als die Sektoren ineinander gebaut wurden, und dies war die einzige MÃ¶glichkeit, zum Beispiel eine Wendeltreppe zu schaffen.  Wendeltreppen erforderten mehrere rekursive Abfahrten in den bereits eingezeichneten Bereich, was die Motordrehzahl drastisch verringerte. <br><br>  Etwa zur gleichen Zeit, als das ID-Team feststellte, dass die <em>Doom-</em> Engine mÃ¶glicherweise zu langsam ist, wurde ID-Software aufgefordert, <em>Wolfenstein 3D</em> auf Super Nintendo zu portieren.  SNES war sogar noch leistungsschwÃ¤cher als die IBM-kompatiblen PCs der damaligen Zeit, und es stellte sich heraus, dass der <em>Wolfenstein-</em> Renderer mit Ray-Marching-Technologie trotz seiner Einfachheit nicht mit Super-Nintendo-GerÃ¤ten mit ausreichender Geschwindigkeit lief.  Aus diesem Grund suchte Carmack nach einem besseren Algorithmus.  TatsÃ¤chlich untersuchte und implementierte Carmack fÃ¼r <em>Wolfensteins</em> Super-Nintendo-Port zunÃ¤chst die Partitionierung des binÃ¤ren Raums.  In <em>Wolfenstein war</em> es ziemlich einfach, weil alle WÃ¤nde parallel zu den Achsen waren;  <em>Untergang macht</em> es schwerer.  Aber Carmack erkannte, dass BSP-BÃ¤ume auch in <em>Doom</em> Geschwindigkeitsprobleme lÃ¶sen wÃ¼rden. <br><br><h2>  BinÃ¤re Raumaufteilung </h2><br>  Die BinÃ¤rraumpartitionierung vereinfacht die LÃ¶sung des VSD-Problems, indem die 3D-Szene vorab aufgeteilt wird.  Im Moment reicht es fÃ¼r Sie, um zu verstehen, warum Partitionierung nÃ¼tzlich ist: Wenn Sie eine Linie (die eigentlich eine Ebene in 3D ist) durch die gesamte Szene ziehen und wissen, auf welcher Seite der Linie sich der Player oder die Kamera befindet, wissen wir auch, dass nichts ist Die andere Seite der Linie kann keine Objekte von der Seite der Linie abhalten, an der sich die Kamera befindet.  Wenn Sie den Vorgang mehrmals wiederholen, erhalten Sie eine 3D-Szene, die in viele Abschnitte unterteilt ist.  Dies ist keine Verbesserung gegenÃ¼ber der ursprÃ¼nglichen Szene, auÃŸer dass wir jetzt mehr darÃ¼ber wissen, wie sich verschiedene Teile der Szene Ã¼berlappen kÃ¶nnen. <br><br>  Die ersten, die Ã¼ber diese Einteilung der 3D-Szene berichteten, waren Forscher, die fÃ¼r die US Air Force herausfinden wollten, ob Computergrafiken fÃ¼r den Einsatz in Flugsimulatoren progressiv genug sind.  Ihre Ergebnisse verÃ¶ffentlichten sie 1969 in einem Bericht mit dem Titel "Forschung zur Verwendung computergenerierter Bilder in der visuellen Simulation".  Der Bericht kam zu dem Schluss, dass Computergrafiken zur Ausbildung von Piloten verwendet werden kÃ¶nnen.  Gleichzeitig warnten die Forscher, dass die Implementierung des Systems durch die Aufgabe des VSD erschwert wÃ¼rde: <br><br><blockquote>  Eine der wichtigsten Aufgaben, die bei der Berechnung von Bildern in Echtzeit gelÃ¶st werden muss, ist die PrioritÃ¤tsaufgabe oder versteckte Linien.  In unserer alltÃ¤glichen visuellen Wahrnehmung der Welt um uns herum lÃ¶st die Natur dieses Problem mit trivialer Einfachheit.  Der Punkt eines undurchsichtigen Objekts Ã¼berlappt alle anderen Punkte, die entlang derselben Sichtlinie liegen und weiter entfernt sind.  Im Falle eines Computers ist diese Aufgabe sehr schwierig.  Der zur Bestimmung der PrioritÃ¤t erforderliche Rechenaufwand nimmt im Allgemeinen mit zunehmender KomplexitÃ¤t der Umgebung exponentiell zu und Ã¼bersteigt bald den Rechenaufwand, der mit der Suche nach Bildern von Objekten unter BerÃ¼cksichtigung der Perspektive verbunden ist. </blockquote><br>  Eine von diesen Forschern erwÃ¤hnte LÃ¶sung, von der sie sagten, dass sie zuvor in einem NASA-Projekt verwendet wurde, basiert auf der Schaffung einer sogenannten â€Ãœberlappungsmatrixâ€œ.  Die Forscher weisen darauf hin, dass eine Ebene, die eine Szene in zwei Teile unterteilt, verwendet werden kann, um "etwaige PrioritÃ¤tenkonflikte" zwischen Objekten auf gegenÃ¼berliegenden Seiten der Ebene aufzulÃ¶sen.  Im Allgemeinen mÃ¼ssen Sie diese Ebenen mÃ¶glicherweise explizit zur Szene hinzufÃ¼gen. Bei einer bestimmten Struktur der Geometrie kÃ¶nnen Sie sich jedoch auf die vorhandenen FlÃ¤chen der Objekte verlassen.  Die Forscher demonstrieren das folgende Beispiel, in dem <em>p1</em> , <em>p2</em> und <em>p3</em> OberflÃ¤chen teilen.  Befindet sich der Blickpunkt der Kamera auf der Vorderseite oder der â€wahrenâ€œ Seite einer dieser Ebenen, ist <em>pi</em> 1. Die Matrix zeigt die Beziehung zwischen den drei Objekten in AbhÃ¤ngigkeit von den drei Trennebenen und der Position des Blickpunkts der Kamera. Wenn Objekt <em>ai</em> Objekt <em>aj</em> Ã¼berlappt, dann Das Element <em>aij der</em> Matrix ist gleich 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/7b5/fda/d247b5fdab1c47b5772d3a3c922c1664.png"></div><br>  Forscher haben vorgeschlagen, diese Matrix in Hardware zu implementieren und sie in jedem Frame neu zu berechnen.  TatsÃ¤chlich sollte die Matrix als groÃŸer Schalter oder als eine Art eingebauter Z-Puffer fungieren.  Beim Rendern des aktuellen Objekts wird das Video nicht fÃ¼r Teile des Objekts ausgegeben, wenn sich 1 in der Objektspalte befindet, sondern das entsprechende Zeilenobjekt wird gezeichnet. <br><br>  Ein schwerwiegender Nachteil dieses Ansatzes besteht darin, dass eine Matrix der GrÃ¶ÃŸe <em>n <sup>2</sup></em> benÃ¶tigt wird, um eine Szene mit <em>n</em> Objekten zu beschreiben.  Die Forscher beschlossen daher zu prÃ¼fen, ob es mÃ¶glich ist, die Ãœberlappungsmatrix in Form einer â€PrioritÃ¤tenlisteâ€œ darzustellen, die nur eine GrÃ¶ÃŸe von <em>n hat,</em> und die Reihenfolge anzugeben, in der Objekte gezeichnet werden sollen.  Sie stellten sofort fest, dass in bestimmten Szenen, beispielsweise in der oben gezeigten, die Reihenfolge nicht vollstÃ¤ndig festgelegt werden kann (da es einen Ãœberlappungszyklus gibt), weshalb sie der mathematischen Definition von â€richtigenâ€œ und â€falschenâ€œ Szenen viel Zeit widmeten.  Am Ende kamen sie zu dem Schluss, dass zumindest fÃ¼r die â€richtigenâ€œ Szenen (und der Szenendesigner kann leicht die â€falschenâ€œ FÃ¤lle vermeiden) eine PrioritÃ¤tenliste erstellt werden kann.  Sie Ã¼berlieÃŸen die Listenerstellung jedoch dem Leser als Ãœbung.  Es scheint, dass der Hauptbeitrag dieser Arbeit von 1969 darin besteht, zumindest <em>theoretisch</em> die MÃ¶glichkeit aufzuzeigen, Teilungsebenen zu verwenden, um Objekte in der Szene anzuordnen. <br><br>  Und nur in einem Artikel von 1980 mit dem Titel â€Ãœber die Erzeugung sichtbarer OberflÃ¤chen durch A-Priori-Baumstrukturenâ€œ wurde ein spezifischer Algorithmus dafÃ¼r demonstriert.  In diesem Artikel, der von Henry Fuchs, Zvi Kedem und Bruce Naylor verfasst wurde, wurde der BSP-Baum erstmals beschrieben.  Die Autoren sagen, ihre neue Datenstruktur sei "eine LÃ¶sung, ein alternativer Ansatz, der erstmals vor zehn Jahren verwendet wurde, aber aufgrund einiger weniger verbreiteter Schwierigkeiten" - und reagieren auf die Entscheidung, die sie 1969 in der Arbeit fÃ¼r die US-Luftwaffe getroffen haben.  Nachdem Sie einen BSP-Baum erstellt haben, kÃ¶nnen Sie auf einfache Weise Objekte mit PrioritÃ¤t in der Szene organisieren. <br><br>  Fuchs, Kedem und Naylor lieferten eine ziemlich klare Beschreibung der Funktionsweise des BSP-Baums, aber ich werde versuchen, eine weniger formelle, aber kurze Beschreibung zu geben. <br><br>  Wir beginnen mit der Auswahl eines Polygons in der Szene und machen die Ebene, in der das Polygon liegt, zu einer Teilungsebene.  Dieses einzelne Polygon wird auch zum Wurzelknoten des Baums.  Die verbleibenden Polygone der Szene befinden sich auf der einen oder anderen Seite der Wurzelteilungsebene.  Polygone auf der "vorderen" Seite oder im "vorderen" Halbraum der Ebene erscheinen im linken Teilbaum des Wurzelknotens und Polygone auf der "hinteren" Seite oder im "hinteren" Halbraum der Ebene erscheinen im rechten Teilbaum.  AnschlieÃŸend wiederholen wir diesen Vorgang rekursiv und wÃ¤hlen Polygone aus den linken und rechten TeilbÃ¤umen als neue TrennflÃ¤chen fÃ¼r ihre eigenen HalbrÃ¤ume aus, die weitere HalbrÃ¤ume und TeilbÃ¤ume erzeugen.  Der Prozess endet, wenn die Polygone enden. <br><br>  Nehmen wir an, wir mÃ¶chten die Geometrie der Szene von hinten nach vorne rendern. (  Â« Â»,   ,         ,    ,   .)   ,       BSP-;   ,      ,    ,      â€”            .             Â«Â»  ,     ,     Â«Â»  . Â«Â»  Â«Â»      .    VSD,  ,      ,             . <br><br>        BSP-,   2D-.  2D      ,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f72/00b/aac/f7200baac3a914eb6fe62ca131b1e3cc.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/564/e28/9bf/564e289bf6d44182b3db68c8ad7178c0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/07a/f5a/63807af5af2f3bfa8c7ec73a81c36035.png"></div><br>    BSP-,  ,       â€”  ,       .   ,   BSP-           . BSP-  ,     .   BSP-        â€”         ,     . <br><br> ,    ,       Â«Â» BSP-.  BSP-   ,        .     ,      ,   ,    BSP ,       ,       ,   â€”  .    ,   BSP-      . <br><br>  ,     1980 ,         1993  Â«Constructing Good Partitioning TreesÂ».       id Software  ,      ,   ,    BSP-  <em>Doom</em> . <br><br><h2> BSP-  <em>Doom</em> </h2><br> ,      <em>Doom</em>        ,      ,   ,   . BSP-       ,            ( ),    . <br><br>  Â« BSP-  <em>Doom</em> Â»      BSP-    <em>Doom</em> .     <em>Doom</em>     BSP-.    ,            11      <em>Doom</em> .       - ,    BSP        Â«Â» BSP-.          ,       ,   ,   BSP-  .  BSP-       ,      . <br><br>       BSP-,    1980 :   <em>Doom</em>   BSP-              ,   .   1980  ,    ,  BSP-          ,         ,      IBM- PC.   <em>Doom</em>       ,    .        BSP-,            .         ,  <em>Doom</em>     z-,      z-,      .   ,     ,    ,         .  <em>Doom</em>      z-,   <em>Doom</em> ,  ,     .       ,    <em>Doom</em>     :    ,      ,     ,     ,  , ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/23c/5de/a7423c5dead349917bd826ee3efa70b9.png"></div><br> <i><em>Doom II</em> ,   ,    .</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/82b/b4a/3a782bb4a5a2c4a44e5821c897239533.png"></div><br> <i>      .</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d0/0e4/443/3d00e4443a7e46c3418e11dac4eec839.png"></div><br> <em>    Quake</em> <br><br>     â€”     <em>Doom</em>    ,    BSP-.   <em>Doom</em>     BSP-,    ; BSP-     .   <em>Doom</em>     ,  (        )  ,     .      ,       .     ,     BSP-,      ,  ,     . <br><br>  BSP-  <em>Doom</em>   . ,     ,  ,      BSP-.      <em></em> ? <br><br>  <a href="http://fabiensanglard.net/gebbdoom/">      <em>Doom</em></a>     , ,     Â«Constructing Good Partitioning TreesÂ»      BSP-     3D-.   ,  ,         <em>Doom</em> ,    .     ,   ,     BSP-      ,    -       .       <em>Masters of Doom</em> :  ,        : Â«    BSP-      3D-,     ?Â» <br><br>     BSP-.      ,        ,     <em>  </em> ,         .        1980 . ,      ,  BSP-      ,             .       , BSP-     . ,        .                        1/30 . <br><br>         BSP-     . , ,  BSP-    ,    â€”   .           ,   .  <a href="https://en.wikipedia.org/wiki/Binary_space_partitioning">   BSP-</a> ,      1991    ,     1990  <em>Computer Graphics: Principles and Practice</em> .      ,    .   1991           BSP-,       ,    <em>Doom</em> ,     Â« z-Â»,        .      BSP-,        . (         1990 .)  <em>Computer Graphics: Principles and Practice</em>      ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6f/134/2a9/b6f1342a90a1ce11fafca1f265f65fda.png"></div><br> <i>    E1M1: Hangar.</i> <br><br>     ,      â€” Â«      ,     ,        ?Â» â€”   ,  ,  BSP- â€”        .    ,    ,    ,  BSP-      ,       ,     . ,  ,    ,   <em>Doom</em>  ,    .       ,  ,        <em>Doom</em> ( <em>Game Engine Black Book: DOOM</em> ) â€”           .    ,   VSD      ,         <em>Doom</em> .    ,   ,     ,   ,   .             . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482614/">https://habr.com/ru/post/de482614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482598/index.html">GefÃ¤lschte Fotos der Dyatlov-Gruppe</a></li>
<li><a href="../de482604/index.html">5 Charaktere der 1920er Jahre, die nach 100 Jahren in die Wolken aufstiegen</a></li>
<li><a href="../de482608/index.html">AMA mit Habr # 15. Neues Jahr und die kÃ¼rzeste VerÃ¶ffentlichung! Chat</a></li>
<li><a href="../de482610/index.html">Starten Sie das transflektive TFT-Display auf der SSD1283A mit STM32</a></li>
<li><a href="../de482612/index.html">Touching Engineering Busi-Board, Neujahr und Freiwillige</a></li>
<li><a href="../de482616/index.html">Foreve Elon 2019/2020 (NY2020 Online-Meeting)</a></li>
<li><a href="../de482620/index.html">Slurm: Habr, schÃ¶ne Ferien ...</a></li>
<li><a href="../de482626/index.html">Ãœberwachen von Anwendungen mit Logger.Backends</a></li>
<li><a href="../de482628/index.html">Schau "Kleine grÃ¼ne Spinne der Zeit"</a></li>
<li><a href="../de482634/index.html">Aber das Wesentliche ist etwas, oder das Minimieren des Quellcodes ist einfacher als es sich anhÃ¶rt.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>