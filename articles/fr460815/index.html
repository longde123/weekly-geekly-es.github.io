<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÜüèΩ üêü ‚ò¢Ô∏è Inventer la biblioth√®que vusb üëßüèø üïß üôéüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 


 Apr√®s avoir lu le titre, une question logique peut se poser: pourquoi √©tudier aujourd'hui l'impl√©mentation logicielle de l'USB bas d√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inventer la biblioth√®que vusb</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460815/"><h2 id="vvedenie">  Pr√©sentation </h2><br><p>  Apr√®s avoir lu le titre, une question logique peut se poser: pourquoi √©tudier aujourd'hui l'impl√©mentation logicielle de l'USB bas d√©bit alors qu'il existe un tas de contr√¥leurs bon march√© avec un module mat√©riel?  Le fait est que le module mat√©riel, cachant le niveau d'√©change des niveaux logiques, transforme le protocole USB en une sorte de magie.  Pour ressentir le fonctionnement de cette ¬´magie¬ª, rien de mieux que de la reproduire √† partir de z√©ro, √† partir du niveau le plus bas. </p><br><p>  √Ä cette fin, nous allons essayer de fabriquer un appareil pr√©tendant √™tre USB-HID bas√© sur le contr√¥leur ATmega8.  Contrairement √† la litt√©rature r√©pandue, nous n'irons pas de la th√©orie √† la pratique, du niveau le plus bas au plus √©lev√©, des tensions logiques aux conclusions, et nous terminerons par l '¬´invention¬ª de la m√™me vusb, apr√®s chaque √©tape v√©rifiant si le code fonctionne comme pr√©vu.  S√©par√©ment, je note que je n'invente pas d'alternative √† cette biblioth√®que, mais plut√¥t, je reproduis constamment son code source, en pr√©servant autant que possible la structure et les noms d'origine, expliquant pourquoi telle ou telle section sert.  Cependant, mon style habituel d'√©criture de code est diff√©rent du style des auteurs vusb.  Imm√©diatement, j'avoue honn√™tement qu'en plus de l'int√©r√™t altruiste (pour raconter un sujet difficile aux autres), j'ai aussi un int√©r√™t √©go√Øste - √©tudier le sujet par moi-m√™me et attraper un maximum de points subtils pour moi-m√™me.  Il s'ensuit √©galement qu'un point important peut √™tre manqu√© ou qu'un sujet n'est pas enti√®rement divulgu√©. </p><br><p>  Pour une meilleure compr√©hension du code, j'ai essay√© de mettre en √©vidence les sections modifi√©es avec des commentaires et de les supprimer des sections discut√©es pr√©c√©demment.  En fait, le code source sera la principale source d'information, et le texte expliquera ce qui a √©t√© fait et pourquoi, ainsi que le r√©sultat attendu. </p><br><p>  Je note √©galement que seul l'USB √† bas d√©bit est pris en compte, m√™me sans mentionner, ce qui distingue les vari√©t√©s les plus rapides. </p><a name="habracut"></a><br><h2 id="shag-0-zhelezo-i-prochaya-podgotovka">  √âtape 0. Fer et autres pr√©parations </h2><br><p>  Comme test, prenons une carte de d√©bogage maison bas√©e sur ATmega8 avec du quartz 12 MHz.  Je ne donnerai pas le sch√©ma, il est assez standard (voir le site officiel vusb), la seule chose qui m√©rite d'√™tre mentionn√©e est les conclusions utilis√©es.  Dans mon cas, la sortie D + correspond √† PD2, la sortie D-PD3, et la bretelle se bloque sur PD4.  En principe, une r√©sistance de rappel pourrait √™tre connect√©e √† l'alimentation, mais le contr√¥le manuel semble un peu plus conforme √† la norme. </p><br><p>  Une alimentation de 5 V est fournie par le connecteur USB, cependant, on ne s'attend pas √† plus de 3,6 V sur les lignes de signal (pourquoi √©tait-ce un myst√®re pour moi).  Vous devez donc soit r√©duire la puissance du contr√¥leur, soit placer les diodes zener sur les lignes de signal.  J'ai choisi la deuxi√®me option, mais dans l'ensemble, cela n'a pas d'importance. </p><br><p>  Puisque nous ¬´inventons¬ª l'impl√©mentation, il serait agr√©able de voir ce qui se passe dans le cerveau du contr√¥leur, c'est-√†-dire qu'au moins une sorte d'informations de d√©bogage est n√©cessaire.  Dans mon cas, ce sont deux LED sur PD6, PD7 et, surtout, UART sur PD0, PD1, configur√©es sur 115200, afin que vous puissiez √©couter le bavardage du contr√¥leur via un √©cran normal ou un autre programme pour travailler avec le port COM: </p><br><pre><code class="bash hljs">$ screen /dev/ttyUSB0 115200</code> </pre> <br><p>  De plus, un wirehark avec le module appropri√© se r√©v√©lera √™tre un utilitaire utile pour le d√©bogage USB (il ne d√©marre pas toujours √† partir de la bo√Æte, mais la r√©solution de ces probl√®mes se trouve assez bien sur Internet et ce n'est pas la t√¢che de cet article). </p><br><p>  Ici, il serait possible de d√©penser un autre kilo-octet de texte pour la description du programmeur, des makefiles et d'autres choses, mais cela n'a gu√®re de sens.  De m√™me, je ne me concentrerai pas sur les param√®tres p√©riph√©riques qui ne sont pas li√©s √† l'USB.  Si quelqu'un ne peut m√™me pas comprendre cela, est-il trop t√¥t pour entrer dans les entrailles du logiciel USB? </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le code source de toutes les √©tapes est disponible sur Github.</a> </p><br><h2 id="shag-1-prinimaem-hot-chto-to">  √âtape 1. Acceptez au moins quelque chose </h2><br><p>  Selon la documentation, l'USB prend en charge plusieurs vitesses fixes, dont l'AVR ne tirera que le plus bas: 1,5 m√©gabits par seconde.  Elle est d√©termin√©e par la r√©sistance de rappel et la communication ult√©rieure.  Pour notre fr√©quence choisie, la r√©sistance doit connecter D- avec une alimentation de 3,3 V et avoir une valeur nominale de 1,5 kOhm, mais en pratique, elle peut √™tre connect√©e avec +5 V et la valeur nominale peut varier l√©g√®rement.  Avec une fr√©quence de contr√¥leur de 12 MHz, seulement 8 cycles d'horloge par bit.  Il est clair qu'une telle pr√©cision et vitesse ne sont r√©alisables que dans l'assembleur, nous allons donc ouvrir le fichier drvasm.S.  Cela implique √©galement la n√©cessit√© d'utiliser une interruption pour intercepter le d√©but d'un octet.  Je suis heureux que le premier octet transmis via USB soit toujours le m√™me, SYNC, donc si vous arrivez au d√©but, √ßa va.  Par cons√©quent, du d√©but de l'octet √† sa fin, seuls 64 cycles de contr√¥leur passent (en fait, la marge est encore plus petite), vous ne devez donc pas utiliser d'autres interruptions non USB. </p><br><p>  Mettez imm√©diatement la configuration dans un fichier usbconfig.h distinct.  C'est l√† que seront fix√©es les broches responsables de l'USB, ainsi que les bits, constantes et registres utilis√©s. </p><br><blockquote>  <strong>Encart th√©orique</strong> <br>  Le transfert via USB s'effectue en paquets de plusieurs octets chacun.  Le premier octet est toujours l'octet de synchronisation SYNC, √©gal √† 0b10000000, le second est l'identifiant d'octet du paquet PID.  Le transfert de chaque octet passe du bit le moins significatif au plus significatif (ce n'est pas tout √† fait vrai, mais en subtilit√© cette subtilit√© est ignor√©e, donn√©e ailleurs) en utilisant le codage NRZI.  Cette m√©thode consiste dans le fait qu'un z√©ro logique est transmis en changeant le niveau logique √† l'oppos√©, et une unit√© logique est transmise par non-changement.  De plus, une protection est introduite contre la d√©synchronisation (que nous n'utiliserons pas, mais doit √™tre prise en compte) de la source et du r√©cepteur du signal: s'il y a six unit√©s d'affil√©e dans la s√©quence transmise, c'est-√†-dire que l'√©tat des terminaux ne change pas pendant six p√©riodes cons√©cutives, une inversion forc√©e est ajout√©e √† la transmission, comme si z√©ro est transmis.  Ainsi, la taille des octets peut √™tre de 8 ou 9 bits. <br>  Il convient √©galement de mentionner que les lignes de donn√©es en USB sont diff√©rentielles, c'est-√†-dire que lorsque D + est √©lev√©, D- il est faible (c'est ce qu'on appelle l'√©tat K) et vice versa (√©tat J).  Ceci est fait pour une meilleure immunit√© au bruit √† haute fr√©quence.  Certes, il y a une exception: le signal √† la fin du paquet (il s'appelle SE0) est transmis en tirant les deux lignes de signal vers le sol (D + = D- = 0).  Il y a deux autres signaux transmis en maintenant une basse tension sur la ligne D + et une haute tension sur la ligne D + pendant des moments diff√©rents.  Si le temps est petit (une longueur d'octet ou un peu plus long) alors c'est Idle, une pause entre les paquets, et s'il est grand, un signal de r√©initialisation. </blockquote><p>  Ainsi, la transmission se fait sur une paire diff√©rentielle, sans compter le cas exotique de SE0, mais nous ne le consid√©rerons pas encore.  Ainsi, pour d√©terminer l'√©tat du bus USB, nous n'avons besoin que d'une seule ligne, D + ou D-.  Dans l'ensemble, il n'y a aucune diff√©rence √† choisir, mais pour √™tre pr√©cis, laissez D- √™tre. </p><br><p>  Le d√©but du paquet peut √™tre d√©termin√© en recevant l'octet SYNC apr√®s un long repos.  L'√©tat inactif correspond √† log.1 sur la ligne D (c'est √©galement l'√©tat J), et l'octet SYNC est 0b100000, mais il est transmis du bit le moins significatif au bit le plus significatif, de plus, il est cod√© en NRZI, c'est-√†-dire que chaque z√©ro signifie l'inversion du signal et un moyen maintenir le m√™me niveau.  La s√©quence des √©tats D- sera donc la suivante: </p><br><div class="scrollable-table"><table><thead><tr><th>  octet </th><th>  Inactif </th><th>  SYNC </th><th>  PID </th></tr></thead><tbody><tr><td>  USB </td><td>  1..1 </td><td>  00000001 </td><td>  ???????? </td></tr><tr><td>  D- </td><td>  1..1 </td><td>  01010100 </td><td>  ???????? </td></tr></tbody></table></div><br><p>  Le d√©but du paquet est plus facile √† d√©tecter sur un front descendant, et nous allons configurer une interruption sur celui-ci.  Mais que se passe-t-il si le contr√¥leur est occup√© au d√©but de la r√©ception et ne peut pas entrer imm√©diatement l'interruption?  Afin d'√©viter de perdre le nombre de pistes dans une telle situation, nous utilisons l'octet SYNC pour sa destination.  Il se compose enti√®rement de fronts aux limites des bits, de sorte que nous pouvons attendre l'un d'eux, puis un autre demi-bit, et aller directement au milieu du suivant.  Cependant, attendre un ¬´certain¬ª front n'est pas une bonne id√©e, car nous devons non seulement entrer au milieu du bit, mais aussi savoir quel bit nous avons obtenu dans le score.  Et pour cela, SYNC convient √©galement: il a deux bits z√©ro cons√©cutifs √† la fin (ce sont des √©tats K).  Ici, nous les attraperons.  Ainsi, dans le fichier drvasm.S, un morceau de code appara√Æt √† partir de l'entr√©e d'interruption vers foundK.  De plus, en raison du temps n√©cessaire pour v√©rifier l'√©tat du port, pour une transition inconditionnelle et ainsi de suite, nous arrivons √† la marque non pas au d√©but du bit, mais juste au milieu.  Mais il est inutile de v√©rifier la m√™me chose, car nous connaissons d√©j√† sa signification.  Par cons√©quent, nous attendons 8 cycles d'horloge (jusqu'√† pr√©sent nop'ami vide) et v√©rifions le bit suivant.  S'il est √©galement nul, alors nous avons trouv√© la fin de SYNC et pouvons proc√©der √† la r√©ception de bits significatifs. </p><br><p>  En fait, tout le code suppl√©mentaire est destin√© √† lire deux octets suppl√©mentaires avec une sortie ult√©rieure vers UART.  Eh bien, en attendant l'√©tat de SE0 pour ne pas entrer accidentellement dans le prochain paquet. </p><br><p>  Vous pouvez maintenant compiler le code r√©sultant et voir quels octets notre appareil accepte.  Personnellement, j'ai la s√©quence suivante: </p><br><pre> <code class="plaintext hljs">4E 55 00 00 4E 55 00 00 4E 55 00 00 4E 55 00 00 4E 55 00 00</code> </pre> <br><p>  N'oubliez pas que nous g√©n√©rons des donn√©es brutes, √† l'exclusion des z√©ros incr√©mentiels et du d√©codage NRZI.  Essayons de d√©coder manuellement, en commen√ßant par le bit bas: </p><br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>  4E </td><td></td></tr><tr><td>  NRZI </td><td>  01001110 </td><td>  0 (bit pr√©c√©dent) </td></tr><tr><td>  octet </td><td>  00101101 </td><td></td></tr><tr><td></td><td>  2D </td><td></td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>  55 </td><td></td></tr><tr><td>  NRZI </td><td>  01010101 </td><td>  0 (bit pr√©c√©dent) </td></tr><tr><td>  octet </td><td>  00000000 </td><td></td></tr><tr><td></td><td>  00 </td><td></td></tr></tbody></table></div><br><p>  Il n'est pas logique de d√©coder des z√©ros, car 16 valeurs identiques cons√©cutives ne peuvent pas √™tre incluses dans un paquet. </p><br><p>  Ainsi, nous avons pu √©crire un firmware qui accepte les deux premiers octets du paquet, mais jusqu'√† pr√©sent sans d√©codage. </p><br><h2 id="shag-2-demo-versiya-nrzi">  √âtape 2. Version de d√©monstration de NRZI </h2><br><p>  Afin de ne pas recoder manuellement, vous pouvez confier cela au contr√¥leur lui-m√™me: l'op√©ration XOR fait exactement ce dont vous avez besoin, bien que le r√©sultat soit invers√©, alors ajoutez une autre inversion apr√®s: </p><br><pre> <code class="plaintext hljs">mov temp, shift lsl shift eor temp, shift com temp rcall uart_hex</code> </pre> <br><p>  Le r√©sultat est tout √† fait attendu: </p><br><pre> <code class="bash hljs">2D 00 FF FF 2D 00 FF FF 2D 00 FF FF 2D 00 FF FF 2D 00 FF FF</code> </pre> <br><h2 id="shag-3-izbavlyaemsya-ot-cikla-priema-bayta">  √âtape 3. D√©barrassez-vous du cycle de r√©ception d'octets </h2><br><p>  Prenons un petit pas de plus et √©largissons le cycle de r√©ception du premier octet dans un code lin√©aire.  Ainsi, il s'av√®re que beaucoup de nops, n√©cessaires uniquement pour attendre le d√©but du bit suivant.  Au lieu de certains d'entre eux, vous pouvez utiliser le d√©codeur NRZI, d'autres vous seront utiles plus tard. </p><br><p>  Le r√©sultat de l'option pr√©c√©dente n'est pas diff√©rent. </p><br><h2 id="shag-4-chitaem-v-bufer">  √âtape 4. Lire dans le tampon </h2><br><p>  La lecture dans des registres s√©par√©s est, bien s√ªr, rapide et belle, mais quand il y a trop de donn√©es, il est pr√©f√©rable d'utiliser une entr√©e de tampon situ√©e quelque part dans la RAM.  Pour ce faire, nous d√©clarerons un tableau de taille suffisante dans le main, et dans l'interruption nous y √©crirons. <br>  Encart th√©orique </p><br><p>  La structure des paquets en USB est normalis√©e et se compose des parties suivantes: octet SYNC, octet PID + CHECK (2 champs de 4 bits chacun), champ de donn√©es (parfois 11 bits, mais le plus souvent un nombre arbitraire d'octets 8 bits) et une somme de contr√¥le CRC de 5 ( pour un champ de donn√©es de 11 bits), ou 16 (pour le reste) bits.  Enfin, l'indication de fin de paquet (EOP) est de deux bits de pause, mais ce ne sont plus des donn√©es. </p><br><p>  Avant de travailler avec le tableau, vous devez toujours configurer les registres et lib√©rer nop avant que le premier bit ne soit pas suffisant pour cela.  Par cons√©quent, vous devrez mettre la lecture des deux premiers bits dans la section lin√©aire du code, entre les commandes dont nous ins√©rerons le code d'initialisation, puis sauter au milieu du cycle de lecture, sur l'√©tiquette rxbit2.  En parlant de taille de tampon.  Selon la documentation, dans un paquet, il est impossible de transf√©rer plus de 8 octets de donn√©es.  Nous ajoutons les octets de service PID et CRC16, nous obtenons une taille de tampon de 11 octets.  Les octets SYNC et l'√©tat EOP ne seront pas √©crits.  Nous ne serons pas en mesure de contr√¥ler l'intervalle des demandes de l'h√¥te, mais nous ne voulons pas non plus les perdre, nous allons donc prendre une double marge pour la lecture.  Pour l'instant, nous n'utiliserons pas l'int√©gralit√© du buffer, mais afin de ne pas revenir dans le futur, il est pr√©f√©rable d'allouer imm√©diatement le volume requis. </p><br><h2 id="shag-5-rabotaem-s-buferom-po-chelovecheski">  √âtape 5. Travailler humainement avec le tampon </h2><br><p>  Au lieu de lire directement les premiers octets du tableau, nous √©crivons un morceau de code qui lit exactement autant d'octets qu'il a √©t√© r√©ellement √©crit dans le tableau.  Et en m√™me temps, ajoutez un s√©parateur entre les packages. <br>  Maintenant, la sortie ressemble √† ceci: </p><br><pre> <code class="bash hljs">&gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF</code> </pre> <br><h2 id="shag-6-dobavlyaem-dobavku-dobavochnyh-nuley">  √âtape 6. Ajout d'un additif Zero Additive </h2><br><p>  Enfin, il est temps de terminer la lecture du flux binaire en standard.  Le dernier √©l√©ment dont nous avons r√©ussi √† nous passer √©tait un faux z√©ro, ajout√© toutes les six unit√©s cons√©cutives.  √âtant donn√© que la r√©ception d'octets est d√©ploy√©e sur le corps lin√©aire de la boucle, vous devez v√©rifier apr√®s chaque bit, aux huit endroits.  Consid√©rez les deux premiers bits comme exemple: </p><br><pre> <code class="plaintext hljs">unstuff0: ;1 (  breq) andi x3, ~(1&lt;&lt;0) ;1 [15]  0-  .     mov x1, x2 ;1 [16]      () in x2, USBIN ;1 [17] &lt;-- 1-   .     ori shift, (1&lt;&lt;0) ;1 [18]  0-   .1      rjmp didUnstuff0 ;2 [20] ;&lt;---//---&gt; rxLoop: eor shift, x3 ;1 [0] in x1, USBIN ;1 [1] st y+, shift ;2 [3] ldi x3, 0xFF ;1 [4] nop ;1 [5] eor x2, x1 ;1 [6] bst x2, USBMINUS ;1 [7]     0-   shift bld shift, 0 ;1 [8] in x2, USBIN ;1 [9] &lt;--  1- (, ) andi x2, USBMASK ;1 [10] breq se0 ;1 [11] andi shift, 0xF9 ;1 [12] didUnstuff0: breq unstuff0 ;1 [13] eor x1, x2 ;1 [14]; bst x1, USBMINUS ;1 [15]     1-   shift bld shift, 1 ;1 [16] rxbit2: in x1, USBIN ;1 [17] &lt;--  2-  (, ) andi shift, 0xF3 ;1 [18] breq unstuff1 ;1 [19] didUnstuff1:</code> </pre> <br><p>  Pour la commodit√© de la navigation, les adresses des commandes d√©crites seront compt√©es par les √©tiquettes √† droite.  Veuillez noter qu'ils ont √©t√© introduits pour compter les cycles d'horloge du contr√¥leur, donc ils ne sont pas en ordre.  L'octet suivant est lu sur l'√©tiquette rxLoop, l'octet pr√©c√©dent est invers√© et √©crit dans le tampon [0, 3].  Ensuite, sur l'√©tiquette [1], l'√©tat de la ligne D est lu, selon XOR avec l'√©tat accept√© pr√©c√©dent, nous d√©codons NRZI (je rappelle que le XOR ordinaire ajoute son inversion, pour corriger ce que nous entrons dans le registre de masque x3, initialis√© avec les unit√©s 0xFF) et √©crivons √† 0- i√®me bit du registre √† d√©calage [7,8].  Ensuite, le plaisir commence - nous v√©rifions si le bit re√ßu √©tait le sixi√®me inchang√©.  Le bit constant re√ßu avec D- correspond √† l'√©criture de z√©ro (pas un! Nous passerons √† un √† la fin, XOR) dans le registre.  Par cons√©quent, vous devez v√©rifier si les bits 0, 7, 6, 5, 4, 3 sont des z√©ros.  Les deux bits restants n'ont pas d'importance, ils sont rest√©s de l'octet pr√©c√©dent et ont √©t√© v√©rifi√©s plus t√¥t.  Pour s'en d√©barrasser, nous coupons le registre par le masque [12], o√π tous les bits qui nous int√©ressent sont mis √† 1: 0b11111001 = 0xF9.  Si apr√®s avoir appliqu√© le masque tous les bits se sont av√©r√©s √™tre des z√©ros, la situation de l'ajout d'un bit est corrig√©e et il y a une transition vers l'√©tiquette unstuff0.  Un bit de plus [17] y est lu au lieu de ce qui a √©t√© lu pr√©c√©demment, dans l'intervalle entre les autres op√©rations, d'un exc√®s [9].  Nous √©changeons √©galement les registres des valeurs actuelles et pr√©c√©dentes x1, x2.  Le fait est que sur chaque bit, la valeur est lue dans un registre, puis XOR est dans un autre, apr√®s quoi les registres sont √©chang√©s.  Par cons√©quent, lors de la lecture du registre incr√©mental, cette op√©ration doit √©galement √™tre effectu√©e.  Mais la chose la plus int√©ressante est que dans le registre de donn√©es √† d√©calage, nous √©crivons non pas le z√©ro, que nous avons re√ßu honn√™tement, mais l'unit√© que l'h√¥te a tent√© de transf√©rer [18].  Cela est d√ª au fait que lors de la r√©ception des bits suivants, la valeur de z√©ro devra √©galement √™tre prise en compte, et si nous avons enregistr√© z√©ro, la v√©rification du masque n'a pas pu d√©couvrir que le bit suppl√©mentaire a d√©j√† √©t√© pris en compte.  Ainsi, dans le registre √† d√©calage, tous les bits sont invers√©s (par rapport √† ceux transmis par l'h√¥te), et le z√©ro ne l'est pas.  Pour √©viter un tel g√¢chis dans le tampon, nous effectuerons une inversion inverse selon XOR non pas avec 0xFF [0], mais avec 0xFE, c'est-√†-dire un registre dans lequel le bit correspondant sera r√©initialis√© √† 0 et, par cons√©quent, ne conduira pas √† une inversion.  Pour ce faire, sur l'√©chantillon [15] et r√©initialisez le bit z√©ro. </p><br><p>  Une situation similaire se produit avec les bits 1-5.  Disons que le 1er bit correspond √† la v√©rification 1, 0, 7, 6, 5, 4, tandis que les bits 2, 3 sont ignor√©s.  Cela correspond au masque 0xF3. <br>  Mais le traitement des 6 et 7 bits est diff√©rent: </p><br><pre> <code class="plaintext hljs">didUnstuff5: andi shift, 0x3F ;1 [45]   5-0 breq unstuff5 ;1 [46] ;&lt;---//---&gt; bld shift, 6 ;1 [52] didUnstuff6: cpi shift, 0x02 ;1 [53]   6-1 brlo unstuff6 ;1 [54] ;&lt;---//---&gt; bld shift, 7 ;1 [60] didUnstuff7: cpi shift, 0x04 ;1 [61]   7-2 brsh rxLoop ;3 [63] unstuff7:</code> </pre> <br><p>  Le masque du 6e bit est le num√©ro 0b01111110 (0x7E), mais vous ne pouvez pas le superposer sur le registre √† d√©calage, car il r√©initialisera le 0e bit, qui doit √™tre √©crit dans le tableau.  De plus, au compte √† rebours [45], un masque √©tait d√©j√† superpos√©, r√©initialisant 7 bits.  Par cons√©quent, il est n√©cessaire de traiter le bit suppl√©mentaire si les bits 1-6 sont √©gaux √† z√©ro et que le 0√®me n'a pas d'importance.  Autrement dit, la valeur du registre doit √™tre 0 ou 1, ce qui est parfaitement v√©rifi√© en comparant "moins de 2" [53, 54]. </p><br><p>  Le m√™me principe a √©t√© utilis√© pour le 7e bit: au lieu d'appliquer le masque 0xFC, une v√©rification est effectu√©e pour ¬´moins de 4¬ª [61, 63]. </p><br><h2 id="shag-7-sortiruem-pakety">  √âtape 7. Triez les packages </h2><br><p>  Puisque nous pouvons recevoir un paquet avec le premier octet (PID) √©gal √† 0x2D (SETUP), nous essaierons de trier celui re√ßu.  Au fait, pourquoi ai-je appel√© le package 0x2D SETUP alors qu'il semble √™tre ACK?  Le fait est que la transmission USB du bit le moins significatif au bit le plus significatif est effectu√©e dans chaque champ, et non octet, alors que nous acceptons octet par octet.  Le premier champ significatif, PID, ne prend que 4 bits, suivi de 4 bits CHECK suppl√©mentaires, repr√©sentant une inversion au niveau du bit du champ PID.  Ainsi, le premier octet re√ßu ne sera pas PID + CHECK, mais plut√¥t CHECK + PID.  Cependant, il n'y a pas beaucoup de diff√©rence, car toutes les valeurs sont connues √† l'avance et il est facile de r√©organiser les grignotages par endroits.  Tout de suite, nous √©crirons les principaux codes qui peuvent nous √™tre utiles dans le fichier usbconfig.h. </p><br><p>  Nous n'avons pas encore commenc√© √† ajouter le code de traitement PID, notez qu'il devrait √™tre rapide (c'est-√†-dire dans l'assembleur), mais l'alignement par horloge n'est pas requis, car nous avons d√©j√† accept√© le paquet.  Par cons√©quent, cette section sera par la suite transf√©r√©e dans le fichier asmcommon.inc, qui contiendra du code assembleur qui n'est pas li√© √† la fr√©quence.  En attendant, mettez simplement le commentaire en surbrillance. <br>  Passons maintenant au tri des paquets re√ßus. </p><br><blockquote>  <strong>Encart th√©orique</strong> <br>  Les paquets de donn√©es sur le bus USB sont combin√©s en transactions.  Chaque transaction commence par l'envoi par l'h√¥te d'un paquet marqueur sp√©cial qui contient des informations sur ce que l'h√¥te veut faire avec le p√©riph√©rique: configurer (SETUP), transmettre des donn√©es (OUT) ou les recevoir (IN).  Apr√®s la transmission du paquet marqueur, une pause de deux bits s'ensuit.  Ceci est suivi d'un paquet de donn√©es (DATA0 ou DATA1), qui peut √™tre envoy√© √† la fois par l'h√¥te et le p√©riph√©rique, en fonction du paquet marqueur.  Ensuite, une autre pause de deux bits et la r√©ponse est HANDSHAKE, un paquet de confirmation (ACK, NAK, STALL, nous les consid√©rerons une autre fois). <br><div class="scrollable-table"><table><thead><tr><th>  CONFIGURATION </th><th></th><th>  DATA0 </th><th></th><th>  Poign√©e de main </th></tr></thead><tbody><tr><td>  h√¥te-&gt; appareil </td><td>  pause </td><td>  h√¥te-&gt; appareil </td><td>  pause </td><td>  appareil-&gt; h√¥te </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  OUT </th><th></th><th>  DATA0 / DATA1 </th><th></th><th>  Poign√©e de main </th></tr></thead><tbody><tr><td>  h√¥te-&gt; appareil </td><td>  pause </td><td>  h√¥te-&gt; appareil </td><td>  pause </td><td>  appareil-&gt; h√¥te </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  EN </th><th></th><th>  DATA0 / DATA1 </th><th></th><th>  Poign√©e de main </th></tr></thead><tbody><tr><td>  h√¥te-&gt; appareil </td><td>  pause </td><td>  appareil-&gt; h√¥te </td><td>  pause </td><td>  h√¥te-&gt; appareil </td></tr></tbody></table></div><br><br>  √âtant donn√© que l'√©change va sur les m√™mes lignes, l'h√¥te et l'appareil doivent constamment basculer entre la transmission et la r√©ception.  De toute √©vidence, le d√©lai de deux bits est pr√©cis√©ment √† cet effet et est fait pour qu'ils ne commencent pas √† jouer push-push, tout en essayant de transf√©rer simultan√©ment certaines donn√©es sur le bus. </blockquote><p>  Nous connaissons donc tous les types de packages n√©cessaires √† l'√©change.  Nous ajoutons une v√©rification de l'octet PID re√ßu pour la conformit√© avec chacun.  Pour le moment, le p√©riph√©rique n'est pas encore en mesure d'√©crire m√™me des paquets primitifs tels que ACK sur le bus, ce qui signifie qu'il est incapable de dire √† l'h√¥te ce que c'est.  Par cons√©quent, des commandes comme IN ne peuvent pas √™tre attendues.  Nous ne v√©rifierons donc que la r√©ception des commandes SETUP et OUT, pour lesquelles nous indiquerons l'inclusion des LED correspondantes dans les branches correspondantes. </p><br><p>  En outre, il vaut la peine de prendre l'envoi de journaux au-del√† de l'interruption, quelque part dans le principal. </p><br><p>  Nous flashons l'appareil avec ce qui s'est pass√© apr√®s avoir effectu√© ces modifications et observons la s√©quence suivante d'octets re√ßus: </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00 C3|80|06|00|01|00|00|40|00 2D|80|06|00|01|00|00|40|00 C3|80|06|00|01|00|00|40|00</code> </pre> <br><p>  Et en plus - les deux LED allum√©es.  Nous avons donc pris SETUP et OUT. </p><br><h2 id="shag-8-chitaem-adres-na-konverte">  √âtape 8. Lisez l'adresse sur l'enveloppe </h2><br><blockquote>  <strong>Encart th√©orique</strong> <br>  Les paquets de marqueurs (SETUP, IN, OUT) servent non seulement √† montrer au p√©riph√©rique ce qu'ils en veulent, mais √©galement √† adresser un p√©riph√©rique sp√©cifique sur le bus et √† un point de terminaison sp√©cifique √† l'int√©rieur.  Des points de terminaison sont n√©cessaires pour mettre en √©vidence de mani√®re fonctionnelle une sous-fonction particuli√®re d'un appareil.  Ils peuvent varier en fr√©quence d'interrogation, en taux de change et en d'autres param√®tres.  Supposons que si l'appareil semble √™tre un adaptateur USB-COM, sa t√¢che principale est de recevoir des donn√©es du bus et de les transf√©rer vers le port (premier point final) et de recevoir des donn√©es du port et de les envoyer vers le bus (deuxi√®me).  En termes de signification, ces points sont destin√©s √† un flux important de donn√©es non structur√©es.  Mais en plus de cela, de temps en temps, l'appareil doit √©changer avec l'h√¥te l'√©tat des lignes de contr√¥le (toutes sortes de RTS, DTR, etc.) et √©changer des param√®tres (vitesse, parit√©).  Et ici, de grandes quantit√©s de donn√©es ne sont pas attendues.  De plus, il est pratique lorsque les informations de service ne sont pas m√©lang√©es avec des donn√©es.  Il s'av√®re donc qu'il est pratique d'utiliser au moins 3 points de terminaison pour l'adaptateur USB-COM.  En pratique, bien s√ªr, cela se passe de diff√©rentes mani√®res ... <br>  Une question tout aussi int√©ressante est de savoir pourquoi l'appareil re√ßoit son adresse, car en dehors de cela, vous ne pouvez toujours rien coller sur ce port particulier.  Ceci est fait pour simplifier le d√©veloppement des concentrateurs USB.  Ils peuvent √™tre assez "stupides" et simplement diffuser des signaux de l'h√¥te vers tous les appareils sans se soucier du tri.  Et l'appareil lui-m√™me le d√©couvrira, traitera le paquet ou l'ignorera. <br>  Ainsi, l'adresse du p√©riph√©rique et l'adresse du point de terminaison sont contenues dans les paquets marqueurs.  La structure de ces packages est donn√©e ci-dessous: <br>  le terrain <br><div class="scrollable-table"><table><thead><tr><th>  le terrain </th><th>  SYNC </th><th>  addr </th><th>  point final </th><th>  CRC </th><th>  Eop </th></tr></thead><tbody><tr><td>  Bits USB </td><td>  0-7 </td><td>  0123456 </td><td>  0123 </td><td>  01234 </td><td>  01 </td></tr><tr><td>  bits re√ßus </td><td></td><td>  0123456 </td><td>  7012 </td><td>  34567 </td><td></td></tr></tbody></table></div><br><br>      ,    -   ( -  PID = SETUP  OUT)   (IN)  ,     . </blockquote><p>     ,       (-)     (Handshake) : </p><br><ul><li>  :     ,     ,  NAK   </li><li>  -:   SETUP  OUT,  ,  IN ‚Äî ,  </li><li>   .   ,              ,        ,        </li></ul><br><p>       ¬´ ‚Äî  ¬ª    .         PID',      ,     .     ¬´PID¬ª  .       usbCurrentTok.   PID'   (DATA0, DATA1)   ,      .      ,   ?  :    ,    ( 0   usbCurrentTok     ),    ,     .       ( SE0)      ,  -  ,     D+, D- .        ,       SYNC,   . ,             ,          .    ¬´¬ª    ,        .          . </p><br><p>        ,         .       x3,          (,     ,     ,         ). </p><br><p>    ,   USB    ,      ,              .     ,  ,     ,          CRC (      ).      ,      [21].       0-    .      ,    [26]. ,        CRC,        . </p><br><h2 id="shag-9-bezotkaznyy-priem">  9.   </h2><br><p>       ,       ,    ¬´ ¬ª,   ACK.         NAK',     (    cnt ‚Äî         ).   USB     ,   ,            SYNC  PID.       Y,           cnt (         ).     ,        ‚Äî ACK.       x3      ‚Äî    1 ,           .     x3 (  r20)    20. </p><br><p>        (     SETUP,     ),   ACK'  ,    ,        ,      . ,              . </p><br><p>   ,       D+, D- (      ),    ‚Äî .      XOR  ,      , ,  ,    -  . </p><br><p>  ,     ,     ,      ,   . ,    ,        ,           .        .   vusb   :  txBitloop   2    ([00], [08]).    3 ,  6 .       ,             .      1    3    :      171.       (    171,        11 ,    ),    ‚Äî ,    .    cnt=4: </p><br><p> 4 ‚Äî 171 = -167 = (   ) 89 (+ ) <br> 89 ‚Äî 171 = -82 = (   ) 174 (+ ) <br> 174 ‚Äî 171 = 3.     ,     <br>       ,      . </p><br><p>  ,   3 ,      1.      6       ,    ,      x4.        D+, D-   ,     . . <br>          : </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00 69|00|10|00|01|00|00|40|00</code> </pre> <br><p>    C3 .  ,       ,      UART   . ,  ,       IN ,       . ,    . </p><br><h2 id="shag-10-posylaem-hosta-nak">  10.   NAK </h2><br><p>    NAK    ,       .      ,      .       ,  -       . </p><br><p>      ,      .    ,  ,   -    ,     .        usbRxBuf,    .        ,   ‚Äî  ,     USB_BUFSIZE.        usbInputBufOffset,            .        . </p><br><p>   NAK    handleData      ,        [22].            (usbRxLen),     - .       (   ‚Äî    ),       usbRxLen,  ,      ‚Äî  usbRxToken,   SETUP  OUT - .   :        ,     ,   ACK . </p><br><p>                  .   ,     ,     -    ,  -,    .         ?    ,   ,    ,   ,    -    . </p><br><p>  ,     </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00</code> </pre> <br><p>     ,    NAK`,    ,     . </p><br><h2 id="shag-11-obrabatyvaem-zaprosy">  11.   </h2><br><p>     , ,        .       ‚Äî         .     ,      ,     , ,  ,     .            .        .         ,    USB,           usbPoll.  ‚Äî      ,     .    ‚Äî     .      SETUP ,     PID  CRC,    SETUP  5-  ,     16-.      3 ¬´¬ª . ¬´¬ª   PID      usbRxToken,  CRC   ,         ,  .        usbProcessRx,      ,       . </p><br><p>  ,   ,        ‚Äî  ,     SE0.   ,     USB      . </p><br><p>     .        SETUP,           .        .  SETUP    usbRequest_t    8 .      :  (    USB-)  ,     - .         ,     .           . <br>      , ,  ,  . </p><br><h2 id="shag-12-podrobnosti-setupa">  12.  SETUP' </h2><br><p> ,  ,      .     .     usbDriverSetup,         . ,      . ,      (    ,     ,            )   . ,           : ACK  NAK,        . </p><br><h2 id="shag-13-otpravlyaem-otvet">  13.   </h2><br><p>    ,      SETUP + DATAx,    DATAx   8 .        IN      DATAx,     .         ,     .        ,      ACK  NAK.           ,       .   ‚Äî    usbTxBuf,   ,   usbTxLen   .  low-speed USB          8  ( PID,    CRC),    usbTxLen      11.      PID,   ,      . ,     16,   , 0x0F,   .    PID      ,       .        IN,   ,       (handshake    ,    ). </p><br><p>      : <br>   SETUP + DATAx,    ACK  NAK      . , ,  usbPoll,   ,        (       PID=DATA1 (  DATA0  DATA1   ,     ,     DATA1).   CRC  .       ,    ,   -   .           ‚Äî 4 .  ,    3 ,   4.   ,   SYNC       .          ¬´   IN   NAK?¬ª     NAK.      ,     , DATA1   . </p><br><p>      ,     ‚Äî USBRQ_SET_ADDRESS (   ,    ).          .          (drvsdm.S,  make SE0).     ,              ,   ,      DATA1    ,  ,          . ,   ,           ,    ,           ,        .       ,         ,      . </p><br><h2 id="shag-14-sortiruem-standartnye-zaprosy">  14.    </h2><br><p>    ,        .   ,    USBRQ_GET_DESCRIPTOR  USBRQ_SET_ADDRESS, ,    .    usbDriverDescriptor,    .        ,   USBRQ_GET_DESCRIPTOR.  ,    , : </p><br><p> USBDESCR_DEVICE ‚Äî   :   USB (1.1   ),  , ,    . . <br> USBDESCR_CONFIG ‚Äî ,     ,    . . <br> USBDESCR_STRING ‚Äî   ,   . <br> ,   ,       USBDESCR_DEVICE,  ,        . </p><br><h2 id="shag-15-zapolnyaem-anketnye-dannye">  15.    </h2><br><p>       . -,     .      ,   - - , , HID,      ,        .     Vendor ID  Product ID,      USB,     .  ,  vusb            . </p><br><p>     , , - .    ,       ,    ,        (, )      usbMsgPtr,   ‚Äî   len,     usbMsgLen.      (     )  18 ,       8. ,    ,  3 .       - ,  STALL. </p><br><p>           usbDeviceRead.   ,       memcpy_P,             ,  , . </p><br><p>   ,      ,  ,      .    ,      ,        . </p><br><p>       ,     ,  . </p><br><blockquote> <strong> </strong> <br>  PID'  DATA0  DATA1       .  PID'     ,          ,  -       . </blockquote><p>       ,  DATA0 / DATA1    (        ),     , ,   3 ,    .     XOR    PID',   .      ,        ,   XOR'    .     PID  DATA1,   XOR    PID   ,   XOR  DATA0    . </p><br><p>      ,    ,     USBDESCR_CONFIG. </p><br><h2 id="shag-16-nakonec-to-ustroystvo">  16. - ! </h2><br><p>   USBDESCR_CONFIG      USBDESCR_DEVICE.     (   ,        )  .   , -     USB-,     ,   D+, D-. </p><br><p>        ,      : , ,   .    ,        (    ,    ).  ,      UTF-16,       .     USB     UTF-8  . </p><br><p>   vusb       ,     lsusb    .    VID, PID      ,        .         ,        VID, PID,     ‚Äî      . </p><br><p> ,         ,      (    ).       SETUP:   ,        ,     .   0,       ,    ‚Äî      . ,     ,       ,  . <br>        . </p><br><h2 id="shag-17-ustroystvo-stanovitsya-chelovechnee-hid">  17.    (HID) </h2><br><blockquote> <strong> </strong> <br> HID ‚Äî human interface device,   ,       ,     .    HID   ,       .  ,      ,   , , ,       .    ¬´¬ª     .      HID     ( low-speed      800   ),        . </blockquote><p>     HID     ,     USBDESCR_HID_REPORT.          vusb,      . ,   usbDriverSetup ( )   usbFunctionSetup ( ).  ,      SETUP,         OUT.      ,         , ,   usbFunctionWrite. </p><br><p>     ,  usbDeviceRead  usbFunctionRead,           .   ,    ,   usbFunctionSetup  (  ,   )   USB_FLG_USE_USER_RW,   usbDriverSetup   . </p><br><p>    ‚Äî      ‚Äî    usbFunctionWrite  usbFunctionRead.          .   ‚Äî      ,       . </p><br><p>       usbDriverSetup. </p><br><h2 id="shag-18-obschaemsya-s-zhelezkoy">  18.    </h2><br><p>  ,      ,        .     HID,    ,   ,      (        udev  - ).  ,        ,   .        ,   ,   ,     . <br> UPD:   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">ramzes2</a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HIDAPI</a> </p><br><p>           . </p><br><h2 id="shag-19-sravnivaem-s-vusb">  19.   vusb </h2><br><p>     vusb              ,   . </p><br><p> drvasm.S   - usbdrvasm.S  asmcommon.inc,   -,   , usbdrvasm12.inc ‚Äî usbdrvasm20.inc. </p><br><p> main.c    main.c ( )  usbdrv.c (  vusb) <br> usbconfig.h      (     ),   ,  ,   usbconfig.h. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>      vusb,            ,   ,    .  ,    ,      . . ,     ,     ,    USB-HID.   ,   ,  ,            vusb,     ,  , ,      . </p><br><h2 id="ispolzovannaya-literatura-i-poleznye-ssylki">      </h2><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.obdev.at/products/vusb/index.html</a> (  vusb) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://microsin.net/programming/arm-working-with-usb/usb-in-a-nutshell-part1.html</a> <br>  ..  USB:     <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://radiohlam.ru/tag/usb/</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://we.easyelectronics.ru/electro-and-pc/usb-dlya-avr-chast-1-vvodnaya.html</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://usb.fober.net/cat/teoriya/</a> </p><br><p> PS -     (,      )     ,   </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460815/">https://habr.com/ru/post/fr460815/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460803/index.html">Lire pour l'√©t√©: des livres pour les techniciens</a></li>
<li><a href="../fr460805/index.html">Comment transf√©rer des donn√©es entre microcontr√¥leurs √† 100 Mbps</a></li>
<li><a href="../fr460807/index.html">Mesurer sept fois, une fois impl√©menter l'outil BI</a></li>
<li><a href="../fr460811/index.html">Composants communs par diff√©rentes √©quipes. Rapport Yandex</a></li>
<li><a href="../fr460813/index.html">Comment utiliser les diagrammes de Voronoi pour contr√¥ler l'IA</a></li>
<li><a href="../fr460819/index.html">WorldSkills: avis du participant de l'Olympiade</a></li>
<li><a href="../fr460821/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 307 (du 15 au 21 juillet)</a></li>
<li><a href="../fr460823/index.html">√âv√©nements num√©riques √† Moscou du 22 juillet au 28 juillet</a></li>
<li><a href="../fr460825/index.html">Introduction √† Screen Capture API - Scannez les codes QR dans un navigateur</a></li>
<li><a href="../fr460827/index.html">Probl√®me PGP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>