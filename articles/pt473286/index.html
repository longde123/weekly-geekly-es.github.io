<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèº üêò üôáüèΩ Escrevemos prote√ß√£o contra ataques DDoS no XDP. Parte nuclear üõí üëµüèº ü¶å</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A tecnologia EXpress Data Path (XDP) permite o processamento arbitr√°rio de tr√°fego nas interfaces Linux antes que os pacotes cheguem √† pilha de rede d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escrevemos prote√ß√£o contra ataques DDoS no XDP. Parte nuclear</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473286/"><p>  A tecnologia EXpress Data Path (XDP) permite o processamento arbitr√°rio de tr√°fego nas interfaces Linux antes que os pacotes cheguem √† pilha de rede do kernel.  Aplica√ß√£o de XDP - prote√ß√£o contra ataques DDoS (CloudFlare), filtros sofisticados, coleta de estat√≠sticas (Netflix).  Os programas XDP s√£o executados pela m√°quina virtual eBPF, portanto, eles t√™m restri√ß√µes tanto em seu c√≥digo quanto nas fun√ß√µes dispon√≠veis do kernel, dependendo do tipo de filtro. </p><br><p>  O artigo pretende preencher as defici√™ncias de v√°rios materiais XDP.  Em primeiro lugar, eles fornecem c√≥digo pronto que ignora imediatamente os recursos do XDP: preparado para verifica√ß√£o ou muito simples para causar problemas.  Quando voc√™ tenta escrever seu c√≥digo do zero, n√£o h√° entendimento do que fazer com erros t√≠picos.  Em segundo lugar, os m√©todos para testar localmente o XDP sem VMs e hardware n√£o s√£o cobertos, apesar de terem suas pr√≥prias armadilhas.  O texto √© destinado a programadores familiarizados com redes e Linux interessados ‚Äã‚Äãem XDP e eBPF. </p><a name="habracut"></a><br><p> Nesta parte, examinaremos em detalhes como o filtro XDP √© montado e como test√°-lo. Em seguida, escreveremos uma vers√£o simples do conhecido mecanismo de cookie SYN no n√≠vel de processamento de pacotes.  Embora n√£o formemos uma "lista branca" <br>  clientes verificados, mant√©m contadores e gerencia o filtro - registros suficientes. </p><br><p>  Vamos escrever em C - isso n√£o est√° na moda, mas √© pr√°tico.  Todo o c√≥digo est√° dispon√≠vel no GitHub atrav√©s do link no final e √© dividido em confirma√ß√µes de acordo com as etapas descritas no artigo. </p><br><p>  <strong>Isen√ß√£o de responsabilidade.</strong>  Durante o artigo, uma mini-solu√ß√£o ser√° desenvolvida para repelir ataques DDoS, porque essa √© uma tarefa realista para XDP e minha √°rea.  No entanto, o principal objetivo √© lidar com a tecnologia, este n√£o √© um guia para criar uma prote√ß√£o pronta.  O c√≥digo de treinamento n√£o √© otimizado e omite algumas nuances. </p><br><h2 id="kratkiy-obzor-xdp">  Vis√£o geral do XDP </h2><br><p>  Vou descrever apenas os principais pontos para n√£o duplicar a documenta√ß√£o e os artigos existentes. </p><br><p> Portanto, o c√≥digo do filtro √© carregado no kernel.  Pacotes de entrada s√£o enviados para o filtro.  Como resultado, o filtro deve tomar uma decis√£o: pular o pacote para o kernel ( <code>XDP_PASS</code> ), descartar o pacote ( <code>XDP_DROP</code> ) ou envi√°-lo de volta ( <code>XDP_TX</code> ).  O filtro pode alterar o pacote, isso √© especialmente verdadeiro para <code>XDP_TX</code> .  Voc√™ tamb√©m pode travar o programa ( <code>XDP_ABORTED</code> ) e descartar o pacote, mas este √© um an√°logo do <code>assert(0)</code> para depura√ß√£o. </p><br><p>  A m√°quina virtual eBPF (Berkley Packet Filter estendida) √© especialmente simplificada para que o kernel possa verificar se o c√≥digo n√£o faz loop e n√£o danifica a mem√≥ria de outra pessoa.  Restri√ß√µes e verifica√ß√µes agregadas: </p><br><ul><li>  Ciclos proibidos (retroceder). </li><li>  H√° uma pilha de dados, mas nenhuma fun√ß√£o (todas as fun√ß√µes C devem ser incorporadas). </li><li>  O acesso √† mem√≥ria fora da pilha e do buffer de pacotes √© proibido. </li><li>  O tamanho do c√≥digo √© limitado, mas na pr√°tica isso n√£o √© muito significativo. </li><li>  As chamadas s√£o permitidas apenas para fun√ß√µes especiais do kernel (auxiliares do eBPF). </li></ul><br><p>  O design e a instala√ß√£o do filtro s√£o assim: </p><br><ol><li>  O c√≥digo fonte (por exemplo, <code>kernel.c</code> ) √© compilado no objeto ( <code>kernel.o</code> ) sob a arquitetura da m√°quina virtual eBPF.  A partir de outubro de 2019, a compila√ß√£o no eBPF √© suportada por Clang e prometida no GCC 10.1. </li><li>  Se nesse c√≥digo de objeto houver chamadas para estruturas do kernel (por exemplo, tabelas e contadores), zeros ser√£o usados ‚Äã‚Äãem vez de seus IDs, ou seja, esse c√≥digo n√£o poder√° ser executado.  Antes de carregar no kernel, voc√™ precisa substituir esses zeros pelo ID de objetos espec√≠ficos criados por meio de chamadas do kernel (c√≥digo de link).  Voc√™ pode fazer isso com utilit√°rios externos ou escrever um programa que vincular√° e carregar√° um filtro espec√≠fico. </li><li>  O kernel verifica o programa carregado.  A aus√™ncia de loops e absente√≠smo al√©m dos limites do pacote e da pilha √© verificada.  Se o verificador n√£o puder provar que o c√≥digo est√° correto, o programa ser√° rejeitado - voc√™ deve poder agrad√°-lo. </li><li>  Ap√≥s a verifica√ß√£o bem-sucedida, o kernel compila o c√≥digo do objeto de arquitetura eBPF no c√≥digo de m√°quina da arquitetura do sistema (just-in-time). </li><li>  O programa se conecta √† interface e come√ßa a processar pacotes. </li></ol><br><p>  Como o XDP funciona no kernel, a depura√ß√£o √© feita por logs de rastreamento e, de fato, por pacotes que o programa filtra ou gera.  No entanto, o eBPF fornece seguran√ßa para o c√≥digo carregado para o sistema, para que voc√™ possa experimentar o XDP diretamente no Linux local. </p><br><h2 id="podgotovka-okruzheniya">  Prepara√ß√£o do ambiente </h2><br><h3 id="sborka">  Assembl√©ia </h3><br><p>  O Clang n√£o pode emitir diretamente o c√≥digo do objeto para a arquitetura do eBPF, portanto, o processo consiste em duas etapas: </p><br><ol><li>  Compile o c√≥digo C no bytecode do LLVM ( <code>clang -emit-llvm</code> ). </li><li>  Converta bytecode em c√≥digo de objeto eBPF ( <code>llc -march=bpf -filetype=obj</code> ). </li></ol><br><p>  Ao escrever um filtro, alguns arquivos com fun√ß√µes auxiliares e macros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dos testes do kernel</a> s√£o √∫teis.  √â importante que eles correspondam √† vers√£o do kernel ( <code>KVER</code> ).  Fa√ßa o download em <code>helpers/</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> KVER=v5.3.7 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> BASE=https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/plain/tools/testing/selftests/bpf wget -P helpers --content-disposition <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${BASE}</span></span></span><span class="hljs-string">/bpf_helpers.h?h=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KVER}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${BASE}</span></span></span><span class="hljs-string">/bpf_endian.h?h=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KVER}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">unset</span></span> KVER BASE</code> </pre> <br><p>  Makefile para Arch Linux (kernel 5.3.7): </p><br><pre> <code class="plaintext hljs">CLANG ?= clang LLC ?= llc KDIR ?= /lib/modules/$(shell uname -r)/build ARCH ?= $(subst x86_64,x86,$(shell uname -m)) CFLAGS = \ -Ihelpers \ \ -I$(KDIR)/include \ -I$(KDIR)/include/uapi \ -I$(KDIR)/include/generated/uapi \ -I$(KDIR)/arch/$(ARCH)/include \ -I$(KDIR)/arch/$(ARCH)/include/generated \ -I$(KDIR)/arch/$(ARCH)/include/uapi \ -I$(KDIR)/arch/$(ARCH)/include/generated/uapi \ -D__KERNEL__ \ \ -fno-stack-protector -O2 -g xdp_%.o: xdp_%.c Makefile $(CLANG) -c -emit-llvm $(CFLAGS) $&lt; -o - | \ $(LLC) -march=bpf -filetype=obj -o $@ .PHONY: all clean all: xdp_filter.o clean: rm -f ./*.o</code> </pre> <br><p>  <code>KDIR</code> cont√©m o caminho para os cabe√ßalhos do kernel, <code>ARCH</code> - a arquitetura do sistema.  Caminhos e ferramentas podem variar um pouco entre as distribui√ß√µes. </p><br><div class="spoiler">  <b class="spoiler_title">Exemplo de diferen√ßa para o Debian 10 (kernel 4.19.67)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#   CLANG ?= clang LLC ?= llc-7 #   KDIR ?= /usr/src/linux-headers-$(shell uname -r) ARCH ?= $(subst x86_64,x86,$(shell uname -m)) #    -I CFLAGS = \ -Ihelpers \ \ -I/usr/src/linux-headers-4.19.0-6-common/include \ -I/usr/src/linux-headers-4.19.0-6-common/arch/$(ARCH)/include \ #   </code> </pre> </div></div><br><p>  <code>CFLAGS</code> incluem um diret√≥rio com cabe√ßalhos auxiliares e v√°rios diret√≥rios com cabe√ßalhos do kernel.  O s√≠mbolo <code>__KERNEL__</code> significa que os cabe√ßalhos UAPI (APIs do espa√ßo do usu√°rio) s√£o definidos para o c√≥digo do kernel, pois o filtro √© executado no kernel. </p><br><p>  A prote√ß√£o da pilha pode ser desativada ( <code>-fno-stack-protector</code> ), porque o verificador de c√≥digo do eBPF ainda procura uma sa√≠da da pilha.  A otimiza√ß√£o deve ser inclu√≠da imediatamente porque o tamanho do bytecode do eBPF √© limitado. </p><br><p>  Vamos come√ßar com um filtro que ignora todos os pacotes e n√£o faz nada: </p><br><pre> <code class="plaintext hljs">#include &lt;uapi/linux/bpf.h&gt; #include &lt;bpf_helpers.h&gt; SEC("prog") int xdp_main(struct xdp_md* ctx) { return XDP_PASS; } char _license[] SEC("license") = "GPL";</code> </pre> <br><p>  O comando <code>make</code> <code>xdp_filter.o</code> .  Onde test√°-lo agora? </p><br><h3 id="testovyy-stend">  Suporte de teste </h3><br><p>  O suporte deve incluir duas interfaces: nas quais haver√° um filtro e a partir dos quais os pacotes ser√£o enviados.  Esses devem ser dispositivos Linux completos com seu IP para verificar como aplicativos regulares funcionam com nosso filtro. </p><br><p>  Dispositivos como o veth (Ethernet virtual) s√£o adequados para n√≥s: eles s√£o um par de interfaces de rede virtual que s√£o "conectadas" diretamente entre si.  Voc√™ pode cri√°-los assim (nesta se√ß√£o, todos os comandos <code>ip</code> s√£o executados como <code>root</code> ): </p><br><pre> <code class="bash hljs">ip link add xdp-remote <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> veth peer name xdp-local</code> </pre> <br><p>  Aqui <code>xdp-remote</code> e <code>xdp-local</code> s√£o nomes de dispositivos.  Um filtro ser√° anexado ao <code>xdp-local</code> (192.0.2.1/24) e o tr√°fego recebido ser√° enviado do <code>xdp-remote</code> (192.0.2.2/24).  No entanto, h√° um problema: as interfaces est√£o na mesma m√°quina e o Linux n√£o envia tr√°fego para uma delas atrav√©s da outra.  Voc√™ pode resolver isso com as regras complicadas do <code>iptables</code> , mas elas ter√£o que alterar os pacotes, o que √© inconveniente ao depurar.  √â melhor usar namespaces de rede (namespaces de rede, a seguir netns). </p><br><p>  O espa√ßo para nome da rede cont√©m um conjunto de interfaces, tabelas de roteamento e regras do NetFilter, isoladas de objetos semelhantes em outros netns.  Cada processo √© executado em um espa√ßo para nome e apenas objetos desses netns s√£o acess√≠veis a ele.  Por padr√£o, o sistema possui um √∫nico namespace de rede para todos os objetos, para que voc√™ possa trabalhar no Linux e n√£o conhecer netns. </p><br><p>  Crie um novo <code>xdp-test</code> nome do <code>xdp-test</code> e mova o <code>xdp-remote</code> . </p><br><pre> <code class="bash hljs">ip netns add xdp-test ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-remote netns xdp-test</code> </pre> <br><p>  Ent√£o o processo em execu√ß√£o no <code>xdp-test</code> n√£o ‚Äúver√°‚Äù o <code>xdp-local</code> (ele permanecer√° em netns por padr√£o) e o enviar√° via <code>xdp-remote</code> ao enviar um pacote para 192.0.2.1, porque esta √© a √∫nica interface em 192.0.2.0/ 24 dispon√≠veis para esse processo.  Isso tamb√©m funciona na dire√ß√£o oposta. </p><br><p>  Ao se mover entre redes, a interface cai e perde o endere√ßo.  Para configurar a interface no netns, voc√™ precisa executar o <code>ip ...</code> neste espa√ßo de nome do comando <code>ip netns exec</code> : </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test \ ip address add 192.0.2.2/24 dev xdp-remote ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test \ ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> xdp-remote up</code> </pre> <br><p>  Como voc√™ pode ver, isso n√£o √© diferente da configura√ß√£o de <code>xdp-local</code> no espa√ßo para nome padr√£o: </p><br><pre> <code class="bash hljs"> ip address add 192.0.2.1/24 dev xdp-local ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> xdp-local up</code> </pre> <br><p>  Se voc√™ executar <code>tcpdump -tnevi xdp-local</code> , poder√° ver que os pacotes enviados a partir do <code>xdp-test</code> s√£o entregues a esta interface: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test ping 192.0.2.1</code> </pre> <br><p>  √â conveniente executar o shell no <code>xdp-test</code> .  H√° um script no reposit√≥rio que automatiza o trabalho com o suporte, por exemplo, voc√™ pode configur√°-lo com o comando <code>sudo ./stand up</code> e exclu√≠-lo com o comando <code>sudo ./stand down</code> . </p><br><h3 id="trassirovka">  Rastrear </h3><br><p>  O filtro est√° conectado ao dispositivo da seguinte maneira: </p><br><pre> <code class="bash hljs">ip -force link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-local xdp object xdp_filter.o verbose</code> </pre> <br><p>  A <code>-force</code> necess√°ria para vincular um novo programa se outro j√° estiver vinculado.  ‚ÄúNenhuma not√≠cia √© boa not√≠cia‚Äù n√£o √© sobre esse comando, a conclus√£o √©, de qualquer forma, volumosa.  <code>verbose</code> opcional, mas com ele um relat√≥rio aparece no trabalho do verificador de c√≥digo com a listagem de montagem: </p><br><pre> <code class="plaintext hljs">Verifier analysis: 0: (b7) r0 = 2 1: (95) exit</code> </pre> <br><p>  Desate o programa da interface: </p><br><pre> <code class="bash hljs">ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-local xdp off</code> </pre> <br><p>  No script, esses s√£o os <code>sudo ./stand attach</code> e <code>sudo ./stand detach</code> . </p><br><p>  Ao anexar um filtro, voc√™ pode verificar se o <code>ping</code> continua funcionando, mas o programa funciona?  Adicione os logs.  A fun√ß√£o <a href=""><code>bpf_trace_printk()</code></a> √© semelhante a <code>printf()</code> , mas suporta apenas at√© tr√™s argumentos, exceto o modelo e uma lista limitada de qualificadores.  A macro <code>bpf_printk()</code> simplifica a chamada. </p><br><pre> <code class="diff hljs"> SEC("prog") int xdp_main(struct xdp_md* ctx) { + bpf_printk("got packet: %p\n", ctx); return XDP_PASS; }</code> </pre> <br><p>  A sa√≠da vai para o canal de rastreamento do kernel, que voc√™ precisa ativar: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n 1 | sudo tee /sys/kernel/debug/tracing/options/trace_printk</code> </pre> <br><p>  Exibir fluxo de mensagens: </p><br><pre> <code class="bash hljs">cat /sys/kernel/debug/tracing/trace_pipe</code> </pre> <br><p>  Ambos os comandos fazem uma chamada para <code>sudo ./stand log</code> . </p><br><p>  O ping agora deve acionar as seguintes mensagens: </p><br><pre> <code class="plaintext hljs">&lt;...&gt;-110930 [004] ..s1 78803.244967: 0: got packet: 00000000ac510377</code> </pre> <br><p>  Se voc√™ observar atentamente a sa√≠da do verificador, notar√° c√°lculos estranhos: </p><br><pre> <code class="plaintext hljs">0: (bf) r3 = r1 1: (18) r1 = 0xa7025203a7465 3: (7b) *(u64 *)(r10 -8) = r1 4: (18) r1 = 0x6b63617020746f67 6: (7b) *(u64 *)(r10 -16) = r1 7: (bf) r1 = r10 8: (07) r1 += -16 9: (b7) r2 = 16 10: (85) call bpf_trace_printk#6 &lt;...&gt;</code> </pre> <br><p>  O fato √© que os programas eBPF n√£o possuem uma se√ß√£o de dados; portanto, a √∫nica maneira de codificar uma sequ√™ncia de formato √© com os argumentos imediatos dos comandos da VM: </p><br><pre> <code class="bash hljs">$ python -c <span class="hljs-string"><span class="hljs-string">"import binascii; print(bytes(reversed(binascii.unhexlify('0a7025203a74656b63617020746f67'))))"</span></span> b<span class="hljs-string"><span class="hljs-string">'got packet: %p\n'</span></span></code> </pre> <br><p>  Por esse motivo, a sa√≠da de depura√ß√£o aumenta bastante o c√≥digo resultante. </p><br><h3 id="otpravka-paketov-xdp">  Enviando pacotes XDP </h3><br><p>  Vamos mudar o filtro: vamos enviar todos os pacotes recebidos de volta.  Isso est√° incorreto do ponto de vista da rede, pois seria necess√°rio alterar os endere√ßos nos cabe√ßalhos, mas agora o trabalho √© importante em princ√≠pio. </p><br><pre> <code class="diff hljs"> bpf_printk("got packet: %p\n", ctx); - return XDP_PASS; + return XDP_TX; }</code> </pre> <br><p>  Execute o <code>tcpdump</code> no <code>xdp-remote</code> .  Ele deve mostrar a solicita√ß√£o de eco ICMP de sa√≠da e entrada id√™ntica e parar de mostrar a resposta de eco do ICMP.  Mas n√£o mostra.  Acontece que, para o <code>XDP_TX</code> funcionar em um programa no <code>xdp-local</code> <a href="">√© necess√°rio</a> que a interface do <code>xdp-remote</code> seja <code>xdp-remote</code> interface <code>xdp-remote</code> , mesmo que esteja vazia, e <a href="">deve</a> ser aumentada. </p><br><div class="spoiler">  <b class="spoiler_title">Como eu descobri?</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O</a> mecanismo de eventos perf, a prop√≥sito, usar a mesma m√°quina virtual permite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rastrear o caminho do pacote no kernel</a> , ou seja, o eBPF √© usado para desmontar o eBPF. </p><br><blockquote>  Voc√™ tem que tirar o bem do mal, porque n√£o h√° mais nada a fazer dele. </blockquote><br><pre> <code class="bash hljs">$ sudo perf trace --call-graph dwarf -e <span class="hljs-string"><span class="hljs-string">'xdp:*'</span></span> 0.000 ping/123455 xdp:xdp_bulk_tx:ifindex=19 action=TX sent=0 drops=1 err=-6 veth_xdp_flush_bq ([veth]) veth_xdp_flush_bq ([veth]) veth_poll ([veth]) &lt;...&gt;</code> </pre> <br><p>  O que √© o c√≥digo 6? </p><br><pre> <code class="bash hljs">$ errno 6 ENXIO 6 No such device or address</code> </pre> <br><p>  A fun√ß√£o <code>veth_xdp_flush_bq()</code> recebe um c√≥digo de erro de <code>veth_xdp_xmit()</code> , onde pesquisamos pelo <code>ENXIO</code> e encontramos um coment√°rio. </p></div></div><br><p>  Restaure o filtro m√≠nimo ( <code>XDP_PASS</code> ) no arquivo <code>xdp_dummy.c</code> , adicione-o ao Makefile, anexe-o ao <code>xdp-remote</code> : </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> remote \ ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev int xdp object dummy.o</code> </pre> <br><p>  Agora <code>tcpdump</code> mostra o que √© esperado: </p><br><pre> <code class="plaintext hljs">62:57:8e:70:44:64 &gt; 26:0e:25:37:8f:96, ethertype IPv4 (0x0800), length 98: (tos 0x0, ttl 64, id 13762, offset 0, flags [DF], proto ICMP (1), length 84) 192.0.2.2 &gt; 192.0.2.1: ICMP echo request, id 46966, seq 1, length 64 62:57:8e:70:44:64 &gt; 26:0e:25:37:8f:96, ethertype IPv4 (0x0800), length 98: (tos 0x0, ttl 64, id 13762, offset 0, flags [DF], proto ICMP (1), length 84) 192.0.2.2 &gt; 192.0.2.1: ICMP echo request, id 46966, seq 1, length 64</code> </pre> <br><p>  Se apenas o ARP for exibido, √© necess√°rio remover os filtros (isso √© feito por <code>sudo ./stand detach</code> ), iniciar o <code>ping</code> , definir os filtros e tentar novamente.  O problema √© que o filtro <code>XDP_TX</code> afeta o ARP e se a pilha <br>  <code>xdp-test</code> espa√ßo para nome <code>xdp-test</code> conseguiu "esquecer" o endere√ßo MAC 192.0.2.1; ele n√£o conseguir√° resolver esse IP. </p><br><h2 id="postanovka-zadachi">  Declara√ß√£o do problema </h2><br><p>  Vamos seguir para a tarefa declarada: escreva o mecanismo de cookies SYN no XDP. </p><br><p>  At√© agora, a inunda√ß√£o SYN continua sendo um ataque DDoS popular, cuja ess√™ncia √© a seguinte.  Ao estabelecer uma conex√£o (handshake TCP), o servidor recebe um SYN, aloca recursos para uma conex√£o futura, responde com um pacote SYNACK e aguarda um ACK.  O invasor simplesmente envia pacotes SYN a partir de endere√ßos falsos, na quantidade de milhares por segundo, de cada host, a partir de uma botnet de v√°rios milhares.  O servidor √© for√ßado a alocar recursos imediatamente ap√≥s a chegada do pacote e libera um grande tempo limite, como resultado, a mem√≥ria ou os limites se esgotam, novas conex√µes n√£o s√£o aceitas e o servi√ßo n√£o est√° dispon√≠vel. </p><br><p>  Se voc√™ n√£o alocar recursos para o pacote SYN, mas apenas responder com um pacote SYNACK, como o servidor pode entender que o pacote ACK que veio depois se refere a um pacote SYN que n√£o foi salvo?  Afinal, um invasor tamb√©m pode gerar ACKs falsos.  A ess√™ncia do cookie SYN √© codificar os par√¢metros de <code>seqnum</code> no <code>seqnum</code> como um hash de endere√ßos, portas e altera√ß√µes no salt.  Se o ACK conseguiu chegar antes da mudan√ßa de sal, √© poss√≠vel calcular novamente o hash e comparar com o <code>acknum</code> .  O atacante n√£o pode falsificar um <code>acknum</code> , j√° que o sal inclui um segredo e n√£o ter√° tempo para resolver devido ao canal limitado. </p><br><p>  O cookie SYN √© implementado h√° muito tempo no kernel do Linux e pode at√© ser ativado automaticamente se o SYN chegar muito rapidamente e em massa. </p><br><div class="spoiler">  <b class="spoiler_title">Programa educacional sobre handshake TCP</b> <div class="spoiler_text"><p>  O TCP fornece transfer√™ncia de dados como um fluxo de bytes; por exemplo, solicita√ß√µes HTTP s√£o enviadas por TCP.  O fluxo √© transmitido em peda√ßos em pacotes.  Todos os pacotes TCP possuem sinalizadores l√≥gicos e n√∫meros de sequ√™ncia de 32 bits: </p><br><ul><li><p>  A combina√ß√£o de sinalizadores determina o papel de um pacote espec√≠fico.  O sinalizador SYN significa que este √© o primeiro pacote de remetente na conex√£o.  O sinalizador ACK significa que o remetente recebeu todos os dados da conex√£o antes do byte da conta.  Um pacote pode ter v√°rios sinalizadores e √© chamado por sua combina√ß√£o, por exemplo, um pacote SYNACK. </p><br></li><li><p>  O n√∫mero de sequ√™ncia (seqnum) define o deslocamento no fluxo de dados para o primeiro byte que √© transmitido neste pacote.  Por exemplo, se no primeiro pacote com X bytes de dados esse n√∫mero for N, no pr√≥ximo pacote com novos dados ser√° N + X.  No in√≠cio da conex√£o, cada lado seleciona esse n√∫mero arbitrariamente. </p><br></li><li><p>  N√∫mero de confirma√ß√£o (acknum) - o mesmo deslocamento que seqnum, mas n√£o determina o n√∫mero de bytes a serem transmitidos, mas o n√∫mero do primeiro byte do destinat√°rio que o remetente n√£o viu. </p><br></li></ul><br><p>  No in√≠cio da conex√£o, as partes devem concordar com <code>seqnum</code> e <code>acknum</code> .  O cliente envia um pacote SYN com seu <code>seqnum = X</code>  O servidor responde com um pacote SYNACK, onde grava seu <code>seqnum = Y</code> e define <code>acknum = X + 1</code> .  O cliente responde ao SYNACK com um pacote ACK, em que <code>seqnum = X + 1</code> , <code>acknum = Y + 1</code> .  Depois disso, a transfer√™ncia real dos dados come√ßa. </p><br><p>  Se o interlocutor n√£o confirmar o recebimento do pacote, o TCP o enviar√° novamente por tempo limite. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Por que os cookies SYN nem sempre s√£o usados?</b> <div class="spoiler_text"><p>  Primeiramente, se o SYNACK ou o ACK forem perdidos, voc√™ ter√° que aguardar o reenvio - a conex√£o est√° mais lenta.  Em segundo lugar, no pacote SYN - e apenas nele!  - s√£o transmitidas v√°rias op√ß√µes que afetam a opera√ß√£o adicional da conex√£o.  Sem lembrar os pacotes SYN recebidos, o servidor ignora essas op√ß√µes. Nos pr√≥ximos pacotes, o cliente n√£o os enviar√° mais.  Nesse caso, o TCP pode funcionar, mas pelo menos no est√°gio inicial, a qualidade da conex√£o diminuir√°. </p></div></div><br><p>  Em termos de pacotes, um programa XDP deve fazer o seguinte: </p><br><ul><li>  SYNACK com cookie para responder a SYN; </li><li>  responder ao ACK RST (desconectar); </li><li>  descartar outros pacotes. </li></ul><br><p>  Pseudoc√≥digo do algoritmo junto com a an√°lise do pacote: </p><br><pre> <code class="plaintext hljs">   Ethernet,  .    IPv4,  .     , (*)    ,  .    TCP,  . (**)   SYN,  SYN-ACK  cookie.   ACK,   acknum   cookie,  .      N  . (*)  RST. (**)     .</code> </pre> <br><p>  Um <code>(*)</code> indica os pontos nos quais controlar o estado do sistema - no primeiro est√°gio, voc√™ pode ficar sem eles, simplesmente implementando um handshake TCP com a gera√ß√£o de um cookie SYN como seqnum. </p><br><p>  No local <code>(**)</code> , enquanto n√£o tivermos uma tabela, pularemos o pacote. </p><br><h2 id="realizaciya-tcp-handshake">  Implementa√ß√£o de handshake TCP </h2><br><h3 id="razbor-paketa-i-verifikaciya-koda">  Analise o pacote e verifique o c√≥digo </h3><br><p>  Precisamos de estruturas de cabe√ßalho de rede: Ethernet ( <code>uapi/linux/if_ether.h</code> ), IPv4 ( <code>uapi/linux/ip.h</code> ) e TCP ( <code>uapi/linux/tcp.h</code> ).  O √∫ltimo que n√£o consegui conectar devido a erros relacionados ao <code>atomic64_t</code> , tive que copiar as defini√ß√µes necess√°rias no c√≥digo. </p><br><p>  Todas as fun√ß√µes alocadas em C para facilitar a leitura devem ser incorporadas no local da chamada, j√° que o verificador eBPF no kernel pro√≠be transi√ß√µes de volta, ou seja, loops e chamadas de fun√ß√£o. </p><br><pre> <code class="plaintext hljs">#define INTERNAL static __attribute__((always_inline))</code> </pre> <br><p>  A macro <code>LOG()</code> desativa a impress√£o na compila√ß√£o do release. </p><br><p>  O programa √© um transportador de fun√ß√µes.  Cada um recebe um pacote no qual o cabe√ßalho do n√≠vel correspondente √© real√ßado, por exemplo, <code>process_ether()</code> espera que o <code>ether</code> esteja cheio.  Com base nos resultados da an√°lise de campo, a fun√ß√£o pode transferir o pacote para um n√≠vel superior.  O resultado da fun√ß√£o √© a a√ß√£o XDP.  At√© agora, os manipuladores SYN e ACK passam todos os pacotes. </p><br><pre> <code class="plaintext hljs">struct Packet { struct xdp_md* ctx; struct ethhdr* ether; struct iphdr* ip; struct tcphdr* tcp; }; INTERNAL int process_tcp_syn(struct Packet* packet) { return XDP_PASS; } INTERNAL int process_tcp_ack(struct Packet* packet) { return XDP_PASS; } INTERNAL int process_tcp(struct Packet* packet) { ... } INTERNAL int process_ip(struct Packet* packet) { ... } INTERNAL int process_ether(struct Packet* packet) { struct ethhdr* ether = packet-&gt;ether; LOG("Ether(proto=0x%x)", bpf_ntohs(ether-&gt;h_proto)); if (ether-&gt;h_proto != bpf_ntohs(ETH_P_IP)) { return XDP_PASS; } // B struct iphdr* ip = (struct iphdr*)(ether + 1); if ((void*)(ip + 1) &gt; (void*)packet-&gt;ctx-&gt;data_end) { return XDP_DROP; /* malformed packet */ } packet-&gt;ip = ip; return process_ip(packet); } SEC("prog") int xdp_main(struct xdp_md* ctx) { struct Packet packet; packet.ctx = ctx; // A struct ethhdr* ether = (struct ethhdr*)(void*)ctx-&gt;data; if ((void*)(ether + 1) &gt; (void*)ctx-&gt;data_end) { return XDP_PASS; } packet.ether = ether; return process_ether(&amp;packet); }</code> </pre> <br><p>  Chamo a aten√ß√£o para as verifica√ß√µes marcadas A e B. Se voc√™ comentar A, o programa ser√° montado, mas haver√° um erro de verifica√ß√£o durante o carregamento: </p><br><pre> <code class="plaintext hljs">Verifier analysis: &lt;...&gt; 11: (7b) *(u64 *)(r10 -48) = r1 12: (71) r3 = *(u8 *)(r7 +13) invalid access to packet, off=13 size=1, R7(id=0,off=0,r=0) R7 offset is outside of the packet processed 11 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0 Error fetching program/map!</code> </pre> <br><p>  A linha principal √© <code>invalid access to packet, off=13 size=1, R7(id=0,off=0,r=0)</code> : existem caminhos de execu√ß√£o quando o d√©cimo terceiro byte do in√≠cio do buffer est√° fora do pacote.  De acordo com a listagem, √© dif√≠cil entender de qual linha estamos falando, mas h√° um n√∫mero de instru√ß√£o (12) e um desmontador mostrando as linhas do c√≥digo-fonte: </p><br><pre> <code class="bash hljs">llvm-objdump -S xdp_filter.o | less</code> </pre> <br><p>  Nesse caso, ele aponta para uma string </p><br><pre> <code class="plaintext hljs">LOG("Ether(proto=0x%x)", bpf_ntohs(ether-&gt;h_proto));</code> </pre> <br><p>  pelo qual fica claro que o problema est√° no <code>ether</code> .  Seria sempre assim. </p><br><h3 id="otvet-na-syn">  Responder a SYN </h3><br><p>  O objetivo nesse est√°gio √© formar um pacote SYNACK correto com um <code>seqnum</code> fixo, que ser√° substitu√≠do por um cookie SYN no futuro.  Todas as altera√ß√µes ocorrem em <code>process_tcp_syn()</code> e na √°rea circundante. </p><br><h4 id="proverka-paketa">  Verifica√ß√£o do pacote </h4><br><p>  Curiosamente, aqui est√° a linha mais not√°vel, mais precisamente, um coment√°rio sobre ela: </p><br><pre> <code class="plaintext hljs">/* Required to verify checksum calculation */ const void* data_end = (const void*)ctx-&gt;data_end;</code> </pre> <br><p>  Ao escrever a primeira vers√£o do c√≥digo, o kernel 5.1 foi usado, para o verificador em que havia uma diferen√ßa entre <code>data_end</code> e <code>(const void*)ctx-&gt;data_end</code> .  Ao escrever o artigo, o kernel 5.3.1 n√£o teve esse problema.  Talvez o compilador tenha acessado a vari√°vel local de maneira diferente do campo.  C√≥digo moral simplificado pode ajudar com muitos aninhamentos. </p><br><p>  Verifica√ß√µes rotineiras adicionais de comprimentos em homenagem ao verificador;  sobre <code>MAX_CSUM_BYTES</code> abaixo. </p><br><pre> <code class="plaintext hljs">const u32 ip_len = ip-&gt;ihl * 4; if ((void*)ip + ip_len &gt; data_end) { return XDP_DROP; /* malformed packet */ } if (ip_len &gt; MAX_CSUM_BYTES) { return XDP_ABORTED; /* implementation limitation */ } const u32 tcp_len = tcp-&gt;doff * 4; if ((void*)tcp + tcp_len &gt; (void*)ctx-&gt;data_end) { return XDP_DROP; /* malformed packet */ } if (tcp_len &gt; MAX_CSUM_BYTES) { return XDP_ABORTED; /* implementation limitation */ }</code> </pre> <br><h4 id="razvorot-paketa">  Propaga√ß√£o de pacote </h4><br><p>  Preencha <code>seqnum</code> e <code>acknum</code> , defina ACK (SYN j√° est√° definido): </p><br><pre> <code class="plaintext hljs">const u32 cookie = 42; tcp-&gt;ack_seq = bpf_htonl(bpf_ntohl(tcp-&gt;seq) + 1); tcp-&gt;seq = bpf_htonl(cookie); tcp-&gt;ack = 1;</code> </pre> <br><p>  Troque portas TCP, endere√ßo IP e endere√ßo MAC.  A biblioteca padr√£o n√£o est√° acess√≠vel no programa XDP, portanto, <code>memcpy()</code> √© uma macro que oculta o Clang intr√≠nseco. </p><br><pre> <code class="plaintext hljs">const u16 temp_port = tcp-&gt;source; tcp-&gt;source = tcp-&gt;dest; tcp-&gt;dest = temp_port; const u32 temp_ip = ip-&gt;saddr; ip-&gt;saddr = ip-&gt;daddr; ip-&gt;daddr = temp_ip; struct ethhdr temp_ether = *ether; memcpy(ether-&gt;h_dest, temp_ether.h_source, ETH_ALEN); memcpy(ether-&gt;h_source, temp_ether.h_dest, ETH_ALEN);</code> </pre> <br><h4 id="pereschet-kontrolnyh-summ">  Rec√°lculo da soma de verifica√ß√£o </h4><br><p>  As somas de verifica√ß√£o IPv4 e TCP exigem a adi√ß√£o de todas as palavras de 16 bits nos cabe√ßalhos, e o tamanho dos cabe√ßalhos est√° escrito nelas, ou seja, no momento da compila√ß√£o √© desconhecido.  Isso √© um problema porque o verificador n√£o pula um loop regular para um limite de vari√°vel.  Mas o tamanho dos cabe√ßalhos √© limitado: at√© 64 bytes cada.  Voc√™ pode fazer um loop com um n√∫mero fixo de itera√ß√µes, que podem terminar antes do previsto. </p><br><p>  Observo que existe o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC 1624</a> sobre como recalcular parcialmente a soma de verifica√ß√£o se apenas palavras de pacotes fixos forem alteradas.  No entanto, o m√©todo n√£o √© universal e a implementa√ß√£o seria mais dif√≠cil de manter. </p><br><p>  Fun√ß√£o de c√°lculo de soma de verifica√ß√£o: </p><br><pre> <code class="plaintext hljs">#define MAX_CSUM_WORDS 32 #define MAX_CSUM_BYTES (MAX_CSUM_WORDS * 2) INTERNAL u32 sum16(const void* data, u32 size, const void* data_end) { u32 s = 0; #pragma unroll for (u32 i = 0; i &lt; MAX_CSUM_WORDS; i++) { if (2*i &gt;= size) { return s; /* normal exit */ } if (data + 2*i + 1 + 1 &gt; data_end) { return 0; /* should be unreachable */ } s += ((const u16*)data)[i]; } return s; }</code> </pre> <br><p>   ,  <code>size</code>   ,    ,      . </p><br><p>  32-     : </p><br><pre> <code class="plaintext hljs">INTERNAL u32 sum16_32(u32 v) { return (v &gt;&gt; 16) + (v &amp; 0xffff); }</code> </pre> <br><p>        : </p><br><pre> <code class="plaintext hljs">ip-&gt;check = 0; ip-&gt;check = carry(sum16(ip, ip_len, data_end)); u32 tcp_csum = 0; tcp_csum += sum16_32(ip-&gt;saddr); tcp_csum += sum16_32(ip-&gt;daddr); tcp_csum += 0x0600; tcp_csum += tcp_len &lt;&lt; 8; tcp-&gt;check = 0; tcp_csum += sum16(tcp, tcp_len, data_end); tcp-&gt;check = carry(tcp_csum); return XDP_TX;</code> </pre> <br><p>  <code>carry()</code>   32-  16-   ,  RFC 791. </p><br><h4 id="proverka-rukopozhatiya-tcp">   TCP </h4><br><p>      <code>netcat</code> ,   ACK,   Linux  RST-,       SYN ‚Äî     SYNACK    -       ,     . </p><br><pre> <code class="bash hljs">$ sudo ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test nc -nv 192.0.2.1 6666 192.0.2.1 6666: Connection reset by peer</code> </pre> <br><p>        <code>tcpdump</code>  <code>xdp-remote</code>  , , <code>hping3</code>      . </p><br><h3 id="syn-cookie"> SYN cookie </h3><br><p>    XDP   .    , ,    .  Linux, ,   SipHash,     XDP     . </p><br><p>    TODO,    : </p><br><ul><li><p> XDP-    <code>cookie_seed</code> (  )   ,    ,         . </p><br></li><li><p>   SYN cookie  ACK-    ,   IP  ,     . </p><br></li></ul><br><p>   : </p><br><pre> <code class="bash hljs">$ sudoip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test nc -nv 192.0.2.1 6666 192.0.2.1 6666: Connection reset by peer</code> </pre> <br><p>      ( <code>flags=0x2</code> ‚Äî  SYN, <code>flags=0x10</code> ‚Äî  ACK): </p><br><pre> <code class="plaintext hljs">Ether(proto=0x800) IP(src=0x20e6e11a dst=0x20e6e11e proto=6) TCP(sport=50836 dport=6666 flags=0x2) Ether(proto=0x800) IP(src=0xfe2cb11a dst=0xfe2cb11e proto=6) TCP(sport=50836 dport=6666 flags=0x10) cookie matches for client 20200c0</code> </pre> <br><p>     IP,    SYN flood  ,     ACK flood,   : </p><br><pre> <code class="bash hljs">sudo ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test hping3 --flood -A -s 1111 -p 2222 192.0.2.1</code> </pre> <br><p>   : </p><br><pre> <code class="plaintext hljs">Ether(proto=0x800) IP(src=0x15bd11a dst=0x15bd11e proto=6) TCP(sport=3236 dport=2222 flags=0x10) cookie mismatch</code> </pre> <br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  eBPF   XDP        ,     . , XDP ‚Äî      ,     ,  DPDK    kernel bypass.   , XDP     , ,   ,       .     ,          userspace-. </p><br><p>   ,   ,       ,     userspace-   . </p><br><p>  Refer√™ncias: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>   GitHub</strong></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bpftrace Cheat Sheet</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BPF and XDP Reference Guide</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">XDP Tutorial</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PoC: compiling to eBPF from Rust</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt473286/">https://habr.com/ru/post/pt473286/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt473274/index.html">Eventos digitais em Moscou, de 28 de outubro a 3 de novembro</a></li>
<li><a href="../pt473276/index.html">Eventos digitais em S√£o Petersburgo, de 28 de outubro a 3 de novembro</a></li>
<li><a href="../pt473278/index.html">Atualiza√ß√£o do terminal do Windows: visualiza√ß√£o 1910</a></li>
<li><a href="../pt473282/index.html">Parthenon. Bilion√°rios de Slumdog: como os irm√£os Bukhman se tornaram bilion√°rios e o Vologda online - global</a></li>
<li><a href="../pt473284/index.html">Senior, TechLead, Architect - o que vem a seguir? Como lidar com uma rotina de trabalho e para onde seguir em frente?</a></li>
<li><a href="../pt473288/index.html">Crie seu c√≥digo do zero, ele ir√° bombear seu n√≠vel</a></li>
<li><a href="../pt473290/index.html">Julia. Por onde come√ßar o projeto? ...</a></li>
<li><a href="../pt473292/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel n¬∫ 319 (de 21 a 27 de outubro)</a></li>
<li><a href="../pt473294/index.html">Gerenciamento de mem√≥ria ou menos frequentemente atire no seu p√©</a></li>
<li><a href="../pt473296/index.html">Inicializa√ß√£o sem dinheiro. Experi√™ncia pessoal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>