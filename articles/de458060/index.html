<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüî¨ ‚úçüèº ‚ö™Ô∏è Erstellen eines Grasshaders in der Unity-Engine üíü ‚ìÇÔ∏è üçÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Tutorial erfahren Sie, wie Sie einen geometrischen Shader schreiben, um Grashalme aus den Spitzen des eingehenden Netzes zu generieren und d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Grasshaders in der Unity-Engine</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458060/"><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  In diesem Tutorial erfahren Sie, wie Sie einen geometrischen Shader schreiben, um Grashalme aus den Spitzen des eingehenden Netzes zu generieren und die Dichte des Grases mithilfe von Tessellation zu steuern. <br><br>  Der Artikel beschreibt den schrittweisen Prozess des Schreibens eines Grasshaders in Unity.  Der Shader empf√§ngt das eingehende Netz und generiert aus jedem Scheitelpunkt des Netzes mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geometrischen Shaders</a> einen Grashalm.  Aus Gr√ºnden des Interesses und des Realismus haben die Grashalme eine <strong>zuf√§llige Gr√∂√üe</strong> und <strong>Rotation</strong> und werden auch vom <strong>Wind beeinflusst</strong> .  Um die Dichte des Grases zu kontrollieren, verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tessellation</a> , um das eingehende Netz zu trennen.  Das Gras kann Schatten <strong>werfen</strong> und <strong>empfangen</strong> . <br><br>  <strong>Das fertige Projekt</strong> wird am Ende des Artikels ver√∂ffentlicht.  Die generierte Shader-Datei enth√§lt eine gro√üe Anzahl von Kommentaren, die das Verst√§ndnis erleichtern. <br><a name="habracut"></a><br><h3>  Anforderungen </h3><br>  Um dieses Tutorial abzuschlie√üen, ben√∂tigen Sie praktische Kenntnisse √ºber die Unity-Engine und ein erstes Verst√§ndnis der Syntax und Funktionalit√§t von Shadern. <br><br>  <a href="">Laden Sie den Entwurf des Projekts herunter (.zip)</a> . <br><br><h2>  An die Arbeit gehen </h2><br>  Laden Sie den Entwurf des Projekts herunter und √∂ffnen Sie ihn im Unity-Editor.  √ñffnen Sie die Hauptszene und dann den <code>Grass</code> Shader in Ihrem Code-Editor. <br><br>  Diese Datei enth√§lt einen Shader, der wei√üe Farbe erzeugt, sowie einige Funktionen, die wir in diesem Tutorial verwenden werden.  Sie werden feststellen, dass diese Funktionen zusammen mit dem Vertex-Shader im <code>CGINCLUDE</code> Block <em>au√üerhalb von</em> <code>SubShader</code> .  Der in diesem Block platzierte Code wird <strong>automatisch in alle Durchg√§nge</strong> im Shader aufgenommen.  Dies wird sp√§ter n√ºtzlich sein, da unser Shader mehrere Durchg√§nge hat. <br><br>  Wir beginnen mit dem Schreiben eines <strong>geometrischen Shaders</strong> , der aus jedem Scheitelpunkt auf der Oberfl√§che unseres Netzes Dreiecke generiert. <br><br><h2>  1. Geometrische Shader </h2><br>  Geometrische Shader sind ein optionaler Bestandteil der Rendering-Pipeline.  Sie werden <strong>nach dem</strong> Vertex-Shader (oder Tessellation-Shader, wenn Tessellation verwendet wird) und vor der Verarbeitung der Vertices f√ºr den Fragment-Shader ausgef√ºhrt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef7/c01/458/ef7c01458cadf7cd0cf46695d7114f96.jpg"></div><br>  <i>Direct3D Graphics Pipeline 11. Beachten Sie, dass in diesem Diagramm der Fragment-Shader als <em>Pixel-Shader bezeichnet wird</em> .</i> <br><br>  Geometrische Shader erhalten am Eingang ein einzelnes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundelement</a> und k√∂nnen null, ein oder mehrere Grundelemente erzeugen.  Wir beginnen mit dem Schreiben eines geometrischen Shaders, der einen <strong>Scheitelpunkt</strong> (oder <em>Punkt</em> ) an der Eingabe empf√§ngt und <strong>ein Dreieck</strong> f√ºttert, das <strong>einen</strong> Grashalm darstellt. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block. struct geometryOutput { float4 pos : SV_POSITION; }; [maxvertexcount(3)] void geo(triangle float4 IN[3] : SV_POSITION, inout TriangleStream&lt;geometryOutput&gt; triStream) { } ‚Ä¶ // Add inside the SubShader Pass, just below the #pragma fragment frag line. #pragma geometry geo</span></span></code> </pre> <br>  Der obige Code deklariert einen geometrischen Shader namens <code>geo</code> mit zwei Parametern.  Das erste <code>triangle float4 IN[3]</code> , dass ein Dreieck (bestehend aus drei Punkten) als Eingabe verwendet wird.  Der zweite, z. B. <code>TriangleStream</code> , richtet einen Shader f√ºr die Ausgabe eines Dreiecksstroms ein, sodass jeder Scheitelpunkt die <code>geometryOutput</code> Struktur zum √úbertragen seiner Daten verwendet. <br><br><div class="spoiler">  <b class="spoiler_title">Wir haben oben gesagt, dass der Shader einen Scheitelpunkt erh√§lt und einen Grashalm ausgibt.</b>  <b class="spoiler_title">Warum bekommen wir dann ein Dreieck?</b> <div class="spoiler_text">  Es ist weniger kostspielig, einen <code></code> als Eingabe zu nehmen.  Dies kann wie folgt erfolgen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">geo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point vertexOutput IN[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">], inout TriangleStream&lt;geometryOutput&gt; triStream)</span></span></span></span></code> </pre> <br>  Da unser eingehendes Netz (in diesem Fall <code>GrassPlane10x10</code> im Ordner "Netz") eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dreieckstopologie aufweist</a> , f√ºhrt dies zu einer Nicht√ºbereinstimmung zwischen der eingehenden Netz-Topologie und dem erforderlichen Eingabeprimitiv.  Obwohl dies in DirectX HLSL <strong>zul√§ssig</strong> ist, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es in OpenGL</a> nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zul√§ssig</a> , sodass ein Fehler angezeigt wird. </div></div><br>  Zus√§tzlich f√ºgen wir den letzten Parameter in eckigen Klammern √ºber der Funktionsdeklaration hinzu: <code>[maxvertexcount(3)]</code> .  Er teilt der GPU mit, dass wir <em>nicht mehr als</em> 3 Eckpunkte ausgeben werden (aber nicht m√ºssen).  Wir lassen <code>SubShader</code> auch einen geometrischen Shader verwenden, indem wir ihn in <code>Pass</code> deklarieren. <br><br>  Unser geometrischer Shader macht noch nichts;  F√ºgen Sie zum Zeichnen eines Dreiecks den folgenden Code in den geometrischen Shader ein. <br><br><pre> <code class="cpp hljs">geometryOutput o; o.pos = float4(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0db/534/ac1/0db534ac10c125955829fd53b9923cd7.gif"></div><br>  Dies ergab sehr seltsame Ergebnisse.  Wenn Sie die Kamera bewegen, wird deutlich, dass das Dreieck im <strong>Bildschirmbereich</strong> gerendert <strong>wird</strong> .  Dies ist logisch: Da der geometrische Shader unmittelbar vor der Verarbeitung der Scheitelpunkte ausgef√ºhrt wird, entzieht er dem Scheitelpunkt-Shader die Verantwortung daf√ºr, dass die Scheitelpunkte im <strong>K√ºrzungsbereich</strong> angezeigt <strong>werden</strong> .  Wir werden unseren Code √§ndern, um dies widerzuspiegeln. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the return call in the vertex shader. //return UnityObjectToClipPos(vertex); return vertex; ‚Ä¶ // Update each assignment of o.pos in the geometry shader. o.pos = UnityObjectToClipPos(float4(0.5, 0, 0, 1)); ‚Ä¶ o.pos = UnityObjectToClipPos(float4(-0.5, 0, 0, 1)); ‚Ä¶ o.pos = UnityObjectToClipPos(float4(0, 1, 0, 1));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/221/912/b3e/221912b3e6bc0581126a0f415b6e79c5.png"></div><br>  Jetzt ist unser Dreieck in der Welt richtig gerendert.  Es scheint jedoch, dass nur eine erstellt wird.  Tats√§chlich wird f√ºr jeden Scheitelpunkt unseres Netzes ein Dreieck <em>gezeichnet</em> , aber die den Scheitelpunkten des Dreiecks zugewiesenen Positionen sind <strong>konstant</strong> - sie √§ndern sich nicht f√ºr jeden eingehenden Scheitelpunkt.  Daher befinden sich alle Dreiecke √ºbereinander. <br><br>  Wir werden dies beheben, indem wir die Positionen der ausgehenden Scheitelpunkte relativ zum eingehenden Punkt versetzen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the top of the geometry shader. float3 pos = IN[0]; ‚Ä¶ // Update each assignment of o.pos. o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); ‚Ä¶ o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); ‚Ä¶ o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/ac4/84c/6b2ac484c5a033b18e88400e10191779.png"></div><br><div class="spoiler">  <b class="spoiler_title">Warum bilden einige Eckpunkte kein Dreieck?</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cab/447/d9c/cab447d9c4c82d8208a28e7cee2f7807.png"></div><br>  Obwohl wir festgestellt haben, dass das eingehende Grundelement ein <strong>Dreieck ist</strong> , wird ein Grashalm nur von <strong>einem</strong> der Punkte des Dreiecks √ºbertragen, wobei die beiden anderen verworfen werden.  Nat√ºrlich k√∂nnen wir einen Grashalm von allen drei ankommenden Punkten √ºbertragen, aber dies f√ºhrt dazu, dass benachbarte Dreiecke √ºberm√§√üig Grashalme √ºbereinander bilden. <br><br>  Sie k√∂nnen dieses Problem auch l√∂sen, indem Sie Netze mit dem Typ Topologiepunkte als eingehende Netze des geometrischen Shaders verwenden. </div></div><br>  Dreiecke werden jetzt korrekt gezeichnet und ihre Basis befindet sich an der Spitze, die sie aussendet.  Bevor Sie <code>GrassPlane</code> , machen Sie das <code>GrassPlane</code> Objekt in der Szene <strong>inaktiv</strong> und <code>GrassBall</code> das <code>GrassBall</code> Objekt.  Wir m√∂chten, dass das Gras auf verschiedenen Oberfl√§chentypen korrekt erzeugt wird. Daher ist es wichtig, es an Maschen unterschiedlicher Form zu testen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19b/f67/8fb/19bf678fbb6ce3c03956dbdf068004f0.png"></div><br>  Bisher werden alle Dreiecke in einer Richtung und nicht von der Oberfl√§che der Kugel nach au√üen emittiert.  Um dieses Problem zu l√∂sen, werden wir Grashalme in einem <strong>tangentialen Raum</strong> erzeugen. <br><br><h2>  2. Tangentenraum </h2><br>  Im Idealfall m√∂chten wir Grashalme erstellen, indem wir eine andere Breite, H√∂he, Kr√ºmmung und Drehung einstellen, ohne den Winkel der Oberfl√§che zu ber√ºcksichtigen, von der der Grashalm emittiert wird.  Einfach ausgedr√ºckt, definieren wir einen Grashalm in einem Raum <strong>lokal zum Scheitelpunkt, der ihn aussendet</strong> , und transformieren ihn dann so, dass er <strong>lokal zum Netz ist</strong> .  Dieser Raum wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tangentenraum genannt</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/8f7/c39/3fd8f7c394bf4eb18cb988aceafe342b.png"></div><br>  <i>Im Tangentenraum werden die <strong>X-</strong> , <strong>Y-</strong> und <strong>Z-</strong> Achsen relativ zur Normalen und zur Position der Oberfl√§che (in unserem Fall den Eckpunkten) definiert.</i> <br><br>  Wie in jedem anderen Raum k√∂nnen wir den Tangentenraum eines Scheitelpunkts mit drei Vektoren definieren: <strong>rechts</strong> , <strong>vorw√§rts</strong> und <strong>aufw√§rts</strong> .  Mit diesen Vektoren k√∂nnen wir eine Matrix erstellen, um den Grashalm von der Tangente in den lokalen Raum zu drehen. <br><br>  Sie k√∂nnen <strong>direkt</strong> und nach <strong>oben</strong> auf die Vektoren zugreifen, indem Sie neue Eingabescheitelpunktdaten hinzuf√ºgen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; ‚Ä¶ // Modify the vertex shader. vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; } ‚Ä¶ // Modify the input for the geometry shader. Note that the SV_POSITION semantic is removed. void geo(triangle vertexOutput IN[3], inout TriangleStream&lt;geometryOutput&gt; triStream) ‚Ä¶ // Modify the existing line declaring pos. float3 pos = IN[0].vertex;</span></span></code> </pre> <br>  Der dritte Vektor kann berechnet werden, indem das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vektorprodukt</a> zwischen zwei anderen genommen wird.  Ein Vektorprodukt gibt einen Vektor <strong>senkrecht</strong> zu zwei eingehenden Vektoren zur√ºck. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Place in the geometry shader, below the line declaring float3 pos. float3 vNormal = IN[0].normal; float4 vTangent = IN[0].tangent; float3 vBinormal = cross(vNormal, vTangent) * vTangent.w;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Warum wird das Ergebnis des Vektorprodukts mit der Koordinate der Tangente w multipliziert?</b> <div class="spoiler_text">  Beim Exportieren eines Netzes aus einem 3D-Editor sind in der Regel bereits Binormale (auch <em>Tangenten an zwei Punkte genannt</em> ) in den Netzdaten gespeichert.  Anstatt diese Binormale zu importieren, nimmt Unity einfach die Richtung jeder Binormale und weist sie der Koordinate der Tangente <strong>w zu</strong> .  Auf diese Weise k√∂nnen Sie Speicherplatz sparen und gleichzeitig das richtige Binormal wiederherstellen.  Eine ausf√ºhrliche Diskussion zu diesem Thema finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </div></div><br>  Mit allen drei Vektoren k√∂nnen wir eine Matrix f√ºr die Transformation zwischen tangentialen und lokalen R√§umen erstellen.  Wir werden jeden Scheitelpunkt des Grashalms mit dieser Matrix <code>UnityObjectToClipPos</code> , bevor <code>UnityObjectToClipPos</code> ihn an <code>UnityObjectToClipPos</code> , das einen Scheitelpunkt im lokalen Raum erwartet. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the lines declaring the three vectors. float3x3 tangentToLocal = float3x3( vTangent.x, vBinormal.x, vNormal.x, vTangent.y, vBinormal.y, vNormal.y, vTangent.z, vBinormal.z, vNormal.z );</span></span></code> </pre> <br>  Bevor wir die Matrix verwenden, √ºbertragen wir den Vertex-Ausgabecode an die Funktion, um nicht immer wieder dieselben Codezeilen zu schreiben.  Dies wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DRY-Prinzip bezeichnet</a> . <strong>Wiederholen Sie sich nicht</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. geometryOutput VertexOutput(float3 pos) { geometryOutput o; o.pos = UnityObjectToClipPos(pos); return o; } ‚Ä¶ // Remove the following from the geometry shader. //geometryOutput o; //o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0)); //triStream.Append(o); // ...and replace it with the code below. triStream.Append(VertexOutput(pos + float3(0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(-0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(0, 1, 0)));</span></span></code> </pre> <br>  Schlie√ülich multiplizieren wir die Ausgabescheitelpunkte mit der <code>tangentToLocal</code> Matrix und <code>tangentToLocal</code> sie korrekt an der Normalen ihres Eingabepunkts aus. <br><br><pre> <code class="cpp hljs">triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/3f8/286/c953f828675a9d4e202c0c9349d37f9d.png" alt="Bild"></div><br>  Dies ist eher das, was wir brauchen, aber nicht ganz richtig.  Das Problem hierbei ist, dass wir anfangs die Richtung ‚Äûup‚Äú (up) der <strong>Y-</strong> Achse zugewiesen haben;  Im Tangentenraum befindet sich die Aufw√§rtsrichtung jedoch normalerweise entlang der <strong>Z-</strong> Achse.  Jetzt werden wir diese √Ñnderungen vornehmen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the position of the third vertex being emitted. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1))));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/f51/ddb/0cff51ddbea12280cb78a1db9ada1786.png"></div><br><h2>  3. Aussehen von Gras </h2><br>  Damit die Dreiecke eher wie Grashalme aussehen, m√ºssen Sie Farben und Variationen hinzuf√ºgen.  Wir beginnen mit dem Hinzuf√ºgen eines <strong>Gef√§lles</strong> , das von der Spitze des Grashalms nach unten verl√§uft. <br><br><h3>  3.1 Farbverlauf </h3><br>  Unser Ziel ist es, dem K√ºnstler zu erm√∂glichen, zwei Farben einzustellen - oben und unten, und zwischen diesen beiden Farben zu interpolieren, die er auf die Basis des Grashalms kippt.  Diese Farben sind in der Shader-Datei bereits als <code>_TopColor</code> und <code>_BottomColor</code> .  F√ºr die ordnungsgem√§√üe Abtastung m√ºssen Sie die <strong>UV-Koordinaten</strong> an den Fragment-Shader √ºbergeben. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. float2 uv : TEXCOORD0; ‚Ä¶ // Modify the VertexOutput function signature. geometryOutput VertexOutput(float3 pos, float2 uv) ‚Ä¶ // Add to VertexOutput, just below the line assigning o.pos. o.uv = uv; ‚Ä¶ // Modify the existing lines in the geometry shader. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br>  Wir haben UV-Koordinaten f√ºr einen Grashalm in Form eines Dreiecks erstellt, dessen zwei Eckpunkte sich unten links und rechts befinden und dessen Spitzenscheitelpunkt in der Mitte oben liegt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/165/e39/932/165e399323aaa07e7c4cee728c0c9988.png"></div><br>  <i>UV-Koordinaten der drei Eckpunkte der Grashalme.</i>  <i>Obwohl wir die Grashalme mit einem einfachen Farbverlauf bemalen, k√∂nnen Sie mit einer √§hnlichen Anordnung von Texturen Texturen √ºberlagern.</i> <br><br>  Jetzt k√∂nnen wir die oberen und unteren Farben im Fragment-Shader mit UV <code>lerp</code> und sie dann mit <code>lerp</code> interpolieren.  Wir m√ºssen auch die Parameter des Fragment- <code>float4</code> √§ndern und <code>geometryOutput</code> als Eingabe und nicht nur die Position von <code>float4</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the function signature of the fragment shader. float4 frag (geometryOutput i, fixed facing : VFACE) : SV_Target ‚Ä¶ // Replace the existing return call. return float4(1, 1, 1, 1); return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/510/51f/59651051f474907a88740e83bc9d4532.png"></div><br><h3>  3.2 Zuf√§llige Blattrichtung </h3><br>  Um Variabilit√§t zu erzeugen und dem Gras ein nat√ºrlicheres Aussehen zu verleihen, lassen wir jeden Grashalm in eine zuf√§llige Richtung schauen.  Dazu m√ºssen wir eine Rotationsmatrix erstellen, die den Grashalm zuf√§llig um seine <strong>obere</strong> Achse dreht. <br><br>  Die Shader-Datei enth√§lt zwei Funktionen, die uns dabei helfen: <code>rand</code> , das aus dreidimensionalen Eingaben eine Zufallszahl generiert, und <code>AngleAxis3x3</code> , das den Winkel (im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bogenma√ü</a> ) empf√§ngt und eine Matrix zur√ºckgibt, die diesen Wert um die angegebene Achse dreht.  Die letztere Funktion funktioniert genauso wie die C # <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quaternion.AngleAxis-</a> Funktion (nur <code>AngleAxis3x3</code> gibt eine Matrix zur√ºck, keine Quaternion). <br><br>  Die <code>rand</code> Funktion gibt eine Zahl im Bereich 0 ... 1 zur√ºck.  Wir multiplizieren es mit <strong>2 Pi</strong> , um den gesamten Bereich der Winkelwerte zu erhalten. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring the tangentToLocal matrix. float3x3 facingRotationMatrix = AngleAxis3x3(rand(pos) * UNITY_TWO_PI, float3(0, 0, 1));</span></span></code> </pre> <br>  Wir verwenden die eingehende Positionsposition als Startwert f√ºr eine zuf√§llige Rotation.  Aus diesem Grund hat jeder Grashalm seine eigene Rotation, die in jedem Rahmen konstant ist. <br><br>  Die Drehung kann auf den Grashalm angewendet werden, indem er mit der erstellten <code>tangentToLocal</code> Matrix <code>tangentToLocal</code> wird.  Beachten Sie, dass die Matrixmultiplikation <strong>nicht</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kommutativ ist</a> .  Die Reihenfolge der Operanden ist <strong>wichtig</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring facingRotationMatrix. float3x3 transformationMatrix = mul(tangentToLocal, facingRotationMatrix); ‚Ä¶ // Replace the multiplication matrix operand with our new transformationMatrix. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09f/c2f/e80/09fc2fe8028b51f78989954e65812cd3.png"></div><br><h3>  3.3 Zuf√§lliges Vorw√§rtsbiegen </h3><br>  Wenn alle Grashalme perfekt ausgerichtet sind, sehen sie gleich aus.  Dies mag f√ºr gepflegtes Gras geeignet sein, zum Beispiel auf einem gepflegten Rasen, aber in der Natur w√§chst das Gras nicht so.  Wir werden eine neue Matrix erstellen, um das Gras entlang der <strong>X-</strong> Achse zu drehen, sowie eine Eigenschaft, um diese Drehung zu steuern. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _BendRotationRandom("Bend Rotation Random", Range(0, 1)) = 0.2 ‚Ä¶ // Add to the CGINCLUDE block. float _BendRotationRandom; ‚Ä¶ // Add to the geometry shader, below the line declaring facingRotationMatrix. float3x3 bendRotationMatrix = AngleAxis3x3(rand(pos.zzx) * _BendRotationRandom * UNITY_PI * 0.5, float3(-1, 0, 0));</span></span></code> </pre> <br>  Wieder verwenden wir die Position des Grashalms als zuf√§lligen Samen, diesmal indem wir ihn <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fegen</a> , um einen einzigartigen Samen zu erzeugen.  Wir werden auch <code>UNITY_PI</code> mit <strong>0,5</strong> multiplizieren;  Dies gibt uns ein zuf√§lliges Intervall von 0 ... 90 Grad. <br><br>  Wir wenden diese Matrix erneut durch Rotation an und multiplizieren alles in der richtigen Reihenfolge. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line. float3x3 transformationMatrix = mul(mul(tangentToLocal, facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49c/122/534/49c122534d7298c0f9c646501a708daa.gif"></div><br><h3>  3.4 Breite und H√∂he </h3><br>  W√§hrend die Gr√∂√üe des Grashalms auf eine Breite von 1 Einheit und eine H√∂he von 1 Einheit begrenzt ist.  Wir werden Eigenschaften hinzuf√ºgen, um die Gr√∂√üe zu steuern, sowie Eigenschaften, um zuf√§llige Variationen hinzuzuf√ºgen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeWidth("Blade Width", Float) = 0.05 _BladeWidthRandom("Blade Width Random", Float) = 0.02 _BladeHeight("Blade Height", Float) = 0.5 _BladeHeightRandom("Blade Height Random", Float) = 0.3 ‚Ä¶ // Add to the CGINCLUDE block. float _BladeHeight; float _BladeHeightRandom; float _BladeWidth; float _BladeWidthRandom; ‚Ä¶ // Add to the geometry shader, above the triStream.Append calls. float height = (rand(pos.zyx) * 2 - 1) * _BladeHeightRandom + _BladeHeight; float width = (rand(pos.xzy) * 2 - 1) * _BladeWidthRandom + _BladeWidth; ‚Ä¶ // Modify the existing positions with our new height and width. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-width, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, height)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35b/22e/f34/35b22ef34945a576100a152a0e25eec5.png"></div><br>  Dreiecke sind jetzt viel mehr wie Grashalme, aber auch zu wenig.  Es gibt einfach nicht genug Spitzen im eingehenden Netz, um den Eindruck eines dicht bewachsenen Feldes zu erwecken. <br><br>  Eine L√∂sung besteht darin, ein neues, dichteres Netz zu erstellen, entweder mit C # oder in einem 3D-Editor.  Dies wird funktionieren, aber es wird uns nicht erm√∂glichen, die Dichte des Grases dynamisch zu steuern.  Stattdessen teilen wir das eingehende Netz mithilfe der <strong>Tessellation auf</strong> . <br><br><h2>  4. Tessellation </h2><br>  <strong>Die Tessellation</strong> ist eine optionale Phase der Rendering-Pipeline, die nach dem Vertex-Shader und vor dem geometrischen Shader (falls vorhanden) ausgef√ºhrt wird.  Seine Aufgabe ist es, eine eingehende Oberfl√§che in viele Grundelemente zu unterteilen.  Die Tessellation wird in zwei programmierbaren Schritten implementiert: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hull-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Domain-</a> Shader. <br><br>  F√ºr Oberfl√§chen-Shader verf√ºgt Unity √ºber eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">integrierte Tessellierungsimplementierung</a> .  Da wir <strong>jedoch keine</strong> Oberfl√§chen-Shader verwenden, m√ºssen wir unsere eigenen Shell- und Domain-Shader implementieren.  In diesem Artikel werde ich die Implementierung von Tessellation nicht im Detail diskutieren, und wir verwenden einfach die vorhandene Datei <code>CustomTessellation.cginc</code> .  Diese Datei wurde aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Catlike Coding √ºbernommen</a> , der eine hervorragende Informationsquelle zur Implementierung von Tessellation in Unity darstellt. <br><br>  Wenn wir das <code>TessellationExample</code> Objekt in die Szene aufnehmen, werden wir feststellen, dass es bereits Material enth√§lt, das die Tessellation implementiert.  Das √Ñndern der Eigenschaft <strong>Tessellation Uniform</strong> zeigt den Unterteilungseffekt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d8/8a7/f01/2d88a7f01e3a7462ffd0c8f20953b5ca.gif"></div><br>  Wir implementieren eine Tessellation im Grasshader, um die Dichte des Flugzeugs und damit die Anzahl der erzeugten Grashalme zu steuern.  Zuerst m√ºssen Sie die Datei <code>CustomTessellation.cginc</code> hinzuf√ºgen.  Wir werden es durch seinen <em>relativen</em> Pfad zum Shader bezeichnen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block, below the other #include statements. #include "Shaders/CustomTessellation.cginc"</span></span></code> </pre> <br>  Wenn Sie <code>CustomTessellation.cginc</code> √∂ffnen, werden Sie feststellen, dass darin bereits <code>vertexInput</code> und <code>vertexOutput</code> sowie Vertex-Shader definiert sind.  Sie m√ºssen sie in unserem Grasshader nicht neu definieren.  Sie k√∂nnen gel√∂scht werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; }*/</span></span></code> </pre> <br>  Beachten Sie, dass der <code>vert</code> Vertex-Shader in <code>CustomTessellation.cginc</code> die Eingabe einfach direkt an die Tessellation-Stufe √ºbergibt.  Die im Domain-Shader <code>vertexOutput</code> Funktion <code>vertexOutput</code> √ºbernimmt die Erstellung der <code>vertexOutput</code> Struktur. <br><br>  Jetzt k√∂nnen wir dem Grassader Shader- und <strong>Domain-</strong> Shader hinzuf√ºgen.  Wir werden auch eine neue <code>_TessellationUniform</code> Eigenschaft hinzuf√ºgen, um die Einheitengr√∂√üe zu steuern. Die dieser Eigenschaft entsprechende Variable wurde bereits in <code>CustomTessellation.cginc</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _TessellationUniform("Tessellation Uniform", Range(1, 64)) = 1 ‚Ä¶ // Add below the other #pragma statements in the SubShader Pass. #pragma hull hull #pragma domain domain</span></span></code> </pre> <br>  Durch √Ñndern der Eigenschaft <strong>Tessellation Uniform</strong> k√∂nnen wir nun die Dichte des Grases steuern.  Ich fand heraus, dass mit einem Wert von <strong>5</strong> gute Ergebnisse erzielt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/280/d93/c14/280d93c1420a9744bd56f2d2496f96ab.gif"></div><br><h2>  5. Der Wind </h2><br>  Wir implementieren den Wind, indem wir die <strong>Verzerrungstextur</strong> abtasten.  Diese Textur sieht aus wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine normale Karte</a> , nur gibt es nur zwei statt drei Kan√§le.  Wir werden diese beiden Kan√§le als Windrichtungen entlang <strong>X</strong> und <strong>Y verwenden.</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a58/aaa/687/a58aaa68742934ff1bddf1cbaf9564f5.png"></div><br>  Bevor wir die Windtextur abtasten, m√ºssen wir eine UV-Koordinate erstellen.  Anstatt die dem Netz zugewiesenen Texturkoordinaten zu verwenden, wenden wir die Position des eingehenden Punkts an.  Wenn es auf der Welt mehrere Grasmaschen gibt, entsteht die Illusion, dass sie alle Teil desselben Windsystems sind.  Wir verwenden auch die <code>_Time</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Variable</a> <code>_Time</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shader,</a> um die <code>_Time</code> entlang der Grasoberfl√§che zu scrollen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _WindDistortionMap("Wind Distortion Map", 2D) = "white" {} _WindFrequency("Wind Frequency", Vector) = (0.05, 0.05, 0, 0) ‚Ä¶ // Add to the CGINCLUDE block. sampler2D _WindDistortionMap; float4 _WindDistortionMap_ST; float2 _WindFrequency; ‚Ä¶ // Add to the geometry shader, just above the line declaring the transformationMatrix. float2 uv = pos.xz * _WindDistortionMap_ST.xy + _WindDistortionMap_ST.zw + _WindFrequency * _Time.y;</span></span></code> </pre> <br>  Wir wenden die Skalierung und den Versatz von <code>_WindDistortionMap</code> auf die Position an und verschieben sie dann weiter auf <code>_Time.y</code> , skaliert auf <code>_WindFrequency</code> .  Jetzt werden wir diese UVs verwenden, um die Textur abzutasten und eine Eigenschaft zu erstellen, um die St√§rke des Windes zu steuern. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _WindStrength("Wind Strength", Float) = 1 ‚Ä¶ // Add to the CGINCLUDE block. float _WindStrength; ‚Ä¶ // Add below the line declaring float2 uv. float2 windSample = (tex2Dlod(_WindDistortionMap, float4(uv, 0, 0)).xy * 2 - 1) * _WindStrength;</span></span></code> </pre> <br>  Beachten Sie, dass wir den abgetasteten Wert von der Textur vom Intervall 0 ... 1 bis zum Intervall -1 ... 1 skalieren.  Als n√§chstes k√∂nnen wir einen normalisierten Vektor erzeugen, der die Windrichtung angibt. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float2 windSample. float3 wind = normalize(float3(windSample.x, windSample.y, 0));</span></span></code> </pre> <br>  Jetzt k√∂nnen wir eine Matrix erstellen, um diesen Vektor zu drehen und mit unserer <code>transformationMatrix</code> multiplizieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3 wind. float3x3 windRotation = AngleAxis3x3(UNITY_PI * windSample, wind); ‚Ä¶ // Modify the existing line. float3x3 transformationMatrix = mul(mul(mul(tangentToLocal, windRotation), facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br>  Schlie√ülich √ºbertragen wir die Windtextur (an der Wurzel des Projekts) in das Feld <strong>Wind Distortion Map</strong> des Grasmaterials im Unity-Editor.  Wir setzen auch den <strong>Tiling-</strong> Parameter der Textur auf <code>0.01, 0.01</code> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Wenn das Gras im Szenenfenster nicht animiert wird, klicken Sie auf die <strong>Schaltfl√§che Skybox, Nebel und verschiedene andere Effekte</strong> umschalten, um animierte Materialien zu aktivieren. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus der Ferne sieht das Gras richtig aus, aber wenn wir uns den Grashalm genau ansehen, stellen wir fest, dass sich der gesamte Grashalm dreht, weshalb die Basis nicht mehr am Boden befestigt ist. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/148/51e/6e914851e888c448c30080a7abefae33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Basis des Grashalms ist nicht mehr am Boden befestigt, sondern schneidet ihn ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rot dargestellt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und h√§ngt √ºber der Bodenebene (angezeigt durch die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gr√ºne</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linie). </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden dies beheben, indem wir eine zweite Transformationsmatrix definieren, die nur f√ºr zwei Eckpunkte der Basis gilt. </font><font style="vertical-align: inherit;">In dieser Matrix </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht werden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enthalten Matrix </font></font><code>windRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>bendRotationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank, auf dem die Basis auf die Grasfl√§che angebracht ist.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3x3 transformationMatrix. float3x3 transformationMatrixFacing = mul(tangentToLocal, facingRotationMatrix); ‚Ä¶ // Modify the existing lines outputting the base vertex positions. triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(-width, 0, 0)), float2(1, 0)));</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Kr√ºmmung der Grashalme </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden einzelne Grashalme durch ein Dreieck definiert. In gro√üen Entfernungen ist dies kein Problem, aber in der N√§he des Grashalms sehen sie eher sehr steif und geometrisch aus als organisch und lebhaft. Wir werden dies beheben, indem wir Grashalme aus mehreren Dreiecken bauen und sie entlang der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurve biegen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder Grashalm wird in mehrere </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segmente unterteilt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jedes Segment hat eine rechteckige Form und besteht aus zwei Dreiecken, mit Ausnahme des oberen Segments - es ist ein Dreieck, das die Spitze des Grashalms bezeichnet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir nur drei Eckpunkte gezeichnet und so ein einziges Dreieck erstellt. Woher wei√ü der geometrische Shader dann, wenn es mehr Eckpunkte gibt, welche zu verbinden und Dreiecke zu bilden sind? Die Antwort liegt in der Datenstruktur</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dreiecksstreifen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die ersten drei Scheitelpunkte verbinden sich und bilden ein Dreieck, und jeder neue Scheitelpunkt bildet mit den beiden vorherigen ein Dreieck.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/871/8ec/676/8718ec676d7efd819718bd25d5b27b54.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein unterteilter Grashalm, der als Dreiecksstreifen dargestellt wird und jeweils einen Scheitelpunkt erstellt. Nach den ersten drei Scheitelpunkten bildet jeder neue Scheitelpunkt mit den beiden vorherigen Scheitelpunkten ein neues Dreieck.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist nicht nur effizienter in Bezug auf die Speichernutzung, sondern erm√∂glicht es Ihnen auch, einfach und schnell Dreieckssequenzen in Ihrem Code zu erstellen. Wenn wir mehrere Dreiecksstreifen erstellen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">m√∂chten</font></a><font style="vertical-align: inherit;"> , k√∂nnen wir </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">RestartStrip</font></a><font style="vertical-align: inherit;"> f√ºr die </font></font><code>TriangleStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bevor wir beginnen, mehr Scheitelpunkte aus dem geometrischen Shader zu zeichnen, m√ºssen wir ihn vergr√∂√üern </font><font style="vertical-align: inherit;">. Wir werden das Design verwenden </font><font style="vertical-align: inherit;">, damit der Shader-Autor die Anzahl der Segmente steuern und die Anzahl der angezeigten Scheitelpunkte daraus berechnen kann.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>maxvertexcount</code><font style="vertical-align: inherit;"></font><code>#define</code><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. #define BLADE_SEGMENTS 3 ‚Ä¶ // Modify the existing line defining the maxvertexcount. [maxvertexcount(BLADE_SEGMENTS * 2 + 1)]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst setzen wir die Anzahl der Segmente auf </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und aktualisieren </font></font><code>maxvertexcount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Anzahl der Scheitelpunkte basierend auf der Anzahl der Segmente zu berechnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um einen segmentierten Grashalm zu erstellen, verwenden wir einen Zyklus </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jede Iteration der Schleife f√ºgt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei Eckpunkte hinzu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">links</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rechts</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nach Abschluss der Spitze f√ºgen wir den letzten Scheitelpunkt an der Spitze des Grashalms hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir dies tun, ist es n√ºtzlich, einen Teil der Rechenposition der Eckpunkte der Grashalme des Codes in die Funktion zu verschieben, da wir diesen Code innerhalb und au√üerhalb der Schleife mehrmals verwenden. F√ºgen Sie dem Block </font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgendes hinzu:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">geometryOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGrassVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 vertexPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, float2 uv, float3x3 transformMatrix)</span></span></span><span class="hljs-function"> </span></span>{ float3 tangentPoint = float3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, height); float3 localPosition = vertexPosition + mul(transformMatrix, tangentPoint); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VertexOutput(localPosition, uv); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Funktion f√ºhrt dieselben Aufgaben aus, da sie die Argumente √ºbergibt, die wir zuvor √ºbergeben haben </font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Eckpunkte des Grashalms zu generieren. </font><font style="vertical-align: inherit;">Wenn Sie eine Position, H√∂he und Breite erhalten, transformiert es den Scheitelpunkt mithilfe der √ºbertragenen Matrix korrekt und weist ihm eine UV-Koordinate zu. </font><font style="vertical-align: inherit;">Wir werden den vorhandenen Code aktualisieren, damit die Funktion ordnungsgem√§√ü funktioniert.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the existing code outputting the vertices. triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion hat ordnungsgem√§√ü funktioniert und wir sind bereit, den Vertex-Generierungscode in die Schleife zu verschieben </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºgen Sie unter der Zeile </font></font><code>float width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgendes </font><font style="vertical-align: inherit;">hinzu </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; BLADE_SEGMENTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = i / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)BLADE_SEGMENTS; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√ºndigen einen Zyklus an, der f√ºr jeden Grashalmsegment einmal ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">F√ºgen Sie innerhalb der Schleife eine Variable hinzu </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Variable speichert einen Wert im Bereich von 0 bis 1, der angibt, wie weit wir uns entlang des Grashalms bewegt haben. </font><font style="vertical-align: inherit;">Wir verwenden diesen Wert, um die Breite und H√∂he des Segments in jeder Iteration der Schleife zu berechnen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float t. float segmentHeight = height * t; float segmentWidth = width * (1 - t);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie einen Grashalm nach oben bewegen, nimmt die H√∂he zu und die Breite ab. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir der Schleife Aufrufe </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hinzuf√ºgen, um dem Dreiecksstrom Scheitelpunkte hinzuzuf√ºgen. </font><font style="vertical-align: inherit;">Wir werden auch einen Aufruf </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au√üerhalb der Schleife </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">, um die Spitze des Grashalms zu erzeugen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float segmentWidth. float3x3 transformMatrix = i == 0 ? transformationMatrixFacing : transformationMatrix; triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, float2(1, t), transformMatrix)); ‚Ä¶ // Add just below the loop to insert the vertex at the tip of the blade. triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix)); ‚Ä¶ // Remove the existing calls to triStream.Append. //triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen Sie sich die Zeile mit der Deklaration an </font></font><code>float3x3 transformMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- hier w√§hlen wir eine von zwei Transformationsmatrizen aus: Wir nehmen </font></font><code>transformationMatrixFacing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr die Eckpunkte der Basis und </font></font><code>transformationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr alle anderen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/211/61c/02b21161cd4afc0cca35ae71ffe2570e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grashalme sind jetzt in viele Segmente unterteilt, aber die Blattoberfl√§che ist immer noch flach - neue Dreiecke sind noch nicht beteiligt. </font><font style="vertical-align: inherit;">Wir werden ein Grashalm Kr√ºmmung hinzuf√ºgen, um </font><font style="vertical-align: inherit;">die Position des Scheitels der Verschiebung </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Zuerst m√ºssen wir die Funktion </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so </font><font style="vertical-align: inherit;">√§ndern </font><font style="vertical-align: inherit;">, dass sie einen Offset in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erh√§lt </font><font style="vertical-align: inherit;">, den wir aufrufen werden </font></font><code>forward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the function signature of GenerateGrassVertex. geometryOutput GenerateGrassVertex(float3 vertexPosition, float width, float height, float forward, float2 uv, float3x3 transformMatrix) ‚Ä¶ // Modify the Y coordinate assignment of tangentPoint. float3 tangentPoint = float3(width, forward, height);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Verschiebung jedes Scheitelpunkts zu berechnen, setzen wir einen </font></font><code>pow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert </font><font style="vertical-align: inherit;">in die Funktion ein </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nach dem Anheben </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf eine Kraft ist ihre Auswirkung auf die Vorw√§rtsverschiebung </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nichtlinear</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und verwandelt den Grashalm in eine Kurve.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeForward("Blade Forward Amount", Float) = 0.38 _BladeCurve("Blade Curvature Amount", Range(1, 4)) = 2 ‚Ä¶ // Add to the CGINCLUDE block. float _BladeForward; float _BladeCurve; ‚Ä¶ // Add inside the geometry shader, below the line declaring float width. float forward = rand(pos.yyz) * _BladeForward; ‚Ä¶ // Add inside the loop, below the line declaring segmentWidth. float segmentForward = pow(t, _BladeCurve) * forward; ‚Ä¶ // Modify the GenerateGrassVertex calls inside the loop. triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, segmentForward, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, segmentForward, float2(1, t), transformMatrix)); ‚Ä¶ // Modify the GenerateGrassVertex calls outside the loop. triStream.Append(GenerateGrassVertex(pos, 0, height, forward, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein ziemlich gro√üer Code, aber alle Arbeiten werden √§hnlich ausgef√ºhrt wie f√ºr die Breite und H√∂he des Grashalms. </font><font style="vertical-align: inherit;">Bei niedrigeren Werten </font></font><code>_BladeForward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und </font></font><code>_BladeCurve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bekommen wir einen geordnete, gepflegten Rasen, und gr√∂√üere Werte der entgegengesetzte Wirkung.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/cbc/e43/c1fcbce43fa5e1c1be319dc1f5190f3d.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Licht und Schatten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als letzten Schritt zur Vervollst√§ndigung des Shaders werden wir die M√∂glichkeit hinzuf√ºgen </font><strong><font style="vertical-align: inherit;">,</font></strong><font style="vertical-align: inherit;"> Schatten </font><font style="vertical-align: inherit;">zu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werfen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und zu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empfangen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir werden auch eine einfache Beleuchtung von der Hauptlichtquelle hinzuf√ºgen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.1 Schatten werfen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Schatten in Unity zu werfen, m√ºssen Sie dem Shader einen zweiten Durchgang hinzuf√ºgen. Diese Passage wird von den schattenerzeugenden Lichtquellen in der Szene verwendet, um die Tiefe des Grases in ihre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schattenkarte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu rendern </font><font style="vertical-align: inherit;">. Dies bedeutet, dass der geometrische Shader im Schattengang gestartet werden muss, damit die Grashalme Schatten werfen k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der geometrische Shader in Bl√∂cken geschrieben ist </font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, k√∂nnen wir ihn in beliebigen Durchl√§ufen der Datei verwenden. Erstellen Sie einen zweiten Durchgang, der dieselben Shader wie der erste verwendet, mit Ausnahme des Fragment-Shaders. Wir definieren einen neuen, in den wir ein Makro schreiben, das die Ausgabe verarbeitet.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the existing Pass. Pass { Tags { "LightMode" = "ShadowCaster" } CGPROGRAM #pragma vertex vert #pragma geometry geo #pragma fragment frag #pragma hull hull #pragma domain domain #pragma target 4.6 #pragma multi_compile_shadowcaster float4 frag(geometryOutput i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neben der Erstellung eines neuen Fragment-Shaders gibt es in dieser Passage einige wichtige Unterschiede. </font><font style="vertical-align: inherit;">Die Beschriftung </font><font style="vertical-align: inherit;">ist nicht </font></font><code>LightMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wichtig </font><font style="vertical-align: inherit;">- dies sagt Unity, dass diese Passage verwendet werden sollte, um das Objekt in Schattenkarten zu rendern. </font><font style="vertical-align: inherit;">Hier gibt es auch eine Pr√§prozessor-Direktive </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es stellt sicher, dass der Shader alle erforderlichen Optionen kompiliert, um Schatten zu werfen. </font><font style="vertical-align: inherit;">Lassen Sie </font><font style="vertical-align: inherit;">uns ein Spiel Objekt machen , </font><font style="vertical-align: inherit;">ist </font><strong><font style="vertical-align: inherit;">aktiv</font></strong><font style="vertical-align: inherit;"> in der Szene; </font><font style="vertical-align: inherit;">So erhalten wir eine Oberfl√§che, auf die die Grashalme einen Schatten werfen k√∂nnen.</font></font><code>ShadowCaster</code><font style="vertical-align: inherit;"></font><code>ForwardBase</code><font style="vertical-align: inherit;"></font><code>multi_compile_shadowcaster</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>Fence</code> <strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c57/640/6cf/c576406cf284fe41e4b04d8af264d96e.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.2 Schatten bekommen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem Unity die Schattenkarte aus der Sicht der Lichtquelle gerendert hat, die den Schatten erzeugt, wird eine Passage gestartet, die die Schatten in der Textur des </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bildschirmbereichs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "sammelt" </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um diese Textur abzutasten, m√ºssen wir die Positionen der Scheitelpunkte im Bildschirmbereich berechnen und an den Fragment-Shader √ºbertragen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. unityShadowCoord4 _ShadowCoord : TEXCOORD1; ‚Ä¶ // Add to the VertexOutput function, just above the return call. o._ShadowCoord = ComputeScreenPos(o.pos);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Fragment-Shader der Passage k√∂nnen </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir ein Makro verwenden, um einen Wert zu erhalten, der </font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angibt, ob sich die Oberfl√§che im Schatten befindet oder nicht. </font><font style="vertical-align: inherit;">Dieser Wert liegt im Bereich von 0 bis 1, wobei 0 f√ºr vollst√§ndige Schattierung und 1 f√ºr vollst√§ndige Beleuchtung steht.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum hei√üt die UV-Koordinate des Bildschirmbereichs _ShadowCoord? </font><font style="vertical-align: inherit;">Dies entspricht nicht den vorherigen Namenskonventionen.</font></font></b> <div class="spoiler_text">    Unity           (       ).          <code>SHADOW_ATTENUATION</code> .         <code>Autolight.cginc</code> ,  ,       . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SHADOW_ATTENUATION(a) unitySampleShadow(a._ShadowCoord)</span></span></code> </pre> <br>              -    ,            . </div></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's fragment shader, replacing the existing return call. return SHADOW_ATTENUATION(i); //return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich m√ºssen wir den Shader richtig konfigurieren, um Schatten zu empfangen. </font><font style="vertical-align: inherit;">Zu diesem Zweck f√ºgen wir dem Pass eine </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√§prozessor-Direktive hinzu, damit alle erforderlichen Shader-Optionen kompiliert werden.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's preprocessor directives, below #pragma target 4.6. #pragma multi_compile_fwdbase</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90a/491/468/90a491468a1ad129d35bea03b0b51898.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Kamera n√§her gebracht haben, k√∂nnen wir Artefakte auf der Oberfl√§che der Grashalme feststellen. </font><font style="vertical-align: inherit;">Sie werden durch die Tatsache verursacht, dass einzelne Grashalme Schatten auf sich selbst werfen. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies beheben, indem wir eine </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lineare Verschiebung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anwenden </font><font style="vertical-align: inherit;">oder die Positionen der Scheitelpunkte im K√ºrzungsraum etwas vom Bildschirm weg verschieben. </font><font style="vertical-align: inherit;">Wir werden das Unity-Makro daf√ºr verwenden und es in das Design </font></font><code>#if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einbeziehen, sodass die Operation nur im Schattenpfad ausgef√ºhrt wird.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add at the end of the VertexOutput function, just above the return call. #if UNITY_PASS_SHADOWCASTER // Applying the bias prevents artifacts from appearing on the surface. o.pos = UnityApplyLinearShadowBias(o.pos); #endif</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dca/ec0/d88/dcaec0d88eea1893b6a07eb45724a0b6.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Anwenden der linearen Schattenverschiebung verschwinden Schattenartefakte in Form von Streifen von der Oberfl√§che der Dreiecke.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum gibt es Artefakte an den R√§ndern der schattierten Grashalme?</font></font></b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08a/12e/af1/08a12eaf1af17fc9b35de7d07a64afca.png"></div><br>      (multisample anti-aliasing <strong>MSAA</strong> ) Unity <em> </em>     ,        .        ,  . <br><br>    ‚Äî  ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  Unity</a> .      (     );     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    Unity</a> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.3 Beleuchtung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden die Beleuchtung mit einem sehr einfachen und gebr√§uchlichen Berechnungsalgorithmus f√ºr diffuses Licht implementieren.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/3ae/452/4043ae452046c0b4b405aa88afe8d2b7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... wobei </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Normale zur Oberfl√§che ist, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die normalisierte Richtung der Hauptlichtquelle ist und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die berechnete Beleuchtung ist. </font><font style="vertical-align: inherit;">In diesem Tutorial </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird keine</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indirekte Beleuchtung implementiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Moment sind den Spitzen der Grashalme keine Normalen zugeordnet. </font><font style="vertical-align: inherit;">Wie bei Scheitelpunktpositionen berechnen wir zuerst die Normalen im </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tangentenraum</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und konvertieren sie dann in lokale. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schaufelkr√ºmmung Betrag</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird auf </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die </font><font style="vertical-align: inherit;">alle das Gras im Tangentenraum in der gleichen Richtung: das Gegenteil von der Achse </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Als ersten Durchgang unserer L√∂sung berechnen wir die Normalen unter der Annahme, dass keine Kr√ºmmung vorliegt.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the GenerateGrassVertex function, belowing the line declaring tangentPoint. float3 tangentNormal = float3(0, -1, 0); float3 localNormal = mul(transformMatrix, tangentNormal);</span></span></code> </pre> <br> <code>tangentNormal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, definiert als direkt gegen√ºber der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Achse </font><font style="vertical-align: inherit;">, wird durch dieselbe Matrix transformiert, mit der wir die Tangentenpunkte in den lokalen Raum konvertiert haben. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir es an eine Funktion </font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und dann an eine Struktur √ºbergeben </font></font><code>geometryOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the return call in GenerateGrassVertex. return VertexOutput(localPosition, uv, localNormal); ‚Ä¶ // Add to the geometryOutput struct. float3 normal : NORMAL; ‚Ä¶ // Modify the existing function signature. geometryOutput VertexOutput(float3 pos, float2 uv, float3 normal) ‚Ä¶ // Add to the VertexOutput function to pass the normal through to the fragment shader. o.normal = UnityObjectToWorldNormal(normal);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass wir vor dem Abschluss das Normale in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Weltraum</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwandeln </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Einheit vermittelt den Shadern die Richtung der Hauptquelle des gerichteten Lichts im Weltraum, daher ist diese Transformation notwendig. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Normalen im Shader-Fragment visualisieren </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um das Ergebnis unserer Arbeit zu √ºberpr√ºfen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader. float3 normal = facing &gt; 0 ? i.normal : -i.normal; return float4(normal * 0.5 + 0.5, 1); // Remove the existing return call. //return SHADOW_ATTENUATION(i);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da in unserem Shader ein </font></font><code>Cull</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert zugewiesen ist </font></font><code>Off</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, werden beide Seiten des Grashalms gerendert. </font><font style="vertical-align: inherit;">Damit die Normalen in die richtige Richtung gerichtet werden, verwenden wir einen Hilfsparameter </font></font><code>VFACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, den wir dem Fragment-Shader hinzugef√ºgt haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Argument </font></font><code>fixed facing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">positive</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zahl zur√ºck, wenn wir die Vorderseite der Oberfl√§che anzeigen, und eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">negative</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zahl, wenn es das Gegenteil ist. </font><font style="vertical-align: inherit;">Wir verwenden dies im obigen Code, um bei Bedarf das Normale umzudrehen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/8ca/965/e1b8ca965ed8e80b539a9773d1adeb0c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blattkr√ºmmungsbetrag</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gr√∂√üer als 1 ist, wird die tangentiale </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position </font><font style="vertical-align: inherit;">jedes Scheitelpunkts um den </font></font><code>forward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an die Funktion √ºbergebenen </font><font style="vertical-align: inherit;">Betrag verschoben </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden diesen Wert verwenden, um die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Achse der </font><font style="vertical-align: inherit;">Normalen </font><font style="vertical-align: inherit;">proportional zu skalieren </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line in GenerateGrassVertex. float3 tangentNormal = normalize(float3(0, -1, forward));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie abschlie√üend den Code zum Fragment-Shader hinzu, um die Schatten, die gerichtete Beleuchtung und die Umgebungsbeleuchtung zu kombinieren. </font><font style="vertical-align: inherit;">Ich empfehle, in meinem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial zu Toon-Shadern</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> detailliertere Informationen zur Implementierung der benutzerdefinierten Beleuchtung in Shadern </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">zu lesen</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader, below the line declaring float3 normal. float shadow = SHADOW_ATTENUATION(i); float NdotL = saturate(saturate(dot(normal, _WorldSpaceLightPos0)) + _TranslucentGain) * shadow; float3 ambient = ShadeSH9(float4(normal, 1)); float4 lightIntensity = NdotL * _LightColor0 + float4(ambient, 1); float4 col = lerp(_BottomColor, _TopColor * lightIntensity, i.uv.y); return col; // Remove the existing return call. //return float4(normal * 0.5 + 0.5, 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/894/d14/c14894d14edc336b770f4b94bedd3708.png"></div><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Tutorial bedeckt Gras eine kleine Fl√§che von 10 x 10 Einheiten. </font><font style="vertical-align: inherit;">Damit der Shader gro√üe Freifl√§chen abdecken und gleichzeitig eine hohe Leistung erzielen kann, m√ºssen Optimierungen eingef√ºhrt werden. </font><font style="vertical-align: inherit;">Sie k√∂nnen die Tessellierung basierend auf der Entfernung anwenden, damit weniger Grashalme von der Kamera entfernt werden. </font><font style="vertical-align: inherit;">Dar√ºber hinaus k√∂nnen √ºber gro√üe Entfernungen anstelle einzelner Grashalme Gruppen von Grashalmen mit einem einzigen Viereck mit einer √ºberlagerten Textur gezeichnet werden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/a05/e86/5a7a05e8690c152f9196bb3c94fada19.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grasstruktur ist im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard Assets-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paket </font><font style="vertical-align: inherit;">der Unity Engine </font><font style="vertical-align: inherit;">enthalten </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Viele Grashalme werden auf ein Viereck gezeichnet, wodurch die Anzahl der Dreiecke in der Szene verringert wird. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir von Natur aus keine geometrischen Shader mit Oberfl√§chen-Shadern verwenden k√∂nnen, um die Funktionalit√§t von Beleuchtung und Schattierung zu verbessern oder zu erweitern, k√∂nnen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses GitHub-Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> studieren </font><font style="vertical-align: inherit;">, das die L√∂sung des Problems durch verz√∂gertes Rendern und manuelles F√ºllen von G-Puffern demonstriert. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shader-Quellcode im GitHub-Repository</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erg√§nzung: Zusammenarbeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne Interoperabilit√§t k√∂nnen Grafikeffekte f√ºr Spieler statisch oder leblos erscheinen. </font><font style="vertical-align: inherit;">Dieses Tutorial ist bereits sehr lang, daher habe ich keinen Abschnitt √ºber die Interaktion von Weltobjekten mit Gras hinzugef√ºgt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine naive Implementierung interaktiver Kr√§uter w√ºrde zwei Komponenten enthalten: etwas in der Spielwelt, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Daten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an den Shader √ºbertragen kann, um ihm mitzuteilen, mit welchem ‚Äã‚ÄãTeil des Grases interagiert wird, und Code im Shader, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diese Daten </font><font style="vertical-align: inherit;">zu </font><strong><font style="vertical-align: inherit;">interpretieren</font></strong><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel, wie dies mit Wasser umgesetzt werden kann, wird </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gezeigt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es kann angepasst werden, um mit Gras zu arbeiten; </font><font style="vertical-align: inherit;">Anstatt an der Stelle, an der sich der Charakter befindet, Wellen zu zeichnen, k√∂nnen Sie den Grashalm nach unten drehen, um die Auswirkungen von Schritten zu simulieren.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458060/">https://habr.com/ru/post/de458060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458046/index.html">Gradle Spickzettel</a></li>
<li><a href="../de458048/index.html">Delegation als Manager-Tool</a></li>
<li><a href="../de458050/index.html">Wie war der Mobius 2019 Piter (und ein bisschen √ºber den n√§chsten Mobius)</a></li>
<li><a href="../de458052/index.html">AMA mit Habr. 10. Letzte * Ausgabe</a></li>
<li><a href="../de458056/index.html">Das gro√üe Interview mit Martin Kleppmann: ‚ÄûDie Zukunft verteilter Datensysteme herausfinden‚Äú</a></li>
<li><a href="../de458062/index.html">√úbersicht √ºber die UserGate-Plattform</a></li>
<li><a href="../de458064/index.html">PVS-Studio in den Clouds - Ausf√ºhren der Analyse auf Travis CI</a></li>
<li><a href="../de458068/index.html">PVS-Studio f√ºr Visual Studio</a></li>
<li><a href="../de458070/index.html">PVS-Studio f√ºr Visual Studio</a></li>
<li><a href="../de458072/index.html">PVS-Studio geht in die Cloud - Starten Sie die Analyse auf Travis CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>