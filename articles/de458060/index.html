<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🔬 ✍🏼 ⚪️ Erstellen eines Grasshaders in der Unity-Engine 💟 Ⓜ️ 🍂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Tutorial erfahren Sie, wie Sie einen geometrischen Shader schreiben, um Grashalme aus den Spitzen des eingehenden Netzes zu generieren und d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Grasshaders in der Unity-Engine</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458060/"><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  In diesem Tutorial erfahren Sie, wie Sie einen geometrischen Shader schreiben, um Grashalme aus den Spitzen des eingehenden Netzes zu generieren und die Dichte des Grases mithilfe von Tessellation zu steuern. <br><br>  Der Artikel beschreibt den schrittweisen Prozess des Schreibens eines Grasshaders in Unity.  Der Shader empfängt das eingehende Netz und generiert aus jedem Scheitelpunkt des Netzes mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geometrischen Shaders</a> einen Grashalm.  Aus Gründen des Interesses und des Realismus haben die Grashalme eine <strong>zufällige Größe</strong> und <strong>Rotation</strong> und werden auch vom <strong>Wind beeinflusst</strong> .  Um die Dichte des Grases zu kontrollieren, verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tessellation</a> , um das eingehende Netz zu trennen.  Das Gras kann Schatten <strong>werfen</strong> und <strong>empfangen</strong> . <br><br>  <strong>Das fertige Projekt</strong> wird am Ende des Artikels veröffentlicht.  Die generierte Shader-Datei enthält eine große Anzahl von Kommentaren, die das Verständnis erleichtern. <br><a name="habracut"></a><br><h3>  Anforderungen </h3><br>  Um dieses Tutorial abzuschließen, benötigen Sie praktische Kenntnisse über die Unity-Engine und ein erstes Verständnis der Syntax und Funktionalität von Shadern. <br><br>  <a href="">Laden Sie den Entwurf des Projekts herunter (.zip)</a> . <br><br><h2>  An die Arbeit gehen </h2><br>  Laden Sie den Entwurf des Projekts herunter und öffnen Sie ihn im Unity-Editor.  Öffnen Sie die Hauptszene und dann den <code>Grass</code> Shader in Ihrem Code-Editor. <br><br>  Diese Datei enthält einen Shader, der weiße Farbe erzeugt, sowie einige Funktionen, die wir in diesem Tutorial verwenden werden.  Sie werden feststellen, dass diese Funktionen zusammen mit dem Vertex-Shader im <code>CGINCLUDE</code> Block <em>außerhalb von</em> <code>SubShader</code> .  Der in diesem Block platzierte Code wird <strong>automatisch in alle Durchgänge</strong> im Shader aufgenommen.  Dies wird später nützlich sein, da unser Shader mehrere Durchgänge hat. <br><br>  Wir beginnen mit dem Schreiben eines <strong>geometrischen Shaders</strong> , der aus jedem Scheitelpunkt auf der Oberfläche unseres Netzes Dreiecke generiert. <br><br><h2>  1. Geometrische Shader </h2><br>  Geometrische Shader sind ein optionaler Bestandteil der Rendering-Pipeline.  Sie werden <strong>nach dem</strong> Vertex-Shader (oder Tessellation-Shader, wenn Tessellation verwendet wird) und vor der Verarbeitung der Vertices für den Fragment-Shader ausgeführt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef7/c01/458/ef7c01458cadf7cd0cf46695d7114f96.jpg"></div><br>  <i>Direct3D Graphics Pipeline 11. Beachten Sie, dass in diesem Diagramm der Fragment-Shader als <em>Pixel-Shader bezeichnet wird</em> .</i> <br><br>  Geometrische Shader erhalten am Eingang ein einzelnes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundelement</a> und können null, ein oder mehrere Grundelemente erzeugen.  Wir beginnen mit dem Schreiben eines geometrischen Shaders, der einen <strong>Scheitelpunkt</strong> (oder <em>Punkt</em> ) an der Eingabe empfängt und <strong>ein Dreieck</strong> füttert, das <strong>einen</strong> Grashalm darstellt. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block. struct geometryOutput { float4 pos : SV_POSITION; }; [maxvertexcount(3)] void geo(triangle float4 IN[3] : SV_POSITION, inout TriangleStream&lt;geometryOutput&gt; triStream) { } … // Add inside the SubShader Pass, just below the #pragma fragment frag line. #pragma geometry geo</span></span></code> </pre> <br>  Der obige Code deklariert einen geometrischen Shader namens <code>geo</code> mit zwei Parametern.  Das erste <code>triangle float4 IN[3]</code> , dass ein Dreieck (bestehend aus drei Punkten) als Eingabe verwendet wird.  Der zweite, z. B. <code>TriangleStream</code> , richtet einen Shader für die Ausgabe eines Dreiecksstroms ein, sodass jeder Scheitelpunkt die <code>geometryOutput</code> Struktur zum Übertragen seiner Daten verwendet. <br><br><div class="spoiler">  <b class="spoiler_title">Wir haben oben gesagt, dass der Shader einen Scheitelpunkt erhält und einen Grashalm ausgibt.</b>  <b class="spoiler_title">Warum bekommen wir dann ein Dreieck?</b> <div class="spoiler_text">  Es ist weniger kostspielig, einen <code></code> als Eingabe zu nehmen.  Dies kann wie folgt erfolgen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">geo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point vertexOutput IN[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">], inout TriangleStream&lt;geometryOutput&gt; triStream)</span></span></span></span></code> </pre> <br>  Da unser eingehendes Netz (in diesem Fall <code>GrassPlane10x10</code> im Ordner "Netz") eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dreieckstopologie aufweist</a> , führt dies zu einer Nichtübereinstimmung zwischen der eingehenden Netz-Topologie und dem erforderlichen Eingabeprimitiv.  Obwohl dies in DirectX HLSL <strong>zulässig</strong> ist, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es in OpenGL</a> nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zulässig</a> , sodass ein Fehler angezeigt wird. </div></div><br>  Zusätzlich fügen wir den letzten Parameter in eckigen Klammern über der Funktionsdeklaration hinzu: <code>[maxvertexcount(3)]</code> .  Er teilt der GPU mit, dass wir <em>nicht mehr als</em> 3 Eckpunkte ausgeben werden (aber nicht müssen).  Wir lassen <code>SubShader</code> auch einen geometrischen Shader verwenden, indem wir ihn in <code>Pass</code> deklarieren. <br><br>  Unser geometrischer Shader macht noch nichts;  Fügen Sie zum Zeichnen eines Dreiecks den folgenden Code in den geometrischen Shader ein. <br><br><pre> <code class="cpp hljs">geometryOutput o; o.pos = float4(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0db/534/ac1/0db534ac10c125955829fd53b9923cd7.gif"></div><br>  Dies ergab sehr seltsame Ergebnisse.  Wenn Sie die Kamera bewegen, wird deutlich, dass das Dreieck im <strong>Bildschirmbereich</strong> gerendert <strong>wird</strong> .  Dies ist logisch: Da der geometrische Shader unmittelbar vor der Verarbeitung der Scheitelpunkte ausgeführt wird, entzieht er dem Scheitelpunkt-Shader die Verantwortung dafür, dass die Scheitelpunkte im <strong>Kürzungsbereich</strong> angezeigt <strong>werden</strong> .  Wir werden unseren Code ändern, um dies widerzuspiegeln. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the return call in the vertex shader. //return UnityObjectToClipPos(vertex); return vertex; … // Update each assignment of o.pos in the geometry shader. o.pos = UnityObjectToClipPos(float4(0.5, 0, 0, 1)); … o.pos = UnityObjectToClipPos(float4(-0.5, 0, 0, 1)); … o.pos = UnityObjectToClipPos(float4(0, 1, 0, 1));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/221/912/b3e/221912b3e6bc0581126a0f415b6e79c5.png"></div><br>  Jetzt ist unser Dreieck in der Welt richtig gerendert.  Es scheint jedoch, dass nur eine erstellt wird.  Tatsächlich wird für jeden Scheitelpunkt unseres Netzes ein Dreieck <em>gezeichnet</em> , aber die den Scheitelpunkten des Dreiecks zugewiesenen Positionen sind <strong>konstant</strong> - sie ändern sich nicht für jeden eingehenden Scheitelpunkt.  Daher befinden sich alle Dreiecke übereinander. <br><br>  Wir werden dies beheben, indem wir die Positionen der ausgehenden Scheitelpunkte relativ zum eingehenden Punkt versetzen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the top of the geometry shader. float3 pos = IN[0]; … // Update each assignment of o.pos. o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); … o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); … o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/ac4/84c/6b2ac484c5a033b18e88400e10191779.png"></div><br><div class="spoiler">  <b class="spoiler_title">Warum bilden einige Eckpunkte kein Dreieck?</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cab/447/d9c/cab447d9c4c82d8208a28e7cee2f7807.png"></div><br>  Obwohl wir festgestellt haben, dass das eingehende Grundelement ein <strong>Dreieck ist</strong> , wird ein Grashalm nur von <strong>einem</strong> der Punkte des Dreiecks übertragen, wobei die beiden anderen verworfen werden.  Natürlich können wir einen Grashalm von allen drei ankommenden Punkten übertragen, aber dies führt dazu, dass benachbarte Dreiecke übermäßig Grashalme übereinander bilden. <br><br>  Sie können dieses Problem auch lösen, indem Sie Netze mit dem Typ Topologiepunkte als eingehende Netze des geometrischen Shaders verwenden. </div></div><br>  Dreiecke werden jetzt korrekt gezeichnet und ihre Basis befindet sich an der Spitze, die sie aussendet.  Bevor Sie <code>GrassPlane</code> , machen Sie das <code>GrassPlane</code> Objekt in der Szene <strong>inaktiv</strong> und <code>GrassBall</code> das <code>GrassBall</code> Objekt.  Wir möchten, dass das Gras auf verschiedenen Oberflächentypen korrekt erzeugt wird. Daher ist es wichtig, es an Maschen unterschiedlicher Form zu testen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19b/f67/8fb/19bf678fbb6ce3c03956dbdf068004f0.png"></div><br>  Bisher werden alle Dreiecke in einer Richtung und nicht von der Oberfläche der Kugel nach außen emittiert.  Um dieses Problem zu lösen, werden wir Grashalme in einem <strong>tangentialen Raum</strong> erzeugen. <br><br><h2>  2. Tangentenraum </h2><br>  Im Idealfall möchten wir Grashalme erstellen, indem wir eine andere Breite, Höhe, Krümmung und Drehung einstellen, ohne den Winkel der Oberfläche zu berücksichtigen, von der der Grashalm emittiert wird.  Einfach ausgedrückt, definieren wir einen Grashalm in einem Raum <strong>lokal zum Scheitelpunkt, der ihn aussendet</strong> , und transformieren ihn dann so, dass er <strong>lokal zum Netz ist</strong> .  Dieser Raum wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tangentenraum genannt</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/8f7/c39/3fd8f7c394bf4eb18cb988aceafe342b.png"></div><br>  <i>Im Tangentenraum werden die <strong>X-</strong> , <strong>Y-</strong> und <strong>Z-</strong> Achsen relativ zur Normalen und zur Position der Oberfläche (in unserem Fall den Eckpunkten) definiert.</i> <br><br>  Wie in jedem anderen Raum können wir den Tangentenraum eines Scheitelpunkts mit drei Vektoren definieren: <strong>rechts</strong> , <strong>vorwärts</strong> und <strong>aufwärts</strong> .  Mit diesen Vektoren können wir eine Matrix erstellen, um den Grashalm von der Tangente in den lokalen Raum zu drehen. <br><br>  Sie können <strong>direkt</strong> und nach <strong>oben</strong> auf die Vektoren zugreifen, indem Sie neue Eingabescheitelpunktdaten hinzufügen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; … // Modify the vertex shader. vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; } … // Modify the input for the geometry shader. Note that the SV_POSITION semantic is removed. void geo(triangle vertexOutput IN[3], inout TriangleStream&lt;geometryOutput&gt; triStream) … // Modify the existing line declaring pos. float3 pos = IN[0].vertex;</span></span></code> </pre> <br>  Der dritte Vektor kann berechnet werden, indem das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vektorprodukt</a> zwischen zwei anderen genommen wird.  Ein Vektorprodukt gibt einen Vektor <strong>senkrecht</strong> zu zwei eingehenden Vektoren zurück. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Place in the geometry shader, below the line declaring float3 pos. float3 vNormal = IN[0].normal; float4 vTangent = IN[0].tangent; float3 vBinormal = cross(vNormal, vTangent) * vTangent.w;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Warum wird das Ergebnis des Vektorprodukts mit der Koordinate der Tangente w multipliziert?</b> <div class="spoiler_text">  Beim Exportieren eines Netzes aus einem 3D-Editor sind in der Regel bereits Binormale (auch <em>Tangenten an zwei Punkte genannt</em> ) in den Netzdaten gespeichert.  Anstatt diese Binormale zu importieren, nimmt Unity einfach die Richtung jeder Binormale und weist sie der Koordinate der Tangente <strong>w zu</strong> .  Auf diese Weise können Sie Speicherplatz sparen und gleichzeitig das richtige Binormal wiederherstellen.  Eine ausführliche Diskussion zu diesem Thema finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </div></div><br>  Mit allen drei Vektoren können wir eine Matrix für die Transformation zwischen tangentialen und lokalen Räumen erstellen.  Wir werden jeden Scheitelpunkt des Grashalms mit dieser Matrix <code>UnityObjectToClipPos</code> , bevor <code>UnityObjectToClipPos</code> ihn an <code>UnityObjectToClipPos</code> , das einen Scheitelpunkt im lokalen Raum erwartet. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the lines declaring the three vectors. float3x3 tangentToLocal = float3x3( vTangent.x, vBinormal.x, vNormal.x, vTangent.y, vBinormal.y, vNormal.y, vTangent.z, vBinormal.z, vNormal.z );</span></span></code> </pre> <br>  Bevor wir die Matrix verwenden, übertragen wir den Vertex-Ausgabecode an die Funktion, um nicht immer wieder dieselben Codezeilen zu schreiben.  Dies wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DRY-Prinzip bezeichnet</a> . <strong>Wiederholen Sie sich nicht</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. geometryOutput VertexOutput(float3 pos) { geometryOutput o; o.pos = UnityObjectToClipPos(pos); return o; } … // Remove the following from the geometry shader. //geometryOutput o; //o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0)); //triStream.Append(o); // ...and replace it with the code below. triStream.Append(VertexOutput(pos + float3(0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(-0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(0, 1, 0)));</span></span></code> </pre> <br>  Schließlich multiplizieren wir die Ausgabescheitelpunkte mit der <code>tangentToLocal</code> Matrix und <code>tangentToLocal</code> sie korrekt an der Normalen ihres Eingabepunkts aus. <br><br><pre> <code class="cpp hljs">triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/3f8/286/c953f828675a9d4e202c0c9349d37f9d.png" alt="Bild"></div><br>  Dies ist eher das, was wir brauchen, aber nicht ganz richtig.  Das Problem hierbei ist, dass wir anfangs die Richtung „up“ (up) der <strong>Y-</strong> Achse zugewiesen haben;  Im Tangentenraum befindet sich die Aufwärtsrichtung jedoch normalerweise entlang der <strong>Z-</strong> Achse.  Jetzt werden wir diese Änderungen vornehmen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the position of the third vertex being emitted. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1))));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/f51/ddb/0cff51ddbea12280cb78a1db9ada1786.png"></div><br><h2>  3. Aussehen von Gras </h2><br>  Damit die Dreiecke eher wie Grashalme aussehen, müssen Sie Farben und Variationen hinzufügen.  Wir beginnen mit dem Hinzufügen eines <strong>Gefälles</strong> , das von der Spitze des Grashalms nach unten verläuft. <br><br><h3>  3.1 Farbverlauf </h3><br>  Unser Ziel ist es, dem Künstler zu ermöglichen, zwei Farben einzustellen - oben und unten, und zwischen diesen beiden Farben zu interpolieren, die er auf die Basis des Grashalms kippt.  Diese Farben sind in der Shader-Datei bereits als <code>_TopColor</code> und <code>_BottomColor</code> .  Für die ordnungsgemäße Abtastung müssen Sie die <strong>UV-Koordinaten</strong> an den Fragment-Shader übergeben. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. float2 uv : TEXCOORD0; … // Modify the VertexOutput function signature. geometryOutput VertexOutput(float3 pos, float2 uv) … // Add to VertexOutput, just below the line assigning o.pos. o.uv = uv; … // Modify the existing lines in the geometry shader. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br>  Wir haben UV-Koordinaten für einen Grashalm in Form eines Dreiecks erstellt, dessen zwei Eckpunkte sich unten links und rechts befinden und dessen Spitzenscheitelpunkt in der Mitte oben liegt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/165/e39/932/165e399323aaa07e7c4cee728c0c9988.png"></div><br>  <i>UV-Koordinaten der drei Eckpunkte der Grashalme.</i>  <i>Obwohl wir die Grashalme mit einem einfachen Farbverlauf bemalen, können Sie mit einer ähnlichen Anordnung von Texturen Texturen überlagern.</i> <br><br>  Jetzt können wir die oberen und unteren Farben im Fragment-Shader mit UV <code>lerp</code> und sie dann mit <code>lerp</code> interpolieren.  Wir müssen auch die Parameter des Fragment- <code>float4</code> ändern und <code>geometryOutput</code> als Eingabe und nicht nur die Position von <code>float4</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the function signature of the fragment shader. float4 frag (geometryOutput i, fixed facing : VFACE) : SV_Target … // Replace the existing return call. return float4(1, 1, 1, 1); return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/510/51f/59651051f474907a88740e83bc9d4532.png"></div><br><h3>  3.2 Zufällige Blattrichtung </h3><br>  Um Variabilität zu erzeugen und dem Gras ein natürlicheres Aussehen zu verleihen, lassen wir jeden Grashalm in eine zufällige Richtung schauen.  Dazu müssen wir eine Rotationsmatrix erstellen, die den Grashalm zufällig um seine <strong>obere</strong> Achse dreht. <br><br>  Die Shader-Datei enthält zwei Funktionen, die uns dabei helfen: <code>rand</code> , das aus dreidimensionalen Eingaben eine Zufallszahl generiert, und <code>AngleAxis3x3</code> , das den Winkel (im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bogenmaß</a> ) empfängt und eine Matrix zurückgibt, die diesen Wert um die angegebene Achse dreht.  Die letztere Funktion funktioniert genauso wie die C # <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quaternion.AngleAxis-</a> Funktion (nur <code>AngleAxis3x3</code> gibt eine Matrix zurück, keine Quaternion). <br><br>  Die <code>rand</code> Funktion gibt eine Zahl im Bereich 0 ... 1 zurück.  Wir multiplizieren es mit <strong>2 Pi</strong> , um den gesamten Bereich der Winkelwerte zu erhalten. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring the tangentToLocal matrix. float3x3 facingRotationMatrix = AngleAxis3x3(rand(pos) * UNITY_TWO_PI, float3(0, 0, 1));</span></span></code> </pre> <br>  Wir verwenden die eingehende Positionsposition als Startwert für eine zufällige Rotation.  Aus diesem Grund hat jeder Grashalm seine eigene Rotation, die in jedem Rahmen konstant ist. <br><br>  Die Drehung kann auf den Grashalm angewendet werden, indem er mit der erstellten <code>tangentToLocal</code> Matrix <code>tangentToLocal</code> wird.  Beachten Sie, dass die Matrixmultiplikation <strong>nicht</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kommutativ ist</a> .  Die Reihenfolge der Operanden ist <strong>wichtig</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring facingRotationMatrix. float3x3 transformationMatrix = mul(tangentToLocal, facingRotationMatrix); … // Replace the multiplication matrix operand with our new transformationMatrix. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09f/c2f/e80/09fc2fe8028b51f78989954e65812cd3.png"></div><br><h3>  3.3 Zufälliges Vorwärtsbiegen </h3><br>  Wenn alle Grashalme perfekt ausgerichtet sind, sehen sie gleich aus.  Dies mag für gepflegtes Gras geeignet sein, zum Beispiel auf einem gepflegten Rasen, aber in der Natur wächst das Gras nicht so.  Wir werden eine neue Matrix erstellen, um das Gras entlang der <strong>X-</strong> Achse zu drehen, sowie eine Eigenschaft, um diese Drehung zu steuern. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _BendRotationRandom("Bend Rotation Random", Range(0, 1)) = 0.2 … // Add to the CGINCLUDE block. float _BendRotationRandom; … // Add to the geometry shader, below the line declaring facingRotationMatrix. float3x3 bendRotationMatrix = AngleAxis3x3(rand(pos.zzx) * _BendRotationRandom * UNITY_PI * 0.5, float3(-1, 0, 0));</span></span></code> </pre> <br>  Wieder verwenden wir die Position des Grashalms als zufälligen Samen, diesmal indem wir ihn <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fegen</a> , um einen einzigartigen Samen zu erzeugen.  Wir werden auch <code>UNITY_PI</code> mit <strong>0,5</strong> multiplizieren;  Dies gibt uns ein zufälliges Intervall von 0 ... 90 Grad. <br><br>  Wir wenden diese Matrix erneut durch Rotation an und multiplizieren alles in der richtigen Reihenfolge. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line. float3x3 transformationMatrix = mul(mul(tangentToLocal, facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49c/122/534/49c122534d7298c0f9c646501a708daa.gif"></div><br><h3>  3.4 Breite und Höhe </h3><br>  Während die Größe des Grashalms auf eine Breite von 1 Einheit und eine Höhe von 1 Einheit begrenzt ist.  Wir werden Eigenschaften hinzufügen, um die Größe zu steuern, sowie Eigenschaften, um zufällige Variationen hinzuzufügen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeWidth("Blade Width", Float) = 0.05 _BladeWidthRandom("Blade Width Random", Float) = 0.02 _BladeHeight("Blade Height", Float) = 0.5 _BladeHeightRandom("Blade Height Random", Float) = 0.3 … // Add to the CGINCLUDE block. float _BladeHeight; float _BladeHeightRandom; float _BladeWidth; float _BladeWidthRandom; … // Add to the geometry shader, above the triStream.Append calls. float height = (rand(pos.zyx) * 2 - 1) * _BladeHeightRandom + _BladeHeight; float width = (rand(pos.xzy) * 2 - 1) * _BladeWidthRandom + _BladeWidth; … // Modify the existing positions with our new height and width. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-width, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, height)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35b/22e/f34/35b22ef34945a576100a152a0e25eec5.png"></div><br>  Dreiecke sind jetzt viel mehr wie Grashalme, aber auch zu wenig.  Es gibt einfach nicht genug Spitzen im eingehenden Netz, um den Eindruck eines dicht bewachsenen Feldes zu erwecken. <br><br>  Eine Lösung besteht darin, ein neues, dichteres Netz zu erstellen, entweder mit C # oder in einem 3D-Editor.  Dies wird funktionieren, aber es wird uns nicht ermöglichen, die Dichte des Grases dynamisch zu steuern.  Stattdessen teilen wir das eingehende Netz mithilfe der <strong>Tessellation auf</strong> . <br><br><h2>  4. Tessellation </h2><br>  <strong>Die Tessellation</strong> ist eine optionale Phase der Rendering-Pipeline, die nach dem Vertex-Shader und vor dem geometrischen Shader (falls vorhanden) ausgeführt wird.  Seine Aufgabe ist es, eine eingehende Oberfläche in viele Grundelemente zu unterteilen.  Die Tessellation wird in zwei programmierbaren Schritten implementiert: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hull-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Domain-</a> Shader. <br><br>  Für Oberflächen-Shader verfügt Unity über eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">integrierte Tessellierungsimplementierung</a> .  Da wir <strong>jedoch keine</strong> Oberflächen-Shader verwenden, müssen wir unsere eigenen Shell- und Domain-Shader implementieren.  In diesem Artikel werde ich die Implementierung von Tessellation nicht im Detail diskutieren, und wir verwenden einfach die vorhandene Datei <code>CustomTessellation.cginc</code> .  Diese Datei wurde aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Catlike Coding übernommen</a> , der eine hervorragende Informationsquelle zur Implementierung von Tessellation in Unity darstellt. <br><br>  Wenn wir das <code>TessellationExample</code> Objekt in die Szene aufnehmen, werden wir feststellen, dass es bereits Material enthält, das die Tessellation implementiert.  Das Ändern der Eigenschaft <strong>Tessellation Uniform</strong> zeigt den Unterteilungseffekt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d8/8a7/f01/2d88a7f01e3a7462ffd0c8f20953b5ca.gif"></div><br>  Wir implementieren eine Tessellation im Grasshader, um die Dichte des Flugzeugs und damit die Anzahl der erzeugten Grashalme zu steuern.  Zuerst müssen Sie die Datei <code>CustomTessellation.cginc</code> hinzufügen.  Wir werden es durch seinen <em>relativen</em> Pfad zum Shader bezeichnen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block, below the other #include statements. #include "Shaders/CustomTessellation.cginc"</span></span></code> </pre> <br>  Wenn Sie <code>CustomTessellation.cginc</code> öffnen, werden Sie feststellen, dass darin bereits <code>vertexInput</code> und <code>vertexOutput</code> sowie Vertex-Shader definiert sind.  Sie müssen sie in unserem Grasshader nicht neu definieren.  Sie können gelöscht werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; }*/</span></span></code> </pre> <br>  Beachten Sie, dass der <code>vert</code> Vertex-Shader in <code>CustomTessellation.cginc</code> die Eingabe einfach direkt an die Tessellation-Stufe übergibt.  Die im Domain-Shader <code>vertexOutput</code> Funktion <code>vertexOutput</code> übernimmt die Erstellung der <code>vertexOutput</code> Struktur. <br><br>  Jetzt können wir dem Grassader Shader- und <strong>Domain-</strong> Shader hinzufügen.  Wir werden auch eine neue <code>_TessellationUniform</code> Eigenschaft hinzufügen, um die Einheitengröße zu steuern. Die dieser Eigenschaft entsprechende Variable wurde bereits in <code>CustomTessellation.cginc</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _TessellationUniform("Tessellation Uniform", Range(1, 64)) = 1 … // Add below the other #pragma statements in the SubShader Pass. #pragma hull hull #pragma domain domain</span></span></code> </pre> <br>  Durch Ändern der Eigenschaft <strong>Tessellation Uniform</strong> können wir nun die Dichte des Grases steuern.  Ich fand heraus, dass mit einem Wert von <strong>5</strong> gute Ergebnisse erzielt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/280/d93/c14/280d93c1420a9744bd56f2d2496f96ab.gif"></div><br><h2>  5. Der Wind </h2><br>  Wir implementieren den Wind, indem wir die <strong>Verzerrungstextur</strong> abtasten.  Diese Textur sieht aus wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine normale Karte</a> , nur gibt es nur zwei statt drei Kanäle.  Wir werden diese beiden Kanäle als Windrichtungen entlang <strong>X</strong> und <strong>Y verwenden.</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a58/aaa/687/a58aaa68742934ff1bddf1cbaf9564f5.png"></div><br>  Bevor wir die Windtextur abtasten, müssen wir eine UV-Koordinate erstellen.  Anstatt die dem Netz zugewiesenen Texturkoordinaten zu verwenden, wenden wir die Position des eingehenden Punkts an.  Wenn es auf der Welt mehrere Grasmaschen gibt, entsteht die Illusion, dass sie alle Teil desselben Windsystems sind.  Wir verwenden auch die <code>_Time</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Variable</a> <code>_Time</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shader,</a> um die <code>_Time</code> entlang der Grasoberfläche zu scrollen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _WindDistortionMap("Wind Distortion Map", 2D) = "white" {} _WindFrequency("Wind Frequency", Vector) = (0.05, 0.05, 0, 0) … // Add to the CGINCLUDE block. sampler2D _WindDistortionMap; float4 _WindDistortionMap_ST; float2 _WindFrequency; … // Add to the geometry shader, just above the line declaring the transformationMatrix. float2 uv = pos.xz * _WindDistortionMap_ST.xy + _WindDistortionMap_ST.zw + _WindFrequency * _Time.y;</span></span></code> </pre> <br>  Wir wenden die Skalierung und den Versatz von <code>_WindDistortionMap</code> auf die Position an und verschieben sie dann weiter auf <code>_Time.y</code> , skaliert auf <code>_WindFrequency</code> .  Jetzt werden wir diese UVs verwenden, um die Textur abzutasten und eine Eigenschaft zu erstellen, um die Stärke des Windes zu steuern. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _WindStrength("Wind Strength", Float) = 1 … // Add to the CGINCLUDE block. float _WindStrength; … // Add below the line declaring float2 uv. float2 windSample = (tex2Dlod(_WindDistortionMap, float4(uv, 0, 0)).xy * 2 - 1) * _WindStrength;</span></span></code> </pre> <br>  Beachten Sie, dass wir den abgetasteten Wert von der Textur vom Intervall 0 ... 1 bis zum Intervall -1 ... 1 skalieren.  Als nächstes können wir einen normalisierten Vektor erzeugen, der die Windrichtung angibt. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float2 windSample. float3 wind = normalize(float3(windSample.x, windSample.y, 0));</span></span></code> </pre> <br>  Jetzt können wir eine Matrix erstellen, um diesen Vektor zu drehen und mit unserer <code>transformationMatrix</code> multiplizieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3 wind. float3x3 windRotation = AngleAxis3x3(UNITY_PI * windSample, wind); … // Modify the existing line. float3x3 transformationMatrix = mul(mul(mul(tangentToLocal, windRotation), facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br>  Schließlich übertragen wir die Windtextur (an der Wurzel des Projekts) in das Feld <strong>Wind Distortion Map</strong> des Grasmaterials im Unity-Editor.  Wir setzen auch den <strong>Tiling-</strong> Parameter der Textur auf <code>0.01, 0.01</code> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Wenn das Gras im Szenenfenster nicht animiert wird, klicken Sie auf die <strong>Schaltfläche Skybox, Nebel und verschiedene andere Effekte</strong> umschalten, um animierte Materialien zu aktivieren. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus der Ferne sieht das Gras richtig aus, aber wenn wir uns den Grashalm genau ansehen, stellen wir fest, dass sich der gesamte Grashalm dreht, weshalb die Basis nicht mehr am Boden befestigt ist. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/148/51e/6e914851e888c448c30080a7abefae33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Basis des Grashalms ist nicht mehr am Boden befestigt, sondern schneidet ihn ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rot dargestellt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und hängt über der Bodenebene (angezeigt durch die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grüne</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linie). </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden dies beheben, indem wir eine zweite Transformationsmatrix definieren, die nur für zwei Eckpunkte der Basis gilt. </font><font style="vertical-align: inherit;">In dieser Matrix </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht werden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enthalten Matrix </font></font><code>windRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>bendRotationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank, auf dem die Basis auf die Grasfläche angebracht ist.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3x3 transformationMatrix. float3x3 transformationMatrixFacing = mul(tangentToLocal, facingRotationMatrix); … // Modify the existing lines outputting the base vertex positions. triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(-width, 0, 0)), float2(1, 0)));</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Krümmung der Grashalme </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden einzelne Grashalme durch ein Dreieck definiert. In großen Entfernungen ist dies kein Problem, aber in der Nähe des Grashalms sehen sie eher sehr steif und geometrisch aus als organisch und lebhaft. Wir werden dies beheben, indem wir Grashalme aus mehreren Dreiecken bauen und sie entlang der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurve biegen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder Grashalm wird in mehrere </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segmente unterteilt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jedes Segment hat eine rechteckige Form und besteht aus zwei Dreiecken, mit Ausnahme des oberen Segments - es ist ein Dreieck, das die Spitze des Grashalms bezeichnet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir nur drei Eckpunkte gezeichnet und so ein einziges Dreieck erstellt. Woher weiß der geometrische Shader dann, wenn es mehr Eckpunkte gibt, welche zu verbinden und Dreiecke zu bilden sind? Die Antwort liegt in der Datenstruktur</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dreiecksstreifen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die ersten drei Scheitelpunkte verbinden sich und bilden ein Dreieck, und jeder neue Scheitelpunkt bildet mit den beiden vorherigen ein Dreieck.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/871/8ec/676/8718ec676d7efd819718bd25d5b27b54.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein unterteilter Grashalm, der als Dreiecksstreifen dargestellt wird und jeweils einen Scheitelpunkt erstellt. Nach den ersten drei Scheitelpunkten bildet jeder neue Scheitelpunkt mit den beiden vorherigen Scheitelpunkten ein neues Dreieck.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist nicht nur effizienter in Bezug auf die Speichernutzung, sondern ermöglicht es Ihnen auch, einfach und schnell Dreieckssequenzen in Ihrem Code zu erstellen. Wenn wir mehrere Dreiecksstreifen erstellen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">möchten</font></a><font style="vertical-align: inherit;"> , können wir </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">RestartStrip</font></a><font style="vertical-align: inherit;"> für die </font></font><code>TriangleStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bevor wir beginnen, mehr Scheitelpunkte aus dem geometrischen Shader zu zeichnen, müssen wir ihn vergrößern </font><font style="vertical-align: inherit;">. Wir werden das Design verwenden </font><font style="vertical-align: inherit;">, damit der Shader-Autor die Anzahl der Segmente steuern und die Anzahl der angezeigten Scheitelpunkte daraus berechnen kann.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>maxvertexcount</code><font style="vertical-align: inherit;"></font><code>#define</code><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. #define BLADE_SEGMENTS 3 … // Modify the existing line defining the maxvertexcount. [maxvertexcount(BLADE_SEGMENTS * 2 + 1)]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst setzen wir die Anzahl der Segmente auf </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und aktualisieren </font></font><code>maxvertexcount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Anzahl der Scheitelpunkte basierend auf der Anzahl der Segmente zu berechnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um einen segmentierten Grashalm zu erstellen, verwenden wir einen Zyklus </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jede Iteration der Schleife fügt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei Eckpunkte hinzu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">links</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rechts</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nach Abschluss der Spitze fügen wir den letzten Scheitelpunkt an der Spitze des Grashalms hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir dies tun, ist es nützlich, einen Teil der Rechenposition der Eckpunkte der Grashalme des Codes in die Funktion zu verschieben, da wir diesen Code innerhalb und außerhalb der Schleife mehrmals verwenden. Fügen Sie dem Block </font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgendes hinzu:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">geometryOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGrassVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 vertexPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, float2 uv, float3x3 transformMatrix)</span></span></span><span class="hljs-function"> </span></span>{ float3 tangentPoint = float3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, height); float3 localPosition = vertexPosition + mul(transformMatrix, tangentPoint); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VertexOutput(localPosition, uv); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Funktion führt dieselben Aufgaben aus, da sie die Argumente übergibt, die wir zuvor übergeben haben </font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Eckpunkte des Grashalms zu generieren. </font><font style="vertical-align: inherit;">Wenn Sie eine Position, Höhe und Breite erhalten, transformiert es den Scheitelpunkt mithilfe der übertragenen Matrix korrekt und weist ihm eine UV-Koordinate zu. </font><font style="vertical-align: inherit;">Wir werden den vorhandenen Code aktualisieren, damit die Funktion ordnungsgemäß funktioniert.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the existing code outputting the vertices. triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion hat ordnungsgemäß funktioniert und wir sind bereit, den Vertex-Generierungscode in die Schleife zu verschieben </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fügen Sie unter der Zeile </font></font><code>float width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgendes </font><font style="vertical-align: inherit;">hinzu </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; BLADE_SEGMENTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = i / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)BLADE_SEGMENTS; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir kündigen einen Zyklus an, der für jeden Grashalmsegment einmal ausgeführt wird. </font><font style="vertical-align: inherit;">Fügen Sie innerhalb der Schleife eine Variable hinzu </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Variable speichert einen Wert im Bereich von 0 bis 1, der angibt, wie weit wir uns entlang des Grashalms bewegt haben. </font><font style="vertical-align: inherit;">Wir verwenden diesen Wert, um die Breite und Höhe des Segments in jeder Iteration der Schleife zu berechnen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float t. float segmentHeight = height * t; float segmentWidth = width * (1 - t);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie einen Grashalm nach oben bewegen, nimmt die Höhe zu und die Breite ab. </font><font style="vertical-align: inherit;">Jetzt können wir der Schleife Aufrufe </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hinzufügen, um dem Dreiecksstrom Scheitelpunkte hinzuzufügen. </font><font style="vertical-align: inherit;">Wir werden auch einen Aufruf </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">außerhalb der Schleife </font><font style="vertical-align: inherit;">hinzufügen </font><font style="vertical-align: inherit;">, um die Spitze des Grashalms zu erzeugen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float segmentWidth. float3x3 transformMatrix = i == 0 ? transformationMatrixFacing : transformationMatrix; triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, float2(1, t), transformMatrix)); … // Add just below the loop to insert the vertex at the tip of the blade. triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix)); … // Remove the existing calls to triStream.Append. //triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen Sie sich die Zeile mit der Deklaration an </font></font><code>float3x3 transformMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- hier wählen wir eine von zwei Transformationsmatrizen aus: Wir nehmen </font></font><code>transformationMatrixFacing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für die Eckpunkte der Basis und </font></font><code>transformationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für alle anderen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/211/61c/02b21161cd4afc0cca35ae71ffe2570e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grashalme sind jetzt in viele Segmente unterteilt, aber die Blattoberfläche ist immer noch flach - neue Dreiecke sind noch nicht beteiligt. </font><font style="vertical-align: inherit;">Wir werden ein Grashalm Krümmung hinzufügen, um </font><font style="vertical-align: inherit;">die Position des Scheitels der Verschiebung </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Zuerst müssen wir die Funktion </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so </font><font style="vertical-align: inherit;">ändern </font><font style="vertical-align: inherit;">, dass sie einen Offset in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erhält </font><font style="vertical-align: inherit;">, den wir aufrufen werden </font></font><code>forward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the function signature of GenerateGrassVertex. geometryOutput GenerateGrassVertex(float3 vertexPosition, float width, float height, float forward, float2 uv, float3x3 transformMatrix) … // Modify the Y coordinate assignment of tangentPoint. float3 tangentPoint = float3(width, forward, height);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Verschiebung jedes Scheitelpunkts zu berechnen, setzen wir einen </font></font><code>pow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert </font><font style="vertical-align: inherit;">in die Funktion ein </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nach dem Anheben </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf eine Kraft ist ihre Auswirkung auf die Vorwärtsverschiebung </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nichtlinear</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und verwandelt den Grashalm in eine Kurve.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeForward("Blade Forward Amount", Float) = 0.38 _BladeCurve("Blade Curvature Amount", Range(1, 4)) = 2 … // Add to the CGINCLUDE block. float _BladeForward; float _BladeCurve; … // Add inside the geometry shader, below the line declaring float width. float forward = rand(pos.yyz) * _BladeForward; … // Add inside the loop, below the line declaring segmentWidth. float segmentForward = pow(t, _BladeCurve) * forward; … // Modify the GenerateGrassVertex calls inside the loop. triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, segmentForward, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, segmentForward, float2(1, t), transformMatrix)); … // Modify the GenerateGrassVertex calls outside the loop. triStream.Append(GenerateGrassVertex(pos, 0, height, forward, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein ziemlich großer Code, aber alle Arbeiten werden ähnlich ausgeführt wie für die Breite und Höhe des Grashalms. </font><font style="vertical-align: inherit;">Bei niedrigeren Werten </font></font><code>_BladeForward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und </font></font><code>_BladeCurve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bekommen wir einen geordnete, gepflegten Rasen, und größere Werte der entgegengesetzte Wirkung.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/cbc/e43/c1fcbce43fa5e1c1be319dc1f5190f3d.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Licht und Schatten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als letzten Schritt zur Vervollständigung des Shaders werden wir die Möglichkeit hinzufügen </font><strong><font style="vertical-align: inherit;">,</font></strong><font style="vertical-align: inherit;"> Schatten </font><font style="vertical-align: inherit;">zu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werfen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und zu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empfangen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir werden auch eine einfache Beleuchtung von der Hauptlichtquelle hinzufügen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.1 Schatten werfen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Schatten in Unity zu werfen, müssen Sie dem Shader einen zweiten Durchgang hinzufügen. Diese Passage wird von den schattenerzeugenden Lichtquellen in der Szene verwendet, um die Tiefe des Grases in ihre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schattenkarte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu rendern </font><font style="vertical-align: inherit;">. Dies bedeutet, dass der geometrische Shader im Schattengang gestartet werden muss, damit die Grashalme Schatten werfen können. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der geometrische Shader in Blöcken geschrieben ist </font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, können wir ihn in beliebigen Durchläufen der Datei verwenden. Erstellen Sie einen zweiten Durchgang, der dieselben Shader wie der erste verwendet, mit Ausnahme des Fragment-Shaders. Wir definieren einen neuen, in den wir ein Makro schreiben, das die Ausgabe verarbeitet.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the existing Pass. Pass { Tags { "LightMode" = "ShadowCaster" } CGPROGRAM #pragma vertex vert #pragma geometry geo #pragma fragment frag #pragma hull hull #pragma domain domain #pragma target 4.6 #pragma multi_compile_shadowcaster float4 frag(geometryOutput i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neben der Erstellung eines neuen Fragment-Shaders gibt es in dieser Passage einige wichtige Unterschiede. </font><font style="vertical-align: inherit;">Die Beschriftung </font><font style="vertical-align: inherit;">ist nicht </font></font><code>LightMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wichtig </font><font style="vertical-align: inherit;">- dies sagt Unity, dass diese Passage verwendet werden sollte, um das Objekt in Schattenkarten zu rendern. </font><font style="vertical-align: inherit;">Hier gibt es auch eine Präprozessor-Direktive </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es stellt sicher, dass der Shader alle erforderlichen Optionen kompiliert, um Schatten zu werfen. </font><font style="vertical-align: inherit;">Lassen Sie </font><font style="vertical-align: inherit;">uns ein Spiel Objekt machen , </font><font style="vertical-align: inherit;">ist </font><strong><font style="vertical-align: inherit;">aktiv</font></strong><font style="vertical-align: inherit;"> in der Szene; </font><font style="vertical-align: inherit;">So erhalten wir eine Oberfläche, auf die die Grashalme einen Schatten werfen können.</font></font><code>ShadowCaster</code><font style="vertical-align: inherit;"></font><code>ForwardBase</code><font style="vertical-align: inherit;"></font><code>multi_compile_shadowcaster</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>Fence</code> <strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c57/640/6cf/c576406cf284fe41e4b04d8af264d96e.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.2 Schatten bekommen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem Unity die Schattenkarte aus der Sicht der Lichtquelle gerendert hat, die den Schatten erzeugt, wird eine Passage gestartet, die die Schatten in der Textur des </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bildschirmbereichs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "sammelt" </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um diese Textur abzutasten, müssen wir die Positionen der Scheitelpunkte im Bildschirmbereich berechnen und an den Fragment-Shader übertragen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. unityShadowCoord4 _ShadowCoord : TEXCOORD1; … // Add to the VertexOutput function, just above the return call. o._ShadowCoord = ComputeScreenPos(o.pos);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Fragment-Shader der Passage können </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir ein Makro verwenden, um einen Wert zu erhalten, der </font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angibt, ob sich die Oberfläche im Schatten befindet oder nicht. </font><font style="vertical-align: inherit;">Dieser Wert liegt im Bereich von 0 bis 1, wobei 0 für vollständige Schattierung und 1 für vollständige Beleuchtung steht.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum heißt die UV-Koordinate des Bildschirmbereichs _ShadowCoord? </font><font style="vertical-align: inherit;">Dies entspricht nicht den vorherigen Namenskonventionen.</font></font></b> <div class="spoiler_text">    Unity           (       ).          <code>SHADOW_ATTENUATION</code> .         <code>Autolight.cginc</code> ,  ,       . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SHADOW_ATTENUATION(a) unitySampleShadow(a._ShadowCoord)</span></span></code> </pre> <br>              -    ,            . </div></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's fragment shader, replacing the existing return call. return SHADOW_ATTENUATION(i); //return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließlich müssen wir den Shader richtig konfigurieren, um Schatten zu empfangen. </font><font style="vertical-align: inherit;">Zu diesem Zweck fügen wir dem Pass eine </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Präprozessor-Direktive hinzu, damit alle erforderlichen Shader-Optionen kompiliert werden.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's preprocessor directives, below #pragma target 4.6. #pragma multi_compile_fwdbase</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90a/491/468/90a491468a1ad129d35bea03b0b51898.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Kamera näher gebracht haben, können wir Artefakte auf der Oberfläche der Grashalme feststellen. </font><font style="vertical-align: inherit;">Sie werden durch die Tatsache verursacht, dass einzelne Grashalme Schatten auf sich selbst werfen. </font><font style="vertical-align: inherit;">Wir können dies beheben, indem wir eine </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lineare Verschiebung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anwenden </font><font style="vertical-align: inherit;">oder die Positionen der Scheitelpunkte im Kürzungsraum etwas vom Bildschirm weg verschieben. </font><font style="vertical-align: inherit;">Wir werden das Unity-Makro dafür verwenden und es in das Design </font></font><code>#if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einbeziehen, sodass die Operation nur im Schattenpfad ausgeführt wird.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add at the end of the VertexOutput function, just above the return call. #if UNITY_PASS_SHADOWCASTER // Applying the bias prevents artifacts from appearing on the surface. o.pos = UnityApplyLinearShadowBias(o.pos); #endif</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dca/ec0/d88/dcaec0d88eea1893b6a07eb45724a0b6.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Anwenden der linearen Schattenverschiebung verschwinden Schattenartefakte in Form von Streifen von der Oberfläche der Dreiecke.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum gibt es Artefakte an den Rändern der schattierten Grashalme?</font></font></b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08a/12e/af1/08a12eaf1af17fc9b35de7d07a64afca.png"></div><br>      (multisample anti-aliasing <strong>MSAA</strong> ) Unity <em> </em>     ,        .        ,  . <br><br>    —  ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  Unity</a> .      (     );     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    Unity</a> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.3 Beleuchtung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden die Beleuchtung mit einem sehr einfachen und gebräuchlichen Berechnungsalgorithmus für diffuses Licht implementieren.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/3ae/452/4043ae452046c0b4b405aa88afe8d2b7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... wobei </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Normale zur Oberfläche ist, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die normalisierte Richtung der Hauptlichtquelle ist und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die berechnete Beleuchtung ist. </font><font style="vertical-align: inherit;">In diesem Tutorial </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird keine</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indirekte Beleuchtung implementiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Moment sind den Spitzen der Grashalme keine Normalen zugeordnet. </font><font style="vertical-align: inherit;">Wie bei Scheitelpunktpositionen berechnen wir zuerst die Normalen im </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tangentenraum</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und konvertieren sie dann in lokale. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schaufelkrümmung Betrag</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird auf </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die </font><font style="vertical-align: inherit;">alle das Gras im Tangentenraum in der gleichen Richtung: das Gegenteil von der Achse </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Als ersten Durchgang unserer Lösung berechnen wir die Normalen unter der Annahme, dass keine Krümmung vorliegt.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the GenerateGrassVertex function, belowing the line declaring tangentPoint. float3 tangentNormal = float3(0, -1, 0); float3 localNormal = mul(transformMatrix, tangentNormal);</span></span></code> </pre> <br> <code>tangentNormal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, definiert als direkt gegenüber der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Achse </font><font style="vertical-align: inherit;">, wird durch dieselbe Matrix transformiert, mit der wir die Tangentenpunkte in den lokalen Raum konvertiert haben. </font><font style="vertical-align: inherit;">Jetzt können wir es an eine Funktion </font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und dann an eine Struktur übergeben </font></font><code>geometryOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the return call in GenerateGrassVertex. return VertexOutput(localPosition, uv, localNormal); … // Add to the geometryOutput struct. float3 normal : NORMAL; … // Modify the existing function signature. geometryOutput VertexOutput(float3 pos, float2 uv, float3 normal) … // Add to the VertexOutput function to pass the normal through to the fragment shader. o.normal = UnityObjectToWorldNormal(normal);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass wir vor dem Abschluss das Normale in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Weltraum</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwandeln </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Einheit vermittelt den Shadern die Richtung der Hauptquelle des gerichteten Lichts im Weltraum, daher ist diese Transformation notwendig. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir die Normalen im Shader-Fragment visualisieren </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um das Ergebnis unserer Arbeit zu überprüfen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader. float3 normal = facing &gt; 0 ? i.normal : -i.normal; return float4(normal * 0.5 + 0.5, 1); // Remove the existing return call. //return SHADOW_ATTENUATION(i);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da in unserem Shader ein </font></font><code>Cull</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert zugewiesen ist </font></font><code>Off</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, werden beide Seiten des Grashalms gerendert. </font><font style="vertical-align: inherit;">Damit die Normalen in die richtige Richtung gerichtet werden, verwenden wir einen Hilfsparameter </font></font><code>VFACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, den wir dem Fragment-Shader hinzugefügt haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Argument </font></font><code>fixed facing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">positive</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zahl zurück, wenn wir die Vorderseite der Oberfläche anzeigen, und eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">negative</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zahl, wenn es das Gegenteil ist. </font><font style="vertical-align: inherit;">Wir verwenden dies im obigen Code, um bei Bedarf das Normale umzudrehen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/8ca/965/e1b8ca965ed8e80b539a9773d1adeb0c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blattkrümmungsbetrag</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> größer als 1 ist, wird die tangentiale </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position </font><font style="vertical-align: inherit;">jedes Scheitelpunkts um den </font></font><code>forward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an die Funktion übergebenen </font><font style="vertical-align: inherit;">Betrag verschoben </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden diesen Wert verwenden, um die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Achse der </font><font style="vertical-align: inherit;">Normalen </font><font style="vertical-align: inherit;">proportional zu skalieren </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line in GenerateGrassVertex. float3 tangentNormal = normalize(float3(0, -1, forward));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie abschließend den Code zum Fragment-Shader hinzu, um die Schatten, die gerichtete Beleuchtung und die Umgebungsbeleuchtung zu kombinieren. </font><font style="vertical-align: inherit;">Ich empfehle, in meinem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial zu Toon-Shadern</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> detailliertere Informationen zur Implementierung der benutzerdefinierten Beleuchtung in Shadern </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">zu lesen</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader, below the line declaring float3 normal. float shadow = SHADOW_ATTENUATION(i); float NdotL = saturate(saturate(dot(normal, _WorldSpaceLightPos0)) + _TranslucentGain) * shadow; float3 ambient = ShadeSH9(float4(normal, 1)); float4 lightIntensity = NdotL * _LightColor0 + float4(ambient, 1); float4 col = lerp(_BottomColor, _TopColor * lightIntensity, i.uv.y); return col; // Remove the existing return call. //return float4(normal * 0.5 + 0.5, 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/894/d14/c14894d14edc336b770f4b94bedd3708.png"></div><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Tutorial bedeckt Gras eine kleine Fläche von 10 x 10 Einheiten. </font><font style="vertical-align: inherit;">Damit der Shader große Freiflächen abdecken und gleichzeitig eine hohe Leistung erzielen kann, müssen Optimierungen eingeführt werden. </font><font style="vertical-align: inherit;">Sie können die Tessellierung basierend auf der Entfernung anwenden, damit weniger Grashalme von der Kamera entfernt werden. </font><font style="vertical-align: inherit;">Darüber hinaus können über große Entfernungen anstelle einzelner Grashalme Gruppen von Grashalmen mit einem einzigen Viereck mit einer überlagerten Textur gezeichnet werden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/a05/e86/5a7a05e8690c152f9196bb3c94fada19.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grasstruktur ist im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard Assets-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paket </font><font style="vertical-align: inherit;">der Unity Engine </font><font style="vertical-align: inherit;">enthalten </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Viele Grashalme werden auf ein Viereck gezeichnet, wodurch die Anzahl der Dreiecke in der Szene verringert wird. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir von Natur aus keine geometrischen Shader mit Oberflächen-Shadern verwenden können, um die Funktionalität von Beleuchtung und Schattierung zu verbessern oder zu erweitern, können Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses GitHub-Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> studieren </font><font style="vertical-align: inherit;">, das die Lösung des Problems durch verzögertes Rendern und manuelles Füllen von G-Puffern demonstriert. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shader-Quellcode im GitHub-Repository</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ergänzung: Zusammenarbeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne Interoperabilität können Grafikeffekte für Spieler statisch oder leblos erscheinen. </font><font style="vertical-align: inherit;">Dieses Tutorial ist bereits sehr lang, daher habe ich keinen Abschnitt über die Interaktion von Weltobjekten mit Gras hinzugefügt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine naive Implementierung interaktiver Kräuter würde zwei Komponenten enthalten: etwas in der Spielwelt, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Daten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an den Shader übertragen kann, um ihm mitzuteilen, mit welchem ​​Teil des Grases interagiert wird, und Code im Shader, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diese Daten </font><font style="vertical-align: inherit;">zu </font><strong><font style="vertical-align: inherit;">interpretieren</font></strong><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel, wie dies mit Wasser umgesetzt werden kann, wird </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gezeigt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es kann angepasst werden, um mit Gras zu arbeiten; </font><font style="vertical-align: inherit;">Anstatt an der Stelle, an der sich der Charakter befindet, Wellen zu zeichnen, können Sie den Grashalm nach unten drehen, um die Auswirkungen von Schritten zu simulieren.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458060/">https://habr.com/ru/post/de458060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458046/index.html">Gradle Spickzettel</a></li>
<li><a href="../de458048/index.html">Delegation als Manager-Tool</a></li>
<li><a href="../de458050/index.html">Wie war der Mobius 2019 Piter (und ein bisschen über den nächsten Mobius)</a></li>
<li><a href="../de458052/index.html">AMA mit Habr. 10. Letzte * Ausgabe</a></li>
<li><a href="../de458056/index.html">Das große Interview mit Martin Kleppmann: „Die Zukunft verteilter Datensysteme herausfinden“</a></li>
<li><a href="../de458062/index.html">Übersicht über die UserGate-Plattform</a></li>
<li><a href="../de458064/index.html">PVS-Studio in den Clouds - Ausführen der Analyse auf Travis CI</a></li>
<li><a href="../de458068/index.html">PVS-Studio für Visual Studio</a></li>
<li><a href="../de458070/index.html">PVS-Studio für Visual Studio</a></li>
<li><a href="../de458072/index.html">PVS-Studio geht in die Cloud - Starten Sie die Analyse auf Travis CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>