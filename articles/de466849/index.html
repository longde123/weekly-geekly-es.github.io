<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò§ üßìüèº üë©üèª‚Äçüè´ noexcept-ctcheck oder ein paar einfache Makros, die dem Compiler helfen, noexcept-Code zu schreiben ü§ü ‚è´ üò∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Entwicklung in C ++ m√ºssen Sie von Zeit zu Zeit Code schreiben, in dem keine Ausnahmen auftreten d√ºrfen. Zum Beispiel, wenn wir einen ausnahme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>noexcept-ctcheck oder ein paar einfache Makros, die dem Compiler helfen, noexcept-Code zu schreiben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466849/"><p>  Bei der Entwicklung in C ++ m√ºssen Sie von Zeit zu Zeit Code schreiben, in dem keine Ausnahmen auftreten d√ºrfen.  Zum Beispiel, wenn wir einen ausnahmefreien Swap f√ºr native Typen schreiben oder eine noexcept move-Anweisung f√ºr unsere Klasse definieren oder manuell einen nichttrivialen Destruktor implementieren m√ºssen. </p><br><p>  In C ++ 11 wurde der Sprache der Modifikator noexcept hinzugef√ºgt, damit der Entwickler verstehen kann, dass Ausnahmen von der mit noexcept gekennzeichneten Funktion (oder Methode) nicht verworfen werden k√∂nnen.  Daher k√∂nnen Funktionen mit einer solchen Markierung sicher in Kontexten verwendet werden, in denen keine Ausnahmen auftreten sollten. </p><br><p>  Zum Beispiel, wenn ich diese Typen und Funktionen habe: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_resource</span></span></span><span class="hljs-class"> {</span></span>...}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">second_resource</span></span></span><span class="hljs-class"> {</span></span>...}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first_resource &amp; r)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(second_resource &amp; r)</span></span></span></span>;</code> </pre> <br><p>  und es gibt eine bestimmte <code>resources_owner</code> Klasse, die Objekte wie <code>first_resource</code> und <code>second_resource</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resources_owner</span></span></span><span class="hljs-class"> {</span></span> first_resource first_resource_; second_resource second_resource_; ... };</code> </pre> <br><p>  dann kann ich den Destruktor <code>resources_owner</code> wie folgt schreiben: </p><br><pre> <code class="cpp hljs">resources_owner::~resources_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  release()   ,    . release(first_resource_); //    close()   ,  //   try-catch. try{ close(second_resource_); } catch(...) {} }</span></span></code> </pre> <br><p>  In gewisser Weise hat noexcept in C ++ 11 das Leben eines C ++ - Entwicklers erleichtert.  Aber die derzeitige Noexcept-Implementierung in modernem C ++ hat eine b√∂se Seite ... </p><br><h1 id="kompilyator-ne-pomogaet-kontrolirovat-soderzhimoe-noexcept-funkciy-i-metodov">  Der Compiler hilft nicht dabei, den Inhalt von noexcept-Funktionen und -Methoden zu steuern </h1><a name="habracut"></a><br><p>  Angenommen, ich habe mich im obigen Beispiel geirrt: Aus irgendeinem Grund habe ich <code>release()</code> als noexcept markiert, aber in Wirklichkeit ist dies keine Ausnahme und kann Ausnahmen ausl√∂sen.  Dies bedeutet, dass, wenn ich einen Destruktor mit einem solchen Wurf <code>release()</code> schreibe: </p><br><pre> <code class="cpp hljs">resources_owner::~resources_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { release(first_resource_); <span class="hljs-comment"><span class="hljs-comment">//  try-catch   ... }</span></span></code> </pre> <br><p>  dann bitte ich um √Ñrger.  Fr√ºher oder sp√§ter wird diese <code>release()</code> eine Ausnahme ausl√∂sen und meine gesamte Anwendung wird aufgrund des automatisch aufgerufenen <code>std::terminate()</code> abst√ºrzen.  Es wird noch schlimmer sein, wenn nicht meine Anwendung abst√ºrzt, sondern die einer anderen, in der sie meine Bibliothek mit einem so problematischen Destruktor f√ºr <code>resources_owner</code> . </p><br><p>  Oder eine andere Variante des gleichen Problems.  Angenommen, ich habe mich nicht geirrt, dass <code>release()</code> tats√§chlich als noexcept markiert ist.  Es war. </p><br><p>  Es wurde in Version 1.0 einer Drittanbieter-Bibliothek markiert, aus der ich <code>first_resource</code> und <code>release()</code> <code>first_resource</code> .  Und dann, nach einigen Jahren, habe ich auf Version 3.0 dieser Bibliothek aktualisiert, aber in Version 3.0 hat <code>release()</code> keinen noexcept-Modifikator mehr. </p><br><p>  Nun, was?  In der neuen Hauptversion k√∂nnten sie die API leicht besch√§digen. </p><br><p>  Erst jetzt werde ich h√∂chstwahrscheinlich vergessen, die Implementierung des Destruktors <code>resources_owner</code> korrigieren.  Und wenn anstelle von mir jemand anderes an der Unterst√ºtzung von <code>resource_owner</code> , der diesen Destruktor nie untersucht hat, bleiben die √Ñnderungen in der <code>release()</code> Signatur wahrscheinlich unbemerkt. </p><br><p>  Daher gef√§llt mir pers√∂nlich die Tatsache nicht, dass der Compiler den Programmierer in keiner Weise warnt, dass der Programmierer in der Methode / Funktion noexcept einen ausnahmefreudigen Methoden- / Funktionsaufruf ausf√ºhrt. </p><br><p>  Es w√§re besser, wenn der Compiler solche Warnungen ausgeben w√ºrde. </p><br><h1 id="spasenie-utopayuschih-delo-ruk-samih-utopayuschih">  Die Rettung des Ertrinkens ist die Arbeit des Ertrinkens selbst </h1><br><p>  OK, der Compiler gibt keine Warnungen aus.  Und gegen diesen einfachen Entwickler kann nichts unternommen werden.  Nehmen Sie keine √Ñnderungen am C ++ - Compiler f√ºr Ihre eigenen Bed√ºrfnisse vor.  Insbesondere, wenn Sie nicht einen Compiler verwenden m√ºssen, sondern verschiedene Versionen verschiedener C ++ - Compiler. </p><br><p>  Ist es m√∂glich, Hilfe vom Compiler zu erhalten, ohne in seine Innereien zu geraten?  Das hei√üt,  Ist es m√∂glich, Werkzeuge zur Steuerung des Inhalts von Methoden / Funktionen ohne Ausnahme zu erstellen, selbst wenn es sich um die dendro-f√§kale Methode handelt? </p><br><p>  Du kannst.  Schlampig, aber m√∂glich. </p><br><h1 id="otkuda-nogi-rastut">  Woher wachsen die Beine? </h1><br><p>  Der in diesem Artikel beschriebene Ansatz wurde in der Praxis getestet, als die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n√§chste Version unseres kleinen eingebetteten HTTP-Servers RESTinio vorbereitet wurde</a> . </p><br><p>  Tatsache ist, dass wir die Ausnahmesicherheitsprobleme an mehreren Stellen aus den Augen verloren haben, da RESTinio mit Funktionen gef√ºllt ist.  Insbesondere wurde im Laufe der Zeit klar, dass Ausnahmen manchmal von R√ºckrufen ausgehen k√∂nnen, die an Asio √ºbertragen wurden (was nicht der Fall sein sollte), und dass Ausnahmen im Prinzip beim Reinigen von Ressourcen auftreten k√∂nnen. </p><br><p>  Gl√ºcklicherweise haben sich diese Probleme in der Praxis nie manifestiert, aber die technischen Schulden haben sich angesammelt und es musste etwas dagegen unternommen werden.  Und Sie mussten etwas mit dem Code tun, der bereits geschrieben wurde.  Das hei√üt,  funktionierender nicht-noexcept-Code sollte in funktionierenden noexcept-Code konvertiert werden. </p><br><p>  Dies geschah mit Hilfe mehrerer Makros, die per Code an den richtigen Stellen angeordnet waren.  Zum Beispiel ein trivialer Fall: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Message_Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trigger_error_and_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Message_Builder msg_builder )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// An exception from logger/msg_builder shouldn't prevent // a call to close(). restinio::utils::log_error_noexcept( m_logger, std::move(msg_builder) ); RESTINIO_ENSURE_NOEXCEPT_CALL( close() ); }</span></span></code> </pre> <br><p>  Und hier ist ein weniger triviales Fragment: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.empty()); RESTINIO_STATIC_ASSERT_NOEXCEPT( m_context_table.pop_response_context_nonchecked()); RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.front()); RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.front().dequeue_group()); RESTINIO_STATIC_ASSERT_NOEXCEPT(make_asio_compaible_error( <span class="hljs-keyword"><span class="hljs-keyword">asio_convertible_error_t</span></span>::write_was_not_executed)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; !m_context_table.empty(); m_context_table.pop_response_context_nonchecked() ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec = make_asio_compaible_error( <span class="hljs-keyword"><span class="hljs-keyword">asio_convertible_error_t</span></span>::write_was_not_executed ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; current_ctx = m_context_table.front(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !current_ctx.empty() ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> wg = current_ctx.dequeue_group(); restinio::utils::suppress_exceptions_quietly( [&amp;] { wg.invoke_after_write_notificator_if_exists( ec ); } ); } } }</code> </pre> <br><p>  Die Verwendung dieser Makros gab mir mehrmals die Hand und zeigte auf Orte, die ich versehentlich als nicht wahrgenommen hatte, die es aber nicht waren. </p><br><p>  Der unten beschriebene Ansatz ist nat√ºrlich ein selbst hergestellter Ansatz mit quadratischen R√§dern, aber es geht ... Ich meine, es funktioniert. </p><br><p>  Weiter im Artikel werden wir die Implementierung, die vom RESTinio-Code isoliert wurde, in einen separaten Satz von Makros diskutieren. </p><br><h1 id="sut-podhoda">  Das Wesentliche des Ansatzes </h1><br><p>  Das Wesentliche des Ansatzes besteht darin, die Anweisung / den Operator (stmt), die auf noexcept √ºberpr√ºft werden muss, an ein bestimmtes Makro zu √ºbergeben.  Dieses Makro verwendet <code>static_assert(noexcept(stmt), msg)</code> , um zu √ºberpr√ºfen, ob stmt wirklich noexcept ist, und ersetzt dann stmt im Code. </p><br><p>  Im Wesentlichen ist dies: </p><br><pre> <code class="cpp hljs">ENSURE_NOEXCEPT_STATEMENT(release(some_resource));</code> </pre> <br><p>  wird ersetzt durch so etwas wie: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(release(some_resource)), <span class="hljs-string"><span class="hljs-string">"release(some_resource) is expected to be noexcept"</span></span>); release(some_resource);</code> </pre> <br><h2 id="pochemu-byl-sdelan-vybor-v-polzu-makrosov">  Warum wurde die Wahl zugunsten von Makros getroffen? </h2><br><p>  Im Prinzip k√∂nnte man auf Makros verzichten und <code>static_assert(noexcept(...))</code> direkt in den Code schreiben, unmittelbar bevor die Aktionen √ºberpr√ºft werden.  Aber Makros haben mindestens ein paar Vorteile, die den Ausschlag f√ºr die gezielte Verwendung von Makros geben. </p><br><p>  Erstens reduzieren Makros die Codeduplizierung.  Es gibt einen Vergleich: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(release(some_resource)), <span class="hljs-string"><span class="hljs-string">"release(some_resource) is expected to be noexcept"</span></span>); release(some_resource);</code> </pre> <br><p>  und </p><br><pre> <code class="cpp hljs">ENSURE_NOEXCEPT_STATEMENT(release(some_resource));</code> </pre> <br><p>  es ist klar, dass bei Makros der Hauptausdruck, d.h.  <code>release(some_resource)</code> kann nur einmal geschrieben werden.  Dies verringert die Wahrscheinlichkeit, dass der Code im Laufe der Zeit mit seiner Begleitung "kriecht", wenn eine Korrektur an einer Stelle vorgenommen und an der zweiten vergessen wurde. </p><br><p>  Zweitens k√∂nnen Makros und dementsprechend die dahinter verborgenen Pr√ºfungen sehr einfach deaktiviert werden.  Sagen wir, wenn die F√ºlle von static_assert-s die Kompilierungsgeschwindigkeit nachteilig beeinflusst (obwohl ich einen solchen Effekt nicht bemerkt habe).  Noch wichtiger ist, dass beim Aktualisieren einer Bibliothek eines Drittanbieters Kompilierungsfehler von static_assert, die hinter Makros versteckt sind, direkt mit dem Fluss bespr√ºht werden k√∂nnen.  Das vor√ºbergehende Deaktivieren von Makros kann eine reibungslose Aktualisierung des Codes erm√∂glichen, einschlie√ülich √úberpr√ºfungsmakros nacheinander zuerst in einer Datei, dann in der zweiten, dann in der dritten usw. </p><br><p>  Obwohl Makros in C ++ eine veraltete und h√∂chst kontroverse Funktion sind, wird in diesem speziellen Fall das Leben des Entwicklers vereinfacht. </p><br><h2 id="osnovnoy-makros-ensure_noexcept_statement">  Hauptmakro ENSURE_NOEXCEPT_STATEMENT </h2><br><p>  Das Hauptmakro ENSURE_NOEXCEPT_STATEMENT ist trivial implementiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENSURE_NOEXCEPT_STATEMENT(stmt) \ do { \ static_assert(noexcept(stmt), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"this statement is expected to be noexcept: "</span></span></span><span class="hljs-meta"> #stmt); \ stmt; \ } while(false)</span></span></code> </pre> <br><p>  Es wird verwendet, um zu √ºberpr√ºfen, ob die aufgerufenen Methoden / Funktionen tats√§chlich keine Ausnahme sind und dass ihre Aufrufe nicht von Try-Catch-Bl√∂cken umrahmt werden m√ºssen.  Zum Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_complex_container</span></span></span><span class="hljs-class"> {</span></span> one_container first_data_part_; another_container second_data_part_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(some_complex_container &amp; a, some_complex_container &amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; <span class="hljs-comment"><span class="hljs-comment">//  swap  noexcept,    . ENSURE_NOEXCEPT_STATEMENT(swap(a.first_data_part_, b.first_data_part_)); ENSURE_NOEXCEPT_STATEMENT(swap(a.second_data_part_, b.second_data_part_)); ... } ... void clean() noexcept { //  clean()  noexcept,    . ENSURE_NOEXCEPT_STATEMENT(first_data_part_.clean()); ENSURE_NOEXCEPT_STATEMENT(second_data_part_.clean()); ... } ... };</span></span></code> </pre> <br><p>  Dar√ºber hinaus gibt es das Makro ENSURE_NOT_NOEXCEPT_STATEMENT.  Es wird verwendet, um sicherzustellen, dass um den Aufruf herum ein zus√§tzlicher Try-Catch-Block erforderlich ist, damit m√∂gliche Ausnahmen nicht herausfliegen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_resource_owner</span></span></span><span class="hljs-class"> {</span></span> some_resource resource_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~some_resource_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  release   noexcept,  try-catch     //      . ENSURE_NOT_NOEXCEPT_STATEMENT(release(resource_)); } catch(...) {} ... } ... };</span></span></code> </pre> <br><h2 id="vspomogatelnye-makrosy-static_assert_noexcept-i-static_assert_not_noexcept">  Hilfsmakros STATIC_ASSERT_NOEXCEPT und STATIC_ASSERT_NOT_NOEXCEPT </h2><br><p>  Leider k√∂nnen die Makros ENSURE_NOEXCEPT_STATEMENT und ENSURE_NOT_NOEXCEPT_STATEMENT nur f√ºr Anweisungen / Anweisungen verwendet werden, nicht jedoch f√ºr Ausdr√ºcke, die einen Wert zur√ºckgeben.  Das hei√üt,  Sie k√∂nnen mit ENSURE_NOEXCEPT_STATEMENT nicht wie folgt schreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = ENSURE_NOEXCEPT_STATEMENT(acquire_resource(params));</code> </pre> <br><p>  Daher kann ENSURE_NOEXCEPT_STATEMENT nicht verwendet werden, z. B. in Schleifen, in denen Sie h√§ufig Folgendes schreiben m√ºssen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = something.get_first(); i != some_other_object; i = i.get_next()) {...}</code> </pre> <br><p>  und Sie m√ºssen sicherstellen, dass die Aufrufe <code>get_first()</code> , <code>get_next()</code> sowie die Zuweisung neuer Werte f√ºr i keine Ausnahme <code>get_next()</code> . </p><br><p>  Um solchen Situationen entgegenzuwirken, wurden die Makros STATIC_ASSERT_NOEXCEPT und STATIC_ASSERT_NOT_NOEXCEPT geschrieben, hinter denen nur static_asserts versteckt sind und nichts weiter.  Mit diesen Makros kann ich auf irgendeine Weise das gew√ºnschte Ergebnis erzielen (die Kompilierung dieses bestimmten Fragments wurde nicht √ºberpr√ºft): </p><br><pre> <code class="cpp hljs">STATIC_ASSERT_NOEXCEPT(something.get_first()); STATIC_ASSERT_NOEXCEPT(something.get_first().get_next()); STATIC_ASSERT_NOEXCEPT(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(something.get_first())&gt;() = something.get_first().get_next()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = something.get_first(); i != some_other_object; i = i.get_next()) {...}</code> </pre> <br><p>  Offensichtlich ist dies nicht die beste L√∂sung, weil  Dies f√ºhrt zu einer Duplizierung des Codes und erh√∂ht das Risiko seines "Kriechens" bei weiterer Wartung.  In einem ersten Schritt erwiesen sich diese einfachen Makros jedoch als n√ºtzlich. </p><br><h1 id="biblioteka-noexcept-ctcheck">  Noexcept-ctcheck-Bibliothek </h1><br><p>  Als ich diese Erfahrung in meinem Blog und auf Facebook teilte, erhielt ich einen Vorschlag, die oben genannten Entwicklungen in einer separaten Bibliothek anzuordnen.  Was getan wurde: github hat jetzt eine winzige Bibliothek, die nur f√ºr Header gedacht ist. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noexcept-compile-time-check (oder noexcept-ctcheck, wenn Sie Buchstaben sparen)</a> .  Sie k√∂nnen also alles oben Genannte ausprobieren.  Die Namen der Makros sind zwar etwas l√§nger als im Artikel verwendet.  Das hei√üt,  NOEXCEPT_CTCHECK_ENSURE_NOEXCEPT_STATEMENT anstelle von ENSURE_NOEXCEPT_STATEMENT. </p><br><h2 id="chto-v-noexcept-ctcheck-ne-popalo-poka">  Was ist (noch?) Nicht in noexcept-ctcheck eingeflossen? </h2><br><p>  Es besteht der Wunsch, das Makro ENSURE_NOEXCEPT_EXPRESSION zu erstellen, das wie folgt verwendet werden k√∂nnte: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = ENSURE_NOEXCEPT_EXPRESSION(acquire_resource(params));</code> </pre> <br><p>  In erster N√§herung k√∂nnte er ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENSURE_NOEXCEPT_EXPRESSION(expr) \ ([&amp;]() noexcept -&gt; decltype(auto) { \ static_assert(noexcept(expr), #expr </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" is expected to be noexcept"</span></span></span><span class="hljs-meta">); \ return expr; \ }())</span></span></code> </pre> <br><p>  Aber es gibt vage Vermutungen, dass es einige Fallstricke gibt, √ºber die ich nicht nachgedacht habe.  Im Allgemeinen haben die H√§nde ENSURE_NOEXCEPT_EXPRESSION :( noch nicht erreicht </p><br><h1 id="a-esli-pomechtat">  Und wenn du tr√§umst? </h1><br><p>  Mein alter Traum ist es, einen Noexcept-Block in C ++ zu bekommen, in dem der Compiler selbst nach Ausnahmen sucht und Warnungen ausgibt, wenn Ausnahmen ausgel√∂st werden k√∂nnen.  Es scheint mir, dass dies das Schreiben von ausnahmesicherem Code erleichtern w√ºrde.  Und das nicht nur in den oben genannten offensichtlichen F√§llen (Swap, Move-Operatoren, Destruktoren).  Zum Beispiel k√∂nnte ein Noexcept-Block in dieser Situation helfen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify_some_complex_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . one_container_.modify(); // ,   . ,      . //         try. noexcept { current_age_.increment(); } //    ,      . try { another_container_.modify(); ... } catch(...) { noexcept { //  ,     . current_age_.decrement(); one_container_.rollback_modifications(); } throw; } }</span></span></code> </pre> <br><p>  F√ºr die Richtigkeit des Codes ist es hier sehr wichtig, dass die in noexcept-Bl√∂cken ausgef√ºhrten Aktionen keine Ausnahmen ausl√∂sen.  Und wenn der Compiler dies verfolgen kann, ist dies eine ernsthafte Hilfe f√ºr den Entwickler. </p><br><p>  Aber vielleicht ist ein Noexcept-Block nur ein Sonderfall eines allgemeineren Problems.  N√§mlich: √úberpr√ºfen der Erwartungen des Programmierers, dass ein Codeblock bestimmte Eigenschaften hat.  Sei es das Fehlen von Ausnahmen, das Fehlen von Nebenwirkungen, das Fehlen von Rekursion, Datenrennen usw. </p><br><p>  √úberlegungen zu diesem Thema vor einigen Jahren f√ºhrten zu der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Idee, Attribute zu implizieren und zu erwarten</a> .  Diese Idee ging nicht weiter als der Blog-Beitrag, weil  w√§hrend sie sich von meinen aktuellen Interessen und M√∂glichkeiten fernh√§lt.  Aber pl√∂tzlich wird es f√ºr jemanden interessant sein und jemand wird darauf dr√§ngen, etwas Lebensf√§higeres zu schaffen. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  In diesem Artikel habe ich versucht, √ºber meine Erfahrungen bei der Vereinfachung des Schreibens von ausnahmesicherem Code zu sprechen.  Die Verwendung von Makros macht den Code nat√ºrlich nicht sch√∂ner und kompakter.  Aber es funktioniert.  Und selbst solche primitiven Makros erh√∂hen den Koeffizienten meines erholsamen Schlafes ganz erheblich.  Wenn jemand anderes nicht dar√ºber nachgedacht hat, wie er den Inhalt seiner eigenen noexcept-Methoden / -Funktionen steuern kann, wird dieser Artikel Sie m√∂glicherweise dazu inspirieren, √ºber dieses Thema nachzudenken. </p><br><p>  Und wenn jemand einen Weg gefunden hat, sein Leben beim Schreiben von Noexcept-Code zu vereinfachen, w√§re es interessant zu wissen, was diese Methode ist, bei der sie hilft und bei der sie nicht hilft.  Und wie zufrieden sind Sie mit dem, was Sie verwenden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466849/">https://habr.com/ru/post/de466849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466833/index.html">Wichtige Informationen zu Tensorflow 2.0</a></li>
<li><a href="../de466837/index.html">Wochenende auf einem Elektrofahrrad mit Gasgenerator</a></li>
<li><a href="../de466839/index.html">Geschichte von Norton Commander. Teil 1/3</a></li>
<li><a href="../de466841/index.html">Warum ein Heizkissen, wenn es einen Laptop gibt: die Untersuchung des W√§rmewiderstands auf atomarer Ebene</a></li>
<li><a href="../de466845/index.html">Umgekehrtes Interview: Welche Fragen sollten Sie dem Unternehmen stellen?</a></li>
<li><a href="../de466851/index.html">Agilex-Linie - 10 nm Intel FPGA</a></li>
<li><a href="../de466855/index.html">Turmverteidigung in Einheit schaffen: Szenarien und Wellen der Feinde</a></li>
<li><a href="../de466857/index.html">Ausf√ºhrung der Hintergrundanwendung in iOS 13</a></li>
<li><a href="../de466859/index.html">Verwenden des AD Federation Service zum Autorisieren von AWS-Benutzern mit Verteilung von Rechten</a></li>
<li><a href="../de466861/index.html">Wie man mit einem Hackathon der Realit√§t entkommt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>