<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😤 🧓🏼 👩🏻‍🏫 noexcept-ctcheck oder ein paar einfache Makros, die dem Compiler helfen, noexcept-Code zu schreiben 🤟 ⏫ 😸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Entwicklung in C ++ müssen Sie von Zeit zu Zeit Code schreiben, in dem keine Ausnahmen auftreten dürfen. Zum Beispiel, wenn wir einen ausnahme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>noexcept-ctcheck oder ein paar einfache Makros, die dem Compiler helfen, noexcept-Code zu schreiben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466849/"><p>  Bei der Entwicklung in C ++ müssen Sie von Zeit zu Zeit Code schreiben, in dem keine Ausnahmen auftreten dürfen.  Zum Beispiel, wenn wir einen ausnahmefreien Swap für native Typen schreiben oder eine noexcept move-Anweisung für unsere Klasse definieren oder manuell einen nichttrivialen Destruktor implementieren müssen. </p><br><p>  In C ++ 11 wurde der Sprache der Modifikator noexcept hinzugefügt, damit der Entwickler verstehen kann, dass Ausnahmen von der mit noexcept gekennzeichneten Funktion (oder Methode) nicht verworfen werden können.  Daher können Funktionen mit einer solchen Markierung sicher in Kontexten verwendet werden, in denen keine Ausnahmen auftreten sollten. </p><br><p>  Zum Beispiel, wenn ich diese Typen und Funktionen habe: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_resource</span></span></span><span class="hljs-class"> {</span></span>...}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">second_resource</span></span></span><span class="hljs-class"> {</span></span>...}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first_resource &amp; r)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(second_resource &amp; r)</span></span></span></span>;</code> </pre> <br><p>  und es gibt eine bestimmte <code>resources_owner</code> Klasse, die Objekte wie <code>first_resource</code> und <code>second_resource</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resources_owner</span></span></span><span class="hljs-class"> {</span></span> first_resource first_resource_; second_resource second_resource_; ... };</code> </pre> <br><p>  dann kann ich den Destruktor <code>resources_owner</code> wie folgt schreiben: </p><br><pre> <code class="cpp hljs">resources_owner::~resources_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  release()   ,    . release(first_resource_); //    close()   ,  //   try-catch. try{ close(second_resource_); } catch(...) {} }</span></span></code> </pre> <br><p>  In gewisser Weise hat noexcept in C ++ 11 das Leben eines C ++ - Entwicklers erleichtert.  Aber die derzeitige Noexcept-Implementierung in modernem C ++ hat eine böse Seite ... </p><br><h1 id="kompilyator-ne-pomogaet-kontrolirovat-soderzhimoe-noexcept-funkciy-i-metodov">  Der Compiler hilft nicht dabei, den Inhalt von noexcept-Funktionen und -Methoden zu steuern </h1><a name="habracut"></a><br><p>  Angenommen, ich habe mich im obigen Beispiel geirrt: Aus irgendeinem Grund habe ich <code>release()</code> als noexcept markiert, aber in Wirklichkeit ist dies keine Ausnahme und kann Ausnahmen auslösen.  Dies bedeutet, dass, wenn ich einen Destruktor mit einem solchen Wurf <code>release()</code> schreibe: </p><br><pre> <code class="cpp hljs">resources_owner::~resources_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { release(first_resource_); <span class="hljs-comment"><span class="hljs-comment">//  try-catch   ... }</span></span></code> </pre> <br><p>  dann bitte ich um Ärger.  Früher oder später wird diese <code>release()</code> eine Ausnahme auslösen und meine gesamte Anwendung wird aufgrund des automatisch aufgerufenen <code>std::terminate()</code> abstürzen.  Es wird noch schlimmer sein, wenn nicht meine Anwendung abstürzt, sondern die einer anderen, in der sie meine Bibliothek mit einem so problematischen Destruktor für <code>resources_owner</code> . </p><br><p>  Oder eine andere Variante des gleichen Problems.  Angenommen, ich habe mich nicht geirrt, dass <code>release()</code> tatsächlich als noexcept markiert ist.  Es war. </p><br><p>  Es wurde in Version 1.0 einer Drittanbieter-Bibliothek markiert, aus der ich <code>first_resource</code> und <code>release()</code> <code>first_resource</code> .  Und dann, nach einigen Jahren, habe ich auf Version 3.0 dieser Bibliothek aktualisiert, aber in Version 3.0 hat <code>release()</code> keinen noexcept-Modifikator mehr. </p><br><p>  Nun, was?  In der neuen Hauptversion könnten sie die API leicht beschädigen. </p><br><p>  Erst jetzt werde ich höchstwahrscheinlich vergessen, die Implementierung des Destruktors <code>resources_owner</code> korrigieren.  Und wenn anstelle von mir jemand anderes an der Unterstützung von <code>resource_owner</code> , der diesen Destruktor nie untersucht hat, bleiben die Änderungen in der <code>release()</code> Signatur wahrscheinlich unbemerkt. </p><br><p>  Daher gefällt mir persönlich die Tatsache nicht, dass der Compiler den Programmierer in keiner Weise warnt, dass der Programmierer in der Methode / Funktion noexcept einen ausnahmefreudigen Methoden- / Funktionsaufruf ausführt. </p><br><p>  Es wäre besser, wenn der Compiler solche Warnungen ausgeben würde. </p><br><h1 id="spasenie-utopayuschih-delo-ruk-samih-utopayuschih">  Die Rettung des Ertrinkens ist die Arbeit des Ertrinkens selbst </h1><br><p>  OK, der Compiler gibt keine Warnungen aus.  Und gegen diesen einfachen Entwickler kann nichts unternommen werden.  Nehmen Sie keine Änderungen am C ++ - Compiler für Ihre eigenen Bedürfnisse vor.  Insbesondere, wenn Sie nicht einen Compiler verwenden müssen, sondern verschiedene Versionen verschiedener C ++ - Compiler. </p><br><p>  Ist es möglich, Hilfe vom Compiler zu erhalten, ohne in seine Innereien zu geraten?  Das heißt,  Ist es möglich, Werkzeuge zur Steuerung des Inhalts von Methoden / Funktionen ohne Ausnahme zu erstellen, selbst wenn es sich um die dendro-fäkale Methode handelt? </p><br><p>  Du kannst.  Schlampig, aber möglich. </p><br><h1 id="otkuda-nogi-rastut">  Woher wachsen die Beine? </h1><br><p>  Der in diesem Artikel beschriebene Ansatz wurde in der Praxis getestet, als die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nächste Version unseres kleinen eingebetteten HTTP-Servers RESTinio vorbereitet wurde</a> . </p><br><p>  Tatsache ist, dass wir die Ausnahmesicherheitsprobleme an mehreren Stellen aus den Augen verloren haben, da RESTinio mit Funktionen gefüllt ist.  Insbesondere wurde im Laufe der Zeit klar, dass Ausnahmen manchmal von Rückrufen ausgehen können, die an Asio übertragen wurden (was nicht der Fall sein sollte), und dass Ausnahmen im Prinzip beim Reinigen von Ressourcen auftreten können. </p><br><p>  Glücklicherweise haben sich diese Probleme in der Praxis nie manifestiert, aber die technischen Schulden haben sich angesammelt und es musste etwas dagegen unternommen werden.  Und Sie mussten etwas mit dem Code tun, der bereits geschrieben wurde.  Das heißt,  funktionierender nicht-noexcept-Code sollte in funktionierenden noexcept-Code konvertiert werden. </p><br><p>  Dies geschah mit Hilfe mehrerer Makros, die per Code an den richtigen Stellen angeordnet waren.  Zum Beispiel ein trivialer Fall: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Message_Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trigger_error_and_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Message_Builder msg_builder )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// An exception from logger/msg_builder shouldn't prevent // a call to close(). restinio::utils::log_error_noexcept( m_logger, std::move(msg_builder) ); RESTINIO_ENSURE_NOEXCEPT_CALL( close() ); }</span></span></code> </pre> <br><p>  Und hier ist ein weniger triviales Fragment: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.empty()); RESTINIO_STATIC_ASSERT_NOEXCEPT( m_context_table.pop_response_context_nonchecked()); RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.front()); RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.front().dequeue_group()); RESTINIO_STATIC_ASSERT_NOEXCEPT(make_asio_compaible_error( <span class="hljs-keyword"><span class="hljs-keyword">asio_convertible_error_t</span></span>::write_was_not_executed)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; !m_context_table.empty(); m_context_table.pop_response_context_nonchecked() ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec = make_asio_compaible_error( <span class="hljs-keyword"><span class="hljs-keyword">asio_convertible_error_t</span></span>::write_was_not_executed ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; current_ctx = m_context_table.front(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !current_ctx.empty() ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> wg = current_ctx.dequeue_group(); restinio::utils::suppress_exceptions_quietly( [&amp;] { wg.invoke_after_write_notificator_if_exists( ec ); } ); } } }</code> </pre> <br><p>  Die Verwendung dieser Makros gab mir mehrmals die Hand und zeigte auf Orte, die ich versehentlich als nicht wahrgenommen hatte, die es aber nicht waren. </p><br><p>  Der unten beschriebene Ansatz ist natürlich ein selbst hergestellter Ansatz mit quadratischen Rädern, aber es geht ... Ich meine, es funktioniert. </p><br><p>  Weiter im Artikel werden wir die Implementierung, die vom RESTinio-Code isoliert wurde, in einen separaten Satz von Makros diskutieren. </p><br><h1 id="sut-podhoda">  Das Wesentliche des Ansatzes </h1><br><p>  Das Wesentliche des Ansatzes besteht darin, die Anweisung / den Operator (stmt), die auf noexcept überprüft werden muss, an ein bestimmtes Makro zu übergeben.  Dieses Makro verwendet <code>static_assert(noexcept(stmt), msg)</code> , um zu überprüfen, ob stmt wirklich noexcept ist, und ersetzt dann stmt im Code. </p><br><p>  Im Wesentlichen ist dies: </p><br><pre> <code class="cpp hljs">ENSURE_NOEXCEPT_STATEMENT(release(some_resource));</code> </pre> <br><p>  wird ersetzt durch so etwas wie: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(release(some_resource)), <span class="hljs-string"><span class="hljs-string">"release(some_resource) is expected to be noexcept"</span></span>); release(some_resource);</code> </pre> <br><h2 id="pochemu-byl-sdelan-vybor-v-polzu-makrosov">  Warum wurde die Wahl zugunsten von Makros getroffen? </h2><br><p>  Im Prinzip könnte man auf Makros verzichten und <code>static_assert(noexcept(...))</code> direkt in den Code schreiben, unmittelbar bevor die Aktionen überprüft werden.  Aber Makros haben mindestens ein paar Vorteile, die den Ausschlag für die gezielte Verwendung von Makros geben. </p><br><p>  Erstens reduzieren Makros die Codeduplizierung.  Es gibt einen Vergleich: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(release(some_resource)), <span class="hljs-string"><span class="hljs-string">"release(some_resource) is expected to be noexcept"</span></span>); release(some_resource);</code> </pre> <br><p>  und </p><br><pre> <code class="cpp hljs">ENSURE_NOEXCEPT_STATEMENT(release(some_resource));</code> </pre> <br><p>  es ist klar, dass bei Makros der Hauptausdruck, d.h.  <code>release(some_resource)</code> kann nur einmal geschrieben werden.  Dies verringert die Wahrscheinlichkeit, dass der Code im Laufe der Zeit mit seiner Begleitung "kriecht", wenn eine Korrektur an einer Stelle vorgenommen und an der zweiten vergessen wurde. </p><br><p>  Zweitens können Makros und dementsprechend die dahinter verborgenen Prüfungen sehr einfach deaktiviert werden.  Sagen wir, wenn die Fülle von static_assert-s die Kompilierungsgeschwindigkeit nachteilig beeinflusst (obwohl ich einen solchen Effekt nicht bemerkt habe).  Noch wichtiger ist, dass beim Aktualisieren einer Bibliothek eines Drittanbieters Kompilierungsfehler von static_assert, die hinter Makros versteckt sind, direkt mit dem Fluss besprüht werden können.  Das vorübergehende Deaktivieren von Makros kann eine reibungslose Aktualisierung des Codes ermöglichen, einschließlich Überprüfungsmakros nacheinander zuerst in einer Datei, dann in der zweiten, dann in der dritten usw. </p><br><p>  Obwohl Makros in C ++ eine veraltete und höchst kontroverse Funktion sind, wird in diesem speziellen Fall das Leben des Entwicklers vereinfacht. </p><br><h2 id="osnovnoy-makros-ensure_noexcept_statement">  Hauptmakro ENSURE_NOEXCEPT_STATEMENT </h2><br><p>  Das Hauptmakro ENSURE_NOEXCEPT_STATEMENT ist trivial implementiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENSURE_NOEXCEPT_STATEMENT(stmt) \ do { \ static_assert(noexcept(stmt), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"this statement is expected to be noexcept: "</span></span></span><span class="hljs-meta"> #stmt); \ stmt; \ } while(false)</span></span></code> </pre> <br><p>  Es wird verwendet, um zu überprüfen, ob die aufgerufenen Methoden / Funktionen tatsächlich keine Ausnahme sind und dass ihre Aufrufe nicht von Try-Catch-Blöcken umrahmt werden müssen.  Zum Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_complex_container</span></span></span><span class="hljs-class"> {</span></span> one_container first_data_part_; another_container second_data_part_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(some_complex_container &amp; a, some_complex_container &amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; <span class="hljs-comment"><span class="hljs-comment">//  swap  noexcept,    . ENSURE_NOEXCEPT_STATEMENT(swap(a.first_data_part_, b.first_data_part_)); ENSURE_NOEXCEPT_STATEMENT(swap(a.second_data_part_, b.second_data_part_)); ... } ... void clean() noexcept { //  clean()  noexcept,    . ENSURE_NOEXCEPT_STATEMENT(first_data_part_.clean()); ENSURE_NOEXCEPT_STATEMENT(second_data_part_.clean()); ... } ... };</span></span></code> </pre> <br><p>  Darüber hinaus gibt es das Makro ENSURE_NOT_NOEXCEPT_STATEMENT.  Es wird verwendet, um sicherzustellen, dass um den Aufruf herum ein zusätzlicher Try-Catch-Block erforderlich ist, damit mögliche Ausnahmen nicht herausfliegen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_resource_owner</span></span></span><span class="hljs-class"> {</span></span> some_resource resource_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~some_resource_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  release   noexcept,  try-catch     //      . ENSURE_NOT_NOEXCEPT_STATEMENT(release(resource_)); } catch(...) {} ... } ... };</span></span></code> </pre> <br><h2 id="vspomogatelnye-makrosy-static_assert_noexcept-i-static_assert_not_noexcept">  Hilfsmakros STATIC_ASSERT_NOEXCEPT und STATIC_ASSERT_NOT_NOEXCEPT </h2><br><p>  Leider können die Makros ENSURE_NOEXCEPT_STATEMENT und ENSURE_NOT_NOEXCEPT_STATEMENT nur für Anweisungen / Anweisungen verwendet werden, nicht jedoch für Ausdrücke, die einen Wert zurückgeben.  Das heißt,  Sie können mit ENSURE_NOEXCEPT_STATEMENT nicht wie folgt schreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = ENSURE_NOEXCEPT_STATEMENT(acquire_resource(params));</code> </pre> <br><p>  Daher kann ENSURE_NOEXCEPT_STATEMENT nicht verwendet werden, z. B. in Schleifen, in denen Sie häufig Folgendes schreiben müssen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = something.get_first(); i != some_other_object; i = i.get_next()) {...}</code> </pre> <br><p>  und Sie müssen sicherstellen, dass die Aufrufe <code>get_first()</code> , <code>get_next()</code> sowie die Zuweisung neuer Werte für i keine Ausnahme <code>get_next()</code> . </p><br><p>  Um solchen Situationen entgegenzuwirken, wurden die Makros STATIC_ASSERT_NOEXCEPT und STATIC_ASSERT_NOT_NOEXCEPT geschrieben, hinter denen nur static_asserts versteckt sind und nichts weiter.  Mit diesen Makros kann ich auf irgendeine Weise das gewünschte Ergebnis erzielen (die Kompilierung dieses bestimmten Fragments wurde nicht überprüft): </p><br><pre> <code class="cpp hljs">STATIC_ASSERT_NOEXCEPT(something.get_first()); STATIC_ASSERT_NOEXCEPT(something.get_first().get_next()); STATIC_ASSERT_NOEXCEPT(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(something.get_first())&gt;() = something.get_first().get_next()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = something.get_first(); i != some_other_object; i = i.get_next()) {...}</code> </pre> <br><p>  Offensichtlich ist dies nicht die beste Lösung, weil  Dies führt zu einer Duplizierung des Codes und erhöht das Risiko seines "Kriechens" bei weiterer Wartung.  In einem ersten Schritt erwiesen sich diese einfachen Makros jedoch als nützlich. </p><br><h1 id="biblioteka-noexcept-ctcheck">  Noexcept-ctcheck-Bibliothek </h1><br><p>  Als ich diese Erfahrung in meinem Blog und auf Facebook teilte, erhielt ich einen Vorschlag, die oben genannten Entwicklungen in einer separaten Bibliothek anzuordnen.  Was getan wurde: github hat jetzt eine winzige Bibliothek, die nur für Header gedacht ist. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noexcept-compile-time-check (oder noexcept-ctcheck, wenn Sie Buchstaben sparen)</a> .  Sie können also alles oben Genannte ausprobieren.  Die Namen der Makros sind zwar etwas länger als im Artikel verwendet.  Das heißt,  NOEXCEPT_CTCHECK_ENSURE_NOEXCEPT_STATEMENT anstelle von ENSURE_NOEXCEPT_STATEMENT. </p><br><h2 id="chto-v-noexcept-ctcheck-ne-popalo-poka">  Was ist (noch?) Nicht in noexcept-ctcheck eingeflossen? </h2><br><p>  Es besteht der Wunsch, das Makro ENSURE_NOEXCEPT_EXPRESSION zu erstellen, das wie folgt verwendet werden könnte: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = ENSURE_NOEXCEPT_EXPRESSION(acquire_resource(params));</code> </pre> <br><p>  In erster Näherung könnte er ungefähr so ​​aussehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENSURE_NOEXCEPT_EXPRESSION(expr) \ ([&amp;]() noexcept -&gt; decltype(auto) { \ static_assert(noexcept(expr), #expr </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" is expected to be noexcept"</span></span></span><span class="hljs-meta">); \ return expr; \ }())</span></span></code> </pre> <br><p>  Aber es gibt vage Vermutungen, dass es einige Fallstricke gibt, über die ich nicht nachgedacht habe.  Im Allgemeinen haben die Hände ENSURE_NOEXCEPT_EXPRESSION :( noch nicht erreicht </p><br><h1 id="a-esli-pomechtat">  Und wenn du träumst? </h1><br><p>  Mein alter Traum ist es, einen Noexcept-Block in C ++ zu bekommen, in dem der Compiler selbst nach Ausnahmen sucht und Warnungen ausgibt, wenn Ausnahmen ausgelöst werden können.  Es scheint mir, dass dies das Schreiben von ausnahmesicherem Code erleichtern würde.  Und das nicht nur in den oben genannten offensichtlichen Fällen (Swap, Move-Operatoren, Destruktoren).  Zum Beispiel könnte ein Noexcept-Block in dieser Situation helfen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify_some_complex_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . one_container_.modify(); // ,   . ,      . //         try. noexcept { current_age_.increment(); } //    ,      . try { another_container_.modify(); ... } catch(...) { noexcept { //  ,     . current_age_.decrement(); one_container_.rollback_modifications(); } throw; } }</span></span></code> </pre> <br><p>  Für die Richtigkeit des Codes ist es hier sehr wichtig, dass die in noexcept-Blöcken ausgeführten Aktionen keine Ausnahmen auslösen.  Und wenn der Compiler dies verfolgen kann, ist dies eine ernsthafte Hilfe für den Entwickler. </p><br><p>  Aber vielleicht ist ein Noexcept-Block nur ein Sonderfall eines allgemeineren Problems.  Nämlich: Überprüfen der Erwartungen des Programmierers, dass ein Codeblock bestimmte Eigenschaften hat.  Sei es das Fehlen von Ausnahmen, das Fehlen von Nebenwirkungen, das Fehlen von Rekursion, Datenrennen usw. </p><br><p>  Überlegungen zu diesem Thema vor einigen Jahren führten zu der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Idee, Attribute zu implizieren und zu erwarten</a> .  Diese Idee ging nicht weiter als der Blog-Beitrag, weil  während sie sich von meinen aktuellen Interessen und Möglichkeiten fernhält.  Aber plötzlich wird es für jemanden interessant sein und jemand wird darauf drängen, etwas Lebensfähigeres zu schaffen. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  In diesem Artikel habe ich versucht, über meine Erfahrungen bei der Vereinfachung des Schreibens von ausnahmesicherem Code zu sprechen.  Die Verwendung von Makros macht den Code natürlich nicht schöner und kompakter.  Aber es funktioniert.  Und selbst solche primitiven Makros erhöhen den Koeffizienten meines erholsamen Schlafes ganz erheblich.  Wenn jemand anderes nicht darüber nachgedacht hat, wie er den Inhalt seiner eigenen noexcept-Methoden / -Funktionen steuern kann, wird dieser Artikel Sie möglicherweise dazu inspirieren, über dieses Thema nachzudenken. </p><br><p>  Und wenn jemand einen Weg gefunden hat, sein Leben beim Schreiben von Noexcept-Code zu vereinfachen, wäre es interessant zu wissen, was diese Methode ist, bei der sie hilft und bei der sie nicht hilft.  Und wie zufrieden sind Sie mit dem, was Sie verwenden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466849/">https://habr.com/ru/post/de466849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466833/index.html">Wichtige Informationen zu Tensorflow 2.0</a></li>
<li><a href="../de466837/index.html">Wochenende auf einem Elektrofahrrad mit Gasgenerator</a></li>
<li><a href="../de466839/index.html">Geschichte von Norton Commander. Teil 1/3</a></li>
<li><a href="../de466841/index.html">Warum ein Heizkissen, wenn es einen Laptop gibt: die Untersuchung des Wärmewiderstands auf atomarer Ebene</a></li>
<li><a href="../de466845/index.html">Umgekehrtes Interview: Welche Fragen sollten Sie dem Unternehmen stellen?</a></li>
<li><a href="../de466851/index.html">Agilex-Linie - 10 nm Intel FPGA</a></li>
<li><a href="../de466855/index.html">Turmverteidigung in Einheit schaffen: Szenarien und Wellen der Feinde</a></li>
<li><a href="../de466857/index.html">Ausführung der Hintergrundanwendung in iOS 13</a></li>
<li><a href="../de466859/index.html">Verwenden des AD Federation Service zum Autorisieren von AWS-Benutzern mit Verteilung von Rechten</a></li>
<li><a href="../de466861/index.html">Wie man mit einem Hackathon der Realität entkommt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>