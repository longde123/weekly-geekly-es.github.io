<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔏 💆 🚪 Wie und warum haben wir unser ECS geschrieben? 🎤 👩🏼‍🍳 🉐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem früheren Artikel habe ich die Technologien und Ansätze beschrieben, die wir bei der Entwicklung eines neuen mobilen, schnellen Shooters verwe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie und warum haben wir unser ECS geschrieben?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/413729/">  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel habe</a> ich die Technologien und Ansätze beschrieben, die wir bei der Entwicklung eines neuen mobilen, schnellen Shooters verwenden.  Weil  Es war eine Rezension und sogar ein oberflächlicher Artikel - heute werde ich tiefer gehen und detailliert erklären, warum wir beschlossen haben, unser eigenes ECS-Framework zu schreiben und die vorhandenen nicht verwendet haben.  Am Ende gibt es Codebeispiele und einen kleinen Bonus. <br><img src="https://habrastorage.org/webt/qn/lg/zw/qnlgzwthwpjkkzzeeilv257iiga.png"><br><a name="habracut"></a><br><h3>  Was ist ECS als Beispiel? </h3><br>  Ich habe bereits kurz beschrieben, was Entity Component System ist, und es gibt Artikel auf Habré über ECS (im Grunde genommen jedoch Übersetzungen von Artikeln - siehe meine Rezension der interessantesten davon am Ende des Artikels als Bonus).  Und heute werde ich Ihnen anhand unseres Codebeispiels erklären, wie wir ECS verwenden. <br><br>  Das obige Diagramm beschreibt die Essenz des <i>Players</i> , seine Komponenten und deren Daten sowie die Systeme, die mit dem Player und seinen Komponenten arbeiten.  Das Hauptobjekt im Diagramm ist der Spieler: <br><br><ul><li>  kann sich im Raum bewegen - <i>Transformations-</i> und <i>Bewegungskomponenten</i> , <i>MoveSystem</i> ; </li><li>  hat etwas Gesundheit und kann sterben - Komponente <i>Gesundheit</i> , <i>Schaden</i> , <i>DamageSystem</i> ; </li><li>  nach dem Tod erscheint am Respawn-Punkt - die <i>Transformationskomponente</i> für die Position, das <i>RespawnSystem</i> ; </li><li>  kann unverwundbar sein - Komponente <i>unbesiegbar</i> . </li></ul><br>  Wir beschreiben dies mit einem Code.  Lassen Sie uns zunächst Schnittstellen für Komponenten und Systeme erhalten.  Komponenten können gemeinsame Hilfsmethoden haben, das System hat nur eine <i>Execute-</i> Methode, die den Zustand der Welt am Eingang zur Verarbeitung empfängt: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IComponent</span></span> { <span class="hljs-comment"><span class="hljs-comment">// &lt; &gt; } public interface ISystem { void Execute(GameState gs); }</span></span></code> </pre> <br>  Für Komponenten erstellen wir Stub-Klassen, die von unserem Codegenerator verwendet werden, um sie in tatsächlich verwendeten Komponentencode zu konvertieren.  Lassen Sie uns ein paar Leerzeichen für <i>Gesundheit</i> , <i>Schaden</i> und <i>Unbesiegbar bekommen</i> (für den Rest der Komponenten wird es ähnlich sein). <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Component</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Health</span></span> { [Max(<span class="hljs-number"><span class="hljs-number">1000</span></span>)] <span class="hljs-comment"><span class="hljs-comment">//  -  1000 public int Hp; // -   public Health(int hp) {} } [Component] public class Damage { [DontSend] //      ,      public uint Amount; // -  public Entity Victim; //    public Entity Source; //    public Damage(uint amount, Entity victim, Entity source) {} } [Component] public class Invincible //   ,  ,    { }</span></span></code> </pre> <br>  Komponenten bestimmen den Zustand der Welt, daher enthalten sie nur Daten ohne Methoden.  Gleichzeitig enthält <i>Invincible</i> keine Daten. Sie werden in der Logik als Zeichen der Unverwundbarkeit verwendet. Wenn die Essenz des Spielers diese Komponente enthält, ist der Spieler jetzt unverwundbar. <br><br>  Das <i>Component-</i> Attribut wird vom Generator verwendet, um die leeren Klassen für die Komponenten zu finden.  Die <i>Attribute</i> <i>Max</i> und <i>DontSend</i> werden als Hinweise für die Serialisierung und Reduzierung der Größe des Status der Welt benötigt, der über das Netzwerk übertragen oder auf der Festplatte gespeichert wird.  In diesem Fall serialisiert der Server das Feld <i>Betrag nicht</i> und sendet es über das Netzwerk (da Clients diesen Parameter nicht verwenden, wird er nur auf dem Server benötigt).  Und das <i>HP-</i> Feld kann angesichts des maximalen Gesundheitswerts gut in mehrere Bits gepackt werden. <br><br>  Wir haben auch eine <i>vorgefertigte Entitätsklasse</i> , in der wir Informationen zu allen möglichen Komponenten einer Entität hinzufügen, und der Generator erstellt bereits eine echte Klasse daraus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Entity</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Health Health; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Damage Damage; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Invincible Invincible; <span class="hljs-comment"><span class="hljs-comment">// ... &lt; &gt; }</span></span></code> </pre> <br>  Danach erstellt unser Generator den Code der Komponentenklassen " <i>Gesundheit"</i> , " <i>Schaden"</i> und " <i>Unbesiegbar"</i> , der bereits in der Spielelogik verwendet wird: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Health</span></span> : <span class="hljs-title"><span class="hljs-title">IComponent</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Hp; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reset</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Hp = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// ... &lt;  &gt; } public sealed class Damage : IComponent { public int Amount; public Entity Victim; public Entity Source; public void Reset() { Amount = default(int); Victim = default(Entity); Source = default(Entity); } // ... &lt;  &gt; } public sealed class Invincible : IComponent { }</span></span></code> </pre> <br>  Wie Sie sehen können, blieben die Daten in den Klassen und Methoden wurden hinzugefügt, z. B. <i>Zurücksetzen</i> .  Es ist erforderlich, um Komponenten in Pools zu optimieren und wiederzuverwenden.  Andere Hilfsmethoden enthalten keine Geschäftslogik - ich werde sie der Kürze halber nicht geben. <br><br>  Es wird auch eine Klasse für den Zustand der Welt generiert, die eine Liste aller Komponenten und Entitäten enthält: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameState</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  public Table&lt;Movement&gt; Movements; public Table&lt;Health&gt; Healths; public Table&lt;Damage&gt; Damages; public Table&lt;Transform&gt; Transforms; public Table&lt;Invincible&gt; Invincibles; //   public Entity CreateEntity() { /* &lt;&gt; */ } public void Copy(GameState gs2) { /* &lt;&gt; */ } public Entity this[uint id] { /* &lt;&gt; */ } // ... &lt;   &gt; }</span></span></code> </pre> <br>  Und schließlich der generierte Code für <i>Entity</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Entity</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Id; <span class="hljs-comment"><span class="hljs-comment">//   public GameState GameState; //     //     : public Health Health { get { return GameState.Healths[Id]; } } public Damage Damage { get { return GameState.Damages[Id]; } } public Invincible Invincible { get { return GameState.Invincibles[Id]; } } // …     public Damage AddDamage() { return GameState.Damages.Insert(Id); } public Damage AddDamage(int total, Entity victim, Entity source) { var c = GameState.Damages.Insert(Id); c.Amount = total; c.Victim = victim; c.Source = source; return c; } public void DelDamage() { GameState.Damages.Delete(Id); } // … &lt;     &gt; }</span></span></code> </pre> <br>  Die <i>Entitätsklasse</i> ist im Wesentlichen nur eine Komponentenkennung.  Der Verweis auf die Objekte der <i>GameState-</i> Welt wird nur in Hilfsmethoden verwendet, um das Schreiben von Geschäftslogikcode zu vereinfachen.  Wenn wir die Kennung einer Komponente kennen, können wir damit Beziehungen zwischen Entitäten serialisieren und Verknüpfungen in Komponenten zu anderen Entitäten implementieren.  Beispielsweise enthält die <i>Schadenskomponente</i> einen Verweis auf die <i>Opfereinheit</i> , um festzustellen, wer beschädigt wurde. <br><br>  Dies beendet den generierten Code.  Im Allgemeinen benötigen wir einen Generator, um nicht jedes Mal Hilfsmethoden zu schreiben.  Wir beschreiben die Komponenten nur als Daten, dann erledigt der Generator die ganze Arbeit.  Beispiele für Hilfsmethoden: <br><br><ul><li>  Entitäten erstellen / löschen; </li><li>  Hinzufügen / Entfernen / Kopieren einer Komponente, Zugriff darauf, falls vorhanden; </li><li>  vergleiche zwei Staaten der Welt; </li><li>  den Zustand der Welt serialisieren; </li><li>  Delta-Komprimierung; </li><li>  Code einer Webseite oder eines Unity-Fensters zur Anzeige des Zustands der Welt, der Entitäten, der Komponenten (siehe Details unten); </li><li>  usw. </li></ul><br>  Fahren wir mit dem Systemcode fort.  Sie definieren Geschäftslogik.  Schreiben wir zum Beispiel den Code eines Systems, das den Schaden eines Spielers berechnet: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DamageSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISystem.Execute(GameState gs) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> damage <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.Damages) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> invincible = damage.Victim.Invincible; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (invincible != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> health = damage.Victim.Health; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (health == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; health.Hp -= damage.Amount; } } }</code> </pre> <br>  Das System durchläuft alle <i>Schadenskomponenten</i> der Welt und prüft, ob ein potenziell beschädigter Spieler ( <i>Opfer</i> ) eine <i>unbesiegbare</i> Komponente enthält.  Wenn dies der Fall ist, ist der Spieler unverwundbar und es entsteht kein Schaden.  Als nächstes erhalten wir die <i>Gesundheitskomponente</i> des Opfers und reduzieren die Gesundheit des Spielers um die Größe des Schadens. <br><br>  Betrachten Sie die Hauptmerkmale der Systeme: <br><br><ol><li>  Ein System ist normalerweise eine zustandslose Klasse, enthält keine internen Daten und versucht nicht, sie irgendwo zu speichern, außer für Daten über die Welt, die von außen übertragen werden. </li><li>  Systeme durchlaufen normalerweise alle Komponenten eines bestimmten Typs und arbeiten mit ihnen.  Sie werden normalerweise nach der Art der Komponente ( <i>Damage</i> → <i>DamageSystem</i> ) oder nach der von ihnen ausgeführten Aktion ( <i>RespawnSystem</i> ) <i>aufgerufen</i> . </li><li>  Das System implementiert minimale Funktionalität.  Wenn wir beispielsweise weiter gehen, nachdem das <i>DamageSystem ausgeführt wurde, entfernt ein</i> anderes <i>RemoveDamageSystem</i> alle <i>Damage-</i> Komponenten.  Im nächsten Tick kann ein anderes <i>ApplyDamageSystem,</i> das auf dem Schießen des Spielers basiert, die <i>Schadenskomponente erneut</i> mit neuem Schaden aufhängen.  Und dann überprüft das <i>PlayerDeathSystem den Zustand</i> des Spielers ( <i>Health.Hp</i> ) und zerstört, wenn er kleiner oder gleich 0 ist, alle Komponenten des Spielers mit Ausnahme von <i>Transform</i> und fügt die Komponente <i>Dead</i> Flag hinzu. </li></ol><br>  Insgesamt erhalten wir die folgenden Klassen und die Beziehungen zwischen ihnen: <br><img src="https://habrastorage.org/webt/g7/59/mq/g759mq06qfqqjymhz8ympcwejro.png"><br><br><h3>  Einige Fakten zu ECS </h3><br>  ECS hat seine Vor- und Nachteile als Entwicklungsansatz und als Repräsentationsmethode für die Welt des Spiels. Jeder entscheidet selbst, ob er es nutzt oder nicht.  Beginnen wir mit den Profis: <br><br><ul><li>  <b>Zusammensetzung versus Mehrfachvererbung.</b>  Bei Mehrfachvererbung kann eine Reihe unnötiger Funktionen vererbt werden.  Im Fall von ECS wird die Funktionalität angezeigt / ausgeblendet, wenn eine Komponente hinzugefügt / entfernt wird. </li><li>  <b>Trennung von Logik und Daten.</b>  Die Fähigkeit, die Logik zu ändern (Systeme ändern, Komponenten entfernen / hinzufügen), ohne Daten zu beschädigen.  Das heißt,  Sie können die Gruppe von Systemen, die für eine bestimmte Funktionalität verantwortlich sind, jederzeit deaktivieren. Alles andere funktioniert weiterhin und dies hat keine Auswirkungen auf die Daten. </li><li>  <b>Der Spielzyklus wird vereinfacht.</b>  Ein <i>Update wird</i> angezeigt und der gesamte Zyklus ist in Systeme unterteilt.  Daten werden unabhängig von der Engine vom "Flow" im System verarbeitet (es gibt keine Millionen von <i>Update-</i> Aufrufen wie in Unity). </li><li>  <b>Eine Entität weiß nicht, welche Klassen sie betreffen</b> (und sollte es nicht wissen). </li><li>  <b>Effiziente Speichernutzung</b> .  Dies hängt von der Implementierung von ECS ab.  Sie können erstellte Entitätsobjekte und -komponenten mithilfe von Pools wiederverwenden.  Sie können Werttypen für Daten verwenden und diese nebeneinander im Speicher speichern ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenlokalität</a> ). </li><li>  <b>Es ist einfacher zu testen,</b> wann Daten von der Logik getrennt sind.  Besonders wenn man bedenkt, dass Logik ein kleines System mit mehreren Codezeilen ist. </li><li>  <b>Zeigen Sie den Zustand der Welt in Echtzeit an und bearbeiten Sie ihn</b> .  Weil  Der Zustand der Welt besteht nur aus Daten. Wir haben ein Tool geschrieben, das auf der Webseite den gesamten Zustand der Welt in einem Match auf dem Server (sowie die Matchszene in 3D) anzeigt.  Jede Komponente einer Entität kann angezeigt, geändert oder gelöscht werden.  Dasselbe kann im Unity-Editor für den Client ausgeführt werden. </li></ul><br><img src="https://habrastorage.org/webt/zd/rz/a-/zdrza-80yltaqp8g3dqwd59zgqw.jpeg"><br><br>  Und jetzt die Nachteile: <br><br><ul><li>  <b>Sie müssen lernen, Code anders zu denken, zu entwerfen und zu schreiben</b> .  Denken Sie in Entitäten, Komponenten und Systemen.  Viele Entwurfsmuster in ECS werden auf völlig andere Weise implementiert (siehe ein Beispiel für die Implementierung des <i>Zustandsmusters</i> in einem der Übersichtsartikel am Ende). </li><li>  <b>Mehr Code</b> .  Umstritten.  Einerseits gibt es aufgrund der Tatsache, dass wir die Logik in kleine Systeme aufteilen, anstatt alle Funktionen in einer Klasse zu beschreiben, mehr Klassen, aber nicht viel mehr Code. </li><li>  <b>Die Reihenfolge der aufrufenden Systeme beeinflusst den Betrieb des gesamten Spiels</b> .  Normalerweise sind die Systeme voneinander abhängig, die Reihenfolge ihrer Ausführung wird durch die Liste festgelegt und sie werden in dieser Reihenfolge ausgeführt.  Beispielsweise berücksichtigt <i>DamageSystem</i> zuerst <i>den</i> Schaden, dann entfernt <i>RemoveDamageSystem</i> die <i>Damage-</i> Komponente.  Wenn Sie versehentlich die Reihenfolge ändern, funktioniert alles anders.  Im Allgemeinen gilt dies auch für den üblichen OOP-Fall, wenn Sie die Reihenfolge der Methodenaufrufe ändern. In ECS ist es jedoch einfacher, einen Fehler zu machen.  Wenn beispielsweise ein Teil der Logik zur Vorhersage auf dem Client ausgeführt wird, sollte die Reihenfolge dieselbe sein wie auf dem Server. </li><li>  <b>Wir müssen die Daten und Ereignisse der Logik irgendwie mit der Ansicht verbinden</b> .  Im Fall von Unity haben wir MVP: <br><br>  - Modell - <i>GameState</i> von ECS; <br>  - <i>Anzeigen</i> - bei uns sind dies ausschließlich Standardklassen für <i>MonoBehavior</i> Unity ( <i>Renderer</i> , <i>Text</i> usw.) und Fertighäuser. <br>  - Presenter verwendet den <i>GameState</i> , um die Ereignisse des Auftretens / Verschwindens von Entitäten, Komponenten usw. zu bestimmen, erstellt Unity-Objekte aus Fertighäusern und ändert sie entsprechend den Änderungen im Zustand der Welt. </li></ul><br>  <i>Wussten Sie, dass:</i> <br><br><ul><li>  <b>Bei ECS geht es nicht nur um Datenlokalität</b> .  Für mich ist dies eher ein Programmierparadigma, ein Muster, eine andere Art, die Spielwelt zu gestalten - nennen Sie es wie Sie wollen.  Die Datenlokalität ist nur eine Optimierung. </li><li>  <b>Einheit hat kein ECS!</b>  Oft fragen Sie Kandidaten bei einem Teaminterview - was wissen Sie über ECS?  Wenn du nichts gehört hast, sagst du es ihnen und sie antworteten: "Ah, so ist es wie in Unity, dann weiß ich es!"  Aber nein, es ist nicht wie in der Unity-Engine.  Dort werden Daten und Logik in der <i>MonoBehaviour-</i> Komponente kombiniert, und <i>GameObject</i> (im Vergleich zu einer Entität in ECS) verfügt über zusätzliche Daten - einen Namen, einen Platz in der Hierarchie usw. Unity-Entwickler arbeiten derzeit an einer normalen Implementierung von ECS in der Engine, und bisher scheint es gut zu sein.  Sie haben Spezialisten auf diesem Gebiet eingestellt - ich hoffe, es wird cool. </li></ul><br><h3>  Unsere Auswahlkriterien für das ECS-Framework </h3><br>  Als wir beschlossen, ein Spiel auf ECS zu entwickeln, suchten wir nach einer vorgefertigten Lösung und schrieben die Anforderungen dafür auf der Grundlage der Erfahrung eines der Entwickler auf.  Und sie haben gemalt, wie vorhandene Lösungen unseren Anforderungen entsprechen.  Es war vor einem Jahr, im Moment hätte sich etwas ändern können.  Als Lösungen haben wir betrachtet: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entitas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artemis C #</a> </li><li>  <a href="">Ash.net</a> </li><li>  ECS ist zu dem Zeitpunkt, als wir es konzipiert haben, unsere eigene Lösung.  Das heißt,  unsere Annahmen und Wünsche, was wir selbst tun können. </li></ul><br>  Wir haben zum Vergleich eine Tabelle zusammengestellt, in der ich auch unsere aktuelle Lösung (als <i>ECS (jetzt) ​​bezeichnet</i> ) aufgenommen habe: <br><br><img src="https://habrastorage.org/webt/0p/eh/hk/0pehhk27fihkyp-qmuhlpu0m5m4.png"><br>  <i>Rote Farbe - die Lösung unterstützt unsere Anforderungen nicht, orange - teilweise unterstützt, grün - vollständig unterstützt.</i> <br><br>  Für uns war die Analogie der Operationen für den Zugriff auf Komponenten und die Suche nach Entitäten in ECS Operationen in einer SQL-Datenbank.  Daher haben wir Konzepte wie Tabelle (Tabelle), Join (Join-Operation), Indizes (Indizes) usw. verwendet. <br><br>  Wir werden unsere Anforderungen beschreiben und inwieweit Bibliotheken und Frameworks von Drittanbietern diesen entsprachen: <br><br><ul><li>  <b>Separate Datensätze (Verlauf, aktuell, visuell, statisch)</b> - Die Möglichkeit, Weltzustände separat abzurufen und zu speichern (z. B. den aktuellen Status für die Verarbeitung, das Rendern, den Statusverlauf usw.).  <i>Alle berücksichtigten Entscheidungen unterstützten diese Anforderung</i> . </li><li>  <b>Entitäts-ID als Ganzzahl</b> - Unterstützung für die Darstellung einer Entität durch ihre Identifikationsnummer.  Es ist notwendig für die Übertragung über das Netzwerk und die Fähigkeit, Entitäten in der Geschichte der Staaten zu verbinden.  <i>Keine der als unterstützt betrachteten Lösungen.</i>  <i>In Entitas wird eine Entität beispielsweise durch ein vollwertiges Objekt dargestellt (wie ein GameObject in Unity).</i> </li><li>  <b>Join durch ID O (N + M)</b> - Unterstützung für eine relativ schnelle Abtastung von zwei Arten von Komponenten.  Zum Beispiel, wenn Sie alle Entitäten mit Komponenten des Schadenstyps (z. B. deren N-Teile) und Gesundheit (M-Teile) zum Berechnen und Verursachen von Schaden erhalten müssen.  <i>Es gab volle Unterstützung in Artemis;</i>  <i>In Entitas und Ash.NET ist es schneller als O (N²), aber langsamer als O (N + M).</i>  <i>Ich kann mich jetzt nicht an die Einschätzung erinnern.</i> </li><li>  <b>Join durch ID-Referenz O (N + M)</b> - das gleiche wie oben, nur wenn eine Komponente einer Entität eine Verknüpfung zu einer anderen hat und diese eine andere Komponente erhalten muss (in unserem Beispiel bezieht sich die <i>Schadenskomponente</i> der Hilfsentität auf die Spielerentität <i>Opfer</i> und von dort müssen Sie die <i>Gesundheitskomponente erhalten</i> ).  <i>Wird von keiner der betrachteten Lösungen unterstützt.</i> </li><li>  <b>Keine Abfragezuweisung</b> - Keine zusätzlichen Speicherzuweisungen beim Abfragen von Komponenten und Entitäten aus dem Zustand der Welt.  In Entitas war es in bestimmten Fällen, aber für uns unbedeutend. </li><li>  <b>Pooltabellen</b> - Speicherung von Weltdaten in Pools, Möglichkeit zur Wiederverwendung von Speicher, Zuordnung nur, wenn der Pool leer ist.  <i>Es gab "einige" Unterstützung in Entitas und Artemis, eine völlige Abwesenheit in Ash.NET.</i> </li><li>  <b>Vergleich nach ID (add, del)</b> - Integrierte Unterstützung für Ereignisse beim Erstellen / Zerstören von Entitäten und Komponenten nach ID.  Die Anzeigeebene (Ansicht) muss Objekte ein- / ausblenden, Animationen und Effekte abspielen.  <i>Wird von keiner der betrachteten Lösungen unterstützt.</i> </li><li>  <b>Δ-Serialisierung (Quantisierung, Überspringen)</b> - integrierte Delta-Komprimierung zur Serialisierung des <b>Weltzustands</b> (z. B. um die Größe der über das Netzwerk gesendeten Daten zu verringern).  <i>Out of the Box wurde in keiner der Lösungen unterstützt.</i> </li><li>  <b>Interpolation</b> ist ein eingebauter Interpolationsmechanismus zwischen Weltstaaten.  <i>Keine der unterstützten Lösungen.</i> </li><li>  <b>Komponententyp wiederverwenden</b> - Die Möglichkeit, einmal geschriebenen Komponententyp in verschiedenen Entitätstypen zu verwenden.  <i>Nur unterstützte Entitas</i> . </li><li>  <b>explizite Reihenfolge der Systeme</b> - die Möglichkeit, eigene Anrufreihenfolgesysteme festzulegen.  <i>Alle Entscheidungen unterstützt.</i> </li><li>  <b>Editor (Einheit / Server)</b> - Unterstützung für das Anzeigen und Bearbeiten von Entitäten in Echtzeit, sowohl für den Client als auch für den Server.  <i>Entitas unterstützte nur die Möglichkeit, Entitäten und Komponenten im Unity-Editor anzuzeigen und zu bearbeiten.</i> </li><li>  <b>schnelles Kopieren / Ersetzen</b> - die Möglichkeit, Daten kostengünstig zu kopieren / ersetzen.  <i>Keine der unterstützten Lösungen.</i> </li><li>  <b>Komponente als Werttyp (Struktur)</b> - Komponenten als Werttypen.  Grundsätzlich wollte ich darauf basierend eine gute Leistung erzielen.  <i>Es wurde kein einziges System unterstützt, Komponentenklassen waren überall.</i> </li></ul><br>  Optionale Anforderungen ( <i>keine der Lösungen unterstützte sie zu diesem Zeitpunkt</i> ): <br><br><ul><li>  <b>Indizes</b> - Indizierung von Daten wie in einer Datenbank. </li><li>  <b>zusammengesetzte Schlüssel</b> - komplexe Schlüssel für den schnellen Zugriff auf Daten (wie in der Datenbank). </li><li>  <b>Integritätsprüfung</b> - die Fähigkeit, die Integrität von Daten in einem Zustand der Welt zu überprüfen.  Nützlich zum Debuggen. </li><li>  <b>Die inhaltsbewusste Komprimierung</b> ist die beste Datenkomprimierung, die auf dem Wissen über die Art der Daten basiert.  Zum Beispiel, wenn wir die maximale Größe der Karte oder die maximale Anzahl von Objekten auf der Welt kennen. </li><li>  <b>Typen- / Systembegrenzung</b> - Beschränkung der Anzahl der Arten von Komponenten oder Systemen.  <i>In Artemis war es zu dieser Zeit unmöglich, mehr als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">32 oder 64 Arten von Komponenten und Systemen</a> zu erstellen</i> . </li></ul><br>  Wie aus der Tabelle hervorgeht, wollten wir alle Anforderungen außer den optionalen selbst implementieren.  In der Tat haben wir im Moment <i>nicht</i> getan: <br><br><ul><li>  <i>Join durch ID O (N + M)</i> und <i>Join durch ID-Referenz O (N + M)</i> - Die Auswahl für zwei verschiedene Komponenten belegt immer noch O (N²) (tatsächlich eine verschachtelte <i>for-</i> Schleife).  Andererseits gibt es nicht so viele Entitäten und Komponenten für eine Übereinstimmung. </li><li>  <i>Vergleich nach ID (add, del)</i> - wird auf Framework-Ebene nicht benötigt.  Wir haben dies auf einer höheren Ebene in MVP implementiert. </li><li>  <i>schnelles Kopieren / Ersetzen</i> und <i>Komponente als Werttyp (Struktur)</i> - irgendwann wurde uns klar, dass das Arbeiten mit Strukturen nicht so bequem ist wie mit Klassen und wir entschieden uns für Klassen - wir bevorzugten Entwicklungskomfort anstelle einer besseren Leistung.  Übrigens haben die Entitas-Entwickler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">am Ende dasselbe getan</a> . </li></ul><br>  Gleichzeitig haben wir dennoch eine der Anforderungen realisiert, die unserer Meinung nach zunächst optional waren: <br><br><ul><li>  <i>inhaltsbewusste Komprimierung</i> - aufgrund dessen konnten wir die Größe des über das Netzwerk übertragenen Pakets erheblich (zehnmal) reduzieren.  Für mobile Datennetze ist es sehr wichtig, die Paketgröße in die MTU einzupassen, damit sie nicht in kleine Teile zerlegt wird, die verloren gehen können, in einer anderen Reihenfolge ablaufen und dann in Teile zusammengesetzt werden müssen.  Wenn in Photon beispielsweise die Datengröße nicht in die MTU-Bibliothek passt, werden die Daten in Pakete aufgeteilt und als zuverlässig (mit garantierter Zustellung) gesendet, selbst wenn Sie sie von oben als "unzuverlässig" senden.  Mit Schmerzen aus erster Hand getestet. </li></ul><br><h3>  Merkmale unserer Entwicklung bei ECS </h3><br><ul><li>  <b>Wir bei ECS schreiben ausschließlich Geschäftslogik</b> .  Keine Arbeit mit Ressourcen, Ansichten usw.  Da der ECS-Logikcode gleichzeitig auf dem Client in Unity und auf dem Server ausgeführt wird, sollte er so unabhängig wie möglich von anderen Ebenen und Modulen sein. </li><li>  <b>Wir versuchen Komponenten und Systeme zu minimieren</b> .  Normalerweise starten wir für jede neue Aufgabe neue Komponenten und Systeme.  Manchmal kommt es jedoch vor, dass wir die alten ändern, den Komponenten neue Daten hinzufügen und die Systeme „aufblasen“. </li><li>  <b>In unserer ECS-Implementierung können Sie einer Entität nicht mehrere Komponenten desselben Typs hinzufügen</b> .  Wenn ein Spieler in einem Tick mehrmals getroffen wurde (z. B. mehrere Gegner), erstellen wir normalerweise für jeden Schaden eine neue Entität und fügen ihr eine <i>Schadenskomponente hinzu</i> . </li><li>  <b>Manchmal reicht die Präsentation nicht aus, um Informationen im <i>GameState zu erhalten</i></b> .  Dann müssen Sie spezielle Komponenten oder zusätzliche Daten hinzufügen, die nicht an der Logik beteiligt sind, die die Ansicht jedoch benötigt.  Zum Beispiel ist die Aufnahme sofort auf dem Server, ein Tick lebt und visuell ist sie auf dem Client länger.  Daher wird für den Client der Schuss zum Parameter "Schusslebensdauer" hinzugefügt. </li><li>  <b>Wir implementieren Ereignisse / Anforderungen, indem wir spezielle Komponenten erstellen</b> .  Wenn beispielsweise ein Spieler gestorben ist, hängen wir ihm eine Komponente ohne <i>tote</i> Daten auf. Dies ist ein Ereignis für andere Systeme und die Ansichtsebene, in der der Spieler gestorben ist.  Oder wenn wir den Spieler auf den Punkt bringen müssen, erstellen wir mit der <i>Respawn-</i> Komponente eine separate Entität mit zusätzlichen Informationen darüber, wen wir wiederbeleben sollen.  Ein separates <i>RespawnSystem</i> zu Beginn des <i>Spielzyklus</i> durchläuft diese Komponenten und schafft bereits die Essenz des Spielers.  Das heißt,  Tatsächlich ist die erste Entität eine Anforderung zum Erstellen der zweiten. </li><li>  <b>Wir haben spezielle "Singleton" -Komponenten / -Entitäten</b> .  Zum Beispiel haben wir eine Entität mit ID = 1, an der spezielle Komponenten hängen - die Spieleinstellungen. </li></ul><br><h3>  Bonus </h3><br>    —       ECS —    .     ,        ,   ,   : <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unity, ECS  --</a> —       ECS   .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mopsicus</a>  ,   ECS,  .        :  Unity  ECS   ,   .    .   «» ECS    Unity.    ECS-,      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LeoECS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BrokenBricksECS</a> , <a href="">Svelto.ECS</a> . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unity3D ECS  Job System</a> —   ,      ECS  Unity.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fstleo</a>   ,   Unity ECS,     ,         -      ,    JobSystem. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  Entity System Framework      ?</a> —    Ash-  ActionScript.  ,   ,        OOP-  ECS-. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    Ash Entity System </a> —   ,    FSM  State  ECS —      ,       . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  Entity-Component-System —    </a> —     ECS  C++. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413729/">https://habr.com/ru/post/de413729/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413717/index.html">GraphQL für InterSystems-Plattformen</a></li>
<li><a href="../de413719/index.html">C ++ 20 unterwegs! Treffen bei Rapperswil Yona</a></li>
<li><a href="../de413721/index.html">Zeitcheck: Timejacking gegen Bitcoin</a></li>
<li><a href="../de413723/index.html">Saga der elektronischen Dienste und ihrer Standorte. Teil 2. Elektronischer Schrank</a></li>
<li><a href="../de413725/index.html">Arbeiten mit Arrays in Bash</a></li>
<li><a href="../de413731/index.html">BA / SA Arbeitsmarktforschung</a></li>
<li><a href="../de413733/index.html">Mikrosh, Krista, Apogee, Lviv - die ersten sowjetischen Computer zum Mitnehmen</a></li>
<li><a href="../de413739/index.html">Wie wir das gesamte Internet gescannt haben und was wir gelernt haben</a></li>
<li><a href="../de413741/index.html">Was es war und wie: Eindrücke des WWDC Redmadrobot-Teams</a></li>
<li><a href="../de413743/index.html">Starten Sie LAMP und Hunderte anderer Webanwendungen mit wenigen Klicks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>