<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèº üë®üèæ‚Äçüè≠ üë¶üèΩ MVCC-4. Datenschnappsch√ºsse üôÜüèº üí∫ üõµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem wir Probleme im Zusammenhang mit der Isolation untersucht und einen Exkurs √ºber das Organisieren von Daten auf niedriger Ebene gemacht hatten ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-4. Datenschnappsch√ºsse</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/446652/">  Nachdem wir Probleme im Zusammenhang mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolation</a> untersucht und einen Exkurs √ºber das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Organisieren von Daten auf niedriger Ebene gemacht hatten</a> , haben wir das letzte Mal ausf√ºhrlich √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeilenversionen gesprochen</a> und nachverfolgt, wie sich die Serviceinformationen im Versionsheader w√§hrend verschiedener Vorg√§nge √§ndern. <br><br>  Heute schauen wir uns an, wie konsistente Versionen von Daten aus Zeilenversionen erhalten werden. <br><br><h1>  Was ist ein Datenschnappschuss? </h1><br>  Physisch k√∂nnen Datenseiten mehrere Versionen derselben Zeile enthalten.  Dar√ºber hinaus sollte jede Transaktion nur eine (oder keine) Version jeder Zeile sehen, damit sie zusammen ein ACID-konsistentes Bild der Daten zu einem bestimmten Zeitpunkt bilden. <br><br>  Die Isolation in PostgreSQL basiert auf Snapshots: Jede Transaktion arbeitet mit einem eigenen Daten-Snapshot, der die Daten enth√§lt, die vor der Erstellung des Snapshots aufgezeichnet wurden, und die zu diesem Zeitpunkt noch nicht festgelegten Daten nicht enth√§lt.  Wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben bereits gesehen,</a> dass die Isolation in diesem Fall strenger ist als es der Standard erfordert, jedoch nicht ohne Anomalien. <br><a name="habracut"></a><br>  Auf der Isolationsstufe von Read Committed wird zu Beginn jeder Transaktionsanweisung ein Snapshot erstellt.  Ein solcher Snapshot ist aktiv, w√§hrend die Anweisung ausgef√ºhrt wird.  In der Abbildung ist der Zeitpunkt der Erstellung des Schnappschusses (der, wie wir uns erinnern, durch die Transaktionsnummer bestimmt wird) blau dargestellt. <br><br><img src="https://habrastorage.org/webt/5g/nz/nj/5gnznjhyp869w4ls01o0wy5kxlo.png"><br><br>  Auf der Ebene "Wiederholbares Lesen" und "Serialisierbar" wird zu Beginn der ersten Transaktionsanweisung einmal ein Snapshot erstellt.  Ein solcher Snapshot bleibt bis zum Ende der Transaktion aktiv. <br><br><img src="https://habrastorage.org/webt/ff/dp/17/ffdp17xhiqemal2dj8k6a21ql38.png"><br><br><h1>  Sichtbarkeit von Zeilenversionen im Snapshot </h1><br><h2>  Sichtbarkeitsregeln </h2><br>  Ein Snapshot ist nat√ºrlich keine physische Kopie aller erforderlichen Zeilenversionen.  Tats√§chlich wird ein Snapshot durch mehrere Zahlen angegeben, und die Sichtbarkeit der Zeilenversionen im Snapshot wird durch die Regeln bestimmt. <br><br>  Ob diese Version der Zeile im Snapshot sichtbar ist oder nicht, h√§ngt von den beiden Feldern des Headers - xmin und xmax - ab, dh von der Anzahl der Transaktionen, die sie erstellt und gel√∂scht haben.  Solche Intervalle schneiden sich nicht, daher wird eine Linie in einem Bild durch maximal eine ihrer Versionen dargestellt. <br><br>  Die genauen Sichtbarkeitsregeln sind recht komplex und ber√ºcksichtigen viele verschiedene Situationen und Extremf√§lle. <br><blockquote>  Dies kann leicht √ºberpr√ºft werden, indem Sie sich src / backend / utils / time / tqual.c ansehen (in Version 12 wurde die Pr√ºfung nach src / backend / access / heap / heapam_visibility.c verschoben). <br></blockquote><br>  Zur Vereinfachung k√∂nnen wir sagen, dass die Version der Zeile sichtbar ist, wenn die durch die xmin-Transaktion vorgenommenen √Ñnderungen im Bild sichtbar sind und die durch die xmax-Transaktion vorgenommenen √Ñnderungen nicht sichtbar sind (mit anderen Worten, es ist bereits sichtbar, dass die Version der Zeile angezeigt wurde, aber es ist noch nicht sichtbar, dass sie gel√∂scht wurde). <br><br>  Transaktions√§nderungen sind wiederum im Snapshot sichtbar, wenn dies entweder dieselbe Transaktion ist, die den Snapshot erstellt hat (sie sieht ihre eigenen √Ñnderungen), oder wenn die Transaktion festgeschrieben wurde, bevor der Snapshot erstellt wurde. <br><br>  Es ist m√∂glich, Transaktionen grafisch in Form von Segmenten darzustellen (vom Start bis zum Zeitpunkt des Festschreibens): <br><br><img src="https://habrastorage.org/webt/w2/cq/yr/w2cqyrzhqwmzzenek8ski3mhbzo.png"><br><br>  Hier: <br><br><ul><li>  √Ñnderungen an Transaktion 2 werden angezeigt, da sie abgeschlossen wurden, bevor der Snapshot erstellt wurde. </li><li>  √Ñnderungen an Transaktion 1 sind nicht sichtbar, da sie zum Zeitpunkt der Erstellung des Snapshots aktiv waren. </li><li>  √Ñnderungen an Transaktion 3 sind nicht sichtbar, da sie nach der Erstellung des Snapshots gestartet wurden (es spielt keine Rolle, ob er beendet wurde oder nicht). </li></ul><br>  Leider ist der Zeitpunkt des Festschreibens von Transaktionen dem System unbekannt.  Es ist nur der Zeitpunkt seines Beginns bekannt (er wird durch die Transaktionsnummer bestimmt und in den obigen Abbildungen durch eine gestrichelte Linie angezeigt), aber die Tatsache der Fertigstellung wird nirgendwo aufgezeichnet. <br><br>  Wir k√∂nnen lediglich den <em>aktuellen</em> Status von Transaktionen ermitteln, wenn wir einen Snapshot erstellen.  Diese Informationen befinden sich im gemeinsam genutzten Speicher des Servers in der ProcArray-Struktur, die eine Liste aller aktiven Sitzungen und ihrer Transaktionen enth√§lt. <br><br>  Und im Nachhinein k√∂nnen wir nicht mehr verstehen, ob zum Zeitpunkt der Erstellung des Snapshots eine Transaktion aktiv war oder nicht.  Daher muss die Liste aller derzeit aktiven Transaktionen im Bild gespeichert werden. <br><br>  Daraus folgt, dass Sie in PostgreSQL keinen Snapshot erstellen k√∂nnen, der konsistente Daten zu einem beliebigen Zeitpunkt zeigt, <em>selbst wenn</em> alle daf√ºr erforderlichen Versionen der Zeilen auf den Tabellenseiten vorhanden sind.  Man h√∂rt oft die Frage, warum es in PostgreSQL keine retrospektiven (oder zeitlichen; in Oracle wird dies als Flashback-Abfrage bezeichnet) Abfragen gibt - dies ist einer der Gr√ºnde. <br><blockquote>  Es ist lustig, dass es anfangs solche Funktionen gab, aber sp√§ter wurde sie aus dem DBMS entfernt.  Sie k√∂nnen dar√ºber in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel von Joseph Hellerstein</a> lesen. <br></blockquote>  Ein Datenschnappschuss wird also durch mehrere Parameter bestimmt: <br><br><ul><li>  der Zeitpunkt der Erstellung des Snapshots, n√§mlich die Nummer der n√§chsten Transaktion, die nicht im System vorhanden ist ( <strong>snapshot.xmax</strong> ); </li><li>  Eine Liste der aktiven Transaktionen zum Zeitpunkt der Erstellung des Snapshots ( <strong>snapshot.xip</strong> ). </li></ul><br>  Zur Vereinfachung und Optimierung wird die Nummer der fr√ºhesten aktiven Transaktion ( <strong>snapshot.xmin</strong> ) ebenfalls separat gespeichert.  Dieser Wert hat eine wichtige Bedeutung, die wir unten diskutieren werden. <br><br>  Au√üerdem werden einige weitere Parameter im Bild gespeichert, die f√ºr uns jedoch nicht wichtig sind. <br><br><img src="https://habrastorage.org/webt/-r/8v/aa/-r8vaa6fvrltfpd4tjjnv_zxnk4.png"><br><br><h2>  Beispiel </h2><br>  Um zu sehen, wie die Sichtbarkeit durch den Schnappschuss bestimmt wird, reproduzieren wir die Situation mit den drei oben diskutierten Transaktionen.  Die Tabelle besteht aus drei Zeilen mit: <br><br><ul><li>  Die erste wurde durch eine Transaktion hinzugef√ºgt, die vor der Erstellung des Snapshots gestartet und sp√§ter beendet wurde. </li><li>  Die zweite wird durch eine Transaktion hinzugef√ºgt, die vor dem Erstellen des Snapshots gestartet und beendet wurde. </li><li>  Der dritte wurde nach der Aufnahme hinzugef√ºgt. </li></ul><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts;</code> </pre> <br>  Erste Transaktion (noch nicht abgeschlossen): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">=&gt; SELECT txid_current(); txid_current -------------- 3695 (1 row)</code> </pre><br>  Die zweite Transaktion (abgeschlossen, bevor der Snapshot erstellt wurde): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3696 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Erstellen Sie einen Snapshot in einer Transaktion in einer anderen Sitzung. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Wir schlie√üen die erste Transaktion ab, nachdem der Snapshot erstellt wurde: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Und die dritte Transaktion (erschien sp√§ter im Schnappschuss): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3697 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Offensichtlich ist in unserem Bild noch eine Linie sichtbar: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Die Frage ist, wie PostgreSQL dies versteht. <br><br>  Alles wird vom Bild bestimmt.  Schauen wir es uns an: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_snapshot();</code> </pre><pre> <code class="plaintext hljs">|| txid_current_snapshot || ----------------------- || 3695:3697:3695 || (1 row)</code> </pre><br>  Hier listet der Doppelpunkt snapshot.xmin, snapshot.xmax und snapshot.xip auf (in diesem Fall eine Nummer, aber im Allgemeinen eine Liste). <br><br>  Gem√§√ü den oben angegebenen Regeln sollte das Bild die √Ñnderungen zeigen, die durch Transaktionen mit den Nummern snapshot.xmin &lt;= xid &lt;snapshot.xmax mit Ausnahme von snapshot.xip vorgenommen wurden.  Schauen wir uns alle Zeilen der Tabelle an (in einem neuen Bild): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | number | client | amount ------+------+----+--------+--------+--------- 3695 | 0 | 1 | 1001 | alice | 1000.00 3696 | 0 | 2 | 2001 | bob | 100.00 3697 | 0 | 3 | 2002 | bob | 900.00 (3 rows)</code> </pre><br>  Die erste Zeile ist nicht sichtbar - sie wurde von einer Transaktion erstellt, die in der Liste der aktiven (xip) enthalten ist. <br>  Die zweite Zeile ist sichtbar - sie wird durch eine Transaktion erstellt, die in den Bereich des Bildes f√§llt. <br>  Die dritte Zeile ist nicht sichtbar - sie wurde von einer Transaktion erstellt, die nicht im Bereich des Snapshots liegt. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Eigene √Ñnderungen </h1><br>  Etwas komplizierter ist das Bild, wenn Sie die Sichtbarkeit Ihrer eigenen Transaktions√§nderungen bestimmen.  Hier m√ºssen Sie m√∂glicherweise nur einen Teil dieser √Ñnderungen sehen.  Beispielsweise sollte ein Cursor, der zu einem bestimmten Zeitpunkt ge√∂ffnet ist, keine √Ñnderungen sehen, die nach diesem Moment in einer Isolationsstufe vorgenommen wurden. <br><br>  Zu diesem Zweck befindet sich im Header der Zeilenversion ein spezielles Feld (das in den Pseudospalten cmin und cmax angezeigt wird), in dem die Sequenznummer der Operation innerhalb der Transaktion angezeigt wird.  Cmin steht f√ºr die einzuf√ºgende Zahl, cmax f√ºr die zu l√∂schende Zahl. Um jedoch Platz in der Zeilen√ºberschrift zu sparen, ist dies tats√§chlich ein Feld, nicht zwei verschiedene.  Es wird angenommen, dass das Einf√ºgen und L√∂schen derselben Zeile in einer einzelnen Transaktion selten ist. <br><br>  Wenn dies immer noch passiert, wird eine spezielle "Combo" -Nummer in dasselbe Feld eingef√ºgt, √ºber die sich der Serviceprozess die tats√§chlichen cmin und cmax merkt.  Das ist aber v√∂llig exotisch. <br><br>  Ein einfaches Beispiel.  Wir starten die Transaktion und f√ºgen die Zeile zur Tabelle hinzu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3698 (1 row)</code> </pre><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3001</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>);</code> </pre><br>  Wir werden den Inhalt der Tabelle zusammen mit dem Feld cmin anzeigen (aber nur f√ºr die Zeilen, die durch unsere Transaktion hinzugef√ºgt wurden - f√ºr andere ist dies nicht sinnvoll): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  √ñffnen Sie nun den Cursor f√ºr die Abfrage, die die Anzahl der Zeilen in der Tabelle zur√ºckgibt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br>  Und danach noch eine Zeile hinzuf√ºgen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3002</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>);</code> </pre><br>  Die Anforderung gibt 4 zur√ºck - die nach dem √ñffnen des Cursors hinzugef√ºgte Zeile f√§llt nicht in den Datenschnappschuss: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> count ------- 4 (1 row)</code> </pre><br>  Warum?  Denn im Snapshot werden nur Zeilenversionen mit cmin &lt;1 ber√ºcksichtigt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 3698 | 1 | 5 | 3002 | charlie | 200.00 (5 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Ereignishorizont </h1><br>  Die Nummer der fr√ºhesten aktiven Transaktion (snapshot.xmin) hat eine wichtige Bedeutung - sie definiert den "Ereignishorizont" der Transaktion.  √úber den Horizont hinaus sieht eine Transaktion n√§mlich immer nur aktuelle Versionen von Zeilen. <br><br>  In der Tat muss eine irrelevante Version nur angezeigt werden, wenn die aktuelle Version durch eine Transaktion erstellt wurde, die noch nicht abgeschlossen wurde und daher noch nicht sichtbar ist.  √úber den "Horizont" hinaus ist jedoch bereits garantiert, dass alle Transaktionen abgeschlossen sind. <br><br><img src="https://habrastorage.org/webt/8z/vp/oo/8zvpoocv891hhtnv9lcs6j7g4ry.png"><br><br>  Der "Ereignishorizont" der Transaktion wird im Systemverzeichnis angezeigt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Sie k√∂nnen auch einen ‚ÄûEreignishorizont‚Äú auf Datenbankebene definieren.  Machen Sie dazu alle aktiven Schnappsch√ºsse und finden Sie unter ihnen die √§ltesten xmin.  Es bestimmt den Horizont, ab dem irrelevante Versionen von Zeilen in dieser Datenbank f√ºr Transaktionen niemals sichtbar sind.  <em>Solche Versionen von Strings k√∂nnen gel√∂scht werden</em> - weshalb das Konzept des Horizonts aus praktischer Sicht so wichtig ist. <br><br>  Wenn eine Transaktion l√§ngere Zeit einen Snapshot enth√§lt, enth√§lt sie auch den Datenbankereignishorizont.  Dar√ºber hinaus wird eine unvollendete Transaktion aufgrund ihrer Existenz den Horizont bestimmen, selbst wenn kein Schnappschuss darin enthalten ist. <br><br>  Dies bedeutet, dass irrelevante Versionen von Zeilen in dieser Datenbank nicht gel√∂scht werden k√∂nnen.  Gleichzeitig darf sich eine ‚Äûlangwierige‚Äú Transaktion nicht mit anderen Transaktionen in den Daten √ºberschneiden - dies ist absolut nicht wichtig, der Datenbankhorizont ist f√ºr alle gleich. <br><br>  Wenn jetzt nicht eine Transaktion, sondern Snapshots (von snapshot.xmin bis snapshot.xmax) als Segment dargestellt werden, kann die Situation wie folgt vorgestellt werden: <br><br><img src="https://habrastorage.org/webt/nd/ve/wi/ndvewikoeiljposax85zp7mmmn8.png"><br><br>  In dieser Abbildung bezieht sich der unterste Snapshot auf eine unvollst√§ndige Transaktion, und in den verbleibenden Snapshot.xmin-Snapshots darf die Anzahl nicht gr√∂√üer sein. <br><br>  In unserem Beispiel wurde eine Transaktion mit der Isolationsstufe Read Committed gestartet.  Obwohl es keinen aktiven Datenschnappschuss enth√§lt, bleibt der Horizont erhalten: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">1.00</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Und erst nach Abschluss der Transaktion bewegt sich der Horizont vorw√§rts, sodass Sie irrelevante Versionen der Zeilen l√∂schen k√∂nnen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3700 (1 row)</code> </pre><br>  Wenn die beschriebene Situation wirklich Probleme verursacht und es auf Anwendungsebene keine M√∂glichkeit gibt, sie zu vermeiden, stehen ab Version 9.6 zwei Optionen zur Verf√ºgung: <br><br><ul><li>  <em>old_snapshot_threshold</em> definiert die maximale Lebensdauer eines Snapshots.  Nach dieser Zeit hat der Server das Recht, irrelevante Versionen der Zeilen zu l√∂schen. Wenn eine "langwierige" Transaktion erforderlich ist, wird jedoch ein zu alter Snapshot-Fehler angezeigt. </li><li>  <em>idle_in_transaction_session_timeout</em> definiert die maximale Lebensdauer einer inaktiven Transaktion.  Nach dieser Zeit wird die Transaktion abgebrochen. </li></ul><br><h1>  Datenschnappschuss exportieren </h1><br>  Es gibt Situationen, in denen garantiert werden muss, dass mehrere Transaktionen gleichzeitig dasselbe Datenbild sehen.  Als Beispiel k√∂nnen wir das Dienstprogramm pg_dump verwenden, das im parallelen Modus arbeiten kann: Alle Arbeitsprozesse m√ºssen die Datenbank im selben Status sehen, damit die Sicherungskopie konsistent ist. <br><br>  Nat√ºrlich k√∂nnen Sie sich nicht darauf verlassen, dass die Datenmuster einfach deshalb zusammenfallen, weil die Transaktionen ‚Äûgleichzeitig‚Äú gestartet werden.  Hierf√ºr gibt es einen Mechanismus zum Exportieren und Importieren eines Snapshots. <br><br>  Die Funktion pg_export_snapshot gibt die Kennung eines Snapshots zur√ºck, der (auf externe Weise an das DBMS) an eine andere Transaktion √ºbertragen werden kann. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">--  </span></span></code> </pre><pre> <code class="plaintext hljs"> count ------- 3 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_export_snapshot();</code> </pre><pre> <code class="plaintext hljs"> pg_export_snapshot --------------------- 00000004-00000E7B-1 (1 row)</code> </pre><br>  Eine andere Transaktion kann den Snapshot mit dem Befehl SET TRANSACTION SNAPSHOT importieren, bevor die erste Anforderung darin ausgef√ºhrt wird.  Sie m√ºssen zuerst die Isolationsstufe als wiederholbares Lesen oder serialisierbar festlegen, da die Bediener auf der Ebene "Festgeschriebenes Lesen" ihre eigenen Snapshots verwenden. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span> <span class="hljs-string"><span class="hljs-string">'00000004-00000E7B-1'</span></span>;</code> </pre><br>  Jetzt funktioniert die zweite Transaktion mit einem Schnappschuss der ersten und sieht dementsprechend drei Zeilen (und nicht Null): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><br>  Die Lebensdauer des exportierten Snapshots entspricht der Lebensdauer der exportierenden Transaktion. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446652/">https://habr.com/ru/post/de446652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446642/index.html">Checkliste zum Erstellen und Ver√∂ffentlichen von Webanwendungen</a></li>
<li><a href="../de446644/index.html">So f√ºhren Sie SMM 2019 aus: 17 Diagramme von Neil Patel</a></li>
<li><a href="../de446646/index.html">InterSystems IRIS 2019.1 Release</a></li>
<li><a href="../de446648/index.html">Kubernetes Operator-Entwicklung mit Operator Framework</a></li>
<li><a href="../de446650/index.html">Wie viel kosten Tester und wovon h√§ngen ihre Geh√§lter ab? Erstellen eines Portr√§ts eines erfolgreichen QS-Spezialisten</a></li>
<li><a href="../de446654/index.html">Wie wir die Code√ºberpr√ºfung gespeichert haben</a></li>
<li><a href="../de446656/index.html">1600bit / s Sprachcodierung mit dem neuronalen Vocoder LPCNet</a></li>
<li><a href="../de446658/index.html">Interview mit Andrei Stankevich √ºber Sportprogrammierung</a></li>
<li><a href="../de446660/index.html">KI, Sch√ºler und gro√üer Preis: Wie man maschinelles Lernen in der 8. Klasse macht</a></li>
<li><a href="../de446662/index.html">Transaktionen und Mechanismen zu ihrer Kontrolle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>