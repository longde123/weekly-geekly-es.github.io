<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏼 👨🏾‍🏭 👦🏽 MVCC-4. Datenschnappschüsse 🙆🏼 💺 🛵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem wir Probleme im Zusammenhang mit der Isolation untersucht und einen Exkurs über das Organisieren von Daten auf niedriger Ebene gemacht hatten ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-4. Datenschnappschüsse</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/446652/">  Nachdem wir Probleme im Zusammenhang mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolation</a> untersucht und einen Exkurs über das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Organisieren von Daten auf niedriger Ebene gemacht hatten</a> , haben wir das letzte Mal ausführlich über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeilenversionen gesprochen</a> und nachverfolgt, wie sich die Serviceinformationen im Versionsheader während verschiedener Vorgänge ändern. <br><br>  Heute schauen wir uns an, wie konsistente Versionen von Daten aus Zeilenversionen erhalten werden. <br><br><h1>  Was ist ein Datenschnappschuss? </h1><br>  Physisch können Datenseiten mehrere Versionen derselben Zeile enthalten.  Darüber hinaus sollte jede Transaktion nur eine (oder keine) Version jeder Zeile sehen, damit sie zusammen ein ACID-konsistentes Bild der Daten zu einem bestimmten Zeitpunkt bilden. <br><br>  Die Isolation in PostgreSQL basiert auf Snapshots: Jede Transaktion arbeitet mit einem eigenen Daten-Snapshot, der die Daten enthält, die vor der Erstellung des Snapshots aufgezeichnet wurden, und die zu diesem Zeitpunkt noch nicht festgelegten Daten nicht enthält.  Wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben bereits gesehen,</a> dass die Isolation in diesem Fall strenger ist als es der Standard erfordert, jedoch nicht ohne Anomalien. <br><a name="habracut"></a><br>  Auf der Isolationsstufe von Read Committed wird zu Beginn jeder Transaktionsanweisung ein Snapshot erstellt.  Ein solcher Snapshot ist aktiv, während die Anweisung ausgeführt wird.  In der Abbildung ist der Zeitpunkt der Erstellung des Schnappschusses (der, wie wir uns erinnern, durch die Transaktionsnummer bestimmt wird) blau dargestellt. <br><br><img src="https://habrastorage.org/webt/5g/nz/nj/5gnznjhyp869w4ls01o0wy5kxlo.png"><br><br>  Auf der Ebene "Wiederholbares Lesen" und "Serialisierbar" wird zu Beginn der ersten Transaktionsanweisung einmal ein Snapshot erstellt.  Ein solcher Snapshot bleibt bis zum Ende der Transaktion aktiv. <br><br><img src="https://habrastorage.org/webt/ff/dp/17/ffdp17xhiqemal2dj8k6a21ql38.png"><br><br><h1>  Sichtbarkeit von Zeilenversionen im Snapshot </h1><br><h2>  Sichtbarkeitsregeln </h2><br>  Ein Snapshot ist natürlich keine physische Kopie aller erforderlichen Zeilenversionen.  Tatsächlich wird ein Snapshot durch mehrere Zahlen angegeben, und die Sichtbarkeit der Zeilenversionen im Snapshot wird durch die Regeln bestimmt. <br><br>  Ob diese Version der Zeile im Snapshot sichtbar ist oder nicht, hängt von den beiden Feldern des Headers - xmin und xmax - ab, dh von der Anzahl der Transaktionen, die sie erstellt und gelöscht haben.  Solche Intervalle schneiden sich nicht, daher wird eine Linie in einem Bild durch maximal eine ihrer Versionen dargestellt. <br><br>  Die genauen Sichtbarkeitsregeln sind recht komplex und berücksichtigen viele verschiedene Situationen und Extremfälle. <br><blockquote>  Dies kann leicht überprüft werden, indem Sie sich src / backend / utils / time / tqual.c ansehen (in Version 12 wurde die Prüfung nach src / backend / access / heap / heapam_visibility.c verschoben). <br></blockquote><br>  Zur Vereinfachung können wir sagen, dass die Version der Zeile sichtbar ist, wenn die durch die xmin-Transaktion vorgenommenen Änderungen im Bild sichtbar sind und die durch die xmax-Transaktion vorgenommenen Änderungen nicht sichtbar sind (mit anderen Worten, es ist bereits sichtbar, dass die Version der Zeile angezeigt wurde, aber es ist noch nicht sichtbar, dass sie gelöscht wurde). <br><br>  Transaktionsänderungen sind wiederum im Snapshot sichtbar, wenn dies entweder dieselbe Transaktion ist, die den Snapshot erstellt hat (sie sieht ihre eigenen Änderungen), oder wenn die Transaktion festgeschrieben wurde, bevor der Snapshot erstellt wurde. <br><br>  Es ist möglich, Transaktionen grafisch in Form von Segmenten darzustellen (vom Start bis zum Zeitpunkt des Festschreibens): <br><br><img src="https://habrastorage.org/webt/w2/cq/yr/w2cqyrzhqwmzzenek8ski3mhbzo.png"><br><br>  Hier: <br><br><ul><li>  Änderungen an Transaktion 2 werden angezeigt, da sie abgeschlossen wurden, bevor der Snapshot erstellt wurde. </li><li>  Änderungen an Transaktion 1 sind nicht sichtbar, da sie zum Zeitpunkt der Erstellung des Snapshots aktiv waren. </li><li>  Änderungen an Transaktion 3 sind nicht sichtbar, da sie nach der Erstellung des Snapshots gestartet wurden (es spielt keine Rolle, ob er beendet wurde oder nicht). </li></ul><br>  Leider ist der Zeitpunkt des Festschreibens von Transaktionen dem System unbekannt.  Es ist nur der Zeitpunkt seines Beginns bekannt (er wird durch die Transaktionsnummer bestimmt und in den obigen Abbildungen durch eine gestrichelte Linie angezeigt), aber die Tatsache der Fertigstellung wird nirgendwo aufgezeichnet. <br><br>  Wir können lediglich den <em>aktuellen</em> Status von Transaktionen ermitteln, wenn wir einen Snapshot erstellen.  Diese Informationen befinden sich im gemeinsam genutzten Speicher des Servers in der ProcArray-Struktur, die eine Liste aller aktiven Sitzungen und ihrer Transaktionen enthält. <br><br>  Und im Nachhinein können wir nicht mehr verstehen, ob zum Zeitpunkt der Erstellung des Snapshots eine Transaktion aktiv war oder nicht.  Daher muss die Liste aller derzeit aktiven Transaktionen im Bild gespeichert werden. <br><br>  Daraus folgt, dass Sie in PostgreSQL keinen Snapshot erstellen können, der konsistente Daten zu einem beliebigen Zeitpunkt zeigt, <em>selbst wenn</em> alle dafür erforderlichen Versionen der Zeilen auf den Tabellenseiten vorhanden sind.  Man hört oft die Frage, warum es in PostgreSQL keine retrospektiven (oder zeitlichen; in Oracle wird dies als Flashback-Abfrage bezeichnet) Abfragen gibt - dies ist einer der Gründe. <br><blockquote>  Es ist lustig, dass es anfangs solche Funktionen gab, aber später wurde sie aus dem DBMS entfernt.  Sie können darüber in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel von Joseph Hellerstein</a> lesen. <br></blockquote>  Ein Datenschnappschuss wird also durch mehrere Parameter bestimmt: <br><br><ul><li>  der Zeitpunkt der Erstellung des Snapshots, nämlich die Nummer der nächsten Transaktion, die nicht im System vorhanden ist ( <strong>snapshot.xmax</strong> ); </li><li>  Eine Liste der aktiven Transaktionen zum Zeitpunkt der Erstellung des Snapshots ( <strong>snapshot.xip</strong> ). </li></ul><br>  Zur Vereinfachung und Optimierung wird die Nummer der frühesten aktiven Transaktion ( <strong>snapshot.xmin</strong> ) ebenfalls separat gespeichert.  Dieser Wert hat eine wichtige Bedeutung, die wir unten diskutieren werden. <br><br>  Außerdem werden einige weitere Parameter im Bild gespeichert, die für uns jedoch nicht wichtig sind. <br><br><img src="https://habrastorage.org/webt/-r/8v/aa/-r8vaa6fvrltfpd4tjjnv_zxnk4.png"><br><br><h2>  Beispiel </h2><br>  Um zu sehen, wie die Sichtbarkeit durch den Schnappschuss bestimmt wird, reproduzieren wir die Situation mit den drei oben diskutierten Transaktionen.  Die Tabelle besteht aus drei Zeilen mit: <br><br><ul><li>  Die erste wurde durch eine Transaktion hinzugefügt, die vor der Erstellung des Snapshots gestartet und später beendet wurde. </li><li>  Die zweite wird durch eine Transaktion hinzugefügt, die vor dem Erstellen des Snapshots gestartet und beendet wurde. </li><li>  Der dritte wurde nach der Aufnahme hinzugefügt. </li></ul><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts;</code> </pre> <br>  Erste Transaktion (noch nicht abgeschlossen): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">=&gt; SELECT txid_current(); txid_current -------------- 3695 (1 row)</code> </pre><br>  Die zweite Transaktion (abgeschlossen, bevor der Snapshot erstellt wurde): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3696 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Erstellen Sie einen Snapshot in einer Transaktion in einer anderen Sitzung. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Wir schließen die erste Transaktion ab, nachdem der Snapshot erstellt wurde: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Und die dritte Transaktion (erschien später im Schnappschuss): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3697 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Offensichtlich ist in unserem Bild noch eine Linie sichtbar: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Die Frage ist, wie PostgreSQL dies versteht. <br><br>  Alles wird vom Bild bestimmt.  Schauen wir es uns an: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_snapshot();</code> </pre><pre> <code class="plaintext hljs">|| txid_current_snapshot || ----------------------- || 3695:3697:3695 || (1 row)</code> </pre><br>  Hier listet der Doppelpunkt snapshot.xmin, snapshot.xmax und snapshot.xip auf (in diesem Fall eine Nummer, aber im Allgemeinen eine Liste). <br><br>  Gemäß den oben angegebenen Regeln sollte das Bild die Änderungen zeigen, die durch Transaktionen mit den Nummern snapshot.xmin &lt;= xid &lt;snapshot.xmax mit Ausnahme von snapshot.xip vorgenommen wurden.  Schauen wir uns alle Zeilen der Tabelle an (in einem neuen Bild): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | number | client | amount ------+------+----+--------+--------+--------- 3695 | 0 | 1 | 1001 | alice | 1000.00 3696 | 0 | 2 | 2001 | bob | 100.00 3697 | 0 | 3 | 2002 | bob | 900.00 (3 rows)</code> </pre><br>  Die erste Zeile ist nicht sichtbar - sie wurde von einer Transaktion erstellt, die in der Liste der aktiven (xip) enthalten ist. <br>  Die zweite Zeile ist sichtbar - sie wird durch eine Transaktion erstellt, die in den Bereich des Bildes fällt. <br>  Die dritte Zeile ist nicht sichtbar - sie wurde von einer Transaktion erstellt, die nicht im Bereich des Snapshots liegt. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Eigene Änderungen </h1><br>  Etwas komplizierter ist das Bild, wenn Sie die Sichtbarkeit Ihrer eigenen Transaktionsänderungen bestimmen.  Hier müssen Sie möglicherweise nur einen Teil dieser Änderungen sehen.  Beispielsweise sollte ein Cursor, der zu einem bestimmten Zeitpunkt geöffnet ist, keine Änderungen sehen, die nach diesem Moment in einer Isolationsstufe vorgenommen wurden. <br><br>  Zu diesem Zweck befindet sich im Header der Zeilenversion ein spezielles Feld (das in den Pseudospalten cmin und cmax angezeigt wird), in dem die Sequenznummer der Operation innerhalb der Transaktion angezeigt wird.  Cmin steht für die einzufügende Zahl, cmax für die zu löschende Zahl. Um jedoch Platz in der Zeilenüberschrift zu sparen, ist dies tatsächlich ein Feld, nicht zwei verschiedene.  Es wird angenommen, dass das Einfügen und Löschen derselben Zeile in einer einzelnen Transaktion selten ist. <br><br>  Wenn dies immer noch passiert, wird eine spezielle "Combo" -Nummer in dasselbe Feld eingefügt, über die sich der Serviceprozess die tatsächlichen cmin und cmax merkt.  Das ist aber völlig exotisch. <br><br>  Ein einfaches Beispiel.  Wir starten die Transaktion und fügen die Zeile zur Tabelle hinzu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3698 (1 row)</code> </pre><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3001</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>);</code> </pre><br>  Wir werden den Inhalt der Tabelle zusammen mit dem Feld cmin anzeigen (aber nur für die Zeilen, die durch unsere Transaktion hinzugefügt wurden - für andere ist dies nicht sinnvoll): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Öffnen Sie nun den Cursor für die Abfrage, die die Anzahl der Zeilen in der Tabelle zurückgibt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br>  Und danach noch eine Zeile hinzufügen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3002</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>);</code> </pre><br>  Die Anforderung gibt 4 zurück - die nach dem Öffnen des Cursors hinzugefügte Zeile fällt nicht in den Datenschnappschuss: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> count ------- 4 (1 row)</code> </pre><br>  Warum?  Denn im Snapshot werden nur Zeilenversionen mit cmin &lt;1 berücksichtigt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 3698 | 1 | 5 | 3002 | charlie | 200.00 (5 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Ereignishorizont </h1><br>  Die Nummer der frühesten aktiven Transaktion (snapshot.xmin) hat eine wichtige Bedeutung - sie definiert den "Ereignishorizont" der Transaktion.  Über den Horizont hinaus sieht eine Transaktion nämlich immer nur aktuelle Versionen von Zeilen. <br><br>  In der Tat muss eine irrelevante Version nur angezeigt werden, wenn die aktuelle Version durch eine Transaktion erstellt wurde, die noch nicht abgeschlossen wurde und daher noch nicht sichtbar ist.  Über den "Horizont" hinaus ist jedoch bereits garantiert, dass alle Transaktionen abgeschlossen sind. <br><br><img src="https://habrastorage.org/webt/8z/vp/oo/8zvpoocv891hhtnv9lcs6j7g4ry.png"><br><br>  Der "Ereignishorizont" der Transaktion wird im Systemverzeichnis angezeigt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Sie können auch einen „Ereignishorizont“ auf Datenbankebene definieren.  Machen Sie dazu alle aktiven Schnappschüsse und finden Sie unter ihnen die ältesten xmin.  Es bestimmt den Horizont, ab dem irrelevante Versionen von Zeilen in dieser Datenbank für Transaktionen niemals sichtbar sind.  <em>Solche Versionen von Strings können gelöscht werden</em> - weshalb das Konzept des Horizonts aus praktischer Sicht so wichtig ist. <br><br>  Wenn eine Transaktion längere Zeit einen Snapshot enthält, enthält sie auch den Datenbankereignishorizont.  Darüber hinaus wird eine unvollendete Transaktion aufgrund ihrer Existenz den Horizont bestimmen, selbst wenn kein Schnappschuss darin enthalten ist. <br><br>  Dies bedeutet, dass irrelevante Versionen von Zeilen in dieser Datenbank nicht gelöscht werden können.  Gleichzeitig darf sich eine „langwierige“ Transaktion nicht mit anderen Transaktionen in den Daten überschneiden - dies ist absolut nicht wichtig, der Datenbankhorizont ist für alle gleich. <br><br>  Wenn jetzt nicht eine Transaktion, sondern Snapshots (von snapshot.xmin bis snapshot.xmax) als Segment dargestellt werden, kann die Situation wie folgt vorgestellt werden: <br><br><img src="https://habrastorage.org/webt/nd/ve/wi/ndvewikoeiljposax85zp7mmmn8.png"><br><br>  In dieser Abbildung bezieht sich der unterste Snapshot auf eine unvollständige Transaktion, und in den verbleibenden Snapshot.xmin-Snapshots darf die Anzahl nicht größer sein. <br><br>  In unserem Beispiel wurde eine Transaktion mit der Isolationsstufe Read Committed gestartet.  Obwohl es keinen aktiven Datenschnappschuss enthält, bleibt der Horizont erhalten: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">1.00</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Und erst nach Abschluss der Transaktion bewegt sich der Horizont vorwärts, sodass Sie irrelevante Versionen der Zeilen löschen können: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3700 (1 row)</code> </pre><br>  Wenn die beschriebene Situation wirklich Probleme verursacht und es auf Anwendungsebene keine Möglichkeit gibt, sie zu vermeiden, stehen ab Version 9.6 zwei Optionen zur Verfügung: <br><br><ul><li>  <em>old_snapshot_threshold</em> definiert die maximale Lebensdauer eines Snapshots.  Nach dieser Zeit hat der Server das Recht, irrelevante Versionen der Zeilen zu löschen. Wenn eine "langwierige" Transaktion erforderlich ist, wird jedoch ein zu alter Snapshot-Fehler angezeigt. </li><li>  <em>idle_in_transaction_session_timeout</em> definiert die maximale Lebensdauer einer inaktiven Transaktion.  Nach dieser Zeit wird die Transaktion abgebrochen. </li></ul><br><h1>  Datenschnappschuss exportieren </h1><br>  Es gibt Situationen, in denen garantiert werden muss, dass mehrere Transaktionen gleichzeitig dasselbe Datenbild sehen.  Als Beispiel können wir das Dienstprogramm pg_dump verwenden, das im parallelen Modus arbeiten kann: Alle Arbeitsprozesse müssen die Datenbank im selben Status sehen, damit die Sicherungskopie konsistent ist. <br><br>  Natürlich können Sie sich nicht darauf verlassen, dass die Datenmuster einfach deshalb zusammenfallen, weil die Transaktionen „gleichzeitig“ gestartet werden.  Hierfür gibt es einen Mechanismus zum Exportieren und Importieren eines Snapshots. <br><br>  Die Funktion pg_export_snapshot gibt die Kennung eines Snapshots zurück, der (auf externe Weise an das DBMS) an eine andere Transaktion übertragen werden kann. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">--  </span></span></code> </pre><pre> <code class="plaintext hljs"> count ------- 3 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_export_snapshot();</code> </pre><pre> <code class="plaintext hljs"> pg_export_snapshot --------------------- 00000004-00000E7B-1 (1 row)</code> </pre><br>  Eine andere Transaktion kann den Snapshot mit dem Befehl SET TRANSACTION SNAPSHOT importieren, bevor die erste Anforderung darin ausgeführt wird.  Sie müssen zuerst die Isolationsstufe als wiederholbares Lesen oder serialisierbar festlegen, da die Bediener auf der Ebene "Festgeschriebenes Lesen" ihre eigenen Snapshots verwenden. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span> <span class="hljs-string"><span class="hljs-string">'00000004-00000E7B-1'</span></span>;</code> </pre><br>  Jetzt funktioniert die zweite Transaktion mit einem Schnappschuss der ersten und sieht dementsprechend drei Zeilen (und nicht Null): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><br>  Die Lebensdauer des exportierten Snapshots entspricht der Lebensdauer der exportierenden Transaktion. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446652/">https://habr.com/ru/post/de446652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446642/index.html">Checkliste zum Erstellen und Veröffentlichen von Webanwendungen</a></li>
<li><a href="../de446644/index.html">So führen Sie SMM 2019 aus: 17 Diagramme von Neil Patel</a></li>
<li><a href="../de446646/index.html">InterSystems IRIS 2019.1 Release</a></li>
<li><a href="../de446648/index.html">Kubernetes Operator-Entwicklung mit Operator Framework</a></li>
<li><a href="../de446650/index.html">Wie viel kosten Tester und wovon hängen ihre Gehälter ab? Erstellen eines Porträts eines erfolgreichen QS-Spezialisten</a></li>
<li><a href="../de446654/index.html">Wie wir die Codeüberprüfung gespeichert haben</a></li>
<li><a href="../de446656/index.html">1600bit / s Sprachcodierung mit dem neuronalen Vocoder LPCNet</a></li>
<li><a href="../de446658/index.html">Interview mit Andrei Stankevich über Sportprogrammierung</a></li>
<li><a href="../de446660/index.html">KI, Schüler und großer Preis: Wie man maschinelles Lernen in der 8. Klasse macht</a></li>
<li><a href="../de446662/index.html">Transaktionen und Mechanismen zu ihrer Kontrolle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>