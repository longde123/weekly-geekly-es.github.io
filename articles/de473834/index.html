<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🏫 🤲🏾 #⃣ Blackbox-Überwachung in Clos-Netzwerken. Yandex-Bericht ☕️ 👨🏼‍🏭 🛁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Topologie moderner Rechenzentren und Geräte in ihnen ermöglicht es uns nicht mehr, uns ausschließlich mit der Whitebox-Überwachung zu begnügen. Im...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blackbox-Überwachung in Clos-Netzwerken. Yandex-Bericht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/473834/"> Die Topologie moderner Rechenzentren und Geräte in ihnen ermöglicht es uns nicht mehr, uns ausschließlich mit der <abbr title="Eine Art der Überwachung basierend auf Metriken, die von Anwendungen auf dem Gerät abgerufen wurden. Die Whitebox-Überwachung umfasst beispielsweise das Sammeln von Protokollen und das Überprüfen des Sitzungsstatus.">Whitebox-Überwachung</abbr> zu begnügen.  Im Laufe der Zeit brauchte ich ein Tool, das die Leistung bestimmter Geräte basierend auf der tatsächlichen Situation bei der Übertragung von Datenverkehr (Datenebene) an eine beliebige Stelle im <abbr title="Klose Network ist eine Art mehrstufiges Vermittlungsnetzwerk, das von Charles Klose beschrieben wird. Weit verbreitet in Rechenzentren.">Clos-Netzwerk</abbr> anzeigt.  Vor einigen Wochen teilte der Yandex-Netzwerkingenieur Alexander Klimenko auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Next Hop-</a> Konferenz seine Erfahrungen bei der Lösung dieses Problems mit. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/o3/kv/n3/o3kvn3oecpuipgvx68yuzfib4t4.jpeg"></a> <br><br>  - Ich arbeite in der Betriebs- und Entwicklungsabteilung des Yandex-Netzwerks und manchmal zwingen sie mich, einige Probleme zu lösen, anstatt schöne Wolken auf Flugblätter zu zeichnen oder eine glänzende Zukunft zu erfinden.  Die Leute kommen und sagen, dass etwas für sie nicht funktioniert.  Wenn diese Angelegenheit überwacht wird und unsere diensthabenden Ingenieure feststellen, dass sie nicht funktioniert, ist es für mich selbst einfacher.  Diese halbe Stunde wird also der Überwachung gewidmet sein. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/wi/m7/gn/wim7gnm9iv9s50sfcujeemna250.jpeg"><br><br>  Früher oder später kommt jeder auf die Idee der Überwachung.  Das heißt, zuerst können Sie Appelle der Benutzer selbst sammeln, sie werden auf Sie klopfen und sagen, dass etwas für sie nicht funktioniert.  Es ist jedoch klar, dass ein solches System nicht gut skaliert.  Wenn Sie mehr als einen Switch haben, wenn Sie ein ausreichend großes Netzwerk haben, können Sie mit dieser Überwachungsoption nicht weit kommen. <br><br>  Und früher oder später kommen alle zu dem Schluss, dass es notwendig ist, einige Daten von den Geräten zu sammeln.  Dies ist der allererste Schritt.  Es können Protokolle, verschiedene Daten zu SNMP, Drops, Sie können Topologien gemäß LLDP erstellen usw. sein. Es gibt ein klares Minus - das Gerät selbst stellt Ihnen all diese Informationen zur Verfügung.  Es darf nichts sagen, dich täuschen usw. <br><br>  Die logische Phase bei der Entwicklung Ihrer Überwachung ist die Überwachung auf Hosts.  Wir können sagen, dass es einen kleinen Zweig gibt.  Wenn Sie das Glück haben oder nicht, ein Netzwerk bei einem Anbieter zu haben, kann der Anbieter Ihnen einige Ihrer eigenen Überwachungsoptionen anbieten.  Aber letztes Jahr bei Next Hop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sagte</a> Dima Ershov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> dass unsere Fabrik von zwei einfachen Anbietern gegründet wurde und wir uns einen solchen Luxus nicht leisten können.  Oder wir können, aber nur teilweise. <br><br>  Endlich die letzte Option, die jeder irgendwie mit der Entwicklung des Netzwerks erreicht.  Dies ist die Überwachung auf Endhosts.  Yandex hat eine solche Überwachung.  Es heißt Netmon. <br><br><img src="https://habrastorage.org/webt/8j/kj/_w/8jkj_whnq8eze73jzmmc_w_c-_q.jpeg"><br><br>  Am Ende der Folie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">befindet sich ein Link mit einer detaillierten Darstellung der</a> Funktionsweise von Netmon.  Ich werde es buchstäblich auf einer Folie erzählen.  Wenn jemand möchte, lesen Sie bitte den Vortrag von einer anderen Netmon-Konferenz. <br><br>  Netmon sind Agenten, die auf fast jedem Host im Netzwerk installiert sind.  Die Aufgabe kommt bei den Agenten an: einige Pakete an einen Netzwerkknoten zu senden.  Sie können völlig unterschiedlich sein: UDP, TCP, ICMP.  Es können verschiedene Farben sein, dh DSCP und Bestimmungsort.  Quell- und Zielports können ebenfalls unterschiedlich sein. <br><br>  Diese Daten werden aggregiert, in einen separaten Speicher hochgeladen, und wir erhalten hier ein Segment wie das rechts in der Abbildung.  Ein Slice kann mehr oder weniger aggregiert sein, je nachdem, was wir sehen möchten.  Zum Beispiel haben wir hier, soweit ich sehe, einen Teil der gesamten Konnektivität von Rechenzentren, dh zwischen all unseren Rechenzentren.  Wir können tiefer in die Quadrate hineinfallen - sehen Sie die Konnektivität zwischen dem POD oder innerhalb des Gebäudes eines Rechenzentrums;  noch tiefer - im POD zwischen den Racks;  und noch tiefer - sogar innerhalb des Racks. <br><br><img src="https://habrastorage.org/webt/ea/iq/to/eaiqtolvrecwgo0apgnxdc2rgy0.jpeg"><br><br>  Was könnte hier möglicherweise schief gehen?  Ein kleiner Exkurs für diejenigen, die den Next Hop des letzten Jahres nicht gesehen haben. <br><br>  Wir haben 400 Gigabit pro ToR verwendet und im ersten Moment der Implementierung dieser Fabrik nur 200 eingeschlossen, weil es wichtigere Aufgaben gab.  Egal warum.  Sie schalteten 200 ein, Dienste kamen und sagten: Warum 200?  Wir wollen 400!  Begann es einzuschalten.  Und so kam es, dass der zweite Teil der Fabrik, den wir mit einbezogen hatten, eine Art Ehe im Gedächtnis der Karten hatte.  Als Ergebnis schalten wir die Fabrik ein und sehen dieses Bild: <br><br><img src="https://habrastorage.org/webt/-m/mt/vb/-mmtvbpckx_kmr42-u3dwoditz4.jpeg"><br><br>  Dieses Netmon, die roten Quadrate, brennt.  Wir verstehen, dass alles verloren ist.  Wir greifen wie Homer nach unseren Köpfen und versuchen, etwas hektisch zu schieben.  Und was zu drücken, was auszuschalten ist, verstehen wir nicht.  Das heißt, Netmon zeigt uns das Vorhandensein eines Problems an, zeigt jedoch nicht an, wo sich das Problem tatsächlich im Netzwerk befindet. <br><br><img src="https://habrastorage.org/webt/ef/sg/tu/efsgtu9frnrwu4mcwoajkhqtw4m.jpeg"><br><br>  Wir sind zu der Aufgabe gekommen, die wir erfüllen müssen.  Was ist zu tun?  Stellen Sie fest, bei welchem ​​Gerät im Netzwerk ein Problem vorliegt, und nehmen Sie es außer Betrieb - entweder automatisch oder durch die Kräfte von beispielsweise Dienstingenieuren <br><br>  Darüber hinaus sind die Anfangsbedingungen so, dass wir eine ziemlich regelmäßige Topologie haben, das heißt, es gibt keine merkwürdigen Verbindungen zwischen Spins der zweiten Ebene oder zwischen Tori.  Wir haben den größten Teil des Datenverkehrs - TCP, es gibt einen zentralen Ort, der uns bereits mitgeteilt wurde, und die Server werden mehr oder weniger zentral verwaltet.  Wir können an diesen zentralen Ort kommen und vernünftigerweise erklären: Leute, wir wollen das, bitte. <br><br>  Welche Optionen haben wir in Betracht gezogen? <br><br><img src="https://habrastorage.org/webt/y-/cx/1m/y-cx1mnilmeqpxmlibivrgychbq.jpeg"><br><br>  Das erste, was mir in den Sinn kommt, ist die Rückverfolgung.  Warum?  Da dasselbe Netmon die fehlgeschlagenen Quell- und Zielpaare in einen separaten Kollektor entlädt.  Dementsprechend können wir dieses 5-Tupel nehmen, es betrachten und eine Spur mit denselben Parametern erstellen.  Und um Daten darüber zu aggregieren, über welche Verbindung oder über welche Geräte die meisten Traces durchlaufen werden. <br><br>  Leider wird MPLS in unserer Fabrik verwendet (jetzt bewegen wir uns in die entgegengesetzte Richtung wie MPLS, aber wir müssen auch die alten Fabriken irgendwie überwachen, aber sie nicht wegwerfen).  Wir haben MPLS in der Fabrik, und das Problem mit MPLS und Ablaufverfolgung besteht darin, dass die TTL-überschrittene ICMP-Nachricht getunnelt werden muss, die der Ablaufverfolgung zugrunde liegt.  Wenn wir eine solche Nachricht von Eingang zu Ausgang verloren haben, können wir die Überwachung verlieren.  Das heißt, wir werden nicht verstehen, über welche Knoten diese Nachricht geleitet wurde.  Dies war für die Überwachung nicht geeignet. <br><br><img src="https://habrastorage.org/webt/xl/bg/fr/xlbgfroj02orrytuqectvxi-n18.jpeg"><br><br>  Es gibt eine zweite Option in Bezug auf ECMP.  Wir nehmen das gleiche Quell- und Zielpaar, zusätzlich Quell-Port-Ziel-Port.  Wir kommen zu einem Stück Eisen, über die API oder über die CLI geben wir dieses Stück Eisen dem Stück Eisen zu und erhalten die Ausgabeschnittstelle.  Viele Geräte unterstützen diese Art der Ausgabe. <br><br>  Wir kommen zu ToR und sehen, dass ToR einen linken oder rechten Link gewählt hat.  In diesem Fall ist der linke Link in Richtung des linken S1. <br><br><img src="https://habrastorage.org/webt/pf/k1/fq/pfk1fq3l3zpso1b0dtteib-ip5a.jpeg"><br><br>  Wir kamen zu diesem S1, schauten nach rechts S2 und auf diese Weise bildete sich ein fertiger Pfad. <br><br><img src="https://habrastorage.org/webt/lb/gu/7r/lbgu7r5ogih0uzo4zoazcczuuya.jpeg"><br><br>  Es gibt einige Nachteile.  Erstens können normalerweise nicht alle Geräte diese von uns angegebenen Eingabedaten akzeptieren.  Dies liegt an der Tatsache, dass wir IPv6 und MPLS haben, sowie an der Tatsache, dass einige Anbieter dies einfach nicht implementiert haben.  Das zweite Minus dieser Lösung: Wir verlassen uns darauf, was das Stück Eisen uns wieder sagt, anstatt zu sehen, was auf den Hosts passiert.  Und schließlich das dritte Minus: Während Sie sehen, was dort passiert, kann sich im Netzwerk bereits etwas ändern, und Ihre Daten sind nicht relevant. <br><br><img src="https://habrastorage.org/webt/dy/he/_s/dyhe_sdybz_8nsum0uce40pjg2c.jpeg"><br><br>  Dann stießen wir auf eine interessante Präsentation von Facebook.  Wir mochten die Idee, die Facebook vorschlug, und beschlossen, etwas Ähnliches zu versuchen. <br><br>  Was war die Hauptidee?  Verwenden Sie ein eBPF-Programm auf dem Host, um die TCP-Neuübertragung einzufärben, und berechnen Sie dann die Anzahl solcher Pakete.  Leider konnten wir das nicht wie auf Facebook machen, wir mussten unser eigenes Fahrrad erfinden.  Ich werde versuchen, Ihnen von dem Weg des Schmerzes und des Leidens zu erzählen, den wir durchlaufen haben. <br><br><img src="https://habrastorage.org/webt/bt/5l/5e/bt5l5e9el6kbhutnjsamv3hpo5u.jpeg"><br><br>  Was haben wir getan  Nur für den Fall, ich möchte darauf hinweisen, dass es sich bei der erneuten TCP-Übertragung um TCP-Nachrichten handelt, die mehrmals wiederholt werden, da ihr Empfang nicht bestätigt wurde.  Wir haben ein eBPF-Programm auf dem Host installiert und prüfen, ob diese TCP-Nachricht erneut übertragen wird oder nicht.  Es macht es kitschig - nach Sequenznummer.  Wenn in einer TCP-Sitzung dieselbe Sequenznummer übertragen wird, wird diese erneut übertragen. <br><br>  Was machen wir mit solchen Paketen?  Wir setzen das letzte Bit im DSCP-Feld auf eins, um das Ganze weiter zu berechnen. <br><br><img src="https://habrastorage.org/webt/rk/nh/qm/rknhqmvuhuu9vss_juaqyzlxtza.jpeg"><br><br>  Im Allgemeinen hängt DSCP irgendwie mit QoS zusammen, oder?  Und mit QoS ist die Geschichte in unserem Netzwerk ziemlich kompliziert und langjährig.  Wir haben bestimmte Richtlinien, die auf ToR-Switches überwacht werden.  Zu diesen Richtlinien haben wir nur die Notwendigkeit hinzugefügt, mehr und diese farbigen Pakete zu zählen. <br><br>  Daher haben wir für farbige Pakete (lesen Sie: für TCP-Neuübertragungspakete vom Host) einfach eine weitere QoS-Warteschlange hinzugefügt.  Dies war einfach genug, da wir noch freie Leitungen hatten.  Dies ist außerdem praktisch, da es in der Phase des Übergangs zwischen IPv6 und MPLS in der Fabrik, dh in der Phase, in der das Paket S1 fliegt und zu unserem MPLS-Teil der Fabrik übergeht, praktisch ist, EXP / TC im MPLS-Paket-Header für jede bestimmte Warteschlange zu übernehmen und neu zu streichen . <br><br><img src="https://habrastorage.org/webt/n1/jz/yy/n1jzyyspbgw39b3zv1xngyavgwm.jpeg"><br><br>  Was machen wir mit diesen Daten?  Wir sammeln sie mit Standard-ACL-Filtern, Verkehrsklasse.  Das heißt, es funktioniert im Prinzip bei jedem Anbieter.  Wir können die Anzahl solcher Pakete überall sammeln und berechnen. <br><br>  Als nächstes betrachten wir die ungleichmäßige Verteilung solcher Pakete auf dem POD.  Darin zum Beispiel vier Rücken, wie auf dem Bild.  Wenn die Anzahl der Pakete auf den gelben Links, auf blau, auf grün und auf rot gleich ist, dann glauben wir, dass alles mehr oder weniger gut ist.  Wenn wir zu einem bestimmten Zeitpunkt einen Anstieg sehen, beispielsweise auf der rechten Seite der ersten Ebene, verstehen wir, dass dieses Gerät eine erneute Übertragung anzieht, etwas stimmt damit nicht.  Dann versuchen wir, es entweder außer Betrieb zu setzen oder zumindest zu leasen.  Zumindest wenn wir Probleme mit Netmon sehen, werden wir wissen, mit welchem ​​Gerät sie auftreten können. <br><br><img src="https://habrastorage.org/webt/ky/9t/8u/ky9t8uf1v57wlbqmqsxmmtusipc.jpeg"><br><br>  Wie sieht es bei einfachen Rohdaten aus?  Hier sind zwei Grafiken.  Tatsächlich handelt es sich hierbei um eine erneute Übertragung von Diagrammen mit ToR in Richtung der Wirbelsäule der ersten Ebene.  Im Beispiel zwei Wirbelsäulen im Modul.  Das obere Diagramm ist die Aggregation der ersten Wirbelsäule, das untere Diagramm ist die zweite Wirbelsäule.  Das Anschauen in dieser Form ist nicht sehr praktisch, daher haben wir die Aggregation dieser Informationen hinzugefügt. <br><br><img src="https://habrastorage.org/webt/ab/pu/-o/abpu-on4l0cwiglpfdftt7mzykc.jpeg"><br><br>  Es sieht so aus.  Es gibt ein Modul, in dem drei Stacheln aus irgendeinem Grund, egal welcher, und wir sehen hier eine solche Gesamtverteilung der erneuten Übertragungen auf drei Stacheln.  Es ist im Prinzip ziemlich einheitlich. <br><br><img src="https://habrastorage.org/webt/ar/m0/cm/arm0cmbz77k8bpdu8qqerqsttto.jpeg"><br><br>  Für die Wirbelsäule der zweiten Ebene können verschiedene Abweichungen auftreten. Nennen wir sie so.  Die Topologie bleibt weiterhin regelmäßig, aber je nach Rechenzentrum können wir eine plattenartige Architektur verwenden oder nicht.  Der Punkt hier ist genau der gleiche.  Auf einer Ebene sollten wir ungefähr die gleiche Verteilung der farbigen Verpackungen haben. <br><br><img src="https://habrastorage.org/webt/if/od/og/ifodogqs86mqbfgahucjzo_wrgi.jpeg"><br><br>  Schauen wir uns einige Beispiele an.  Hat jemand ein Problem in einem solchen Diagramm?  Hier gibt es ein Problem, aber es ist nicht gleichzeitig da.  Ja, das ist Schrödingers Problem.  Warum ist sie da und nicht?  Da die Anzahl der erneuten Übertragungen zunimmt, ist es direkt offensichtlich, dass etwas für uns passiert ist.  Gleichzeitig sehen wir aber, dass dieses Wachstum ziemlich gleichmäßig ist.  Das heißt, drei Wirbelsäulenblau, Rot, Blau, gleichmäßige Verteilung über sie.  Was bedeutet das?  Dass es ein Problem im Netzwerk gab, hängt jedoch nicht mit dieser Ebene der Datenaggregation zusammen.  Sie ist woanders. <br><br>  Vielleicht hat jemand den Port auf Firewalls geschlossen, einen Cluster getrennt, das heißt, etwas ist passiert.  Aber wir interessieren uns überhaupt nicht dafür, was da war und warum.  Das heißt, wir betrachten ein solches Problem nicht einmal. <br><br><img src="https://habrastorage.org/webt/ie/_4/tz/ie_4tzqchudv3zrxi6vi_mcwxgm.jpeg"><br><br>  Und hier vielleicht nicht so klar, aber das Problem ist sichtbar.  Zwei Stacheln im Modul, 46 bemalte Päckchen flogen auf einen und ein wenig auf den zweiten.  Wir verstehen, dass wir ein Problem mit einer Art Wirbelsäule im Netzwerk haben, wir müssen etwas dagegen tun. <br><br>  Warum habe ich zuerst über den Weg des Schmerzes und des Leidens gesprochen?  Weil es bei einer solchen Lösung viele Probleme gibt.  Das Hauptproblem ist natürlich das Problem jeder Überwachung, dies ist falsch positiv.  Falsch positiv war ziemlich viel.  Hauptsächlich aufgrund der Tatsache, dass wir DSCP verwenden und im Allgemeinen an QoS gebunden sind. <br><br><img src="https://habrastorage.org/webt/ht/md/rb/htmdrbopskl2febbslxadjbqtlw.jpeg"><br><br>  Wir haben festgestellt, dass die Pakete anderer Leute in unserer Farbe fliegen und uns auf unsere Überwachung aufmerksam machen.  Das heißt, wir denken, dass dies eine erneute Übertragung ist, und jemand anderes legt seine Pakete dort ab und verdirbt im Allgemeinen das Bild für uns.  Natürlich begannen wir zu verstehen, fanden viele Orte, an denen wir dachten, dass es funktioniert, aber es funktioniert tatsächlich nicht so, wie wir denken.  Zum Beispiel sollte der Verkehr, der in das Netzwerk eintritt, scheinbar neu gestrichen werden, der Verkehr mit den Klassen CS6 und CS7 an den Grenzen sollte nicht in unser Netzwerk gelangen.  Aber an einigen Stellen gab es beispielsweise Mängel, und wir haben sie erfolgreich behandelt. <br><br>  Einige Hersteller präsentierten Überraschungen in der Form, dass Sie Zähler in der Ausgangsrichtung solcher Pakete zählen, und der Chip funktioniert so, dass er bei der Verarbeitung der Ausgangszugriffsliste den Datenverkehr erneut durch sich selbst wickelt und die Hälfte der Chipbandbreite abbeißt .  Es waren 900 Gigabit pro Chip, es wurde halb so viel. <br><br>  Und wir haben einige Verbesserungen vorgenommen, da die Einstellungen auf dem Host unterschiedlich sein können.  Das heißt, einige Hosts können häufiger Neuübertragungen senden, einige Hosts können weniger häufig, einige zwei, einige fünf und all diese Warnungen unserer Überwachung, all dies ist falsch positiv. <br><br>  Zunächst haben wir die Idee aufgegeben, jede TCP-Neuübertragung zu malen.  Wir haben erkannt, dass wir im Prinzip nicht jede erneute Übertragung benötigen, um zu verstehen, wo das Problem liegt.  Wir fingen an, nur SYN-Retransmit zu malen.  SYN ist das erste Paket in der Sitzung. Dies reicht aus, um ein Signal zu empfangen.  Wir malen auch SYN-ACL. <br><br>  Trotzdem gab es einige falsch positive.  Wir gingen etwas weiter.  Wir haben begonnen, nur die erste TCP-SYN-Neuübertragung in der Sitzung zu malen.  Das heißt, es werden tatsächlich mehrere von ihnen gesendet, wir haben jeden gemalt - nur einer begann gemalt zu werden.  Wir sind also zu dem gekommen, was wir jetzt haben. <br><br>  Insgesamt gibt es Netmon, es gibt Agenten auf Hosts, die die erste SYN-Neuübertragung in der Sitzung färben, und wir zählen diese Neuübertragungen auf jedem Gerät, auf fast jeder Verbindung in unserem Netzwerk. <br><br><img src="https://habrastorage.org/webt/bk/pn/y1/bkpny1rbllgxlz8nf4v6wynm6ro.jpeg"><br><br>  Aber mit den Augen auf das Bild zu schauen, das ich früher gezeigt habe, ist nicht sehr praktisch.  Das heißt, Sie können es nicht an einen diensthabenden Beamten verkaufen, da Sie in jedem Abschnitt alles mit Ihren Augen bewerten müssen.  Und wir kamen zu der Tatsache, dass ich eine Warnung haben möchte.  Ich möchte, dass ein Licht aufleuchtet: Ein Gerät wie dieses ist ein Problem;  Ein anderes Gerät ist ein Problem. <br><br>  Erinnern wir uns an einige mathematische Statistiken.  Die Idee mit Alarm ist, dass jedes Gerät im Wesentlichen ein Korb ist.  Wir haben eine Erfolgswahrscheinlichkeit und eine Ausfallwahrscheinlichkeit für vier Geräte.  Die Wahrscheinlichkeit einer erneuten Übertragung in den Warenkorb, dh Erfolg, beträgt ¼.  Es stellt sich eine Binomialverteilung heraus. <br><br>  Was ist die Schwierigkeit, hier einen Alarm auszulösen?  Die Tatsache, dass wir die Schwellenwerte nicht statisch machen können, können wir nicht sagen: Wenn zehn Neuübertragungen auf einem Gerät und neun auf dem anderen ankommen, gibt es kein Problem.  Und wenn zehn und fünf, dann gibt es ein Problem.  Denn wenn wir es auf tausend PPS skalieren, sind solche Daten nicht mehr relevant.  1000 PPS und 800 PPS zwischen verschiedenen Geräten sind definitiv ein Problem. <br><br>  Wir können keine statischen Schwellenwerte in PPS oder Bytes festlegen, wir können sie nicht als Prozentsatz festlegen - das gleiche Problem mit ihnen.  Daher benötigen wir eine Lösung, die diesen Schwellenwert je nach Anzahl der Pakete mehr oder weniger dynamisch macht. <br><br>  Und der Reiz der Binomialverteilung besteht darin, dass sie bei der PPS-Erhöhung zur Normalität tendiert, und für eine Normalverteilung können wir bereits die Erwartung, Varianz und das Konfidenzintervall berechnen, was wir getan haben.  Das Konfidenzintervall für uns beträgt 3NPQ, dh es hängt von der Anzahl der Pakete durch das Gerät ab.  Als Ergebnis haben wir eine dynamische Verschiebungsschwelle. <br><br>  So sieht unser Signal im Bild aus.  Wenn ein Gerät aus der Distribution ausgeschlossen wird, setzen wir eine Flagge darauf - etwas stimmt nicht. <br><br><img src="https://habrastorage.org/webt/0e/bo/c_/0eboc_4g2lwamtfgsdus0o-tqzi.jpeg"><br><br>  Wo wollen wir uns weiterentwickeln, was wollen wir hier verbessern, zusätzlich natürlich zum Kampf gegen falsch positive Ergebnisse?  Zunächst wären wir interessiert zu sehen, was zum Zeitpunkt des Problems da war.  Zu diesem Zweck haben wir eine solche Option im Agenten - Debug.  Wir können genau das, was erneut übertragen wurde, dh ein 5-Tupel-Paket, in einen separaten Kollektor hochladen und dann betrachten.  Dies belastet die Hosts jedoch etwas, so dass es uns manchmal verboten ist, dies zu tun.  Wir möchten ERSPAN befestigen und solche Pakete von der Hardware selbst auf den Kollektor entladen, da uns niemand verbietet, dies auf der Hardware zu tun. <br><br>  Dima Afanasyev <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erklärte,</a> wie wir unsere Fabriken entwickeln werden, und einer der Punkte war der Übergang von der MPLS-Fabrik zu IPv6.  Was gibt uns das?  MPLS verfügt über drei Bits für die QoS-Markierung.  In IPv6 mindestens sechs.  Derzeit werden in unserem Netzwerk nur drei Bits verwendet.  Das heißt, wir haben noch drei weitere Bits, in die wir tatsächlich alle Informationen vom Host einfügen können. <br><br>  Zum Beispiel malen wir jetzt nur die erste SYN-Neuübertragung in der Sitzung.  Und wir können das zweite Bit beispielsweise einfärben, wenn das Paket an ein externes Netzwerk geht.  Und wir können erneut senden, dh ein anderes Signal hervorheben, das wir dann separat betrachten werden. <br><br>  Darüber hinaus droht uns der Übergang zum Design mit Edge Pod, wenn wir DCI an einem bestimmten Ort durchgeführt haben, damit, dass wir an diesem Ort unsere Diffserv-Domäne genauer steuern können.  Das heißt, etwas neu streichen und mit Farben tun, um falsch positive Ergebnisse abzuschneiden. <br><br>  Infolgedessen erwies sich all dies als ziemlich schmerzhaft, aber interessant.  Es gab nichts zu befürchten.  Wir haben tatsächlich eine Lösung entwickelt, die jeder nutzen kann.  Es wird bei praktisch jedem Anbieter getestet, es funktioniert, es ist nicht schwierig.  Und es zeigt wirklich, auf welchem ​​Gerät im Netzwerk ein Problem vorliegt.  Daher lautet meine Botschaft: Haben Sie keine Angst, dasselbe zu tun, und lassen Sie Ihre Überwachung grün bleiben.  Danke fürs Zuhören. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473834/">https://habr.com/ru/post/de473834/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473822/index.html">Stellenangebot an einem Tag: Wie wir am selben Tag interviewt und Feedback gegeben haben</a></li>
<li><a href="../de473824/index.html">So erstellen Sie eine Geschäftstechnologie für die Vertriebsplanung in einem einzigen System</a></li>
<li><a href="../de473826/index.html">OTP-Authentifizierung auf dem Apache-Webserver</a></li>
<li><a href="../de473828/index.html">Computer Vision als Alternative zu Büroausweisen</a></li>
<li><a href="../de473832/index.html">ShIoTiny: Updates und Benachrichtigungen</a></li>
<li><a href="../de473838/index.html">DJI Mavic Mini: der leichteste zusammenklappbare Quadrocopter</a></li>
<li><a href="../de473840/index.html">Streamen Sie Videos vom Android-Gerät über UDP zur JAVA-Anwendung</a></li>
<li><a href="../de473842/index.html">Oktober Maschinelles Lernen und künstliche Intelligenz News Digest</a></li>
<li><a href="../de473844/index.html">Warum brauchen wir Bereiche von C ++ 20 in einem einfachen Brecher?</a></li>
<li><a href="../de473846/index.html">So messen Sie die Leistung von Blockchain-Netzwerken. Schlüsselkennzahlen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>