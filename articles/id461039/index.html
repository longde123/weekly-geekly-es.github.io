<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎀 🥄 👨🏾‍🍳 Buku “Algoritma Sempurna. Algoritma Grafik dan Struktur Data " 🍌 👩🏼‍🎓 🤦🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, habrozhiteli! Algoritma adalah jantung dan jiwa dari ilmu komputer. Anda tidak dapat melakukannya tanpa mereka, mereka ada di mana saja - mulai d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku “Algoritma Sempurna. Algoritma Grafik dan Struktur Data "</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/461039/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/e5/2z/76/e52z769bpr1nib4vz_bij_xvkgo.jpeg" align="left" alt="gambar"></a>  Hai, habrozhiteli!  Algoritma adalah jantung dan jiwa dari ilmu komputer.  Anda tidak dapat melakukannya tanpa mereka, mereka ada di mana saja - mulai dari perutean jaringan dan perhitungan genomik hingga kriptografi dan pembelajaran mesin.  "Algoritma Sempurna" akan mengubah Anda menjadi seorang profesional sejati yang akan menetapkan tugas dan menyelesaikannya dengan baik dalam kehidupan maupun dalam sebuah wawancara saat mempekerjakan perusahaan IT mana pun. <br><br>  Dalam buku kedua, Tim Rafgarden, guru algoritma, berbicara tentang pencarian grafik dan aplikasinya, algoritma pencarian jalur terpendek, dan penggunaan dan implementasi beberapa struktur data: tumpukan, pohon pencarian, tabel hash, dan filter Bloom. <br><br>  Posting ini menyajikan kutipan dari Bloom Filter: The Basics. <br><a name="habracut"></a><br><h3>  Tentang apa buku ini </h3><br>  Bagian kedua dari buku "Algoritma Sempurna" adalah kursus pengantar tentang dasar-dasar literasi pada tiga topik berikut. <br><br>  <b>Pencarian grafik dan aplikasi</b> .  Grafik memodelkan sejumlah jenis jaringan yang berbeda, termasuk jalan, komunikasi, jejaring sosial dan jaringan ketergantungan antar tugas.  Grafik bisa rumit, tetapi ada beberapa primitif yang sangat cepat untuk berbicara tentang struktur grafik.  Kita akan mulai dengan algoritma pencarian grafik linear-waktu, dari aplikasi mulai dari analisis jaringan hingga membangun urutan operasi. <br><br>  <b>Jalur terpendek</b> .  Dalam masalah jalur terpendek, tujuannya adalah untuk menghitung rute terbaik di jaringan dari titik A ke titik B. Tugas ini memiliki aplikasi yang jelas, seperti menghitung rute lalu lintas, dan juga tampak tersembunyi dalam banyak tugas universal lainnya.  Kami akan menggeneralisasi salah satu algoritma pencarian grafik kami dan datang ke algoritma pencarian jalur terpendek Dijkstra yang terkenal. <br><br>  <b>Struktur data</b> .  Buku ini akan menjadikan Anda pengguna berpendidikan tinggi dari beberapa struktur data berbeda yang dirancang untuk mendukung serangkaian objek yang berkembang dengan kunci terkait.  Tujuan utamanya adalah untuk mengembangkan intuisi tentang struktur data mana yang tepat untuk aplikasi Anda.  Bagian tambahan memberikan pedoman untuk menerapkan struktur data ini dari awal. <br><br>  Pertama, kami membahas tumpukan yang dapat dengan cepat mengidentifikasi objek yang disimpan dengan kunci terkecil, dan juga berguna untuk menyortir, mengimplementasikan antrian prioritas, dan mengimplementasikan algoritma Dijkstra yang hampir linier-temporal.  Pohon pencarian mempertahankan urutan kunci lengkap pada objek yang disimpan dan mendukung jangkauan operasi yang lebih luas.  Tabel hash dioptimalkan untuk operasi pencarian ultra cepat dan tersebar luas dalam program modern.  Kami juga melihat filter Bloom, kerabat dekat dari tabel hash, yang menggunakan lebih sedikit ruang karena kesalahan acak. <br><br>  Anda dapat membiasakan diri dengan isi buku ini secara lebih rinci di bagian "Kesimpulan", yang melengkapi setiap bab dan mengidentifikasi poin-poin terpenting.  Bagian-bagian buku, ditandai dengan tanda bintang, adalah yang paling canggih dalam hal tingkat informasi yang disajikan.  Jika buku ini dirancang untuk pengenalan topik yang dangkal, maka pembaca dapat mengabaikannya tanpa kehilangan integritas tulisannya. <br><br>  <b>Topik dibahas dalam tiga bagian lainnya</b> .  Bagian pertama buku “Algoritma Sempurna.  Fundamentals ”mencakup notasi asimptotik (notasi O-besar dan kerabat dekatnya), algoritma“ divide and conquer ”dan teorema relasi perulangan utama - metode utama, pengurutan cepat secara acak dan analisisnya, serta algoritma seleksi linear-temporal.  Bagian ketiga berkaitan dengan algoritma serakah (perencanaan, pohon spanning minimal, pengelompokan, kode Huffman) dan pemrograman dinamis (masalah ransel, penyelarasan urutan, jalur terpendek, pohon pencarian optimal).  Bagian keempat dikhususkan untuk kelengkapan NP, apa artinya bagi perancang algoritma, dan strategi untuk memecahkan masalah yang tidak dapat larut secara komputasi, termasuk analisis heuristik dan pencarian lokal. <br><br><h3>  12.5.  Filter Bloom: Dasar-Dasarnya </h3><br>  Filter Bloom adalah kerabat dekat dari tabel hash.  Mereka sangat kompak, tetapi secara berkala membuat kesalahan.  Bagian ini menjelaskan bagaimana filter Bloom baik dan bagaimana mereka diterapkan, sementara bagian 12.6 menetapkan kurva kompromi antara jumlah ruang yang digunakan oleh filter dan tingkat kesalahannya. <br><br><h3>  12.5.1.  Operasi yang didukung </h3><br>  Alasan keberadaan filter Bloom pada dasarnya sama dengan hash table: operasi penyisipan dan tampilan super cepat, berkat itu Anda dapat dengan cepat mengingat apa yang Anda lihat dan apa yang tidak.  Mengapa kita harus direpotkan oleh struktur data yang berbeda dengan rangkaian operasi yang sama?  Karena filter Bloom lebih disukai daripada tabel hash dalam aplikasi di mana ruang bernilai beratnya dalam emas, dan kesalahan acak bukan halangan untuk transaksi. <br><br>  Seperti tabel hash dengan pengalamatan terbuka, filter Bloom jauh lebih mudah untuk diterapkan dan bayangkan dalam pikiran ketika mereka hanya mendukung operasi Sisipkan dan Lihat (dan tanpa operasi Hapus).  Kami akan fokus pada kasus ini. <br><br><blockquote>  FILTER BLOOM: OPERASI YANG DIDUKUNG <br><br>  Lihat: dengan kunci k, kembalikan "ya" jika k sebelumnya dimasukkan ke dalam filter Bloom, dan "tidak" sebaliknya. <br>  Tempel: tambahkan kunci baru k ke filter Bloom. </blockquote><br>  Filter Bloom sangat efisien secara spasial;  biasanya, mereka mungkin hanya membutuhkan 8 bit per sisipan.  Ini cukup sulit dipercaya, karena 8 bit sama sekali tidak cukup untuk mengingat bahkan kunci 32-bit atau pointer ke objek!  Karena alasan ini, operasi tampilan di filter Bloom hanya mengembalikan jawaban "ya" / "tidak", sementara di tabel hash, operasi ini mengembalikan pointer ke objek yang diinginkan (jika ditemukan).  Itulah sebabnya operasi Sisipkan sekarang hanya menerima kunci, dan bukan objek (penunjuk ke). <br><br>  Tidak seperti semua struktur data lain yang kami pelajari, filter Bloom bisa salah.  Ada dua jenis kesalahan: false negative ketika operasi View mengembalikan "false" bahkan jika kunci yang diminta telah dimasukkan sebelumnya, dan pernyataan palsu (atau pemicu) ketika operasi View mengembalikan "true", meskipun kunci yang diminta belum dimasukkan di masa lalu .  Pada bagian 12.5.3 kita akan melihat bahwa filter Bloom dasar tidak pernah menderita negatif palsu, tetapi mereka dapat memiliki "elemen hantu" dalam bentuk pernyataan palsu.  Bagian 12.6 menunjukkan bahwa frekuensi klaim palsu dapat dikontrol dengan menyesuaikan penggunaan ruang secara tepat.  Implementasi khas filter Bloom mungkin memiliki tingkat kesalahan sekitar 1% atau 0,1%. <br><br>  Waktu eksekusi untuk operasi Sisipkan dan Lihat secepat di tabel hash.  Dan yang lebih baik lagi, operasi ini dijamin akan dilakukan dalam waktu yang konstan, terlepas dari penerapan filter Bloom dan data1.  Namun, implementasi dan kumpulan data memengaruhi tingkat kesalahan filter. <br><br>  Untuk merangkum keuntungan dan kerugian filter Bloom atas tabel hash: <br><br><blockquote>  FILTER BLOOM TERHADAP TABEL HASH <br><br>  1. Kelebihan: lebih efektif secara spasial. <br><br>  2. Kelebihan: operasi permanen-waktu yang dijamin untuk setiap kumpulan data. <br><br>  3. Kekurangan: tidak dapat menyimpan pointer ke objek. <br><br>  4. Kontra: penghapusan lebih kompleks dibandingkan dengan tabel hash dengan kopling. <br><br>  5. Kekurangan: probabilitas pernyataan nol salah. </blockquote><br>  Daftar indikator untuk filter Bloom dasar adalah sebagai berikut. <br><br>  Tabel 12.4.  Filter Bloom Dasar: operasi yang didukung dan waktu pelaksanaannya.  Tanda belati (†) menunjukkan bahwa operasi Tampilan memiliki probabilitas klaim palsu yang dapat dikontrol tetapi tidak nol <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j2/s0/bc/j2s0bcwhevqsy2-scnfyznyywpi.png" alt="gambar"></div><br>  Filter Bloom harus digunakan sebagai pengganti tabel hash dalam aplikasi di mana keunggulannya penting dan kerugiannya tidak menjadi penghalang untuk transaksi. <br><br><blockquote>  KAPAN MENGGUNAKAN FILTER BLOOM <br><br>  Jika aplikasi memerlukan pencarian cepat dengan serangkaian objek yang berkembang secara dinamis, ruang sepadan dengan bobotnya dalam emas dan sejumlah kecil klaim palsu yang dapat diterima, maka filter Bloom biasanya merupakan struktur data yang disukai. </blockquote><br><h3>  12.5.2.  Aplikasi </h3><br>  Selanjutnya, ada tiga kegunaan dengan pemindaian berulang, di mana menghemat ruang bisa menjadi penting, dan pernyataan palsu tidak menjadi penghalang untuk transaksi. <br><br>  Pemeriksa ejaan.  Kembali pada tahun 1970-an, filter Bloom digunakan untuk mengimplementasikan pemeriksa ejaan - pemeriksa ejaan.  Pada tahap pra-pemrosesan, setiap kata dalam kamus dimasukkan ke dalam filter Bloom.  Ejaan dokumen turun ke satu operasi. Lihatlah kata dalam dokumen, tandai setiap kata yang operasi ini mengembalikan "tidak". <br><br>  Dalam lampiran ini, pernyataan palsu sesuai dengan kata yang tidak valid yang diterima oleh pemeriksa ejaan secara tidak sengaja.  Kesalahan seperti itu tidak membuat pemeriksa ejaan ideal.  Namun, pada awal 1970-an, ruang bernilai emas, jadi menggunakan filter Bloom pada saat itu adalah strategi win-win. <br><br>  <b>Kata sandi yang dilarang</b> .  Aplikasi lama yang masih berlaku hingga hari ini melacak kata sandi terlarang - kata sandi yang terlalu umum atau terlalu mudah ditebak.  Awalnya, semua kata sandi terlarang dimasukkan ke dalam filter Bloom;  kata sandi terlarang tambahan dapat dimasukkan kemudian, sesuai kebutuhan.  Ketika pengguna mencoba untuk mengatur atau mengatur ulang kata sandi, sistem mencari kata sandi yang diusulkan di filter Bloom.  Jika pencarian mengembalikan "ya", maka pengguna diminta untuk mencoba lagi dengan kata sandi yang berbeda.  Di sini, pernyataan palsu diterjemahkan menjadi kata sandi yang kuat, yang ditolak oleh sistem. <br><br>  Asalkan tingkat kesalahan tidak terlalu tinggi, katakan tidak lebih dari 1% atau 0,1%, ini tidak terlalu menjadi masalah.  Dari waktu ke waktu, beberapa pengguna perlu satu upaya tambahan untuk menemukan kata sandi yang dapat diterima oleh sistem. <br><br>  <b>Router internet</b> .  Sejumlah aplikasi Bloom filter yang menakjubkan saat ini berlangsung jauh di Internet, di mana paket data melewati router dengan kecepatan streaming.  Ada banyak alasan mengapa router mungkin ingin dengan cepat mengingat apa yang dilihatnya di masa lalu.  Misalnya, router mungkin ingin menemukan alamat IP sumber dari paket dalam daftar alamat IP yang diblokir, melacak konten cache untuk menghindari tampilan cache palsu, atau menyimpan statistik yang membantu mengidentifikasi penolakan serangan jaringan layanan.  Tingkat kedatangan paket membutuhkan tampilan super cepat, dan memori router yang terbatas membuat ruang bernilai emas.  Aplikasi ini dikelola secara langsung oleh Bloom Filter. <br><br><h3>  12.5.3.  Implementasi </h3><br>  Melihat ke dalam filter Bloom, Anda dapat melihat implementasi yang elegan.  Struktur data mendukung string n-bit atau, sama, sebuah array A dengan panjang n di mana setiap elemen adalah 0 atau 1. (Semua elemen diinisialisasi ke nol.) Struktur ini juga menggunakan fungsi hash m h1, h2, ..., hm , sementara masing-masing memetakan semesta U dari semua kunci yang mungkin ke set {0, 1, 2, ..., n - 1} dari posisi dalam array.  Parameter m sebanding dengan jumlah bit yang digunakan oleh filter Bloom untuk penyisipan, dan, sebagai aturan, adalah konstanta kecil (misalnya, 5). <br><br>  Setiap kali kunci dimasukkan ke filter Bloom, masing-masing fungsi hash menetapkan flag, mengatur bit array A ke 1 yang sesuai. <br><br><blockquote>  BLOOM FILTER: INSERT (ON KEY) <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> A[hi(k)] := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </blockquote><br>  Misalnya, jika m = 3 dan h1 (k) = 23, h2 (k) = 17 dan h3 (k) = 5, memasukkan k menyebabkan bit ke-5, 17 dan 23 dari array diatur sama 1 (Gbr. 12.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/-d/zf/ma-dzftjbgtmytk1uoelbb0q17o.png" alt="gambar"></div><br>  Dalam operasi Lihat, filter Bloom mencari sidik jari yang mungkin tetap ada pada sisipan k. <br><br><blockquote>  FILTER BLOOM: LIHAT (KEY KEY) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A [hi (k)] = <span class="hljs-number"><span class="hljs-number">0</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> «» <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> «»</code> </pre> </blockquote><br>  Sekarang kita dapat melihat mengapa filter Bloom tidak dapat menderita negatif palsu.  Ketika kunci k dimasukkan, bit m yang sesuai diatur ke 1. Selama masa hidup filter Bloom, bit dapat mengubah nilainya dari 0 ke 1, tetapi tidak sebaliknya.  Jadi, m bit ini tetap 1 selamanya.  Setiap operasi Lihat k berikutnya dijamin untuk mengembalikan jawaban ya yang benar. <br><br>  Kita juga bisa melihat bagaimana pernyataan palsu muncul.  Misalkan m = 3 dan empat tombol k1, k2, k3, k4 memiliki nilai hash berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m0/uo/7r/m0uo7rbq7ewvpqhhmpvdmx8pfs4.png" alt="gambar"></div><br>  Misalkan kita memasukkan k1, k2, k3 dan k4 ke dalam filter Bloom (Gambar 12.6).  Ketiga sisipan ini menghasilkan total sembilan bit yang diatur ke 1, termasuk tiga bit dalam sidik jari kunci k1 (5, 17, dan 23).  Pada titik ini, filter Bloom tidak lagi dapat membedakan apakah kunci k1 dimasukkan atau tidak.  Bahkan jika k1 tidak dimasukkan ke dalam filter, pencarian akan mengembalikan "ya", yang merupakan pernyataan salah. <br><br>  Secara intuitif, kita dapat mengasumsikan bahwa dengan peningkatan ukuran n filter Bloom, jumlah overlay di antara sidik jari kunci yang berbeda akan berkurang, yang, pada gilirannya, mengarah pada sejumlah kecil pernyataan salah.  Tetapi tujuan utama filter Bloom adalah untuk menghemat ruang.  Apakah ada jalan tengah di mana n dan frekuensi pernyataan palsu secara bersamaan kecil?  Jawabannya tidak jelas dan memerlukan beberapa analisis matematika yang dilakukan di bagian selanjutnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/ib/_o/gzib_oomyz17bbrtney0kyxiru4.png" alt="gambar"></div><br><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Untuk diskon 20% Khabrozhiteley pada kupon - <b>Algoritma</b> <br>  Setelah pembayaran versi kertas buku, sebuah buku elektronik dikirim melalui email. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461039/">https://habr.com/ru/post/id461039/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461029/index.html">Danau data pemasaran - dari tabel mengerikan hingga laporan dan visualisasi</a></li>
<li><a href="../id461031/index.html">Kami menghubungkan peta online ke navigator di smartphone. Bagian 1 - peta raster standar</a></li>
<li><a href="../id461033/index.html">Dari mana konfigurasi ini berasal? [Debian / Ubuntu]</a></li>
<li><a href="../id461035/index.html">Episode instruktif dari seri Silicon Valley (Musim 1)</a></li>
<li><a href="../id461037/index.html">Dan di sinilah aku "nyata"</a></li>
<li><a href="../id461041/index.html">Bulat atau sudut akut?</a></li>
<li><a href="../id461043/index.html">Manajemen konflik dalam tindakan penyeimbangan tim atau kebutuhan vital?</a></li>
<li><a href="../id461045/index.html">Dapatkan ekstrak dari Rosreestr melalui FSIS USRN dan python. Bagian 1</a></li>
<li><a href="../id461047/index.html">Menulis atau tidak menulis. Surat kepada pihak berwenang selama acara</a></li>
<li><a href="../id461049/index.html">ONYX BOOX Faust - Dia yang mencari tidak dipaksa untuk berkeliaran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>