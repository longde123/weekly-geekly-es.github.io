<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüëß üêç ‚è∏Ô∏è Geheimnisse der Arbeit mit Stoff im Spiel Alan Wake ü¶ã üî¨ üéé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Der Animationsprogrammierer Henrik Enquist beschrieb, wie sein Team eine √ºberzeugende Tweed-Jackensimulation des Protagonisten des Horror-Thrillers A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geheimnisse der Arbeit mit Stoff im Spiel Alan Wake</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458486/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/18e/a10/c1818ea10be738aafeb51e0157ad247b.jpg"></div><br>  <em>[Der Animationsprogrammierer Henrik Enquist beschrieb, wie sein Team eine √ºberzeugende Tweed-Jackensimulation des Protagonisten des Horror-Thrillers Alan Wake erstellte.]</em> <br><br>  Die Hauptfigur unseres Action-Thrillers ist Alan Wake, ein Schriftsteller, der in einen Albtraum verwickelt ist, in dem er gezwungen ist, mit dunklen M√§chten zu k√§mpfen und das Geheimnis des Verschwindens seiner Frau zu l√∂sen.  Er ist kein gut ausgebildeter Actionheld, sondern ein gew√∂hnlicher Mensch. <br><br>  Um den Charakter zu betonen, wollte unser Art Director ihm eine alte Tweedjacke mit Flecken an den Ellbogen anziehen.  Das Spiel findet im Gefolge der realen Welt statt, daher sind die Charaktere im Gegensatz zu einem Fantasy-Spiel oder einem Weltraum-Shooter in den verwendeten Werkzeugen begrenzt.  Und das bedeutet, dass die Kleidung unserer Charaktere viel wichtiger wird. <br><br>  Um die Illusion einer Thrilleratmosph√§re zu vermitteln, sollte Alan Wakes Jacke so glaubw√ºrdig wie m√∂glich sein.  Die Jacke sollte im Wind flattern und dem Charakter zus√§tzliche Bewegungen hinzuf√ºgen, wenn er sich durch den Wald bewegt.  Als Programmierer begann ich sofort √ºber die Verwendung von Gewebesimulation nachzudenken. <br><br>  Stoffsimulation wurde in vielen Spielen vor uns verwendet, aber die dort oft verwendeten Techniken gaben ein Gef√ºhl von Seide oder Gummi - Materialien, die f√ºr uns nicht geeignet sind.  Erst in j√ºngster Zeit tauchten sehr gute Gewebesimulationssysteme von Drittunternehmen auf, aber zu der Zeit, als wir eine stabile L√∂sung ben√∂tigten, gab es solche Tools noch nicht oder sie entsprachen nicht unseren Anforderungen. <br><br>  In diesem Artikel werde ich √ºber die Probleme sprechen, mit denen wir konfrontiert waren, und √ºber die L√∂sungen f√ºr die Erstellung unserer eigenen Gewebesimulation. <br><a name="habracut"></a><br><h1>  Jacke Rig </h1><br>  Die Jacke wurde zusammen mit dem Rest des Charakters wie ein normales Hautnetz modelliert.  Die Knochen, die das Jackennetz steuern, sind eine separate Schicht auf einem normalen Skelett.  Jacken√§rmel verwenden das √ºbliche Muster f√ºr Schulter und Unterarm.  Sowohl Schultern als auch Unterarme sind in einen Hauptknochen und einen Biegeknochen unterteilt.  Der obere Teil der Jacke wird durch Betrachtungsbeschr√§nkungen gesteuert, und der untere Teil wird durch die Verlet-Simulation gesteuert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c2/6a6/63c/0c26a663c171f554b18e4bd555601477.png"></div><br>  <strong>Abbildung 1. Rig-Jacke auf einem normalen Wildger√ºst.</strong> <br><br><h1>  Jackenoberteil </h1><br>  Die Knochen der Jacke haben eine Hierarchie, die von oben nach unten verl√§uft (die unteren sind Kinder der oberen). Wenn sich also die oberen Knochen bewegen, folgen ihnen die unteren Knochen.  Wir waren versucht, die Tochter mit den unteren Knochen direkt an die Brust zu bringen, aber das w√ºrde zu einem Bewegungsverlust f√ºhren, insbesondere zu vertikalen Bewegungen, wenn der Charakter seine Schultern hebt. <br><br>  Im oberen Teil der Jacke simulieren wir die Bewegung der Polster auf den Schultern, wobei wir die Knochen der Schultern mithilfe von Betrachtungsbeschr√§nkungen in Richtung der Knochen der Schultern bewegen.  Dank dessen folgen die Polster der Schulter, und wenn Sie Ihre Hand heben, hebt das Polster den Rest der Knochen an, wie bei einer echten Jacke. <br><br><div class="spoiler">  <b class="spoiler_title">Wie sieht die Einschr√§nkung der Kostenbeschr√§nkung aus?</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/206/2a0/3af/2062a03af21d6458b3d9b2a278223b83.gif" alt="Bild"></div><br>  <b>Blick auf den roten Kegel</b> </div></div><br>  Die n√§chsten Knochen in der Kette sind die Schichten zwischen dem oberen Teil der Jacke und dem simulierten unteren Teil.  Diese Knochen werden direkt durch Betrachtungsbeschr√§nkungen nach unten getrieben, um die Rotation zu kompensieren, die die Schultern erzeugen.  Wir haben auch Positionsbeschr√§nkungen zwischen dem linken und dem rechten Knochen hinzugef√ºgt, um die Dehnung auszugleichen, die auftritt, wenn sich die Schulterpolster bewegen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/085/686/dc2/085686dc265664fe90ab7659a199f7e0.png"></div><br>  <strong>Abbildung 2. Die Bewegung der Knochen beim Anheben eines Handcharakters.</strong> <br><br>  Dies k√∂nnte v√∂llig ausreichen, um die Einschr√§nkungen im Exporteur von Animationen zu implementieren und die Ergebnisse in den Animationsdaten zu backen, aber wir haben trotzdem versucht, die Knochen in der Spiel-Engine in Echtzeit zu steuern. <br><br>  Dank dessen konnten wir einige Bytes in den Animationsdaten speichern und Animationen einfach zwischen den Charakteren √ºbertragen, unabh√§ngig davon, ob Jacken darauf sind.  Au√üerdem w√ºrden die Schulterbewegungen, die durch die inverse Kinematik des Spiels (zum Beispiel zum Zeitpunkt des Zielens) beim Aufl√∂sen von Echtzeitbeschr√§nkungen erzeugt werden, korrekt angewendet. <br><br><h1>  Die Unterseite der Jacke </h1><br>  Nachdem wir das Problem mit dem oberen Teil der Jacke gel√∂st hatten, simulierten wir den unteren Teil.  Die meisten Spielsimulationen von Stoffen verwenden eine Eins-zu-Eins-Bindung zwischen den Eckpunkten in der Gewebesimulation und den Eckpunkten des gerenderten Netzes. <br><br>  Wir wollten die Genauigkeit des Jackennetzes beibehalten, damit die vom Programmierer festgelegten Einschr√§nkungen nicht beeintr√§chtigt werden.  Wenn wir zum Beispiel das gleiche Netz f√ºr die Stoffsimulation wie f√ºr das Rendern verwenden w√ºrden, w√ºrde die Silhouette der Taschen und der Vorderseite der Jacke verloren gehen. <br><br>  Normale Karten k√∂nnten verwendet werden, um der Jacke Volumen zu verleihen, aber wir waren der Meinung, dass dies nicht ausreichen w√ºrde.  Wir wollten, dass unsere K√ºnstler die Jacke so modellieren, wie sie es wollten, und sie dann normale Karten verwenden, um Falten oder andere Details hinzuzuf√ºgen, anstatt verlorene Geometrie zu kompensieren. <br><br>  Wir kamen zu dieser Entscheidung: Erstellen Sie ein Netz aus Stoff mit niedriger Aufl√∂sung, um eine Jacke zu simulieren, und befestigen Sie es dann an den Knochen des Skeletts, mit dem das Hautnetz gesteuert wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/011/cf3/4e2/011cf34e28fedf303ecc5a62ee15a7b0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f4/bd8/582/2f4bd8582bc2c876c24a6a0663784938.png"></div><br>  <strong>Abbildung 3. Vergleich der Silhouetten unserer Jacke und unseres Stoffes mit denselben Eckpunkten mit einer Simulation.</strong> <br><br><h1>  Physik Werle </h1><br>  Zuerst schauen wir uns die Physik von Verlet an und dann lernen wir, wie man ein Match f√ºr die Simulation von Knochen erstellt.  Verl√© Physics ist derzeit die Standardl√∂sung zur Simulation von Stoffen in Spielen.  Wenn Sie mit der Verlet-Technik nicht vertraut sind, empfehle ich zun√§chst, einen dieser Artikel √ºber Gamasutra zu lesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>Teufel im blau facettierten Kleid: Echtzeit-Stoffanimation</u></a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>fortgeschrittene Charakterphysik</u></a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c62/348/0d0/c623480d0de44a9ae1041f6c2ba9a5e0.png"></div><br>  <strong>Abbildung 4. Ein Raster mit 4x4-Scheitelpunkten und Einschr√§nkungen f√ºr einen der Scheitelpunkte.</strong> <br><br>  Im √úbrigen werde ich das Arbeitsprinzip kurz wiederholen.  Abbildung 4 zeigt ein Stoffnetz und Federbeschr√§nkungen f√ºr einen seiner Eckpunkte.  Wie Sie der Abbildung entnehmen k√∂nnen, ist jeder Netzscheitelpunkt mit allen benachbarten Scheitelpunkten sowie mit deren Nachbarn verbunden. <br><br>  Einschr√§nkungen von unmittelbaren Nachbarn werden als Dehnungsbeschr√§nkungen bezeichnet und sind blau gekennzeichnet.  Lange Bedingungen, die rot angezeigt werden, werden als Scher- / Biegebeschr√§nkungen bezeichnet. <br><br>  Es ist wichtig, diese Einschr√§nkungen in zwei Gruppen zu speichern, da wir sie sp√§ter mit unterschiedlichen Parametern aufl√∂sen werden.  Bitte beachten Sie, dass in unserer Jacke die obere Reihe der Stoffpunkte durch Enth√§uten an den Charakter gebunden ist und nicht von der Simulation gesteuert wird. <br><br>  Das Vorhandensein eines Maschennetzes ist keine Anforderung des Algorithmus selbst. Um jedoch eine Struktur mit einer solchen Topologie zu simulieren, ist es am einfachsten, damit zu arbeiten.  Die Grundlage der Gewebesimulation besteht aus zwei Teilen.  Der erste Teil ist die Verlet-Integration, bei der wir die Geschwindigkeit f√ºr jeden Scheitelpunkt berechnen und auf die Position anwenden. <br><br><pre><code class="cpp hljs">Vector3 vVelocity = vertex.vCurrentPosition - vertex.vPreviousPosition; vertex.vPreviousPosition = vertex.vCurrentPosition; vertex.vCurrentPosition += vVelocity * ( <span class="hljs-number"><span class="hljs-number">1.0f</span></span> - fDampingFactor ) + vAcceleration * fDeltaTime * fDeltaTime;</code> </pre> <br>  In unserem Projekt wurde die <code>vAcceleration</code> durch die Summe von Gravitationskraft und Wind festgelegt.  Die D√§mpfung wurde verwendet, um das Aussehen der Jacke anzupassen und die Simulation zu stabilisieren.  Ein hoher D√§mpfungsfaktor <code>fDampingFactor</code> verleiht der Jacke das Gef√ºhl, dass sehr leichter Stoff langsam und gleichm√§√üig herunterkommt, w√§hrend ein niedriger D√§mpfungsfaktor die Jacke schwerer macht und sie nach der Bewegung l√§nger schwingen / schwingen l√§sst. <br><br>  Der zweite Teil des Algorithmus ist die Aufl√∂sung von Federbeschr√§nkungen (dieser Prozess wird als Relaxation bezeichnet).  F√ºr jede Einschr√§nkung ziehen wir die Scheitelpunkte an oder sto√üen sie voneinander ab, so dass sie ihre urspr√ºngliche L√§nge erf√ºllen.  Hier ist ein lesbarer Codeausschnitt. <br><br><pre> <code class="cpp hljs">Vector3 vDelta = constraint.m_vertex1.m_vCurPos - constraint.m_vertex0.m_vCurPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fLength = vDelta.length(); vDelta.normalize(); Vector3 vOffset = vDelta * ( fLength - constraint.m_fRestLength ); constraint.m_vertex0.m_vCurrentPosition += vOffset / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; constraint.m_vertex1.m_vCurrentPosition -= vOffset / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>;</code> </pre> <br>  Dehnungsbeschr√§nkungen halten die Stoffoberseiten zusammen, und Neigungs- / Biegebeschr√§nkungen helfen dabei, die Form des Stoffes beizubehalten.  Wie Sie sehen k√∂nnen, bewegt sich der Stoff mit einer idealen L√∂sung f√ºr dieses System zu stark.  Aus diesem Grund f√ºgen wir vor dem Aufl√∂sen neuer Positionen einen Koeffizienten zu den Neigungs- / Biegebeschr√§nkungen hinzu. <br><br><pre> <code class="cpp hljs">vOffset *= fStiffness; constraint.m_vertex0.m_vCurrentPosition += vOffset / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; constraint.m_vertex1.m_vCurrentPosition -= vOffset / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>;</code> </pre> <br>  Bei einem Steifheitskoeffizienten von 1,0 ist der Stoff nicht flexibel, und bei 0,0 biegt sich der Stoff ohne Einschr√§nkungen. <br><br><h1>  Zeitschritt behoben </h1><br>  Sie m√ºssen bereits bemerkt haben, dass die Verlet-Integration darauf hindeutet, dass der vorherige Zeitschritt genau der gleiche war wie der aktuelle.  Andernfalls ist die berechnete Geschwindigkeit falsch.  Bei Verwendung der Verlet-Integration kann auf einen variablen Zeitschritt verzichtet werden, die Aufl√∂sung von Einschr√§nkungen reagiert jedoch sehr empfindlich auf √Ñnderungen im Zeitschritt. <br><br>  Da der L√∂ser das Problem durch iteratives Umgehen der Einschr√§nkungen l√∂st, k√∂nnen sie niemals ideal gel√∂st werden.  Im Spiel manifestiert sich diese Ungenauigkeit als Dehnung. Je k√ºrzer der Zeitschritt ist, desto weniger Dehnung sieht der Spieler. <br><br>  Letztendlich ist dies ein Kompromiss zwischen Genauigkeit und der Prozessorzeit, die Sie f√ºr Kleidung aufwenden k√∂nnen.  Wenn der Zeitschritt nicht konstant ist, variiert die Dehnung der Kleidung und wir f√ºhren unerw√ºnschte Vibrationen in das System ein.  Noch wichtiger ist, dass der Zeitschritt den Steifigkeitsindikator und andere Stoffparameter beeinflusst: Je k√ºrzer der Zeitschritt ist, desto steifer wird der Stoff, selbst wenn der gleiche Steifheitskoeffizient verwendet wird. <br><br>  In der Praxis bedeutet dies, dass Sie sich selbst f√ºr einen festen Zeitschritt entscheiden m√ºssen, bevor Sie das Erscheinungsbild der Kleidung mithilfe von Stoffparametern anpassen k√∂nnen.  Ich wei√ü, dass es Spiele gibt, in denen ein variabler Zeitschritt f√ºr die Physik verwendet wird, aber meine pers√∂nliche Erfahrung zeigt mir, dass das Leben viel einfacher wird, wenn der Zeitschritt sowohl f√ºr die Physik als auch f√ºr die Spielelogik festgelegt ist. <br><br><h1>  Haube </h1><br>  Bevor wir uns mit den Details der Gewebesimulation befassen, werfen wir einen kurzen Blick darauf, wie die Haube simuliert wird.  Um die Oberseiten des Haubennetzes zu h√§uten, haben wir einen zus√§tzlichen Knochen verwendet.  Wir haben ein Pendel von der Mitte des Knochens bis zur Position hinter der Haube erstellt.  Das Ende des Pendels ist ein Teilchen, das von der Verlet-Physik gesteuert wird.  Dann wird der Knochen unter Verwendung einer Betrachtungsbeschr√§nkung auf das Pendel gerichtet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/090/fdf/57a/090fdf57a84edb44d5db943b1430f2b8.png"></div><br>  <strong>Abbildung 5. Haube und Pendel.</strong> <br><br><h1>  Knochenmatrizen erstellen </h1><br>  Die Kapuze gibt uns einen Hinweis darauf, was als n√§chstes mit der Unterseite der Jacke zu tun ist.  Wir werden die Scheitelpunktpositionen im simulierten Netz verwenden, um Knochentransformationen zu berechnen. <br><br>  Als erstes ordnen wir die Knochen so zu, dass das Scharnier jedes Knochens mit der Oberseite des simulierten Netzes √ºbereinstimmt.  Aus diesem Grund wird die Aufgabe des Teils der Matrix, der sich auf die Verschiebung bezieht, ein trivialer Prozess sein. <br><br>  Dann m√ºssen wir die 3x3-Rotationsmatrix berechnen.  Jede Zeile (oder Spalte, abh√§ngig von der Konfiguration der Matrix) wird durch die x-, y- und z-Achse des Knochens definiert. <br><br>  Wir definieren die x-Achse des Knochens als die Richtung vom Basisscheitelpunkt zum n√§chsten darunter.  Dann wird die y-Achse durch den Vektor vom Scheitelpunkt links zum Scheitelpunkt rechts definiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0d/ba1/428/c0dba1428673d304dc5119e43e96e92e.png"></div><br>  <strong>Abbildung 6. Am Stoffnetz befestigte Knochen.</strong> <br><br>  In Abbildung 6 ist die x-Achse rot und die y-Achse gr√ºn dargestellt.  Dann wird die z-Achse als Vektorprodukt dieser Vektoren berechnet.  Am Ende orthonormalisieren wir auch die Matrix, um die Verzerrung in den Verschiebungsdaten zu beseitigen. <br><br>  Wie Sie sehen k√∂nnen, verwenden wir in vertikaler Richtung jede Reihe des Stoffnetzes (mit Ausnahme der letzten), um die Knochen anzupassen, aber in horizontaler Richtung wird nur jede zweite Spalte verwendet.  Neben der Tatsache, dass es die oben beschriebenen k√ºnstlerischen Vorteile bietet, ist diese Methode auch recht schnell.  Dank dessen k√∂nnen herk√∂mmliche Skinning-Techniken auf der GPU-Seite verwendet werden, um das Netz zu rendern, da wir sonst den riesigen dynamischen Scheitelpunktpuffer aktualisieren m√ºssten. <br><br>  Ein Fabric-Mesh kann eine relativ niedrige Aufl√∂sung haben, wodurch die CPU weniger belastet wird.  Die einzigen zus√§tzlichen Kosten f√ºr unsere L√∂sung bestehen darin, die Simulation mit niedriger Aufl√∂sung in ein hochaufl√∂sendes Netz umzuwandeln. In unserem Schema sind diese Kosten jedoch im Vergleich zum Rest der Simulation vernachl√§ssigbar. <br><br><h1>  Kollisionen </h1><br>  Um das Problem des Trimmens von Gewebe mit Beinen und K√∂rper zu l√∂sen, verwenden wir die Erkennung von Kollisionen zwischen einem Ellipsoid und einem Partikel.  Abbildung 7 zeigt die Ellipsoide, die zum Aufl√∂sen des Abschneidens einer Jacke durch ein Charaktermodell erforderlich sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4a/277/f0c/a4a277f0c2991b0a013d821a8879ecea.jpg"></div><br>  <strong>Abbildung 7. Das Ellipsoidsystem f√ºr das Wake-Modell.</strong> <br><br>  Die Erkennung von Kollisionen von Ellipsoiden mit Partikeln ist sehr schnell.  Kollisionen k√∂nnen gel√∂st werden, indem der Raum, in dem sich das Ellipsoid und das Teilchen befinden, so transformiert wird, dass sich das Ellipsoid in eine Kugel verwandelt.  Anschlie√üend k√∂nnen Sie einen schnellen Kollisionstest der Kugel und des Partikels durchf√ºhren. <br><br>  In der Praxis geht dies mit der Erzeugung einer inversen Transformation einher, die auf den Werten der L√§nge, Breite und H√∂he des Ellipsoids mit seiner Anwendung auf die Position des Partikels basiert.  Das einzige Problem hierbei ist, dass die normale Kollision, die wir nach der R√ºckkonvertierung in das urspr√ºngliche Koordinatensystem erhalten, verzerrt ist. <br><br>  Wir haben beschlossen, dass wir uns bei der Berechnung der Kollisionsrichtung mit einer leichten Ungenauigkeit abfinden k√∂nnen.  In F√§llen, in denen ein stark gedehntes Ellipsoid zu falschen Reaktionen f√ºhren kann, haben wir es in zwei homogenere unterteilt. <br><br><h1>  Der maximale Abstand zum Partikel </h1><br>  Ein weiteres Problem, das gel√∂st werden musste, war die Stabilit√§t der Jacke.  Das Gewebe w√§hrend einer schnellen Bewegung kann zur Bildung von Knoten f√ºhren oder auf der anderen Seite des Kollisionsvolumens erscheinen und durch den K√∂rper gelangen.  Wir haben dieses Problem gel√∂st, indem wir f√ºr jeden Scheitelpunkt des simulierten Gewebes einen Sicherheitsabstand festgelegt haben. <br><br>  F√ºr jeden Scheitelpunkt wird die anf√§ngliche Ruheposition durch Enth√§uten am n√§chsten Knochen befestigt und wir verwenden sie als Referenzpunkt.  Wenn die Simulation den Schwellenwert √ºberschreitet, bewegen wir den Scheitelpunkt einfach n√§her an den Referenzpunkt.  In unserem Design haben wir zugelassen, dass sich die Spitzen darunter um eine gr√∂√üere Strecke bewegen als die Spitzen n√§her an den Schultern. <br><br>  Die maximale Entfernung, √ºber die sich die Peaks bewegen k√∂nnen, betr√§gt ca. 40 cm. Wenn dieser Wert √ºberschritten wird, treten seltene F√§lle von Knoten und K√ºrzungen auf.  Wir haben auch versucht, andere Techniken zu verwenden, zum Beispiel Kollisionsebenen, aber die Methode der maximalen Entfernung erwies sich als die beste.  Es war schnell, einfach einzurichten und bot die gr√∂√üte Bewegungsfreiheit, bevor erkennbare Fehler im Stoff auftraten. <br><br><h1>  Mehr Tweed, weniger Gummi </h1><br>  Bisher konnten wir gute Wege finden, um unsere Ziele zu erreichen.  Unser K√ºnstler hat seine Jacke so modelliert, wie er wollte;  F√ºr die Animation der Jacke wurde kein Animator ben√∂tigt, da alles im Spiel simuliert wurde und der Prozessor sich dar√ºber freute, dass wir gen√ºgend Ressourcen f√ºr andere Berechnungen im Spiel hatten.  Aber eines hat uns gest√∂rt - der Stoff sah aus wie Gummi. <br><br><h1>  Stretching bek√§mpfen </h1><br>  Zuerst m√ºssen wir die Strecke loswerden.  Wie ich oben sagte, wird das Ph√§nomen des Streckens durch Fehler verursacht, die aufgrund der iterativen Natur des Algorithmus auftreten.  Dies ist ein beliebtes Forschungsthema und es k√∂nnen viele Methoden gefunden werden, um dieses Problem zu l√∂sen. <br><br>  Leider w√ºrden uns alle verf√ºgbaren L√∂sungen dazu zwingen, viel knappere CPU-Ressourcen f√ºr Gewebeberechnungen zuzuweisen.  Daher haben wir das Problem der Dehnung gel√∂st, indem wir der Gewebesimulation den letzten Schritt hinzugef√ºgt haben, in dem die sogenannten ‚Äûharten Einschr√§nkungen‚Äú angewendet werden. <br><br>  Wir haben die Dehnungsbeschr√§nkungen streng eingeschr√§nkt (sie sind alle vertikal ausgerichtet).  Diese Einschr√§nkungen wurden von oben nach unten sortiert, so dass Einschr√§nkungen in der N√§he der Schultern in Einschr√§nkungen in der N√§he der Beine aufgel√∂st wurden. <br><br>  Da wir die Einschr√§nkungen von oben durchlaufen, wissen wir, dass der obere Scheitelpunkt im Paar bereits gel√∂st wurde und keine Dehnung verursacht. Daher m√ºssen wir nur den unteren Scheitelpunkt in Richtung des oberen verschieben.  Dank dessen k√∂nnen wir sicher sein, dass nach einer einzelnen Iteration die L√§nge von oben nach unten genau der L√§nge in Ruhe entspricht. <br><br><pre> <code class="cpp hljs">Vector3 vDelta = constraint.m_vertexTop.m_vCurPos - constraint.m_vertexDown.m_vCurPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fLength = vDelta.length(); vDelta.normalize(); Vector3 vOffset = vDelta * ( fLength - constraint.m_fRestLength ); constraint.m_vertexDown.m_vCurrentPosition += vOffset;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7e/84c/a2a/c7e84ca2afe73e36a6c4c89a01fbec14.png"></div><br>  <strong>Abbildung 8. Enge Einschr√§nkungen.</strong> <br><br>  Wie Sie sehen, ber√ºcksichtigen wir die horizontale Dehnung der Jacke nicht.  Es ist unm√∂glich, strenge Beschr√§nkungen f√ºr die horizontale Richtung anzuwenden, da in diesem Fall der Scheitelpunkt zweimal aufgel√∂st wird, dh wir verlieren die Ergebnisse der vertikalen Berechnungsstufe und die L√§nge des Gewebes wird nicht in Ruhe gehalten. <br><br>  Wir haben jedoch festgestellt, dass bei einer Jacke die horizontale Dehnung f√ºr das menschliche Auge tats√§chlich unsichtbar bleibt und die Jacke aufgrund der vertikalen Dehnung sehr schlecht aussieht.  Diese L√∂sung erwies sich als recht gut. <br><br><h1>  Jackenkanten </h1><br>  Zweitens wollten wir, dass sich die Kanten der Jacke etwas mehr bewegen als der Rest.  Wenn Sie beispielsweise in einer weit ge√∂ffneten Jacke laufen, werden Sie feststellen, dass der Luftwiderstand die Kanten der Jacke st√§rker beeinflusst als den Mittelteil.  Dies liegt daran, dass Ihr K√∂rper den Rest der Jacke vor dem Wind sch√ºtzt. <br><br>  Kanten k√∂nnen leicht anhand der Anzahl der damit verbundenen Einschr√§nkungen gefunden werden.  Jeder Scheitelpunkt mit weniger als vier Dehnungsbeschr√§nkungen ist eine Kante.  Daher k√∂nnen wir diese Eckpunkte markieren und mit anderen Parametern simulieren. <br><br><ul><li>  Reduzierte D√§mpfung. </li><li>  Der globale Wind hat einen gr√∂√üeren Einfluss. </li><li>  Bewegung im Weltraum hat einen gr√∂√üeren Einfluss (mehr zur Bewegung im Weltraum siehe unten). </li><li>  Der maximal zul√§ssige Sicherheitsabstand ist h√∂her. </li></ul><br>  Aus diesem Grund unterscheidet sich die Innenfrequenz der Kanten vom Rest der Jacke.  Jetzt reagiert die gesamte Jacke nicht mehr auf Impulse wie ein gro√ües Pendel, und nur die Kanten verleihen der Bewegung eine sch√∂ne Hilfsbewegung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d8/31a/db6/8d831adb6fe8481e9b05830abf71e555.png"></div><br>  <strong>Abbildung 9. Die Kantenoberseiten.</strong> <br><br><h1>  Bewegung im Weltraum und im lokalen Raum </h1><br>  Dann haben wir festgestellt, dass beim Bewegen eines Charakters die Bewegung im Weltraum einen ziemlich gro√üen Einfluss auf die Simulation hat, w√§hrend kleine lokale K√∂rperdrehungen oder Schulterbewegungen unbemerkt bleiben. <br><br>  In einer traditionellen Gewebesimulation werden die Positionen der Eckpunkte im Weltraum simuliert.  Jemand mag sagen, dass die Simulation des Stoffes korrekt ist, aber es f√ºhlt sich unnat√ºrlich an.  Aus diesem Grund haben wir eine Jacke f√ºr Charaktere im lokalen Raum simuliert und separat eine kleine Bewegung im Weltraum hinzugef√ºgt.  Wir haben festgestellt, dass die Ergebnisse, die wir ben√∂tigen, mit 100% lokaler Animation des Skeletts mit 10-30% Bewegung im Weltraum erzielt werden. <br><br><h1>  Reibung </h1><br>  Und schlie√ülich wollten wir den Kontrast zwischen der Jacke in langsamen und schnellen Bewegungen √ºbertreiben.  Wir wollten, dass die Jacke beim Gehen relativ bewegungslos ist, und wenn Alan springt oder ausweicht, sollte die Bewegung lebhafter sein. <br><br>  Wir dachten, wenn die Jacke den K√∂rper ber√ºhrt, sollte sie sich aufgrund der Reibung zwischen Jacke und Hemd weniger bewegen, und wenn sich die Jacke hebt, sollte sie sich mehr bewegen, weil nichts sie einschr√§nkt.  Wir haben dies simuliert, indem wir jedem Scheitelpunkt, der das Ellipsoid ber√ºhrt, einen erh√∂hten D√§mpfungswert zugewiesen haben.  Dank dessen erscheinen die den K√∂rper ber√ºhrenden Oberteile etwas klebrig, wodurch in normalen Situationen und bei schnellen Bewegungen ein ausreichender Kontrast zwischen der Jacke entsteht. <br><br><h1>  Fazit und weitere Arbeit </h1><br>  Die erste Ausf√ºhrungsform der Gewebesimulation war recht einfach zu implementieren: Wir haben nur in der Spielentwicklungsliteratur nach dem Wort ‚ÄûStoff‚Äú gesucht und die gefundenen Algorithmen angewendet.  Die zweite Phase, in der wir versuchten, ein √ºberzeugendes Gef√ºhl f√ºr eine Tweedjacke zu erzielen, erforderte das Studium wissenschaftlicher Artikel, viele Versuche und sogar das Entfernen eines Teils des Codes. <br><br>  Nat√ºrlich kann man immer etwas verbessern.  Die Verwendung einer Simulation mit niedriger Aufl√∂sung und die Verkn√ºpfung mit einem hochaufl√∂senden Netz erschwert beispielsweise die L√∂sung des Problems aller K√ºrzungen.  Wir hatten nicht genug Zeit f√ºr andere kleine Details: Dies sind beispielsweise Faltkarten an den Stellen der Falten der Jacke oder die Umsetzung der richtigen Interaktion zwischen Jacke und Tornado. <br><br>  Letztendlich haben sich unsere Bem√ºhungen gelohnt - unser Stoff unterscheidet sich stark von der Gewebesimulation in anderen Spielen.  Sie sieht viel mehr aus wie ein Tweed als wie Seide oder Gummi.  Dar√ºber hinaus erwies sich unser System als sehr flexibel und erm√∂glichte es uns, andere Stoffe zu simulieren, beispielsweise die Daunenjacke von Barry Wheeler und den Schleier der alten Dame.  Es scheint, dass Sie durch Anpassen der Parameter eine Simulation und andere Gewebetypen erzielen k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/18e/a10/c1818ea10be738aafeb51e0157ad247b.jpg"></div><br>  <strong>Abbildung 10. Tweedjacke.</strong> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458486/">https://habr.com/ru/post/de458486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458468/index.html">Wie f√ºhre ich ein beeindruckendes Kanban-StandUp-Meeting durch?</a></li>
<li><a href="../de458470/index.html">Texturierung oder was Sie wissen m√ºssen, um ein Oberfl√§chenk√ºnstler zu werden. Teil 2. Masken und Texturen</a></li>
<li><a href="../de458472/index.html">Erstellung einer Gebietsbewertung nach der Methode der thermischen Potentiale unter Verwendung offener Daten</a></li>
<li><a href="../de458474/index.html">Beste Berichte mit HighLoad ++ 2018</a></li>
<li><a href="../de458482/index.html">Teil 3: Linux fast von einer SD-Karte auf RocketChip laden</a></li>
<li><a href="../de458488/index.html">Data Science Digest (Juli 2019)</a></li>
<li><a href="../de458490/index.html">Halten Sie das Lenkrad fest ... Unser Projekt zur √úberwachung des Fahrerzustands</a></li>
<li><a href="../de458492/index.html">‚ÄûWir haben immer an Wettbewerb und das Recht geglaubt, einen Benutzer auszuw√§hlen‚Äú ¬© Yandex</a></li>
<li><a href="../de458494/index.html">Ein praktisches Beispiel f√ºr die Verwendung der Renderfunktionen von Vue: Erstellen eines typografischen Rasters f√ºr ein Entwurfssystem</a></li>
<li><a href="../de458496/index.html">Praktische Richtlinien f√ºr die Entwicklung umfangreicher React-Anwendungen. Planung, Aktionen, Datenquellen und APIs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>