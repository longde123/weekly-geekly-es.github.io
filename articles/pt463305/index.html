<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💑 🍩 🎷 Ferramentas para analisar e depurar aplicativos .NET 👨🏽‍🌾 🎚️ 👳🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Você pode olhar sob o capô do código ou ver o dispositivo CLR interno usando várias ferramentas. Este post nasceu de um tweet e eu tenho que agradecer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ferramentas para analisar e depurar aplicativos .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/463305/"><p>  Você pode olhar sob o capô do código ou ver o dispositivo CLR interno usando várias ferramentas.  Este post nasceu de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tweet</a> e eu tenho que agradecer a todos que ajudaram a fazer uma lista de ferramentas adequadas.  Se eu perdi algum deles, escreva nos comentários. </p><br><p>  Primeiro, devo mencionar que um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bom depurador já está presente no Visual Studio</a> e no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VSCode</a> .  Também existem muitas boas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferramentas de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criação de perfil .NET</a> (comerciais) e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferramentas de monitoramento de aplicativos</a> .  Por exemplo, recentemente tentei trabalhar com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Codetrack</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fiquei</a> impressionado com seus recursos. </p><br><p>  No entanto, a postagem restante é dedicada a <strong>ferramentas para executar tarefas individuais</strong> , o que ajudará a <strong>entender melhor o</strong> que está acontecendo.  Todas as ferramentas são de <strong>código aberto</strong> . </p><br><p><img src="https://habrastorage.org/webt/uu/sb/pb/uusbpbgbp6ae5s67fn03rsdhbdw.jpeg"></p><a name="habracut"></a><br><h3 id="perfviewhttpsgithubcommicrosoftperfview-ot-vensa-morrisonahttpsblogsmsdnmicrosoftcomvancem">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PerfView</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vance Morrison</a> </h3><br><p>  PerfView é uma ótima ferramenta que venho usando há vários anos.  Ele funciona com base no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Windows Event Tracing</a> (ETW) e permite entender melhor o que está acontecendo no CLR, além de oferecer a oportunidade de obter um perfil de utilização de memória e CPU.  Para dominar a ferramenta, você terá que absorver muitas informações, por exemplo, com a ajuda de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vídeos</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">treinamento</a> , mas vale a pena o tempo e o esforço. </p><br><p>  A ferramenta é tão útil que os próprios engenheiros da Microsoft a usam e muitas das recentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">melhorias de desempenho no MSBuild</a> apareceram após a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">análise de gargalos</a> usando o PerfView. <br>  A ferramenta é baseada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca Microsoft.Diagnostics.Tracing.TraceEvent</a> , que você pode usar para criar suas próprias ferramentas.  Além disso, como o código fonte da biblioteca está aberto, graças à comunidade, muitas funções úteis apareceram nela, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gráficos de chama</a> : </p><br><p><img src="https://habrastorage.org/webt/ih/vw/hw/ihvwhwkremjcudbtwjt4a0ajtbo.png"></p><br><h3 id="sharplabhttpssharplabio-ot-andreya-schyokinahttpstwittercomashmind">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SharpLab</a> por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Andrey Shcheokin</a> </h3><br><p> O SharpLab surgiu como uma ferramenta para verificar o código IL gerado pelo compilador Roslyn e acabou se transformando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em algo mais</a> : </p><br><blockquote>  O SharpLab é um ambiente interativo para executar o código .NET, que exibe as etapas intermediárias e os resultados da compilação do código.  Algumas funções da linguagem são apenas invólucros para outras, por exemplo, usando () torna-se try / catch.  Com o SharpLab, você verá o código como o compilador o vê e entenderá melhor a essência das linguagens .NET. </blockquote><p>  A ferramenta suporta C #, Visual Basic e F #, mas as funções mais interessantes são Descompilação / Desmontagem: <br>  As funções de descompilação / desmontagem podem ser usadas para: </p><br><ol><li>  C # </li><li>  Visual basic </li><li>  IL </li><li>  JIT Asm (código ASM nativo) </li></ol><br><p>  Você entendeu corretamente: a ferramenta gera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o código do assembler</a> que o .NET JIT gera a partir do seu código C #: </p><br><p><img src="https://habrastorage.org/webt/ch/3g/x2/ch3gx2hpoda7dcxa3qpjiknwfsa.png"></p><br><h3 id="object-layout-inspectorhttpsgithubcomsergeyteplyakovobjectlayoutinspector-ot-sergeya-teplyakovahttpstwittercomsteplyakov">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inspetor de layout de objetos</a> por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sergey Teplyakov</a> </h3><br><p>  Com essa ferramenta, você pode analisar a estrutura dos objetos .NET na memória, ou seja,  como o JITter organizou os campos pertencentes à sua classe ou estrutura.  Isso é útil ao escrever código de alto desempenho.  Também é bom ter uma ferramenta que faça o trabalho duro para nós. </p><br><p> Não há documentação oficial que descreva a estrutura do campo, pois os autores do CLR se reservam o direito de alterá-la no futuro.  Mas o conhecimento da estrutura pode ser útil se você estiver trabalhando em um aplicativo de alta velocidade. <br>  Como você pode estudar a estrutura?  Você pode examinar a memória não processada no Visual Studio ou usar o <code>!dumpobj</code> na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">extensão de depuração</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SOS</a> .  Ambas as abordagens exigem muito esforço, portanto, criaremos uma ferramenta que exibirá a estrutura do objeto em tempo de execução. </p><br><p>  De acordo com o exemplo no repositório GitHub, se você usar <code>TypeLayout.Print&lt;NotAlignedStruct&gt;()</code> com código semelhante: </p><br><pre> <code class="plaintext hljs">public struct NotAlignedStruct { public byte m_byte1; public int m_int; public byte m_byte2; public short m_short; }</code> </pre> <br><p>  A saída a seguir será exibida, mostrando com precisão como o CLR organizará a estrutura na memória com base nas regras de otimização e preenchimento. </p><br><pre> <code class="plaintext hljs">Size: 12. Paddings: 4 (%33 of empty space) |================================| | 0: Byte m_byte1 (1 byte) | |--------------------------------| | 1-3: padding (3 bytes) | |--------------------------------| | 4-7: Int32 m_int (4 bytes) | |--------------------------------| | 8: Byte m_byte2 (1 byte) | |--------------------------------| | 9: padding (1 byte) | |--------------------------------| | 10-11: Int16 m_short (2 bytes) | |================================|</code> </pre> <br><h3 id="the-ultimate-net-experiment-tunehttptooslowexceptioncomthe-ultimate-net-experiment-project-ot-konrada-kokosyhttpstwittercomkonradkokosa">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A experiência definitiva em .NET (TUNE)</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conrad Coconuts</a> </h3><br><p>  Conforme declarado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na página do GitHub</a> , o TUNE é uma ferramenta promissora.  Ele o ajudará a aprender sobre os componentes internos do .NET e como melhorar o desempenho experimentando o código C # </p><br><p>  Informações detalhadas sobre ele podem ser encontradas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta postagem</a> , mas em um nível alto, ele funciona da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seguinte maneira</a> : </p><br><ul><li>  escreva um exemplo de código C # que contenha pelo menos uma classe com um método público que use um parâmetro de seqüência de caracteres.  O código é iniciado usando o botão Executar.  Você pode incluir qualquer número de métodos e classes.  Mas lembre-se de que o primeiro método público da primeira classe pública será executado usando o primeiro parâmetro da janela de entrada sob o código; </li><li>  clique no botão Executar para compilar e executar o código.  Além disso, ele será compilado no código IL e no código do montador nas guias correspondentes; </li><li>  enquanto o Tune está em execução (inclusive em tempo de execução), a ferramenta cria um gráfico que exibe dados do coletor de lixo.  Ele contém informações sobre tamanhos de geração e sessões de coleta de lixo (representadas como linhas verticais com um número abaixo, que indica em qual coleta de lixo de geração é realizada). </li></ul><br><p>  É assim: </p><br><p><img src="https://habrastorage.org/webt/3f/iv/rh/3fivrhkihbo4q3oxyi0bk47z7py.png"></p><br><h2 id="instrumenty-na-baze-clr-memory-diagnostics-clrmd">  Ferramentas de diagnóstico de memória CLR (ClrMD) </h2><br><p>  Finalmente, vamos dar uma olhada em uma certa categoria de ferramentas.  Desde o lançamento do .NET, os desenvolvedores sempre conseguiram usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WinDBG</a> e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">extensão de depuração SOS</a> para ver o que acontece no tempo de execução do .NET.  No entanto, essas não são as ferramentas mais fáceis para um primeiro conhecido e, como afirmado no próximo tweet, nem sempre são as mais produtivas: </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="973923339906486272"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>  Felizmente, a Microsoft disponibilizou a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ClrMD</a> (também conhecida como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Microsoft.Diagnostics.Runtime</a> ) e agora qualquer um pode criar uma ferramenta para analisar despejos de memória para programas .NET.  Informações detalhadas podem ser encontradas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no blog oficial</a> .  Eu também recomendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dar uma</a> olhada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ClrMD.Extensions</a> , que <em>"... fornece integração com o LINPad e facilita o uso do ClrMD"</em> . </p><br><p>  Eu queria montar uma lista de todas as ferramentas existentes e pedir ajuda no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Twitter</a> .  Lembrando-se: tenha cuidado com os tweets.  O gerente responsável pelo WinDBG pode lê-los e ficar chateado! </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="973940550473797633"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>  A maioria dessas ferramentas funciona com base no ClrMD, porque é mais fácil.  Mas se desejar, você pode usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interfaces COM diretamente</a> .  Também deve ser observado que qualquer ferramenta baseada no ClrMD <strong>não</strong> é <strong>multiplataforma</strong> , já que o próprio ClrMD foi projetado apenas para Windows.  As opções de plataforma cruzada são <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descritas</a> em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Analisando um .NET Core Core Dump no Linux</a> . </p><br><p>  Por fim, para manter o equilíbrio de alguma forma, uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">versão aprimorada do WinDBG</a> apareceu recentemente, e eles imediatamente tentaram adicionar funcionalidade: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estendendo o novo WinDbg, Parte 1 - Botões e Comandos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estendendo o novo WinDbg, Parte 2 - Janelas de Ferramentas e Saída de Comandos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estendendo o novo WinDbg, Parte 3 - Incorporando um interpretador de C #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Extensão WinDBG + extensões da ferramenta de interface do usuário</a> e muito mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O NetExt</a> é um aplicativo WinDBG que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">facilita a depuração no .NET em</a> comparação com as opções atuais: sos ou psscor.  Veja também <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este artigo da InfoQ</a> . </li></ul><br><p>  <strong>Depois de todas essas palavras, vá para a lista:</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SuperDump</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> ) <br><ul><li>  Ferramenta para análise automática de despejo de memória ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apresentação</a> ) </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">msos</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> ) <br><ul><li>  Um ambiente com uma interface de linha de comando, como o WinDbg, para executar comandos do SOS na ausência do SOS. </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MemoScope.Net</a> ( <a href="">GitHub</a> ) <br><ul><li>  Uma ferramenta para analisar a memória do processo no .NET.  Você pode despejar a memória do aplicativo em um arquivo e lê-lo mais tarde. </li><li>  O arquivo contém todos os dados (objetos) e informações sobre os threads (estado, pilha, pilha de chamadas).  O MemoScope.Net analisará os dados e o ajudará a encontrar vazamentos de memória e conflitos. </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dnSpy</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> ) <br><ul><li>  Depurador e editor de assembly .NET </li><li>  Pode ser usado para editar e depurar assemblies, mesmo se você não tiver código fonte. </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MemAnalyzer</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> ) <br><ul><li>  Uma ferramenta de análise de memória para código gerenciado.  Existe uma interface de linha de comando. </li><li>  O <code>!DumpHeap</code> no <code>!DumpHeap</code> pode determinar quais objetos ocupam mais espaço no heap sem precisar instalar um depurador. </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DumpMiner</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> ) <br><ul><li>  Ferramenta GUI ClrMD.  Mais recursos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aparecerão no futuro</a> . </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rastrear CLI</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> ) <br><ul><li>  Ferramenta para depuração e rastreamento durante a operação </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Galpão</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> ) <br><ul><li>  Shed é um aplicativo que analisa a execução de um programa no .NET.  Ele pode ser usado para analisar malware, a fim de obter dados sobre quais informações são armazenadas quando esse software é iniciado.  Galpão pode: </li><li>  Recuperar todos os objetos armazenados no heap gerenciado </li><li>  exibir linhas armazenadas na memória; </li><li>  crie um instantâneo de heap no formato JSON para processamento adicional; </li><li>  despejar todos os módulos carregados na memória. </li></ul></li></ul><br><p>  Você pode encontrar muitas outras ferramentas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que usam o ClrMD</a> .  A disponibilização foi uma boa ideia da Microsoft. </p><br><h2 id="drugie-instrumenty">  Outras ferramentas </h2><br><p>  Outras ferramentas que vale a pena mencionar: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Debugdiag</a> <br><ul><li>  A ferramenta DebugDiag foi projetada para corrigir problemas como congelamentos, baixo desempenho, vazamentos de memória ou fragmentação, além de falhas nos processos no modo de usuário (agora com integração ao CLRMD). </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SOSEX</a> (talvez não esteja mais sendo desenvolvido) <br><ul><li>  ... uma extensão para depurar código gerenciado que reduz minha insatisfação com o SOS. </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VMMap</a> da Sysinternals <br><ul><li>  O VMMap é uma ferramenta para analisar a memória virtual e física dos processos. </li><li>  Usei-o para analisar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o uso de memória no CLR</a> </li></ul></li></ul><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt463305/">https://habr.com/ru/post/pt463305/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt463295/index.html">C ++ e CMake - Brothers Forever, Parte II</a></li>
<li><a href="../pt463297/index.html">Lealdade ao seu gosto</a></li>
<li><a href="../pt463299/index.html">Dicas e truques do Kubernetes: como aumentar a produtividade</a></li>
<li><a href="../pt463301/index.html">Gonkey - Ferramenta de Teste de Microsserviços</a></li>
<li><a href="../pt463303/index.html">Finalmente, o Facebook para de segmentar anúncios para números de telefone que as pessoas inserem para o 2FA</a></li>
<li><a href="../pt463307/index.html">Estudo de caso sobre comunicação com um cliente "pesado"</a></li>
<li><a href="../pt463311/index.html">CTT em soluções de servidor. A segunda versão + o anúncio da terceira, com a capacidade de tocar</a></li>
<li><a href="../pt463313/index.html">Uma abordagem alternativa para se inscrever em eventos ou o EventObject é realmente necessário?</a></li>
<li><a href="../pt463317/index.html">Detalhes técnicos de hackers Capital One bank na AWS</a></li>
<li><a href="../pt463321/index.html">Cestas e caixas de usabilidade: análise das 20 principais lojas online de nichos russos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>