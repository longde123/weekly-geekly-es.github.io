<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßóüèæ üò≥ üèè C√≥mo conectamos Prometeo ‚§¥Ô∏è üí´ üåø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De alguna manera tuve que lidiar con las m√©tricas para nuestra API, como siempre (¬øno hay tiempo?) Para agregar m√°s tarde, es muy dif√≠cil y a√∫n no se ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo conectamos Prometeo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475600/"><p> De alguna manera tuve que lidiar con las m√©tricas para nuestra API, como siempre (¬øno hay tiempo?) Para agregar m√°s tarde, es muy dif√≠cil y a√∫n no se ha implementado, lo que significa que es hora de implementarlo.  Despu√©s de algunas andanzas en la red, me pareci√≥ que el sistema de monitoreo m√°s popular era Prometeo. </p><br><p>  Usando Prometheus, podemos monitorear varios recursos de la computadora, tales como: memoria, procesador, disco, carga de red.  Tambi√©n puede ser importante para nosotros calcular el n√∫mero de llamadas a los m√©todos de nuestra API o medir el tiempo de ejecuci√≥n, porque cuanto mayor es la carga en el sistema, m√°s costoso es el tiempo de inactividad.  Y aqu√≠ Prometeo viene en nuestra ayuda.  Me parece que este art√≠culo proporciona los puntos principales para comprender el trabajo de Prometheus y para agregar una colecci√≥n de m√©tricas a la API.  Por lo tanto, comenzamos con lo m√°s banal, con una peque√±a descripci√≥n. </p><a name="habracut"></a><br><p>  Prometheus es un sistema de c√≥digo abierto y DBMS de series temporales escrito en Go y desarrollado por SoundCloud.  Tiene documentaci√≥n oficial y soporte para idiomas como: Go, Java o Scala, Python, Ruby.  Hay soporte no oficial para otros idiomas, como: C #, C ++, C, Bash, Lua para Nginx, Lua para Tarantool y otros, toda la lista est√° en el sitio web oficial de Prometheus. </p><br><p>  Todos los servicios de Prometheus est√°n disponibles como im√°genes de Docker en Docker Hub o Quay.io. </p><br><p> Prometheus se inicia mediante el <code>docker run -p 9090:9090 prom/prometheus</code> , que lo inicia con la configuraci√≥n predeterminada y establece el puerto <code>localhost:9090</code> Despu√©s de eso, la interfaz de usuario de Prometheus estar√° disponible en <code>localhost:9090</code> . </p><br><p>  Prometheus es un sistema de monitoreo que incluye varias herramientas para configurar el monitoreo de aplicaciones (puntos finales) utilizando el protocolo HTTP.  Cuando se conecta a Prometheus, la API HTTP no admite "autenticaci√≥n b√°sica".  Si desea usar la autenticaci√≥n b√°sica para conectarse a Prometheus, se recomienda que use Prometheus junto con un servidor proxy inverso y use la autenticaci√≥n a nivel de proxy.  Puede usar cualquier proxy inverso con Prometheus. </p><br><p>  <strong><em>Los principales componentes de Prometeo:</em></strong> </p><br><ul><li>  un servidor que recopila m√©tricas, las guarda en la base de datos y las limpia; </li><li>  paquetes para recopilar m√©tricas en la API; </li><li>  Pushgateway: componente para recibir m√©tricas de aplicaciones para las que no se puede utilizar una solicitud Pull; </li><li>  Exportadores: herramientas para exportar m√©tricas de aplicaciones y servicios de terceros, instalados en m√°quinas de destino; </li><li>  AlertManager: administrador de notificaciones (alertas), las alertas se definen en el archivo de configuraci√≥n y se establecen mediante un conjunto de reglas para las m√©tricas. <br>  Si durante la operaci√≥n se cumple con la regla, se activa una alerta y se env√≠a a los destinatarios especificados por correo electr√≥nico, Slack, etc. </li></ul><br><p>  Los objetos con los que Prometheus trabaja se llaman m√©tricas recibidas de los objetivos, ya sea a trav√©s de Pushgateway o de Exportadores. </p><br><p>  <strong><em>Al recopilar m√©tricas, se utilizan varios m√©todos para transmitirlas:</em></strong> </p><br><ul><li>  Prometheus solicita m√©tricas del objetivo a trav√©s de una solicitud de extracci√≥n, cuya configuraci√≥n se especifica en el archivo de configuraci√≥n en la secci√≥n scrape_config para cada trabajo. <br>  Cuando el sistema recopila datos, puede controlar la frecuencia de recopilaci√≥n y crear varias configuraciones de recopilaci√≥n de datos para seleccionar una frecuencia diferente para diferentes objetos; </li><li>  Los exportadores le permiten recopilar m√©tricas de varios objetos, por ejemplo: bases de datos (MongoDB, SQL, etc.), corredores de mensajes (RabbitMQ, EMQ, NSQ, etc.), equilibradores de carga HTTP, etc. </li><li>  Pushgateway.  Se puede usar si es necesario, cuando la aplicaci√≥n no puede proporcionar la capacidad de proporcionar m√©tricas directamente a Prometheus;  o cuando se usan trabajos por lotes que no tienen la capacidad de usar la solicitud de extracci√≥n de Prometheus. </li></ul><br><p>  Por lo tanto, Prometheus almacenar√° todas las m√©tricas recibidas en una base de datos con marcas de tiempo. </p><br><p>  <strong><strong>Configuracion</strong></strong> </p><br><p>  Prometheus se configura utilizando los indicadores de l√≠nea de comando y los archivos de configuraci√≥n provistos en el formato YAML.  Los indicadores de l√≠nea de comando le permiten configurar par√°metros inmutables, como: rutas, vol√∫menes de datos almacenados en el disco y en la memoria, etc.  El archivo de configuraci√≥n le permite configurar todo lo relacionado con trabajos y configurar archivos cargados de reglas yaml.  Todo est√° escrito en el archivo de configuraci√≥n global, le permite establecer configuraciones generales para todos y resaltar configuraciones para diferentes secciones de configuraci√≥n por separado.  La configuraci√≥n que las encuestas de Prometheus se configuran en el archivo de configuraci√≥n en la secci√≥n scrape_configs. </p><br><p>  Prometheus puede volver a cargar los archivos de configuraci√≥n durante la operaci√≥n, si la nueva configuraci√≥n no es v√°lida, no se aplicar√°.  El reinicio del archivo de configuraci√≥n se activa enviando el comando SIGHUP Prometheus o enviando la solicitud HTTP POST a <code>/-/reload</code> , siempre que se <code>--web.enable-lifecycle</code> el <code>--web.enable-lifecycle</code> .  Tambi√©n volver√° a cargar todos los archivos de reglas configurados. </p><br><p>  <strong><strong>¬øQu√© tipos de datos se utilizan?</strong></strong> </p><br><p>  Prometheus almacena un modelo de datos multidimensional personalizado y utiliza un lenguaje de consulta para datos multidimensionales llamado PromQL.  Prometheus almacena datos en forma de series de tiempo; admite varias opciones de almacenamiento: </p><br><ul><li>  almacenamiento en disco local: cada 2 horas, los datos almacenados en la memoria se comprimen y almacenan en el disco.  Por defecto, el directorio ./data se usa en el directorio de trabajo para guardar archivos comprimidos; </li><li>  Repositorio remoto: Prometheus admite la integraci√≥n con repositorios de terceros (por ejemplo: Kafka, PostgreSQL, Amazon S3, etc.) a trav√©s del adaptador Protocol Buffer. </li></ul><br><p>  La serie de tiempo almacenada est√° determinada por la m√©trica y los metadatos en forma de pares clave-valor, aunque, si es necesario, el nombre de la m√©trica no se puede usar y la m√©trica misma consistir√° solo en metadatos.  Una serie temporal se puede definir formalmente como &lt;nombre de m√©trica&gt; {&lt;metadata&gt;}.  <strong><em>La clave</em></strong> es &lt;nombre de la m√©trica&gt; {&lt;metadata&gt;}: lo que estamos midiendo, y el <strong><em>valor</em></strong> es el valor real como un n√∫mero con el tipo float64 (Prometheus solo admite este tipo).  La descripci√≥n de la clave contiene metadatos (etiquetas), tambi√©n descritos por pares clave-valor: &lt;nombre de etiqueta&gt; = "&lt;valor de etiqueta&gt;", &lt;nombre de etiqueta&gt; = "&lt;valor de etiqueta&gt;", ... </p><br><p>  <strong>Al almacenar m√©tricas, se utilizan los siguientes tipos de datos:</strong> </p><br><ul><li>  <strong><em>Contador</em></strong> : cuenta la cantidad durante un per√≠odo de tiempo.  Este tipo de m√©tricas solo puede aumentar (no puede usar valores negativos) o restablecer el valor. <br>  Puede ser adecuado, por ejemplo, para contar la cantidad de solicitudes por minuto o la cantidad de errores por d√≠a, la cantidad de paquetes de red enviados / recibidos, etc. </li><li>  <strong><em>Indicador</em></strong> : almacena valores que pueden disminuir o aumentar con el tiempo. <br>  Gauge no muestra el desarrollo de m√©tricas durante un per√≠odo de tiempo.  Con Gauge, puede perder cambios m√©tricos irregulares con el tiempo. </li><li>  <strong><em>Histograma</em></strong> : guarda varias series de tiempo: la suma total de todos los valores observados;  el n√∫mero de eventos que se observaron; <br>  contadores acumulativos (cubos): se indican en la etiqueta como <code>le="&lt;upper inclusive bound&gt;"</code> . <br>  Los valores se recopilan en √°reas con l√≠mites superiores personalizados (dep√≥sitos). </li><li>  <strong><em>Resumen</em></strong> : guarda varias series de tiempo: la suma total de todos los valores observados;  el n√∫mero de eventos que se observaron; <br>  flujo œÜ-cuantiles (0 ‚â§ œÜ ‚â§ 1) de eventos observados - se indican en la etiqueta como <code>quantile="&lt;œÜ&gt;"</code> . </li></ul><br><p>  <strong><strong>¬øC√≥mo se guardan los datos?</strong></strong> </p><br><p>  Prometheus recomienda "dar" 2/3 de RAM a una aplicaci√≥n en ejecuci√≥n. <br>  Para almacenar datos en la memoria, Prometheus usa archivos llamados fragmentos; cada m√©trica tiene su propio archivo.  Todos los archivos de fragmentos son inmutables, excepto el √∫ltimo en el que se escriben los datos.  Los nuevos datos se guardan en fragmentos y cada 2 horas la secuencia de fondo combina los datos y los escribe en el disco.  Cada bloque de dos horas consta de un directorio que contiene uno o m√°s archivos de fragmentos que contienen todas las muestras de series de tiempo para ese per√≠odo de tiempo, as√≠ como un archivo de metadatos y un archivo de √≠ndice (que indexa los nombres de las m√©tricas y etiquetas para series de tiempo en los archivos de fragmentos).  Si dentro de una hora, Prometheus no escribe datos en el fragmento, entonces se guardar√° en el disco y se crear√° un nuevo fragmento para escribir datos.  El per√≠odo m√°ximo de retenci√≥n de datos en Prometheus es de ~ 21 d√≠as. </p><br><p>  Porque  el tama√±o de la memoria es fijo, el rendimiento de escritura y lectura del sistema estar√° limitado por esta cantidad de memoria.  La cantidad de memoria PTSDB est√° determinada por el per√≠odo de tiempo m√≠nimo, el per√≠odo de recopilaci√≥n y el n√∫mero de m√©tricas de tiempo. </p><br><p>  Prometheus tambi√©n tiene un mecanismo WAL para evitar la p√©rdida de datos. </p><br><p>  <strong><em>El registro de escritura anticipada (WAL)</em></strong> serializa las operaciones memorizadas en un medio permanente en forma de archivos de registro.  En caso de falla, los archivos WAL se pueden usar para restaurar la base de datos a su estado consistente mediante la restauraci√≥n desde los registros. </p><br><p>  Los archivos de registro se almacenan en un directorio wal en segmentos de 128 MB.  Estos archivos contienen datos sin procesar que a√∫n no se han comprimido, por lo que son significativamente m√°s grandes que los archivos de fragmentos normales. </p><br><p>  Prometheus almacenar√° al menos 3 archivos de registro, pero los servidores con mucho tr√°fico pueden ver m√°s de tres archivos WAL, ya que necesita almacenar al menos dos horas de datos sin procesar. </p><br><p>  El resultado del uso de WAL es una reducci√≥n significativa en el n√∫mero de solicitudes de escritura en el disco, ya que  solo un archivo de registro debe escribirse en el disco, y no todos los datos que se han modificado como resultado de la operaci√≥n.  El archivo de registro se escribe secuencialmente y, por lo tanto, el costo de sincronizar el registro es mucho menor que el costo de escribir fragmentos con datos. </p><br><p>  Prometheus guarda puntos de interrupci√≥n peri√≥dicos, que por defecto se agregan cada 2 horas al comprimir los registros del per√≠odo anterior y guardarlos en el disco. </p><br><p>  Todos los puntos de interrupci√≥n se almacenan en el mismo directorio que checkpoint.ddd, donde ddd es un n√∫mero monot√≥nicamente creciente.  Por lo tanto, cuando se recupera de una falla, puede restaurar los puntos de interrupci√≥n del cat√°logo de puntos de interrupci√≥n con una indicaci√≥n del pedido (.ddd). <br>  Al escribir registros de WAL, puede volver a cualquier punto de control para el que est√© disponible el registro de datos. </p><br><p>  <strong><strong>¬øQu√© pas√≥ en la pr√°ctica?</strong></strong> </p><br><p>  Al agregar al proyecto (.Net Framework), utilizamos el paquete Prometheus.Client.3.0.2 para recopilar m√©tricas.  Para recopilar m√©tricas, los m√©todos y clases necesarios se han agregado al proyecto para almacenar m√©tricas hasta que Prometheus las reciba. </p><br><p>  Originalmente se defini√≥ una interfaz IMetricsService que conten√≠a m√©todos de temporizador para medir cu√°nto tiempo funcionaron los m√©todos: </p><br><pre> <code class="plaintext hljs">public interface IMetricsService { Stopwatch StartTimer(); void StopTimer(Stopwatch timer, string controllerName, string actionName, string methodName = "POST"); }</code> </pre> <br><p>  Agregamos la clase MetricsService, que implementa la interfaz IMetricsService y almacena temporalmente las m√©tricas. </p><br><pre> <code class="plaintext hljs">public class MetricsService : IMetricsService { private static Histogram _histogram; static MetricsService() { _histogram = CreateHistogram(); } public Stopwatch StartTimer() { try { var timer = new Stopwatch(); timer.Start(); return timer; } catch (Exception exception) { Logger.Error(exception); } return null; } public void StopTimer(Stopwatch timer, string controllerName, string actionName, string methodName = "POST") { try { if (timer == null) { throw new ArgumentException($"{nameof(timer)} can't be null."); } timer.Stop(); _histogram .WithLabels(controllerName, actionName, methodName) .Observe(timer.ElapsedMilliseconds, DateTimeOffset.UtcNow); } catch (Exception exception) { Logger.Error(exception); } } public static List&lt;string&gt; GetAllLabels() { var metricsList = new List&lt;string&gt;(); try { foreach (var keyValuePair in _histogram.Labelled) { var controllerName = keyValuePair.Key.Labels[0].Value; var actionName = keyValuePair.Key.Labels[1].Value; var methodName = keyValuePair.Key.Labels[2].Value; var requestDurationSum = keyValuePair.Value.Value.Sum; var requestCount = keyValuePair.Value.Value.Count; metricsList.Add($"http_request_duration_widget_sum{{controller={controllerName},action={actionName},method={methodName}}} {requestDurationSum}"); metricsList.Add($"http_request_duration_widget_count{{controller={controllerName},action={actionName},method={methodName}}} {requestCount}"); } _histogram = CreateHistogram(); } catch (Exception exception) { Logger.Error(exception); } return metricsList; } private static Histogram CreateHistogram() { var newMetrics = Metrics .WithCustomRegistry(new CollectorRegistry()) .CreateHistogram(name: "http_request_duration_web_api", help: "Histogram metrics of Web.Api", includeTimestamp: true, labelNames: new[] { "controller", "action", "method" }); var oldValue = _histogram; for (var i = 0; i &lt; 10; i++) { var oldValue = Interlocked.Exchange&lt;Histogram&gt;(ref oldValue, newMetrics); if (oldValue != null) { return oldValue; } } return null; } }</code> </pre> <br><p>  Ahora podemos usar nuestra clase para almacenar las m√©tricas que planeamos recopilar en los m√©todos Application_BeginRequest, Application_Error, Application_EndRequest.  En la clase Global.cs, agregamos una colecci√≥n de m√©tricas a los m√©todos anteriores. </p><br><pre> <code class="plaintext hljs">private IMetricsService _metricsService; protected virtual void Application_BeginRequest(object sender, EventArgs e) { var context = new HttpContextWrapper(HttpContext.Current); var metricServiceTimer = _metricsService.StartTimer(); context.Items.Add("metricsService", _metricsService); context.Items.Add("metricServiceTimer", metricServiceTimer); } protected virtual void Application_EndRequest(object sender, EventArgs e) { WriteMetrics(new HttpContextWrapper(HttpContext.Current)); } protected void Application_Error(object sender, EventArgs e) { WriteMetrics(new HttpContextWrapper(HttpContext.Current)); } private void WriteMetrics(HttpContextBase context) { try { _metricsService = context.Items["metricsService"] as IMetricsService; if (_metricsService != null) { var timer = context.Items["metricServiceTimer"] as Stopwatch; string controllerName = null; string actionName = null; var rd = RouteTable.Routes.GetRouteData(context); if (rd != null) { controllerName = rd.GetRequiredString("controller"); actionName = rd.GetRequiredString("action"); } _metricsService.StopTimer(timer, controllerName, actionName, context.Request.HttpMethod); } } catch (Exception exception) { Logger.Error("Can't write metrics.", exception); } }</code> </pre><br><p>  Agregue un nuevo controlador, que ser√° un punto de referencia para enviar las m√©tricas de nuestra API a Prometheus: </p><br><pre> <code class="plaintext hljs">public class MetricsController : Controller { [HttpGet] public string[] GetAllMetrics() { try { var metrics = MetricsService.GetAllLabels(); return metrics.ToArray(); } catch (Exception exception) { Logger.Error(exception); } return new string[] { }; } }</code> </pre> <br><p>  El √∫ltimo paso ser√° configurar la configuraci√≥n de Prometheus para recopilar m√©tricas en la secci√≥n scrape_configs, despu√©s de lo cual podemos ver las m√©tricas recopiladas ya en la interfaz de usuario de Prometheus o Grafana. </p><br><p>  <strong><strong>Caracter√≠sticas clave que nos interesaron en Prometheus:</strong></strong> </p><br><p>  Modelo de datos multidimensionales: m√©tricas y etiquetas. <br>  Lenguaje flexible de consulta PromQL.  En el mismo operador de consulta, podemos usar operaciones como multiplicaci√≥n, suma, concatenaci√≥n, etc.  Se puede realizar con m√∫ltiples m√©tricas. <br>  Recopila datos basados ‚Äã‚Äãen HTTP utilizando el m√©todo de extracci√≥n. <br>  Compatible con el m√©todo push a trav√©s de Pushgateway. <br>  Es posible recopilar m√©tricas de otras aplicaciones a trav√©s de exportadores. <br>  Proporciona un mecanismo para evitar la p√©rdida de datos. <br>  Admite varias representaciones gr√°ficas de datos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/475600/">https://habr.com/ru/post/475600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../475588/index.html">Tres paradigmas</a></li>
<li><a href="../475590/index.html">Compilaci√≥n de programas con Notepad ++</a></li>
<li><a href="../475594/index.html">JavaScript entretenido: una ecuaci√≥n casi lineal</a></li>
<li><a href="../475596/index.html">Grandes hip√≥tesis de n√∫meros primos demostradas para sistemas de n√∫meros peque√±os</a></li>
<li><a href="../475598/index.html">Organizaci√≥n de una arquitectura simple en una aplicaci√≥n de Android con un mont√≥n de ViewModel + LiveData, Retrofit + Coroutines</a></li>
<li><a href="../475604/index.html">Configuraci√≥n de la plantilla oficial de PostgreSQL en Zabbix 4.4</a></li>
<li><a href="../475608/index.html">Administrador de etiquetas de Google: configuraciones de disparador poco obvias y √∫tiles</a></li>
<li><a href="../475610/index.html">L√°mparas de mesa LED seguras que retienen la visi√≥n</a></li>
<li><a href="../475612/index.html">Dado, cuando, afirmaciones y confianza en la implementaci√≥n</a></li>
<li><a href="../475614/index.html">Automatizaci√≥n para los m√°s peque√±os. Segunda parte Dise√±o de red</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>