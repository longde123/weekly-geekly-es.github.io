<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”¤ ğŸ‘¨ğŸ½â€ğŸ¨ ğŸ‡ğŸ¾ Pertukaran macam ğŸ‚ğŸ» ğŸ ğŸ¤¸ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda menjelaskan dalam beberapa kalimat tentang prinsip pertukaran sorting apa yang berfungsi, maka: 



1. Elemen array dibandingkan berpasangan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pertukaran macam</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414653/"><div style="text-align:center;"><img width="700" height="312" src="https://habrastorage.org/webt/cf/xj/x_/cfxjx_qzr1qqhjmwvqz8eyygnxm.png"></div><br><br>  Jika Anda menjelaskan dalam beberapa kalimat tentang prinsip pertukaran sorting apa yang berfungsi, maka: <br><br><ol><li>  Elemen array dibandingkan berpasangan </li><li>  Jika elemen di sebelah kiri <sup>*</sup> lebih besar dari elemen di sebelah kanan, maka elemen tersebut ditukar </li><li>  Ulangi langkah 1-2 hingga array diurutkan </li></ol><br>  <sup><em>* - elemen di sebelah kiri berarti elemen dari pasangan yang dibandingkan, yang lebih dekat ke tepi kiri array.</em></sup>  <sup><em>Dengan demikian, elemen di sebelah kanan lebih dekat ke tepi kanan.</em></sup> <br><a name="habracut"></a><br>  Saya segera minta maaf karena mengulangi materi terkenal, tidak mungkin bahwa setidaknya satu dari algoritma dalam artikel akan menjadi wahyu untuk Anda.  Tentang pengurutan ini di HabrÃ© sudah ditulis berkali-kali (termasuk saya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> ) dan bertanya mengapa lagi untuk kembali ke topik ini?  Tetapi karena saya memutuskan untuk menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian artikel yang koheren tentang semua penyortiran di dunia</a> , saya harus melalui metode pertukaran bahkan dalam versi kilat.  Ketika mempertimbangkan kelas-kelas berikut, sudah akan ada banyak algoritma baru (dan sedikit orang yang tahu) yang pantas mendapatkan artikel menarik yang terpisah. <br><br>  Secara tradisional, "penukar" termasuk penyortiran di mana elemen berubah (semu) secara acak (bogosort, bozosort, permsort, dll.).  Namun, saya tidak memasukkan mereka ke dalam kelas ini, karena mereka tidak memiliki perbandingan.  Akan ada artikel terpisah tentang penyortiran ini, di mana kami banyak berfilsafat tentang teori probabilitas, kombinatorik, dan kematian termal Semesta. <br><br><h1>  Sortir Konyol :: Urut antek </h1><br><img width="342" height="96" src="https://habrastorage.org/web/eb5/6f6/820/eb56f6820b904324a5df67714e2c8866.gif"><br><br><ol><li>  Bandingkan (dan jika perlu ubah) elemen-elemen di ujung subarray. </li><li>  Kami mengambil dua pertiga dari subarray dari awal dan menerapkan algoritma umum untuk 2/3 ini secara rekursif. </li><li>  Kami mengambil dua pertiga dari subarray dari ujungnya dan menerapkan algoritma umum untuk 2/3 ini secara rekursif. </li><li>  Dan lagi, kita mengambil dua pertiga dari subarray dari awal dan menerapkan algoritma umum untuk 2/3 ini secara rekursif. </li></ol><br>  Awalnya, sebuah subarray adalah seluruh array.  Dan kemudian rekursi membagi subarray induk menjadi 2/3, membuat perbandingan / pertukaran di ujung segmen yang terfragmentasi, dan akhirnya mengatur semuanya. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stooge_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, j = None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: j = len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[j] &lt; data[i]: data[i], data[j] = data[j], data[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j - i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: t = (j - i + <span class="hljs-number"><span class="hljs-number">1</span></span>) // <span class="hljs-number"><span class="hljs-number">3</span></span> stooge_rec(data, i, j - t) stooge_rec(data, i + t, j) stooge_rec(data, i, j - t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stooge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stooge_rec(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Kelihatannya skizofrenik, tetapi 100% benar. <br><br><h1>  Sortir Lambat :: Sortir lambat </h1><br><img width="342" height="96" src="https://habrastorage.org/web/f31/348/4f5/f313484f5bd44ea09b50e899e3d90548.gif"><br><br>  Dan di sini kita amati mistisisme rekursif: <br><br><ol><li>  Jika subarray terdiri dari satu elemen, maka kami menyelesaikan rekursi. </li><li>  Jika sebuah subarray terdiri dari dua atau lebih elemen, maka bagi menjadi dua. </li><li>  Kami menerapkan algoritma secara rekursif ke bagian kiri. </li><li>  Kami menerapkan algoritma secara rekursif ke bagian kanan. </li><li>  Elemen di ujung subarray dibandingkan (dan diubah jika perlu). </li><li>  Kami menerapkan algoritma secara rekursif ke subarray tanpa elemen terakhir. </li></ol><br><br>  Awalnya, sebuah subarray adalah seluruh array.  Dan rekursi akan terus membelah dua, membandingkan dan mengubah sampai semuanya beres. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slow_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, i, j)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= j: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data m = (i + j) // <span class="hljs-number"><span class="hljs-number">2</span></span> slow_rec(data, i, m) slow_rec(data, m + <span class="hljs-number"><span class="hljs-number">1</span></span>, j) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[m] &gt; data[j]: data[m], data[j] = data[j], data[m] slow_rec(data, i, j - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> slow_rec(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Ini terlihat seperti omong kosong, tetapi array tersebut dipesan. <br><br><h3>  Mengapa StoogeSort dan SlowSort berfungsi dengan benar? </h3><br>  Seorang pembaca yang ingin tahu akan mengajukan pertanyaan yang masuk akal: mengapa kedua algoritma ini bekerja?  Mereka tampaknya sederhana, tetapi tidak terlalu jelas bahwa Anda dapat mengurutkan sesuatu seperti itu. <br><br>  Pertama mari kita lihat pada Slow sort.  Poin terakhir dari algoritma ini mengisyaratkan bahwa upaya pengurutan lamban yang rekursif hanya ditujukan untuk menempatkan elemen terbesar dalam subarray di posisi paling kanan.  Ini terutama terlihat jika Anda menerapkan algoritma ke array yang dipesan kembali: <br><br><img width="342" height="96" src="https://habrastorage.org/webt/lk/mx/nu/lkmxnutci_ufoymes6b4rksoqua.gif"><br><br>  Terlihat jelas bahwa pada semua tingkat rekursi, maxima dengan cepat bermigrasi ke kanan.  Kemudian maxima ini, di mana mereka diperlukan, dimatikan dari permainan: algoritma memanggil dirinya sendiri - tetapi tanpa elemen terakhir. <br><br>  Dalam semacam Stooge, sihir yang sama terjadi: <br><br><img width="672" height="454" src="https://habrastorage.org/webt/d-/pd/vj/d-pdvj8zcvmnlywcedlhkmhyfku.png"><br><br>  Bahkan, penekanan juga diberikan pada elemen maksimal.  Hanya Slow sort yang menggerakkan mereka ke ujung satu per satu, dan Stooge sort mendorong sepertiga elemen dari subarray (yang terbesar dari mereka) mendorong ke sepertiga paling kanan dari ruang sel. <br><br>  Kami beralih ke algoritma, di mana semuanya sudah cukup jelas. <br><br><h1>  Sortir Bodoh :: Sortir bodoh </h1><br><img width="336" height="109" src="https://habrastorage.org/webt/sz/i3/hh/szi3hhaimi67d84kjaivphl4a9q.gif"><br><br>  Penyortiran sangat hati-hati.  Ia pergi dari awal array ke akhir dan membandingkan elemen tetangga.  Jika dua elemen tetangga harus dipertukarkan, maka, untuk berjaga-jaga, menyortir kembali ke awal array dan mulai dari awal lagi. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stupid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; data[i]: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: i += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Gnome sort :: Gnome sort </h1><br><img width="570" height="95" src="https://habrastorage.org/web/2af/c2a/b73/2afc2ab738d54ca1b65a0bbcac9eaa19.gif"><br><br>  Hampir hal yang sama, tetapi menyortir selama pertukaran tidak kembali ke awal array, tetapi hanya mengambil satu langkah mundur.  Ternyata, ini sudah cukup untuk menyelesaikan semuanya. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gnome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= data[i]: i += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: i -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h3>  Sortir Kurcaci yang Dioptimalkan </h3><br><img width="570" height="95" src="https://habrastorage.org/web/37c/91c/9fc/37c91c9fcffd4b1a9d1f225171bbdc64.gif"><br><br>  Tetapi Anda dapat menghemat tidak hanya pada retret, tetapi juga saat bergerak maju.  Dengan beberapa pertukaran berturut-turut, Anda harus mengambil langkah mundur sebanyak mungkin.  Dan kemudian Anda harus kembali (membandingkan sepanjang jalan elemen yang sudah dipesan relatif satu sama lain).  Jika Anda ingat posisi dari mana pertukaran dimulai, maka Anda dapat langsung melompat ke posisi ini ketika pertukaran selesai. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gnome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, j, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= data[i]: i, j = j, j + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] i -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span>: i, j = j, j + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Bubble Sort :: Bubble sort </h1><br><img width="570" height="95" src="https://habrastorage.org/web/b68/67d/5b7/b6867d5b7d064421b5f7b1f6fae6d058.gif"><br><br>  Tidak seperti penyortiran bodoh dan gnomeish, ketika bertukar elemen dalam gelembung, tidak ada pengembalian terjadi - itu terus bergerak maju.  Mencapai akhir, elemen terbesar dari array dipindahkan ke bagian paling akhir. <br><br>  Kemudian proses penyortiran mengulangi seluruh proses lagi, sebagai hasilnya elemen kedua dalam senioritas berada di tempat terakhir tetapi satu.  Pada iterasi berikutnya, elemen terbesar ketiga adalah elemen ketiga dari akhir, dll. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bubble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> changed = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> changed: changed = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] changed = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h3>  Sortir Bubble yang Dioptimalkan </h3><br><img width="570" height="95" src="https://habrastorage.org/web/ca0/9e7/20f/ca09e720f56c417bbbb8204aa8c35a7d.gif"><br><br>  Anda bisa mendapat sedikit manfaat di gang-gang di awal array.  Dalam prosesnya, elemen pertama dipesan sementara untuk relatif satu sama lain (bagian yang diurutkan ini terus-menerus berubah ukuran - berkurang, meningkat).  Ini mudah diperbaiki dan dengan iterasi baru Anda cukup melompati sekelompok elemen tersebut. <br>  <sub><em>(Saya akan menambahkan implementasi yang diuji dengan Python di sini sebentar lagi. Saya tidak punya waktu untuk mempersiapkannya.)</em></sub> <br><br><br><h1>  Shaker Sort :: Shaker Sort <br>  (Sortir koktail :: Semacam koktail) </h1><br><img width="570" height="95" src="https://habrastorage.org/web/616/739/0f8/6167390f8005452e8dbcbeeacb5c95fc.gif"><br><br>  Semacam gelembung.  Pada operan pertama, seperti biasa - dorong maksimal ke ujung.  Lalu kami dengan tajam berbalik dan mendorong minimum ke awal.  Area marginal yang disortir dari array bertambah besar setelah setiap iterasi. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shaker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> up = range(len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> indices <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (up, reversed(up)): swapped = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> indices: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] swapped = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> swapped: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Sorting ganjil :: Ganjil genap </h1><br><img width="570" height="95" src="https://habrastorage.org/webt/yn/9t/oy/yn9toy8yjzuud4azxdffcb-6mwm.gif"><br><br>  Lagi iterasi atas perbandingan berpasangan dari elemen tetangga ketika bergerak dari kiri ke kanan.  Hanya pertama, bandingkan pasangan di mana elemen pertama aneh dalam penghitungan, dan yang kedua adalah genap (yaitu, yang pertama dan kedua, ketiga dan keempat, kelima dan keenam, dll).  Dan sebaliknya - bahkan + ganjil (kedua dan ketiga, keempat dan kelima, keenam dan ketujuh, dll.).  Dalam hal ini, banyak elemen besar array pada satu iterasi pada saat yang sama mengambil satu langkah maju (dalam gelembung, yang terbesar untuk iterasi mencapai akhir, tetapi sisanya yang agak besar hampir tetap di tempatnya). <br><br>  By the way, ini awalnya semacam paralel dengan kompleksitas O (n).  Penting untuk mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AlgoLab</a> di bagian "Penyortiran Paralel". <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">odd_even</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> n = len(data) isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> isSorted == <span class="hljs-number"><span class="hljs-number">0</span></span>: isSorted = <span class="hljs-number"><span class="hljs-number">1</span></span> temp = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Comb Sort :: Comb sort </h1><br><img width="570" height="95" src="https://habrastorage.org/web/52f/41b/2fb/52f41b2fbd024cf8b9dfdba8d0dbd239.gif"><br><br>  Modifikasi gelembung paling sukses.  Algoritma kecepatan bersaing dengan pengurutan cepat. <br><br>  Di semua variasi sebelumnya, kami membandingkan tetangga.  Dan di sini, pertama, pasangan elemen dianggap berada pada jarak maksimum satu sama lain.  Pada setiap iterasi baru, jarak ini menyempit secara seragam. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> gap = len(data) swaps = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> gap &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swaps: gap = max(<span class="hljs-number"><span class="hljs-number">1</span></span>, int(gap / <span class="hljs-number"><span class="hljs-number">1.25</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># minimum gap is 1 swaps = False for i in range(len(data) - gap): j = i + gap if data[i] &gt; data[j]: data[i], data[j] = data[j], data[i] swaps = True return data</span></span></code> </pre> <br><br><h1>  Sortir cepat :: Sortir cepat </h1><br><img width="684" height="95" src="https://habrastorage.org/webt/b1/xb/ve/b1xbvefydxsfynp91mnxaxluvfe.gif"><br><br>  Nah, algoritma pertukaran paling canggih. <br><br><ol><li>  Bagilah array menjadi dua.  Elemen tengah adalah referensi. </li><li>  Kami bergerak dari tepi kiri array ke kanan, sampai kami menemukan elemen yang lebih besar dari yang referensi. </li><li>  Kami bergerak dari tepi kanan array ke kiri hingga kami menemukan elemen yang lebih kecil dari yang referensi. </li><li>  Kami menukar dua elemen yang ditemukan di poin 2 dan 3. </li><li>  Kami terus melakukan item 2-3-4 hingga pertemuan terjadi sebagai akibat dari gerakan timbal balik. </li><li>  Pada titik pertemuan, array dibagi menjadi dua bagian.  Untuk setiap bagian, kami menerapkan algoritma pengurutan cepat secara rekursif. </li></ol><br>  Mengapa ini berhasil?  Di sebelah kiri titik pertemuan adalah elemen yang lebih kecil atau sama dengan yang referensi.  Di sebelah kanan titik pertemuan adalah elemen yang lebih besar atau sama dengan referensi.  Artinya, setiap elemen dari sisi kiri kurang dari atau sama dengan elemen apa pun dari sisi kanan.  Oleh karena itu, pada titik pertemuan, array dapat dengan aman dibagi menjadi dua subarrays dan mengurutkan masing-masing subarray dengan cara yang serupa secara rekursif. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> less = [] pivotList = [] more = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(data) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pivot = data[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &lt; pivot: less.append(i) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> i &gt; pivot: more.append(i) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pivotList.append(i) less = quick(less) more = quick(more) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> less + pivotList + more</code> </pre> <br><br><h1>  K-sort :: K-sort </h1><br>  Pada HabrÃ©, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan dari</a> salah satu artikel diterbitkan, yang melaporkan tentang modifikasi QuickSort, yang mengungguli pengurutan piramida oleh 7 juta elemen.  Ngomong-ngomong, ini sendiri merupakan pencapaian yang meragukan, karena penyortiran piramida klasik tidak memecahkan rekor kinerja.  Secara khusus, kompleksitas asimptotiknya dalam keadaan apa pun tidak mencapai O (n) (fitur dari algoritma ini). <br><br>  Tetapi masalahnya berbeda.  Menurut pseudo-code penulis (dan jelas salah), umumnya tidak mungkin untuk memahami apa, sebenarnya, ide utama dari algoritma.  Secara pribadi, saya mendapat kesan bahwa penulis adalah beberapa penjahat yang bertindak sesuai dengan metode ini: <br><ol><li>  Kami mendeklarasikan penemuan algoritma penyortiran super. </li><li>  Kami memperkuat pernyataan dengan pseudo-code yang tidak berfungsi dan tidak bisa dipahami (seperti, pintar dan sangat jelas, tetapi orang bodoh masih tidak bisa mengerti). </li><li>  Kami menyajikan grafik dan tabel yang seharusnya menunjukkan kecepatan praktis dari algoritma pada data besar.  Karena kurangnya kode yang benar-benar berfungsi, masih tidak ada yang dapat memverifikasi atau menyangkal perhitungan statistik ini. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Kami menerbitkan omong kosong</a> di Arxiv.org dengan kedok artikel ilmiah. </li><li>  KEUNTUNGAN !!! </li></ol><br>  Mungkin saya sedang berbicara dengan sia-sia kepada orang-orang dan pada kenyataannya algoritma ini bekerja?  Adakah yang bisa menjelaskan cara kerja k-sort? <br><br>  <strong>UPD</strong>  <strong>Tuduhan menyapu saya tentang penulis penipuan ternyata tidak dapat dipertahankan :) Pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">jetsys</a> menemukan pseudo-code dari algoritma, menulis versi yang berfungsi dalam PHP dan mengirimkannya kepada saya dalam pesan pribadi:</strong> <br><br><div class="spoiler">  <b class="spoiler_title">K-sort dalam PHP</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_ksort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$a,$left,$right)</span></span></span></span>{ $ke=$a[$left]; $i=$left; $j=$right+<span class="hljs-number"><span class="hljs-number">1</span></span>; $k=$p=$left+<span class="hljs-number"><span class="hljs-number">1</span></span>; $temp=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>($j-$i&gt;=<span class="hljs-number"><span class="hljs-number">2</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($ke&lt;=$a[$p]){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(($p!=$j) &amp;&amp; ($j!=($right+<span class="hljs-number"><span class="hljs-number">1</span></span>))){ $a[$j]=$a[$p]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($j==($right+<span class="hljs-number"><span class="hljs-number">1</span></span>)){ $temp=$a[$p]; } $j--; $p=$j; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $a[$i]=$a[$p]; $i++; $k++; $p=$k; } } $a[$i]=$ke; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($temp) $a[$i+<span class="hljs-number"><span class="hljs-number">1</span></span>]=$temp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($left&lt;($i<span class="hljs-number"><span class="hljs-number">-1</span></span>)) _ksort($a,$left,$i<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($right&gt;($i+<span class="hljs-number"><span class="hljs-number">1</span></span>)) _ksort($a,$i+<span class="hljs-number"><span class="hljs-number">1</span></span>,$right); }</code> </pre> </div></div><br><br><h2>  Pengumuman </h2><br>  Itu semua teori, saatnya beralih ke latihan.  Artikel selanjutnya adalah pengujian pertukaran sortir pada set data yang berbeda.  Kami akan mencari tahu: <br><br><ul><li>  Penyortiran apa yang terburuk - konyol, membosankan, atau membosankan? </li><li>  Apakah optimisasi dan modifikasi pada bubble sorting sangat membantu? </li><li>  Dalam kondisi apa algoritma lambat dengan cepat dalam kecepatan QuickSort? </li></ul><br><br>  Dan ketika kita menemukan jawaban untuk pertanyaan-pertanyaan paling penting ini, kita dapat mulai mempelajari kelas berikutnya - jenis sisipan. <br><br><h1>  Referensi </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi-Excel</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AlgoLab</a> , yang dengannya Anda dapat selangkah demi selangkah melihat visualisasi dari jenis-jenis ini (dan bukan hanya ini). <br><br>  <b>Wiki</b> - <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Silly</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Stooge</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Lambat</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Kerdil</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Gnome</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Gelembung</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Gelembung</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Pengocok</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Pengocok</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Ganjil</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Genap</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Sisir</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Sisir</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Cepat</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Cepat</a></nobr> <br><br><h3>  Artikel Seri </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi Excel AlgoLab.xlsm</a> </li><li>  <b>Pertukaran macam</b> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perbandingan Penukaran Exchange</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Urutan Penyisipan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sortir berdasarkan pilihan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gabungkan Urusan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Urutkan berdasarkan distribusi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sortasi Hibrid</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414653/">https://habr.com/ru/post/id414653/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414639/index.html">Layanan peretas di Internet gelap</a></li>
<li><a href="../id414641/index.html">Menjinakkan XBRL: Catatan Analis</a></li>
<li><a href="../id414643/index.html">Pengodean toko: pemenang M.SMART hackathon</a></li>
<li><a href="../id414645/index.html">ONETRAK - gelang pintar dan banyak lagi</a></li>
<li><a href="../id414651/index.html">Pemindai 3D Shining 3D Einscan SE. Ikhtisar pemindai 3D</a></li>
<li><a href="../id414655/index.html">Router virtual DD-WRT x86 pada VirtualBox</a></li>
<li><a href="../id414657/index.html">Protokol AMF3 Berbahaya</a></li>
<li><a href="../id414661/index.html">Kendaraan peluncuran Soyuz-5SL akan bekerja dengan mesin bergaya Soviet</a></li>
<li><a href="../id414663/index.html">Kelelahan profesional: sepatah kata untuk para ahli</a></li>
<li><a href="../id414667/index.html">[Mini fan theme] Tabel kejuaraan FIFA di terminal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>