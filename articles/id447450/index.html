<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🏭 🎷 👍🏽 Memecah "celah" sederhana dengan Ghidra - Bagian 1 🔊 🧕 🤾🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak orang mungkin sudah tahu secara langsung jenis binatang apa ini - Ghidra ("Hydra") dan apa yang dimakan program tersebut secara langsung, meski...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memecah "celah" sederhana dengan Ghidra - Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447450/">  Banyak orang mungkin sudah tahu secara langsung jenis binatang apa ini - <b>Ghidra</b> ("Hydra") dan apa yang dimakan program tersebut secara langsung, meskipun alat ini tersedia untuk umum baru-baru ini - pada bulan Maret tahun ini.  Saya tidak akan mengganggu pembaca dengan deskripsi Hydra, fungsinya, dll.  Mereka yang berada dalam topik, saya yakin, telah mempelajari semua ini sendiri, dan mereka yang belum dalam topik - mereka dapat melakukannya kapan saja, karena sekarang mudah untuk menemukan informasi terperinci di Internet.  Ngomong-ngomong, salah satu aspek Hydra (pengembangan plugin untuk itu) telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibahas</a> di Habré (artikel bagus!) Saya hanya akan memberikan tautan utama: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halaman resmi di situs web NSA</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek Github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ulasan pertama di Majalah Hacker</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saluran YouTube yang luar biasa dengan program parsing di Ghidra</a> </li></ul><br>  Jadi, Hydra adalah <em>disassembler interaktif dan platform bebas dekompiler bebas dengan struktur modular, dengan dukungan untuk hampir semua arsitektur CPU utama dan antarmuka grafis yang fleksibel untuk bekerja dengan kode yang dibongkar, memori, kode yang dipulihkan (didekompilasi), simbol debugging, dan banyak lagi</em> . <br><br>  Ayo coba hancurkan sesuatu dengan Hydra ini! <br><a name="habracut"></a><br><h2>  Langkah 1. Temukan dan pelajari celahnya </h2><br>  Sebagai "korban" kami menemukan program "crackme" sederhana.  Saya baru saja pergi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">crackmes.one</a> , yang ditunjukkan dalam pencarian tingkat kesulitan = 2-3 ("sederhana" dan "sedang"), bahasa sumber program = "C / C ++" dan platform = "Multiplatform", seperti pada tangkapan layar di bawah: <br><br><img src="https://habrastorage.org/webt/oz/hh/4w/ozhh4w-nraygltspefvjnyrvpjk.png"><br><br>  Pencarian menghasilkan 2 hasil (berwarna hijau di bawah).  Retakan pertama ternyata 16-bit dan tidak dimulai pada Win10 64-bit saya, tetapi yang kedua ( <b>level_2 oleh seveb</b> ) muncul.  Anda dapat mengunduhnya dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ini</a> . <br><br>  Unduh dan buka kemasannya;  Kata sandi untuk arsip, sebagaimana ditunjukkan di situs, adalah <b>crackmes.de</b> .  Dalam arsip kami menemukan dua direktori yang sesuai dengan Linux dan Windows.  Di komputer saya, saya pergi ke direktori Windows dan saya bertemu di dalamnya satu-satunya "executable" - <b>level_2.exe</b> .  Ayo lari dan lihat apa yang dia inginkan: <br><br><img src="https://habrastorage.org/webt/qx/mu/yj/qxmuyjfvnatrgoggnmet17egii8.png"><br><br>  Sepertinya gelandangan!  Saat startup, program tidak menampilkan apa pun.  Kami mencoba untuk menjalankannya lagi, memberikannya string yang berubah-ubah sebagai parameter (tiba-tiba, apakah itu menunggu kunci?) - dan sekali lagi tidak ada ... Tapi jangan putus asa.  Mari kita asumsikan bahwa kita juga harus mencari tahu parameter peluncuran sebagai tugas!  Sudah waktunya untuk mengungkap "pisau Swiss" kami - Hydra. <br><br><h2>  Langkah 2. Membuat proyek di Hydra dan analisis pendahuluan </h2><br>  Misalkan Anda sudah menginstal Hydra.  Jika belum, maka semuanya sederhana. <br><br><div class="spoiler">  <b class="spoiler_title">Instal Ghidra</b> <div class="spoiler_text">  1) instal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JDK</a> versi 11 atau lebih tinggi (saya punya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">12</a> ) <br><br>  2) unduh Hydra (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> ) dan instal (pada saat penulisan, versi terbaru Hydra adalah 9.0.2, saya punya 9.0.1) <br></div></div><br>  Kami meluncurkan Hydra dan dalam Project Manager yang terbuka segera membuat proyek baru;  Saya memberinya nama <b>crackme3</b> (mis., Proyek crackme dan crackme2 telah dibuat untuk saya).  Proyek ini, pada kenyataannya, adalah direktori file, Anda dapat menambahkan file apa saja untuk dipelajari (exe, dll, dll.).  Kami akan segera menambahkan level_2.exe kami ( <b>File | Impor</b> atau hanya kunci <b>I</b> ): <br><br><img src="https://habrastorage.org/webt/sb/gl/_e/sbgl_e0acdolgbxtvjnuohiscua.png"><br><br>  Kami melihat bahwa, sebelum mengimpor, Hydra mengidentifikasi dukun eksperimental kami sebagai PE 32-bit (dapat dieksekusi portabel) untuk OS Win32 dan platform x86.  Setelah impor, kami menunggu lebih banyak informasi: <br><br><img src="https://habrastorage.org/webt/zb/v0/ga/zbv0gatojwqtmbdejhe6zclenac.png"><br><br>  Di sini, selain kedalaman bit yang disebutkan di atas, kita mungkin masih tertarik dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">urutan endianness</a> , yang dalam kasus kami adalah <b>Little</b> (dari byte rendah ke tinggi), yang diharapkan untuk platform Intel 86. <br><br>  Dengan analisis pendahuluan, kita selesai. <br><br><h2>  Langkah 3. Lakukan analisis otomatis </h2><br>  Saatnya memulai analisis otomatis penuh dari program di Hydra.  Ini dilakukan dengan mengklik dua kali pada file yang sesuai (level_2.exe).  Memiliki struktur modular, Hydra menyediakan semua fungsi dasarnya dengan sistem plug-in yang dapat ditambahkan / dinonaktifkan atau dikembangkan secara mandiri.  Sama halnya dengan analisis - setiap plugin bertanggung jawab untuk jenis analisisnya.  Karena itu, pertama, kita dihadapkan dengan jendela ini di mana Anda dapat memilih jenis analisis yang menarik: <br><br><div class="spoiler">  <b class="spoiler_title">Jendela Pengaturan Analisis</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/p2/aw/sa/p2awsa9slwl8tkbjo0mtcbkgnh8.png"></div></div><br>  Untuk tujuan kami, masuk akal untuk meninggalkan pengaturan default dan menjalankan analisis.  Analisis itu sendiri dilakukan dengan sangat cepat (saya butuh sekitar 7 detik), meskipun pengguna di forum mengeluh bahwa untuk proyek-proyek besar, Hydra kehilangan kecepatan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IDA Pro</a> .  Ini mungkin benar, tetapi untuk file kecil perbedaan ini tidak signifikan. <br><br>  Jadi, analisisnya lengkap.  Hasilnya ditampilkan di jendela Code Browser: <br><br><img src="https://habrastorage.org/webt/lh/dy/e5/lhdye5faqmse8w2evahggln5bge.png"><br><br>  Jendela ini adalah yang utama untuk bekerja di Hydra, jadi Anda harus mempelajarinya lebih hati-hati. <br><br><div class="spoiler">  <b class="spoiler_title">Ikhtisar Kode Antarmuka Browser</b> <div class="spoiler_text">  Pengaturan antarmuka default membagi jendela menjadi tiga bagian. <br><br>  Di bagian <b>tengah</b> adalah jendela utama - daftar disassembler, yang kurang lebih mirip dengan "saudara" di IDA, OllyDbg, dll.  Secara default, kolom dalam daftar ini adalah (dari kiri ke kanan): alamat memori, opcode perintah, perintah ASM, parameter perintah ASM, referensi silang (jika berlaku).  Secara alami, tampilan dapat diubah dengan mengklik tombol dalam bentuk dinding bata di bilah alat jendela ini.  Sejujurnya, saya belum pernah melihat konfigurasi yang fleksibel dari output disassembler di mana pun, itu sangat nyaman. <br><br>  Di bagian <b>kiri dari</b> 3 panel: <br><br><ol><li>  Bagian dari program (klik pada mouse untuk menelusuri bagian-bagian) </li><li>  Pohon karakter (impor, ekspor, fungsi, header, dll.) </li><li>  Ketik pohon variabel yang digunakan </li></ol><br>  Bagi kami, jendela paling berguna di sini adalah pohon simbol, yang memungkinkan Anda untuk dengan cepat menemukan, misalnya fungsi dengan namanya dan pergi ke alamat yang sesuai. <br><br>  Di sebelah <b>kanan</b> adalah daftar kode yang didekompilasi (dalam kasus kami, dalam C). <br><br>  Selain jendela default, di menu <b>Window</b> Anda dapat memilih dan menempatkan puluhan jendela lain dan menampilkan di mana saja di browser.  Untuk kenyamanan, saya menambahkan jendela Bytes dan jendela dengan Function Graph ke tengah, dan ke kanan, variabel string (Strings) dan tabel fungsi (Functions).  Jendela ini sekarang tersedia di tab terpisah.  Juga, setiap jendela dapat dilepas dan dibuat "mengambang", menempatkan dan mengubah ukurannya sesuai kebijaksanaan Anda - ini juga merupakan solusi yang sangat bijaksana, menurut saya,. <br></div></div><br><h2>  Langkah 4. Mempelajari algoritma program - fungsi utama () </h2><br>  Baiklah, mari kita lanjutkan ke analisis langsung dari program crack kita.  Dalam kebanyakan kasus, Anda harus mulai dengan mencari titik masuk program, yaitu  Fungsi utama yang dipanggil saat itu dimulai.  Mengetahui bahwa crack kami ditulis dalam C / C ++, kami menduga bahwa nama fungsi utama akan menjadi <b>main ()</b> atau sesuatu seperti itu :) Dikatakan dan dilakukan.  Masukkan "main" di filter Tree of Symbols (di panel kiri) dan lihat fungsi <b>_main ()</b> di bagian <b>Functions</b> .  Pergi ke sana dengan klik mouse. <br><br><h3>  Tinjauan umum fungsi utama () dan penggantian nama fungsi tidak jelas </h3><br>  Dalam daftar disassembler, bagian kode yang sesuai segera ditampilkan, dan di sebelah kanan kita melihat kode-C yang didekompilasi dari fungsi ini.  Perlu diperhatikan satu lagi fitur sinkronisasi Hydra-selection yang nyaman: ketika mouse memilih serangkaian perintah ASM, bagian kode yang sesuai dalam dekompiler disorot dan sebaliknya.  Selain itu, jika jendela melihat memori terbuka, alokasi disinkronkan dengan memori.  Seperti yang mereka katakan, semua cerdik itu sederhana! <br><br>  Segera, saya perhatikan fitur penting bekerja di Hydra (sebagai lawan dari, katakanlah, bekerja di IDA).  <em>Pekerjaan di Hydra terutama difokuskan pada analisis kode yang didekompilasi</em> .  Untuk alasan ini, pencipta Hydra (kita ingat - kita berbicara tentang mata-mata dari NSA :)) menaruh perhatian besar pada kualitas dekompilasi dan kenyamanan bekerja dengan kode.  Secara khusus, seseorang dapat dengan mudah mendefinisikan fungsi, variabel, dan bagian memori dengan hanya mengklik dua kali pada kode.  Juga, variabel dan fungsi apa pun dapat segera diganti namanya, yang sangat nyaman, karena nama default tidak memiliki makna dan dapat membingungkan.  Seperti yang akan Anda lihat nanti, kita akan sering menggunakan mekanisme ini. <br><br>  Jadi, inilah fungsi <b>utama ()</b> , yang Hydra “membedah” sebagai berikut: <br><br><div class="spoiler">  <b class="spoiler_title">Daftar utama ()</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __cdecl _main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _Argc,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **_Argv,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **_Env) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bVar1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVar2; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *_Dest; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sVar3; FILE *_File; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **ppcVar4; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_18; ___main(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_Argc == <span class="hljs-number"><span class="hljs-number">3</span></span>) { bVar1 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _Dest = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)_text(<span class="hljs-number"><span class="hljs-number">0x100</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); local_18 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (local_18 &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bVar1) { _text(_Dest,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0x100</span></span>); _text(_Dest,_Argv[local_18],<span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } sVar3 = _text(_Argv[local_18]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((sVar3 == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*_Argv[local_18] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x2d</span></span>)) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_Argv[local_18][<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x66</span></span>)) { bVar1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } local_18 = local_18 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bVar1) &amp;&amp; (*_Dest != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { _File = _text(_Dest,<span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_File == (FILE *)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { _text(<span class="hljs-string"><span class="hljs-string">"Failed to open file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } ppcVar4 = _construct_key(_File); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ppcVar4 == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { _text(<span class="hljs-string"><span class="hljs-string">"Nope."</span></span>); _free_key((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _text(<span class="hljs-string"><span class="hljs-string">"%s%s%s%s\n"</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x10d</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x219</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x325</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x431</span></span>); _free_key(ppcVar4); } _text(_File); } _text(_Dest); iVar2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { iVar2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iVar2; }</code> </pre> <br></div></div><br>  Tampaknya semuanya tampak normal - definisi variabel, tipe-C standar, kondisi, loop, pemanggilan fungsi.  Tetapi melihat lebih dekat pada kode, kita perhatikan bahwa untuk beberapa alasan nama-nama dari beberapa fungsi tidak didefinisikan dan diganti oleh pseudo- <b>function _text ()</b> (di jendela decompiler - <b>.text ()</b> ).  Mari kita mulai dengan mendefinisikan apa fungsi-fungsi ini. <br><br>  Mengklik dua kali pada badan panggilan pertama <br><br><pre> <code class="cpp hljs"> _Dest = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)_text(<span class="hljs-number"><span class="hljs-number">0x100</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  kita melihat bahwa ini hanyalah fungsi pembungkus di sekitar fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">calloc ()</a> standar, yang digunakan untuk mengalokasikan memori untuk data.  Jadi mari kita ganti nama fungsi ini menjadi <b>calloc2 ()</b> .  Mengatur kursor pada header fungsi, panggil menu konteks dan pilih <b>Ubah nama fungsi</b> (tombol panas - <b>L</b> ) dan masukkan nama baru di bidang yang terbuka: <br><br><img src="https://habrastorage.org/webt/nz/q1/3z/nzq13zx8ddn0vsbvni8mkpencyc.png"><br><br>  Kami melihat bahwa fungsi itu segera diganti namanya.  Kita kembali ke badan <b>() utama (</b> tombol <b>Kembali</b> di bilah alat atau <b>Alt + &lt;-</b> ) dan kita melihat bahwa di sini alih-alih <b>_text () calloc2 ()</b> yang misterius sudah berdiri.  Hebat! <br><br>  Kami melakukan hal yang sama dengan semua fungsi pembungkus lainnya: kita masuk ke definisi mereka satu per satu, melihat apa yang mereka lakukan, mengganti nama (saya menambahkan indeks 2 ke nama standar fungsi-C) dan kembali ke fungsi utama. <br><br><h3>  Kami memahami kode fungsi utama () </h3><br>  Oke, kami menemukan beberapa fungsi aneh.  Kami mulai mempelajari kode fungsi utama.  Melewati deklarasi variabel, kita melihat bahwa fungsi mengembalikan nilai variabel iVar2, yaitu nol (tanda keberhasilan fungsi) hanya jika kondisi yang ditentukan oleh string terpenuhi <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_Argc == <span class="hljs-number"><span class="hljs-number">3</span></span>) { ... }</code> </pre><br>  <b>_Argc</b> adalah jumlah parameter baris perintah (argumen) yang diteruskan ke <b>main ()</b> .  Yaitu, program kami “makan” 2 argumen (argumen pertama, kita ingat, selalu merupakan jalur ke file yang dapat dieksekusi). <br><br>  Oke, mari kita lanjutkan.  Di sini kita membuat C-string ( <b>char</b> array) 256 karakter: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *_Dest; _Dest = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)calloc2(<span class="hljs-number"><span class="hljs-number">0x100</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  new char[256]  C++</span></span></code> </pre><br>  Selanjutnya kita memiliki loop 3 iterasi.  Di dalamnya, pertama-tama kita memeriksa apakah flag <b>bVar1 diatur,</b> dan jika demikian, salin argumen baris perintah berikut (string) ke <b>_Dest</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*    .  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bVar1) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> memset2(_Dest,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*    _Dest    */</span></span> strncpy2(_Dest,_Argv[i],<span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ... }</code> </pre><br>  Bendera ini disetel saat menguraikan argumen berikut: <br><br><pre> <code class="cpp hljs">n_strlen = strlen2(_Argv[i]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((n_strlen == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*_Argv[i] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x2d</span></span>)) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_Argv[i][<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x66</span></span>)) { bVar1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Baris pertama menghitung panjang argumen ini.  Lebih lanjut, kondisi memeriksa bahwa panjang argumen harus 2, karakter kedua dari belakang == "-" dan karakter terakhir == "f".  Perhatikan bagaimana dekompiler "menerjemahkan" ekstraksi karakter dari string menggunakan topeng byte. <br><blockquote>  Nilai angka desimal, dan pada saat yang sama karakter ASCII yang sesuai, dapat dimata-matai dengan menahan kursor di atas heksadesimal heksadesimal yang sesuai.  Pemetaan ASCII tidak selalu berhasil (?), Jadi saya sarankan melihat tabel ASCII di Internet.  Anda juga dapat secara langsung dalam Hydra mengonversi skalar dari sistem bilangan apa pun ke sistem bilangan lainnya (melalui menu konteks -&gt; <b>Konversi</b> ), dalam hal ini nomor ini akan ditampilkan di mana-mana dalam sistem bilangan yang dipilih (dalam disassembler dan dalam dekompiler);  tetapi secara pribadi, saya lebih suka meninggalkan hexes dalam kode untuk harmoni kerja, karena  alamat memori, offset, dll.  heks ditetapkan di mana-mana. <br></blockquote>  Setelah loop muncul kode ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bVar1) &amp;&amp; (*_Dest != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">/*    1) "-f"  2)  -         */</span></span> _File = fopen2(_Dest,<span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_File == (FILE *)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  1    */</span></span> perror2(<span class="hljs-string"><span class="hljs-string">"Failed to open file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } ... }</code> </pre><br>  Di sini saya langsung menambahkan komentar.  Kami memeriksa kebenaran argumen ("-f path_to_file") dan membuka file yang sesuai (argumen ke-2 berlalu, yang kami salin ke _Dest).  File akan dibaca dalam format biner, seperti yang ditunjukkan oleh parameter "rb" pada fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fopen ()</a> .  Jika pembacaan gagal (misalnya, file tidak tersedia), pesan kesalahan ditampilkan dalam aliran stderror dan program keluar dengan kode 1. <br><br>  Berikutnya adalah yang paling menarik: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* !!!     !!! */</span></span> ppcVar3 = _construct_key(_File); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ppcVar3 == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*    ,  "Nope" */</span></span> puts2(<span class="hljs-string"><span class="hljs-string">"Nope."</span></span>); _free_key((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*    -      */</span></span> printf2(<span class="hljs-string"><span class="hljs-string">"%s%s%s%s\n"</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x10d</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x219</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x325</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x431</span></span>); _free_key(ppcVar3); } fclose2(_File);</code> </pre><br>  Deskriptor file terbuka ( <b>_File</b> ) diteruskan ke fungsi <b>_construct_key ()</b> , yang, jelas, melakukan verifikasi kunci yang dicari.  Fungsi ini mengembalikan array byte dua dimensi ( <b>char **</b> ), yang disimpan dalam variabel <b>ppcVar3</b> .  Jika array kosong, "Tidak" singkat ditampilkan pada konsol (yaitu, menurut pendapat kami, "Tidak!") Dan memori dibebaskan.  Kalau tidak (jika array tidak kosong), kunci yang tampaknya benar ditampilkan dan memori juga dibebaskan.  Di akhir fungsi, deskriptor file ditutup, memori dibebaskan, dan nilai <b>iVar2 dikembalikan</b> . <br><br>  Jadi, sekarang kami menyadari bahwa kami membutuhkan: <br><br>  <i>1) membuat file biner dengan kunci yang benar;</i> <i><br></i>  <i>2) melewati jalannya di celah setelah argumen "-f"</i> <br><br>  Di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua artikel,</a> kami akan menganalisis fungsi <b>_construct_key ()</b> , yang, seperti yang kami <b>ketahui</b> , bertanggung jawab untuk memeriksa kunci yang diinginkan dalam file. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447450/">https://habr.com/ru/post/id447450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447438/index.html">Tes unittest dan abstrak</a></li>
<li><a href="../id447440/index.html">RBKmoney Pembayaran di bawah tenda - logika platform pembayaran</a></li>
<li><a href="../id447442/index.html">Memperkenalkan shell-operator: membuat operator untuk Kubernet lebih mudah</a></li>
<li><a href="../id447446/index.html">Lokakarya IBM: musim semi-musim panas 2019 - kecerdasan buatan, pengembangan cloud, chat bot, blockchain dan teknologi lainnya</a></li>
<li><a href="../id447448/index.html">Evolusi Kecerdasan: Awal</a></li>
<li><a href="../id447452/index.html">Keamanan Rantai Pasokan: "Seandainya saya Negara Bangsa ..."</a></li>
<li><a href="../id447454/index.html">Kontrol Tampilan Tujuh Segmen FPGA</a></li>
<li><a href="../id447456/index.html">Seberapa akurat Yandex memprediksi curah hujan di musim dingin? Kami menganalisis keakuratan layanan prediksi</a></li>
<li><a href="../id447458/index.html">Bagaimana kata-kata baru dibuat dalam bahasa Inggris modern</a></li>
<li><a href="../id447460/index.html">Retas Vacuum Cleaner XiaoMi Anda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>