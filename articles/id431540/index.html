<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜­ ğŸ˜† ğŸ˜¾ Paket dan manajer paket untuk k8s ğŸ’¾ ğŸ¤² ğŸ‘„</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kita semua menggunakan beberapa jenis manajer paket, termasuk wanita pembersih Bibi Galya, yang memiliki iPhone di sakunya sekarang diperbarui. Tetapi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Paket dan manajer paket untuk k8s</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/431540/">  Kita semua menggunakan beberapa jenis manajer paket, termasuk wanita pembersih Bibi Galya, yang memiliki iPhone di sakunya sekarang diperbarui.  Tetapi tidak ada kesepakatan umum tentang fungsi manajer paket, dan rpm standar dan OS dpkg dan sistem bangun disebut manajer paket.  Kami menawarkan untuk merefleksikan topik fungsi mereka - apa itu dan mengapa mereka dibutuhkan di dunia modern.  Dan kemudian kita akan menggali ke arah Kubernetes dan dengan hati-hati mempertimbangkan Helm dalam hal fungsi-fungsi ini. <br><img src="https://habrastorage.org/webt/xs/mf/h5/xsmfh5898yrlawroqge2dn6v_iw.png"><br><br>  Kami akan memahami mengapa dalam diagram ini hanya fungsi template yang disorot dalam warna hijau, dan apa masalah dengan perakitan dan pengemasan, otomatisasi lingkungan, dan banyak lagi.  Tapi jangan khawatir, artikel itu tidak berakhir dengan fakta bahwa semuanya buruk.  Komunitas tidak bisa menerima ini dan menawarkan alat dan solusi alternatif - kami akan menanganinya. <br><br>  <b>Ivan Glushkov</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">gli</a> ) membantu kami dengan ini dengan laporannya tentang RIT ++, versi video dan teks dari presentasi terperinci dan terperinci di bawah ini. <br><br><blockquote>  Video tentang hal ini dan pidato DevOps lainnya di RIT ++ dipublikasikan dan terbuka untuk ditonton secara gratis di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran youtube</a> kami - cari jawaban atas pertanyaan Anda yang sedang dikerjakan. <br></blockquote><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/V_DGgD7ihsQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara:</strong> Ivan Glushkov telah mengembangkan perangkat lunak selama 15 tahun.  Saya berhasil bekerja di MZ, di Echo pada platform untuk komentar, berpartisipasi dalam pengembangan kompiler untuk prosesor Elbrus di MCST.  Dia saat ini terlibat dalam proyek infrastruktur di Postmates.  Ivan adalah salah satu podcast <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevZen</a> terkemuka di mana mereka berbicara tentang konferensi kami: di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> adalah tentang RIT ++, dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> tentang HighLoad ++. <br><br><h2>  Manajer paket <br></h2><br>  Meskipun semua orang menggunakan beberapa jenis manajer paket, tidak ada kesepakatan tunggal tentang apa itu.  Ada pemahaman bersama, dan masing-masing memiliki sendiri. <br><br>  Mari kita ingat jenis manajer paket apa yang pertama kali terlintas dalam pikiran: <br><br><ul><li>  Manajer paket standar dari semua sistem operasi: <strong>rpm, dpkg, portage</strong> , ... </li><li>  Manajer paket untuk berbagai bahasa pemrograman: <strong>kargo, komplotan rahasia, rebar3, mix</strong> , ... </li></ul><br>  Fungsi utamanya adalah untuk menjalankan perintah untuk menginstal paket, memperbarui paket, menghapus paket, dan mengelola dependensi.  Dalam manajer paket di dalam bahasa pemrograman, hal-hal sedikit lebih rumit.  Misalnya, ada perintah seperti "luncurkan paket" atau "buat rilis" (build / run / release).  Ternyata ini sudah merupakan sistem build, meskipun kami juga menyebutnya manajer paket. <br><img src="https://habrastorage.org/webt/ct/di/ni/ctdinidgmq8e-zcuksmz-cfym2y.png"><br><br>  Semua ini hanya karena Anda tidak bisa mengambilnya dan ... biarkan pecinta Haskell memaafkan perbandingan ini.  Anda dapat menjalankan file biner, tetapi Anda tidak dapat menjalankan program di Haskell atau C, pertama-tama Anda harus mempersiapkannya entah bagaimana.  Dan persiapan ini agak rumit, dan pengguna ingin semuanya dilakukan secara otomatis. <br><br><h3>  Pengembangan <br></h3><br>  Orang yang bekerja dengan GNU libtool, yang dibuat untuk proyek besar yang terdiri dari sejumlah besar komponen, tidak menertawakan sirkus.  Ini benar-benar sangat sulit, dan beberapa kasus pada prinsipnya tidak dapat diselesaikan, tetapi hanya dapat dielakkan. <br><br>  Dibandingkan dengan itu, manajer bahasa paket modern seperti kargo untuk Rust jauh lebih mudah - Anda menekan tombol dan semuanya berfungsi.  Meskipun pada kenyataannya, di bawah tenda, sejumlah besar masalah diselesaikan.  Selain itu, semua fungsi baru ini memerlukan sesuatu yang tambahan, khususnya, basis data.  Meskipun dalam paket manajer itu sendiri dapat disebut apa pun yang Anda suka, saya menyebutnya basis data, karena  data disimpan di sana: tentang paket yang diinstal, tentang versinya, repositori yang terhubung, versi dalam repositori ini.  Semua ini harus disimpan di suatu tempat, jadi ada basis data internal. <br><br>  Pengembangan dalam bahasa pemrograman ini, pengujian untuk bahasa pemrograman ini, diluncurkan - semua ini adalah built-in dan terletak di dalam, <strong>pekerjaan menjadi sangat nyaman</strong> .  Sebagian besar bahasa modern telah mendukung pendekatan ini.  Bahkan mereka yang tidak mendukung mulai mendukung, karena masyarakat menekan dan mengatakan bahwa di dunia modern tidak mungkin tanpa itu. <br><br>  <strong>Tetapi solusi apa pun selalu tidak hanya memiliki kelebihan, tetapi juga kelemahan</strong> .  Kelemahannya di sini adalah Anda membutuhkan pembungkus, utilitas tambahan, dan "basis data" bawaan. <br><br><h2>  Docker <br></h2><br><blockquote>  Apakah Anda pikir Docker adalah manajer paket atau tidak? <br></blockquote><br>  Tidak peduli bagaimana, tetapi pada dasarnya ya.  Saya tidak tahu utilitas yang lebih benar untuk benar-benar meletakkan aplikasi bersama dengan semua dependensi, dan membuatnya berfungsi dengan mengklik tombol.  Apa ini jika bukan manajer paket?  Ini adalah manajer paket yang hebat! <br><br>  Maxim Lapshin telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan</a> bahwa dengan Docker menjadi lebih mudah, dan memang begitu.  Docker memiliki sistem built-in build, semua database, binding, utilitas ini. <br><br>  Berapa harga semua manfaatnya?  Mereka yang bekerja dengan Docker tidak banyak memikirkan aplikasi industri.  Saya punya pengalaman seperti itu, dan harganya sebenarnya sangat tinggi: <br><br><ul><li>  <strong>Jumlah informasi</strong> (ukuran gambar) yang harus disimpan dalam gambar Docker.  Anda memerlukan semua dependensi, bagian dari utilitas, pustaka untuk dikemas di dalamnya, gambarnya besar dan Anda harus dapat bekerja dengannya. </li><li>  Jauh lebih rumit bahwa <strong>pergeseran paradigma</strong> sedang terjadi. </li></ul><br>  Misalnya, saya punya tugas untuk mentransfer satu program untuk menggunakan Docker.  Program ini dikembangkan selama bertahun-tahun oleh sebuah tim.  Saya datang, kami melakukan semua yang ditulis dalam buku: kami melukiskan kisah, peran, melihat apa yang dilakukan pengguna, rutinitas standar mereka. <br><br>  Saya katakan: <br><br>  - Docker dapat menyelesaikan semua masalah Anda.  Perhatikan bagaimana ini dilakukan. <br><br>  - Semuanya akan ada di tombol - hebat!  Tapi kami ingin SSH melakukan di dalam wadah Kubernetes. <br><br>  - Tunggu, tidak ada SSH di mana pun. <br><br>  - Ya, ya, semuanya baik-baik saja ... Tetapi apakah SSH mungkin? <br><br>  Untuk mengubah persepsi pengguna menjadi arah baru, dibutuhkan banyak waktu, dibutuhkan pekerjaan pendidikan dan banyak usaha. <br><br>  Faktor harga lainnya adalah bahwa <strong>Docker-registry</strong> adalah repositori eksternal untuk gambar, itu perlu diinstal dan dikendalikan entah bagaimana.  Ini memiliki masalah sendiri, pengumpul sampah dan sebagainya, dan itu sering bisa jatuh jika Anda tidak mengikutinya, tetapi ini semua diselesaikan. <br><br><h2>  Kubernetes <br></h2><br>  Akhirnya kami sampai di Kubernetes.  Ini adalah sistem manajemen aplikasi OpenSource keren yang secara aktif didukung oleh komunitas.  Meskipun awalnya meninggalkan satu perusahaan, Kubernetes sekarang memiliki komunitas yang besar, dan tidak mungkin untuk mengikutinya, praktis tidak ada alternatif. <br><br>  Menariknya, semua simpul Kubernetes bekerja di Kubernetes sendiri melalui wadah, dan semua aplikasi eksternal bekerja melalui wadah - <strong>semuanya bekerja melalui wadah</strong> !  Ini adalah plus dan minus. <br><br>  Kubernetes memiliki banyak fungsi dan properti yang berguna: distribusi, toleransi kesalahan, kemampuan untuk bekerja dengan berbagai layanan cloud, dan orientasi ke arah arsitektur layanan-mikro.  Semua ini menarik dan keren, tetapi bagaimana cara menginstal aplikasi di Kubernetes? <br><br><h3>  Bagaimana cara menginstal aplikasi? <br></h3><br><blockquote>  Instal gambar Docker di registri Docker. </blockquote><br>  Di belakang kalimat ini terletak jurang yang dalam.  Anda bayangkan - Anda memiliki aplikasi yang ditulis, misalnya, di Ruby, dan Anda harus meletakkan gambar Docker di registri Docker.  Ini berarti Anda harus: <br><br><ul><li>  Mempersiapkan gambar Docker </li><li>  memahami bagaimana perkembangannya, pada versi apa itu didasarkan; </li><li>  dapat mengujinya; </li><li>  kumpulkan, isi Docker-registry, yang Anda, omong-omong, instal sebelumnya. </li></ul><br>  Sebenarnya, ini adalah rasa sakit yang sangat besar dalam satu baris. <br><br>  Plus, Anda masih perlu menjelaskan manifes aplikasi dalam hal (sumber daya) k8s.  Opsi termudah: <br><br><ul><li>  jelaskan penyebaran + pod, layanan + masuknya (mungkin); </li><li>  jalankan kubectl terapkan perintah -f resources.yaml, dan transfer semua sumber daya ke perintah ini. </li></ul><br><img src="https://habrastorage.org/webt/o9/pj/8w/o9pj8wgukswoi3laskibnzkemg0.png"><br><br>  Gandhi menggosok-gosokkan tangannya pada slide - sepertinya aku menemukan manajer paket di Kubernetes.  Tapi kubectl bukan manajer paket.  Dia hanya mengatakan bahwa saya ingin melihat keadaan akhir dari sistem.  Ini bukan menginstal paket, tidak bekerja dengan dependensi, bukan membangun - itu hanya "Saya ingin melihat keadaan akhir ini." <br><br><h2>  Helm <br></h2><br>  Akhirnya kami sampai di Helm.  Helm adalah utilitas serba guna.  Sekarang kita akan mempertimbangkan bidang pengembangan Helm apa dan bekerja dengannya. <br><br><h3>  Mesin Templat <br></h3><br>  Pertama, Helm adalah mesin templat.  Kami membahas sumber daya apa yang perlu disiapkan, dan masalahnya adalah menulis dalam istilah Kubernetes (dan tidak hanya dalam yaml).  Yang paling menarik adalah ini adalah file statis untuk aplikasi spesifik Anda di lingkungan khusus ini. <br><br>  Namun, jika Anda bekerja dengan beberapa lingkungan dan Anda tidak hanya memiliki Produksi, tetapi juga Pementasan, Pengujian, Pengembangan, dan lingkungan yang berbeda untuk tim yang berbeda, Anda perlu memiliki beberapa manifes serupa.  Misalnya, karena di salah satu dari mereka ada beberapa server, dan Anda perlu memiliki sejumlah besar replika, dan yang lain - hanya satu replika.  Tidak ada database, akses ke RDS, dan Anda perlu menginstal PostgreSQL di dalamnya.  Dan di sini kita memiliki versi lama, dan kita perlu menulis ulang semuanya sedikit. <br><br>  Semua perbedaan ini mengarah pada kenyataan bahwa Anda harus membawa manifes Anda untuk Kubernetes, menyalinnya di mana-mana dan memperbaikinya di mana-mana: di sini ganti satu digit, di sini ada hal lain.  Ini menjadi sangat tidak nyaman. <br><br>  Solusinya sederhana - Anda harus <strong>memasukkan template</strong> .  Artinya, Anda membentuk manifes, menentukan variabel di dalamnya, dan kemudian mengirimkan variabel yang ditentukan secara eksternal sebagai file.  Template menciptakan manifes akhir.  Ternyata menggunakan kembali manifes yang sama untuk semua lingkungan, yang jauh lebih nyaman. <br><br>  Misalnya, manifes untuk Helm. <br><img src="https://habrastorage.org/webt/ls/ys/ms/lsysmsc7kcnrm1vl8epif7ooowu.png"><br><br><ul><li>  Bagian terpenting dalam Helm adalah <strong>Chart.yaml</strong> , yang menjelaskan jenis manifes apa, versi apa, cara kerjanya. </li><li>  <strong>templat</strong> hanyalah templat sumber daya Kubernet yang berisi beberapa jenis variabel di dalamnya.  Variabel-variabel ini harus didefinisikan dalam file eksternal atau pada baris perintah, tetapi selalu eksternal. </li><li>  <strong>values.yaml</strong> adalah nama standar untuk file dengan variabel untuk template ini. </li></ul><br>  Perintah startup paling sederhana untuk menginstal grafik adalah menginstal helm ./wordpress (folder).  Untuk mendefinisikan kembali beberapa parameter, kita mengatakan: "Saya ingin mendefinisikan kembali parameter ini secara tepat dan mengatur nilai ini dan itu." <br><br>  Helm mengatasi tugas ini, jadi dalam diagram kami menandainya hijau. <br><img src="https://habrastorage.org/webt/it/nk/7s/itnk7so3wdowimy9riigh74amhy.png"><br><br>  Benar, kontra muncul: <br><br><ul><li>  <strong>Verbositas</strong> .  Sumber daya didefinisikan sepenuhnya dalam hal Kubernetes, konsep tingkat abstraksi tambahan tidak diperkenalkan: kami hanya menulis semua yang ingin kami tulis untuk Kubernetes dan mengganti variabel di sana. </li><li>  <strong>Jangan ulangi diri Anda sendiri - tidak berlaku.</strong>  Seringkali perlu untuk mengulangi hal yang sama.  Jika Anda memiliki dua layanan serupa dengan nama yang berbeda, Anda harus menyalin seluruh folder (paling sering mereka melakukan ini) dan mengubah file yang diperlukan. </li></ul><br>  Sebelum terjun ke arah Helm - manajer paket, yang saya ceritakan ini semua, mari kita lihat bagaimana Helm bekerja dengan dependensi. <br><br><h3>  Bekerja dengan dependensi <br></h3><br>  Helm sulit untuk bekerja dengan ketergantungan.  Pertama, ada file requirement.yaml yang cocok dengan apa yang kita andalkan.  Saat bekerja dengan persyaratan, ia melakukan persyaratan. Kunci - ini adalah kondisi saat ini (nugget) dari semua dependensi.  Setelah itu, ia mengunduhnya ke folder bernama / chart. <br><br>  Ada alat untuk mengelola: siapa, bagaimana, di mana menghubungkan - <strong>tag dan ketentuan</strong> , yang ditentukan di lingkungan mana, tergantung pada parameter eksternal apa, untuk menghubungkan atau tidak menghubungkan beberapa dependensi. <br><br>  Katakanlah Anda memiliki PostgreSQL untuk lingkungan Pementasan (atau RDS untuk Produksi, atau NoSQL untuk pengujian).  Dengan menginstal paket ini di Production, Anda tidak akan menginstal PostgreSQL, karena tidak diperlukan di sana - hanya menggunakan tag dan ketentuan. <br><br>  Apa yang menarik di sini? <br><br><ul><li>  Helm menggabungkan semua sumber daya dari semua dependensi dan aplikasi; </li><li>  sort -&gt; instal / perbarui </li></ul><br>  Setelah kami mengunduh semua dependensi di / chart (dependensi ini mungkin, misalnya, 100), Helm mengambil dan menyalin semua sumber daya di dalamnya.  Setelah dia memberikan template, dia mengumpulkan semua sumber daya di satu tempat dan mengurutkan dalam beberapa jenis pesanannya sendiri.  Anda tidak dapat memengaruhi pesanan ini.  Anda harus menentukan sendiri untuk apa paket Anda bergantung, dan jika paket tersebut memiliki dependensi transitif, maka Anda harus memasukkan semuanya dalam deskripsi dalam persyaratan.yaml.  Ini harus diingat. <br><br><h3>  Manajer paket <br></h3><br>  Helm menginstal aplikasi dan dependensi, dan Anda dapat memberitahu Helm menginstal - dan itu akan menginstal paket.  Jadi ini adalah manajer paket. <br><br>  Pada saat yang sama, jika Anda memiliki repositori eksternal tempat Anda mengunggah paket, Anda dapat mengaksesnya bukan sebagai folder lokal, tetapi cukup mengatakan: "Dari repositori ini, ambil paket ini, instal dengan parameter ini dan itu." <br><br>  Ada repositori terbuka dengan banyak paket.  Misalnya, Anda dapat menjalankan: helm install -f prod / values.yaml stable / wordpress <br><br>  Dari repositori stabil, Anda akan mengambil wordpress dan menginstalnya sendiri.  Anda dapat melakukan segalanya: mencari / meningkatkan / menghapus.  Ternyata, sungguh, Helm adalah manajer paket. <br><br>  Tetapi ada kontra: semua <strong>dependensi transitif</strong> harus dimasukkan di dalam.  Ini adalah masalah besar ketika dependensi transitif adalah aplikasi independen dan Anda ingin bekerja dengannya secara terpisah untuk pengujian dan pengembangan. <br><br>  Minus lainnya adalah <strong>konfigurasi ujung ke ujung</strong> .  Ketika Anda memiliki database dan namanya perlu ditransfer ke semua paket, ini bisa, tetapi sulit dilakukan. <br><br><img src="https://habrastorage.org/webt/ws/8m/ox/ws8moxa7dp9ekfc_fcb4mcrytae.png"><br><br>  Lebih sering daripada tidak, Anda telah menginstal satu paket kecil dan berfungsi.  Dunia ini kompleks: aplikasi tergantung pada aplikasi, yang pada gilirannya juga tergantung pada aplikasi - Anda perlu mengonfigurasinya dengan cerdik.  Helm tidak tahu bagaimana mendukung ini, atau mendukungnya dengan masalah besar, dan kadang-kadang Anda harus banyak menari dengan rebana untuk membuatnya bekerja.  Ini buruk, jadi "manajer paket" dalam diagram disorot dengan warna merah. <br><br><img src="https://habrastorage.org/webt/c5/rj/sz/c5rjszxy-hf_-pulkkcz_tsaie0.png"><br><br><h3>  Perakitan dan pengemasan <br></h3><br>  "Anda tidak bisa mendapatkan dan menjalankan" aplikasi di Kubernetes.  Anda perlu merakitnya, yaitu membuat gambar Docker, menulisnya ke registri Docker, dll.  Meskipun seluruh definisi paket di Helm adalah.  Kami menentukan paketnya, fungsi dan bidang apa yang harus ada, tanda tangan, dan otentikasi (sistem keamanan perusahaan Anda akan sangat senang).  Oleh karena itu, di satu sisi, perakitan dan pengemasan tampaknya didukung, dan di sisi lain, bekerja dengan gambar Docker tidak dikonfigurasikan. <br><br><blockquote>  Helm tidak memungkinkan Anda menjalankan aplikasi tanpa gambar Docker.  Pada saat yang sama, Helm tidak dikonfigurasikan untuk perakitan dan pengemasan, yaitu, pada kenyataannya, ia tidak tahu cara bekerja dengan gambar Docker. <br></blockquote><br>  Ini sama seperti jika, untuk membuat instalasi pemutakhiran untuk beberapa perpustakaan kecil, Anda akan dikirim ke folder yang jauh untuk menjalankan kompiler. <br><br>  Karena itu, kami mengatakan bahwa Helm tidak tahu cara bekerja dengan gambar. <br><img src="https://habrastorage.org/webt/am/li/ia/amliiax7srabjlml74xvn2xtyb8.png"><br><br><h3>  Pengembangan <br></h3><br>  Sakit kepala berikutnya adalah pengembangan.  Dalam pengembangan, kami ingin mengubah kode kami dengan cepat dan mudah.  Waktu telah berlalu ketika Anda membuat lubang pada kartu punch, dan hasilnya diperoleh setelah 5 hari.  Semua orang terbiasa mengganti satu huruf dengan yang lain di editor, menekan kompilasi, dan program yang sudah dimodifikasi berfungsi. <br><br>  Ternyata di sini bahwa ketika mengubah kode, banyak tindakan tambahan diperlukan: menyiapkan file Docker;  Jalankan Docker sehingga itu membangun gambar;  untuk mendorongnya ke suatu tempat;  disebarkan ke kluster Kubernetes.  Dan hanya dengan begitu Anda akan mendapatkan apa yang Anda inginkan di Production, dan Anda dapat memeriksa kodenya. <br><br>  Masih ada ketidaknyamanan karena <strong>pembaruan pembaruan</strong> helm yang <strong>merusak</strong> .  Anda melihat bagaimana semuanya bekerja, melalui eksekutif Kubectl Anda melihat di dalam wadah, semuanya baik-baik saja.  Pada saat ini Anda memulai pembaruan, gambar baru diunduh, sumber daya baru diluncurkan, dan yang lama dihapus - Anda harus memulai semuanya dari awal. <br><br>  Rasa sakit terbesar adalah <strong>gambar besar</strong> .  Sebagian besar perusahaan tidak bekerja dengan aplikasi kecil.  Seringkali, jika bukan supermonolith, maka setidaknya monolitik kecil.  Seiring waktu, dering tahunan bertambah, basis kode bertambah, dan lambat laun aplikasi menjadi cukup besar.  Saya telah berulang kali menemukan gambar Docker yang lebih besar dari 2 GB.  Bayangkan sekarang bahwa Anda membuat perubahan dalam satu byte dalam program Anda, tekan tombol, dan gambar Docker dua gigabyte mulai berkumpul.  Kemudian Anda menekan tombol berikutnya, dan transfer 2 GB ke server dimulai. <br><br>  Docker memungkinkan Anda untuk bekerja dengan layer, mis.  memeriksa apakah ada satu layer atau yang lain dan mengirimkan yang hilang.  Tetapi dunia sedemikian rupa sehingga paling sering akan menjadi satu lapisan besar.  Sementara 2 GB akan masuk ke server, sementara mereka akan pergi ke Kubernetes dengan Docker-registry, mereka akan diluncurkan dalam semua cara, sampai Anda akhirnya mulai - Anda dapat dengan aman minum teh. <br><br>  Helm tidak menawarkan bantuan apa pun dengan gambar Docker besar.  Saya percaya bahwa ini tidak boleh, tetapi pengembang Helm tahu lebih baik daripada semua pengguna, dan Steve Jobs tersenyum. <br><br><img src="https://habrastorage.org/webt/xk/wk/4z/xkwk4zdrvxa1xpejhdf02ogsdgo.png"><br><br>  Blok dengan pengembangan juga berubah merah. <br><br><img src="https://habrastorage.org/webt/pu/o2/ha/puo2ha8r-gmi9cqnkr_sfdv_mpq.png"><br><br><h3>  Otomasi Lingkungan <br></h3><br>  Arah terakhir - otomatisasi lingkungan - adalah area yang menarik.  Sebelum dunia Docker (dan Kubernetes, sebagai model terkait), tidak ada cara untuk mengatakan: "Saya ingin menginstal aplikasi saya di server ini atau di server ini sehingga ada n replika, 50 dependensi, dan semuanya otomatis bekerja!"  Seperti itu, bisa dikatakan, apa itu, tapi tidak! <br><br>  Kubernetes menyediakan ini dan logis untuk menggunakannya entah bagaimana, misalnya, untuk mengatakan: "Saya menyebarkan lingkungan baru di sini dan saya ingin semua tim pengembangan yang menyiapkan aplikasi mereka hanya dapat mengklik tombol dan semua aplikasi ini akan diinstal secara otomatis di lingkungan baru" .  Secara teoritis, Helm harus membantu dalam hal ini, sehingga konfigurasi dapat diambil dari sumber data eksternal - S3, GitHub - dari mana saja. <br><br>  Dianjurkan bahwa ada tombol khusus di Helm "Apakah aku sudah baik akhirnya!"  - dan itu akan segera menjadi baik.  Kubernetes memungkinkan Anda untuk melakukan ini. <br><br>  Ini sangat nyaman karena Kubernet dapat dijalankan di mana saja, dan ini bekerja melalui API.  Dengan meluncurkan minikube secara lokal, baik di AWS atau di Google Cloud Engine, Anda mengeluarkan Kubernet langsung dan bekerja di mana-mana: tekan tombol dan semuanya baik-baik saja segera. <br><br>  Tampaknya Helm secara alami memungkinkan Anda untuk melakukan ini.  Karena kalau tidak, apa gunanya menciptakan Helm secara umum? <br><br>  Tapi ternyata, tidak! <br><img src="https://habrastorage.org/webt/xs/mf/h5/xsmfh5898yrlawroqge2dn6v_iw.png"><br><br>  Tidak ada otomatisasi lingkungan. <br><br><h2>  Alternatif <br></h2><br>  Ketika ada aplikasi dari Kubernetes yang digunakan semua orang (sekarang sebenarnya adalah solusi nomor 1), tetapi Helm memiliki masalah yang dibahas di atas, masyarakat tidak bisa tidak menanggapi.  Itu mulai menciptakan alat dan solusi alternatif. <br><br><h3>  Mesin templat <br></h3><br>  Tampaknya, sebagai mesin templat, Helm menyelesaikan semua masalah, tetapi komunitas masih menciptakan alternatif.  Biarkan saya mengingatkan Anda masalah mesin template: verbosity dan penggunaan kembali kode. <br><br>  Perwakilan yang baik di sini adalah <strong>Ksonnet.</strong>  Ini menggunakan model data dan konsep yang berbeda secara fundamental, dan tidak bekerja dengan sumber daya Kubernetes, tetapi dengan definisi sendiri: <br>  <em>prototipe (params) -&gt; komponen -&gt; aplikasi -&gt; lingkungan.</em> <em><br></em> <br><br>  Ada bagian yang membentuk prototipe.  Prototipe ini diparameterisasi oleh data eksternal, dan komponen muncul.  Beberapa komponen membuat aplikasi yang dapat Anda jalankan.  Ini berjalan di lingkungan yang berbeda.  Ada beberapa tautan yang jelas ke sumber daya Kubernetes di sini, tetapi mungkin tidak ada analogi langsung. <br><br>  Tujuan utama Ksonnet, tentu saja, untuk <strong>menggunakan kembali sumber daya</strong> .  Mereka ingin memastikan bahwa setelah Anda menulis kode, Anda nanti dapat menggunakannya di mana saja, yang meningkatkan kecepatan pengembangan.  Jika Anda membuat perpustakaan eksternal yang besar, orang-orang dapat terus memposting sumber daya mereka di sana, dan seluruh komunitas akan dapat menggunakannya kembali. <br><br>  Secara teoritis, ini nyaman.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya praktis tidak menggunakannya. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manajer paket </font></font><br></h3><br>  ,    â€”   ,  ,  .  Ksonnet  .  Ksonnet    Helm ,         ,       ..   ,    ,     ,       . <br><img src="https://habrastorage.org/webt/-e/ed/76/-eed76zagrsnj_ydzkcqedelf1g.png"><br><br>    ,   ,  ,    ,   .      .    ,      ,   ,      0.1. ,     . <br><img src="https://habrastorage.org/webt/-c/om/sm/-comsmfipyfxjxvsbit48zbwhoe.png"><br><br> ,   â€”  <strong>KubePack</strong> ,       . <br><br><h3>  Pengembangan <br></h3><br>      : <br><br><ol><li>    Helm; <br></li><li>  Helm; <br></li><li>    ,        ; <br></li><li>   ,   . <br></li></ol><br><h4> 1.   Helm <br></h4><br>   â€”  <strong>Draft</strong> .   â€”      ,   ,     . Draft    â€” Heroku-style: <br><br><ul><li>      (pack); </li><li> , ,  Python Â«Hello, world!Â»; </li><li>  ,   Docker- (   ); </li><li>   ,   ,   docker-registry,     ; </li><li>    . </li></ul><br>        ,   ,   . <br><br>          Helm,   Draft  Helm-,        production ready,   ,  Draft   Helm-,  .       . <br><br> ,  Draft           ,      Helm-. Draft â€”     . <br><br><h4> 2.   Helm <br></h4><br>   Helm Charts      Kubernetes-,       Helm Charts.   : <br><br><ul><li> GitKube; </li><li> Skaffold; </li><li> Forge. </li></ul><br>      Helm,    .  ,   ,     command line interface,  Chart ,     git push   . <br><br>   ,     docker build, docker push  kubectl rollout.   ,     Helm,   .        . <br><br><h4> 3.     <br></h4><br>   â€”    .    â€” <strong>Metaparticle</strong> . ,     Python,    Python  ,     . <br><br><blockquote>       ,          ,      ,      sysconfig  ..    . <br></blockquote><br>     ,     ,    ,  -           Kubernetes-. <br><br>    :   ,     ;   ,      ;        .. <br><img src="https://habrastorage.org/webt/wn/vg/4-/wnvg4-72i7bhg5dabn9_1zinijw.png"><br><br>   ,  ,     ,    -  ,   Python-     Kubernetes-.     ? <br><br>     - ,    .    . ,  ,       preinstall ,   -     .      Kubernetes-,       Metaparticle,   . <br><br>     ,    ,   Kubernetes-   .  ,       ,  Metaparticle. <br><br><img src="https://habrastorage.org/webt/l1/py/fi/l1pyfi0l2xjkhgatomlhj6sil3s.png"><br><br>    Metaparticle,      Helm .   ,       . <br><br> <strong>Telepresence/Ksync</strong> â€”   . ,      ,  Helm-,   .   ,   -  ,       - , ,      . ,     Production-,     Production - . <br><br>  Kubernetes  ,        Docker,  registry,   Kubernetes.          .      ,    . <br><br> , ,       ,    Development     .    :  ,   ,   ,     ,     â€”   ,   ,   ,   Helm,  ,     . <br><br>   ,    . <br><br><h4> 4.   Kubernetes  Kubernetes <br></h4><br>   ,      Kubernetes  Kubernetes.  ,       Helm-    ,         .          ,      .     ,    Docker-compose . <br><br>    Docker-compose ,       ,    ,    ,       Docker,     Kubernetes,    Docker-compose,   .     ,    .   ,       Docker.     . <br><br>        minikube   ,      Docker-compose,    .  ,   ,  Docker-compose â€”  10     .         ,   . <br><img src="https://habrastorage.org/webt/m2/h4/tt/m2h4tthsizav7rv4tubxlkfo0qg.png"><br><br>     Docker-compose,    ,         . <br><br><h3>    <br></h3><br> ,    â€”   Helm, , ,  Helm -  .       CI/CD,   ,   .     â€”      Helm,     ? ,     ,    . <br><br>     CI/CD,     ,      docker',  set-,         ,    â€”   . <br><br> CI/CD â€”       ,     . <br><br><h2>  Ringkasan <br></h2><br><img src="https://habrastorage.org/webt/fy/pc/ba/fypcbahu2fgsz16tn-imk2a5vpy.png"><br><br>  5   Helm   .   ,    .     ,  ,       .     ,          ,  ,   . <br><br><h2>  Helm <br></h2><br> ,       ,   Helm  .   ,  Helm    ,   . ,     ,   ,     Helm. <br><br> ,     Road Map.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kuberneres Helm  community</a> ,          ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Helm V3</a> . <br><br><h3>   Tiller,  cli <br></h3><br>      ,   .  Helm    : <br><br><ol><li>  ,       (cmd  ..). <br></li><li> Tiller â€”  ,      Kubernetes. <br></li></ol><br> Tiller  ,     Command Line Interface.    : Â«     ChartÂ» â€”   Helm  , ,  Tiller',    : Â«,  - ! ,      Kubernetes-Â» â€”  . <br><br>    Helm,    Tiller       ,    .    ,   ,    ,     ,   Tiller' â€”   namespace .  Tiller      namespace,    ,       .      ,     . <br><br>    V3 Tiller  . <br><img src="https://habrastorage.org/webt/k2/rs/3d/k2rs3djfuxajcdf1cgr2whzob58.png"><br><br>     ?  ,   ,   Command Line Interface,  ,     Kubernetes. ,   Kubernetes      ,    Tiller.      kubectl cli    . <br><br>  Tiller  <strong> </strong> .    ,     Kubernetes  Command Line Interface  : , , , pre-  post-.    . <br><br><h3> Lua-  Chart <br></h3><br>       ,  â€” ,       <strong>lua-</strong> .    Chart    lua-,     .       . ,  .   ,   ,    ,      . <br><img src="https://habrastorage.org/webt/cr/ie/h1/crieh1qr2o9qc9oocuti_i9bhhm.png"><br><br> Lua      ,      ,   ,  - ,    ,      . <br><br>  ,   ,   .  ,           .       Kubernetes,    - ,    ,    ,   ,    .  Mari kita lihat apa yang terjadi. <br><br><h3> Release- + secret   <br></h3><br>  ,     ,  <strong>Release-</strong>    ,  Release  .   ,     Release-,     ,  ,   CRD,  , . <br><br><h3>   namespace  <br></h3><br>  Release-     namespace,     ,   -  <strong>   Tiller'</strong>  namespace â€”  ,      . <br><br><h3> CRD: controller <br></h3><br>        ,   CRD-controller  Helm   ,       push-.        . <br><br><h2>   <br></h2><br>  ,     . <br><img src="https://habrastorage.org/webt/c-/kk/zv/c-kkzvsvdzuwr3werccbixl1an4.png"><br><br>  ,  <strong>Helm</strong> .   ,      ,     ,     .  ,       ,      .  Helm â€”  -   Kubernetes.      -  ,  ,  . <br><br>  , <strong>CI/CD</strong> ,    .      <strong>  Slack</strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kami memiliki bot yang melaporkan ketika bangunan baru lulus master, dan semua tes berhasil. </font><font style="vertical-align: inherit;">Anda memberi tahu dia: "Saya ingin menginstal ini di Pementasan" - dan dia menginstal, Anda berkata: "Saya ingin menjalankan tes di sana!" </font><font style="vertical-align: inherit;">- dan dia mulai. </font><font style="vertical-align: inherit;">Cukup nyaman. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk pengembangan, gunakan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker-compose atau Telepresence.</font></font></strong> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beberapa versi dari satu layanan </font></font><br></h2><br><img src="https://habrastorage.org/webt/gg/cq/wv/ggcqwvrbonamtzi4wudhx3t9jly.png"><br><br>  Pada akhirnya, kita akan menganalisis situasi ketika ada dua aplikasi A dan B, yang bergantung pada C, tetapi C dari versi yang berbeda.  Perlu mengatasi masalah ini: <br><br><ul><li>  untuk pengembangan, karena sebenarnya kita harus mengembangkan hal yang sama, tetapi dua versi berbeda; </li><li>  untuk rilis; </li><li>  untuk konflik nama, karena di semua manajer paket standar, menginstal dua paket versi yang berbeda dapat menyebabkan masalah. </li></ul><br>  Bahkan, Kubernetes memutuskan segalanya untuk kami - Anda hanya perlu menggunakannya dengan benar. <br><br><img src="https://habrastorage.org/webt/wq/ra/mr/wqramrfg3yh1izbnppjmxeuc9hs.png"><br><br>  Saya akan menyarankan membuat 4 Bagan dalam hal Helm, 3 repositori (untuk repositori C, ini hanya akan menjadi dua cabang yang berbeda).  Apa yang paling menarik, semua instalasi untuk v1 dan untuk v2 harus berisi informasi di dalamnya sendiri tentang versi atau untuk layanan apa itu dibuat.  Satu solusi pada slide, lampiran C;  nama rilis menunjukkan bahwa ini adalah versi v1 untuk layanan A;  nama layanan juga berisi versi.  Ini adalah contoh paling sederhana, Anda dapat melakukannya dengan sangat berbeda.  Tetapi yang paling penting adalah bahwa nama-nama itu unik. <br><br>  Yang kedua adalah dependensi transitif, dan di sini lebih rumit. <br><img src="https://habrastorage.org/webt/pi/5l/ya/pi5lyafuuagwemrrfdhkdb_zby4.png"><br><br>  Misalnya, Anda sedang mengembangkan rantai layanan dan ingin menguji A. Untuk ini, Anda harus mentransfer semua dependensi yang A bergantung, termasuk transitif, ke definisi Helm dari paket Anda.  Tetapi pada saat yang sama, Anda ingin mengembangkan B dan juga mengujinya - cara melakukan ini tidak jelas, karena Anda perlu memasukkan semua dependensi transitif di dalamnya juga. <br><br>  Oleh karena itu, saya menyarankan Anda untuk tidak menambahkan semua dependensi di dalam setiap paket, tetapi untuk membuatnya independen dan mengelola apa yang berjalan dari luar.  Ini merepotkan, tetapi lebih rendah dari dua kejahatan. <br><br><h2>  Tautan yang bermanfaat <br></h2><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konsep</a> <br><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitKube</a> <br><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Helm</a> <br><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ksonnet</a> <br><br>  â€¢ Stiker telegram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> <br><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sig-Aplikasi</a> <br><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KubePack</a> <br><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metapartikel</a> <br><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Skaffold</a> <br><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Helm v3</a> <br><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Susunan Docker</a> <br><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ksync</a> <br><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Telepresence</a> <br><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Drone</a> <br><br>  â€¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menempa</a> <br><br>  Profil pembicara Ivan Glushkov di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> , di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter</a> , di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Habr</a> . <br><br><blockquote>  Berita bagus <br><br>  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran youtube</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> kami <strong>membuka video semua laporan tentang DevOps dari festival RIT ++</strong> .  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar putar</a> terpisah, tetapi dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar lengkap</a> video ada banyak hal berguna dari konferensi lain. <br><br>  Lebih baik lagi, berlangganan saluran dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buletin</a> , karena di tahun mendatang <strong>kita akan melihat banyak devops</strong> : pada bulan Mei, kerangka kerja RIT ++;  di musim semi, musim panas dan musim gugur sebagai bagian dari HighLoad ++, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevOpsConf Rusia</a> musim gugur yang terpisah. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431540/">https://habr.com/ru/post/id431540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431530/index.html">Buka pelajaran "Desain Material Android: pembaruan ikhtisar"</a></li>
<li><a href="../id431532/index.html">Memristor terdiri dari bagian tebal 2 nm</a></li>
<li><a href="../id431534/index.html">Identitas Masalah Di Antara Pengembang</a></li>
<li><a href="../id431536/index.html">Ceph. Anatomi bencana</a></li>
<li><a href="../id431538/index.html">Case Rate & Barang dan Mobio: peningkatan bertahap dalam semua indikator</a></li>
<li><a href="../id431542/index.html">Pengembangan dan pemeliharaan yang efektif untuk peran yang memungkinkan</a></li>
<li><a href="../id431544/index.html">Bawa DevOps ke massa</a></li>
<li><a href="../id431546/index.html">Kenapa kita bilang oke?</a></li>
<li><a href="../id431548/index.html">Solar Dozor - Apa Dibalik Bintang?</a></li>
<li><a href="../id431550/index.html">Pembuatan Film Injeksi (IMD): Cara Kerjanya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>