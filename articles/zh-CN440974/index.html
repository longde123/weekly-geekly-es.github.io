<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏻 💨 👩🏾‍🤝‍👨🏻 科特林拼图，卷。 2：新一批难题 😟 ☝🏾 👨🏾‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您可以预测这样的Kotlin代码如何表现吗？ 它会编译输出什么，为什么？ 

 不管编程语言有多好，它都会抛出它，以至于它只会擦伤后脑。 Kotlin也不例外-当即使很短的一段代码都具有意外行为时，它也包含困惑器。 

 早在2017年，我们就在Habré上发布了Anton Keks antonke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>科特林拼图，卷。 2：新一批难题</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/440974/"><img src="https://habrastorage.org/webt/bj/9x/wi/bj9xwicnsccegyu2fo2xvbvglr0.png"><br><br> 您可以预测这样的Kotlin代码如何表现吗？ 它会编译输出什么，为什么？ <br><br> 不管编程语言有多好，它都会抛出它，以至于它只会擦伤后脑。  Kotlin也不例外-当即使很短的一段代码都具有意外行为时，它也包含困惑器。 <br><br> 早在2017年，我们就在Habré上发布了<b>Anton</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Keks antonkeks</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">精选的</a>此类<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">益智游戏</a> 。 后来，他在Mobius上与我们一起进行了第二次选择，我们现在也将其翻译成Habr转换为文本视图，将正确的答案隐藏在剧透下面。 <br><br> 我们还会附上演讲的视频录像，如果文本中出现难以理解的内容，您也可以与她联系。 <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/t387acWEK3o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 上半部分的谜题针对那些对Kotlin不太熟悉的人。 下半部分是针对Kotlin核心开发人员的。 即使启用了渐进模式，我们也将在Kotlin 1.3上启动所有功能。  Puzzler源代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在GitHub上</a> 。 谁提出新的想法，发送请求请求。 <br><br><h2>  1号观众 </h2><br><pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { println(print(″Hello″) == print(″World″) == <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } hello()</code> </pre> <br> 在我们面前的是一个简单的hello函数，它会运行几次打印。 然后我们自己启动此功能。 一个简单的超频问题：应该显示什么？ <br><br>  a）HelloWorld <br>  b）HelloWorldfalse <br>  c）HelloWorldtrue <br>  d）未编译 <br><br><div class="spoiler">  <b class="spoiler_title">正确答案</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ce/uc/rg/ceucrgqimyvojaud8llfktt0l1s.png"><br><br> 第一种选择是正确的。 两种打印都已经开始后才触发比较，但无法更早开始。 为什么要完全编译这样的代码？ 除了返回Nothing以外的任何函数都将返回某些内容。 由于Kotlin中的所有内容都是一个表达式，所以即使return也是一个表达式。  return的返回类型为Nothing，它强制转换为任何类型，因此您可以像这样进行比较。 并且打印返回Unit，因此Unit可以多次与Nothing进行比较，并且一切正常。 <br></div></div><br><h2> 观众人数2 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { println(n) } printInt(-<span class="hljs-number"><span class="hljs-number">2_147_483_648</span></span>.inc())</code> </pre><br> 提示，您不会猜到：可怕的数字实际上是最小的32位有符号整数。 <br><br> 这里的一切看起来都很简单。  Kotlin具有出色的扩展功能，例如.inc（）可以递增。 我们可以在Int上调用它，并且可以打印结果。 会发生什么？ <br><br>  a）-2147483647 <br>  b）-2147483649 <br>  c）2147483647 <br>  d）以上都不是 <br><br><div class="spoiler">  <b class="spoiler_title">发射！</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/se/sa/hy/sesahyqljf-z0kyeil35hpev4ho.png"><br><br> 从错误消息中可以看到，这是Long的问题。 但是为什么要长呢？ <br><br> 扩展函数具有优先权，编译器首先运行inc（），然后运行减号运算符。 如果inc（）被删除，则它将为Int，并且一切正常。 但是inc（）首先开始将2_147_483_648转换为Long，因为此数字不带减号不再是有效的Int。 原来是Long，只有这样才叫减号。 所有这些都不能再传递给printInt（）函数，因为它需要一个Int。 <br><br> 如果将对printInt的调用更改为可以接受Long的常规打印，则第二个选项将是正确的。 <br><br><img src="https://habrastorage.org/webt/qf/vf/q3/qfvfq3njfzcubm6ax7uvda6g8b4.png"><br><br> 我们看到这实际上是Long。 请注意：并非所有的拼图游戏都可以在真实代码中运行，但是这个可以。 <br></div></div><br><h2> 观众人数3 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x: UInt = <span class="hljs-number"><span class="hljs-number">0</span></span>u println(x--.toInt()) println(--x)</code> </pre><br>  Kotlin 1.3中引入了新的强大功能。 除了Corutin的最终版本，我们 <br> 现在终于有了未签名的数字。 这是必要的，尤其是在编写某种网络代码时。 <br><br> 现在，对于文字，甚至还有一个特殊的字母u，我们可以定义常量，如示例中所示，我们可以将x减1并转换为Int。 我提醒您Int熟悉我们。 <br><br> 会发生什么？ <br><br>  a）-1 4294967294 <br>  b）0 4294967294 <br>  c）0 -2 <br>  d）未编译 <br><br>  4294967294是可以获取的最大32位数字。 <br><br><div class="spoiler">  <b class="spoiler_title">发射！</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/uj/up/ch/ujupchn07nkjmqfl8a9hnhbycha.png"><br><br> 更正选项b。 <br><br> 在这里，与以前的版本一样：首先，在x上调用toInt（），然后才递减。 显示无符号减量的结果，这是unsignedInt的最大值。 <br><br> 最有趣的是，如果您这样编写，代码将无法编译： <br><br><pre> <code class="kotlin hljs">println(x--.toInt()) println(--x.toInt())</code> </pre><br> 对于我来说，第一行有效，而第二行有效-这是不合逻辑的，这很奇怪。 <br><br> 在预发行版本中，正确的选项是C，因此在JetBrains中做得很好，可以在发行最终版本之前修复错误。 <br></div></div><br><h2> 观众人数4 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cells = arrayOf(arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbors = cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] print(neighbors)</code> </pre><br> 我们在实际代码中遇到了这种情况。 我们在Codeborne进行了Coding Dojo编码，并在Kotlin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的《生命游戏》中</a>实现了它。 如您所见，在Kotlin上使用多级阵列并不是很方便。 <br><br> 在“生命游戏”中，算法的重要部分是确定一个小区的邻居数量。 周围的所有小动物都是邻居，这取决于细胞是存活还是死亡。 在这段代码中，您可以数一数并假设会发生什么。 <br><br>  a）6 <br>  b）3 <br>  c）2 <br>  d）未编译 <br><br><div class="spoiler">  <b class="spoiler_title">让我们来看看</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/m2/8_/j0/m28_j0aa1kg9j7aixnsj2trzsrg.png"><br><br> 正确答案是3。 <br><br> 事实是第一行的加号向下移动，而Kotlin认为这是一元加号（）。 结果，仅对前三个单元进行求和。 如果要分几行编写此代码，则需要向上移动加号。 <br><br> 这是另一个“坏难题”。 请记住，在Kotlin中，您不需要将语句转移到新行，否则它可能会认为它是一元的。 <br><br><img src="https://habrastorage.org/webt/f5/-9/ew/f5-9ewbhsw0ucybzsg-7xkeld1u.png"><br><br> 我没有看到在DSL之外的实际代码中需要unaryPlus的情况。 这是一个非常奇怪的话题。 <br><br> 这是没有分号时我们要付出的代价。 如果是这样，则很清楚一个表达式何时结束而另一个表达式何时开始。 没有它们，编译器必须做出决定。 编译器的换行符通常意味着尝试单独检查这些行是有意义的。 <br><br> 但是有一种非常酷的JavaScript语言，您也无法使用其中的分号编写该代码，但该代码仍然可以正常工作。 <br></div></div><br><h2> 观众人数5 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x?:<span class="hljs-number"><span class="hljs-number">0</span></span> + y println(sum)</code> </pre><br> 该拼图游戏由KotlinConf演讲者Thomas Nild主讲。 <br><br>  Kotlin具有强大的可空类型功能。 我们有可为空的x，如果结果为null，则可以通过Elvis运算符将其转换为某个正常值。 <br><br> 会发生什么？ <br><br>  a）3 <br>  b）5 <br>  c）2 <br>  d）0 <br><br><div class="spoiler">  <b class="spoiler_title">发射！</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1_/zg/-o/1_zg-ozj8sgftbrk2nswebclg30.png"><br><br> 问题再次出在操作员的顺序或优先级上。 如果我们重新设置格式，则官方格式将执行以下操作： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x ?: <span class="hljs-number"><span class="hljs-number">0</span></span>+y</code> </pre><br> 该格式已经建议0 + y首先开始，然后才是x？：。 因此，当然还有2个，因为X为2，所以它不为null。 <br></div></div><br><h2> 观众人数6 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hops: List&lt;Hops&gt; = emptyList() ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hops</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kind: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> atMinute: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grams: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Recipe</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = Recipe().apply(build) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Recipe.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hops</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Hops</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { hops += Hops().apply(build) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recipe = beer { name = ″Simple IPA″ hops { name = ″Cascade″ grams = <span class="hljs-number"><span class="hljs-number">100</span></span> atMinute = <span class="hljs-number"><span class="hljs-number">15</span></span> } }</code> </pre><br> 当他们打电话给我时，他们答应我精酿啤酒。 我今晚要去找他，还没见过他。  Kotlin有一个很棒的话题-建筑商。 使用四行代码，我们编写了DSL，然后通过构建器创建了DSL。 <br><br> 我们首先创建IPA，然后在沸腾的第15分钟内添加称为Cascade的啤酒花，100克，然后打印此配方。 我们做了什么？ <br><br>  a）配方（名称=简单IPA，跃点= [跃点（名称=级联，atMinute = 15，克= 100）]） <br>  b）IllegalArgumentException <br>  c）未编译 <br>  d）以上都不是 <br><br><div class="spoiler">  <b class="spoiler_title">发射！</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ji/ci/8p/jici8p8px4kd4hnogzpvcufsrqi.png"><br><br> 我们得到了与精酿啤酒类似的东西，但是里面没有啤酒花，它消失了。 他们想要IPA，但得到了波罗的海7。 <br><br> 这就是命名冲突发生的地方。  Hops中的字段实际上称为kind，在行名称=“ Cascade”中，我们使用name，该名称与配方名称一起缓存。 <br><br> 我们可以创建自己的BeerLang批注并将其注册为BeerLang DSL的一部分。 现在，我们正在尝试运行此代码，不应与我们一起对其进行编译。 <br><br><img src="https://habrastorage.org/webt/eq/i-/a3/eqi-a3r5hjxbpsy7z-rlzqlkqjg.png"><br><br> 现在我们被告知，原则上不能在此上下文中使用名称。 为此，需要DSLMarker，因为构建器内部的编译器不允许我们使用外部字段，如果内部具有相同的字段，则不存在命名冲突。 像这样固定代码，我们得到了食谱。 <br><br><img src="https://habrastorage.org/webt/rv/kn/8y/rvkn8ys1t9syngob9ikmtfbgij8.png"><br></div></div><br><h2> 观众人数7 </h2><br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(″$x TRUE″) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(″$x FALSE″) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br> 这个难题是JetBrains的雇员之一。  Kotlin具有when功能。 它适用于所有场合，它允许您编写出色的代码，它通常与密封类一起用于API设计。 <br><br> 在这种情况下，我们有一个函数f（），该函数采用布尔值并根据true和false打印一些内容。 <br><br> 会发生什么？ <br><br>  a）是TRUE； 错误错误 <br>  b）是TRUE； 假TRUE <br>  c）真假； 错误错误 <br>  d）以上都不是 <br><br><div class="spoiler">  <b class="spoiler_title">让我们来看看</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/c6/g0/lo/c6g0loicys30gkbo0bf9cagvk20.png"><br><br> 为什么这样 首先，我们计算表达式x == true：例如，在第一种情况下，它将为true == true，这表示true。 然后还与我们在何时传递的模式进行了比较。 <br><br> 当x设置为false时，将x == true评估为false，但是样本也将为false-因此示例将与样本匹配。 <br><br> 有两种方法可以修复此代码，一种是在两种情况下都删除“ x ==”： <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(″$x TRUE″) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(″$x FALSE″) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br> 第二种选择是在时间之后删除（x）。 当在任何条件下均可工作时，则将与样品不匹配。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(″$x TRUE″) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(″$x FALSE″) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br></div></div><br><h2> 观众八号 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullSafeLang</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> logo = name[<span class="hljs-number"><span class="hljs-number">0</span></span>].toUpperCase() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = ″Kotlin″ } print(Kotlin().logo)</code> </pre><br>  Kotlin被推销为“零安全”语言。 想象一下，我们有一个抽象类，它有一个名称，还有一个返回该语言徽标的属性：以防万一，该名称的首字母大写（突然被忘了使用大写字母）。 <br><br> 由于该语言是无效的语言，因此我们将更改名称，并且可能应该获得正确的徽标，即一个字母。 我们真正得到什么？ <br><br>  a）K <br>  b）NullPointerException <br>  c）IllegalStateException <br>  d）未编译 <br><br><div class="spoiler">  <b class="spoiler_title">发射！</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bb/et/sm/bbetsm3lj5eh356zwho6z4bhzjs.png"><br><br> 我们收到了一个N​​ullPointerException，我们不应该收到它。 问题在于，首先调用超类的构造函数，代码尝试初始化属性徽标，并从零开始使用名称char，此时名称为null，因此发生NullPointerException。 <br><br> 解决此问题的最佳方法是： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = ″Kotlin″ }</code> </pre><br> 如果运行这样的代码，则得到“ K”。 现在，基类将调用基类的构造函数，它实际上将调用getter名称并获取Kotlin。 <br><br> 属性是Kotlin的一项重要功能，但是您在覆盖属性时需要非常小心，因为它很容易忘记，犯错或确保做错事情。 <br><br></div></div><br><h2>  9号观众 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = mutableListOf&lt;() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>) { i++ result += { print(″$i, $j; ″) } } result.forEach { it() }</code> </pre><br> 有一些令人恐惧的事情的可变列表。 如果它使您想起Scala，那么它并不是徒劳的，因为它的确看起来像。 有一个List lambd，我们有两个计数器-I和j，递增，然后对它们执行一些操作。 会发生什么？ <br><br>  a）1 1;  2 2;  3 3 <br>  b）1 3;  2 3;  3 3 <br>  c）3 1;  3 2;  3 3 <br>  d）以上都不是 <br><br><div class="spoiler">  <b class="spoiler_title">跑吧</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/y8/ap/9j/y8ap9j-cfyyuanfscsg_irflczy.png"><br><br> 我们得到3 1;  3 2;  3 3.发生这种情况是因为i是一个变量，它将一直保留其值直到函数结束。  j通过值传递。 <br><br> 如果不是var i = 0，而是val i = 0，这将不起作用，但是我们不能递增变量。 <br><br> 在Kotlin中，我们使用闭包，而Java中没有此功能。 这很酷，但是如果我们不立即使用i的值，而是将其传递给lambda，它会在以后给我们带来麻烦，该lambda会在以后启动并查看此变量的最后一个值。 并且j通过值传递，因为循环条件中的变量-它们与val相同，因此不再更改其值。 <br><br> 在JavaScript中，答案将是“ 3 3;  3 3;  3 3”，因为没有值传输。 <br><br></div></div><br><h2> 观众人数10 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = print(″$a, $b″) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = <span class="hljs-number"><span class="hljs-number">4</span></span> foo(c &lt; a, b &gt; d)</code> </pre><br> 我们有一个函数foo（），使用两个布尔值，将它们打印出来，一切似乎都很简单。 我们有很多数字，剩下的就是看看哪个数字比另一个数字大，然后确定哪个选项是正确的。 <br><br>  a）真实，真实 <br>  b）错误，错误 <br>  c）null，null <br>  d）未编译 <br><br><div class="spoiler">  <b class="spoiler_title">我们启动</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/j6/m5/5c/j6m55cysqvltjnc9x67mxerzglq.png"><br><br> 未编译。 <br><br> 问题在于编译器认为这与通用参数相似：使用&lt;a，b&gt;。 尽管“ c”似乎不是一个类，但尚不清楚为什么它应该具有通用参数。 <br><br> 如果代码是这样的，那就可以了： <br><br><pre> <code class="kotlin hljs">foo(c &gt; a, b &gt; d)</code> </pre><br> 在我看来，这是编译器中的错误。 但是，当我带着任何这样的谜题去找安德烈·布雷斯拉夫（Andrei Breslav）时，他说：“这是因为解析器就是这样，他们不希望它太慢。” 通常，他总是找到原因的解释。 <br><br> 不幸的是，是这样。 他说他们不会修复它，因为解析器 <br>  Kotlin尚不了解语义。 解析首先发生，然后将其传递到另一个编译器组件。 不幸的是，这种情况可能仍然如此。 因此，不要在中间写两个这样的尖括号和任何代码！ <br></div></div><br><h2> 观众人数11 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Container</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> items: List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;) : List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (name, items) = Container(″Kotlin″, listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) println(″Hello $name, $items″)</code> </pre><br> 委托是Kotlin的一项重要功能。 顺便说一句，安德烈·布雷斯拉夫（Andrei Breslav）说，这是他很乐意从语言中删除的功能，他不再喜欢它。 现在，也许，我们将找出原因！ 他还说，同伴的物体很丑陋。 <br><br> 但是数据类绝对是美丽的。 我们有一个数据类Container，它本身具有名称和项目。 同时，在Container中，我们实现项目的类型，即List，并将其所有方法委托给项目。 <br><br> 然后，我们使用另一个很酷的功能-分解。 我们从容器中“销毁”名称和项目元素，并将其显示在屏幕上。 一切似乎都很简单明了。 会发生什么？ <br><br>  a）你好科特林，[1,2,3] <br>  b）你好，科特林，1岁 <br>  c）你好1、2 <br>  d）你好，科特林，2岁 <br><br><div class="spoiler">  <b class="spoiler_title">我们启动</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fn/jt/bb/fnjtbbmz1sikuctkwsxxkmih7vc.png"><br><br> 最模糊的选项是d。 他原来是真的。 事实证明，项目只是从项目集合中消失，而不是从开头或结尾消失，而只是在中间消失。 怎么了 <br><br> 销毁的问题是由于委托，科特林的所有藏品 <br> 有自己的解构选择。 我可以写val（I，j）= listOf（1，2），并将这1和2放入变量，即List已实现函数component1（）和 <br>  component2（）。 <br><br> 数据类还具有component1（）和component2（）。 但是，由于本例中的第二个组件是私有的，因此在List上公开的那个组件是赢家，因此第二个元素是从List上获得的，我们到了这里2。道德很简单：不要那样做，不要那样做。 <br></div></div><br><h2> 观众人数12 </h2><br> 下一个难题是非常可怕的。 这是一个与科特林有某种联系的顺从人，所以他知道自己在写什么。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Any?.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asGeneric</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T <span class="hljs-number"><span class="hljs-number">42</span></span>.asGeneric&lt;<span class="hljs-built_in"><span class="hljs-built_in">Nothing</span></span>&gt;()!!!! <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-number"><span class="hljs-number">87</span></span> println(a)</code> </pre><br> 我们在可为空的Any上具有扩展功能，也就是说，它可以完全应用于任何对象。 这是一个非常有用的功能。 如果尚不在您的项目中，则值得添加，因为它可以将您想要的一切放入任何东西。 然后我们取42并将其转换为Nothing。 <br><br> 好吧，如果我们想确保我们做了重要的事情，我们可以改为！！！ 编写!!!!，Kotlin编译器允许您执行以下操作：如果您缺少两个感叹号，请至少编写26个。 <br><br> 然后我们做if（true），然后我自己什么都不知道。让我们立即选择会发生什么。 <br><br>  a）87 <br>  b）Kotlin.Unit <br>  c）ClassCastException <br>  d）未编译 <br><br><div class="spoiler">  <b class="spoiler_title">看着</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_t/g7/l-/_tg7l-vw0wze-y2vu_dix7cnvni.png"><br><br> 给出合理的解释是非常困难的。 最有可能的是，这里的部队是由于没有更多可推入的事实。 这是无效的代码，但是可以使用，因为我们没有使用过。 我们已经向Nothing上传了一些东西，这是一种特殊的类型，它告诉编译器该类型的实例永远都不会出现。 编译器知道，如果有出现Nothing的可能性（按定义是不可能的），则无法进一步检查，这是不可能的情况。 <br><br> 最有可能的是，这是编译器中的错误，JetBrains团队甚至表示，也许有一天该错误会得到修复，这不是很重要。 诀窍是因为这种转换，我们在这里欺骗了编译器。 如果删除行42.asGeneric &lt;Nothing&gt;（）!!! 并停止作弊，代码将停止编译。 如果我们离开了，编译器就会发疯，认为这是一个不可能的表达式，然后把所有东西塞进去。 <br><br> 我明白 也许某天某人会更好地解释它。 <br><br></div></div><br><h2> 观众13 </h2><br> 我们有一个非常有趣的功能。 您可以使用依赖项注入，也可以不使用依赖项注入，通过对象进行单调运行，然后运行程序很酷。 为什么需要Koin，Dagger之类的东西？ 但是，测试将很困难。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any?) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = javaClass.simpleName } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> B : A(C) <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> C : A(B) println(Bx) println(Cx)</code> </pre><br> 我们有一个开放给继承的类A，它继承了内部的东西，我们创建了两个对象，一个单例B和C，它们都从A继承并在那里相互传递。 即，形成了良好的循环。 然后我们打印出B和C得到的结果。 <br><br>  a）null； 空值 <br>  b）C; 空值 <br>  c）ExceptionInInitializerError <br>  d）未编译 <br><br><div class="spoiler">  <b class="spoiler_title">我们启动</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/lf/ic/tc/lfictczohzri2l2os2w5xpypbfw.png"><br><br> 正确的选项是C； 空值 <br><br> 一个人会认为，当第一个对象初始化时，第二个对象还不存在。 但是，当我们推论出这一点时，C缺少B。也就是说，获得了相反的顺序：由于某种原因，编译器决定先初始化C，然后再与C一起初始化B。这看起来很不合逻辑，相反，它是逻辑上为null ;  B． <br><br> 但是编译器试图做某事，但是没有成功，他在那儿留下了空，决定什么都不给我们。 也可能是这样。 <br><br> 如果有的话？ 在参数类型中，删除？，则将无法使用。 <br><br><img src="https://habrastorage.org/webt/re/mh/6n/remh6n7bggwrm2ig962qbh1uvlu.png"><br><br> 我们可以向编译器说，当null解析后，他尝试了，但是失败了，但是呢？ 不，他给我们抛出了一个例外，那就是不可能循环。 <br></div></div><br><h2> 帕兹勒№14 </h2><br>  1.3版在Kotlin中发布了很棒的新协程。 我想了很长时间，想出一个关于Corutin的谜题，以便有人可以理解。 我认为对于某些人来说，任何带有协程的代码都是一个难题。 <br><br> 在1.3版中，实验API中的某些函数名称已更改，在1.2版中。 例如，buildSequence（）重命名为简单的sequence（）。 也就是说，我们可以使用yield函数，无限循环来创建出色的序列，然后尝试从该序列中获取一些东西。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> coroutines.yieldNoOne <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = sequence { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) yield(n++) } println(x.take(<span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre><br> 他们用协程说，其他语言中所有很酷的原语（例如yield）都可以作为库函数来完成，因为yield是可以中断的暂停函数。 <br><br> 会发生什么？ <br><br>  a）[1、2、3] <br>  b）[0，1，2] <br>  c）无限循环 <br>  d）以上都不是 <br><br><div class="spoiler">  <b class="spoiler_title">发射！</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/dh/p2/s3/dhp2s3ugmoll1vijctjtmlxgmtm.png"><br><br> 正确的选项是最后一个。 <br><br> 序列是一种懒惰的手段，当我们坚持下去时，它也是懒惰的。 但是，如果您添加toList，那么它将真正打印出[0，1，2]。 <br><br> 正确答案根本与协程无关。 协程确实有效，易于使用。 对于序列和收益函数，您甚至不需要将库与协程连接起来，所有内容都已在标准库中。 <br></div></div><br><h2> 帕兹勒№15 </h2><br>  JetBrains的开发人员也制服了这个难题。 有这样一个地狱般的代码： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> whatAmI = {-&gt;}.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}() println(whatAmI)</code> </pre><br> 当我第一次见到他时，在KotlinConf期间，我无法入睡，我试图了解那是什么。 这样的密码可以用Kotlin编写，因此如果有人认为Scalaz吓人，那么在Kotlin中也可以。 <br><br> 让我们猜测： <br><br>  a）Kotlin.Unit <br>  b）科特林 <br>  c）未编译 <br>  d）以上都不是 <br><br><div class="spoiler">  <b class="spoiler_title">跑吧</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/xy/o_/fkxyo_vljbjpo9gv1lak7ubr_1a.png"><br><br> 我们得到了一个无处可来的部队。 <br><br> 怎么了 首先我们给变量lambda赋值：{-&gt;}-这是有效的代码，您可以编写一个空的lambda。 它没有参数，它什么也不返回。 因此，它返回Unit。 <br><br> 我们为该变量分配一个lambda，然后立即将扩展名写入该lambda，然后运行它。 实际上，它将仅保留Kotlin.Unit。 <br><br> 然后，您可以在此lambda上编写扩展功能： <br><br><pre> <code class="kotlin hljs">.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}</code> </pre><br> 它在Function &lt;*&gt;类型上声明，而我们最上面的内容也适用于它。 实际上是Function &lt;Unit&gt;，但是我没有写出不清楚的Unit。 您知道科特林星号如何工作吗？     ,    Java.    ,    . <br><br>     ,    Unit  {},      ,  void-. ,   ,  .  -,      —   . <br></div></div><br>    .    ,  Kotlin —  .   iOS-     ,    ,   Kotlin   ! <br><blockquote>       Mobius,  :  <b>Mobius</b>  <b>22-23   </b> .   Kotlin    — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> «Coroutining Android Apps»        .        ( Android,   iOS),      —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ,   <b>1 </b>   . <br><br>  :     ,            —  <b>6 </b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>  . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN440974/">https://habr.com/ru/post/zh-CN440974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN440958/index.html">我如何尝试修复地图搜索驱动程序。 第二部分</a></li>
<li><a href="../zh-CN440960/index.html">Orange Pi 2G-IOT：雷区地图</a></li>
<li><a href="../zh-CN440962/index.html">通讯提供商将有义务签订住宅建筑物连接合同</a></li>
<li><a href="../zh-CN440966/index.html">将KELLER传感器连接到MATLAB</a></li>
<li><a href="../zh-CN440972/index.html">Innopolis大学将举办俄罗斯第一所国际自动驾驶汽车设计学校</a></li>
<li><a href="../zh-CN440976/index.html">我扫描了整个奥地利，发现...</a></li>
<li><a href="../zh-CN440978/index.html">无线Wi-Fi可编程房间恒温器，带有空气质量监测器和其他实用功能</a></li>
<li><a href="../zh-CN440980/index.html">2月23日正在等待男人的礼物是什么？ 调查结果</a></li>
<li><a href="../zh-CN440984/index.html">降低获取率将如何影响我们（持卡人）-2</a></li>
<li><a href="../zh-CN440986/index.html">机车：我们对自行式轨道车的了解</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>