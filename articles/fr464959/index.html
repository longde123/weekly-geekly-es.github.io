<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🚀 🤘🏾 🍗 Analyser la phrase de la langue russe 👩🏿‍🤝‍👨🏽 🍞 🧠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article décrit le processus d'analyse de la phrase de la langue russe en utilisant la grammaire sans contexte et l'algorithme d'analyse LR. 

 Le ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyser la phrase de la langue russe</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464959/">  Cet article décrit le processus d'analyse de la phrase de la langue russe en utilisant la grammaire sans contexte et l'algorithme d'analyse LR. <br><br>  <b>Le traitement du langage naturel</b> est la direction générale de l'intelligence artificielle et de la linguistique mathématique.  Il étudie les problèmes d'analyse informatique et de synthèse des langages naturels. <br><br>  En général, le processus d'analyse des phrases en langage naturel est le suivant: (1) la division des phrases en unités syntaxiques - mots et phrases;  (2) détermination des paramètres grammaticaux de chaque unité;  (3) la définition de la relation syntaxique entre les unités.  La sortie est un arbre d'analyse abstrait. <br><a name="habracut"></a><br><h3>  1. Diviser les phrases en unités syntaxiques </h3><br>  Une phrase en langage naturel se compose de formes de mots et de phrases fortes.  Un certain nombre de formes de mots d'un mot donné est appelé un paradigme. <br><br>  Par exemple <br><br><pre><code class="plaintext hljs">  "": [, , , , ,  ]</code> </pre> <br>  Les phrases - conjonctions composées, prédicats ou expressions stables - ne changent pas et ne peuvent pas être décomposées en unités plus petites sans perte de sens.  De plus, par un mot, nous entendons toute unité syntaxique - une forme de mot ou une phrase. <br><br>  Chaque mot d'une phrase est déterminé par un triple: <br><br><ol><li>  forme des mots / chaîne de mots («écrit») </li><li>  forme normale du mot ("écrire") </li><li>  un ensemble de paramètres grammaticaux (['VERBE', 'chanter', 'musc', 'tran', 'passé']) </li></ol><br>  Ainsi, la répartition de la phrase " <i>Clairement, il ne viendra pas à la réunion</i> " sera la suivante: <br><br><pre> <code class="plaintext hljs">[' ', '', '', '', '', '']  ' ' -  , </code> </pre> <br><h3>  2. Définition des paramètres grammaticaux (grammaires) </h3><br>  <b>Un gramme</b> est un élément d'une catégorie grammaticale;  différents grammes de la même catégorie s'excluent mutuellement et ne peuvent être exprimés ensemble.  Pour chaque forme de mot, nous définissons un ensemble de sept grammes: <br><br><pre> <code class="plaintext hljs">[  , , , , , ,  ]</code> </pre> <br>  Comme source, nous utiliserons le dictionnaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenCorpora</a> et son interface, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pymorphy2</a> .  Pour rechercher une règle dans la grammaire pour un ensemble de grammes donné, nous les présenterons sous forme générale: <br><br><pre> <code class="plaintext hljs"> '' [NOUN,plur,neut,accs] -&gt; [NOUN,?numb,?per,?gend,accs,None,None]  '?' ,      </code> </pre> <br><h3>  3. Définition de la relation syntaxique entre les mots </h3><br>  Pour déterminer la relation syntaxique entre les mots, nous utiliserons la grammaire hors contexte et l'analyse LR. <br><br><h4>  Grammaire et analyse LR </h4><br>  <b>La grammaire formelle</b> est une façon de décrire une langue sous la forme de productions dites.  Par exemple: <br><br><pre> <code class="plaintext hljs">a -&gt; ab | ac</code> </pre> <br>  signifie la règle 'a' engendre 'ab' OU 'ac'. <br><br>  <b>Les non-terminaux</b> sont des objets qui dénotent n'importe quelle essence du langage (phrase, formule, etc.).  <b>Terminaux</b> - objets directement présents dans la langue correspondant à la grammaire et ayant une signification spécifique et immuable (lettres, mots, formules, etc.).  Les grammaires sans contexte sont des grammaires dans lesquelles les côtés gauche de tous les produits sont des non-terminaux uniques. <br><br>  Pour décrire la langue russe, nous utiliserons la théorie de la grammaire des composants ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">grammaire de structure de phrases</a> ), qui prétend que toute unité grammaticale complexe se compose de deux unités plus simples et sans intersection, appelées ses composantes immédiates.  Les composants suivants sont distingués: <br><br>  <b>(1) Groupe nominal (NP)</b> <br><br><pre> <code class="plaintext hljs">NP[case='nomn'] -&gt; N[case='nomn'] | ADJ[case='nomn'] NP[case='nomn'] | …</code> </pre> <br>  C'est-à-dire qu'une expression nominale nominative est un substantif dans le cas nominatif OU un adjectif dans le cas nominatif + une expression nominale nominative OU une autre. <br><br>  <b>(2) Groupe verbal (VP)</b> <br><br><pre> <code class="plaintext hljs">VP[tran] -&gt; V[tran] NP[case='ablt'] | ADJ VP[tran] | …</code> </pre> <br>  En d'autres termes, un groupe de verbes transitifs est un verbe transitif + un groupe de noms ablatifs OU un adjectif court + un groupe de verbes transitifs OU un autre. <br><br>  <b>(3) Groupe prépositionnel (PP)</b> <br><br><pre> <code class="plaintext hljs"> PP -&gt; PREP NP[case='datv'] | ...</code> </pre> <br>  Un groupe prépositionnel est une préposition + un groupe datif nominal OU un autre. <br><br>  <b>(4) Offre complète (S)</b> <br><br><pre> <code class="plaintext hljs">S -&gt; NP[case='nomn'] VP[tran]</code> </pre><br>  Une phrase complète existe si et seulement si les groupes de noms et de verbes sont appariés en nombre, personne et sexe. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">agreement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node_left, node_right)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numb1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> numb2): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numb1 != numb2): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (per1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> per2): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (per1 != per2): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gend1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> gend2): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gend1 != gend2): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>;</code> </pre><br>  Une phrase incomplète est une phrase où la partie nominale est omise.  En règle générale, dans de telles phrases, le groupe de verbes est exprimé par un verbe impersonnel.  Par exemple, « <i>je veux marcher</i> », «il fait <i>jour</i> ».  Une phrase elliptique est une phrase où la partie verbale est omise, elle est remplacée par un tiret.  Par exemple, " <i>Derrière le dos est une forêt. À droite et à gauche se trouvent des marécages</i> ." <br><br>  Afin de déterminer si cette phrase appartient au langage grammatical, nous utiliserons l'algorithme d'analyse LR.  Cet algorithme implique la construction d'un arbre d'analyse de bas en haut (des feuilles à la racine).  L'élément clé de l'algorithme est la méthode de "transfert-convolution" (anglais <i>shift-réduire</i> ): <br><br>  (1) nous lisons les caractères de la ligne d'entrée jusqu'à ce qu'il y ait une chaîne qui correspond au côté droit de certaines des règles, mettons la chaîne trouvée dans la pile (transfert); <br>  (2) remplacer la chaîne trouvée par la règle de la grammaire (convolution). <br><br>  Si toutes les chaînes de chaînes ont été encapsulées, cette phrase appartient au langage de grammaire et il existe au moins un arbre d'analyse. <br><br>  <b>Arbre</b> <br><br>  Pour représenter la connexion syntaxique, la phrase utilise un arbre binaire, où les feuilles sont des mots (terminaux) avec un ensemble de grammes, et les nœuds sont des règles (pré-terminaux).  La racine est la phrase (non terminale). <br><br>  Un nœud d'arbre est défini comme suit: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, word=None, tag=None, grammemes=None, leaf=False)</span></span></span><span class="hljs-function">:</span></span> self.word = word; <span class="hljs-comment"><span class="hljs-comment">#   self.tag = tag; #   - ,      self.grammemes = grammemes; #   self.leaf = leaf; self.l = None; self.r = None; self.p = None;</span></span></code> </pre><br>  La construction d'un arbre commence par les feuilles, auxquelles on assigne une chaîne de mots ou de phrases, ainsi qu'un ensemble de ses grammes. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, sent)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sent: new_node = Node(word[<span class="hljs-number"><span class="hljs-number">0</span></span>], word[<span class="hljs-number"><span class="hljs-number">1</span></span>], word[<span class="hljs-number"><span class="hljs-number">2</span></span>], leaf=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) self.nodes.append(new_node)</code> </pre> <br>  Ensuite, l'analyse LR est effectuée.  Chaque convolution correspond à l'union de deux nœuds ou feuilles sous un ancêtre commun.  Un nœud ancêtre se voit attribuer une balise pré-terminale qui correspond à la règle de grammaire, en outre, l'ancêtre accepte les grammaires du membre principal du groupe, par exemple, dans le groupe de verbes V [tran] PRCL (par exemple <i>"aimerait"</i> ) les signes seront tirés du verbe transitif V [tran], et pas d'une particule de PRCL;  et dans le groupe de noms NP [case = 'nomn'] NP [case = 'gent'] (par exemple <i>"père d'enfants"</i> ), les signes seront tirés du nom dans le nominatif. <br><br>  Il est important de noter que la convolution se produit dans l'ordre établi: <br><br><pre> <code class="plaintext hljs"> def reduce(self): self.reduce_ADJ() #  self.reduce_NP() #   self.reduce_PP() #  self.reduce_VP() #  self.reduce_S() #    </code> </pre><br>  Cet ordre est important car il exclut la possibilité de «rater» certains membres de la proposition.  Tout d'abord, les adjectifs sont formés avec des modificateurs (par exemple <i>incroyablement beaux</i> ), puis des groupes nominaux, prépositionnels et enfin verbaux.  Après cela, il y a une recherche de phrases complètes / incomplètes, s'il n'y en a pas, alors l'arbre n'a pas de racine, et donc la phrase n'appartient pas au langage de grammaire. <br><br>  Prenons un exemple conditionnel de construction d'un arbre: <br><br><pre> <code class="plaintext hljs">sent = "    " def build(self, sent): for word in sent: new_node = Node(word[0], word[1], word[2], leaf=True) self.nodes.append(new_node)</code> </pre><br><img src="https://habrastorage.org/webt/dv/os/q2/dvosq2enl-vsvwnoif2ikvwspqw.png"><br><br><pre> <code class="plaintext hljs">NP[case='nomn'] -&gt; NPRO[case='nomn'] NP[case='accs'] -&gt; N[case='accs'] NP[case='datv'] -&gt; ADJ[case='datv'] NP[case='datv']</code> </pre> <br><img src="https://habrastorage.org/webt/zo/dp/3i/zodp3iqmbp3-v7mheec_rd2d_gy.png"><br><br><pre> <code class="plaintext hljs">VP[tran] -&gt; V[tran] NP[case='accs']</code> </pre> <br><img src="https://habrastorage.org/webt/ez/9a/jk/ez9ajkpo58rfxtnsqt3o0ij2las.png"><br><br><pre> <code class="plaintext hljs">VP[tran] -&gt; VP[tran] NP[case='datv']</code> </pre> <br><img src="https://habrastorage.org/webt/w3/0y/m_/w30ym_ey2ehicxufasvky3vml4w.png"><br><br><pre> <code class="plaintext hljs">S -&gt; NP[case='nomn'] VP[tran]</code> </pre> <br><img src="https://habrastorage.org/webt/wg/f_/xw/wgf_xw3qoj9dhpk8nvhjztzhqlu.png"><br><br>  Un exemple spécifique d'analyse d'une phrase en deux parties: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> analyzer parser = analyzer.Parser() sent = <span class="hljs-string"><span class="hljs-string">"  ,     ."</span></span> t = parser.parse(sent) t[<span class="hljs-number"><span class="hljs-number">0</span></span>].display() S NP[case=<span class="hljs-string"><span class="hljs-string">'nomn'</span></span>]  [<span class="hljs-string"><span class="hljs-string">'NOUN'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'femn'</span></span>, <span class="hljs-string"><span class="hljs-string">'nomn'</span></span>] VP[tran] VP[tran]  [<span class="hljs-string"><span class="hljs-string">'VERB'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'3per'</span></span>, <span class="hljs-string"><span class="hljs-string">'tran'</span></span>, <span class="hljs-string"><span class="hljs-string">'pres'</span></span>] NP[case=<span class="hljs-string"><span class="hljs-string">'datv'</span></span>]  [<span class="hljs-string"><span class="hljs-string">'NOUN'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'datv'</span></span>] S NP[case=<span class="hljs-string"><span class="hljs-string">'nomn'</span></span>]  [<span class="hljs-string"><span class="hljs-string">'NOUN'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'femn'</span></span>, <span class="hljs-string"><span class="hljs-string">'nomn'</span></span>] VP[tran] PP PREP  [<span class="hljs-string"><span class="hljs-string">'PREP'</span></span>] NP[case=<span class="hljs-string"><span class="hljs-string">'ablt'</span></span>]  [<span class="hljs-string"><span class="hljs-string">'NOUN'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'femn'</span></span>, <span class="hljs-string"><span class="hljs-string">'ablt'</span></span>] VP[tran]  [<span class="hljs-string"><span class="hljs-string">'VERB'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'3per'</span></span>, <span class="hljs-string"><span class="hljs-string">'tran'</span></span>, <span class="hljs-string"><span class="hljs-string">'pres'</span></span>]</code> </pre> <br><h3>  Les problèmes </h3><br>  Le langage naturel est ambigu, sa compréhension dépend d'un certain nombre de facteurs - des caractéristiques de la structure grammaticale de la langue, de la culture nationale, du locuteur, etc.  Nous listons les principaux problèmes du traitement en langage machine. <br><br><ol><li>  Divulgation de l'anaphore.  Une personne vivante comprend une anaphore basée sur le bon sens et le contexte, mais pour un ordinateur, ce n'est évidemment pas toujours facile. </li><li>  L'homonymie est une coïncidence dans le son et l'orthographe des unités linguistiques dont les significations ne sont pas liées les unes aux autres.  Une solution est les méthodes probabilistes.  Dans la phrase « <i>Je le sais bien</i> », la probabilité que « <i>ceci</i> » soit un pronom et non une particule sera plus grande.  De telles méthodes nécessitent une enceinte suffisamment grande. </li><li>  L'ordre libre des mots conduit au fait que l'interprétation de la phrase peut être ambiguë.  Par exemple, «L' <i>être détermine la conscience</i> » - qu'est-ce qui détermine quoi?  En russe, l'ordre des mots libres est compensé par une morphologie développée, des mots de service et des signes de ponctuation, mais dans la plupart des cas pour l'ordinateur, cela pose un problème supplémentaire. </li><li>  Tout le monde n'écrit pas correctement.  Sur le net, les gens ont tendance à utiliser des abréviations, des néologismes, des ellipses et d'autres choses qui peuvent contredire la norme littéraire.  Pour cette raison, l'utilisation de grammaires et de dictionnaires sans contexte n'est pas toujours possible. </li></ol><br><h4>  Conclusion </h4><br>  Le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est disponible</a> pour utilisation et modification.  Il contient l'analyseur lui-même, l'arbre d'analyse, ainsi que la grammaire russe et la grammaire de la langue russe et un petit dictionnaire des unions composées et des prédicats qui ne sont pas dans le dictionnaire OpenCorpora.  À l'heure actuelle, pour les phrases longues et complexes, l'analyseur peut trouver 3 arbres ou plus, pour résoudre ce problème, des modifications sont apportées à la grammaire, et il est également prévu d'utiliser des méthodes probabilistes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464959/">https://habr.com/ru/post/fr464959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464939/index.html">Test des annotations @ NonNull / @ Nullable</a></li>
<li><a href="../fr464947/index.html">Événements numériques à Moscou du 25 août au 1er septembre</a></li>
<li><a href="../fr464949/index.html">Encore une fois sur GCD, l'algorithme euclidien et un peu sur l'histoire des algorithmes en général. Bien sûr, avec des exemples Swift</a></li>
<li><a href="../fr464951/index.html">Plus la tâche est simple, plus je me trompe souvent</a></li>
<li><a href="../fr464955/index.html">Iron Mike Tyson et le projet de blockchain Fight to Fame</a></li>
<li><a href="../fr464961/index.html">Créez des composants visuels dans l'interface utilisateur Unity. Système de particules</a></li>
<li><a href="../fr464963/index.html">Localisez rapidement les problèmes de performances de Microsoft SQL Server dans Quest Foglight</a></li>
<li><a href="../fr464965/index.html">Frontend Weekly Digest (19-25 août 2019)</a></li>
<li><a href="../fr464967/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 377 (19-25 août 2019)</a></li>
<li><a href="../fr464969/index.html">CRISPR vous donne la possibilité de sauver une personne de la douleur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>