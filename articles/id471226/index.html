<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â—¼ï¸ ğŸ‘©ğŸ¾â€ğŸš€ ğŸ‘´ Linux memiliki banyak wajah: cara bekerja pada distribusi apa pun â„¹ï¸ ğŸ¥ â™ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Membuat aplikasi cadangan yang berjalan pada distribusi apa pun bukanlah tugas yang mudah. Untuk memastikan bahwa Veeam Agent untuk Linux berjalan pad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux memiliki banyak wajah: cara bekerja pada distribusi apa pun</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/471226/"><img src="https://habrastorage.org/webt/ry/zz/2e/ryzz2enp795e4whkxs9rgxbmwsm.jpeg"><br><br>  Membuat aplikasi cadangan yang berjalan pada distribusi apa pun bukanlah tugas yang mudah.  Untuk memastikan bahwa Veeam Agent untuk Linux berjalan pada distribusi dari RHEL 6 dan Debian 6, openSUSE Leap 15.1 dan Ubuntu 19.04 harus menyelesaikan berbagai masalah, terutama ketika Anda menganggap bahwa modul kernel adalah bagian dari produk perangkat lunak. <br><br>  Artikel ini didasarkan pada presentasi di konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LinuxPiter 2019</a> . <br><a name="habracut"></a><br>  Linux bukan hanya salah satu OS yang paling populer.  Sebenarnya, ini adalah platform yang di atasnya Anda dapat melakukan sesuatu yang unik, sesuatu milik Anda.  Karena itu, Linux memiliki banyak distribusi yang berbeda dalam satu set komponen perangkat lunak.  Dan di sini muncul masalah: agar produk perangkat lunak berfungsi pada distribusi apa pun, Anda harus memperhitungkan karakteristik masing-masing. <br><br><h2>  Manajer paket.  .deb vs .rpm </h2><br>  Mari kita mulai dengan masalah yang jelas dalam mendistribusikan produk untuk distribusi yang berbeda. <br>  Cara paling umum untuk mendistribusikan produk perangkat lunak adalah dengan meletakkan paket pada repositori sehingga manajer paket yang dibangun ke dalam sistem dapat menginstalnya dari sana. <br>  Namun, kami memiliki dua format paket populer: <i>rpm</i> dan <i>deb</i> .  Jadi, semua orang harus mendukung. <br><br>  Dalam dunia paket deb, tingkat kompatibilitasnya luar biasa.  Paket yang sama menginstal dengan baik dan bekerja pada Debian 6 dan Ubuntu 19.04.  Standar untuk proses membangun paket dan bekerja dengannya, ditetapkan dalam distribusi Debian lama, tetap relevan dalam Linux Mint dan OS dasar.  Oleh karena itu, dalam kasus Veeam Agent untuk Linux, satu paket deb untuk setiap platform perangkat keras sudah cukup. <br><br>  Namun dalam dunia paket rpm, perbedaannya besar.  Pertama, karena ada dua distributor Red Hat dan SUSE yang sepenuhnya independen, yang kompatibilitasnya sama sekali tidak diperlukan.  Kedua, distributor ini memiliki distribusi dari mereka.  dukungan dan eksperimental.  Di antara mereka, kompatibilitas juga tidak diperlukan.  Ternyata untuk el6, el7 dan el8 paket mereka sendiri.  Paket terpisah untuk Fedora.  Paket untuk SLES11 dan 12 dan terpisah untuk openSUSE.  Masalah utama adalah dependensi dan nama paket. <br><br><h2>  Masalah ketergantungan </h2><br>  Sayangnya, paket yang sama sering berakhir dengan nama yang berbeda dalam distribusi yang berbeda.  Di bawah ini adalah sebagian daftar dependensi paket veeam. <br><div class="scrollable-table"><table><tbody><tr><th>  Untuk EL7: </th><th>  Untuk SLES 12: </th></tr><tr><td><ul><li>  libblkid </li><li>  libgcc </li><li>  libstdc ++ </li><li>  ncurses-libs </li><li>  fuse-libs </li><li>  file-libs </li><li>  veeamsnap = 3.0.2.1185 </li></ul></td><td><ul><li>  libblkid1 </li><li>  libgcc_s1 </li><li>  libstdc ++ 6 </li><li>  libmagic1 </li><li>  libfuse2 </li><li>  veeamsnap-kmp = 3.0.2.1185 </li></ul></td></tr></tbody></table></div><br>  Akibatnya, daftar dependensi unik untuk distribusi. <br><br>  Semakin buruk ketika versi yang diperbarui mulai bersembunyi di bawah nama paket lama. <br><br>  <b>Contoh:</b> <br><br>  Fedora 24 telah memperbarui paket <i>ncurses</i> dari versi 5 ke versi 6. Produk kami dibuat dengan versi 5 untuk memastikan kompatibilitas dengan distribusi yang lebih lama.  Untuk menggunakan perpustakaan versi ke-5 di Fedora 24, saya harus menggunakan paket <i>ncurses-compat-libs</i> . <br><br>  Akibatnya, dua paket muncul untuk Fedora, dengan dependensi berbeda. <br><br>  Lebih menarik.  Setelah pembaruan berikutnya dari paket distribusi, paket <i>ncurses-compat-libs</i> dengan versi 5 perpustakaan tidak tersedia.  Tidak menguntungkan bagi distributor untuk menarik perpustakaan lama ke versi distribusi baru.  Setelah beberapa waktu, masalahnya terulang dalam distribusi SUSE. <br><br>  Akibatnya, untuk beberapa distribusi, saya harus meninggalkan ketergantungan eksplisit pada <i>ncurses-libs</i> , dan memperbaiki produk sehingga dapat bekerja dengan versi perpustakaan apa pun. <br><br>  Ngomong-ngomong, dalam Red Hat versi ke-8 tidak ada lagi paket meta <i>python</i> yang merujuk pada <i>python 2.7 yang bagus</i> .  Ada <i>python2</i> dan <i>python</i> 3. <br><br><h2>  Alternatif untuk manajer paket </h2><br>  Masalah dengan ketergantungan sudah lama dan sudah jelas.  Hanya ingat neraka Ketergantungan. <br>  Gabungkan berbagai pustaka dan aplikasi sehingga semuanya bekerja secara stabil dan tidak bertentangan - pada kenyataannya, distributor Linux mana pun berusaha menyelesaikan masalah ini. <br><br>  Manajer paket Canonical, <b>Snappy,</b> mencoba menyelesaikan masalah ini dengan sangat berbeda.  Gagasan utama: aplikasi berjalan di kotak pasir yang terisolasi dan dilindungi dari sistem utama.  Jika aplikasi membutuhkan pustaka, maka mereka dikirim dengan aplikasi itu sendiri. <br><br>  <b>Flatpak</b> juga memungkinkan Anda menjalankan aplikasi di kotak pasir menggunakan Linux Containers.  Ada juga <b>AppImage</b> , yang memungkinkan Anda membuat gambar program yang portabel. <br><br>  Solusi ini memungkinkan Anda membuat satu paket untuk distribusi apa pun.  Dalam hal <b>Flatpak</b> dan <b>AppImage</b> <b>,</b> instalasi dan peluncuran aplikasi dimungkinkan bahkan tanpa sepengetahuan administrator. <br><br>  Masalah utama adalah bahwa tidak semua aplikasi dapat berjalan di sandbox dan tanpa hak akses <i>root</i> .  Beberapa membutuhkan akses langsung ke platform.  Saya tidak berbicara tentang modul kernel, yang sangat tergantung pada kernel dan tidak cocok dengan konsep sandbox. <br><br>  Masalah kedua adalah bahwa distribusi populer dari Red Hat dan SUSE di lingkungan perusahaan belum mendukung Snappy dan Flatpak. <br><br>  Dalam hal ini, Veeam Agent untuk Linux tidak ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">snapcraft.io</a> atau di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">flathub.org</a> . <br><br>  Di akhir pertanyaan tentang manajer paket, saya perhatikan bahwa ada opsi untuk sepenuhnya mengabaikan manajer paket dengan menggabungkan file biner dan skrip untuk menginstalnya dalam satu paket. <br><br>  Bundel semacam itu memungkinkan Anda untuk membuat satu paket umum untuk berbagai distribusi dan platform, untuk melakukan proses instalasi interaktif, melakukan penyesuaian yang diperlukan.  Saya menemukan paket seperti itu untuk Linux hanya dari VMware. <br><br><h2>  Perbarui masalah </h2><br><img src="https://habrastorage.org/webt/ny/8c/-k/ny8c-kdpc74mgrym0nszgkd0d04.png"><br>  Bahkan jika semua masalah ketergantungan diselesaikan, program dapat bekerja secara berbeda pada distribusi yang sama.  Intinya ada di pembaruan. <br><br>  Ada 3 strategi peningkatan: <br><br><ul><li>  Yang termudah adalah tidak pernah memperbarui.  Mengkonfigurasi server dan lupa.  Mengapa diperbarui jika semuanya berfungsi?  Masalah mulai saat pertama kali Anda menghubungi dukungan.  Pembuat distribusi hanya mendukung rilis yang diperbarui. </li><li>  Anda dapat mempercayai distributor dan mengatur pembaruan otomatis.  Dalam hal ini, panggilan untuk mendukung kemungkinan segera setelah pembaruan yang gagal. </li><li>  Pilihan untuk memperbarui secara manual hanya setelah menjalankannya pada infrastruktur pengujian adalah yang paling setia, tetapi mahal dan memakan waktu.  Tidak semua orang mampu membelinya. </li></ul><br>  Karena pengguna yang berbeda menggunakan strategi pembaruan yang berbeda, Anda perlu mendukung rilis terbaru dan semua yang dirilis sebelumnya.  Ini mempersulit proses pengembangan, dan proses pengujian, menambah sakit kepala ke layanan dukungan. <br><br><h2>  Berbagai platform perangkat keras </h2><br>  Berbagai platform perangkat keras adalah masalah yang sebagian besar khusus untuk kode asli.  Minimal, Anda harus mengumpulkan binari untuk setiap platform yang didukung. <br><br>  Dalam proyek Veeam Agent untuk Linux, kami masih tidak dapat mendukung setidaknya sesuatu seperti RISC. <br><br>  Saya tidak akan membahas masalah ini secara rinci.  Saya hanya akan menguraikan masalah utama: tipe yang bergantung pada platform seperti <code>size_t</code> , perataan struktur, dan urutan byte. <br><br><h2>  Statis dan / atau tautan dinamis </h2><br><img src="https://habrastorage.org/webt/x7/im/9v/x7im9v9gtvi7lkwmodbajd0au_g.jpeg"><br>  Dan di sini ada pertanyaan "Bagaimana menautkan ke perpustakaan - secara dinamis atau statis?"  layak didiskusikan. <br><br>  Biasanya, aplikasi Linux C / C ++ menggunakan tautan dinamis.  Ini berfungsi baik jika aplikasi dibangun khusus untuk distribusi tertentu. <br><br>  Jika tugasnya adalah untuk menutupi berbagai distribusi dengan satu file biner, maka Anda harus fokus pada distribusi tertua yang didukung.  Bagi kami, ini Red Hat 6. Ini berisi gcc 4.4, yang bahkan standar C ++ 11 tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sepenuhnya</a> mendukung. <br><br>  Kami sedang membangun proyek kami menggunakan gcc 6.3, yang sepenuhnya mendukung C ++ 14.  Secara alami, dalam kasus ini di Red Hat 6 libstdc ++ dan boost library harus diseret.  Cara termudah untuk menautkannya adalah secara statis. <br><br>  Namun sayang, tidak semua perpustakaan dapat dihubungkan secara statis. <br><br>  Pertama, pustaka sistem, seperti <i>libfuse</i> , <i>libblkid,</i> perlu dihubungkan secara dinamis untuk memastikan bahwa mereka kompatibel dengan kernel dan modul-modulnya. <br><br>  Kedua, ada kehalusan dengan lisensi. <br><br>  Lisensi GPL pada dasarnya memungkinkan menghubungkan perpustakaan hanya dengan kode opensource.  MIT dan BSD memungkinkan tautan statis dan memungkinkan perpustakaan untuk dimasukkan dalam proyek.  Tetapi LGPL tampaknya tidak bertentangan dengan tautan statis, tetapi membutuhkan pembagian file yang diperlukan untuk menghubungkan. <br><br>  Secara umum, penggunaan tautan dinamis akan melindungi terhadap kebutuhan untuk menyediakan sesuatu. <br><br><h2>  Membangun Aplikasi C / C ++ </h2><br>  Untuk membangun aplikasi C / C ++ untuk berbagai platform dan distribusi, cukup memilih atau mengkompilasi versi gcc yang sesuai dan menggunakan lintas-kompiler untuk arsitektur tertentu, untuk mengumpulkan seluruh rangkaian perpustakaan.  Pekerjaan ini cukup layak, tetapi agak merepotkan.  Dan tidak ada jaminan bahwa kompiler dan perpustakaan yang dipilih akan memberikan opsi yang bisa diterapkan. <br><br>  Nilai tambah yang jelas: infrastrukturnya sangat disederhanakan, karena seluruh proses perakitan dapat dilakukan pada satu mesin.  Selain itu, cukup mengumpulkan satu set file biner untuk satu arsitektur dan Anda dapat mengemasnya ke dalam paket untuk distribusi yang berbeda.  Ini adalah bagaimana paket veeam untuk Veeam Agent untuk Linux dibangun. <br><br>  Berbeda dengan opsi ini, Anda cukup menyiapkan farm build, yaitu, beberapa mesin untuk perakitan.  Setiap mesin tersebut akan menyediakan kompilasi aplikasi dan perakitan paket untuk distribusi tertentu dan arsitektur tertentu.  Dalam hal ini, kompilasi dilakukan dengan cara yang telah disiapkan distributor.  Artinya, tahap persiapan kompiler dan pemilihan perpustakaan tidak lagi diperlukan.  Selain itu, proses perakitan dapat dengan mudah diparalelkan. <br><br>  Namun, ada minus untuk pendekatan ini: untuk setiap distribusi dalam arsitektur yang sama, Anda harus merakit set file biner Anda sendiri.  Yang juga minus adalah bahwa begitu banyak mesin perlu dipertahankan, untuk mengalokasikan sejumlah besar ruang disk dan RAM. <br><br>  Dengan demikian, paket KMOD dari modul kernel veeamsnap untuk distribusi Red Hat dikumpulkan. <br><br><h2>  Layanan build terbuka </h2><br>  Rekan SUSE mencoba mengimplementasikan jalan tengah sebagai layanan khusus untuk mengompilasi aplikasi dan membangun paket - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">openbuildservice</a> . <br><br>  Intinya, ini adalah hypervisor yang menciptakan mesin virtual, menginstal semua paket yang diperlukan di dalamnya, mengkompilasi aplikasi dan mengkompilasi paket dalam lingkungan yang terisolasi ini, setelah itu mesin virtual seperti itu dibebaskan. <br><br><img src="https://habrastorage.org/webt/y0/4p/uy/y04puyokz_w-fexue3zcgpvhcgc.png"><br><br>  Penjadwal yang diimplementasikan dalam OpenBuildService akan menentukan berapa banyak mesin virtual yang dapat dijalankan untuk kecepatan pembuatan paket yang optimal.  Mekanisme tanda tangan built-in itu sendiri akan menandatangani paket dan menempatkannya di repositori built-in.  Sistem kontrol versi bawaan akan menyimpan riwayat perubahan dan rakitan.  Tetap menambahkan kode sumber Anda ke sistem ini.  Bahkan server itu sendiri tidak perlu dinaikkan, tetapi Anda dapat menggunakan yang terbuka. <br><br>  Namun, di sini ada masalah: penggabungan seperti itu sulit masuk ke infrastruktur yang ada.  Misalnya, kontrol versi tidak diperlukan, kami sudah memiliki sumbernya sendiri.  Mekanisme tanda tangan berbeda: server khusus digunakan.  Repositori juga tidak diperlukan. <br><br>  Selain itu, dukungan untuk distribusi lain - misalnya, Red Hat - dilaksanakan agak buruk, yang dapat dimengerti. <br><br>  Keuntungan dari layanan ini adalah dukungan cepat dari versi distribusi SUSE berikutnya.  Sebelum pengumuman rilis resmi, paket yang diperlukan untuk perakitan diunggah ke repositori publik.  Yang baru muncul dalam daftar distribusi yang tersedia di OpenBuildService.  Kami memberi tanda centang dan ditambahkan ke rencana perakitan.  Dengan demikian, menambahkan versi baru distribusi dilakukan di hampir satu klik. <br><br>  Dalam infrastruktur kami, menggunakan OpenBuildService, kami mengumpulkan seluruh paket KMP dari modul kernel veeamsnap untuk distribusi SUSE. <br><br>  Lebih lanjut, saya ingin membahas masalah-masalah khusus untuk modul kernel. <br><br><h2>  kernel ABI </h2><br>  Modul kernel Linux secara historis telah didistribusikan dalam bentuk sumber.  Faktanya adalah bahwa pencipta kernel tidak membebani diri mereka sendiri dengan hati-hati memelihara API yang stabil untuk modul-modul kernel, dan terlebih lagi pada tingkat biner, kemudian kABI. <br><br>  Untuk membangun modul untuk kernel vanilla, header dari kernel khusus ini diperlukan, dan itu hanya akan berfungsi pada core ini. <br><br>  DKMS memungkinkan Anda untuk mengotomatiskan proses perakitan modul saat memperbarui kernel.  Akibatnya, pengguna repositori Debian (dan banyak kerabatnya) menggunakan modul kernel baik dari repositori distributor atau dikumpulkan dari sumber menggunakan DKMS. <br><br>  Namun, situasi ini tidak terlalu nyaman dengan segmen Enterprise.  Distributor kode kepemilikan ingin mendistribusikan produk dalam bentuk binari terkompilasi. <br><br>  Administrator tidak ingin menyimpan alat pengembangan di server produksi untuk alasan keamanan.  Distributor Enterprise Linux - seperti Red Hat dan SUSE - telah memutuskan bahwa mereka dapat mempertahankan kABI yang stabil untuk para penggunanya.  Akibatnya, paket KMOD untuk Red Hat dan paket KMP untuk SUSE muncul. <br><br>  Inti dari solusi ini cukup sederhana.  API kernel dibekukan untuk versi distribusi tertentu.  Distributor menyatakan bahwa ia menggunakan kernel, misalnya, 3.10, dan hanya membuat perbaikan dan perbaikan yang tidak mempengaruhi antarmuka kernel dengan cara apa pun, dan modul yang dirakit untuk kernel pertama dapat digunakan untuk semua yang berikutnya tanpa kompilasi ulang. <br><br>  Red Hat mengumumkan kompatibilitas kABI untuk distribusi sepanjang siklus hidup.  Artinya, modul yang dirakit untuk rhel 6.0 (rilis November 2010) juga harus berfungsi pada versi 6.10 (rilis Juni 2018).  Dan ini hampir 8 tahun.  Tentu, tugasnya agak rumit. <br>  Kami mencatat beberapa kasus ketika, karena masalah dengan kompatibilitas KABI, modul veeamsnap berhenti bekerja. <br><br>  Setelah modul veeamsnap yang dikompilasi untuk RHEL 7.0 ternyata tidak kompatibel dengan kernel dari RHEL 7.5, tetapi itu dimuat dan dijamin untuk menjatuhkan server, kami menolak untuk menggunakan kompatibilitas kABI untuk RHEL 7 secara umum. <br><br>  Saat ini, paket KMOD untuk RHEL 7 berisi perakitan untuk setiap versi rilis dan skrip yang menyediakan pemuatan modul. <br><br>  SUSE mendekati tugas kompatibilitas kABI lebih hati-hati.  Mereka menyediakan kompatibilitas kABI hanya dalam satu paket layanan. <br><br>  Sebagai contoh, rilis SLES 12 terjadi pada bulan September 2014. Dan SLES 12 SP1 sudah pada bulan Desember 2015, yaitu, sedikit lebih dari setahun telah berlalu.  Meskipun kedua rilis menggunakan kernel 3,12, mereka tidak kompatibel dengan kABI.  Jelas, menjaga kompatibilitas KABI hanya selama satu tahun jauh lebih mudah.  Siklus pembaruan modul inti tahunan tidak boleh menyebabkan masalah bagi pembuat modul. <br><br>  Sebagai akibat dari kebijakan SUSE ini, kami tidak memperbaiki masalah dengan kompatibilitas kABI dalam modul veeamsnap kami.  Benar, jumlah paket untuk SUSE hampir merupakan urutan besarnya lebih besar. <br><br><h2>  Tambalan dan backport </h2><br>  Terlepas dari kenyataan bahwa distributor berusaha untuk memastikan kompatibilitas kABI dan stabilitas kernel, mereka juga berusaha untuk meningkatkan kinerja dan menghilangkan cacat pada kernel stabil ini. <br><br>  Selain itu, di samping "work on error" mereka sendiri, para pengembang dari kernel perusahaan linux melacak perubahan pada kernel vanilla dan mentransfernya ke yang "stabil". <br><br>  Terkadang ini menyebabkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesalahan</a> baru. <br><br>  Rilis terbaru Red Hat 6 membuat kesalahan dalam salah satu pembaruan kecil.  Itu mengarah pada fakta bahwa modul veeamsnap dijamin akan merusak sistem ketika snapshot dirilis.  Dengan membandingkan sumber kernel sebelum dan setelah pembaruan, kami menemukan bahwa backport yang harus disalahkan.  Perbaikan serupa dibuat di kernel vanilla versi 4.19.  Tapi hanya di core vanilla, perbaikan ini bekerja dengan baik, dan ketika mentransfernya ke "stable" 2.6.32, ada masalah dengan spin-lock. <br><br>  Tentu saja, semua orang selalu memiliki kesalahan, tetapi apakah itu layak menyeret kode dari 4,19 menjadi 2,6,32, mempertaruhkan stabilitas? .. Saya tidak yakin ... <br><br>  Yang terburuk, ketika pemasaran dikaitkan dengan tarik-menarik "stabilitas" perang &lt;-&gt; "modernisasi".  Departemen pemasaran membutuhkan inti dari distribusi yang diperbarui agar stabil, di satu sisi, dan pada saat yang sama menjadi lebih baik dalam kinerja dan memiliki fitur-fitur baru.  Ini mengarah pada kompromi aneh. <br><br>  Ketika saya mencoba membangun modul pada kernel 4.4 dari SLES 12 SP3, saya terkejut menemukan fungsionalitas dari vanilla 4.8 di dalamnya.  Menurut pendapat saya, implementasi blok I / O dari kernel 4.4 dari SLES 12 SP3 lebih seperti kernel 4.8 daripada rilis kernel 4.4 yang stabil sebelumnya dari SLES12 SP2.  Saya tidak dapat menilai berapa persen kode yang ditransfer dari kernel 4.8 ke SLES 4.4 untuk SP3, tetapi saya masih tidak memiliki kesempatan untuk memanggil kernel dengan stable 4.4 yang sama. <br><br>  Hal yang paling tidak menyenangkan tentang hal ini adalah ketika menulis modul yang bekerja dengan baik pada core yang berbeda, Anda tidak dapat lagi mengandalkan versi kernel.  Kami juga harus memperhitungkan distribusi.  Sangat baik bahwa kadang-kadang Anda dapat terlibat dalam definisi yang muncul bersama dengan fungsionalitas baru, tetapi fitur ini tidak selalu muncul. <br><br>  Akibatnya, kode dikelilingi oleh arahan mewah untuk kompilasi bersyarat. <br><br>  Ada juga tambalan yang mengubah API kernel yang didokumentasikan. <br>  Saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kit</a> distribusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KDE neon</a> 5.16 dan sangat terkejut melihat bahwa panggilan lookup_bdev dalam versi kernel ini mengubah daftar parameter input. <br><br>  Untuk berkumpul, kami harus menambahkan skrip di makefile yang memeriksa apakah fungsi lookup_bdev memiliki parameter mask. <br><br><h2>  Tanda tangan modul kernel </h2><br>  Namun kembali ke masalah distribusi paket. <br><br>  Salah satu keuntungan dari stabil kABI adalah bahwa modul kernel dapat ditandatangani sebagai file biner.  Dalam hal ini, pengembang dapat memastikan bahwa modul itu tidak sengaja rusak atau sengaja diubah.  Anda dapat memeriksa ini dengan perintah modinfo. <br><br>  Distribusi Red Hat dan SUSE memungkinkan Anda memverifikasi tanda tangan modul dan mengunduhnya hanya jika sertifikat yang sesuai terdaftar dalam sistem.  Sertifikat adalah kunci publik tempat modul ditandatangani.  Kami mendistribusikannya sebagai paket terpisah. <br><br>  Masalahnya di sini adalah bahwa sertifikat dapat dibangun ke dalam kernel (mereka digunakan oleh distributor), atau harus ditulis ke memori EFI yang tidak mudah menguap menggunakan utilitas <i>mokutil</i> .  Saat memasang sertifikat, utilitas <i>mokutil</i> memerlukan reboot sistem dan bahkan sebelum kernel sistem operasi dimuat, ia menawarkan administrator untuk mengizinkan pengunduhan sertifikat baru. <br><br>  Jadi, menambahkan sertifikat memerlukan akses fisik administrator ke sistem.  Jika mesin terletak di suatu tempat di cloud atau hanya di ruang server jauh dan akses hanya melalui jaringan (misalnya, melalui ssh), maka tidak mungkin untuk menambahkan sertifikat. <br><br><h2>  EFI di mesin virtual </h2><br>  Terlepas dari kenyataan bahwa EFI telah lama didukung oleh hampir semua pencipta motherboard, ketika menginstal sistem, administrator mungkin tidak memikirkan kebutuhan akan EFI, dan itu dapat dinonaktifkan. <br><br>  Tidak semua hypervisors mendukung EFI.  VMWare vSphere mendukung EFI sejak versi 5. <br>  Microsoft Hyper-V juga menerima dukungan EFI, dimulai dengan Hyper-V untuk Windows Server 2012R2. <br><br>  Namun, dalam konfigurasi default, fungsi ini dinonaktifkan untuk mesin Linux, yang berarti bahwa sertifikat tidak dapat diinstal. <br><br>  Di vSphere 6.5, Anda dapat mengatur opsi <b>Boot Aman</b> hanya di versi lama antarmuka web yang bekerja melalui Flash.  Web UI pada HTML-5 jauh di belakang. <br><br><h2>  Distribusi Eksperimental </h2><br>  Dan akhirnya, pertimbangkan masalah distribusi dan distribusi eksperimental tanpa dukungan resmi.  Di satu sisi, distribusi seperti itu tidak mungkin ditemukan di server organisasi yang serius.  Tidak ada dukungan resmi untuk distribusi semacam itu.  Karena itu, untuk menyediakannya.  dukungan produk pada distribusi semacam itu tidak dimungkinkan. <br><br>  Namun, distribusi tersebut menjadi platform yang nyaman untuk menguji solusi eksperimental baru.  Misalnya, Fedora, OpenSUSE Tumbleweed, atau versi Debian yang tidak stabil.  Mereka cukup stabil.  Mereka selalu memiliki versi program baru dan selalu kernel baru.  Setelah satu tahun, fungsi eksperimental ini mungkin ada di RHEL, SLES atau Ubuntu yang diperbarui. <br><br>  Jadi, jika sesuatu tidak berfungsi pada kit distribusi eksperimental, ini adalah kesempatan untuk menyelesaikan masalah dan menyelesaikannya.  Anda harus siap dengan kenyataan bahwa fungsi ini akan segera muncul di server produksi pengguna. <br><br>  Daftar distribusi saat ini yang didukung secara resmi untuk versi 3.0 dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Tetapi daftar distribusi yang sebenarnya yang dapat digunakan oleh produk kami jauh lebih luas. <br><br>  Secara pribadi, saya tertarik pada percobaan dengan OS Elbrus.  Setelah memperbarui paket veeam, produk kami dipasang dan diterima.  Tentang percobaan ini saya menulis di HabrÃ© dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> . <br><br>  Nah, dukungan untuk distribusi baru terus berlanjut.  Kami menunggu rilis versi 4.0.  Beta akan segera muncul, jadi tetap ikuti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perkembangannya</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471226/">https://habr.com/ru/post/id471226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471210/index.html">Ya Tuhan ... Balada tentang seorang programmer</a></li>
<li><a href="../id471212/index.html">10 tips dan trik untuk membantu Anda menjadi pengembang terbaik di VueJS</a></li>
<li><a href="../id471216/index.html">Sejarah panjang buku panduan - bagaimana saya menulis layanan untuk jalur pendakian yang cerdas selama 5 tahun</a></li>
<li><a href="../id471220/index.html">Cockpit - menyederhanakan tugas administrasi tipikal di Linux melalui antarmuka web yang nyaman</a></li>
<li><a href="../id471222/index.html">Memahami kebijakan privasi aplikasi dan layanan akan membantu jaringan saraf</a></li>
<li><a href="../id471228/index.html">Grokay PyTorch</a></li>
<li><a href="../id471232/index.html">Pengalaman saya menghubungkan LPS331AP ke Omega Onion2</a></li>
<li><a href="../id471236/index.html">Dosimeter untuk Seryozha. Bagian III. Radiometer nasional</a></li>
<li><a href="../id471240/index.html">"Bitchy Betty" dan antarmuka audio modern: mengapa mereka berbicara dengan suara wanita?</a></li>
<li><a href="../id471242/index.html">Pengantar Bash Shell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>