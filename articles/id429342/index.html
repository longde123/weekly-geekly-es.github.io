<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐜 ⏪ ⚖️ Angular 6+ adalah panduan injeksi ketergantungan lengkap. penyedia yang disediakan vs vs: [] 🍐 🛳️ 🎳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Angular 6 memperkenalkan sintaks baru yang ditingkatkan untuk menanamkan dependensi layanan dalam aplikasi ( ProvidIn ). Terlepas dari kenyataan bahwa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angular 6+ adalah panduan injeksi ketergantungan lengkap. penyedia yang disediakan vs vs: []</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429342/"><img src="https://habrastorage.org/getpro/habr/post_images/878/6df/25a/8786df25a4fd4d9b0699cabbfc8dcaec.jpg" alt="gambar"><br><br>  Angular 6 memperkenalkan sintaks baru yang ditingkatkan untuk menanamkan dependensi layanan dalam aplikasi ( <b>ProvidIn</b> ).  Terlepas dari kenyataan bahwa 7 Angular telah dirilis, topik ini masih relevan.  <b>Ada banyak kebingungan dalam komentar GitHub, Slack, dan Stack Overflow, jadi mari kita lihat lebih dekat topik ini.</b> <b><br></b> <br><h3>  Dalam artikel ini kami akan mempertimbangkan: </h3><br><ol><li>  <b>Ketergantungan injeksi</b> </li><li>  Cara lama untuk menyuntikkan dependensi ke Angular ( <b>penyedia: []</b> ); </li><li>  Cara baru untuk menyuntikkan dependensi dalam Angular ( <b>tersedia di: 'root' | SomeModule</b> ); </li><li>  Skenario <b>UseIn menyediakanIn</b> ; </li><li>  Rekomendasi untuk menggunakan sintaks baru dalam aplikasi; </li><li>  Untuk meringkas. </li></ol><a name="habracut"></a><br><h3>  Injeksi Ketergantungan </h3><br>  Anda dapat melewati bagian ini jika Anda sudah memiliki gagasan tentang <b>DI</b> . <br><blockquote>  Dependency <b>injection</b> ( <b>DI</b> ) adalah cara untuk membuat objek yang bergantung pada objek lain.  Sistem injeksi dependensi menyediakan objek tergantung ketika instantiate kelas. <br><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi Sudut</a> </blockquote><br>  Penjelasan formal itu bagus, tapi mari kita lihat lebih dekat apa itu injeksi ketergantungan. <br><br>  Semua komponen dan layanan adalah kelas.  Setiap kelas memiliki metode <b>konstruktor</b> khusus, yang, ketika dipanggil, membuat objek instance dari kelas ini, yang digunakan dalam aplikasi. <br><br>  Misalkan di salah satu layanan kami ada kode berikut: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private http: HttpClient)</code> </pre> <br>  Jika Anda membuatnya tanpa menggunakan mekanisme injeksi ketergantungan, Anda harus menambahkan <b>HttpClient</b> secara manual.  Maka kode akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyService(httpClient)</code> </pre> <br>  Tapi di mana dalam hal ini untuk mendapatkan <b>httpClient</b> ?  Itu juga harus dibuat: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(httpHandler)</code> </pre> <br>  Tapi di mana mendapatkan <b>httphandler</b> sekarang?  Dan seterusnya, sampai semua kelas yang diperlukan dipakai.  Seperti yang bisa kita lihat, pembuatan manual bisa rumit dan kesalahan dapat terjadi dalam proses. <br><br>  <b>Mekanisme injeksi dependensi sudut melakukan semua ini secara otomatis.</b>  <b>Yang perlu kita lakukan adalah menentukan dependensi dalam konstruktor komponen dan mereka akan ditambahkan tanpa upaya dari pihak kita.</b> <br><br><h3>  Cara lama untuk menyuntikkan dependensi dalam Angular (penyedia: []) </h3><br>  Untuk menjalankan aplikasi, Angular perlu tahu tentang setiap objek individu yang ingin kita terapkan dalam komponen dan layanan.  Sebelum rilis Angular 6, satu-satunya cara untuk melakukan ini adalah menentukan layanan di properti <b>penyedia: []</b> dekorator <b>@NgModule</b> , <b>@Component</b> dan <b>@Directive</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6c/3a7/433/f6c3a7433a1f72dc45b9e9cd2b5edc18.png" alt="gambar"><br><br>  Berikut adalah tiga kegunaan utama <b>penyedia: []</b> : <br><br><ol><li>  Dalam dekorator <b>@NgModule</b> dari modul yang segera dimuat ( <b>bersemangat</b> ); </li><li>  Dalam dekorator <b>@NgModule</b> dari modul pemuatan yang tertunda ( <b>malas</b> ); </li><li>  Di dekorator <b>@Component</b> dan <b>@Directive</b> . </li></ol><br><h4>  Modul yang diunduh dengan aplikasi (Eager) </h4><br>  Dalam hal ini, layanan terdaftar dalam lingkup global sebagai singleton.  Ini akan menjadi singleton walaupun disertakan dalam <b>penyedia []</b> beberapa modul.  Sebuah instance dari kelas layanan dibuat yang akan didaftarkan pada level root aplikasi. <br><br><h4>  Modul Beban Ditangguhkan (Malas) </h4><br>  Mesin virtual dari layanan yang terhubung ke modul <b>malas</b> akan dibuat selama inisialisasi.  Menambahkan layanan seperti itu ke komponen <b>eager</b> modul akan menghasilkan kesalahan: <b>Tidak ada penyedia untuk MyService!</b>  <b>kesalahan</b> . <br><br><h4>  Implementasi dalam @ Component dan @ Directive </h4><br>  Ketika diimplementasikan dalam komponen atau arahan, turunan terpisah dari layanan dibuat, yang akan tersedia dalam komponen ini dan semua anak.  <b>Dalam situasi ini, layanan tidak akan menjadi singleton, instance-nya akan dibuat setiap kali komponen digunakan dan dihapus bersama dengan penghapusan komponen dari DOM.</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b0/4fc/6a9/6b04fc6a974ad8278ba910524a3e062e.png" alt="gambar"><br><br>  Dalam hal ini, <b>RandomService</b> tidak diimplementasikan pada level modul dan bukan singleton, <br>  tetapi terdaftar dengan <b>penyedia: []</b> dari komponen <b>RandomComponent</b> .  Akibatnya, kami akan mendapatkan nomor acak baru setiap kali menggunakan <b>&lt;randm&gt; &lt;/ randm&gt;</b> . <br><br><h3>  Cara baru untuk menyuntikkan dependensi dalam Angular (tersedia di: 'root' | SomeModule) </h3><br>  Di Angular 6, kami mendapat alat <b>"Tree-shakable penyedia" baru</b> untuk <b>menyuntikkan</b> dependensi ke dalam aplikasi, yang dapat digunakan menggunakan properti <b>In yang</b> <b>disediakan</b> dari dekorator <b>@Injectable</b> . <br><br>  <b>Anda dapat membayangkan <b>asalkan</b> sebagai implementasi dependensi dalam arah yang berlawanan: sebelum modul menggambarkan layanan di mana ia akan terhubung, sekarang layanan mendefinisikan modul yang terhubung.</b> <br><br>  Layanan ini dapat disematkan di root aplikasi ( <b>disediakan di: 'root'</b> ) atau di modul apa saja ( <b>disediakan di: SomeModule</b> ).  <b>asalkan Di: 'root'</b> adalah singkatan untuk implementasi di <b>AppModule</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c41/57a/fa6/c4157afa6304838f407ab76f4665aaa8.png" alt="gambar"><br><br>  Mari kita menganalisis skenario utama untuk menggunakan sintaks baru: <br><br><ol><li>  Implementasi dalam modul root aplikasi ( <b>tersedia di: 'root'</b> ); </li><li>  Implementasi dalam modul yang segera dimuat ( <b>bersemangat</b> ); </li><li>  Implementasi dalam modul dengan loading tertunda ( <b>malas</b> ). </li></ol><br><h4>  Implementasi dalam modul root aplikasi (tersedia di: 'root') </h4><br>  Ini adalah opsi injeksi ketergantungan yang paling umum.  Dalam hal ini, layanan akan ditambahkan ke aplikasi bundel hanya jika itu benar-benar digunakan, mis.  tertanam dalam komponen atau layanan lain. <br><br>  Saat menggunakan pendekatan baru, tidak akan ada banyak perbedaan dalam aplikasi SPA monolitik, di mana semua layanan tertulis digunakan, namun jika <b>disediakan: 'root'</b> akan berguna saat menulis perpustakaan. <br><br>  Sebelumnya, semua layanan perpustakaan perlu ditambahkan ke <b>penyedia: []</b> modulnya.  Setelah mengimpor perpustakaan ke dalam aplikasi, semua layanan ditambahkan ke bundel, bahkan jika hanya satu yang digunakan.  Dalam hal <b>disediakanIn: 'root'</b> tidak perlu menghubungkan modul perpustakaan.  Cukup sematkan layanan di komponen yang diinginkan. <br><br><h4>  Modul pemuatan yang tertunda (malas) dan disediakanIn: 'root' </h4><br>  Apa yang terjadi jika Anda mengimplementasikan layanan dengan <b>providedIn: 'root'</b> di modul <b>malas</b> ? <br><br>  Secara teknis, <b>'root'</b> adalah singkatan dari <b>AppModule</b> , tetapi Angular cukup pintar untuk menambahkan layanan ke kumpulan modul yang <b>malas</b> jika hanya diimplementasikan dalam komponen dan layanannya.  Tetapi ada satu masalah (meskipun beberapa orang mengklaim bahwa ini adalah fitur).  Jika nanti Anda memperkenalkan layanan yang hanya digunakan dalam modul <b>malas</b> ke modul utama, layanan akan ditransfer ke bundel utama.  Dalam aplikasi besar dengan banyak modul dan layanan, ini dapat menyebabkan masalah pelacakan ketergantungan dan perilaku yang tidak dapat diprediksi. <br><br>  <b>Berhati-hatilah!</b>  <b>Menerapkan satu layanan dalam banyak modul dapat menyebabkan ketergantungan tersembunyi yang sulit dipahami dan tidak mungkin terurai.</b> <br><br>  Untungnya, ada cara untuk mencegah hal ini, dan kami akan mempertimbangkannya di bawah ini. <br><br><h3>  Ketergantungan injeksi dalam modul yang segera dimuat (bersemangat) </h3><br>  Sebagai aturan, kasus ini tidak masuk akal dan sebagai gantinya kita dapat menggunakan <b>asalkan dalam: 'root'</b> .  Menghubungkan layanan di <b>EagerModule</b> dapat digunakan untuk enkapsulasi dan akan mencegah implementasi tanpa menghubungkan modul, tetapi dalam kebanyakan kasus ini tidak diperlukan. <br><br>  Jika Anda benar-benar perlu membatasi ruang lingkup layanan, lebih mudah untuk menggunakan <b>penyedia</b> lama <b>: []</b> metode, karena itu pasti tidak akan mengarah pada ketergantungan siklik. <br><br>  <b>Jika memungkinkan, coba gunakan yang disediakan di: 'root' di semua modul bersemangat.</b> <br><br><h4>  Catatan  Keuntungan dari modul pemuatan yang tertunda (malas) </h4><br>  Salah satu fitur utama Angular adalah kemampuan untuk dengan mudah membagi aplikasi menjadi fragmen, yang memberikan keuntungan sebagai berikut: <br><br><ol><li>  Ukuran kecil bundel utama aplikasi, karena itu aplikasi memuat dan mulai lebih cepat; </li><li>  Modul pemuatan yang tertunda terisolasi dengan baik dan terhubung dalam aplikasi sekali di properti <b>loadChildren</b> dari rute yang sesuai. </li></ol><br>  <b>Berkat pemuatan yang tertunda, seluruh modul dengan ratusan layanan dan komponen dapat dihapus atau dipindahkan ke aplikasi atau perpustakaan terpisah, dengan sedikit atau tanpa usaha.</b> <br><br>  Keuntungan lain dari isolasi modul <b>lazy</b> adalah kesalahan yang dibuat di dalamnya tidak akan mempengaruhi sisa aplikasi.  Sekarang Anda dapat tidur nyenyak bahkan pada hari pelepasan. <br><br><h3>  Implementasi dalam modul dengan pemuatan yang tertunda (tersedia di: LazyModule) </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/6ce/a76/ebd/6cea76ebda5a5fe9190c79554065f399.png" alt="gambar"><br><br>  Ketergantungan injeksi ke modul tertentu mencegah penggunaan layanan di bagian lain dari aplikasi.  Ini mempertahankan struktur dependensi, yang sangat berguna untuk aplikasi besar di mana injeksi dependensi yang berantakan dapat menyebabkan kebingungan. <br><br>  <b>Fakta menarik: Jika Anda menerapkan layanan malas di bagian utama aplikasi, majelis (bahkan AOT) akan gagal tanpa kesalahan, tetapi aplikasi akan macet dengan kesalahan "Tidak ada penyedia untuk LazyService".</b> <br><br><h4>  Masalah dengan ketergantungan siklik </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/789/f3d/551/789f3d551cca5651454027e49a1513c3.png" alt="gambar"><br><br>  Anda dapat mereproduksi kesalahan sebagai berikut: <br><br><ol><li>  Buat modul <b>LazyModule</b> ; </li><li>  Kami membuat layanan <b>LazyService</b> dan terhubung menggunakan yang <b>disediakan Di: LazyModule</b> ; </li><li>  Kami membuat komponen <b>LazyComponent</b> dan menghubungkannya ke <b>LazyModule</b> ; </li><li>  Tambahkan <b>LazyService</b> ke konstruktor komponen <b>LazyComponent</b> ; </li><li>  Kami mendapatkan kesalahan dengan ketergantungan siklik. </li></ol><br>  Secara skematis, tampilannya seperti ini: <b>service -&gt; module -&gt; component -&gt; service</b> . <br><br>  Anda dapat memecahkan masalah ini dengan membuat submodule <b>LazyServiceModule</b> , yang akan terhubung ke <b>LazyModule</b> .  Hubungkan layanan ke submodule. <br><img src="https://habrastorage.org/getpro/habr/post_images/c9c/da3/bae/c9cda3bae241d0c3e748ca16007ed816.jpg" alt="gambar"><br><br>  Dalam hal ini, Anda harus membuat modul tambahan, tetapi tidak membutuhkan banyak usaha dan akan memberikan keuntungan sebagai berikut: <br><br><ol><li>  Ini akan mencegah pengenalan layanan dalam modul aplikasi lain; </li><li>  Layanan akan ditambahkan ke bundel hanya jika tertanam dalam komponen atau layanan lain yang digunakan dalam modul. </li></ol><br><h4>  Menyematkan layanan ke dalam komponen (tersedia di: SomeComponent) </h4><br>  Apakah mungkin untuk menyematkan layanan di <b>@Component</b> atau <b>@Directive</b> menggunakan sintaks baru? <br><br>  <b>Tidak saat ini!</b> <br><br>  Untuk membuat turunan dari layanan untuk setiap komponen, Anda masih perlu menggunakan <b>penyedia: []</b> di <b>@</b> <b>omponent</b> atau <b>@Directive dekorator</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46b/56b/6af/46b56b6af20ae67ffe30cff15fc0eb47.png" alt="gambar"><br><br><h3>  Praktik Terbaik untuk Menggunakan Sintaks Baru dalam Aplikasi </h3><br><h4>  Perpustakaan </h4><br>  <b>asalkan: 'root'</b> baik untuk membuat perpustakaan.  Ini adalah cara yang sangat nyaman untuk menghubungkan hanya bagian yang langsung digunakan dari fungsi ke aplikasi utama dan mengurangi ukuran perakitan akhir. <br><br>  <b>Salah satu contoh praktis adalah perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ngx-model</a> , yang telah ditulis ulang menggunakan sintaks baru dan sekarang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ angular-extensions / model</a> .</b>  <b>Dalam implementasi baru, tidak perlu menghubungkan NgxModelModule ke aplikasi, cukup dengan menanamkan ModelFactory ke dalam komponen yang diperlukan.</b>  <b>Detail implementasi dapat ditemukan di <a href="">sini</a> .</b> <br><br><h4>  Modul Unduhan Tangguhan (malas) </h4><br>  Gunakan modul terpisah yang <b>disediakan Di: LazyServicesModule</b> untuk layanan dan hubungkan ke <b>LazyModule</b> .  Pendekatan ini merangkum layanan dan mencegah mereka terhubung ke modul lain.  Ini akan menetapkan batas-batas dan membantu menciptakan arsitektur yang dapat diskalakan. <br><br>  <b>Dalam pengalaman saya, pengenalan yang tidak disengaja ke modul utama atau tambahan (menggunakan providedIn: 'root') dapat menyebabkan kebingungan dan bukan solusi terbaik!</b> <br><br>  <b>asalkan: 'root'</b> akan bekerja dengan benar juga, tetapi ketika menggunakan <b>disediakan di: LazyServideModule</b> kita mendapatkan kesalahan <b>"penyedia hilang"</b> ketika diterapkan dalam modul lain dan kita dapat memperbaiki arsitektur.  <b>Pindahkan layanan ke tempat yang lebih tepat di bagian utama aplikasi.</b> <br><br><h4>  Kapan penyedia harus digunakan: []? </h4><br>  Dalam kasus di mana perlu untuk mengkonfigurasi modul.  Misalnya, hubungkan layanan hanya ke <b>SomeModule.forRoot (someConfig)</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe3/244/6e1/fe32446e118077fc5fb5839bb32c7501.png" alt="gambar"><br><br>  <b>Di sisi lain, dalam situasi ini, Anda dapat menggunakan providedIn: 'root'.</b>  <b>Ini akan menjamin bahwa layanan akan ditambahkan ke aplikasi hanya sekali.</b> <br><br><h3>  Kesimpulan </h3><br><ol><li>  Gunakan yang <b>disediakan Di: 'root'</b> untuk mendaftarkan layanan sebagai singleton, tersedia di seluruh aplikasi. </li><li>  Untuk modul yang termasuk dalam bundel utama, gunakan yang <b>disediakan Di: 'root'</b> , tidak <b>disediakan Di: EagerlyImportedModule</b> .  Dalam kasus luar biasa, gunakan <b>penyedia: []</b> untuk enkapsulasi. </li><li>  Buat submodule dengan layanan untuk membatasi ruang lingkup yang <b>disediakan Di: LazyServiceModule</b> saat menggunakan <b>lazy</b> loading. </li><li>  Colokkan modul <b>LazyServiceModule</b> ke <b>LazyModule</b> untuk mencegah ketergantungan melingkar. </li><li>  Gunakan <b>penyedia: []</b> di <b>@</b> <b>omponent</b> dan <b>@Directive dekorator</b> untuk membuat instance layanan baru untuk setiap instance komponen baru.  Mesin virtual layanan juga akan tersedia di semua komponen anak. </li><li>  Selalu membatasi ruang lingkup dependensi untuk meningkatkan arsitektur dan menghindari dependensi yang membingungkan. </li></ol><br><h3>  Referensi </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel asli</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Angular adalah komunitas berbahasa Rusia.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertemuan Sudut di Rusia</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429342/">https://habr.com/ru/post/id429342/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429328/index.html">Modul perangkat lunak untuk mendigitalkan dokumen yang rusak</a></li>
<li><a href="../id429330/index.html">Mitos dan legenda Agile - dari Firaun hingga saat ini</a></li>
<li><a href="../id429336/index.html">Komunikasi antara driver dan perangkat dengan metode _HID ACPI menggunakan GPIO dari pengontrol Lynxpoint sebagai contoh</a></li>
<li><a href="../id429338/index.html">Penyimpanan Android: Internal, Eksternal, Dapat Dilepas. Bagian 1/3</a></li>
<li><a href="../id429340/index.html">Berpikir dua kali sebelum menggunakan Helm.</a></li>
<li><a href="../id429344/index.html">Membaca Akhir Pekan: Sumber Daya Tuning Audio dan Desain Speaker</a></li>
<li><a href="../id429346/index.html">Untuk program master tanpa ujian: arah baru "Big Data" di Olimpiade "I am a Professional"</a></li>
<li><a href="../id429348/index.html">Kenapa di masa depan Agile tidak akan dibutuhkan</a></li>
<li><a href="../id429350/index.html">Pengkabelan Energi Angin Lepas Pantai dan Pasar Kabel Mencapai £ 14 Miliar</a></li>
<li><a href="../id429352/index.html">Daftar IT'shnik sehat, atau bagaimana tidak merusak hidup Anda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>