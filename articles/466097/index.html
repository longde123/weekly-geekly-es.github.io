<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîè üë©‚Äçüëß‚Äçüë¶ üë´ Supervisi√≥n de aplicaciones .NET üë©üèΩ‚Äçü§ù‚Äçüë©üèª üë®‚Äçüéì ‚ù§Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NET es un tiempo de ejecuci√≥n administrado . Esto significa que contiene funciones de alto nivel que controlan su programa por usted (de Introducci√≥n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Supervisi√≥n de aplicaciones .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/466097/"><p>  .NET es un <em>tiempo de ejecuci√≥n administrado</em> .  Esto significa que contiene funciones de alto nivel que controlan su programa por usted (de <a href="">Introducci√≥n al Common Language Runtime (CLR), 2007</a> ): </p><br><blockquote>  El tiempo de ejecuci√≥n proporciona muchas funciones, por lo que es conveniente dividirlas en las siguientes categor√≠as: <br><br><ol><li>  <b>Las funciones principales</b> que afectan el dispositivo de los dem√°s.  Estos incluyen: <ol><li>  recolecci√≥n de basura; </li><li>  asegurar el acceso a la memoria y la seguridad del sistema de tipos; </li><li>  Soporte de alto nivel para lenguajes de programaci√≥n. </li></ol></li><li>  <b>Funciones adicionales</b> : trabaje sobre la base de las principales.  Muchos programas √∫tiles lo hacen sin ellos.  Estas funciones incluyen: <ol><li>  Aislar aplicaciones usando AppDomains </li><li>  Protecci√≥n de aplicaciones y aislamiento de cajas de arena. </li></ol></li><li>  Todos los tiempos de ejecuci√≥n necesitan <b>otras funciones</b> , pero no utilizan las funciones b√°sicas de CLR.  Tales caracter√≠sticas reflejan el deseo de crear un entorno de programaci√≥n completo.  Estos incluyen: <br><ol><li>  control de versiones; </li><li>  depuraci√≥n / perfilado; </li><li>  asegurando la interacci√≥n. </li></ol></li></ol></blockquote><p>  Se puede ver que, aunque la depuraci√≥n y la creaci√≥n de perfiles no son las funciones principales o adicionales, est√°n en la lista debido al " <em>deseo de crear un entorno de programaci√≥n completo</em> ". </p><br><p><img src="https://habrastorage.org/webt/mh/eq/nn/mheqnnqmnlkhoroovhqseskeyba.jpeg"></p><a name="habracut"></a><br><p>  <strong>El resto de la publicaci√≥n describe qu√© caracter√≠sticas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">monitoreo</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">observabilidad</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">introspecci√≥n</a> existen en el Core CLR, por qu√© son √∫tiles y c√≥mo las proporciona el entorno.</strong> </p><br><h2 id="diagnostika">  Diagn√≥sticos </h2><br><p>  Primero, eche un vistazo a la informaci√≥n de diagn√≥stico que nos proporciona el CLR.  Tradicionalmente, el seguimiento de eventos para Windows (ETW) se ha utilizado para esto. <br>  Hay muchos eventos sobre los cuales el CLR proporciona informaci√≥n.  Est√°n asociados con: </p><br><ul><li>  recolecci√≥n de basura (GC); </li><li>  Compilaci√≥n JIT; </li><li>  m√≥dulos y dominios de aplicaci√≥n; </li><li>  trabajar con hilos y conflictos al bloquear; </li><li>  as√≠ como muchos otros </li></ul><br><p>  Por ejemplo, aqu√≠ <a href="https://github.com/dotnet/coreclr/blob/release/2.1/src/vm/corhost.cpp#">se</a> produce un <a href="https://github.com/dotnet/coreclr/blob/release/2.1/src/vm/corhost.cpp#">evento durante la carga en AppDomain</a> , aqu√≠ el <a href="">evento se asocia con una excepci√≥n</a> y aqu√≠ con el <a href="">ciclo de asignaci√≥n de memoria del recolector de basura</a> . </p><br><h3 id="perf-view">  Vista Perf </h3><br><p> Si desea ver los eventos en el sistema de rastreo (ETW) relacionados con sus aplicaciones .NET, le recomiendo usar la excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta PerfView</a> y comenzar con estos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">videos de capacitaci√≥n</a> o esta presentaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PerfView: la herramienta de rendimiento .NET definitiva</a> .  PerfView ha sido ampliamente reconocido por proporcionar informaci√≥n invaluable.  Por ejemplo, los ingenieros de Microsoft lo usan regularmente para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">analizar el rendimiento</a> . </p><br><h3 id="obschaya-infrastruktura">  Infraestructura com√∫n </h3><br><p>  Si de repente el nombre no est√° claro, el seguimiento de eventos en ETW est√° disponible solo en Windows, lo que no encaja muy bien con el mundo multiplataforma de .NET Core.  Puede usar <a href="">PerfView para analizar el rendimiento en Linux</a> (usando LTTng).  Sin embargo, esta herramienta de l√≠nea de comandos, llamada PerfCollect, solo recopila datos.  Las capacidades de an√°lisis y una rica interfaz de usuario (incluidas las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gr√°ficas de fuego</a> ) actualmente solo est√°n disponibles en las soluciones de Windows. </p><br><p>  Pero si a√∫n desea analizar el rendimiento de .NET en Linux, existen otros enfoques: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Obtenci√≥n de pilas para eventos LTTng con .NET Core en Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Problema de rendimiento de Linux</a> </li></ul><br><p>  El segundo enlace anterior conduce a una discusi√≥n sobre la nueva <strong>infraestructura EventPipe</strong> , en la que se est√° trabajando en .NET Core (adem√°s de EventSources y EventListeners).  Sus objetivos de desarrollo se pueden encontrar en el documento <a href="">Dise√±o de monitoreo de rendimiento multiplataforma</a> .  A un alto nivel, esta infraestructura crear√° un solo lugar donde el CLR enviar√° eventos relacionados con el diagn√≥stico y el rendimiento.  Luego, estos eventos ser√°n redirigidos a uno o m√°s registradores, que, por ejemplo, pueden incluir ETW, LTTng y BPF.  El registrador necesario se determinar√° seg√∫n el sistema operativo o la plataforma en la que se ejecuta el CLR.  Para obtener una explicaci√≥n detallada de los pros y los contras de varias tecnolog√≠as de registro, consulte el <a href="">Dise√±o de eventos y rendimiento de .NET Cross-Plat</a> . </p><br><p>  El progreso de EventPipes se monitorea a trav√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del proyecto de Monitoreo de rendimiento</a> y problemas relacionados con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">'EventPipe'</a> . </p><br><h3 id="plany-na-buduschee">  Planes futuros </h3><br><p>  Finalmente, hay planes para crear un <a href="">controlador de perfiles de rendimiento</a> , que tiene las siguientes tareas: </p><br><p>  El controlador debe administrar la infraestructura de creaci√≥n de perfiles y presentar los datos de rendimiento generados por los componentes .NET responsables del diagn√≥stico de rendimiento de una manera simple y multiplataforma. </p><br><p>  Seg√∫n el plan, el controlador debe proporcionar la <a href="">siguiente funcionalidad a trav√©s del servidor HTTP</a> , recibiendo todos los datos necesarios de la infraestructura de EventPipes: </p><br><p>  <strong>API REST</strong> </p><br><ul><li>  Principio 1: perfil simple: perfile el tiempo de ejecuci√≥n en el per√≠odo de tiempo X y devuelva la traza. </li><li>  Principio 1: perfil avanzado: inicio de seguimiento (junto con la configuraci√≥n) </li><li>  Principio 1: perfil avanzado: seguimiento completo (la respuesta a esta llamada ser√° el seguimiento en s√≠). </li><li>  Principio 2: Obtenga estad√≠sticas asociadas con todos los EventCounters o un EventCounter espec√≠fico. </li></ul><br><p>  <strong>P√°ginas navegables HTML</strong> </p><br><ul><li>  Principio 1: una representaci√≥n textual de todas las pilas de c√≥digo administrado en un proceso. <br><ul><li>  Crea instant√°neas de procesos en ejecuci√≥n para usar como un informe de diagn√≥stico simple. </li></ul></li><li>  Principio 2: mostrar el estado actual (posiblemente con un historial) de los contadores EventCounters. <br><ul><li>  Proporciona una visi√≥n general de los contadores existentes y sus valores. </li><li>  PROBLEMA NO RESUELTO: No creo que haya API p√∫blicas necesarias para contar EventCounters. </li></ul></li></ul><br><p>  Realmente quiero ver qu√© sucede con el controlador de perfiles de rendimiento (PPC).  Creo que si est√° integrado en el CLR, traer√° muchos beneficios a .NET.  Dicha funcionalidad existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en otros tiempos de ejecuci√≥n</a> . </p><br><h2 id="profilirovanie">  Perfilado </h2><br><p>  Otra herramienta efectiva que tiene el CLR es una API de creaci√≥n de perfiles.  Es utilizado (principalmente) por herramientas de terceros para conectarse al tiempo de ejecuci√≥n en un nivel bajo.  Puede obtener m√°s informaci√≥n sobre la API <a href="">de esta revisi√≥n</a> , pero a un alto nivel, puede usarla para realizar devoluciones de llamada que se activan si: </p><br><ul><li>  eventos relacionados con el recolector de basura; </li><li>  se lanzan excepciones; </li><li>  los ensambles se cargan / descargan; </li><li>  <a href="">y mucho mas</a> </li></ul><br><p>  <em>Imagen de la <a href="">p√°gina de API de creaci√≥n de perfiles BOTR: descripci√≥n general</a></em> </p><br><p>  Adem√°s, tiene otras caracter√≠sticas efectivas.  Primero, puede configurar controladores que se invocan cada vez que se ejecuta el m√©todo .NET, ya sea en el entorno mismo o desde el c√≥digo de usuario.  Estas devoluciones de llamada se conocen como controladores de entrada / salida.  Aqu√≠ hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">buen ejemplo de</a> c√≥mo usarlos.  Sin embargo, para esto necesita comprender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las convenciones de llamadas para diferentes arquitecturas de SO y CPU</a> , lo que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no siempre es f√°cil</a> .  Adem√°s, recuerde que la API de creaci√≥n de perfiles es un componente COM al que solo se puede acceder desde el c√≥digo C / C ++, pero no desde C # / F # / VB.NET. </p><br><p>  En segundo lugar, el generador de perfiles puede reescribir el c√≥digo IL de cualquier m√©todo .NET antes de la compilaci√≥n JIT utilizando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API SetILFunctionBody ()</a> .  Esta API es realmente eficiente.  Es la base de muchas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramientas APM .NET</a> .  Puede obtener m√°s informaci√≥n sobre su uso en mi publicaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo burlarse de las clases selladas y los m√©todos est√°ticos</a> y el c√≥digo relacionado. </p><br><h3 id="icorprofiler-api">  API ICorProfiler </h3><br><p>  Resulta que la API de creaci√≥n de perfiles funcion√≥, deber√≠a haber todo tipo de trucos en el entorno de tiempo de ejecuci√≥n.  Simplemente mire la discusi√≥n en la p√°gina <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Permitir rejit en adjuntar</a> (vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ReJIT: Una gu√≠a de</a> procedimientos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para</a> obtener m√°s informaci√≥n sobre ReJIT). </p><br><p> Puede encontrar una definici√≥n completa de todas las interfaces API y devoluciones de llamada en <a href="">\ vm \ inc \ corprof.idl</a> (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lenguaje de descripci√≥n de interfaz</a> ).  Se divide en 2 partes l√≥gicas.  Una parte es la interfaz <strong>Profiler -&gt; Runtime Environment (EE)</strong> , conocida como <code>ICorProfilerInfo</code> : </p><br><pre> <code class="plaintext hljs">//  ,    ICorProfilerInfo*,  //     .  ,  DLL   //          ,     //    .</code> </pre> <br><p>  Esto se implementa en los siguientes archivos: </p><br><ul><li>  <a href="">\ vm \ proftoeeinterfaceimpl.h</a> </li><li>  <a href="">\ vm \ proftoeeinterfaceimpl.inl</a> </li><li>  <a href="">\ vm \ proftoeeinterfaceimpl.cpp</a> </li></ul><br><p>  La otra parte principal es callbacks Runtime -&gt; Profiler, que se agrupan bajo la interfaz <code>ICorProfilerCallback</code> : </p><br><pre> <code class="plaintext hljs">//       //  ICorProfilerCallaback* .       // ,     EEToProfInterfaceImpl.</code> </pre> <br><p>  Estas devoluciones de llamada se implementan en los siguientes archivos: </p><br><ul><li>  <a href="">vm \ eetoprofinterfaceimpl.h</a> </li><li>  <a href="">vm \ eetoprofinterfaceimpl.inl</a> </li><li>  <a href="">vm \ eetoprofinterfaceimpl.cpp</a> </li><li>  <a href="">vm \ eetoprofinterfacewrapper.inl</a> </li></ul><br><p>  Finalmente, vale la pena se√±alar que las API de creaci√≥n de perfiles pueden no funcionar en todos los sistemas operativos y arquitecturas que ejecutan .NET Core.  Aqu√≠ hay un ejemplo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problemas de c√≥digo auxiliar de llamada ELT en Linux</a> .  Consulte el <a href="">estado de las API de CoreCLR Profiler</a> para obtener m√°s informaci√≥n. </p><br><h3 id="profiling-v-debugging">  Perfilado v.  Depuraci√≥n </h3><br><p>  Como una peque√±a digresi√≥n, debo decir que los perfiles y la depuraci√≥n todav√≠a se superponen un poco.  Por lo tanto, es √∫til comprender qu√© proporcionan las diferentes API en el contexto de .NET Runtime (tomado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CLR Debugging vs. CLR Profiling</a> ). </p><br><p>  <strong>La diferencia entre depurar y perfilar en el CLR</strong> </p><br><div class="scrollable-table"><table><thead><tr><th>  Depuraci√≥n </th><th>  Perfilado </th></tr></thead><tbody><tr><td>  Dise√±ado para encontrar problemas con la correcci√≥n del c√≥digo. </td><td>  Dise√±ado para diagnosticar y solucionar problemas de rendimiento. </td></tr><tr><td>  Puede tener un nivel muy alto de interferencia. </td><td>  Generalmente tiene un bajo nivel de intervenci√≥n.  Aunque el generador de perfiles admite la modificaci√≥n del c√≥digo IL o la instalaci√≥n de controladores de entrada / salida, todo esto es para instrumentaci√≥n, no para cambios radicales en el c√≥digo. </td></tr><tr><td>  La tarea principal es el control completo del objetivo.  Esto incluye inspecci√≥n, control de ejecuci√≥n (por ejemplo, el comando set-next-Statement) y modificaciones (funci√≥n Editar y continuar). </td><td>  La tarea principal es inspeccionar el objetivo.  Para hacer esto, se proporciona instrumentaci√≥n (cambio del c√≥digo IL, instalaci√≥n de controladores de entrada / salida) </td></tr><tr><td>  Amplia API y un modelo de objeto grueso lleno de abstracciones. </td><td>  Una peque√±a API.  Hay pocas o ninguna abstracci√≥n. </td></tr><tr><td>  Alto nivel de interactividad: las acciones del depurador son controladas por el usuario (o algoritmo).  De hecho, los editores y depuradores a menudo est√°n integrados (IDE). </td><td>  Sin interactividad: los datos generalmente se recopilan sin la intervenci√≥n del usuario y luego se analizan. </td></tr><tr><td>  Una peque√±a cantidad de cambios cr√≠ticos si se necesita compatibilidad con versiones anteriores.  Creemos que la migraci√≥n de la versi√≥n 1.1 a la versi√≥n 2.0 del generador de perfiles ser√° una tarea simple o no muy dif√≠cil. </td><td>  Una gran cantidad de cambios cr√≠ticos si se necesita compatibilidad con versiones anteriores.  Creemos que migrar de la versi√≥n 1.1 a la versi√≥n 2.0 del generador de perfiles ser√° una tarea dif√≠cil, id√©ntica a reescribirlo por completo. </td></tr></tbody></table></div><br><h2 id="otladka">  Depuraci√≥n </h2><br><p>  Los desarrolladores entienden de manera diferente qu√© es la depuraci√≥n.  Por ejemplo, pregunt√© en Twitter "c√≥mo depurar los programas .NET" y obtuve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muchas</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">respuestas diferentes</a> .  Al mismo tiempo, las respuestas conten√≠an una buena lista de herramientas y m√©todos, por lo que recomiendo mirarlos.  Gracias, #LazyWeb </p><br><p>  Creo que lo mejor de todo es que la esencia de la depuraci√≥n refleja este mensaje: </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="399339918213652480"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>  El CLR proporciona una extensa lista de caracter√≠sticas relacionadas con la depuraci√≥n.  Sin embargo, ¬øpor qu√© se necesitan estos fondos?  Se mencionan al menos tres razones en esta gran publicaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øPor qu√© la depuraci√≥n administrada es diferente de la depuraci√≥n nativa?</a>  : </p><br><ol><li>  La depuraci√≥n de c√≥digo no administrado puede abstraerse a nivel de hardware, pero la depuraci√≥n de c√≥digo administrado debe abstraerse a nivel de c√≥digo IL. </li><li>  La depuraci√≥n de c√≥digo administrado requiere mucha informaci√≥n que no est√° disponible antes de la ejecuci√≥n. </li><li>  El depurador de c√≥digo administrado debe coordinarse con el recolector de basura (GC) </li></ol><br><p>  Por lo tanto, para facilitar su uso, el CLR debe proporcionar una API de depuraci√≥n de alto nivel conocida como <code>ICorDebug</code> .  Se muestra en la figura siguiente que muestra un escenario de depuraci√≥n general (fuente: BOTR): </p><br><h3 id="icordebug-api">  API ICorDebug </h3><br><p>  El principio de implementaci√≥n y la descripci√≥n de los diversos componentes se toma de la <a href="">depuraci√≥n de CLR, una breve introducci√≥n</a> : </p><br><blockquote>  Todo el soporte de depuraci√≥n en .Net se implementa en la parte superior de la biblioteca dll, que llamamos The Dac.  Este archivo (generalmente llamado <code>mscordacwks.dll</code> ) es un elemento estructural tanto para nuestra API de depuraci√≥n p√∫blica ( <code>ICorDebug</code> ) como para dos API de depuraci√≥n privadas: SOS-Dac API y IXCLR. <br>  En un mundo ideal, todos usar√≠an <code>ICorDebug</code> , nuestra API p√∫blica.  Sin embargo, <code>ICorDebug</code> carece de muchas de las caracter√≠sticas que necesitan los desarrolladores de herramientas.  Este es el problema que estamos tratando de solucionar donde podemos.  Sin embargo, estas mejoras solo est√°n presentes en CL.v.next, pero no en versiones anteriores de CLR.  De hecho, el soporte de depuraci√≥n de volcado por ca√≠da apareci√≥ en la API <code>ICorDebug</code> solo con el lanzamiento de CLR v4.  Todos los que usan volcados de memoria para la depuraci√≥n en CLR v2 no podr√°n aplicar <code>ICorDebug</code> en absoluto. </blockquote><p>  <em>(Ver SOS e ICorDebug para m√°s informaci√≥n)</em> </p><br><p>  De hecho, la API <code>ICorDebug</code> est√° dividida en m√°s de 70 interfaces.  No les dar√© todos, pero mostrar√© por qu√© categor√≠as se pueden dividir.  Para obtener m√°s informaci√≥n, consulte la partici√≥n de ICorDebug, donde se ha publicado esta lista. </p><br><ul><li>  <strong>Nivel superior</strong> : ICorDebug + ICorDebug2: interfaces de nivel superior que sirven perfectamente como una colecci√≥n de objetos ICorDebugProcess. </li><li>  <strong>Callbacks</strong> : los eventos de depuraci√≥n de c√≥digo administrado se env√≠an mediante m√©todos al objeto de devoluci√≥n de llamada implementado por el depurador. </li><li>  <strong>Proceso</strong> : este conjunto de interfaces representa el c√≥digo de trabajo e incluye API relacionadas con eventos. </li><li>  <strong>Inspecci√≥n de c√≥digo / tipo</strong> : funciona principalmente con im√°genes PE est√°ticas, pero existen m√©todos convenientes para datos reales. </li><li>  <strong>Control de ejecuci√≥n</strong> : capacidad para monitorear el progreso del hilo.  En la pr√°ctica, esto significa la capacidad de establecer puntos de interrupci√≥n (F9) y recorrer el c√≥digo (entrada de c√≥digo F11, omisi√≥n de c√≥digo F10, salida de c√≥digo S + F11).  La funci√≥n de control de ejecuci√≥n ICorDebug solo funciona en c√≥digo administrado. </li><li>  <strong>Subprocesos + pilas de llamadas</strong> : las <strong>pilas de llamadas</strong> son la base de las funciones de inspecci√≥n implementadas por el depurador.  El trabajo con la pila de llamadas se lleva a cabo utilizando las siguientes interfaces.  ICorDebug solo admite la depuraci√≥n de c√≥digo administrado y, en consecuencia, puede rastrear la pila de solo c√≥digo administrado. </li><li>  <strong>Inspecci√≥n de objetos</strong> : la <strong>inspecci√≥n de objetos</strong> es parte de la API que le permite ver los valores de las variables en el c√≥digo depurado.  Para cada interfaz, doy el m√©todo MVP, que, me parece, deber√≠a describir brevemente el prop√≥sito de esta interfaz. </li></ul><br><p>  Al igual que con las API de creaci√≥n de perfiles, los niveles de soporte de API de depuraci√≥n var√≠an seg√∫n el sistema operativo y la arquitectura del procesador.  Por ejemplo, a partir de agosto de 2018, todav√≠a no existe una soluci√≥n ARM de Linux para diagnosticar y depurar c√≥digo administrado.  Para obtener m√°s informaci√≥n sobre la compatibilidad con Linux, consulte la publicaci√≥n Depuraci√≥n de .NET Core en Linux con LLDB y el repositorio de Diagn√≥sticos de Microsoft, cuyo objetivo es facilitar la depuraci√≥n de programas .NET para Linux. </p><br><p>  Finalmente, si desea ver c√≥mo se ve la API <code>ICorDebug</code> en C #, eche un vistazo a los contenedores en la biblioteca CLRMD, incluidas todas las devoluciones de llamada disponibles (m√°s adelante en esta publicaci√≥n se discutir√° m√°s sobre CLRMD). </p><br><h3 id="sos-i-dac">  SOS y DAC </h3><br><p>  El componente de acceso a datos (DAC) se analiza en detalle en <a href="">la p√°gina BOTR</a> .  Esencialmente, proporciona acceso fuera del proceso a las estructuras de datos CLR para que la informaci√≥n dentro de ellas pueda leerse desde otro proceso.  Por lo tanto, el depurador (a trav√©s de <code>ICorDebug</code> ) o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la extensi√≥n 'Son of Strike' (SOS)</a> puede acceder a la instancia CLR en ejecuci√≥n o al volcado de memoria y encontrar, por ejemplo: </p><br><ul><li>  todos los hilos en ejecuci√≥n; </li><li>  objetos gestionados del mont√≥n </li><li>  informaci√≥n completa sobre el m√©todo, incluido el c√≥digo de m√°quina; </li><li>  rastro actual de la pila. </li></ul><br><p>  <strong>Una peque√±a digresi√≥n</strong> : si desea averiguar de d√≥nde provienen estos nombres extra√±os y obtener una peque√±a lecci√≥n sobre el historial de .NET, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta respuesta en Stack Overflow</a> . </p><br><p>  La lista completa de comandos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SOS</a> es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">impresionante</a> .  Si lo usa junto con WinDBG, puede averiguar qu√© est√° sucediendo dentro de su programa y el CLR a un nivel muy bajo.  Para ver c√≥mo se implementa todo, veamos el <code>!HeapStat</code> , que muestra una descripci√≥n de los tama√±os de los diversos montones que utiliza .NET GC: </p><br><p>  (Imagen tomada de SOS: La pr√≥xima versi√≥n tiene algunos comandos nuevos: HeapStat) </p><br><p>  Aqu√≠ hay una secuencia de c√≥digo que muestra c√≥mo SOS y DAC trabajan juntos: </p><br><ul><li>  <strong>SOS</strong> Complete Team <code>!HeapStat</code> ( <a href="">enlace</a> ) </li><li>  C√≥digo <strong>SOS</strong> en el <code>!HeapStat</code> que funciona con Workstation GC (enlace) </li><li>  Funci√≥n <strong>SOS</strong> <code>GCHeapUsageStats(..)</code> , que realiza la parte m√°s dif√≠cil del trabajo ( <a href="">enlace</a> ) </li><li>  <code>DacpGcHeapDetails</code> datos <code>DacpGcHeapDetails</code> <strong>compartida</strong> que contiene punteros a los datos principales en el mont√≥n de GC, como segmentos, m√°scaras de bits y generaciones individuales ( <a href="">referencia</a> ). </li><li>  <code>GetGCHeapStaticData</code> <strong>DAC</strong> <code>GetGCHeapStaticData</code> que llena la estructura <code>DacpGcHeapDetails</code> ( <a href="">enlace</a> ) </li><li>  <code>DacpHeapSegmentData</code> datos <code>DacpHeapSegmentData</code> <strong>compartida</strong> que contiene informaci√≥n sobre un segmento de mont√≥n de GC individual ( <a href="">enlace</a> ) </li><li>  <strong>DAC</strong> <code>GetHeapSegmentData(..)</code> , que <code>DacpHeapSegmentData</code> estructura <code>DacpHeapSegmentData</code> ( <a href="">enlace</a> ) </li></ul><br><h3 id="storonnie-otladchiki">  Depuradores de terceros </h3><br><p>  Desde que Microsoft public√≥ la API de depuraci√≥n, los desarrolladores <code>ICorDebug</code> pudieron usar las interfaces <code>ICorDebug</code> .  Aqu√≠ hay una lista de los que pude encontrar: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Samsung</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Debugger para .NET Core runtime</a> <br><ul><li>  El depurador le permite utilizar la interfaz del adaptador de depuraci√≥n GDB / MI o VSCode para corregir errores en aplicaciones .NET desde el tiempo de ejecuci√≥n de .NET Core. </li><li>  <em>Probablemente</em> escrito como parte de un proyecto para portar <a href="">.NET Core a su sistema operativo Tizen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dnSpy</a> : depurador .NET y editor de ensamblajes <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una herramienta muy poderosa</a> .  Este es un depurador, editor de ensamblaje, editor hexadecimal, descompilador y mucho m√°s. </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MDbg.exe (depurador de l√≠nea de comandos de .NET Framework)</a> <br><ul><li>  Disponible como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paquete NuGet</a> .  Tambi√©n se puede descargar desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el repositorio de GitHub</a> o el sitio web de Microsoft. </li><li>  Sin embargo, por el momento, MDBG no parece admitir .NET Core.  Consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Port MDBG a CoreCLR</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ETA para portar mdbg a coreclr para obtener m√°s informaci√≥n</a> . </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JetBrains 'Rider' le</a> permite depurar .NET Core en Windows. <br><ul><li>  Hubo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algunos problemas de</a> licencia con esta herramienta. </li><li>  Se puede encontrar m√°s informaci√≥n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este hilo de HackerNews.</a> </li></ul></li></ul><br><h3 id="dampy-pamyati">  Volcados de memoria </h3><br><p>  De lo √∫ltimo que hablaremos es de los volcados de memoria, que se pueden obtener de un sistema de trabajo y analizar fuera de √©l.  El tiempo de ejecuci√≥n de .NET siempre ha admitido el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">volcado de memoria en Windows</a> .  Y ahora que .NET Core se ha convertido en multiplataforma, han aparecido herramientas que realizan la misma tarea en otros sistemas operativos. </p><br><p>  Cuando se utilizan volcados de memoria, a veces es dif√≠cil obtener las versiones correctas y coincidentes de los archivos SOS y DAC.  Afortunadamente, Microsoft lanz√≥ recientemente la herramienta CLI de <code>dotnet symbol</code> dotnet, que: </p><br><blockquote>  puede descargar todos los archivos necesarios para la depuraci√≥n (conjuntos de caracteres, m√≥dulos, archivos SOS y DAC para un m√≥dulo coreclr espec√≠fico) para cualquier volcado de n√∫cleo espec√≠fico, minivolcado o archivos de cualquier plataforma compatible, incluidos ELF, MachO, DLL de Windows, PDB y port√°tiles PDB </blockquote><p>  Finalmente, si est√° analizando un poco los volcados de memoria, le recomiendo que eche un vistazo a la excelente biblioteca CLR MD que Microsoft lanz√≥ hace varios a√±os.  Ya escrib√≠ sobre sus funciones.  En resumen, con la biblioteca, puede trabajar con volcados de memoria a trav√©s de una API C # intuitiva que contiene clases que proporcionan acceso a ClrHeap, GC Roots, CLR Threads, Stack Frames y mucho m√°s.  De hecho, CLR MD puede implementar la mayor√≠a (si no todos) de los comandos SOS. </p><br><p>  Puedes averiguar c√≥mo funciona en esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n</a> : </p><br><blockquote>  La Biblioteca administrada de ClrMD es una envoltura alrededor de las API de depuraci√≥n destinadas al uso interno solo en el CLR.  A pesar de que estas API son muy efectivas para el diagn√≥stico, no las admitimos en forma de lanzamientos p√∫blicos y documentados, ya que su uso es complejo y est√° estrechamente relacionado con otras caracter√≠sticas de la implementaci√≥n de CLR.  ClrMD resuelve este problema al proporcionar un contenedor f√°cil de usar y manejable alrededor de estas API de depuraci√≥n de bajo nivel. </blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466097/">https://habr.com/ru/post/466097/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466075/index.html">C√≥mo dej√© la ciencia b√°sica en una startup</a></li>
<li><a href="../466077/index.html">Transmitir el D√≠a del Techdir en San Petersburgo</a></li>
<li><a href="../466081/index.html">3 de septiembre</a></li>
<li><a href="../466089/index.html">Algoritmo de pensamiento y conciencia, parte 2</a></li>
<li><a href="../466093/index.html">¬øC√≥mo funciona kubectl exec?</a></li>
<li><a href="../466099/index.html">Caracter√≠sticas de probar una aplicaci√≥n web para servicio de video</a></li>
<li><a href="../466103/index.html">Monitoreo de seguridad en la nube</a></li>
<li><a href="../466105/index.html">Overclocking Magento Rest API con RoadRunner</a></li>
<li><a href="../466107/index.html">Sistema de hogar inteligente h√°galo usted mismo</a></li>
<li><a href="../466109/index.html">Resoluci√≥n de problemas con pwnable.kr 22 - brainfuck. Ataque Ret2libc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>