<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌔 🌌 🚶🏻 PostgreSQL反模式：将集合和选择传递给SQL 🤥 🧚🏼 ➗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="开发人员有时需要将一组参数传递给请求，甚至需要传递整个 “输入” 选择 。 有时会遇到非常奇怪的解决方案。 

 让我们从相反的角度出发，看看它不值得做什么，为什么以及如何做得更好。 

 直接将值插入请求主体 
 通常看起来像这样： 



query = "SELECT * FROM tbl W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL反模式：将集合和选择传递给SQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/481122/"> 开发人员有时需要<b>将一组参数传递给请求，甚至</b>需要<b>传递整个</b> “输入” <b>选择</b> 。 有时会遇到非常奇怪的解决方案。 <br><img src="https://habrastorage.org/webt/gy/db/kv/gydbkvfvb0m5yahydebhfhyadb4.png"><br> 让我们从相反的角度出发，看看它不值得做什么，为什么以及如何做得更好。 <br><a name="habracut"></a><br><h2> 直接将值插入请求主体 </h2><br> 通常看起来像这样： <br><br><pre><code class="plaintext hljs">query = "SELECT * FROM tbl WHERE id = " + value</code> </pre> <br>  ...左右： <br><br><pre> <code class="plaintext hljs">query = "SELECT * FROM tbl WHERE id = :param".format(param=value)</code> </pre> <br> 关于这种方法，据说， <a href="https://xkcd.com/327/">甚至</a>写得很丰富： <br><br><img src="https://habrastorage.org/webt/ir/e8/73/ire873nizb3svo3sm7z6lemdoqk.png"><br><br> 几乎总是这样，这是<b>通向SQL注入</b>的<b>直接路径，</b>并且给业务逻辑带来了额外的负担，这被迫“粘合”查询字符串。 <br><br> 仅当需要在PostgreSQL 10及更低版本的PostgreSQL中<b>使用section</b>以获得更有效的计划时，这种方法才可以部分证明是合理的。 在这些版本中，即使不考虑传输的参数，也仅基于请求主体来确定扫描部分的列表。 <br><br><h2>  $ n参数 </h2><br> 使用参数<a href="https://postgrespro.ru/docs/postgresql/12/xfunc-sql">占位符</a>是好的，它允许您使用<a href="https://postgrespro.ru/docs/postgresql/12/sql-prepare">PREPARED STATEMENTS</a> ，减少业务逻辑（查询字符串仅生成和传输一次）和数据库服务器（不需要为每个请求实例重新解析和计划）的负载。 <br><br><h4> 可变数量的参数 </h4><br> 当我们想提前传递未知数量的参数时，问题将等待我们： <br><br><pre> <code class="sql hljs">... id IN ($1, $2, $3, ...) <span class="hljs-comment"><span class="hljs-comment">-- $1 : 2, $2 : 3, $3 : 5, ...</span></span></code> </pre> <br> 如果您以这种形式保留请求，那么尽管它可以使我们免于潜在的注入，但仍然需要<b>根据参数数量对每个选项</b>的请求<b>进行</b>粘合/解析。 比每次都做的更好，但是您可以不用它。 <br><br> 仅传递一个包含<b>数组</b>的<b>序列化表示形式的</b>参数就足够<b>了</b> ： <br><br><pre> <code class="sql hljs">... id = ANY($1::integer[]) <span class="hljs-comment"><span class="hljs-comment">-- $1 : '{2,3,5,8,13}'</span></span></code> </pre> <br> 唯一的区别是需要将参数显式转换为所需的数组类型。 但这不会引起问题，因为我们已经提前知道了要解决的问题。 <br><br><h4> 样品转移（矩阵） </h4><br> 通常，这些都是用于“在一个请求中”将数据集插入数据库的各种选项： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tbl(k, v) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>($<span class="hljs-number"><span class="hljs-number">1</span></span>,$<span class="hljs-number"><span class="hljs-number">2</span></span>),($<span class="hljs-number"><span class="hljs-number">3</span></span>,$<span class="hljs-number"><span class="hljs-number">4</span></span>),...</code> </pre> <br> 除了上述“重新粘贴”请求问题之外，这还可能导致<b>内存不足</b>和服务器崩溃。 原因很简单-PG为参数保留了额外的内存，并且集合中的记录数仅受所应用的愿望清单业务逻辑的限制。 在特别是临床情况下，人们不得不看到<i>“编号”的论点大于9,000美元</i> -无需这样做。 <br><br> 我们使用<b>“两级”序列化</b>重写请求： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span> k , <span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>]::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>($<span class="hljs-number"><span class="hljs-number">1</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>[])::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>[] <span class="hljs-comment"><span class="hljs-comment">-- $1 : '{"{a,1}","{b,2}","{c,3}","{d,4}"}' ) T;</span></span></code> </pre><br> 是的，在数组内部为“复杂”值的情况下，它们需要用引号引起来。 <br> 显然，您可以用任意数量的字段“扩展”选择范围。 <br><br><h4> 巢，巢，... </h4><br> 定期有传输选项，而不是几个“列数组”的“数组数组”，我<a href="https://habr.com/ru/post/479920/">在上一篇文章中</a>提到<a href="https://habr.com/ru/post/479920/">过</a> ： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>($<span class="hljs-number"><span class="hljs-number">1</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>[]) k , <span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>($<span class="hljs-number"><span class="hljs-number">2</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>[]) v;</code> </pre> <br> 使用这种方法，在生成不同列的值列表时会出错，因此获得完全<b>意外的结果</b>非常简单，这也取决于服务器版本： <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- $1 : '{a,b,c}', $2 : '{1,2}' -- PostgreSQL 9.4 k | v ----- a | 1 b | 2 c | 1 a | 2 b | 1 c | 2 -- PostgreSQL 11 k | v ----- a | 1 b | 2 c |</span></span></code> </pre> <br><h2> 杰森 </h2><br> 从9.3版开始，PostgreSQL引入了完善的函数来处理json类型。 因此，如果在浏览器中定义了输入参数，则可以<b>在</b>此处<b>为SQL查询</b>创建一个<b>json对象</b> ： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> k , <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_each($<span class="hljs-number"><span class="hljs-number">1</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>); <span class="hljs-comment"><span class="hljs-comment">-- '{"a":1,"b":2,"c":3,"d":4}'</span></span></code> </pre> <br> 对于以前的版本， <b>每个（hstore）</b>都可以使用相同的方法，但是在hstore中转义复杂对象的正确“卷积”会导致问题。 <br><br><h4>  json_populate_recordset </h4><br> 如果预先知道来自“输入” json数组的数据将填充某种表，则可以使用json_populate_recordset函数在“解引用”字段并将其转换为必要的类型方面节省很多： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_populate_recordset( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>::pg_class , $<span class="hljs-number"><span class="hljs-number">1</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">json</span></span> <span class="hljs-comment"><span class="hljs-comment">-- $1 : '[{"relname":"pg_class","oid":1262},{"relname":"pg_namespace","oid":2615}]' );</span></span></code> </pre> <br><h4>  json_to_recordset </h4><br> 而且此函数只是简单地将转移的对象数组“扩展”到选择中，而无需依赖表格式： <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_to_recordset($<span class="hljs-number"><span class="hljs-number">1</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>) T(k <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, v <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-comment"><span class="hljs-comment">-- $1 : '[{"k":"a","v":1},{"k":"b","v":2}]' k | v ----- a | 1 b | 2</span></span></code> </pre> <br><h2> 临时表 </h2><br> 但是，如果传输的样本中的数据量非常大，则将其放入一个序列化参数很困难，有时甚至是不可能的，因为它需要一次性<b>分配大量内存</b> 。 例如，您需要长期，长时间地从外部系统收集有关事件的大数据包，然后希望在数据库端对其进行一次处理。 <br><br> 在这种情况下，最好的解决方案是使用<a href="https://postgrespro.ru/docs/postgresql/12/sql-createtable">临时表</a> ： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TEMPORARY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl(k <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, v <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); ... <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tbl(k, v) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">--  -  ... --   -      </span></span></code> </pre><br> 该方法<b>适用于罕见的大量</b>数据传输。 <br> 从描述其数据结构的角度来看，临时表与<i>pg_class系统表中</i>的“正常”功能只有一个功能不同，而在<i>pg_type，pg_depend，pg_attribute，pg_attrdef等方面则</i>完全没有。 <br><br> 因此，在每个都有大量短期连接的Web系统中，这样的表每次都会生成新的系统记录，并在与数据库的连接关闭时将其删除。 结果， <b>对TEMP TABLE</b>的<b>不受控制的使用导致pg_catalog中的表“膨胀”，</b>并减慢了使用它们的许多操作。 <br> 当然，这可以借助<i>VACUUM FULL定期</i>遍历系统目录表来解决。 <br><br><h2> 会话变量 </h2><br> 假设对于单个SQL查询，前一种情况下的数据处理非常复杂，但是您要经常这样做。 也就是说，我们希望在<a href="https://postgrespro.ru/docs/postgresql/12/sql-do">DO块中</a>使用过程处理，但是通过临时表使用数据传输将太昂贵。 <br><br> 我们也将无法使用$ n参数来转移到匿名块。 会话变量和<b>current_setting</b>函数将帮助我们摆脱这种情况。 <br><br> 在9.2版之前，有必要为“您的”会话变量预先配置<i>custom_variable_classes</i> <a href="https://www.postgresql.org/docs/9.1/runtime-config-custom.html">命名空间</a> 。 在当前版本中，您可以编写如下内容： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> my.val = <span class="hljs-string"><span class="hljs-string">'{1,2,3}'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>(current_setting(<span class="hljs-string"><span class="hljs-string">'my.val'</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>[])) <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RAISE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOTICE</span></span> <span class="hljs-string"><span class="hljs-string">'id : %'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $$ LANGUAGE plpgsql; <span class="hljs-comment"><span class="hljs-comment">-- NOTICE: id : 1 -- NOTICE: id : 2 -- NOTICE: id : 3</span></span></code> </pre> <br> 其他受支持的过程语言可以找到其他解决方案。 <br><br>  <i>你知道更多方法吗？</i>  <i>分享评论！</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481122/">https://habr.com/ru/post/zh-CN481122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481112/index.html">5700岁的“口香糖”会告诉咀嚼它的人吗？</a></li>
<li><a href="../zh-CN481114/index.html">Kubernetes上的Seccomp：从一开始就需要了解的7件事</a></li>
<li><a href="../zh-CN481116/index.html">自动将VKontakte社区中的帖子发布到Discord</a></li>
<li><a href="../zh-CN481118/index.html">匿名圣诞老人2019-2020：吹嘘新年礼物</a></li>
<li><a href="../zh-CN481120/index.html">边缘服务器在哪里以及如何应用？</a></li>
<li><a href="../zh-CN481124/index.html">编写自我文档代码的技巧</a></li>
<li><a href="../zh-CN481126/index.html">程序员工会？ 不要告诉我的拖鞋</a></li>
<li><a href="../zh-CN481130/index.html">TOP12跨学科科学发现2019</a></li>
<li><a href="../zh-CN481134/index.html">如何评估服务的容量而不承受负载</a></li>
<li><a href="../zh-CN481138/index.html">这些人创造人工智能-AI和ML专家的4个故事</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>