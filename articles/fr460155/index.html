<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßì üçï üìõ ReactiveX Redux üõÄüèæ üë©üèº‚Äçüíª ‚öõÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quiconque travaille avec Redux se heurtera t√¥t ou tard au probl√®me des actions asynchrones. Mais une application moderne ne peut √™tre d√©velopp√©e sans ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ReactiveX Redux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfa/blog/460155/">  Quiconque travaille avec Redux se heurtera t√¥t ou tard au probl√®me des actions asynchrones.  Mais une application moderne ne peut √™tre d√©velopp√©e sans eux.  Ce sont des requ√™tes http vers le backend, et toutes sortes de temporisations / retards.  Les cr√©ateurs Redux eux-m√™mes parlent sans ambigu√Øt√© - par d√©faut, seul le flux de donn√©es synchrone est pris en charge, toutes les actions asynchrones doivent √™tre plac√©es dans le middleware. <br><br>  Bien s√ªr, cela est trop verbeux et peu pratique, il est donc difficile de trouver un d√©veloppeur qui utilise uniquement le middleware ¬´natif¬ª.  Les biblioth√®ques et les frameworks tels que Thunk, Saga et similaires viennent toujours √† la rescousse. <br><br>  Pour la plupart des t√¢ches, elles suffisent.  Mais que se passe-t-il si une logique un peu plus complexe est n√©cessaire que d'envoyer une demande ou de cr√©er un temporisateur?  Voici un petit exemple: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> dispatch =&gt; { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> .all([fetchOne, fetchTwo]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[respOne, respTwo]</span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo }); }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }); } }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }</code> </pre> <br>  Il est m√™me p√©nible de regarder un tel code, mais il est tout simplement impossible de le maintenir et de le d√©velopper.  Que faire lorsqu'un traitement d'erreur plus sophistiqu√© est n√©cessaire?  Et si vous avez besoin d'une demande r√©p√©t√©e?  Et si je veux r√©utiliser cette fonctionnalit√©? <br><br>  Je m'appelle Dmitry Samokhvalov, et dans ce post, je vais vous dire quel est le concept d'Observable et comment le mettre en pratique en collaboration avec Redux, et aussi comparer tout cela avec les capacit√©s de Redux-Saga. <br><a name="habracut"></a><br>  En r√®gle g√©n√©rale, dans de tels cas, prenez redux-saga.  OK, nous r√©√©crivons les sagas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(delay, <span class="hljs-number"><span class="hljs-number">2000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [respOne, respTwo] = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> [ call(fetchOne), call(fetchTwo) ]; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }); }</code> </pre><br>  Il est devenu sensiblement meilleur - le code est presque lin√©aire, semble et lit mieux.  Mais l'expansion et la r√©utilisation sont toujours difficiles, car la saga est tout aussi imp√©rative que le thunk. <br><br>  Il existe une autre approche.  C'est exactement l'approche, et pas seulement une autre biblioth√®que pour √©crire du code asynchrone.  On l'appelle Rx (ce sont aussi des observables, des flux r√©actifs, etc.).  Nous allons l'utiliser et r√©√©crire l'exemple sur Observable: <br><br><pre> <code class="javascript hljs">action$ .delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>) .switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable.merge(fetchOne, fetchTwo) .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[respOne, respTwo]</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo })) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }))</code> </pre> <br>  Le code est non seulement devenu plat et a diminu√© de volume, mais le principe m√™me de la description des actions asynchrones a chang√©.  Maintenant, nous ne travaillons pas directement avec les requ√™tes, mais effectuons des op√©rations sur des objets sp√©ciaux appel√©s Observable. <br><br>  Il est pratique de repr√©senter Observable comme une fonction qui donne un flux (s√©quence) de valeurs.  Observable a trois √©tats principaux - suivant (¬´donner la valeur suivante¬ª), erreur (¬´une erreur s'est produite¬ª) et complet (¬´les valeurs sont termin√©es, il n'y a plus rien √† donner¬ª).  √Ä cet √©gard, c'est un peu comme Promise, mais diff√®re en ce qu'il est possible d'it√©rer sur ces valeurs (et c'est l'une des superpuissances observables).  Vous pouvez envelopper n'importe quoi dans Observable - timeouts, requ√™tes http, √©v√©nements DOM, juste des objets js. <br><br><img src="https://habrastorage.org/webt/be/qu/yr/bequyrg-gjvichysgtzom-c0mju.png" width="540"><br><br>  Les deuxi√®mes superpuissances observables sont les op√©rateurs.  Un op√©rateur est une fonction qui accepte et renvoie un observable, mais effectue une action sur le flux de valeurs.  L'analogie la plus proche est la carte et le filtre de javascript (en passant, ces op√©rateurs sont en Rx). <br><br><img src="https://habrastorage.org/webt/bu/hi/mc/buhimcdgpjmngscttymdt1rzsqk.png" width="540"><br><br>  Les plus utiles pour moi personnellement √©taient les op√©rateurs zip, forkJoin et flatMap.  En utilisant leur exemple, il est plus facile d'expliquer le travail des op√©rateurs. <br><br>  L'op√©rateur zip fonctionne tr√®s simplement - il prend quelques Observable (pas plus de 9) et retourne dans un tableau les valeurs qu'ils √©mettent. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = fromEvent(<span class="hljs-string"><span class="hljs-string">"mousedown"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = fromEvent(<span class="hljs-string"><span class="hljs-string">"mouseup"</span></span>); zip(first, second) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${e[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">].x}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${e[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">].x}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//output [119,120] [120,233] ‚Ä¶</span></span></code> </pre><br>  En g√©n√©ral, le travail de zip peut √™tre repr√©sent√© par le sch√©ma: <br><br><img src="https://habrastorage.org/webt/zu/4j/in/zu4jinxmtwpt4vs3azoy81a6xpc.png" width="540"><br><br>  Zip est utilis√© si vous avez plusieurs observables et que vous devez en recevoir syst√©matiquement des valeurs (malgr√© le fait qu'elles peuvent √™tre √©mises √† diff√©rents intervalles, de mani√®re synchrone ou non).  Il est tr√®s utile lorsque vous travaillez avec des √©v√©nements DOM. <br><br>  L'instruction forkJoin est similaire √† zip √† une exception pr√®s - elle ne renvoie que les derni√®res valeurs de chaque observable. <br><br><img src="https://habrastorage.org/webt/3p/mb/s6/3pmbs6uzqz4w9c3fklfhslw6j6k.png" width="540"><br><br>  En cons√©quence, il est raisonnable de l'utiliser lorsque seules des valeurs finies du flux sont n√©cessaires. <br>  L'op√©rateur flatMap est un peu plus compliqu√©.  Il prend un observable en entr√©e et renvoie un nouvel observable, et mappe les valeurs de celui-ci au nouvel observable, en utilisant soit une fonction de s√©lection, soit un autre observable.  Cela peut sembler d√©routant, mais le diagramme est assez simple: <br><br><img src="https://habrastorage.org/webt/kz/7t/fn/kz7tfnjuhklblx5czaxhbs06_mi.png" width="540"><br><br>  Encore plus clair dans le code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string"> World`</span></span>); observable .flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> promise(value)) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result)); <span class="hljs-comment"><span class="hljs-comment">//output "Hello World"</span></span></code> </pre> <br>  Le plus souvent, flatMap est utilis√© dans les demandes d'arri√®re-plan, avec switchMap et concatMap. <br>  Comment puis-je utiliser Rx dans Redux?  Il existe une merveilleuse biblioth√®que redux-observable pour cela.  Son architecture ressemble √† ceci: <br><br><img src="https://habrastorage.org/webt/9p/y1/kv/9py1kvsgrpqjaovs3zrukrghbwc.png" width="540"><br><br>  Tous les op√©rateurs et actions observables sur ceux-ci se pr√©sentent sous la forme d'un middleware sp√©cial appel√© epic.  Chaque √©pop√©e prend une action en entr√©e, l'enveloppe dans un observable et doit retourner une action, √©galement en observable.  Vous ne pouvez pas retourner une action r√©guli√®re, cela cr√©e une boucle sans fin.  √âcrivons une petite √©pop√©e qui fait une demande √† l'API. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchEpic = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action$</span></span></span><span class="hljs-function"> =&gt;</span></span> action$ .ofType(<span class="hljs-string"><span class="hljs-string">'FETCH_INFO'</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_START'</span></span> })) .flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable .from(apiRequest) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_SUCCESS'</span></span>, data })) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_ERROR'</span></span>, error })) )</code> </pre><br>  Il est impossible de le faire sans comparer redux-observable et redux-saga.  Il semble √† beaucoup qu'ils sont proches en termes de fonctionnalit√©s et de capacit√©s, mais ce n'est pas du tout le cas.  Les sagas sont un outil absolument imp√©ratif, essentiellement un ensemble de m√©thodes pour travailler avec les effets secondaires.  Observable est un style fondamentalement diff√©rent d'√©criture de code asynchrone, si vous voulez, une philosophie diff√©rente. <br><br>  J'ai √©crit plusieurs exemples pour illustrer les possibilit√©s et l'approche de r√©solution des probl√®mes. <br><br>  Supposons que nous devons impl√©menter un temporisateur qui s'arr√™tera par action.  Voici √† quoi cela ressemble dans les sagas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> race({ <span class="hljs-attr"><span class="hljs-attr">stopped</span></span>: take(<span class="hljs-string"><span class="hljs-string">'STOP'</span></span>), <span class="hljs-attr"><span class="hljs-attr">tick</span></span>: call(wait, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!timer.stopped) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put(actions.tick()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } }</code> </pre> <br>  Utilisez maintenant Rx: <br><br><pre> <code class="javascript hljs">interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .takeUntil(action$.ofType(<span class="hljs-string"><span class="hljs-string">'STOP'</span></span>))</code> </pre> <br><br>  Supposons qu'il existe une t√¢che pour impl√©menter une demande avec annulation dans les sagas: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchSaga</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(fetchUser); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-string"><span class="hljs-string">'FETCH'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchSaga = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fork(fetchSaga); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-string"><span class="hljs-string">'FETCH_CANCEL'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> cancel(fetchSaga); }</code> </pre> <br>  Tout est plus simple sur Rx: <br><br><pre> <code class="javascript hljs">switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchUser()) .takeUntil(action$.ofType(<span class="hljs-string"><span class="hljs-string">'FETCH_CANCEL'</span></span>))</code> </pre> <br>  Enfin, mon pr√©f√©r√©.  Mettre en ≈ìuvre une demande d'API, en cas d'√©chec ne pas faire plus de 5 demandes r√©p√©t√©es avec un d√©lai de 2 secondes.  Voici ce que nous avons dans les sagas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> apiResponse = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(apiRequest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apiResponse; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(); }</code> </pre> <br>  Que se passe-t-il sur Rx: <br><br><pre> <code class="javascript hljs">.retryWhen(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors</span></span></span><span class="hljs-function"> =&gt;</span></span> errors .delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .take(<span class="hljs-number"><span class="hljs-number">5</span></span>))</code> </pre><br>  Si vous r√©sumez les avantages et les inconv√©nients de la saga, vous obtenez l'image suivante: <br><br><img src="https://habrastorage.org/webt/y6/bs/un/y6bsun3cbbwp4tayqhuuhwpudyc.png" width="540"><br><br>  Les sagas sont faciles √† apprendre et tr√®s populaires, donc dans la communaut√©, vous pouvez trouver des recettes pour presque toutes les occasions.  Malheureusement, le style imp√©ratif emp√™che l'utilisation des sagas de mani√®re vraiment flexible. <br><br>  Rx a une situation compl√®tement diff√©rente: <br><br><img src="https://habrastorage.org/webt/mc/5a/wx/mc5awxjs7lszbo9jcq-qzrzg2qa.png" width="540"><br><br>  Il peut sembler que Rx est un marteau magique et une balle d'argent.  Ce n'est malheureusement pas le cas.  Le seuil pour entrer Rx est beaucoup plus √©lev√©, il est donc plus difficile d'initier une nouvelle personne √† un projet qui utilise activement Rx. <br><br>  De plus, lorsque vous travaillez avec Observable, il est particuli√®rement important d'√™tre prudent et de toujours bien comprendre ce qui se passe.  Sinon, vous risquez de tomber sur des erreurs non √©videntes ou un comportement non d√©fini. <br><br><pre> <code class="javascript hljs">action$ .ofType(<span class="hljs-string"><span class="hljs-string">'DELETE'</span></span>) .switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable .fromPromise(deleteRequest) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'DELETE_SUCCESS'</span></span>})))</code> </pre> <br>  Une fois que j'ai √©crit une √©pop√©e qui a fait un travail assez simple - avec chaque action de type 'SUPPRIMER', une m√©thode API a √©t√© appel√©e pour supprimer l'√©l√©ment.  Cependant, il y a eu des probl√®mes lors des tests.  Le testeur s'est plaint d'un comportement √©trange - parfois, lorsque vous avez cliqu√© sur le bouton Supprimer, rien ne s'est produit.  Il s'est av√©r√© que l'op√©rateur switchMap prend en charge l'ex√©cution d'un seul observable √† la fois, une sorte de protection contre les conditions de concurrence. <br><br>  En cons√©quence, je vais donner quelques recommandations que je suis et exhorter tous ceux qui commencent √† travailler avec Rx √† suivre: <br><br><ul><li>  Soyez prudent. </li><li>  Consultez la documentation. </li><li>  V√©rifiez dans le bac √† sable. </li><li>  √âcrivez des tests. </li><li>  Ne tirez pas sur les moineaux avec le canon. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460155/">https://habr.com/ru/post/fr460155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460143/index.html">Module dis de Python et convolution de constantes</a></li>
<li><a href="../fr460147/index.html">Framework de microservices PHP - Swoft 2.0.3 publi√©</a></li>
<li><a href="../fr460149/index.html">Typage correct: l'aspect sous-estim√© du code propre</a></li>
<li><a href="../fr460151/index.html">Conception orient√©e mod√®le. Moteur CC sans balais</a></li>
<li><a href="../fr460153/index.html">Les aventures des signatures √©lectroniques en Russie</a></li>
<li><a href="../fr460157/index.html">Comment les r√©ponses ¬´correctes¬ª des r√©pondants peuvent fausser les r√©sultats de l'enqu√™te au-del√† de la reconnaissance</a></li>
<li><a href="../fr460159/index.html">M√©thode de surveillance de l'√©tat actuel des routes russes par les smartphones des utilisateurs</a></li>
<li><a href="../fr460161/index.html">FusionPBX et ACL</a></li>
<li><a href="../fr460163/index.html">Comme il semblait</a></li>
<li><a href="../fr460165/index.html">Contexte: cryptographie √† doigts quantiques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>