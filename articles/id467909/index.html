<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“ ğŸ‘©ğŸ½â€ğŸ¤ ğŸš™ Obrolan di iOS: menggunakan soket ğŸŠ ğŸ•´ğŸ½ ğŸ“«</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gambar dibuat oleh rawpixel.com 

 Dalam publikasi ini, kita akan turun ke lapisan TCP, belajar tentang soket dan alat-alat dari Core Foundation mengg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Obrolan di iOS: menggunakan soket</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467909/"><img src="https://habrastorage.org/webt/dn/dv/gc/dndvgcrra0mv7ipvglf1ywvxdaw.png"><br>  <i>Gambar dibuat oleh rawpixel.com</i> <br><br>  Dalam publikasi ini, kita akan turun ke lapisan TCP, belajar tentang soket dan alat-alat dari Core Foundation menggunakan contoh mengembangkan aplikasi obrolan. <br><br>  Perkiraan waktu membaca: 25 menit. <br><a name="habracut"></a><br><h2>  Mengapa soket? </h2><br>  Anda mungkin bertanya-tanya: "Mengapa saya harus pergi satu tingkat lebih rendah dari <b>URLSession</b> ?"  Jika Anda cukup pintar dan tidak mengajukan pertanyaan ini, langsung ke bagian selanjutnya. <br><br><div class="spoiler">  <b class="spoiler_title">Jawabannya untuk tidak begitu pintar</b> <div class="spoiler_text"> Pertanyaan bagus!  Faktanya adalah bahwa penggunaan URLSession didasarkan pada <b>protokol HTTP</b> , yaitu, komunikasi terjadi dalam gaya <b>permintaan-respons</b> , kira-kira sebagai berikut: <br><br><ul><li>  meminta dari server beberapa data dalam format JSON </li><li>  dapatkan data ini, proses, tampilan, dll. </li></ul><br>  Tetapi bagaimana jika kita membutuhkan server atas inisiatifnya sendiri untuk mentransfer data ke aplikasi Anda?  Di sini HTTP tidak berfungsi. <br><br>  Tentu saja, kami dapat terus-menerus menarik server dan melihat apakah ada data untuk kami (alias <b>polling</b> ).  Atau kita bisa lebih canggih dan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">polling panjang</a> .  Tetapi semua kruk ini sedikit tidak pantas dalam kasus ini. <br><br>  Lagi pula, mengapa membatasi diri pada paradigma permintaan-respons jika itu sesuai dengan tugas kita sedikit kurang dari tidak sama sekali? <br><br>  Dalam panduan ini, Anda akan belajar cara menyelam ke tingkat abstraksi yang lebih rendah dan langsung menggunakan <b>SOCKETS</b> dalam aplikasi obrolan. <br><br>  Alih-alih memeriksa pesan baru dari server, aplikasi kami akan menggunakan stream yang tetap terbuka selama sesi obrolan. <br></div></div><br><h2>  Memulai </h2><br>  Unduh <a href="">bahan sumbernya</a> .  Ada aplikasi klien tiruan dan server sederhana yang ditulis dalam <b>Go</b> . <br><br>  Anda tidak harus menulis di Go, tetapi Anda harus menjalankan aplikasi server agar aplikasi klien dapat terhubung dengannya. <br><br><h2>  Luncurkan aplikasi server </h2><br>  Bahan sumber memiliki aplikasi terkompilasi dan sumber.  Jika Anda memiliki paranoia yang sehat dan tidak mempercayai kode kompilasi orang lain, Anda dapat mengkompilasi sendiri kode sumbernya. <br><br>  Jika Anda berani, lalu buka <b>Terminal</b> , buka direktori dengan materi yang diunduh dan jalankan perintah: <br><br><a name="a1"></a> <code>sudo ./server</code> <br> <br>  Saat diminta, masukkan kata sandi Anda.  Setelah itu Anda akan melihat pesan <br><br>  <i>Mendengarkan pada 127.0.0.1:80.</i> <br><br><blockquote>  Catatan: aplikasi server dimulai dalam mode istimewa (perintah "sudo") karena ia mendengarkan pada port 80. Semua port dengan angka kurang dari 1024 memerlukan akses khusus. </blockquote><br>  Server obrolan Anda sudah siap!  Anda dapat pergi ke bagian selanjutnya. <br><br><div class="spoiler">  <b class="spoiler_title">Jika Anda ingin mengkompilasi sendiri kode sumber server,</b> <div class="spoiler_text">  maka dalam hal ini Anda perlu menginstal <b>Go</b> menggunakan <b>Homebrew</b> . <br><br>  Jika Anda tidak memiliki Homebrew, maka Anda harus menginstalnya terlebih dahulu.  Buka Terminal dan rekatkan baris berikut di sana: <br><br> <code>/usr/bin/ruby -e \ <br> "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</code> <br> <br>  Kemudian gunakan perintah ini untuk menginstal Go: <br><br> <code>brew install go</code> <br> <br>  Pada akhirnya, buka direktori dengan bahan sumber yang diunduh dan kompilasi kode sumber aplikasi server: <br><br> <code>go build server.go</code> <br> <br>  Akhirnya, Anda dapat memulai server dengan perintah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di awal bagian ini</a> . <br></div></div><br><h2>  Kami melihat apa yang kami miliki di klien </h2><br>  Sekarang buka proyek <b>DogeChat</b> , kompilasi dan lihat apa yang ada di sana. <br><br><img src="https://habrastorage.org/webt/t5/mq/uw/t5mquwzt4dfvbn25cqglbf8sxgy.gif"><br><br>  Seperti yang Anda lihat, DogeChat sekarang memungkinkan Anda untuk memasukkan nama pengguna dan pergi ke bagian obrolan itu sendiri. <br><br>  Tampaknya pengembang proyek ini tidak tahu cara membuat obrolan.  Jadi yang kita miliki hanyalah UI dasar dan navigasi.  Kami akan menulis lapisan jaringan.  Hore! <br><br><h2>  Buat ruang obrolan </h2><br>  Untuk langsung menuju pengembangan, buka <b>ChatRoomViewController.swift</b> .  Ini adalah pengontrol tampilan yang dapat menerima teks yang dimasukkan pengguna dan menampilkan pesan yang diterima dalam tampilan tabel. <br><br>  Karena kita memiliki <b>ChatRoomViewController</b> , masuk akal untuk mengembangkan kelas <b>ChatRoom</b> yang akan melakukan semua pekerjaan kasar. <br><br>  Mari kita pikirkan tentang apa yang akan diberikan oleh kelas baru: <br><br><ul><li>  membuka koneksi ke aplikasi server; </li><li>  menghubungkan pengguna dengan nama yang ditentukan olehnya ke obrolan; </li><li>  mengirim dan menerima pesan; </li><li>  menutup koneksi di akhir. </li></ul><br>  Sekarang kita tahu apa yang kita inginkan dari kelas ini, tekan <b>Command-N</b> , pilih <b>Swift File</b> dan sebut itu <b>ChatRoom</b> . <br><br><h2>  Membuat Streaming I / O </h2><br>  <b>Ganti</b> konten <b>ChatRoom.swift</b> dengan ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ChatRoom: NSObject { <span class="hljs-comment"><span class="hljs-comment">//1 var inputStream: InputStream! var outputStream: OutputStream! //2 var username = "" //3 let maxReadLength = 4096 }</span></span></code> </pre> <br>  Di sini kita mendefinisikan kelas <b>ChatRoom</b> dan mendeklarasikan properti yang kita butuhkan. <br><br><ol><li>  Pertama kita mendefinisikan aliran input / output.  Menggunakannya sebagai pasangan akan memungkinkan kita untuk membuat koneksi soket antara aplikasi dan server obrolan.  Tentu saja, kami akan mengirim pesan menggunakan aliran output, dan menerima menggunakan aliran input. </li><li>  Selanjutnya, kami mendefinisikan nama pengguna. </li><li>  Dan akhirnya, kita mendefinisikan variabel maxReadLength, yang membatasi panjang maksimum satu pesan. </li></ol><br>  Sekarang buka file <b>ChatRoomViewController.swift</b> dan tambahkan baris ini ke daftar propertinya: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chatRoom = <span class="hljs-type"><span class="hljs-type">ChatRoom</span></span>()</code> </pre> <br>  Sekarang kita telah membuat struktur dasar kelas, sekarang saatnya untuk melakukan tugas-tugas pertama yang direncanakan: membuka koneksi antara aplikasi dan server. <br><br><h2>  Koneksi terbuka </h2><br>  Kami kembali ke ChatRoom.swift dan menambahkan metode ini untuk definisi properti: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupNetworkCommunication</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 var readStream: Unmanaged&lt;CFReadStream&gt;? var writeStream: Unmanaged&lt;CFWriteStream&gt;? // 2 CFStreamCreatePairWithSocketToHost(kCFAllocatorDefault, "localhost" as CFString, 80, &amp;readStream, &amp;writeStream) }</span></span></code> </pre> <br>  Inilah yang kami lakukan di sini: <br><br><ol><li>  pertama-tama kita mendefinisikan dua variabel untuk aliran socket tanpa menggunakan manajemen memori otomatis </li><li>  lalu kita, menggunakan variabel yang sama ini, membuat langsung stream yang terikat ke nomor host dan port. </li></ol><br>  Fungsi ini memiliki empat argumen.  Yang pertama adalah jenis pengalokasi memori yang akan kita gunakan saat menginisialisasi utas.  Anda harus menggunakan <b>kCFAllocatorDefault</b> , meskipun ada opsi lain yang mungkin jika Anda ingin mengubah perilaku utas. <br><br><div class="spoiler">  <b class="spoiler_title">Catatan Penerjemah</b> <div class="spoiler_text">  Dokumentasi untuk fungsi <b>CFStreamCreatePairWithSocketToHost</b> mengatakan: gunakan <b>NULL</b> atau <b>kCFAllocatorDefault</b> .  Dan deskripsi <b>kCFAllocatorDefault</b> mengatakan bahwa ini adalah sinonim untuk <b>NULL</b> .  Lingkaran ditutup! <br></div></div><br>  Lalu kita atur nama host.  Dalam kasus kami, kami terhubung ke server lokal.  Jika server Anda berada di tempat lain, maka Anda dapat mengatur alamat IP-nya. <br><br>  Kemudian nomor port yang didengarkan server. <br><br>  Akhirnya, kami meneruskan pointer ke stream I / O kami sehingga fungsinya dapat menginisialisasi mereka dan menghubungkannya ke stream yang dibuatnya. <br><br>  Sekarang setelah kita memiliki aliran yang diinisialisasi, kita dapat menyimpan tautan ke sana dengan menambahkan baris-baris ini di akhir metode <b>setupNetworkCommunication ()</b> : <br><br><pre> <code class="swift hljs">inputStream = readStream!.takeRetainedValue() outputStream = writeStream!.takeRetainedValue()</code> </pre> <br>  Menggunakan <b>takeRetainedValue ()</b> sebagaimana diterapkan pada objek yang tidak dikelola memungkinkan kami untuk mempertahankan referensi untuk itu dan, pada saat yang sama, menghindari kebocoran memori di masa depan.  Sekarang kita dapat menggunakan utas kami di mana pun kami inginkan. <br><br>  Sekarang kita perlu menambahkan utas ini ke <b>run loop</b> sehingga aplikasi kita memproses acara jaringan dengan benar.  Untuk melakukan ini, tambahkan dua baris ini di akhir <b>setupNetworkCommunication ()</b> : <br><br><pre> <code class="swift hljs">inputStream.schedule(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: .current, forMode: .common) outputStream.schedule(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: .current, forMode: .common)</code> </pre> <br>  Akhirnya saatnya berlayar!  Untuk memulai, tambahkan ini di bagian paling akhir metode <b>setupNetworkCommunication ()</b> : <br><br><pre> <code class="swift hljs">inputStream.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>() outputStream.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>()</code> </pre> <br>  Sekarang kami memiliki koneksi terbuka antara aplikasi klien dan server kami. <br><br>  Kami dapat mengkompilasi dan menjalankan aplikasi kami, tetapi Anda tidak akan melihat perubahan apa pun, karena sementara kami tidak melakukan apa-apa dengan koneksi client-server kami. <br><br><h2>  Terhubung ke obrolan </h2><br>  Sekarang setelah kita memiliki koneksi yang mapan dengan server, saatnya untuk mulai melakukan sesuatu tentang itu!  Dalam hal obrolan, Anda harus memperkenalkan diri terlebih dahulu, dan kemudian Anda dapat mengirim pesan ke lawan bicara. <br><br>  Ini membawa kita pada kesimpulan penting: karena kita memiliki dua jenis pesan, kita perlu entah bagaimana membedakannya. <br><br><h2>  Protokol obrolan </h2><br>  Salah satu keuntungan menggunakan lapisan TCP adalah kita dapat mendefinisikan "protokol" kita sendiri untuk komunikasi. <br><br>  Jika kita menggunakan HTTP, maka kita perlu menggunakan kata-kata berbeda ini <b>GET</b> , <b>PUT</b> , <b>PATCH</b> .  Kita perlu membentuk URL dan menggunakan tajuk yang tepat dan semua itu. <br><br>  Kami hanya memiliki dua jenis pesan.  Kami akan kirim <br><br> <code>iam:Luke</code> <br> <br>  untuk memasuki obrolan dan memperkenalkan diri Anda. <br><br>  Dan kami akan kirim <br><br> <code>msg:Hey, how goes it, man?</code> <br> <br>  untuk mengirim pesan obrolan kepada semua responden. <br><br>  Ini sangat sederhana, tetapi benar-benar tidak berprinsip, jadi jangan gunakan metode ini dalam proyek-proyek penting. <br><br>  Sekarang kita tahu apa yang diharapkan server kami dan kami dapat menulis metode di kelas <b>ChatRoom</b> yang akan memungkinkan pengguna untuk terhubung ke obrolan.  Satu-satunya argumen adalah nama panggilan pengguna. <br><br>  Tambahkan metode ini di dalam <b>ChatRoom.swift</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">joinChat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(username: String)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 let data = "iam:\(username)".data(using: .utf8)! //2 self.username = username //3 _ = data.withUnsafeBytes { guard let pointer = $0.baseAddress?.assumingMemoryBound(to: UInt8.self) else { print("Error joining chat") return } //4 outputStream.write(pointer, maxLength: data.count) } }</span></span></code> </pre> <br><ol><li>  Pertama kita membentuk pesan kita menggunakan "protokol" kita sendiri </li><li>  Simpan nama untuk referensi di masa mendatang. </li><li>  <b>withUnsafeBytes (_ :)</b> menyediakan cara mudah untuk bekerja dengan pointer yang tidak aman di dalam penutupan. </li><li>  Akhirnya, kami mengirim pesan kami ke arus keluaran.  Ini mungkin terlihat lebih rumit daripada yang Anda harapkan, namun tulis (_: maxLength :) menggunakan pointer tidak aman yang dibuat pada langkah sebelumnya. </li></ol><br>  Sekarang metode kami siap, buka <b>ChatRoomViewController.swift</b> dan tambahkan panggilan ke metode ini di akhir <b>viewWillAppear (_ :)</b> . <br><br><pre> <code class="swift hljs">chatRoom.joinChat(username: username)</code> </pre> <br>  Sekarang kompilasi dan jalankan aplikasi.  Masukkan nama panggilan Anda dan ketuk kembali untuk melihat ... <br><br><img src="https://habrastorage.org/webt/t5/mq/uw/t5mquwzt4dfvbn25cqglbf8sxgy.gif"><br><br>  ... <b>itu lagi tidak ada yang berubah!</b> <br><br>  Tunggu, tidak apa-apa!  Pergi ke jendela terminal.  Di sana Anda akan melihat pesan bahwa <b>Vasya telah bergabung</b> atau sesuatu seperti itu jika nama Anda bukan Vasya. <br><br>  Ini hebat, tetapi alangkah baiknya memiliki indikasi koneksi yang sukses di layar ponsel Anda. <br><br><h2>  Menanggapi Pesan Masuk </h2><br>  Server mengirimkan klien yang bergabung dengan pesan ke semua orang yang ada dalam obrolan, termasuk Anda.  Untungnya, aplikasi kita sudah memiliki segalanya untuk menampilkan pesan yang masuk dalam bentuk sel dalam tabel pesan di <b>ChatRoomViewController</b> . <br><br>  Yang harus Anda lakukan adalah menggunakan <b>inputStream</b> untuk â€œmenangkapâ€ pesan-pesan ini, mengonversinya menjadi instance dari kelas <b>pesan</b> , dan meneruskannya ke meja untuk ditampilkan. <br><br>  Agar dapat menanggapi pesan yang masuk, Anda perlu <b>ChatRoom</b> untuk <b>mematuhi</b> protokol <b>StreamDelegate</b> . <br><br>  Untuk melakukan ini, tambahkan ekstensi ini di bagian bawah file <b>ChatRoom.swift</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRoom</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamDelegate</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Sekarang nyatakan siapa yang akan menjadi delegasi untuk inputStream. <br><br>  Tambahkan baris ini ke metode setupNetworkCommunication () tepat sebelum panggilan untuk menjadwalkan (di: forMode :): <br><br><pre> <code class="swift hljs">inputStream.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span></code> </pre> <br>  Sekarang tambahkan stream (_: handle :) implementasi metode ke ekstensi: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aStream: Stream, handle eventCode: Stream.Event)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> eventCode { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .hasBytesAvailable: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"new message received"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .endEncountered: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"The end of the stream has been reached."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .errorOccurred: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"error occurred"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .hasSpaceAvailable: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"has space available"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"some other event..."</span></span>) } }</code> </pre> <br><h2>  Kami memproses pesan masuk </h2><br>  Jadi, kami siap untuk mulai memproses pesan masuk.  Acara yang menarik minat kami adalah <b>.hasBytesAvailable</b> , yang menunjukkan bahwa pesan masuk telah tiba. <br><br>  Kami akan menulis metode yang memproses pesan-pesan ini.  Di bawah metode yang baru ditambahkan, kami menulis yang berikut: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readAvailableBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stream: InputStream)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 let buffer = UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: maxReadLength) //2 while stream.hasBytesAvailable { //3 let numberOfBytesRead = inputStream.read(buffer, maxLength: maxReadLength) //4 if numberOfBytesRead &lt; 0, let error = stream.streamError { print(error) break } // Construct the Message object } }</span></span></code> </pre> <br><ol><li>  Kami mengatur buffer di mana kami akan membaca byte yang masuk. </li><li>  Kami berputar dalam satu lingkaran, sementara di aliran input ada sesuatu untuk dibaca. </li><li>  Kami menyebutnya read (_: maxLength :), yang membaca byte dari stream dan menempatkannya di buffer. </li><li>  Jika panggilan mengembalikan nilai negatif, kami mengembalikan kesalahan dan keluar dari loop. </li></ol><br>  Kita perlu memanggil metode ini segera setelah kita memiliki data di aliran masuk, jadi pergi ke <b>pernyataan beralih</b> di dalam <b>aliran (_: menangani :)</b> metode, cari saklar <b>.hasBytesAvailable</b> dan panggil metode ini segera setelah pernyataan cetak: <br><br><pre> <code class="swift hljs">readAvailableBytes(stream: aStream <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">InputStream</span></span>)</code> </pre> <br>  Di tempat ini kami menyiapkan penyangga data yang diterima! <br><br>  Tetapi kita masih perlu mengubah buffer ini menjadi isi dari tabel pesan. <br><br>  Tempatkan metode ini di <b>readAvailableBytes (stream :)</b> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processedMessageString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buffer: UnsafeMutablePointer&lt;UInt8&gt;, length: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Message?</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 guard let stringArray = String( bytesNoCopy: buffer, length: length, encoding: .utf8, freeWhenDone: true)?.components(separatedBy: ":"), let name = stringArray.first, let message = stringArray.last else { return nil } //2 let messageSender: MessageSender = (name == self.username) ? .ourself : .someoneElse //3 return Message(message: message, messageSender: messageSender, username: name) }</span></span></code> </pre> <br>  Pertama, kita menginisialisasi String menggunakan buffer dan ukuran yang kita berikan ke metode ini. <br><br>  Teks akan berada di UTF-8, pada akhirnya kita akan membebaskan buffer, dan membagi pesan dengan simbol ':' untuk memisahkan nama pengirim dan pesan itu sendiri. <br><br>  Sekarang kami sedang menganalisis apakah pesan ini berasal dari peserta lain.  Pada produk, Anda dapat membuat sesuatu seperti token unik, ini sudah cukup untuk demo. <br><br>  Akhirnya, dari semua ekonomi ini, kami membentuk instance dari Pesan dan mengembalikannya. <br><br>  Untuk menggunakan metode ini, tambahkan <b>if-let</b> di akhir <b>loop sementara</b> di metode <b>readAvailableBytes (stream :)</b> , segera setelah komentar terakhir: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = processedMessageString(buffer: buffer, length: numberOfBytesRead) { <span class="hljs-comment"><span class="hljs-comment">// Notify interested parties }</span></span></code> </pre> <br>  Sekarang semuanya siap untuk disampaikan kepada seseorang <b>Pesan</b> ... Tetapi kepada siapa? <br><br><h2>  Buat Protokol ChatRoomDelegate </h2><br>  Jadi, kami perlu memberi tahu <b>ChatRoomViewController.swift</b> tentang pesan baru tersebut, tetapi kami tidak memiliki tautan ke sana.  Karena ini berisi tautan <b>ChatRoom yang</b> kuat, kita bisa jatuh ke dalam perangkap siklus tautan yang kuat. <br><br>  Ini adalah tempat yang sempurna untuk membuat protokol delegasi.  ChatRoom tidak peduli siapa yang perlu tahu tentang posting baru. <br><br>  Di bagian atas <b>ChatRoom.swift,</b> tambahkan definisi protokol baru: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRoomDelegate</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">received</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: Message)</span></span></span></span> }</code> </pre> <br>  Sekarang di dalam kelas <b>ChatRoom,</b> tambahkan tautan yang lemah ke toko yang akan menjadi delegasi: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delegate: <span class="hljs-type"><span class="hljs-type">ChatRoomDelegate?</span></span></code> </pre> <br>  Sekarang mari kita tambahkan metode <b>readAvailableBytes (stream :)</b> , menambahkan baris berikut di dalam konstruksi if-let, di bawah komentar terakhir dalam metode: <br><br><pre> <code class="swift hljs">delegate?.received(message: message)</code> </pre> <br>  Kembali ke <b>ChatRoomViewController.swift</b> dan tambahkan ekstensi kelas berikut, yang memastikan kepatuhan dengan protokol ChatRoomDelegate, segera setelah MessageInputDelegate: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRoomViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRoomDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">received</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: Message)</span></span></span></span> { insertNewMessageCell(message) } }</code> </pre> <br>  Proyek asli sudah berisi yang diperlukan, jadi <b>insertNewMessageCell (_ :)</b> akan menerima pesan Anda dan menampilkan sel yang benar di tampilan tabel. <br><br>  Sekarang tetapkan view controller sebagai delegasi dengan menambahkan ini ke <b>viewWillAppear (_ :)</b> segera setelah memanggil super.viewWillAppear () <br><br><pre> <code class="swift hljs">chatRoom.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span></code> </pre> <br>  Sekarang kompilasi dan jalankan aplikasi.  Masukkan nama dan ketuk kembali. <br><br><img src="https://habrastorage.org/webt/km/21/ed/km21ed-ey4avyntpx53si6oqbra.gif"><br><br>  Anda akan melihat sel tentang koneksi Anda ke obrolan.  Hore, Anda berhasil mengirim pesan ke server dan menerima tanggapan darinya! <br><br><h2>  Posting Pesan </h2><br>  Sekarang ChatRoom dapat mengirim dan menerima pesan, sekarang saatnya untuk memberikan kemampuan kepada pengguna untuk mengirim frasa mereka sendiri. <br><br>  Di <b>ChatRoom.swift,</b> tambahkan metode berikut di akhir definisi kelas: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: String)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-string"><span class="hljs-string">"msg:\(message)"</span></span>.data(using: .utf8)! <span class="hljs-number"><span class="hljs-number">_</span></span> = data.withUnsafeBytes { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pointer = $<span class="hljs-number"><span class="hljs-number">0</span></span>.baseAddress?.assumingMemoryBound(to: <span class="hljs-type"><span class="hljs-type">UInt8</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Error joining chat"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } outputStream.write(pointer, maxLength: data.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>) } }</code> </pre> <br>  Metode ini mirip dengan <b>joinChat (nama pengguna :)</b> , yang kami tulis sebelumnya, kecuali bahwa ia memiliki awalan <b>msg</b> di depan teks (untuk menunjukkan bahwa ini adalah pesan obrolan nyata). <br><br>  Karena kami ingin mengirim pesan dengan tombol <b>Kirim</b> , kami kembali ke <b>ChatRoomViewController.swift</b> dan temukan <b>MessageInputDelegate di</b> sana. <br><br>  Di sini kita melihat metode <b>sendWasTapped (message :)</b> kosong.  Untuk mengirim pesan, kirim ke chatRoom: <br><br><pre> <code class="swift hljs">chatRoom.send(message: message)</code> </pre> <br>  Sebenarnya, itu saja!  Karena server akan menerima pesan dan meneruskannya ke semua orang, ChatRoom akan diberitahu tentang pesan baru dengan cara yang sama seperti ketika bergabung dengan obrolan. <br><br>  Kompilasi dan jalankan aplikasi. <br><br><img src="https://habrastorage.org/webt/i6/e6/r1/i6e6r1tzjl-2r1ekzdk5gvplbsq.gif"><br><br>  Jika Anda tidak memiliki orang untuk diajak ngobrol sekarang, luncurkan jendela terminal baru dan masukkan: <br><br> <code>nc localhost 80</code> <br> <br>  Ini akan menghubungkan Anda ke server.  Sekarang Anda dapat terhubung ke obrolan menggunakan "protokol" yang sama: <br><br> <code>iam:gregg</code> <br> <br>  Maka - kirim pesan: <br><br> <code>msg:Ay mang, wut's good?</code> <br> <br><img src="https://habrastorage.org/webt/qm/5e/_l/qm5e_l4wi4a0_whqffyzbmeyqzs.gif"><br><br>  Selamat, Anda menulis klien untuk mengobrol! <br><br><h2>  Kami membersihkan diri </h2><br>  Jika Anda pernah mengembangkan aplikasi yang secara aktif membaca / menulis file, maka Anda harus tahu bahwa pengembang yang baik menutup file ketika mereka selesai bekerja dengannya.  Faktanya adalah bahwa koneksi melalui soket disediakan oleh deskriptor file.  Ini berarti bahwa setelah menyelesaikan pekerjaan Anda harus menutupnya, seperti file lainnya. <br><br>  Untuk melakukan ini, tambahkan metode berikut ke <b>ChatRoom.swift</b> setelah mendefinisikan <b>kirim (pesan :)</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopChatSession</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { inputStream.close() outputStream.close() }</code> </pre><br>  Seperti yang mungkin Anda tebak, metode ini menutup utas sehingga Anda tidak dapat lagi menerima dan mengirim pesan.  Selain itu, utas dihapus dari <b>run loop</b> yang sebelumnya kami tempatkan. <br><br>  Tambahkan panggilan ke metode ini di bagian <b>.endEncountered</b> dari <b>pernyataan sakelar</b> di dalam <b>aliran (_: handle :)</b> : <br><br><pre> <code class="swift hljs">stopChatSession()</code> </pre> <br>  Kemudian kembali ke <b>ChatRoomViewController.swift</b> dan lakukan hal yang sama di <b>viewWillDisappear (_ :)</b> : <br><br><pre> <code class="swift hljs">chatRoom.stopChatSession()</code> </pre> <br>  Itu saja!  Sekarang sudah pasti! <br><br><h2>  Kesimpulan </h2><br>  Sekarang setelah Anda menguasai dasar-dasar jaringan dengan soket, Anda dapat memperdalam pengetahuan Anda. <br><br><h4>  Soket UDP </h4><br>  Aplikasi ini adalah contoh dari komunikasi jaringan menggunakan TCP, yang menjamin pengiriman paket ke tujuan. <br><br>  Namun, Anda dapat menggunakan soket UDP.  Jenis koneksi ini tidak menjamin pengiriman paket ke tujuan yang dimaksudkan, tetapi jauh lebih cepat. <br><br>  Ini sangat berguna dalam gim.  Pernah mengalami kelambatan?  Ini berarti Anda memiliki koneksi yang buruk dan banyak paket UDP hilang. <br><br><h4>  Soket web </h4><br>  Alternatif lain untuk HTTP dalam aplikasi adalah teknologi yang disebut soket web. <br><br>  Tidak seperti soket TCP biasa, soket web menggunakan HTTP untuk membangun komunikasi.  Dengan bantuan mereka, Anda dapat mencapai hal yang sama dengan soket biasa, tetapi dengan kenyamanan dan keamanan, seperti di browser. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467909/">https://habr.com/ru/post/id467909/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467897/index.html">Alat uji otomatis, integrasi Yandex Mapkit 3, desain keren, dan pendekatan UI Berbasis Server - Pengumuman mitap Android</a></li>
<li><a href="../id467901/index.html">Sanggah empat stereotip tentang bahasa pemrograman Rust</a></li>
<li><a href="../id467903/index.html">20 fitur navigasi teratas di IntelliJ IDEA. Bagian 1</a></li>
<li><a href="../id467905/index.html">Bagaimana kami membuat pengakuan tengara di Cloud Mail.ru, dan mengapa</a></li>
<li><a href="../id467907/index.html">Pro dan kontra dari outsourcing</a></li>
<li><a href="../id467913/index.html">Cara meningkatkan "mineral bajingan", atau antarmuka baru untuk panel surya</a></li>
<li><a href="../id467915/index.html">Memantau postgres di dalam OpenShift</a></li>
<li><a href="../id467917/index.html">Template Manajemen</a></li>
<li><a href="../id467919/index.html">Masalah pemrosesan batch permintaan dan solusinya (bagian 2)</a></li>
<li><a href="../id467921/index.html">Keluarkan pulpen berdebu: tulisan tangan baik untuk otak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>