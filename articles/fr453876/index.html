<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🏭 🤚🏽 ♑️ Comme dans Yandex.Practicum, le front desync a gagné: un numéro acrobatique avec Redux-Saga, postMessage et Jupyter 🤙🏼 🍼 👨🏿‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je m'appelle Artyom Nesmiyanov, je suis développeur full-stack chez Yandex. Pratique, je m'occupe principalement du frontend. Nous pensons qu'il est p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comme dans Yandex.Practicum, le front desync a gagné: un numéro acrobatique avec Redux-Saga, postMessage et Jupyter</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/453876/">  Je m'appelle Artyom Nesmiyanov, je suis développeur full-stack chez Yandex. Pratique, je m'occupe principalement du frontend.  Nous pensons qu'il est possible et nécessaire d'étudier avec plaisir la programmation, l'analyse de données et d'autres métiers numériques.  Et commencez à apprendre et continuez.  Tout développeur qui n'a pas renoncé à lui-même «continue» toujours.  Nous aussi.  Par conséquent, nous percevons les tâches professionnelles comme un format d'apprentissage.  Et l'un des récents m'a aidé, moi et les gars, à mieux comprendre dans quelle direction développer notre pile frontale. <br><br><img src="https://habrastorage.org/webt/u2/uh/nx/u2uhnxzsc0hv3v7clkqskbzwnc0.png"><br><br><h3>  De qui et de quoi l'atelier est fait </h3><br>  Notre équipe de développement est extrêmement compacte.  Il n'y a que deux personnes sur le backend, sur le front-end - quatre, compte tenu de moi, une pile complète.  De temps en temps, des gars de Yandex.Tutorial nous rejoignent en renfort.  Nous travaillons sur Scrum avec des sprints de deux semaines. <br><a name="habracut"></a><br>  Notre frontend est basé sur React.js en collaboration avec Redux / Redux-Saga, nous utilisons Express pour communiquer avec le backend.  La partie backend de la pile est en Python (plus précisément, Django), la base de données est PostgreSQL, et pour certaines tâches, Redis.  En utilisant Redux, nous stockons des stockages d'informations, envoyons des actions qui sont traitées par Redux et Redux-Saga.  Tous les effets secondaires, tels que les demandes de serveur, les appels à Yandex.Metrica et les redirections, sont traités uniquement dans Redux-Saga.  Et toutes les modifications de données se produisent dans les réducteurs Redux. <br><br><h3>  Comment ne pas oublier un journal dans votre iframe </h3><br>  Désormais sur notre plateforme, la formation est ouverte dans trois métiers: développeur front-end, développeur web, analyste de données.  Et nous scions activement des outils pour chaque cours. <br><br>  Pour le cours de six mois « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Data Analyst</a> », nous avons créé un simulateur interactif, où nous enseignons aux utilisateurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment utiliser le bloc-notes Jupyter</a> .  Il s'agit d'une coquille cool pour l'informatique interactive, qui est appréciée à juste titre par les scientifiques des données.  Toutes les opérations dans l'environnement sont effectuées à l'intérieur du bloc-notes, mais d'une manière simple - un bloc-notes (comme je l'appellerai plus tard). <br><br>  L'expérience vous invite, et nous en sommes sûrs: il est important que les tâches de formation soient proches de la réalité.  Y compris en termes d'environnement de travail.  Par conséquent, il était nécessaire de s'assurer qu'à l'intérieur de la leçon, tout le code pouvait être écrit, exécuté et vérifié directement dans le cahier. <br><br>  Avec la mise en œuvre de base des difficultés ne se posent pas.  Le bloc-notes lui-même a été installé dans un iframe séparé, la logique de vérification a été prescrite sur le backend. <br><br><img src="https://habrastorage.org/webt/2z/_9/iy/2z_9iyuj7pmha0ielvj4evuyhic.png"><br>  <i>Le cahier de l'élève lui-même (à droite) n'est qu'un iframe dont l'URL mène à un cahier spécifique dans JupyterHub.</i> <br><br>  En première approximation, tout fonctionnait sans accroc, sans accroc.  Cependant, lors des tests, des absurdités sont apparues.  Par exemple, vous êtes assuré de conduire la bonne version du code dans un ordinateur portable, cependant, après avoir cliqué sur le bouton "Tâche de test", le serveur répond que la réponse est supposée incorrecte.  Et pourquoi - un mystère. <br><br>  Eh bien, ce qui se passe, nous nous sommes rendu compte le même jour quand nous avons trouvé un bug: il s'est avéré que la solution qui ne volait pas était la solution actuelle, la solution vient d'être introduite dans le formulaire Jupyter Notebook, mais la précédente avait déjà été effacée.  L'ordinateur portable lui-même n'a pas eu le temps de survivre, et nous avons ralenti le backend pour qu'il vérifie la tâche qu'il contient.  Ce qu'il ne pouvait bien sûr pas faire. <br><br>  Nous avons dû nous débarrasser du rassinhron entre l'enregistrement du portable et l'envoi d'une demande au serveur pour le vérifier.  Le hic, c'était qu'il fallait faire communiquer l'iframe du cahier avec la fenêtre parent, c'est-à-dire avec le frontend sur lequel la leçon dans son ensemble tournait.  Bien sûr, il était impossible de transmettre directement un événement entre eux: ils vivent sur des domaines différents. <br><br>  À la recherche d'une solution, j'ai découvert que Jupyter Notebook permet de connecter ses plugins.  Il existe un objet Jupiter - un cahier - avec lequel vous pouvez opérer.  Travailler avec elle implique des événements, y compris la préservation du cahier, ainsi que l'appel à l'action appropriée.  Après avoir compris l'intérieur de Jupyter (je devais: il n'y a pas de documentation normale), les gars et moi l'avons fait - nous avons construit notre propre plug-in pour cela et, en utilisant le mécanisme postMessage, nous avons réalisé le travail coordonné des éléments à partir desquels la leçon de l'atelier a été assemblée. <br><br>  Nous avons élaboré une solution de contournement en tenant compte du fait que notre pile inclut initialement le Redux-Saga déjà mentionné - pour le dire simplement, un middleware sur Redux, ce qui permet de travailler de manière plus flexible avec des effets secondaires.  Par exemple, l'enregistrement d'un ordinateur portable est quelque chose comme cet effet secondaire.  Nous envoyons quelque chose au backend, attendons quelque chose, obtenons quelque chose.  Tout ce mouvement est traité dans Redux-Saga: il envoie les événements au frontend, lui dictant comment afficher quoi dans l'interface utilisateur. <br><br>  Quel est le résultat?  PostMessage est créé et envoyé à l'iframe avec un bloc-notes.  Lorsqu'un iframe voit que quelque chose est venu de l'extérieur, il analyse la chaîne reçue.  Conscient qu'il doit garder le cahier, il effectue cette action et, à son tour, envoie une réponse postMessage sur l'exécution de la demande. <br><br>  Lorsque nous cliquons sur le bouton "Vérifier la tâche", l'événement correspondant est envoyé au magasin Redux: "Telle et telle, nous sommes allés être vérifiés."  Redux-Saga voit l'action arriver et faire un postMessage dans un iframe.  Maintenant, elle attend la réponse de l'iframe.  En attendant, notre élève voit l'indicateur de téléchargement sur le bouton "Vérifier la tâche" et comprend que le simulateur ne se bloque pas, mais "réfléchit".  Et seulement lorsque postMessage revient en disant que la sauvegarde est terminée, Redux-Saga continue de fonctionner et envoie une demande au backend.  Sur le serveur, la tâche est vérifiée - la bonne solution ou non, si des erreurs sont commises, lesquelles, etc., et ces informations sont soigneusement stockées dans le magasin Redux.  Et à partir de là, le script frontal le tire dans l'interface de la leçon. <br><br>  Voici le schéma qui est finalement sorti: <br><br><img src="https://habrastorage.org/webt/ks/gc/eu/ksgceup6hokoh9jtvqoajegbjfc.png"><br><br>  <i>(1) Nous appuyons sur le bouton "Vérifier la tâche" (Vérifier) ​​→ (2) Nous envoyons l'action CHECK_NOTEBOOK_REQUEST → (3) Nous envoyons l'action du contrôle → (2) Nous envoyons l'action SAVE_NOTEBOOK_REQUEST → (3) Nous capturons l'action et envoyons un message dans l'iframe → enregistrer l'événement (4) Recevoir le message → (5) Le bloc-notes est enregistré → (4) Recevoir l'événement de l'API Jupyter que le bloc-notes a été enregistré et envoyer postMessage enregistré sur le bloc-notes → (1) Recevoir l'événement → (2) Envoyer l'action SAVE_NOTEBOOK_SUCCESS → (3) Nous interceptons l'action et envoyer une demande pour vérifier le cahier → (6) → (7) Vérifier que ce cahier est dans la base de données → (8) → (7) Rechercher le code du cahier → (5) Renvoyer le code → (7) Lancer la vérification du code → (9 ) → (7) Nous obtenons une coupe</i>  <i>tat contrôle → (6) → (3) nous envoyons</i> une <i>action CHECK_NOTEBOOK_SUCCESS → (2) vers</i> le <i>bas pour vérifier</i> la <i>réponse face → (1) tirage</i> au <i>résultat</i> <br><br>  Voyons comment tout cela fonctionne dans le contexte du code. <br><br>  Nous avons à l'avant trainer_type_jupyter.jsx - le script de la page où notre cahier est dessiné. <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"trainer__right-column"</span></span></span><span class="hljs-tag">&gt;</span></span> {notebookLinkIsLoading ? ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">iframe</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"trainer__jupiter-frame"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{this.onIframeRef}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{notebookLink}</span></span></span><span class="hljs-tag"> /&gt;</span></span> ) : ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Spin</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">size</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"l"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mix</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"trainer__jupiter-spin"</span></span></span><span class="hljs-tag"> /&gt;</span></span> )} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Après avoir cliqué sur le bouton "Vérifier le travail", la méthode handleCheckTasks est appelée. <br><br><pre> <code class="xml hljs">handleCheckTasks = () =&gt; { const {checkNotebook, lesson} = this.props; checkNotebook({id: lesson.id, iframe: this.iframeRef}); };</code> </pre> <br>  En fait, handleCheckTasks sert à appeler l'action Redux avec les paramètres passés. <br><br><pre> <code class="xml hljs">export const checkNotebook = getAsyncActionsFactory(CHECK_NOTEBOOK).request;</code> </pre> <br>  Il s'agit d'une action courante conçue pour Redux-Saga et les méthodes asynchrones.  Ici, getAsyncActionsFactory génère trois actions: <br><br>  // utils / store-helpers / async.js <br><br><pre> <code class="xml hljs">export function getAsyncActionsFactory(type) { const ASYNC_CONSTANTS = getAsyncConstants(type); return { request: payload =&gt; ({type: ASYNC_CONSTANTS.REQUEST, payload}), error: (response, request) =&gt; ({type: ASYNC_CONSTANTS.ERROR, response, request}), success: (response, request) =&gt; ({type: ASYNC_CONSTANTS.SUCCESS, response, request}), } }</code> </pre> <br>  En conséquence, getAsyncConstants génère trois constantes de la forme * _REQUEST, * _SUCCESS et * _ERROR. <br><br>  Voyons maintenant comment notre Redux-Saga va gérer toute cette économie: <br><br>  // trainer.saga.js <br><br><pre> <code class="xml hljs">function* watchCheckNotebook() { const watcher = createAsyncActionSagaWatcher({ type: CHECK_NOTEBOOK, apiMethod: Api.checkNotebook, preprocessRequestGenerator: function* ({id, iframe}) { yield put(trainerActions.saveNotebook({iframe})); yield take(getAsyncConstants(SAVE_NOTEBOOK).SUCCESS); return {id}; }, successHandlerGenerator: function* ({response}) { const {completed_tests: completedTests} = response; for (let id of completedTests) { yield put(trainerActions.setTaskSolved(id)); } }, errorHandlerGenerator: function* ({response: error}) { yield put(appActions.setNetworkError(error)); } }); yield watcher(); }</code> </pre> <br>  La magie?  Rien d'extraordinaire.  Comme vous pouvez le voir, createAsyncActionSagaWatcher crée simplement un filigrane qui peut prétraiter les données entrant dans l'action, faire une demande à une URL spécifique, envoyer l'action * _REQUEST et envoyer * _SUCCESS et * _ERROR après une réponse réussie du serveur.  De plus, bien entendu, pour chaque option, des gestionnaires sont fournis à l'intérieur de la montre. <br><br>  Vous avez probablement remarqué que dans le préprocesseur de données, nous appelons un autre Redux-Saga, attendons qu'il se termine avec SUCCESS, puis continuez à travailler.  Et bien sûr, les iframes n'ont pas besoin d'être envoyés au serveur, nous ne donnons donc que l'identifiant. <br><br>  Examinez de plus près la fonction saveNotebook: <br><br><pre> <code class="xml hljs">function* saveNotebook({payload: {iframe}}) { iframe.contentWindow.postMessage(JSON.stringify({ type: 'save-notebook' }), '*'); yield; }</code> </pre> <br>  Nous avons atteint le mécanisme le plus important dans l'interaction des iframes avec le frontend - postMessage.  Le fragment de code donné envoie une action avec le type save-notebook, qui est traitée à l'intérieur de l'iframe. <br><br>  J'ai déjà mentionné que nous devions écrire un plug-in pour le bloc-notes Jupyter, qui serait chargé à l'intérieur du bloc-notes.  Ces plugins ressemblent à ceci: <br><br><pre> <code class="xml hljs">define([ 'base/js/namespace', 'base/js/events' ], function( Jupyter, events ) {...});</code> </pre><br>  Pour créer de telles extensions, vous devez traiter avec l'API Jupyter Notebook elle-même.  Malheureusement, il n'y a pas de documentation claire à ce sujet.  Mais les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">codes sources</a> sont disponibles et je les ai explorés.  C'est bien que le code soit lisible là-bas. <br><br>  Le plugin doit apprendre à communiquer avec la fenêtre parent dans le front de la leçon: après tout, la désynchronisation entre eux est la cause du bug avec la vérification des tâches.  Tout d'abord, nous souscrivons à tous les messages que nous recevons: <br><br><pre> <code class="xml hljs">window.addEventListener('message', actionListener);</code> </pre> <br>  Nous allons maintenant fournir leur traitement: <br><br><pre> <code class="xml hljs">function actionListener({data: eventString}) { let event = ''; try { event = JSON.parse(eventString); } catch(e) { return; } switch (event.type) { case 'save-notebook': Jupyter.actions.call('jupyter-notebook:save-notebook'); Break; ... default: break; } }</code> </pre> <br>  Tous les événements qui ne correspondent pas à notre format sont hardiment ignorés. <br><br>  Nous voyons que l'événement save-notebook nous arrive, et nous appelons l'action pour enregistrer le notebook.  Il ne reste plus qu'à renvoyer un message que le carnet a été conservé: <br><br><pre> <code class="xml hljs">events.on('notebook_saved.Notebook', actionDispatcher); function actionDispatcher(event) { switch (event.type) { case 'select': const selectedCell = Jupyter.notebook.get_selected_cell(); dispatchEvent({ type: event.type, data: {taskId: getCellTaskId(selectedCell)} }); return; case 'notebook_saved': default: dispatchEvent({type: event.type}); } } function dispatchEvent(event) { return window.parent.postMessage( typeof event === 'string' ? event : JSON.stringify(event), '*' ); }</code> </pre><br>  En d'autres termes, envoyez simplement {type: 'notebook_saved'}.  Cela signifie que le carnet a été conservé. <br><br>  Revenons à notre composante: <br><br>  //trainer_type_jupyter.jsx <br><br><pre> <code class="xml hljs">componentDidMount() { const {getNotebookLink, lesson} = this.props; getNotebookLink({id: lesson.id}); window.addEventListener('message', this.handleWindowMessage); }</code> </pre> <br>  Lors du montage du composant, nous demandons au serveur un lien vers le notebook et souscrivons à toutes les actions qui peuvent nous parvenir: <br><br><pre> <code class="xml hljs">handleWindowMessage = ({data: eventString}) =&gt; { const {activeTaskId, history, match: {params}, setNotebookSaved, tasks} = this.props; let event = null; try { event = JSON.parse(eventString); } catch(e) { return; } const {type, data} = event; switch (type) { case 'app_initialized': this.selectTaskCell({taskId: activeTaskId}) return; case 'notebook_saved': setNotebookSaved(); return; case 'select': { const taskId = data &amp;&amp; data.taskId; if (!taskId) { return } const task = tasks.find(({id}) =&gt; taskId === id); if (task &amp;&amp; task.status === TASK_STATUSES.DISABLED) { this.selectTaskCell({taskId: null}) return; } history.push(reversePath(urls.trainerTask, {...params, taskId})); return; } default: break; } };</code> </pre> <br>  C'est là que la répartition de l'action setNotebookSaved est appelée, ce qui permettra à Redux-Saga de continuer à travailler et à sauvegarder le bloc-notes. <br><br><h3>  Glitches de choix </h3><br>  Nous avons résolu le bogue de conservation des cahiers.  Et immédiatement passé à un nouveau problème.  Il fallait apprendre à bloquer des tâches (tâches), auxquelles l'élève n'avait pas encore atteint.  En d'autres termes, il était nécessaire de synchroniser la navigation entre notre simulateur interactif et le cahier Jupyter: dans une leçon, nous avions un cahier avec plusieurs tâches assis dans l'iframe, dont les transitions devaient être coordonnées avec les changements dans l'interface de la leçon dans son ensemble.  Par exemple, de sorte qu'en cliquant sur la deuxième tâche dans l'interface de la leçon dans le bloc-notes, le passage à la cellule correspondant à la deuxième tâche a lieu.  Et vice versa: si dans le cadre Jupyter Notebook vous sélectionnez une cellule liée à la troisième tâche, alors l'URL dans la barre d'adresse du navigateur doit immédiatement changer et, en conséquence, le texte d'accompagnement avec la théorie de la troisième tâche doit être affiché dans l'interface de la leçon. <br><br>  Il y avait une tâche plus difficile.  Le fait est que notre programme de formation est conçu pour le passage cohérent des leçons et des travaux.  Pendant ce temps, par défaut, dans le bloc-notes Jupiter, rien n'empêche l'utilisateur d'ouvrir une cellule.  Et dans notre cas, chaque cellule est une tâche distincte.  Il s'est avéré que vous pouvez résoudre les première et troisième tâches et ignorer la seconde.  Le risque de passage non linéaire de la leçon devait être éliminé. <br><br>  La solution était basée sur le même postMessage.  Seulement, nous avons dû approfondir l'API Jupyter Notebook, plus précisément, ce que l'objet Jupiter lui-même peut faire.  Et trouvez un mécanisme pour vérifier à quelle tâche la cellule est attachée.  Dans sa forme la plus générale, elle est la suivante.  Dans la structure du cahier, les cellules vont séquentiellement les unes après les autres.  Ils peuvent avoir des métadonnées.  Le champ "Balises" est fourni dans les métadonnées, et les balises ne sont que des identificateurs de tâches à l'intérieur de la leçon.  De plus, en utilisant des cellules de marquage, vous pouvez déterminer si elles doivent être bloquées par l'étudiant jusqu'à présent.  En conséquence, conformément au modèle actuel du simulateur, en cliquant sur la cellule, nous commençons à envoyer postMessage de l'iframe à notre frontend, qui, à son tour, va au magasin Redux et vérifie, en fonction des propriétés de la tâche, s'il est disponible pour nous maintenant.  S'il n'est pas disponible, nous basculons vers la cellule active précédente. <br><br>  Nous avons donc réalisé qu'il était impossible de sélectionner une cellule dans un cahier qui ne devrait pas être accessible par la chronologie de la formation.  Certes, cela a donné lieu à un bug non critique, mais: vous essayez de cliquer sur une cellule avec une tâche inaccessible, et elle "clignote" rapidement: il est clair qu'elle a été activée pendant un moment, mais a été immédiatement bloquée.  Bien que nous n'ayons pas éliminé cette rugosité, cela n'interfère pas avec la prise de leçons, mais en arrière-plan, nous continuons à penser comment y faire face (en passant, y a-t-il des pensées?). <br><br>  Un peu sur la façon dont nous avons modifié notre interface pour résoudre le problème.  Passons à nouveau à trainer_type_jupyter.jsx - nous allons nous concentrer sur app_initialized et sélectionner. <br><br>  Avec app_initialized, tout est élémentaire: le bloc-notes est chargé et nous voulons faire quelque chose.  Par exemple, sélectionnez la cellule actuelle en fonction de la tâche sélectionnée.  Le plugin est décrit afin que vous puissiez passer taskId et basculer vers la première cellule correspondant à ce taskId. <br><br>  À savoir: <br><br>  // trainer_type_jupyter.jsx <br><br><pre> <code class="xml hljs">selectTaskCell = ({taskId}) =&gt; { const {selectCell} = this.props; if (!this.iframeRef) { return; } selectCell({iframe: this.iframeRef, taskId}); };</code> </pre> <br>  // trainer.actions.js <br><br><pre> <code class="xml hljs">export const selectCell = ({iframe, taskId}) =&gt; ({ type: SELECT_CELL, iframe, taskId });</code> </pre> <br>  // trainer.saga.js <br><br><pre> <code class="xml hljs">function* selectCell({iframe, taskId}) { iframe.contentWindow.postMessage(JSON.stringify({ type: 'select-cell', data: {taskId} }), '*'); yield; } function* watchSelectCell() { yield takeEvery(SELECT_CELL, selectCell); }</code> </pre> <br>  // custom.js (plugin Jupyter) <br><br><pre> <code class="xml hljs">function getCellTaskId(cell) { const notebook = Jupyter.notebook; while (cell) { const tags = cell.metadata.tags; const taskId = tags &amp;&amp; tags[0]; if (taskId) { return taskId; } cell = notebook.get_prev_cell(cell); } return null; } function selectCell({taskId}) { const notebook = Jupyter.notebook; const selectedCell = notebook.get_selected_cell(); if (!taskId) { selectedCell.unselect(); return; } if (selectedCell &amp;&amp; selectedCell.selected &amp;&amp; getCellTaskId(selectedCell) === taskId) { return; } const index = notebook.get_cells() .findIndex(cell =&gt; getCellTaskId(cell) === taskId); if (index <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag">) { </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span><span class="hljs-tag">; } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">notebook.select</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">index</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cell</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">notebook.get_cell(index);</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cell.element</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag">]</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.scrollIntoView</span></span></span><span class="hljs-tag">({ </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">behavior:</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">smooth</span></span></span><span class="hljs-tag">', </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">block:</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">start</span></span></span><span class="hljs-tag">' }); } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">function</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">actionListener</span></span></span><span class="hljs-tag">({</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">eventString</span></span></span><span class="hljs-tag">}) { </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">case</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">select-cell</span></span></span><span class="hljs-tag">'</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">selectCell</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">event.data</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">break</span></span></span><span class="hljs-tag">;</span></span></code> </pre> <br>  Vous pouvez maintenant changer de cellule et apprendre de l'iframe que la cellule a été changée. <br><br>  Lors du changement de cellule, nous changeons l'URL et tombons dans une autre tâche.  Il ne reste plus qu'à faire le contraire - lors du choix d'une autre tâche dans l'interface, changez de cellule.  Facile: <br><br><pre> <code class="xml hljs">componentDidUpdate({match: {params: {prevTaskId}}) { const {match: {params: {taskId}}} = this.props; if (taskId !== prevTaskId) { this.selectTaskCell({taskId});</code> </pre> <br><h3>  Chaudière séparée pour perfectionnistes </h3><br>  Ce serait cool de se vanter de notre bien-être.  La solution en fin de compte est efficace, même si elle semble un peu désordonnée: pour résumer, nous avons une méthode qui traite tout message provenant de l'extérieur (dans notre cas, à partir d'un iframe).  Mais dans le système que nous avons nous-mêmes construit, il y a des choses que moi et mes collègues n'aimons pas vraiment. <br><br>  • Il n'y a pas de flexibilité dans l'interaction des éléments: chaque fois que nous voulons ajouter de nouvelles fonctionnalités, nous devrons changer le plugin afin qu'il supporte à la fois l'ancien et le nouveau format de communication.  Il n'y a pas de mécanisme isolé unique pour travailler entre l'iframe et notre composant frontal, ce qui rend le bloc-notes Jupyter dans l'interface de la leçon et fonctionne avec nos tâches.  Globalement - il existe un souhait de rendre un système plus flexible, de sorte qu'à l'avenir, il soit facile d'ajouter de nouvelles actions, de nouveaux événements et de les traiter.  Et dans le cas non seulement du portable Jupiter, mais aussi de tout iframe dans les simulateurs.  Nous cherchons donc à passer le code du plugin via postMessage et à le rendre (eval) à l'intérieur du plugin. <br><br>  • Les fragments de code qui résolvent les problèmes sont dispersés tout au long du projet.  La communication avec les iframes s'effectue à la fois depuis Redux-Saga et depuis le composant, ce qui n'est certainement pas optimal. <br><br>  • Iframe lui-même avec le rendu Jupyter Notebook est assis sur un autre service.  Le modifier est légèrement problématique, notamment dans le respect du principe de compatibilité descendante.  Par exemple, si nous voulons changer une logique sur le frontend et dans le notebook lui-même, nous devons faire un double travail. <br><br>  • Beaucoup aimeraient mettre en œuvre plus facilement.  Prenez au moins React.  Il a une tonne de méthodes de cycle de vie, et chacune d'elles doit être traitée.  De plus, je suis confus par la liaison à React lui-même.  Idéalement, j'aimerais pouvoir travailler avec nos iframes, quel que soit votre framework frontal.  En général, l'intersection des technologies que nous avons choisies impose des limites: la même Redux-Saga attend de nous des actions Redux, pas postMessage. <br><br>  Nous ne nous arrêterons donc certainement pas sur ce qui a été accompli.  Un dilemme des manuels: vous pouvez aller du côté de la beauté, mais sacrifier l'optimalité de la performance, ou vice versa.  Nous n'avons pas encore trouvé la meilleure solution. <br><br>  Peut-être que des idées vous viennent? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453876/">https://habr.com/ru/post/fr453876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453866/index.html">Demande d'API avec React Hooks, HOC ou Render Prop</a></li>
<li><a href="../fr453868/index.html">Mini interrupteur tactile avec panneau en verre sur nRF52832</a></li>
<li><a href="../fr453870/index.html">Nous écrivons le proxy Reverse socks5 sur PowerShell. Partie 1</a></li>
<li><a href="../fr453872/index.html">Restauration de photos à l'aide de réseaux de neurones</a></li>
<li><a href="../fr453874/index.html">De la roulette russe au LOTO sécurisé: comment protéger le personnel du centre de données</a></li>
<li><a href="../fr453882/index.html">Un excellent guide sur le métier d'architecte de solutions (+ liste de liens utiles)</a></li>
<li><a href="../fr453884/index.html">Remplacement de la caméra HYIP ou du reflex numérique?</a></li>
<li><a href="../fr453886/index.html">Le programme fonctionne</a></li>
<li><a href="../fr453890/index.html">Rêves soviétiques de l'avenir</a></li>
<li><a href="../fr453892/index.html">Certification ISTQB. Partie 2: Comment se préparer à la certification ISTQB? Histoires de pratique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>