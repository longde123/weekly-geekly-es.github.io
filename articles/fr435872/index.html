<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ü ü§≥üèø üßëüèø‚Äçü§ù‚Äçüßëüèª Langage de programmation Zig üß• üë©‚Äçüë©‚Äçüëß üì†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le premier commentaire sur le merveilleux article Subjective Vision of an Ideal Programming Language s'est av√©r√© √™tre une r√©f√©rence au langage de prog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Langage de programmation Zig</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435872/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/fm/db/pqfmdbfclpie1tmlpudotsmvlbw.jpeg"></div><br>  Le premier commentaire sur le merveilleux article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Subjective Vision of an Ideal Programming Language</a> s'est av√©r√© √™tre une r√©f√©rence au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">langage de programmation Zig</a> .  Naturellement, il est devenu int√©ressant de savoir quel type de langage il s'agit, qui pr√©tend √™tre une niche de C ++, D et Rust.  J'ai regard√© - la langue semblait jolie et quelque peu int√©ressante.  Belle syntaxe si-like, approche originale de la gestion des erreurs, coroutines int√©gr√©es.  Cet article est un bref aper√ßu de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle</a> entrecoup√©e de leurs propres r√©flexions et impressions d'exemples de code en cours d'ex√©cution. <br><a name="habracut"></a><br><h2>  Pour commencer </h2><br>  L'installation du compilateur est assez simple, pour Windows, d√©compressez simplement le package de distribution dans un dossier.  Nous cr√©ons un fichier texte hello.zig dans le m√™me dossier, y ins√©rons le code de la documentation et l'enregistrons.  L'assemblage se fait par la commande <br><br><pre><code class="plaintext hljs">zig build-exe hello.zig</code> </pre> <br>  apr√®s quoi hello.exe appara√Æt dans le m√™me r√©pertoire. <br><br>  En plus de l'assemblage, le mode de test unitaire est disponible; pour cela, des blocs de test sont utilis√©s dans le code, et l'assemblage et le lancement des tests sont effectu√©s par <br><br><pre> <code class="plaintext hljs">zig test hello.zig</code> </pre> <br><h3>  Premi√®res bizarreries </h3><br>  Le compilateur ne prend pas en charge les sauts de ligne Windows (\ r \ n).  Bien s√ªr, le fait m√™me que les sauts de ligne dans chaque syst√®me (Win, Nix, Mac) soient les leurs est une folie et une relique du pass√©.  Mais il n'y a rien √† faire, il suffit donc de s√©lectionner, par exemple, dans Notepad ++ le format que vous souhaitez pour le compilateur. <br><br>  La deuxi√®me bizarrerie que j'ai rencontr√©e par accident - les onglets ne sont pas pris en charge dans le code!  Seuls les espaces.  Mais √ßa arrive :) <br><br>  Cependant, cela est honn√™tement √©crit dans la documentation - la v√©rit√© est d√©j√† √† la toute fin. <br><br><h3>  Commentaires </h3><br>  Une autre bizarrerie est que Zig ne prend pas en charge les commentaires sur plusieurs lignes.  Je me souviens que tout √©tait fait correctement dans l'ancien turbo pascal - les commentaires multi-lignes imbriqu√©s √©taient pris en charge.  Apparemment, depuis lors, aucun d√©veloppeur de langage n'a ma√Ætris√© une chose aussi simple :) <br><br>  Mais il y a des commentaires documentaires.  Commencez par ///.  Doit √™tre √† certains endroits - devant les objets correspondants (variables, fonctions, classes ...).  S'ils sont ailleurs - une erreur de compilation.  Pas mal. <br><br><h3>  D√©claration de variable </h3><br>  Fait dans le style √† la mode maintenant (et id√©ologiquement correct), lorsque le mot cl√© (const ou var) est √©crit en premier, puis le nom, puis √©ventuellement le type, puis la valeur initiale.  C'est-√†-dire  l'inf√©rence de type automatique est disponible.  Les variables doivent √™tre initialis√©es - si vous ne sp√©cifiez pas de valeur initiale, il y aura une erreur de compilation.  Cependant, une valeur sp√©ciale non d√©finie est fournie, qui peut √™tre utilis√©e explicitement pour sp√©cifier des variables non initialis√©es. <br><br><pre> <code class="plaintext hljs">var i:i32 = undefined;</code> </pre> <br><h3>  Sortie console </h3><br>  Pour les exp√©riences, nous avons besoin d'une sortie vers la console - dans tous les exemples, c'est la m√©thode utilis√©e.  Dans le domaine des plug-ins <br><br><pre> <code class="plaintext hljs">const warn = std.debug.warn;</code> </pre> <br>  et le code est √©crit comme ceci: <br><br><pre> <code class="plaintext hljs">warn("{}\n{}\n", false, "hi");</code> </pre> <br>  Le compilateur a quelques bugs, qu'il rapporte honn√™tement en essayant de sortir un entier ou un nombre √† virgule flottante de cette mani√®re: <br><blockquote>  erreur: bogue du compilateur: les litt√©raux entiers et flottants dans la fonction var args doivent √™tre transtyp√©s.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/ziglang/zig/issues/557</a> </blockquote><h2>  Types de donn√©es </h2><br><h3>  Types primitifs </h3><br>  Les noms de type sont apparemment tir√©s de Rust (i8, u8, ... i128, u128), il existe √©galement des types sp√©ciaux pour la compatibilit√© binaire C, 4 types de types √† virgule flottante (f16, f32, f64, f128).  Il y a un type bool.  Il y a un type de vide de longueur nulle et un retour de nor sp√©cial, dont je parlerai plus tard. <br><br>  Vous pouvez √©galement construire des types entiers de n'importe quelle longueur en bits de 1 √† 65535. Le nom du type commence par la lettre i ou u, puis la longueur en bits est √©crite. <br><br><pre> <code class="plaintext hljs">//  ! var j:i65535 = 0x0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF;</code> </pre> <br>  Cependant, je n'ai pas pu obtenir cette valeur sur la console - une erreur s'est produite dans le LLVM pendant le processus de compilation. <br><br>  En g√©n√©ral, c'est une solution int√©ressante, bien qu'ambigu√´ (√† mon humble avis: prendre en charge des litt√©raux num√©riques exactement longs au niveau du compilateur, mais nommer les types de cette mani√®re n'est pas tr√®s bon, il est pr√©f√©rable de le faire honn√™tement via un type de mod√®le).  Et pourquoi la limite est-elle de 65535?  Des biblioth√®ques comme GMP ne semblent pas imposer de telles restrictions? <br><br><h3>  Litt√©raux de cha√Æne </h3><br>  Ce sont des tableaux de caract√®res (sans z√©ro √† la fin).  Pour les litt√©raux dont le z√©ro se termine, le pr√©fixe ¬´c¬ª est utilis√©. <br><br><pre> <code class="plaintext hljs">const normal_bytes = "hello"; const null_terminated_bytes = c"hello";</code> </pre> <br>  Comme la plupart des langues, Zig prend en charge les s√©quences d'√©chappement standard et l'insertion de caract√®res Unicode via leurs codes (\ uNNNN, \ UNNNNNN o√π N est un chiffre hexad√©cimal). <br>  Les litt√©raux multilignes sont form√©s √† l'aide de deux barres obliques inverses au d√©but de chaque ligne.  Aucun guillemet n'est requis.  Autrement dit, certains tentent de cr√©er des lignes brutes, mais √† mon humble avis - l'avantage des lignes brutes est que vous pouvez ins√©rer n'importe quel morceau de texte de n'importe o√π dans le code - et, id√©alement, ne change rien, mais ici, vous devez ajouter \\ au d√©but de chaque ligne. <br><br><pre> <code class="plaintext hljs">const multiline = \\#include &lt;stdio.h&gt; \\ \\int main(int argc, char **argv) { \\ printf("hello world\n"); \\ return 0; \\} ;</code> </pre> <br><h3>  Litt√©raux entiers </h3><br>  Tout est dans des langues similaires.  J'√©tais tr√®s heureux que pour les litt√©raux octaux, le pr√©fixe 0o soit utilis√©, et pas seulement z√©ro, comme en C.  Les litt√©raux binaires avec le pr√©fixe 0b sont √©galement pris en charge.  Les litt√©raux √† virgule flottante peuvent √™tre hexad√©cimaux (comme cela se fait dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'extension GCC</a> ). <br><br><h3>  Les op√©rations </h3><br>  Bien s√ªr, il existe des op√©rations C arithm√©tiques, logiques et au niveau du bit standard.  Les op√©rations abr√©g√©es sont prises en charge (+ = etc.).  Au lieu de &amp;&amp; et ||  les mots-cl√©s et et ou sont utilis√©s.  Un point int√©ressant est que les op√©rations avec une s√©mantique enveloppante garantie sont √©galement prises en charge.  Ils ressemblent √† ceci: <br><br><pre> <code class="plaintext hljs">a +% b a +%= b</code> </pre> <br>  Dans ce cas, les op√©rations arithm√©tiques ordinaires ne garantissent pas le d√©bordement et leurs r√©sultats pendant le d√©bordement sont consid√©r√©s comme ind√©finis (et des erreurs de compilation sont g√©n√©r√©es pour les constantes).  √Ä mon humble avis, c'est un peu √©trange, mais apparemment, il est fait √† partir de certaines consid√©rations profondes de compatibilit√© avec la s√©mantique du langage C. <br><br><h3>  Tableaux </h3><br>  Les litt√©raux de tableau ressemblent √† ceci: <br><br><pre> <code class="plaintext hljs">const msg = []u8{ 'h', 'e', 'l', 'l', 'o' }; const arr = []i32{ 1, 2, 3, 4 };</code> </pre> <br>  Les cha√Ænes sont des tableaux de caract√®res, comme en C.  Indexation classique avec crochets.  Les op√©rations d'addition (concat√©nation) et de multiplication de tableaux sont fournies.  C'est une chose tr√®s int√©ressante, et si tout est clair avec la concat√©nation, alors multiplication - j'ai continu√© d'attendre jusqu'√† ce que quelqu'un impl√©mente cela, et maintenant j'attends :) Dans Assembler (!) Il y a une telle op√©ration de dup qui vous permet de g√©n√©rer des donn√©es en double.  Maintenant √† Zig: <br><br><pre> <code class="plaintext hljs">const one = []i32{ 1, 2, 3, 4 }; const two = []i32{ 5, 6, 7, 8 }; const c = one ++ two; // { 1,2,3,4,5,6,7,8 } const pattern = "ab" ** 3; // "ababab"</code> </pre> <br><h3>  Pointeurs </h3><br>  La syntaxe est similaire √† C. <br><br><pre> <code class="plaintext hljs">var x: i32 = 1234; //  const x_ptr = &amp;x; //  </code> </pre> <br>  Pour le d√©r√©f√©rencement (prise de valeurs par pointeur), une op√©ration de suffixe inhabituelle est utilis√©e: <br><br><pre> <code class="plaintext hljs">x_ptr.* == 5678; x_ptr.* += 1;</code> </pre> <br>  Le type de pointeur est d√©fini explicitement en d√©finissant un ast√©risque devant le nom du type <br><br><pre> <code class="plaintext hljs">const x_ptr : *i32 = &amp;x;</code> </pre> <br><h3>  Tranches (tranches) </h3><br>  Une structure de donn√©es int√©gr√©e au langage qui vous permet de r√©f√©rencer un tableau ou une partie de celui-ci.  Contient un pointeur sur le premier √©l√©ment et le nombre d'√©l√©ments.  Cela ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">var array = []i32{ 1, 2, 3, 4 }; const slice = array[0..array.len];</code> </pre> <br>  Il semble provenir de Go, pas s√ªr.  Et je ne sais pas non plus si cela valait la peine d'√™tre incorpor√© dans une langue, alors que la mise en ≈ìuvre dans une langue OOP d'une telle chose est tr√®s √©l√©mentaire. <br><br><h3>  Structures </h3><br>  Une fa√ßon int√©ressante de d√©clarer une structure: une constante est d√©clar√©e, dont le type est automatiquement affich√© comme "type" (type), et c'est elle qui est utilis√©e comme nom de la structure.  Et la structure elle-m√™me (struct) est "sans nom". <br><br><pre> <code class="plaintext hljs">const Point = struct { x: f32, y: f32, };</code> </pre> <br>  Il est impossible de sp√©cifier un nom de la mani√®re habituelle dans les langages de type C, cependant, le compilateur affiche le nom du type selon certaines r√®gles - en particulier, dans le cas consid√©r√© ci-dessus, il co√Øncidera avec le nom de la constante "type". <br><br>  En g√©n√©ral, la langue ne garantit pas l'ordre des champs et leur alignement en m√©moire.  Si des garanties sont n√©cessaires, des structures ¬´packag√©es¬ª doivent √™tre utilis√©es. <br><br><pre> <code class="plaintext hljs">const Point2 = packed struct { x: f32, y: f32, };</code> </pre> <br>  Initialisation - dans le style des d√©signateurs Sishny: <br><br><pre> <code class="plaintext hljs">const p = Point { .x = 0.12, .y = 0.34, };</code> </pre> <br>  Les structures peuvent avoir des m√©thodes.  Cependant, placer une m√©thode dans une structure consiste simplement √† utiliser la structure comme espace de noms;  contrairement √† C ++, aucun param√®tre implicite n'est transmis. <br><br><h3>  Transferts </h3><br>  En g√©n√©ral, la m√™me chose qu'en C / C ++.  Il existe des moyens int√©gr√©s pratiques d'acc√©der aux m√©ta-informations, par exemple le nombre de champs et leurs noms, impl√©ment√©s par des macros de syntaxe int√©gr√©es au langage (appel√©es fonctions int√©gr√©es dans la documentation). <br><br>  Pour la "compatibilit√© binaire avec C", certaines √©num√©rations externes sont fournies. <br><br>  Pour indiquer le type qui devrait sous-tendre l'√©num√©ration, une construction du formulaire <br><br><pre> <code class="plaintext hljs">packed enum(u8)</code> </pre> <br>  o√π u8 est le type de base. <br>  Les √©num√©rations peuvent avoir des m√©thodes similaires aux structures (c'est-√†-dire utiliser un nom d'√©num√©ration comme espace de noms). <br><br><h3>  Les syndicats </h3><br>  Si je comprends bien, l'union de Zig est une somme de type alg√©brique, c'est-√†-dire  contient un champ de balise masqu√© qui d√©termine lequel des champs d'union est ¬´actif¬ª.  L '¬´activation¬ª d'un autre champ est r√©alis√©e par une r√©affectation compl√®te de l'ensemble de l'association.  Exemple de documentation <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; const mem = @import("std").mem; const Payload = union { Int: i64, Float: f64, Bool: bool, }; test "simple union" { var payload = Payload {.Int = 1234}; // payload.Float = 12.34; // !    assert(payload.Int == 1234); //       payload = Payload {.Float = 12.34}; assert(payload.Float == 12.34); }</code> </pre> <br>  Les syndicats peuvent √©galement utiliser explicitement des √©num√©rations pour la balise. <br><br><pre> <code class="plaintext hljs">// Unions can be given an enum tag type: const ComplexTypeTag = enum { Ok, NotOk }; const ComplexType = union(ComplexTypeTag) { Ok: u8, NotOk: void, };</code> </pre> <br>  Les unions, comme les √©num√©rations et les structures, peuvent √©galement fournir leur propre espace de noms pour les m√©thodes. <br><br><h3>  Types optionnels </h3><br>  Zig a un support optionnel int√©gr√©.  Un point d'interrogation est ajout√© avant le nom du type: <br><br><pre> <code class="plaintext hljs">const normal_int: i32 = 1234; // normal integer const optional_int: ?i32 = 5678; // optional integer</code> </pre> <br>  Fait int√©ressant, Zig met en ≈ìuvre une chose √† propos de la possibilit√© dont je soup√ßonnais, mais je ne savais pas si c'√©tait vrai ou non.  Les pointeurs sont rendus compatibles avec les options sans ajouter de champ cach√© suppl√©mentaire (¬´tag¬ª), qui stocke un signe de la validit√© de la valeur;  et null est utilis√© comme valeur non valide.  Ainsi, les types de r√©f√©rence repr√©sent√©s dans Zig par des pointeurs ne n√©cessitent m√™me pas de m√©moire suppl√©mentaire pour le ¬´caract√®re facultatif¬ª.  Dans le m√™me temps, l'attribution de valeurs nulles √† des pointeurs r√©guliers est interdite. <br><br><h3>  Types d'erreur </h3><br>  Ils sont similaires aux types facultatifs, mais au lieu de la balise bool√©enne (¬´vraiment invalide¬ª), un √©l√©ment d'√©num√©ration correspondant au code d'erreur est utilis√©.  La syntaxe est similaire aux options, un point d'exclamation est ajout√© au lieu d'un point d'interrogation.  Ainsi, ces types peuvent √™tre utilis√©s, par exemple, pour retourner √† partir de fonctions: soit le r√©sultat de l'objet de l'op√©ration r√©ussie de la fonction est renvoy√©, soit une erreur avec le code correspondant est renvoy√©e.  Les types d'erreur sont une partie importante du syst√®me de gestion des erreurs en langage Zig, pour plus de d√©tails, voir la section Gestion des erreurs. <br><br><h3>  Tapez void </h3><br>  Des variables comme void et les op√©rations avec elles sont possibles dans Zig <br><br><pre> <code class="plaintext hljs">var x: void = {}; var y: void = {}; x = y;</code> </pre> <br>  aucun code n'est g√©n√©r√© pour de telles op√©rations;  ce type est principalement utile pour la m√©taprogrammation. <br><br>  Il existe √©galement un type c_void pour la compatibilit√© C. <br><br><h2>  Op√©rateurs et fonctions de contr√¥le </h2><br>  Ceux-ci incluent: blocs, commutateur, tandis que, pour, si, sinon, casser, continuer.  Pour regrouper le code, des accolades standard sont utilis√©es.  Seuls les blocs, comme en C / C ++, sont utilis√©s pour limiter la port√©e des variables.  Les blocs peuvent √™tre consid√©r√©s comme des expressions.  Il n'y a pas de goto dans le langage, mais il existe des √©tiquettes qui peuvent √™tre utilis√©es avec les instructions break et continue.  Par d√©faut, ces op√©rateurs fonctionnent avec des boucles; cependant, si un bloc a une √©tiquette, vous pouvez l'utiliser. <br><br><pre> <code class="plaintext hljs">var y: i32 = 123; const x = blk: { y += 1; break :blk y; //   blk   y };</code> </pre> <br>  L'instruction switch diff√®re de l'op√©rateur en ce qu'elle n'a pas de "fallthrough", c'est-√†-dire  une seule condition (cas) est ex√©cut√©e et le commutateur se ferme.  La syntaxe est plus compacte: au lieu de la casse, la fl√®che "=&gt;" est utilis√©e.  Switch peut √©galement √™tre consid√©r√© comme une expression. <br><br>  Les instructions while et if sont g√©n√©ralement les m√™mes que dans tous les langages de type C.  L'instruction for ressemble plus √† foreach.  Tous peuvent √™tre consid√©r√©s comme des expressions.  Parmi les nouvelles fonctionnalit√©s, while et for, ainsi que if, peuvent avoir un bloc else qui s'ex√©cute s'il n'y a pas d'it√©ration de boucle. <br><br>  Et ici, il est temps de parler d'une caract√©ristique commune pour le commutateur, tandis que, qui est en quelque sorte emprunt√© au concept de boucles foreach - ¬´capture¬ª de variables.  Cela ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">while (eventuallyNullSequence()) |value| { sum1 += value; } if (opt_arg) |value| { assert(value == 0); } for (items[0..1]) |value| { sum += value; }</code> </pre><br>  Ici, l'argument while est une certaine ¬´source¬ª de donn√©es, qui peut √™tre facultative, pour for, un tableau ou une tranche, et une variable situ√©e entre deux lignes verticales contient une valeur ¬´√©tendue¬ª - c'est-√†-dire,  l'√©l√©ment actuel du tableau ou de la tranche (ou un pointeur vers celui-ci), la valeur interne du type facultatif (ou un pointeur vers celui-ci). <br><br><h3>  D√©clarations de report et d'erreur </h3><br>  Le relev√© d'ex√©cution diff√©r√© emprunt√© √† Go.  Il fonctionne de la m√™me mani√®re - l'argument de cet op√©rateur est ex√©cut√© en quittant la port√©e dans laquelle l'op√©rateur est utilis√©.  De plus, l'op√©rateur errdefer est fourni, qui est d√©clench√© si un type d'erreur avec un code d'erreur actif est renvoy√© par la fonction.  Cela fait partie du syst√®me de gestion des erreurs Zig d'origine. <br><br><h3>  Op√©rateur inaccessible </h3><br>  L'√©l√©ment de la programmation contractuelle.  Un mot-cl√© sp√©cial, qui est mis l√† o√π la direction ne doit en aucun cas venir.  S'il y arrive, dans les modes Debug et ReleaseSafe, une panique est g√©n√©r√©e et dans ReleaseFast, l'optimiseur rejette compl√®tement ces branches. <br><br><h3>  noreturn </h3><br>  Techniquement, c'est un type compatible dans les expressions avec tout autre type.  Cela est possible car un objet de ce type ne reviendra jamais.  Puisque les op√©rateurs sont des expressions en Zig, un type sp√©cial est n√©cessaire pour les expressions qui ne seront jamais √©valu√©es.  Cela se produit lorsque le c√¥t√© droit de l'expression transf√®re irr√©vocablement le contr√¥le quelque part √† l'ext√©rieur.  Pour de telles instructions, les boucles et les fonctions infinies qui ne renvoient jamais le contr√¥le sont interrompues, poursuivies, renvoy√©es, inaccessibles.  √Ä titre de comparaison, un appel √† une fonction r√©guli√®re (retour de contr√¥le) n'est pas un op√©rateur noreturn, car bien que le contr√¥le soit transf√©r√© √† l'ext√©rieur, il sera renvoy√© au point d'appel t√¥t ou tard. <br><br>  Ainsi, les expressions suivantes deviennent possibles: <br><br><pre> <code class="plaintext hljs">fn foo(condition: bool, b: u32) void { const a = if (condition) b else return; @panic("do something with a"); }</code> </pre> <br>  La variable a obtient la valeur renvoy√©e par l'instruction if / else.  Pour cela, les parties (√† la fois if et else) doivent renvoyer une expression du m√™me type.  La partie if renvoie bool, la partie else est le type noreturn, qui est techniquement compatible avec n'importe quel type, par cons√©quent, le code se compile sans erreur. <br><br><h3>  Les fonctions </h3><br>  La syntaxe est classique pour les langues de ce type: <br><br><pre> <code class="plaintext hljs">fn add(a: i8, b: i8) i8 { return a + b; }</code> </pre> <br>  En g√©n√©ral, les fonctions semblent assez standard.  Jusqu'√† pr√©sent, je n'ai pas remarqu√© de signes de fonctions de premi√®re classe, mais ma connaissance du langage est tr√®s superficielle, je peux me tromper.  Bien que cela n'ait peut-√™tre pas encore √©t√© fait. <br><br>  Une autre caract√©ristique int√©ressante est que dans Zig, ignorer les valeurs renvoy√©es ne peut √™tre fait explicitement qu'en utilisant le trait de soulignement _ <br><br><pre> <code class="plaintext hljs"> _ = foo();</code> </pre> <br>  Il y a une r√©flexion qui vous permet d'obtenir diverses informations sur la fonction <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "fn reflection" { assert(@typeOf(assert).ReturnType == void); //    assert(@typeOf(assert).is_var_args == false); //    }</code> </pre> <br><h2>  Ex√©cution de code au moment de la compilation </h2><br>  Zig fournit une fonctionnalit√© puissante - ex√©cutant du code √©crit en zig au moment de la compilation.  Pour que le code soit ex√©cut√© au moment de la compilation, enveloppez-le simplement dans un bloc avec le mot cl√© comptime.  La m√™me fonction peut √™tre appel√©e √† la fois au moment de la compilation et au moment de l'ex√©cution, ce qui vous permet d'√©crire du code universel.  Bien s√ªr, il existe certaines limitations associ√©es aux diff√©rents contextes du code.  Par exemple, dans la documentation de nombreux exemples, comptime est utilis√© pour v√©rifier le temps de compilation: <br><br><pre> <code class="plaintext hljs">// array literal const message = []u8{ 'h', 'e', 'l', 'l', 'o' }; // get the size of an array comptime { assert(message.len == 5); }</code> </pre> <br>  Mais bien s√ªr, la puissance de cet op√©rateur est loin d'√™tre pleinement d√©voil√©e ici.  Ainsi, dans la description du langage, un exemple classique de l'utilisation efficace des macros syntaxiques est donn√© - la mise en ≈ìuvre d'une fonction similaire √† printf, mais en analysant la cha√Æne de format et en effectuant tous les types de v√©rification d'arguments n√©cessaires au stade de la compilation. <br><br>  En outre, le mot comptime est utilis√© pour indiquer les param√®tres des fonctions de compilation, qui est similaire aux fonctions de mod√®le C ++. <br><br><pre> <code class="plaintext hljs">   fn max(comptime T: type, a: T, b: T) T { return if (a &gt; b) a else b; }</code> </pre> <br><h2>  Gestion des erreurs </h2><br>  Zig a invent√© un syst√®me de gestion des erreurs original qui ne ressemblait pas aux autres langues.  Cela peut √™tre appel√© ¬´exceptions explicites¬ª (dans cette langue, l'explicitness est g√©n√©ralement l'un des idiomes).  Il ressemble √©galement aux codes de retour Go, mais il fonctionne diff√©remment. <br><br>  Le syst√®me de traitement des erreurs Zig est bas√© sur des √©num√©rations sp√©ciales pour impl√©menter ses propres codes d'erreur (erreur) et construit sur leur base des ¬´types d'erreur¬ª (somme de type alg√©brique, combinant le type de fonction retourn√© et le code d'erreur). <br><br>  Les √©num√©rations d'erreur sont d√©clar√©es de la m√™me mani√®re que les √©num√©rations r√©guli√®res: <br><br><pre> <code class="plaintext hljs">const FileOpenError = error { AccessDenied, OutOfMemory, FileNotFound, }; const AllocationError = error { OutOfMemory, };</code> </pre> <br>  Cependant, tous les codes d'erreur re√ßoivent des valeurs sup√©rieures √† z√©ro;  en outre, si vous d√©clarez un code du m√™me nom dans deux √©num√©rations, il recevra la m√™me valeur.  Cependant, les conversions implicites entre diff√©rentes √©num√©rations d'erreurs sont interdites. <br><br>  Le mot-cl√© anyerror signifie une √©num√©ration qui inclut tous les codes d'erreur. <br><br>  Comme les types facultatifs, le langage prend en charge la g√©n√©ration de types d'erreur √† l'aide d'une syntaxe sp√©ciale.  Type! U64 est une forme abr√©g√©e de anyerror! U64, qui √† son tour signifie une union (option), qui comprend le type u64 et le type anyerror (si je comprends bien, le code 0 est r√©serv√© pour indiquer l'absence d'erreur et la validit√© du champ de donn√©es, le reste des codes sont en fait des codes d'erreur). <br><br>  Le mot cl√© catch vous permet de d√©tecter l'erreur et de la transformer en valeur par d√©faut: <br><br><pre> <code class="plaintext hljs">const number = parseU64(str, 10) catch 13;</code> </pre> <br>  Par cons√©quent, si une erreur se produit dans la fonction parseU64 renvoyant le type! U64, alors catch "l'interceptera" et renverra la valeur par d√©faut de 13. <br><br>  Le mot-cl√© try vous permet de "transmettre" l'erreur au niveau sup√©rieur (c'est-√†-dire au niveau de la fonction appelante).  Afficher le code <br><br><pre> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = try parseU64(str, 10); // ... }</code> </pre> <br>  √©quivalent √† ceci: <br><br><pre> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = parseU64(str, 10) catch |err| return err; // ... }</code> </pre> <br>  Voici ce qui se produit: parseU64 est appel√©, si une erreur en est renvoy√©e - il est intercept√© par l'instruction catch, dans laquelle le code d'erreur est extrait √† l'aide de la syntaxe "capture", plac√©e dans la variable err, qui est renvoy√©e via! Void √† la fonction appelante. <br><br>  L'op√©rateur errdefer d√©crit pr√©c√©demment fait √©galement r√©f√©rence √† la gestion des erreurs.  Le code qui est un argument errdefer n'est ex√©cut√© que si la fonction renvoie une erreur. <br><br>  Encore plus de possibilit√©s.  Utilisation du ||  vous pouvez fusionner des ensembles d'erreurs <br><br><pre> <code class="plaintext hljs">const A = error{ NotDir, PathNotFound, }; const B = error{ OutOfMemory, PathNotFound, }; const C = A || B;</code> </pre> <br>  Zig fournit √©galement des fonctionnalit√©s telles que le suivi des erreurs.  C'est quelque chose de similaire √† une trace de pile, mais contenant des informations d√©taill√©es sur l'erreur qui s'est produite et sur la fa√ßon dont elle s'est propag√©e le long de la cha√Æne d'essai du lieu d'occurrence √† la fonction principale du programme. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, le syst√®me de gestion des erreurs dans Zig est une solution tr√®s originale, qui ne ressemble pas √† des exceptions en C ++ ou √† des codes de retour dans Go. </font><font style="vertical-align: inherit;">Nous pouvons dire qu'une telle solution a un certain prix - 4 octets suppl√©mentaires, qui doivent √™tre retourn√©s avec chaque valeur retourn√©e; </font><font style="vertical-align: inherit;">les avantages √©vidents sont une visibilit√© et une transparence absolues. </font><font style="vertical-align: inherit;">Contrairement √† C ++, ici, la fonction ne peut pas lever d'exception inconnue quelque part dans la profondeur de la cha√Æne d'appel. </font><font style="vertical-align: inherit;">Tout ce que la fonction retourne - elle retourne explicitement et seulement explicitement.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coroutines </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zig a des coroutines int√©gr√©es. </font><font style="vertical-align: inherit;">Ce sont des fonctions qui sont cr√©√©es avec le mot-cl√© async, √† l'aide desquelles les fonctions de l'allocateur et du d√©sallocateur sont transf√©r√©es (si je comprends bien, pour une pile suppl√©mentaire).</font></font><br><br><pre> <code class="plaintext hljs">test "create a coroutine and cancel it" { const p = try async&lt;std.debug.global_allocator&gt; simpleAsyncFn(); comptime assert(@typeOf(p) == promise-&gt;void); cancel p; assert(x == 2); } async&lt;*std.mem.Allocator&gt; fn simpleAsyncFn() void { x += 1; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async renvoie un objet sp√©cial de type promesse-&gt; T (o√π T est le type de retour de la fonction). En utilisant cet objet, vous pouvez contr√¥ler la coroutine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les niveaux les plus bas incluent les mots-cl√©s suspendre, reprendre et annuler. En utilisant suspend, l'ex√©cution de la coroutine est suspendue et transmise au programme appelant. La syntaxe du bloc suspendu est possible, tout √† l'int√©rieur du bloc est ex√©cut√© jusqu'√† ce que la coroutine soit r√©ellement suspendue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resume prend un argument de type promise-&gt; T et reprend l'ex√©cution de la coroutine d'o√π elle a √©t√© suspendue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">annuler lib√®re la m√©moire coroutine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette image montre le transfert de contr√¥le entre le programme principal (sous forme de test) et la coroutine. Tout est assez simple:</font></font><br><br><img src="https://habrastorage.org/webt/yi/em/dv/yiemdv3ujvm-rodjnohawjtld68.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deuxi√®me caract√©ristique (niveau sup√©rieur) est l'utilisation de l'attente. </font><font style="vertical-align: inherit;">C'est la seule chose que, franchement, je n'ai pas compris (h√©las, la documentation est encore tr√®s rare). </font><font style="vertical-align: inherit;">Voici le sch√©ma de transfert de contr√¥le r√©el d'un exemple l√©g√®rement modifi√© de la documentation, peut-√™tre que cela vous expliquera quelque chose:</font></font><br><br><img src="https://habrastorage.org/webt/yo/gu/uq/yoguuqayvhwyxtrhcni-rjn-w7g.png" alt="image"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fonctions int√©gr√©es </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonctions int√©gr√©es - un ensemble assez important de fonctions qui sont int√©gr√©es dans le langage et ne n√©cessitent la connexion d'aucun module. Il est peut-√™tre plus correct d'appeler certaines d'entre elles des ¬´macros syntaxiques int√©gr√©es¬ª, car les capacit√©s de beaucoup vont bien au-del√† des fonctions. les fonctions int√©gr√©es permettent d'acc√©der aux outils de r√©flexion (sizeOf, tagName, TagType, typeInfo, typeName, typeOf), avec leurs modules d'aide (importation) connect√©s. D'autres ressemblent davantage au C / C ++ int√©gr√© classique - ils impl√©mentent des conversions de type bas niveau, diverses op√©rations telles que sqrt, popCount, slhExact, etc. Il est tr√®s probable que la liste des fonctions int√©gr√©es change au fur et √† mesure que le langage se d√©veloppe.</font></font><br><br><h3>  En conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est tr√®s agr√©able que de tels projets apparaissent et se d√©veloppent. </font><font style="vertical-align: inherit;">Bien que le langage C soit pratique, concis et familier √† beaucoup, il est toujours d√©pass√© et, pour des raisons architecturales, ne peut pas prendre en charge de nombreux concepts de programmation modernes. </font><font style="vertical-align: inherit;">Le C ++ se d√©veloppe, mais objectivement repens√©, il devient de plus en plus difficile avec chaque nouvelle version, et pour les m√™mes raisons architecturales et en raison du besoin de compatibilit√© descendante, rien ne peut √™tre fait √† ce sujet. </font><font style="vertical-align: inherit;">La rouille est int√©ressante, mais avec un seuil d'entr√©e tr√®s √©lev√©, ce qui n'est pas toujours justifi√©. </font><font style="vertical-align: inherit;">D est une bonne tentative, mais il y a quelques failles mineures, il semble qu'au d√©part le langage a √©t√© cr√©√© plus probablement sous l'influence de Java, et les fonctionnalit√©s suivantes ont √©t√© introduites d'une mani√®re ou d'une autre pas comme elles le devraient. </font><font style="vertical-align: inherit;">De toute √©vidence, Zig est une autre de ces tentatives. </font><font style="vertical-align: inherit;">La langue est int√©ressante, et c'est int√©ressant de voir ce qui en sort.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435872/">https://habr.com/ru/post/fr435872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435862/index.html">Temple de la renomm√©e de l'√©lectronique grand public: les histoires des meilleurs gadgets des 50 derni√®res ann√©es, partie 4</a></li>
<li><a href="../fr435864/index.html">Cartographie des demandes pour Netty</a></li>
<li><a href="../fr435866/index.html">Release IT: une nouvelle plateforme de lancement de produits et services dans le cadre du festival SXSW 2019</a></li>
<li><a href="../fr435868/index.html">Slush 2018. Preview Day</a></li>
<li><a href="../fr435870/index.html">Orchestre cybern√©tique. Docker Container Orchestration avec des applications .NET Core dans le cloud</a></li>
<li><a href="../fr435876/index.html">Param√®tres d√©taill√©s du navigateur Firefox</a></li>
<li><a href="../fr435878/index.html">Amateur en open source - le√ßons apprises en 3 ans</a></li>
<li><a href="../fr435880/index.html">Modification du sch√©ma des tables PostgreSQL sans longs verrous. Conf√©rence Yandex</a></li>
<li><a href="../fr435882/index.html">Test du Xiaomi Mi Box S et petite comparaison avec la Mi Box 3</a></li>
<li><a href="../fr435884/index.html">Recherche de m√©taux et ... r√©seau neuronal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>