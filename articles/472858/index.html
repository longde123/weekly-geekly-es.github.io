<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèª üïäÔ∏è ü§≤üèª Python y clientes HTTP r√°pidos üëéüèæ üßùüèø üßúüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy en d√≠a, si est√° escribiendo alg√∫n tipo de aplicaci√≥n Python, lo m√°s probable es que tenga que equiparla con la funcionalidad de un cliente HTTP qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python y clientes HTTP r√°pidos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472858/">  Hoy en d√≠a, si est√° escribiendo alg√∫n tipo de aplicaci√≥n Python, lo m√°s probable es que tenga que equiparla con la funcionalidad de un cliente HTTP que pueda comunicarse con los servidores HTTP.  La ubicuidad de la API REST ha hecho de las herramientas HTTP una caracter√≠stica respetada en innumerables proyectos de software.  Es por eso que cualquier programador necesita poseer patrones destinados a organizar un trabajo √≥ptimo con conexiones HTTP. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/fv/ix/xt/fvixxt-a-wwkrs5vivurfucn5pe.jpeg"></a> <br><br>  Hay muchos clientes HTTP para Python.  Los m√°s comunes entre ellos y, adem√°s, con el que es f√°cil trabajar, se pueden llamar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitudes</a> .  Hoy, este cliente es el est√°ndar de facto. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Conexiones permanentes</font> </h2><br>  La primera optimizaci√≥n a tener en cuenta al trabajar con HTTP es utilizar conexiones persistentes a los servidores web.  Las conexiones persistentes se han convertido en est√°ndar desde HTTP 1.1, pero muchas aplicaciones a√∫n no las usan.  Esta falla es f√°cil de explicar, sabiendo que cuando se usa la biblioteca de <code>requests</code> en modo simple (por ejemplo, usando su m√©todo <code>get</code> ), la conexi√≥n al servidor se cierra despu√©s de recibir una respuesta de este.  Para evitar esto, la aplicaci√≥n necesita usar el objeto <code>Session</code> , que permite reutilizar conexiones abiertas: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() session.get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    session.get("http://example.com")</span></span></code> </pre> <br>  Las conexiones se almacenan en el grupo de conexiones (el valor predeterminado es 10 conexiones por defecto).  El tama√±o de la piscina se puede personalizar: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() adapter = requests.adapters.HTTPAdapter(    pool_connections=<span class="hljs-number"><span class="hljs-number">100</span></span>,    pool_maxsize=<span class="hljs-number"><span class="hljs-number">100</span></span>) session.mount(<span class="hljs-string"><span class="hljs-string">'http://'</span></span>, adapter) response = session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)</code> </pre> <br>  La reutilizaci√≥n de una conexi√≥n TCP para enviar m√∫ltiples solicitudes HTTP le brinda a la aplicaci√≥n muchos beneficios de rendimiento: <br><br><ul><li>  Reduciendo la carga en el procesador y reduciendo la necesidad de RAM (debido al hecho de que se abren menos conexiones al mismo tiempo). </li><li>  Reducci√≥n de demoras al ejecutar solicitudes una tras otra (no hay un procedimiento de protocolo de enlace TCP). </li><li>  Se pueden generar excepciones sin tiempo adicional para cerrar la conexi√≥n TCP. </li></ul><br>  HTTP 1.1 tambi√©n admite la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">canalizaci√≥n</a> de solicitudes.  Esto le permite enviar m√∫ltiples solicitudes dentro de la misma conexi√≥n sin esperar respuestas a solicitudes enviadas previamente (es decir, enviar solicitudes en "paquetes").  Lamentablemente, la biblioteca de <code>requests</code> no admite esta funci√≥n.  Sin embargo, las solicitudes de canalizaci√≥n pueden no ser tan r√°pidas como procesarlas en paralelo.  Y, adem√°s, es apropiado prestar atenci√≥n a esto: las respuestas a las solicitudes de "paquete" deben ser enviadas por el servidor en la misma secuencia en que recibi√≥ estas solicitudes.  El resultado no es el esquema de procesamiento de solicitudes m√°s eficiente basado en el principio FIFO (‚Äúprimero en entrar, primero en salir‚Äù - ‚Äúprimero en llegar, primero en salir‚Äù). <br><br><h2>  <font color="#3AC1EF">Procesamiento de consultas paralelas</font> </h2><br>  <code>requests</code> tambi√©n tienen otro inconveniente grave.  Esta es una biblioteca s√≠ncrona.  Una llamada a un m√©todo como <code>requests.get("http://example.org")</code> bloquea el programa hasta que se recibe una respuesta completa del servidor HTTP.  El hecho de que la aplicaci√≥n tenga que esperar y no hacer nada puede considerarse un inconveniente de este esquema de organizaci√≥n de interacci√≥n con el servidor.  ¬øEs posible hacer que el programa haga algo √∫til en lugar de solo esperar? <br><br>  Una aplicaci√≥n de dise√±o inteligente puede mitigar este problema mediante el uso de un grupo de subprocesos, similar a los proporcionados por <code>concurrent.futures</code> .  Esto le permite paralelizar r√°pidamente las solicitudes HTTP: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> futures.ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> executor:    futures = [        executor.submit(            <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: requests.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>))        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)    ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Este patr√≥n muy √∫til se implementa en la biblioteca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitudes de futuros</a> .  Al mismo tiempo, el uso de objetos <code>Session</code> es transparente para el desarrollador: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions session = sessions.FuturesSession() futures = [    session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>) ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  De manera predeterminada, se crea un trabajador con dos subprocesos, pero el programa puede establecer f√°cilmente este valor al pasar el argumento <code>FuturSession</code> o incluso su propio ejecutor al objeto <code>FuturSession</code> .  Por ejemplo, podr√≠a verse as√≠: <br><br><pre> <code class="python hljs">FuturesSession(executor=ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">10</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">Trabajo asincr√≥nico con solicitudes</font> </h2><br>  Como ya se mencion√≥, la biblioteca de <code>requests</code> es completamente sincr√≥nica.  Esto conduce al bloqueo de la aplicaci√≥n mientras se espera una respuesta del servidor, lo que afecta el rendimiento de manera deficiente.  Una soluci√≥n a este problema es ejecutar solicitudes HTTP en subprocesos separados.  Pero el uso de hilos es una carga adicional en el sistema.  Adem√°s, esto significa la introducci√≥n de un esquema paralelo de procesamiento de datos en el programa, que no se adapta a todos. <br><br>  Comenzando con Python 3.5, las caracter√≠sticas del lenguaje est√°ndar incluyen programaci√≥n asincr√≥nica usando <code>asyncio</code> .  La biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://aio">aiohttp</a> proporciona al desarrollador un cliente HTTP as√≠ncrono basado en <code>asyncio</code> .  Esta biblioteca permite que la aplicaci√≥n env√≠e una serie de solicitudes y contin√∫e trabajando.  Al mismo tiempo, para enviar otra solicitud, no necesita esperar una respuesta a una solicitud enviada anteriormente.  A diferencia de canalizar solicitudes HTTP, <code>aiohttp</code> env√≠a solicitudes en paralelo utilizando m√∫ltiples conexiones.  Esto evita el "problema FIFO" descrito anteriormente.  <code>aiohttp</code> es como se ve el uso de <code>aiohttp</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response loop = asyncio.get_event_loop() coroutines = [get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)] results = loop.run_until_complete(asyncio.gather(*coroutines)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Todos los enfoques descritos anteriormente (usando <code>Session</code> , streams, <code>concurrent.futures</code> o <code>asyncio</code> ) ofrecen diferentes formas de acelerar los clientes HTTP. <br><br><h2>  <font color="#3AC1EF">Rendimiento</font> </h2><br>  El siguiente c√≥digo es un ejemplo en el que el cliente HTTP env√≠a solicitudes al servidor <code>httpbin.org</code> .  El servidor admite una API que puede, entre otras cosas, simular un sistema que tarda mucho en responder a una solicitud (en este caso, es de 1 segundo).  Aqu√≠, se implementan todas las t√©cnicas discutidas anteriormente y se mide su rendimiento: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> contextlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions URL = <span class="hljs-string"><span class="hljs-string">"http://httpbin.org/delay/1"</span></span> TRIES = <span class="hljs-number"><span class="hljs-number">10</span></span> @contextlib.contextmanager <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report_time</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(test)</span></span></span><span class="hljs-function">:</span></span>    t0 = time.time()    <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>    print(<span class="hljs-string"><span class="hljs-string">"Time needed for `%s' called: %.2fs"</span></span>          % (test, time.time() - t0)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"serialized"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        requests.get(URL) session = requests.Session() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"Session"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        session.get(URL) session = sessions.FuturesSession(max_workers=<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ 2 workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() session = sessions.FuturesSession(max_workers=TRIES) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ max workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.read() loop = asyncio.get_event_loop() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"aiohttp"</span></span>):    loop.run_until_complete(        asyncio.gather(*[get(URL)                         <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]))</code> </pre> <br>  Aqu√≠ est√°n los resultados obtenidos despu√©s de comenzar este programa: <br><br><pre> <code class="python hljs">Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `serialized<span class="hljs-string"><span class="hljs-string">' called: 12.12s Time needed for `Session'</span></span> called: <span class="hljs-number"><span class="hljs-number">11.22</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `FuturesSession w/ <span class="hljs-number"><span class="hljs-number">2</span></span> workers<span class="hljs-string"><span class="hljs-string">' called: 5.65s Time needed for `FuturesSession w/ max workers'</span></span> called: <span class="hljs-number"><span class="hljs-number">1.25</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `aiohttp<span class="hljs-string"><span class="hljs-string">' called: 1.19s</span></span></code> </pre> <br>  Aqu√≠ hay una tabla de los resultados. <br><img src="https://habrastorage.org/getpro/habr/post_images/c84/655/e65/c84655e655fc6d400a4ffd2d932aaa61.png"><br>  <i><font color="#999999">Los resultados de un estudio sobre el rendimiento de diferentes m√©todos para ejecutar solicitudes HTTP</font></i> <br><br>  No es sorprendente que el esquema de ejecuci√≥n de consulta s√≠ncrona m√°s simple result√≥ ser el m√°s lento.  El punto aqu√≠ es que aqu√≠ las consultas se ejecutan una por una, sin reutilizar la conexi√≥n.  Como resultado, lleva 12 segundos completar 10 consultas. <br><br>  El uso del objeto <code>Session</code> y, como resultado, la reutilizaci√≥n de las conexiones, ahorra el 8% del tiempo.  Esto ya es muy bueno, y lograr esto es muy simple.  Cualquiera que se preocupe por el rendimiento debe usar al menos el objeto <code>Session</code> . <br><br>  Si su sistema y su programa le permiten trabajar con hilos, entonces esta es una buena raz√≥n para pensar en usar hilos para paralelizar las solicitudes.  Sin embargo, las transmisiones crean una carga adicional en el sistema, por as√≠ decirlo, no son "gratuitas".  Deben crearse, ejecutarse, debe esperar la finalizaci√≥n de su trabajo. <br><br>  Si desea utilizar el cliente HTTP as√≠ncrono r√°pido, entonces si no est√° escribiendo en versiones anteriores de Python, debe prestar la mayor atenci√≥n a <code>aiohttp</code> .  Esta es la soluci√≥n m√°s r√°pida, mejor escalable.  Es capaz de manejar cientos de solicitudes concurrentes. <br><br>  Una alternativa a <code>aiohttp</code> , no una alternativa particularmente buena, es administrar cientos de hilos en paralelo. <br><br><h2>  <font color="#3AC1EF">Procesamiento de datos de flujo</font> </h2><br>  Otra optimizaci√≥n para trabajar con recursos de red, que puede ser √∫til en t√©rminos de mejorar el rendimiento de la aplicaci√≥n, es utilizar la transmisi√≥n de datos.  El esquema de procesamiento de solicitudes est√°ndar tiene este aspecto: la aplicaci√≥n env√≠a una solicitud, despu√©s de lo cual el cuerpo de esta solicitud se carga de una vez.  El par√°metro de <code>stream</code> , que admite la biblioteca de <code>requests</code> , as√≠ como el atributo de <code>content</code> de la biblioteca <code>aiohttp</code> , le permite alejarse de este esquema. <br><br>  As√≠ es como se ve la organizaci√≥n del procesamiento de datos de transmisi√≥n mediante <code>requests</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-comment"><span class="hljs-comment">#  `with`          #     . with requests.get('http://example.org', stream=True) as r:    print(list(r.iter_content()))</span></span></code> </pre> <br>  Aqu√≠ le mostramos c√≥mo transmitir datos usando <code>aiohttp</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.content.read() loop = asyncio.get_event_loop() tasks = [asyncio.ensure_future(get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>))] loop.run_until_complete(asyncio.wait(tasks)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % [task.result() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> task <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tasks])</code> </pre> <br>  Eliminar la necesidad de cargar instant√°neamente el contenido de la respuesta completa es importante en los casos en que necesite evitar la posibilidad potencial de asignaci√≥n in√∫til de cientos de megabytes de memoria.  Si el programa no necesita acceso a la respuesta en su conjunto, si puede trabajar con fragmentos individuales de la respuesta, entonces probablemente sea mejor recurrir a m√©todos de transmisi√≥n de trabajo con solicitudes.  Por ejemplo, si va a guardar datos de la respuesta del servidor a un archivo, leerlo y escribirlo en partes ser√° mucho m√°s eficiente en t√©rminos de uso de memoria que leer todo el cuerpo de la respuesta, asignar una gran cantidad de memoria y luego escribirlo todo en el disco. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Espero que mi charla sobre las diferentes formas de optimizar el funcionamiento de los clientes HTTP lo ayude a elegir lo que mejor se adapte a su aplicaci√≥n Python. <br><br>  <b>Estimados lectores!</b>  Si a√∫n conoce otras formas de optimizar el trabajo con solicitudes HTTP en aplicaciones Python, comp√°rtalas. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472858/">https://habr.com/ru/post/472858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472848/index.html">Reflexiones sobre una carrera en TI</a></li>
<li><a href="../472850/index.html">Profesi√≥n o vida: Gana un curso de Netolog√≠a si no tienes miedo</a></li>
<li><a href="../472852/index.html">GitLab realiza cambios para usuarios de productos en la nube y comerciales</a></li>
<li><a href="../472854/index.html">Unity UI Profiling: ¬øQui√©n estropea mi procesamiento por lotes?</a></li>
<li><a href="../472856/index.html">C√≥mo cre√© un servicio de control de calidad a partir de tablas y palos</a></li>
<li><a href="../472860/index.html">Invalidaci√≥n de cach√© en cascada. Parte 1</a></li>
<li><a href="../472864/index.html">Punto de control: optimizaci√≥n de CPU y RAM</a></li>
<li><a href="../472866/index.html">Talism√°n para comunicaci√≥n estable</a></li>
<li><a href="../472870/index.html">Por qu√© Agile se detiene sin transformar la arquitectura y las herramientas de desarrollo - presentaci√≥n de la conferencia</a></li>
<li><a href="../472876/index.html">Complejidad Cascada y Arquitectura bajo demanda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>