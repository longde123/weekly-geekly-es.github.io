<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè• üê∑ üàπ Architekturprobleme in gro√üen Projekten üë®üèΩ‚Äçüî¨ üôéüèº üßëüèø‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Entwicklung mobiler Apps scheint eine ziemlich einfache Aufgabe zu sein. Es scheint, was dort zu tun ist? Ich warf ein paar Ansichten, salbte es m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Architekturprobleme in gro√üen Projekten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/485172/"><p>  Die Entwicklung mobiler Apps scheint eine ziemlich einfache Aufgabe zu sein.  Es scheint, was dort zu tun ist?  Ich warf ein paar Ansichten, salbte es mit etwas Architektur, und das war es, das Projekt ist fertig, Sie k√∂nnen die Anwendung an die Station senden.  In einer Reihe von Artikeln werde ich auf die Funktionen eingehen, auf die wir bei der Entwicklung einer Anwendung f√ºr eine gro√üe Bank gesto√üen sind. </p><br><p>  Betrachten Sie 5 wichtige Themen.  Nat√ºrlich wurden die meisten von ihnen mehrmals in der Community diskutiert, aber hinter jedem Thema stehen Schmerzen, Tr√§nen, Zeitverlust und vor allem die Erfahrung, die uns n√ºtzlich war, und ich hoffe, dass es Ihnen n√ºtzlich sein wird. </p><br><p><img src="https://habrastorage.org/webt/ix/2q/wk/ix2qwkfsj5gueik1fd0-r5pjuog.png" alt="Bild"></p><a name="habracut"></a><br><p>  Zu Beginn der Entwicklung einer mobilen Anwendung stellt sich dem Marktf√ºhrer oder Designer die Frage, welches Architekturmuster zu verwenden ist.  Unser Studio hat ein gemeinsames Architekturmuster MVP.  Pure MVP ist in seiner reinen Form sicherlich gut (siehe Bild unten), aber wir w√§ren keine echten Entwickler, wenn wir dieses Muster nicht finalisieren w√ºrden.  Sie haben nicht bei einer Option Halt gemacht, und wir haben zwei Zweige von reinem MVP erhalten. </p><br><p><img src="https://habrastorage.org/webt/cf/4d/2v/cf4d2vj2mn9rbneovqjig0lce7y.jpeg" alt="Bild"></p><br><p>  Daher standen wir in der Entwurfsphase vor der Aufgabe, eines auszuw√§hlen und auf der Grundlage eines allgemein akzeptierten und verst√§ndlichen Architekturmusters fortzufahren.  Aber schon in einem so fr√ºhen Stadium ist es uns gelungen, einen Fehler zu machen, der uns sp√§ter viele Probleme bescherte. </p><br><p>  Schauen wir uns zwei unserer MVPs zu Steroiden an. </p><br><h2 id="surfmvphttpsgithubcomsurfstudiosurf-ios-developersblobmastersurf_mvpmd">  <a href="">SurfMVP</a> </h2><br><p><img src="https://habrastorage.org/webt/l7/aa/fu/l7aafucodquvixudd7ygcsn_tbk.jpeg" alt="Bild"></p><br><p>  Das Bild zeigt, dass sich im Vergleich zum √ºblichen MVP nicht viel ge√§ndert hat.  Beim Wechseln zwischen Bildschirmen in iOS-Anwendungen sind einige Probleme aufgetreten.  Eine gro√üe Menge an Logik f√ºr die Bildung neuer Bildschirme, bevor der √úbergang direkt im UIViewController konzentriert wird, erschien uns nicht ganz richtig. Deshalb haben wir zuerst die Router-Entit√§t getrennt, die f√ºr die √úberg√§nge zwischen Bildschirmen in der Anwendung verantwortlich ist. <br>  Modelle in SurfMVP sind die Dienste, die Presenter zum Abrufen von Daten aufruft.  Oft l√∂st ein Dienst die Aufgaben f√ºr das gesamte Modul, aber in schwierigen Situationen muss man mit mehreren interagieren. <br>  Die Configurator-Entit√§t ist f√ºr die Erstellung eines separaten Moduls verantwortlich, initialisiert alle erforderlichen Komponenten und ist f√ºr die Erstellung von Abh√§ngigkeiten zwischen ihnen verantwortlich. </p><br><p><img src="https://habrastorage.org/webt/ws/bc/pz/wsbcpzpyevuhps1taqnd-m0gy3w.jpeg" alt="Bild"></p><br><p>  Das Hauptmerkmal von SurfMVP ist, dass jede Schicht in MVP durch ein Protokoll getrennt ist.  Das Bild zeigt ein Diagramm der Schichten und die Beziehung der Protokolle zwischen ihnen.  Protokolle werden ben√∂tigt, damit jede Schicht von der anderen getrennt und theoretisch leicht ersetzt werden kann.  Jede der Schichten sollte keine Implementierungsdetails offenlegen. </p><br><p>  <strong>Betrachten wir sie getrennt:</strong> </p><br><p>  <strong>ViewInput</strong> - implementiert <strong>View</strong> selbst, <strong>Presenter</strong> beh√§lt den Link bei.  Dieses Protokoll beschreibt die Methoden, mit denen <strong>Presenter</strong> die <strong>Ansicht</strong> steuern, Daten √ºbertragen, Status √§ndern usw. kann. </p><br><p> <strong>ViewOutput</strong> - implementiert <strong>Presenter</strong> , <strong>View</strong> enth√§lt einen Link dazu.  Das Protokoll beschreibt eine Reihe von Aktionen, die in der <strong>Ansicht</strong> und in den Lebenszyklusmethoden ausgef√ºhrt werden k√∂nnen, z. B. Ereignisse der Benutzerinteraktion mit dem Bildschirm. </p><br><p>  <strong>RouterInput</strong> - implementiert den <strong>Router</strong> , und <strong>Presenter</strong> beh√§lt eine Verkn√ºpfung zu ihm bei, da dies der einzige ist, der f√ºr die weitere Navigation in der Anwendung verantwortlich ist. </p><br><p>  <strong>ModuleTransitionable</strong> - <strong>View</strong> ist implementiert, <strong>Router</strong> beh√§lt eine Verkn√ºpfung dazu.  Dies ist das einzige "grundlegende" Protokoll in <strong>SurfMVP</strong> .  Es wird ben√∂tigt, um dem Router eine Reihe von Methoden f√ºr die Arbeit mit der Anwendungsnavigation bereitzustellen. </p><br><p>  <strong>ModuleInput</strong> - Implementiert <strong>Presenter</strong> .  Dieses Protokoll muss Methoden enthalten, mit denen ein anderes Modul, das eine Verkn√ºpfung zu diesem Protokoll enth√§lt, den Status des aktuellen Moduls √§ndern kann. </p><br><p>  <strong>ModuleOutput</strong> - implementiert den <strong>Presenter des</strong> aufrufenden Moduls, der Link enth√§lt den <strong>Presenter des</strong> aufgerufenen Moduls.  Wenn der Profilbildschirm √ºber das Nachrichtenmodul angezeigt werden kann, sollte <em>NewsPresenter</em> <em>ProfileModuleOutput</em> implementieren und <em>ProfilePresenter sollte</em> einen Link dazu enthalten. <br>  <strong>ModuleOutput</strong> wird an den <strong>Configurator</strong> des aufgerufenen Moduls √ºbergeben und dort in <strong>Presenter</strong> installiert.  Enth√§lt Modulmethoden, die das Verhalten des aufrufenden Moduls beeinflussen. </p><br><h2 id="problema-surfmvp">  SurfMVP Problem </h2><br><p>  Aus all diesen Gr√ºnden gibt es ein Hauptproblem: die Navigation.  Wie sich herausstellte, bestand die Meldung zum Hervorheben einer separaten Router-Entit√§t zwar aus Navigationsproblemen, diese waren jedoch nicht mehr vorhanden.  SurfMVP wurde erfolgreich in Projekten mit einfacher <a href="https://developer.apple.com/design/human-interface-guidelines/ios/app-architecture/navigation/">flacher Navigation</a> ohne komplexe DeepLinks und Push-Benachrichtigungen eingesetzt. </p><br><p>  Das folgende Bild zeigt schematisch die Navigation in der Anwendung mit SurfMVP.  Jedes einzelne Modul kommuniziert √ºber einen eigenen Router mit dem anderen.  Auf diese Weise wird die Navigation eines beliebigen Flusses in der Anwendung erstellt. </p><br><p><img src="https://habrastorage.org/webt/-v/jp/r_/-vjpr_9j8vrlfqrtr25aoislf_m.jpeg" alt="Bild"></p><br><p>  Diese Art der Navigation eignet sich gut f√ºr den Fall, dass der Benutzer den Ablauf seiner Wahl in der Anwendung durchl√§uft.  Zum Beispiel in der folgenden Abbildung: Der Benutzer durchl√§uft die Bildschirme von Punkt A bis Punkt D, sodass er selbst einen Stapel erstellt, auf dem er auf die gleiche Weise vor- und zur√ºckgehen muss. </p><br><p><img src="https://habrastorage.org/webt/3x/qu/dp/3xqudpqcov2oqn32vx9cltkg9um.jpeg" alt="Bild"></p><br><p>  Probleme beginnen in dem Moment, in dem der Benutzer von Punkt A nach Punkt D versetzt werden muss, und dies sollte ohne seine Teilnahme geschehen.  Wenn ein Benutzer beispielsweise auf Push-Benachrichtigung klickt oder einem Link aus einer Drittanbieteranwendung folgt.  Im Fall von SurfMVP m√ºssen wir einen globalen Router hinzuf√ºgen, der die Navigation steuert, unabh√§ngig davon, wo sich der Benutzer gerade in der Anwendung befindet.  Um dieses Problem global zu l√∂sen, haben wir uns entschlossen, die Koordinatoren zu nutzen. Gehen wir zu ihnen √ºber. </p><br><p><img src="https://habrastorage.org/webt/rn/fn/mb/rnfnmbs2b7lias_cqvmpp6mvpz0.jpeg" alt="Bild"></p><br><h2 id="coordinated-surfmvp">  Koordiniertes SurfMVP </h2><br><p><img src="https://habrastorage.org/webt/bz/q3/qr/bzq3qrf53ggr3iczo32ex_rpcs0.jpeg" alt="Bild"></p><br><p>  Coordinated SurfMVP ist ein Architekturmuster, bei dem wir im Gegensatz zu SurfMVP die Router-Entit√§t, die sich in jedem einzelnen Modul befand, entfernt haben.  Das Paradigma, eine Anwendung zu erstellen, hat sich ein wenig ge√§ndert.  Module sind nicht mehr vollst√§ndig unabh√§ngig.  Jedes Modul, mit Ausnahme von vollst√§ndig wiederverwendbaren Modulen, befindet sich in einem separaten UserFlow, der wie geplant einige allgemeine Aktionen ausf√ºhren sollte, die den Benutzer zum gew√ºnschten Ergebnis f√ºhren. </p><br><p>  Ein Beispiel f√ºr einen solchen Fluss in unserer Anwendung ist der Zahlungsfluss.  Zahlungen sind eine Reihe von Bildschirmen, auf denen der Benutzer eine √úberweisung oder Zahlung auf verschiedene Arten vornehmen kann. </p><br><p>  In Coordinated SurfMVP ersetzte die Router-Entit√§t die <a href="http://khanlou.com/2015/01/the-coordinator/">Coordinator-</a> Entit√§t, die jetzt nicht nur f√ºr die Navigation eines einzelnen Moduls, sondern f√ºr eine Reihe von Modulen zust√§ndig ist, die logisch miteinander verbunden sind.  Dies vereinfacht die Navigation und das Arbeiten mit der Anwendung.  Schematisch sieht unsere Bewerbung so aus: </p><br><p><img src="https://habrastorage.org/webt/ln/uv/ce/lnuvcepenm_ai5xuufuxn_3eff8.jpeg" alt="Bild"></p><br><p>  Ganz oben befindet sich der ApplicationCoordinator, der f√ºr das anf√§ngliche Routing in der Anwendung verantwortlich ist.  In einem Fall, in dem der Benutzer autorisiert ist, werden wir ihn sofort an den Hauptteil der Anwendung senden. Andernfalls werden wir ihn an den Autorisierungsbildschirm senden. </p><br><p>  Wenn unsere Anwendung Deeplinks oder Push-Notifications enth√§lt, k√∂nnen wir jederzeit Initialisierungs- und Startregeln f√ºr Koordinatoren festlegen, damit diese den Stapel direkt an dem gew√ºnschten Punkt D erstellen, √ºber den wir zuvor gesprochen haben. </p><br><p><img src="https://habrastorage.org/webt/bz/i6/i3/bzi6i3mk9bfzl6dgi1oselxjmxm.jpeg" alt="Bild"></p><br><p>  Schematisch sieht unsere Navigation jetzt so aus.  Jeder einzelne UserFlow verweist auf seinen eigenen Koordinator, der seinerseits entscheidet, was in Zukunft passieren wird.  Die Verantwortung f√ºr die Daten√ºbertragung und die Einleitung der weiteren Navigation liegt jetzt beim Koordinator. Er ist bereits mit anderen Modulen oder anderen Koordinatoren verbunden, um den Navigationsstapel weiter aufzubauen. </p><br><h2 id="plyusy-i-minusy-coordinated-surfmvp">  Vor- und Nachteile von Coordinated SurfMVP </h2><br><p>  <strong>Vorteile:</strong> </p><br><ol><li>  Der Hauptvorteil des Koordinatoransatzes besteht in der M√∂glichkeit, ganze Navigationsbl√∂cke innerhalb der Anwendung wiederzuverwenden.  Jetzt k√∂nnen Sie von √ºberall in der Anwendung aus diesen Koordinator anrufen und √ºber nichts anderes nachdenken, als seine Arbeit abzuschlie√üen. </li><li>  Da die Navigationslogik in einem separaten Koordinator isoliert ist, ist es jetzt viel bequemer, der Navigation zu folgen: √ñffnen Sie nur eine Datei und das gesamte Bild vor Ihren Augen.  Es ist nicht mehr erforderlich, alle einzelnen Module zu durchstechen, um zu verstehen, worauf sie abzielen, die Anwendung zusammenzustellen und das Design zu betrachten. </li><li>  Es ist bequemer, in gro√üen Teams zu entwerfen.  In der Entwurfsphase eines separaten neuen Features ist es ausreichend, Zeit f√ºr den Aufbau der gesamten Navigation und die Initialisierung aller Module bereitzustellen. Anschlie√üend wird die Entwicklung an eine gro√üe Anzahl von Entwicklern delegiert, und die Integration dieser Bildschirme untereinander wird weitaus problemloser. </li><li>  Die Integration von Deeplinks und Push-Notifications bereitet keine Kopfschmerzen mehr. </li></ol><br><p>  <strong>Nachteile:</strong> </p><br><p>  Wie bei jedem architektonischen Ansatz gibt es auch bei Coordinated SurfMVP Nachteile. </p><br><ol><li>  Gro√üe Koordinatoren taten weh.  Aufgrund der Konzentration der gesamten Logik an einem Ort wird es viel schwieriger, nicht in einer gro√üen Anzahl von Codezeilen zu ertrinken.  Wenn Sie nicht dem Prinzip der geteilten Verantwortung folgen, kann der Koordinator nat√ºrlich zu einem gro√üen Monster heranwachsen, und alle Vorteile der Codelesbarkeit verschwinden leicht. </li><li>  Sie m√ºssen viel schreiben, um den Code sch√∂n zu machen.  Aufgrund der gro√üen Anzahl von Ebenen in der Anwendung, von denen jede f√ºr eine separate Aktion verantwortlich ist, m√ºssen Sie diese Ebenen durchbrechen, um den gew√ºnschten Koordinator zu erreichen. </li><li>  Speicherlecks - das Problem ist nicht neu, aber Sie sollten diese Angelegenheit befolgen, um nicht in das Loch zu geraten.  Der Hauptgrund f√ºr Speicherverluste bei der Arbeit mit Koordinatoren ist das Beibehalten von Zyklen in Modulr√ºckrufen.  Daher m√ºssen Sie die starken Verbindungen in den Verschl√ºssen sorgf√§ltig √ºberwachen. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Typischer Fall</b> <div class="spoiler_text"><p> Ein typischer Fall ist die Initialisierung des neuen Koordinators und die Implementierung von Closure FinishFlow.  Die Erfassung eines <code>weak coordinator</code> ist obligatorisch, andernfalls verweist der Koordinator auf sich selbst, was zu einem Leck in Form von AuthCoordinator f√ºhrt. </p><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runAuthFlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> coordinator = <span class="hljs-type"><span class="hljs-type">AuthCoordinator</span></span>(router: <span class="hljs-type"><span class="hljs-type">MainRouter</span></span>()) coordinator.finishFlow = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> coordinator] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.removeDependency(coordinator) } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addDependency(coordinator) coordinator.start() }</code> </pre> </div></div><br><h2 id="vyvody">  Schlussfolgerungen </h2><br><p>  In der Entwurfsphase haben wir die Komplexit√§t des Projekts untersch√§tzt und den falschen architektonischen Ansatz gew√§hlt.  Dieser Fehler hat jedoch dazu beigetragen, ein Regelwerk zu bilden und die Auswahl der Architektur bei der Initialisierung von Projekten sorgf√§ltiger zu treffen. </p><br><h3 id="kogda-ispolzovat-coordinated-surfmvp">  Wann soll Coordinated SurfMVP verwendet werden? </h3><br><p>  In der Tat, wenn Sie wollen, dann verwenden Sie es, aber wir halten uns an die folgenden Bedingungen: </p><br><ul><li>  Die Struktur der Bildschirme ist komplex und kann sich √§ndern. </li><li>  Es gibt Deeplinks und / oder Push-Notifications mit Navigation; </li><li>  Es ist notwendig, in einem gro√üen Team zu arbeiten. </li></ul><br><h3 id="kogda-ispolzovat-surfmvp">  Wann ist SurfMVP anzuwenden? </h3><br><p>  Wir haben unser erstes Architekturmuster nicht vergessen.  Wir verwenden es immer noch im Studio, wenn wir Projekte entwickeln, wenn es die folgenden Bedingungen erf√ºllt: </p><br><ul><li>  Das Projekt ist klein genug und plant keine rasche Entwicklung. </li><li>  Das Projekt hat eine sehr einfache Bildschirmstruktur und unterliegt keinen starken √Ñnderungen. </li></ul><br><h2 id="dopolnitelnye-materialy">  Zus√§tzliche Materialien </h2><br><ul><li>  <a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52">Architektur in iOS</a> <a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52"><br></a> </li><li>  <a href="https://en.wikipedia.org/wiki/Model%25E2%2580%2593view%25E2%2580%2593presenter">Was ist reines MVP?</a> </li><li>  <a href="https://developer.apple.com/design/human-interface-guidelines/ios/app-architecture/navigation/">Was ist flache Navigation?</a> </li><li>  Artikel und eine Geschichte von Soroush Khanlou √ºber Koordinatoren (mit denen der Begriff "Koordinator" verwendet wurde). <br><ol><li>  <a href="http://khanlou.com/2015/01/the-coordinator/">Der Koordinator</a> </li><li>  <a href="http://khanlou.com/2015/10/coordinators-redux/">Koordinatoren Redux</a> </li><li>  <a href="https://youtu.be/a1g3k3NObkE">CocoaHeads Stockholm \ Koordinatoren - Soroush Khanlou</a> </li></ol></li><li>  Artikel und Implementierungsbeispiel von Andrey Panov <br><ol><li>  <a href="https://github.com/AndreyPanov/ApplicationCoordinator">AndreyPanov / ApplicationCoordinator: Grundlegendes Tutorial f√ºr Koordinatoren</a> </li><li>  <a href="https://medium.com/blacklane-engineering/coordinators-essential-tutorial-part-i-376c836e9ba7">Artikel ‚ÄûCoordinators Essential Tutorial.</a>  <a href="https://medium.com/blacklane-engineering/coordinators-essential-tutorial-part-i-376c836e9ba7">Teil I ¬ª</a> </li><li>  <a href="https://medium.com/%40panovdev/coordinators-essential-tutorial-part-ii-b5ab3eb4a74">Artikel ‚ÄûCoordinators Essential Tutorial.</a>  <a href="https://medium.com/%40panovdev/coordinators-essential-tutorial-part-ii-b5ab3eb4a74">Teil II ¬ª</a> </li></ol></li><li>  <a href="https://badootech.badoo.com/screen-navigation-in-ios-dd99b09228b2">Ein Artikel von</a> Bogdan Orlov mit seinen Gedanken zur Anwendungsnavigation </li><li>  Materialien von Andrey Rychkovs Bericht √ºber den praktischen Einsatz von Koordinatoren <br><ol><li>  <a href="https://speakerdeck.com/cocoaheads/andriei-rychkov-how-to-deal-with-navigation">Andrey Rychkov: Wie man mit Navigation umgeht</a> </li><li>  <a href="https://github.com/Moonko/CoordinatorExample">Moonko / CoordinatorExample: Beispiel f√ºr einen Anwendungskoordinator</a> </li></ol></li></ul><br><p>  In diesem Artikel habe ich ein Problem mit der Architektur beschrieben, auf die wir bei der Arbeit gesto√üen sind.  Die Wahl der zu verwendenden Architektur liegt nat√ºrlich bei Ihnen.  Im n√§chsten Artikel werde ich die Probleme des Backends in gro√üen Projekten erl√§utern und erl√§utern, wie wir sie gel√∂st haben.  Bleib dran! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485172/">https://habr.com/ru/post/de485172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485156/index.html">Wie man ein h√§uslicher Crowdfunder ist (Teil 1)</a></li>
<li><a href="../de485158/index.html">Nikolay Vavilov. Der Mann, der die ganze Welt ern√§hren wollte und in einer Gef√§ngniszelle verhungerte</a></li>
<li><a href="../de485160/index.html">Was ist ich in ACID oder einer anderen Perspektive</a></li>
<li><a href="../de485162/index.html">Wie sich Codekommentare von den 1940ern bis 2020 entwickelten</a></li>
<li><a href="../de485164/index.html">Transformatoren und Hass in Vancouver: Wie Anti-Plagiat das NeurIPS-2019 beherrscht</a></li>
<li><a href="../de485174/index.html">Haskell-abh√§ngige Typen: Warum ist die Zukunft der Softwareentwicklung?</a></li>
<li><a href="../de485176/index.html">Sechs Konzepte zur Erl√§uterung von Produktmanagementkonzepten</a></li>
<li><a href="../de485178/index.html">Methode zur Rekonstruktion von verlorenen Geb√§uden aus Fotografien</a></li>
<li><a href="../de485180/index.html">Ben√∂tigen wir einen Datensee? Was tun mit dem Data Warehouse?</a></li>
<li><a href="../de485182/index.html">Sennheiser im Jahr 2020 - aktualisierte Funkkopfh√∂rer zum Jubil√§um</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>