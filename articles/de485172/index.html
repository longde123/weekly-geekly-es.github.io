<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏥 🐷 🈹 Architekturprobleme in großen Projekten 👨🏽‍🔬 🙎🏼 🧑🏿‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Entwicklung mobiler Apps scheint eine ziemlich einfache Aufgabe zu sein. Es scheint, was dort zu tun ist? Ich warf ein paar Ansichten, salbte es m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Architekturprobleme in großen Projekten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/485172/"><p>  Die Entwicklung mobiler Apps scheint eine ziemlich einfache Aufgabe zu sein.  Es scheint, was dort zu tun ist?  Ich warf ein paar Ansichten, salbte es mit etwas Architektur, und das war es, das Projekt ist fertig, Sie können die Anwendung an die Station senden.  In einer Reihe von Artikeln werde ich auf die Funktionen eingehen, auf die wir bei der Entwicklung einer Anwendung für eine große Bank gestoßen sind. </p><br><p>  Betrachten Sie 5 wichtige Themen.  Natürlich wurden die meisten von ihnen mehrmals in der Community diskutiert, aber hinter jedem Thema stehen Schmerzen, Tränen, Zeitverlust und vor allem die Erfahrung, die uns nützlich war, und ich hoffe, dass es Ihnen nützlich sein wird. </p><br><p><img src="https://habrastorage.org/webt/ix/2q/wk/ix2qwkfsj5gueik1fd0-r5pjuog.png" alt="Bild"></p><a name="habracut"></a><br><p>  Zu Beginn der Entwicklung einer mobilen Anwendung stellt sich dem Marktführer oder Designer die Frage, welches Architekturmuster zu verwenden ist.  Unser Studio hat ein gemeinsames Architekturmuster MVP.  Pure MVP ist in seiner reinen Form sicherlich gut (siehe Bild unten), aber wir wären keine echten Entwickler, wenn wir dieses Muster nicht finalisieren würden.  Sie haben nicht bei einer Option Halt gemacht, und wir haben zwei Zweige von reinem MVP erhalten. </p><br><p><img src="https://habrastorage.org/webt/cf/4d/2v/cf4d2vj2mn9rbneovqjig0lce7y.jpeg" alt="Bild"></p><br><p>  Daher standen wir in der Entwurfsphase vor der Aufgabe, eines auszuwählen und auf der Grundlage eines allgemein akzeptierten und verständlichen Architekturmusters fortzufahren.  Aber schon in einem so frühen Stadium ist es uns gelungen, einen Fehler zu machen, der uns später viele Probleme bescherte. </p><br><p>  Schauen wir uns zwei unserer MVPs zu Steroiden an. </p><br><h2 id="surfmvphttpsgithubcomsurfstudiosurf-ios-developersblobmastersurf_mvpmd">  <a href="">SurfMVP</a> </h2><br><p><img src="https://habrastorage.org/webt/l7/aa/fu/l7aafucodquvixudd7ygcsn_tbk.jpeg" alt="Bild"></p><br><p>  Das Bild zeigt, dass sich im Vergleich zum üblichen MVP nicht viel geändert hat.  Beim Wechseln zwischen Bildschirmen in iOS-Anwendungen sind einige Probleme aufgetreten.  Eine große Menge an Logik für die Bildung neuer Bildschirme, bevor der Übergang direkt im UIViewController konzentriert wird, erschien uns nicht ganz richtig. Deshalb haben wir zuerst die Router-Entität getrennt, die für die Übergänge zwischen Bildschirmen in der Anwendung verantwortlich ist. <br>  Modelle in SurfMVP sind die Dienste, die Presenter zum Abrufen von Daten aufruft.  Oft löst ein Dienst die Aufgaben für das gesamte Modul, aber in schwierigen Situationen muss man mit mehreren interagieren. <br>  Die Configurator-Entität ist für die Erstellung eines separaten Moduls verantwortlich, initialisiert alle erforderlichen Komponenten und ist für die Erstellung von Abhängigkeiten zwischen ihnen verantwortlich. </p><br><p><img src="https://habrastorage.org/webt/ws/bc/pz/wsbcpzpyevuhps1taqnd-m0gy3w.jpeg" alt="Bild"></p><br><p>  Das Hauptmerkmal von SurfMVP ist, dass jede Schicht in MVP durch ein Protokoll getrennt ist.  Das Bild zeigt ein Diagramm der Schichten und die Beziehung der Protokolle zwischen ihnen.  Protokolle werden benötigt, damit jede Schicht von der anderen getrennt und theoretisch leicht ersetzt werden kann.  Jede der Schichten sollte keine Implementierungsdetails offenlegen. </p><br><p>  <strong>Betrachten wir sie getrennt:</strong> </p><br><p>  <strong>ViewInput</strong> - implementiert <strong>View</strong> selbst, <strong>Presenter</strong> behält den Link bei.  Dieses Protokoll beschreibt die Methoden, mit denen <strong>Presenter</strong> die <strong>Ansicht</strong> steuern, Daten übertragen, Status ändern usw. kann. </p><br><p> <strong>ViewOutput</strong> - implementiert <strong>Presenter</strong> , <strong>View</strong> enthält einen Link dazu.  Das Protokoll beschreibt eine Reihe von Aktionen, die in der <strong>Ansicht</strong> und in den Lebenszyklusmethoden ausgeführt werden können, z. B. Ereignisse der Benutzerinteraktion mit dem Bildschirm. </p><br><p>  <strong>RouterInput</strong> - implementiert den <strong>Router</strong> , und <strong>Presenter</strong> behält eine Verknüpfung zu ihm bei, da dies der einzige ist, der für die weitere Navigation in der Anwendung verantwortlich ist. </p><br><p>  <strong>ModuleTransitionable</strong> - <strong>View</strong> ist implementiert, <strong>Router</strong> behält eine Verknüpfung dazu.  Dies ist das einzige "grundlegende" Protokoll in <strong>SurfMVP</strong> .  Es wird benötigt, um dem Router eine Reihe von Methoden für die Arbeit mit der Anwendungsnavigation bereitzustellen. </p><br><p>  <strong>ModuleInput</strong> - Implementiert <strong>Presenter</strong> .  Dieses Protokoll muss Methoden enthalten, mit denen ein anderes Modul, das eine Verknüpfung zu diesem Protokoll enthält, den Status des aktuellen Moduls ändern kann. </p><br><p>  <strong>ModuleOutput</strong> - implementiert den <strong>Presenter des</strong> aufrufenden Moduls, der Link enthält den <strong>Presenter des</strong> aufgerufenen Moduls.  Wenn der Profilbildschirm über das Nachrichtenmodul angezeigt werden kann, sollte <em>NewsPresenter</em> <em>ProfileModuleOutput</em> implementieren und <em>ProfilePresenter sollte</em> einen Link dazu enthalten. <br>  <strong>ModuleOutput</strong> wird an den <strong>Configurator</strong> des aufgerufenen Moduls übergeben und dort in <strong>Presenter</strong> installiert.  Enthält Modulmethoden, die das Verhalten des aufrufenden Moduls beeinflussen. </p><br><h2 id="problema-surfmvp">  SurfMVP Problem </h2><br><p>  Aus all diesen Gründen gibt es ein Hauptproblem: die Navigation.  Wie sich herausstellte, bestand die Meldung zum Hervorheben einer separaten Router-Entität zwar aus Navigationsproblemen, diese waren jedoch nicht mehr vorhanden.  SurfMVP wurde erfolgreich in Projekten mit einfacher <a href="https://developer.apple.com/design/human-interface-guidelines/ios/app-architecture/navigation/">flacher Navigation</a> ohne komplexe DeepLinks und Push-Benachrichtigungen eingesetzt. </p><br><p>  Das folgende Bild zeigt schematisch die Navigation in der Anwendung mit SurfMVP.  Jedes einzelne Modul kommuniziert über einen eigenen Router mit dem anderen.  Auf diese Weise wird die Navigation eines beliebigen Flusses in der Anwendung erstellt. </p><br><p><img src="https://habrastorage.org/webt/-v/jp/r_/-vjpr_9j8vrlfqrtr25aoislf_m.jpeg" alt="Bild"></p><br><p>  Diese Art der Navigation eignet sich gut für den Fall, dass der Benutzer den Ablauf seiner Wahl in der Anwendung durchläuft.  Zum Beispiel in der folgenden Abbildung: Der Benutzer durchläuft die Bildschirme von Punkt A bis Punkt D, sodass er selbst einen Stapel erstellt, auf dem er auf die gleiche Weise vor- und zurückgehen muss. </p><br><p><img src="https://habrastorage.org/webt/3x/qu/dp/3xqudpqcov2oqn32vx9cltkg9um.jpeg" alt="Bild"></p><br><p>  Probleme beginnen in dem Moment, in dem der Benutzer von Punkt A nach Punkt D versetzt werden muss, und dies sollte ohne seine Teilnahme geschehen.  Wenn ein Benutzer beispielsweise auf Push-Benachrichtigung klickt oder einem Link aus einer Drittanbieteranwendung folgt.  Im Fall von SurfMVP müssen wir einen globalen Router hinzufügen, der die Navigation steuert, unabhängig davon, wo sich der Benutzer gerade in der Anwendung befindet.  Um dieses Problem global zu lösen, haben wir uns entschlossen, die Koordinatoren zu nutzen. Gehen wir zu ihnen über. </p><br><p><img src="https://habrastorage.org/webt/rn/fn/mb/rnfnmbs2b7lias_cqvmpp6mvpz0.jpeg" alt="Bild"></p><br><h2 id="coordinated-surfmvp">  Koordiniertes SurfMVP </h2><br><p><img src="https://habrastorage.org/webt/bz/q3/qr/bzq3qrf53ggr3iczo32ex_rpcs0.jpeg" alt="Bild"></p><br><p>  Coordinated SurfMVP ist ein Architekturmuster, bei dem wir im Gegensatz zu SurfMVP die Router-Entität, die sich in jedem einzelnen Modul befand, entfernt haben.  Das Paradigma, eine Anwendung zu erstellen, hat sich ein wenig geändert.  Module sind nicht mehr vollständig unabhängig.  Jedes Modul, mit Ausnahme von vollständig wiederverwendbaren Modulen, befindet sich in einem separaten UserFlow, der wie geplant einige allgemeine Aktionen ausführen sollte, die den Benutzer zum gewünschten Ergebnis führen. </p><br><p>  Ein Beispiel für einen solchen Fluss in unserer Anwendung ist der Zahlungsfluss.  Zahlungen sind eine Reihe von Bildschirmen, auf denen der Benutzer eine Überweisung oder Zahlung auf verschiedene Arten vornehmen kann. </p><br><p>  In Coordinated SurfMVP ersetzte die Router-Entität die <a href="http://khanlou.com/2015/01/the-coordinator/">Coordinator-</a> Entität, die jetzt nicht nur für die Navigation eines einzelnen Moduls, sondern für eine Reihe von Modulen zuständig ist, die logisch miteinander verbunden sind.  Dies vereinfacht die Navigation und das Arbeiten mit der Anwendung.  Schematisch sieht unsere Bewerbung so aus: </p><br><p><img src="https://habrastorage.org/webt/ln/uv/ce/lnuvcepenm_ai5xuufuxn_3eff8.jpeg" alt="Bild"></p><br><p>  Ganz oben befindet sich der ApplicationCoordinator, der für das anfängliche Routing in der Anwendung verantwortlich ist.  In einem Fall, in dem der Benutzer autorisiert ist, werden wir ihn sofort an den Hauptteil der Anwendung senden. Andernfalls werden wir ihn an den Autorisierungsbildschirm senden. </p><br><p>  Wenn unsere Anwendung Deeplinks oder Push-Notifications enthält, können wir jederzeit Initialisierungs- und Startregeln für Koordinatoren festlegen, damit diese den Stapel direkt an dem gewünschten Punkt D erstellen, über den wir zuvor gesprochen haben. </p><br><p><img src="https://habrastorage.org/webt/bz/i6/i3/bzi6i3mk9bfzl6dgi1oselxjmxm.jpeg" alt="Bild"></p><br><p>  Schematisch sieht unsere Navigation jetzt so aus.  Jeder einzelne UserFlow verweist auf seinen eigenen Koordinator, der seinerseits entscheidet, was in Zukunft passieren wird.  Die Verantwortung für die Datenübertragung und die Einleitung der weiteren Navigation liegt jetzt beim Koordinator. Er ist bereits mit anderen Modulen oder anderen Koordinatoren verbunden, um den Navigationsstapel weiter aufzubauen. </p><br><h2 id="plyusy-i-minusy-coordinated-surfmvp">  Vor- und Nachteile von Coordinated SurfMVP </h2><br><p>  <strong>Vorteile:</strong> </p><br><ol><li>  Der Hauptvorteil des Koordinatoransatzes besteht in der Möglichkeit, ganze Navigationsblöcke innerhalb der Anwendung wiederzuverwenden.  Jetzt können Sie von überall in der Anwendung aus diesen Koordinator anrufen und über nichts anderes nachdenken, als seine Arbeit abzuschließen. </li><li>  Da die Navigationslogik in einem separaten Koordinator isoliert ist, ist es jetzt viel bequemer, der Navigation zu folgen: Öffnen Sie nur eine Datei und das gesamte Bild vor Ihren Augen.  Es ist nicht mehr erforderlich, alle einzelnen Module zu durchstechen, um zu verstehen, worauf sie abzielen, die Anwendung zusammenzustellen und das Design zu betrachten. </li><li>  Es ist bequemer, in großen Teams zu entwerfen.  In der Entwurfsphase eines separaten neuen Features ist es ausreichend, Zeit für den Aufbau der gesamten Navigation und die Initialisierung aller Module bereitzustellen. Anschließend wird die Entwicklung an eine große Anzahl von Entwicklern delegiert, und die Integration dieser Bildschirme untereinander wird weitaus problemloser. </li><li>  Die Integration von Deeplinks und Push-Notifications bereitet keine Kopfschmerzen mehr. </li></ol><br><p>  <strong>Nachteile:</strong> </p><br><p>  Wie bei jedem architektonischen Ansatz gibt es auch bei Coordinated SurfMVP Nachteile. </p><br><ol><li>  Große Koordinatoren taten weh.  Aufgrund der Konzentration der gesamten Logik an einem Ort wird es viel schwieriger, nicht in einer großen Anzahl von Codezeilen zu ertrinken.  Wenn Sie nicht dem Prinzip der geteilten Verantwortung folgen, kann der Koordinator natürlich zu einem großen Monster heranwachsen, und alle Vorteile der Codelesbarkeit verschwinden leicht. </li><li>  Sie müssen viel schreiben, um den Code schön zu machen.  Aufgrund der großen Anzahl von Ebenen in der Anwendung, von denen jede für eine separate Aktion verantwortlich ist, müssen Sie diese Ebenen durchbrechen, um den gewünschten Koordinator zu erreichen. </li><li>  Speicherlecks - das Problem ist nicht neu, aber Sie sollten diese Angelegenheit befolgen, um nicht in das Loch zu geraten.  Der Hauptgrund für Speicherverluste bei der Arbeit mit Koordinatoren ist das Beibehalten von Zyklen in Modulrückrufen.  Daher müssen Sie die starken Verbindungen in den Verschlüssen sorgfältig überwachen. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Typischer Fall</b> <div class="spoiler_text"><p> Ein typischer Fall ist die Initialisierung des neuen Koordinators und die Implementierung von Closure FinishFlow.  Die Erfassung eines <code>weak coordinator</code> ist obligatorisch, andernfalls verweist der Koordinator auf sich selbst, was zu einem Leck in Form von AuthCoordinator führt. </p><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runAuthFlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> coordinator = <span class="hljs-type"><span class="hljs-type">AuthCoordinator</span></span>(router: <span class="hljs-type"><span class="hljs-type">MainRouter</span></span>()) coordinator.finishFlow = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> coordinator] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.removeDependency(coordinator) } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addDependency(coordinator) coordinator.start() }</code> </pre> </div></div><br><h2 id="vyvody">  Schlussfolgerungen </h2><br><p>  In der Entwurfsphase haben wir die Komplexität des Projekts unterschätzt und den falschen architektonischen Ansatz gewählt.  Dieser Fehler hat jedoch dazu beigetragen, ein Regelwerk zu bilden und die Auswahl der Architektur bei der Initialisierung von Projekten sorgfältiger zu treffen. </p><br><h3 id="kogda-ispolzovat-coordinated-surfmvp">  Wann soll Coordinated SurfMVP verwendet werden? </h3><br><p>  In der Tat, wenn Sie wollen, dann verwenden Sie es, aber wir halten uns an die folgenden Bedingungen: </p><br><ul><li>  Die Struktur der Bildschirme ist komplex und kann sich ändern. </li><li>  Es gibt Deeplinks und / oder Push-Notifications mit Navigation; </li><li>  Es ist notwendig, in einem großen Team zu arbeiten. </li></ul><br><h3 id="kogda-ispolzovat-surfmvp">  Wann ist SurfMVP anzuwenden? </h3><br><p>  Wir haben unser erstes Architekturmuster nicht vergessen.  Wir verwenden es immer noch im Studio, wenn wir Projekte entwickeln, wenn es die folgenden Bedingungen erfüllt: </p><br><ul><li>  Das Projekt ist klein genug und plant keine rasche Entwicklung. </li><li>  Das Projekt hat eine sehr einfache Bildschirmstruktur und unterliegt keinen starken Änderungen. </li></ul><br><h2 id="dopolnitelnye-materialy">  Zusätzliche Materialien </h2><br><ul><li>  <a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52">Architektur in iOS</a> <a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52"><br></a> </li><li>  <a href="https://en.wikipedia.org/wiki/Model%25E2%2580%2593view%25E2%2580%2593presenter">Was ist reines MVP?</a> </li><li>  <a href="https://developer.apple.com/design/human-interface-guidelines/ios/app-architecture/navigation/">Was ist flache Navigation?</a> </li><li>  Artikel und eine Geschichte von Soroush Khanlou über Koordinatoren (mit denen der Begriff "Koordinator" verwendet wurde). <br><ol><li>  <a href="http://khanlou.com/2015/01/the-coordinator/">Der Koordinator</a> </li><li>  <a href="http://khanlou.com/2015/10/coordinators-redux/">Koordinatoren Redux</a> </li><li>  <a href="https://youtu.be/a1g3k3NObkE">CocoaHeads Stockholm \ Koordinatoren - Soroush Khanlou</a> </li></ol></li><li>  Artikel und Implementierungsbeispiel von Andrey Panov <br><ol><li>  <a href="https://github.com/AndreyPanov/ApplicationCoordinator">AndreyPanov / ApplicationCoordinator: Grundlegendes Tutorial für Koordinatoren</a> </li><li>  <a href="https://medium.com/blacklane-engineering/coordinators-essential-tutorial-part-i-376c836e9ba7">Artikel „Coordinators Essential Tutorial.</a>  <a href="https://medium.com/blacklane-engineering/coordinators-essential-tutorial-part-i-376c836e9ba7">Teil I »</a> </li><li>  <a href="https://medium.com/%40panovdev/coordinators-essential-tutorial-part-ii-b5ab3eb4a74">Artikel „Coordinators Essential Tutorial.</a>  <a href="https://medium.com/%40panovdev/coordinators-essential-tutorial-part-ii-b5ab3eb4a74">Teil II »</a> </li></ol></li><li>  <a href="https://badootech.badoo.com/screen-navigation-in-ios-dd99b09228b2">Ein Artikel von</a> Bogdan Orlov mit seinen Gedanken zur Anwendungsnavigation </li><li>  Materialien von Andrey Rychkovs Bericht über den praktischen Einsatz von Koordinatoren <br><ol><li>  <a href="https://speakerdeck.com/cocoaheads/andriei-rychkov-how-to-deal-with-navigation">Andrey Rychkov: Wie man mit Navigation umgeht</a> </li><li>  <a href="https://github.com/Moonko/CoordinatorExample">Moonko / CoordinatorExample: Beispiel für einen Anwendungskoordinator</a> </li></ol></li></ul><br><p>  In diesem Artikel habe ich ein Problem mit der Architektur beschrieben, auf die wir bei der Arbeit gestoßen sind.  Die Wahl der zu verwendenden Architektur liegt natürlich bei Ihnen.  Im nächsten Artikel werde ich die Probleme des Backends in großen Projekten erläutern und erläutern, wie wir sie gelöst haben.  Bleib dran! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485172/">https://habr.com/ru/post/de485172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485156/index.html">Wie man ein häuslicher Crowdfunder ist (Teil 1)</a></li>
<li><a href="../de485158/index.html">Nikolay Vavilov. Der Mann, der die ganze Welt ernähren wollte und in einer Gefängniszelle verhungerte</a></li>
<li><a href="../de485160/index.html">Was ist ich in ACID oder einer anderen Perspektive</a></li>
<li><a href="../de485162/index.html">Wie sich Codekommentare von den 1940ern bis 2020 entwickelten</a></li>
<li><a href="../de485164/index.html">Transformatoren und Hass in Vancouver: Wie Anti-Plagiat das NeurIPS-2019 beherrscht</a></li>
<li><a href="../de485174/index.html">Haskell-abhängige Typen: Warum ist die Zukunft der Softwareentwicklung?</a></li>
<li><a href="../de485176/index.html">Sechs Konzepte zur Erläuterung von Produktmanagementkonzepten</a></li>
<li><a href="../de485178/index.html">Methode zur Rekonstruktion von verlorenen Gebäuden aus Fotografien</a></li>
<li><a href="../de485180/index.html">Benötigen wir einen Datensee? Was tun mit dem Data Warehouse?</a></li>
<li><a href="../de485182/index.html">Sennheiser im Jahr 2020 - aktualisierte Funkkopfhörer zum Jubiläum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>