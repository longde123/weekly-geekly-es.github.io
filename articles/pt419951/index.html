<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖🏼 👼🏽 🐅 Experiência usando o WebRTC. Palestra Yandex 👃🏻 👈🏿 👩🏿‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O que é melhor usar ao desenvolver software - tecnologias nativas ou da web? Holivar sobre esse assunto não terminará em breve, mas poucos argumentarã...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Experiência usando o WebRTC. Palestra Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/419951/">  O que é melhor usar ao desenvolver software - tecnologias nativas ou da web?  Holivar sobre esse assunto não terminará em breve, mas poucos argumentarão que é útil duplicar funções nativas para uso em navegadores ou no WebView.  E se os aplicativos de chamadas existiam exclusivamente separadamente do navegador, agora são fáceis de implementar na Web.  O desenvolvedor Grigory Kuznetsov explicou como usar a tecnologia WebRTC para conexões P2P. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_Jvdi--GtOg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Como todos sabem, nos últimos anos, existem muitos aplicativos baseados na troca direta de dados entre dois navegadores, ou seja, P2P.  Estes são todos os tipos de mensagens instantâneas, bate-papos, discadores, videoconferências.  Também podem ser aplicativos que realizam algum tipo de computação distribuída.  Os limites da fantasia não são limitados de forma alguma. <br><a name="habracut"></a><br>  Como fazemos essa tecnologia?  Imagine que queremos fazer uma ligação de um navegador para outro.  E imagine quais etapas precisamos para alcançar esse objetivo.  Antes de tudo, parece que a ligação é nossa imagem, nossa voz, imagem e precisamos ter acesso aos dispositivos de mídia conectados ao computador: à câmera e ao microfone.  Depois de obter acesso, você precisa de dois navegadores, dois clientes, para se encontrarem.  É necessário ajudá-los de alguma forma a se conectar, alcançar, transmitir metainformação. <br><br>  Quando você chega, precisa iniciar a transferência de dados no modo P2P, ou seja, para garantir a transmissão dos fluxos de mídia.  Temos todos os itens necessários, estamos prontos para implementar nossa nova moto legal.  Mas isso é uma piada, somos engenheiros e entendemos que é caro, injustificado e arriscado.  Portanto, como engenheiros clássicos, vamos primeiro pensar em quais soluções já existem. <br><br>  Primeiro de tudo, a antiga tecnologia Adobe Flash moribunda.  Ela está realmente morrendo e a Adobe deixará de apoiá-lo até 2020.  A tecnologia realmente permitirá que você acesse seus dispositivos de mídia; dentro dele, você pode implementar toda a mecânica necessária para ajudar os navegadores a se conectarem, para que eles comecem a transmitir informações P2P, mas você inventará sua bicicleta novamente, porque não existe um padrão único, uma abordagem única para implementar esse método. transferência de dados. <br><br>  Você pode escrever um plugin para o navegador.  É assim que o Skype funciona para os navegadores que não suportam tecnologias mais modernas.  Você precisará implementar sua bicicleta, porque não existe um padrão único e isso também é ruim para os usuários, pois o usuário precisará instalar algum tipo de plug-in no navegador e executar ações adicionais.  Os usuários não gostam disso e não querem fazê-lo. <br><br>  E existe a tecnologia WebRTC - o Google Hangouts, o Facebook Messenger trabalham com ele.  O Voximplant o utiliza para que você possa fazer suas ligações.  Vamos nos aprofundar nisso com mais detalhes.  Esta é uma nova tecnologia em desenvolvimento, apareceu em 2011 e continua a se desenvolver.  O que ela permite fazer?  Tenha acesso à câmera e ao microfone.  Estabeleça uma conexão P2P entre dois computadores, dois navegadores.  Naturalmente, permite transferir fluxos de mídia em tempo real.  Além disso, permite transferir informações, ou seja, qualquer data binária, você também pode transmitir P2P, você pode criar seu próprio sistema de computação distribuído. <br><br>  Um ponto importante: o WebRTC não fornece aos navegadores uma maneira de se encontrar.  Podemos gerar todas as meta-informações necessárias sobre nossos entes queridos, mas como um navegador pode aprender sobre a existência de outro?  Como conectá-los?  Considere um exemplo. <br><br><img src="https://habrastorage.org/webt/8l/dc/lu/8ldclukfmmhiyusud1ftwkmvmi0.png"><br><br>  Existem dois clientes.  O primeiro cliente deseja fazer uma chamada para o segundo cliente.  O WebRTC fornece todas as informações necessárias para você se identificar.  Mas permanece a questão de como encontrar outro navegador, como enviar essa meta-informação, como inicializar a chamada.  Isso é deixado para os desenvolvedores, podemos usar absolutamente qualquer método, pegar essas meta-informações, imprimi-las em um pedaço de papel, enviá-las por correio, outro irá usá-las e tudo funcionará. <br><br>  E podemos criar algum mecanismo de sinalização.  Nesse caso, este é um mecanismo de terceiros que nos permitirá, se conhecermos nossos clientes, garantir a transferência entre eles de algumas informações necessárias para estabelecer uma conexão. <br><br>  Considere um exemplo usando um servidor de sinal.  Existe um servidor de sinal que mantém uma conexão constante com nossos clientes, por exemplo, via soquetes da web ou usando HTTP.  O primeiro cliente gera meta-informações e as envia ao servidor de sinal usando soquetes da web ou HTTP.  Ele também envia parte da informação com a qual deseja se conectar, por exemplo, um apelido ou outra informação. <br><br>  O servidor de sinal usando esse identificador determina qual cliente precisa redirecionar nossa meta-informação e a encaminha.  O segundo cliente pega, usa, instala a si próprio, forma uma resposta e, usando o mecanismo de sinalização, envia para o servidor de sinal, que por sua vez o retransmite para o primeiro cliente.  Portanto, atualmente, ambos os clientes têm toda a data e meta-informações necessárias para estabelecer uma conexão P2P.  Feito. <br><br>  Vamos examinar mais de perto exatamente o que os clientes estão trocando, eles estão trocando um datagrama SDP, Session Description Protocol. <br><br><img src="https://habrastorage.org/webt/zl/e-/ok/zle-oknfv3cz36cwgdbt00ldc4q.png"><br><br>  Este é essencialmente um arquivo de texto que contém todas as informações necessárias para estabelecer uma conexão.  Há informações sobre o endereço IP, sobre as portas que são usadas, sobre que tipo de informação está sendo perseguida entre os clientes, o que é - áudio, vídeo, quais codecs são usados.  Tudo o que precisamos está lá. <br><br>  Preste atenção na segunda linha.  Ele mostra o endereço IP do cliente, 192.168.0.15.  Obviamente, esse é o endereço IP de um computador que está em alguma rede local.  Se tivermos dois computadores, cada um deles na rede local, e cada um souber seu endereço IP nessa rede, eles desejam ligar.  Eles serão capazes de fazer isso com esse datagrama?  Obviamente não, eles não conhecem os endereços IP externos.  Como ser <br><br><img src="https://habrastorage.org/webt/6j/ol/xu/6jolxumekywnyr1txfh6vdhjk-a.png"><br><br>  Vamos nos afastar e ver como o NAT funciona.  Na Internet, muitos computadores estão ocultos atrás de roteadores.  Existem redes locais nas quais os computadores sabem seus endereços, há um roteador que possui um endereço IP externo e todos esses computadores se destacam com o endereço IP desse roteador.  Quando um pacote de um computador na rede local vai para o roteador, o roteador verifica para onde deve ser encaminhado.  Se em outra rede local, ele simplesmente a retransmitir, e se você precisar enviá-la para a Internet, será compilada uma tabela de roteamento. <br><br><img src="https://habrastorage.org/webt/0c/w3/vj/0cw3vj67zemxzrbjwe5cr0bfzvc.png"><br><br>  Nós preenchemos o endereço IP interno do computador que deseja encaminhar o pacote, sua porta, definimos o endereço IP externo, o endereço IP do roteador e também fazemos uma alteração de porta.  Para que serve?  Imagine que dois computadores estão acessando o mesmo recurso e precisamos rotear corretamente os pacotes de resposta.  Nós os identificaremos por porta, a porta será exclusiva para cada um dos computadores, enquanto o endereço IP externo corresponderá. <br><br>  Como viver se houver NAT, se os computadores permanecerem sob o mesmo endereço IP, mas por dentro eles se conhecerão pelo outro? <br><br>  A estrutura do ICE para o estabelecimento de conectividade com a Internet vem em socorro.  Ele descreve maneiras de ignorar o NAT, como estabelecer uma conexão se tivermos o NAT. <br><br>  Essa estrutura usa o chamado atributo do servidor STUN. <br><br><img src="https://habrastorage.org/webt/59/zv/am/59zvamcoxdislwvhlj3qkn2k_cq.png"><br><br>  Este é um servidor tão especial, referindo-se ao qual, você pode descobrir seu endereço IP externo.  Assim, no processo de estabelecer uma conexão P2P, cada cliente deve fazer uma solicitação a este servidor STUN para descobrir seu endereço IP e gerar informações adicionais, IceCandidate e trocar IceCandidate com o mecanismo de sinalização.  Em seguida, os clientes se conhecerão com os endereços IP corretos e poderão estabelecer uma conexão P2P. <br><br>  No entanto, existem casos mais complicados.  Por exemplo, quando o computador está oculto por trás do NAT duplo.  Nesse caso, a estrutura do ICE requer o uso de um servidor TURN. <br><br><img src="https://habrastorage.org/webt/yd/0r/j3/yd0rj3j5touybbu9ji2yxajvu0w.png"><br><br>  Este é um servidor tão especial que transforma uma conexão cliente-cliente, P2P, em uma conexão cliente-servidor-cliente, ou seja, atua como um relé.  A boa notícia para os desenvolvedores é que, independentemente de qual dos três cenários a conexão foi feita, se estamos na rede local, se precisamos recorrer a um servidor STUN ou TURN, a tecnologia da API será idêntica para nós.  Simplesmente indicamos no início a configuração dos servidores ICE e TURN, indicamos como acessá-los e, depois disso, a tecnologia faz tudo por nós sob o capô. <br><br><img src="https://habrastorage.org/webt/u5/gm/d3/u5gmd3hsoofg6zt_-gnop6nx0zs.png"><br><br>  Um breve resumo.  Para estabelecer uma conexão, você precisa selecionar e implementar algum tipo de mecanismo de sinalização, um certo intermediário que nos ajudará a enviar meta-informações.  O WebRTC nos dará toda a meta necessária para isso. <br><br>  Temos que lutar com o NAT, este é o nosso principal inimigo nesta fase.  Mas, para contornar isso, usamos o servidor STUN para descobrir nosso endereço IP externo e usamos o servidor TURN como retransmissão. <br><br>  O que exatamente estamos transmitindo?  Sobre fluxos de mídia. <br><br><img src="https://habrastorage.org/webt/qd/5n/sh/qd5nsho7njp_zbptyvvgxzgyeyk.png"><br><br>  Fluxos de mídia são canais que contêm faixas dentro de si.  As faixas no fluxo de mídia são sincronizadas.  Áudio e vídeo não divergem, eles vêm com um único tempo.  Você pode criar qualquer número de faixas dentro do fluxo de mídia; as faixas podem ser controladas separadamente; por exemplo, você pode silenciar o áudio, deixando apenas uma imagem.  Você também pode transferir qualquer número de fluxos de mídia, o que permite, por exemplo, implementar uma conferência. <br><br>  Como acessar a mídia de um navegador?  Vamos falar sobre a API. <br><br><img src="https://habrastorage.org/webt/xd/li/lw/xdlilwqq1hvfwsmpzbo2abyu22i.png"><br><br>  Existe um método getUserMedia que aceita um conjunto de constantes como entrada.  Este é um objeto especial em que você indica quais dispositivos deseja acessar, qual câmera e qual microfone.  Você especifica as características que deseja ter, qual resolução e também há dois argumentos - successCallback e errorCallback, que são chamados em caso de sucesso ou falha.  Implementações de tecnologia mais modernas usam promessas. <br><br>  Há também um método conveniente enumerateDevices que retorna uma lista de todos os dispositivos de mídia conectados ao seu computador, o que lhe dá a oportunidade de mostrá-los ao usuário, desenhe algum tipo de seletor para que o usuário escolha qual câmera específica deseja usar. <br><br><img src="https://habrastorage.org/webt/ga/vp/uo/gavpuolkqqbou4mgkr5nkgyn_ga.png"><br><br>  O objeto central na API é RTCPeerConnection.  Quando fazemos a conexão, usamos a classe RTCPeerConnection, que retorna o objeto peerConnection.  Como configuração, especificamos um conjunto de servidores ICE, ou seja, STUN e TURN, aos quais acessaremos durante o processo de instalação.  E há um importante evento onicecandidate que dispara toda vez que precisamos da ajuda do nosso mecanismo de sinalização.  Ou seja, a tecnologia WebRTC fez uma solicitação, por exemplo, para um servidor STUN, reconhecemos nosso endereço IP externo, um novo ICECandidate apareceu e precisamos enviá-lo usando um mecanismo de terceiros, o evento foi mais estressante. <br><br><img src="https://habrastorage.org/webt/ou/lu/zp/ouluzpi6ahoovtpo1acf01pblbe.png"><br><br>  Quando estabelecemos uma conexão e queremos inicializar a chamada, usamos o método createOffer () para formar o SDP inicial, oferecer SDP, a mesma meta informação que precisa ser enviada ao parceiro. <br><br>  Para defini-lo como PeerConnection, usamos o método setLocalDescription ().  O interlocutor recebe essas informações pelo mecanismo de sinalização, define-as usando o método setRemoteDescription () e gera uma resposta usando o método createAnswer (), que também é enviado ao primeiro cliente usando o mecanismo de sinalização. <br><br><img src="https://habrastorage.org/webt/-z/tt/ns/-zttnspmlmdyfjgvn6koame5duw.png"><br><br>  Quando obtivemos acesso à mídia, obtivemos o fluxo de mídia, transferimos para nossa conexão P2P usando o método addStream, e nosso interlocutor descobre isso, ele tem o evento onaddstream aparado.  Ele receberá nosso fluxo e poderá exibi-lo. <br><br><img src="https://habrastorage.org/webt/e5/4m/ot/e54mot_c6nmcg60na7bj-k7kbro.png"><br><br>  Você também pode trabalhar com fluxos de dados.  É muito semelhante à formação de um peerConnection regular, basta especificar RtpDataChannels: true e chamar o método createDataChannel ().  Não vou me debruçar sobre isso em detalhes, porque esse trabalho é muito semelhante ao trabalho com soquetes da web. <br><br>  Algumas palavras sobre segurança.  O WebRTC funciona apenas em HTTPS, seu site deve ser assinado com um certificado.  Os fluxos de mídia também são criptografados, usando DTLS.  A tecnologia não requer a instalação de nada extra, sem plug-ins, e isso é bom.  E não funcionará para criar um aplicativo spyware, o site não escutará ou espionará o usuário, ele mostrará ao usuário um prompt especial, solicitará acesso a ele e o receberá apenas se o usuário permitir acesso a dispositivos de áudio e mídia. <br><br><img src="https://habrastorage.org/webt/4d/pf/mp/4dpfmps0b2axjq2kyrshvgf-xaa.png"><br><br>  Quanto ao suporte ao navegador - o IE permanece e permanece vermelho.  No final do ano passado, o suporte ao Safari foi adicionado, ou seja, todos os navegadores modernos já podem trabalhar com essa tecnologia e podemos usá-la com segurança. <br><br>  Quero compartilhar um conjunto de todos os tipos de utilitários que o ajudarão se você quiser trabalhar com o WebRTC.  Este é principalmente um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">adaptador</a> .  As tecnologias estão em constante evolução e há uma diferença nas APIs do navegador.  A biblioteca de adaptadores elimina essa diferença e facilita o trabalho.  Uma biblioteca conveniente para trabalhar com fluxos de dados é o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Peerjs</a> .  Você também pode examinar as implementações de código aberto dos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">servidores</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">STUN</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TURN</a> .  Um grande conjunto de tutoriais, exemplos e artigos está na página <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">awesome-webrtc</a> , eu recomendo. <br><br>  A última ferramenta útil para depuração é webrtc-internals.  Durante o desenvolvimento, você pode digitar um comando especial na barra de endereços - por exemplo, no navegador Chrome, é Chrome: // webrtc-internals.  Você verá uma página com todas as informações sobre sua conexão atual com o WebRTC.  Haverá sequências de chamadas nos métodos e todos os datagramas trocados entre navegadores e gráficos que de alguma forma caracterizam sua conexão.  Em geral, haverá todas as informações necessárias durante a depuração e o desenvolvimento.  Obrigado pela atenção. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt419951/">https://habr.com/ru/post/pt419951/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt419941/index.html">Audiomania Office Photo Tour: Parte Um</a></li>
<li><a href="../pt419943/index.html">O que lemos em julho: como encontrar tempo para ler, cinco livros para o líder da equipe e alguns artigos novos</a></li>
<li><a href="../pt419945/index.html">Como se preparar para uma entrevista no Google e não passar nela. Duas vezes</a></li>
<li><a href="../pt419947/index.html">Conecte-se ao PiZeroW com Raspbian Stretch Lite, sem adaptadores adicionais e um monitor</a></li>
<li><a href="../pt419949/index.html">Quais codecs de vídeo (não) os navegadores usam para vídeo chamadas?</a></li>
<li><a href="../pt419953/index.html">Estou escrevendo um livro sobre a primeira “nossa” startup que conquistou o mundo: ajuda</a></li>
<li><a href="../pt419955/index.html">Recursos do buffer FIFO UART no ESP32</a></li>
<li><a href="../pt419961/index.html">O resumo de materiais interessantes para o desenvolvedor móvel 265 (6 a 12 de agosto)</a></li>
<li><a href="../pt419963/index.html">Fazemos um controlador "inteligente" para o ar condicionado no ESP8266</a></li>
<li><a href="../pt419965/index.html">Recursos de configuração do switch ExtremeXOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>