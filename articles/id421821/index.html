<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â²ï¸ ğŸ‘ˆğŸ¼ ğŸ‘¨ğŸ¿â€âš–ï¸ Kami menggunakan mosaik, pikselasi, dan topeng geometri Voronoi di shader untuk menghias situs ğŸ’ ğŸ¥‹ ğŸ§›ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini adalah kelanjutan logis dari pengenalan shader pemrograman untuk desainer tata letak . Di dalamnya, kami membuat templat untuk membuat ber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menggunakan mosaik, pikselasi, dan topeng geometri Voronoi di shader untuk menghias situs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421821/"><img src="https://habrastorage.org/webt/tw/dv/y5/twdvy5bonlmr47omgfhgmi9rjqu.jpeg" alt="gambar"><br><br><p> Artikel ini adalah kelanjutan logis dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengenalan shader pemrograman untuk desainer tata letak</a> .  Di dalamnya, kami membuat templat untuk membuat berbagai efek dua dimensi dengan foto menggunakan shader dan melihat beberapa contoh.  Pada artikel ini kami akan menambahkan beberapa tekstur lagi, menerapkan pembelahan Voronoi dalam praktek untuk membuat mosaik dari mereka, berbicara tentang membuat berbagai topeng di shader, tentang pixelation, dan juga menyentuh beberapa masalah sintaks GLSL kuno yang masih ada di browser kami. </p><br><p>  Sama seperti terakhir kali, akan ada teori minimum dan maksimum praktik dan penalaran dalam bahasa sehari-hari yang biasa.  Pemula akan menemukan di sini serangkaian tindakan dengan tips dan catatan yang berguna, dan vendor front-end yang berpengalaman dapat menemukan beberapa ide untuk inspirasi. </p><a name="habracut"></a><br><p>  <em>Sebuah survei dalam artikel sebelumnya menunjukkan bahwa topik efek WebGL untuk situs mungkin menarik tidak hanya untuk pengetik huruf, tetapi juga untuk rekan kami dari spesialisasi lainnya.</em>  <em>Agar tidak membingungkan mereka dengan fitur ES terbaru, kami sengaja membatasi diri pada konstruksi sintaksis yang lebih tradisional yang dipahami semua orang.</em>  <em>Dan sekali lagi saya menarik perhatian pembaca pada fakta bahwa editor bawaan dari CodePen mempengaruhi kinerja apa yang dilakukan di dalamnya.</em> </p><br><p>  Tapi mari kita mulai ... </p><br><h2 id="shablon-dlya-raboty-s-sheyderami">  Template untuk bekerja dengan shader </h2><br><p>  Bagi mereka yang belum membaca artikel sebelumnya, kami membuat template ini untuk bekerja dengan shader: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/ZMBMPJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Sebuah pesawat dibuat di dalamnya (dalam kasus kami, kotak) di mana tekstur gambar "digambar".  Tidak ada dependensi yang tidak perlu dan shader vertex yang sangat sederhana.  Kemudian kami mengembangkan templat ini, tetapi sekarang kami akan mulai dari saat ketika belum ada logika dalam shader fragmen. </p><br><h2 id="mozaika">  Mosaik </h2><br><p>  Mosaik adalah bidang yang dipecah menjadi daerah-daerah kecil, di mana masing-masing bidang diisi dengan warna tertentu atau, seperti dalam kasus kami, tekstur.  Bagaimana kita dapat mematahkan pesawat kita menjadi beberapa bagian?  Jelas, Anda dapat memecahnya menjadi empat persegi panjang.  Tapi ini sudah sangat mudah dilakukan dengan bantuan SVG, untuk menyeret WebGL ke tugas ini dan meletakkan semuanya tiba-tiba tanpa tujuan. </p><br><p>  Agar mosaik menarik, ia harus memiliki fragmen yang berbeda, baik dalam bentuk maupun ukuran.  Ada satu pendekatan yang sangat sederhana, tetapi pada saat yang sama sangat menghibur untuk membangun partisi seperti itu.  Dikenal sebagai mosaik Voronoi atau partisi Dirichlet, dan di Wikipedia ditulis bahwa Descartes menggunakan sesuatu yang serupa di abad XVII yang jauh.  Idenya kira-kira seperti ini: </p><br><ul><li>  Ambil satu set poin di pesawat. </li><li>  Untuk setiap titik di pesawat, cari titik terdekat dari set ini. </li><li>  Itu saja.  Bidang dibagi menjadi bidang poligonal, yang masing-masing ditentukan oleh salah satu titik dalam himpunan. </li></ul><br><p>  Mungkin lebih baik untuk menunjukkan proses ini dengan contoh praktis.  Ada algoritma yang berbeda untuk menghasilkan partisi ini, tetapi kami akan bertindak di dahi, karena menghitung sesuatu untuk setiap titik di pesawat hanyalah tugas untuk shader.  Pertama, kita perlu membuat satu set poin acak.  Agar tidak memuat kode contoh, kami akan membuat variabel global untuk mereka. </p><br><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { POINTS.push([<span class="hljs-type"><span class="hljs-type">Math.random</span></span>(), <span class="hljs-type"><span class="hljs-type">Math.random</span></span>()]); } }</code> </pre> <br><p>  Sekarang kita harus meneruskannya ke shader.  Data bersifat global, jadi kami akan menggunakan pengubah <code>uniform</code> .  Tetapi ada satu titik halus: kita tidak bisa hanya melewati sebuah array.  Tampaknya abad ke-21 ada di halaman, tetapi tidak ada yang datang darinya.  Akibatnya, Anda harus mentransfer sejumlah poin satu per satu. </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { GL.uniform2fv(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_points['</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-string"><span class="hljs-string">']'</span></span>), POINTS[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); }</code> </pre> <br><p>  Hari ini, kita akan sering menghadapi masalah ketidakkonsistenan yang serupa antara apa yang diharapkan dan apa yang ada di browser nyata.  Biasanya tutorial WebGL menggunakan THREE.js dan pustaka ini menyembunyikan beberapa kotoran itu sendiri, seperti yang pernah dilakukan jQuery dalam tugasnya, tetapi jika Anda menghapusnya, itu benar-benar melukai otak Anda. </p><br><p>  Di fragmen shader, kami memiliki variabel array untuk poin.  Kami hanya dapat membuat array dengan panjang tetap.  Mari kita mulai dengan 10 poin: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_POINTS 10 uniform vec2 u_points[NUMBER_OF_POINTS];</span></span></code> </pre> <br><p>  Pastikan semua ini berfungsi dengan menggambar lingkaran di tempat-tempat titik.  Gambar berbagai geometri primitif seperti ini sering digunakan selama debugging - mereka terlihat jelas dan Anda dapat segera memahami apa yang berada dan di mana ia bergerak. </p><br><blockquote>  Gunakan "gambar" lingkaran, garis, dan tengara lainnya untuk objek tak terlihat yang menjadi dasar pembuatan animasi.  Ini akan memberikan petunjuk yang jelas tentang cara kerjanya, terutama jika algoritmanya rumit untuk dipahami dengan cepat tanpa persiapan sebelumnya.  Kemudian semua ini dapat dikomentari dan diserahkan kepada kolega - mereka akan mengucapkan terima kasih. </blockquote><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; <span class="hljs-number"><span class="hljs-number">0.02</span></span>) { gl_FragColor = WHITE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/pONOme" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Bagus  Mari kita juga menambahkan beberapa gerakan ke poin.  Biarkan mereka bergerak dalam lingkaran untuk memulai, maka kita akan kembali ke masalah ini nanti.  Koefisien juga diletakkan pada mata, hanya untuk sedikit memperlambat gerakan mereka dan mengurangi amplitudo osilasi. </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movePoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeStamp)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timeStamp) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] += Math.sin(i * timeStamp / <span class="hljs-number"><span class="hljs-number">5000.0</span></span>) / <span class="hljs-number"><span class="hljs-number">500.0</span></span>; POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] += Math.cos(i * timeStamp / <span class="hljs-number"><span class="hljs-number">5000.0</span></span>) / <span class="hljs-number"><span class="hljs-number">500.0</span></span>; } } }</code> </pre> <br><p>  Kembali ke shader.  Untuk percobaan di masa mendatang, kami akan menemukan sejumlah area yang berguna di mana semuanya akan dibagi.  Jadi kami menemukan titik terdekat dengan piksel saat ini dari set dan menyimpan jumlah titik itu - itu adalah nomor area. </p><br><pre> <code class="hljs matlab">float min_distance = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; int area_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { float current_distance = distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current_distance &lt; min_distance) { min_distance = current_distance; area_index = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } }</code> </pre> <br><p>  Untuk menguji kinerja, kami sekali lagi mengecat semuanya dengan warna-warna cerah: </p><br><pre> <code class="hljs pgsql">gl_FragColor = texture2D(u_texture, texture_coord); gl_FragColor.g = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index))); gl_FragColor.b = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index)));</code> </pre> <br><blockquote>  Kombinasi modul (abs) dan fungsi terbatas (khususnya sin dan cos) sering digunakan ketika bekerja dengan efek yang sama.  Di satu sisi, ini menambahkan sedikit keacakan, dan di sisi lain, itu segera memberikan hasil yang dinormalisasi dari 0 hingga 1, yang sangat nyaman - kami memiliki banyak nilai yang terletak tepat di dalam batas-batas ini. </blockquote><p>  Kami juga akan menemukan poin kurang lebih sama dari beberapa poin dari set, dan mewarnai mereka.  Tindakan ini tidak membawa muatan khusus, tetapi melihat hasilnya masih menarik. </p><br><pre> <code class="hljs matlab">int number_of_near_points = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; min_distance + EPSILON) { number_of_near_points++; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number_of_near_points &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { gl_FragColor.rgb = vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Anda harus mendapatkan sesuatu seperti ini: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/xaRavJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Ini masih konsep, kami masih akan menyelesaikannya.  Tapi sekarang konsep umum pemisahan pesawat seperti itu sudah jelas. </p><br><h2 id="mozaika-iz-fotografiy">  Mosaik dari foto </h2><br><p>  Jelas bahwa dalam bentuknya yang murni tidak banyak manfaat dari partisi semacam itu.  Untuk memperluas wawasan Anda dan hanya untuk bersenang-senang, Anda dapat bermain dengannya, tetapi di situs nyata ada baiknya menambahkan beberapa foto lagi dan membuat mosaik dari mereka.  Mari kita ulangi fungsi membuat tekstur sedikit, sehingga ada lebih dari satu. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTextures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt; URLS.textures.length; i++)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crossOrigin</span></span></span><span class="hljs-function"> = '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anonymous</span></span></span><span class="hljs-function">'; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onload</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt; { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texture</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activeTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL['TEXTURE' + index])</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, texture)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pixelStorei</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.UNPACK_FLIP_Y_WEBGL, true)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texImage2D</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, 0, GL.RGB, GL.RGB, GL.UNSIGNED_BYTE, image)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uniform1i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.getUniformLocation(PROGRAM, 'u_textures[' + index + ']')</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function">); }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">src</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLS</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[index]</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><p>  Tidak ada yang tidak biasa terjadi, kami hanya mengganti nol dengan parameter <code>index</code> dan menggunakan kembali kode yang ada untuk memuat tiga tekstur.  Di shader, kami sekarang memiliki array tekstur: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_TEXTURES 3 uniform sampler2D u_textures[NUMBER_OF_TEXTURES];</span></span></code> </pre> <br><p>  Sekarang kita dapat menggunakan nomor area yang disimpan sebelumnya untuk memilih salah satu dari tiga tekstur.  Tapi ... </p><br><p>  Tetapi sebelum itu saya ingin melakukan penyimpangan kecil.  Tentang sakit.  Tentang sintaksisnya.  Javascript modern (bersyarat ES6 +) adalah bahasa yang bagus.  Hal ini memungkinkan Anda untuk mengekspresikan pikiran Anda saat muncul, tidak membatasi kerangka kerja untuk paradigma pemrograman tertentu, menyelesaikan beberapa poin untuk kami dan memungkinkan Anda untuk lebih fokus pada ide daripada pada implementasinya.  Untuk pencipta - itu dia.  Beberapa orang percaya bahwa itu memberi terlalu banyak kebebasan dan beralih ke TypeScript misalnya.  Pure C adalah bahasa yang lebih keras.  Ini juga memungkinkan banyak, Anda dapat memikat apa pun di atasnya, tetapi setelah JS dianggap sedikit canggung, kuno atau sesuatu.  Meskipun demikian, dia masih baik.  GLSL seperti yang ada di browser hanyalah sesuatu.  Tidak hanya urutan besarnya lebih ketat dari C, ia masih kekurangan banyak operator dan konstruksi sintaks yang dikenal.  Ini mungkin masalah terbesar ketika menulis shader yang lebih kompleks untuk WebGL.  Di balik kengerian bahwa kode berubah menjadi, bisa sangat sulit untuk melihat pada algoritma aslinya.  Beberapa coders berpikir bahwa sampai mereka belajar C, jalur menuju shader ditutup untuk mereka.  Jadi: pengetahuan tentang C tidak akan sangat membantu di sini.  Ini semacam dunia tersendiri.  Dunia kegilaan, dinosaurus dan kruk. </p><br><p>  Bagaimana saya bisa memilih salah satu dari tiga tekstur yang memiliki satu nomor - nomor area.  Sisanya terlintas dalam pikiran dari membagi nomor dengan jumlah tekstur.  Ide bagus  Hanya operator <code>%</code> , yang sudah menulis sendiri, tidak ada di sini.  Kesan memahami fakta ini dijelaskan dengan baik oleh gambar: </p><br><p><img src="https://habrastorage.org/webt/3j/w3/on/3jw3on4pazjczkana82degd6gcc.png" alt="gambar"></p><br><p>  Tentu saja, Anda berkata, "Ya, tidak masalah, ada fungsi <code>mod</code> - ayo ambil!".  Tetapi ternyata dia tidak menerima dua bilangan bulat, hanya bilangan pecahan.  Ok, well, buat <code>float</code> dari mereka.  Kami juga mendapatkan <code>float</code> , tetapi kami membutuhkan <code>int</code> .  Anda harus mengonversi semuanya kembali, jika tidak ada kemungkinan palsu untuk mendapatkan kesalahan kompilasi. </p><br><pre> <code class="hljs lisp">int texture_index = int(<span class="hljs-name"><span class="hljs-name">mod</span></span>(<span class="hljs-name"><span class="hljs-name">float</span></span>(<span class="hljs-name"><span class="hljs-name">area_index</span></span>), float(<span class="hljs-name"><span class="hljs-name">NUMBER_OF_TEXTURES</span></span>)))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Dan ini adalah pertanyaan retoris: mungkin akan lebih mudah untuk merealisasikan fungsinya dari sisa divisi integer daripada mencoba merakitnya dari metode standar?  Dan ini masih merupakan fungsi yang sederhana, dan kebetulan sekuens transformasi yang tertanam sangat dalam diperoleh di mana tidak lagi jelas apa yang terjadi. </p><br><p>  Oke, mari kita biarkan seperti sekarang.  Ambil saja warna piksel yang diinginkan dari tekstur yang dipilih dan tetapkan ke variabel <code>gl_FragColor</code> .  Jadi?  Apakah kita sudah melakukan ini?  Dan kemudian kucing ini muncul lagi.  Anda tidak dapat menggunakan non-konstan saat mengakses array.  Dan semua yang kita hitung tidak lagi konstan.  Ba-dum-tsss !!! </p><br><p>  Anda harus melakukan sesuatu seperti ini: </p><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">0</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">1</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">2</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">2</span></span>], texture_coord); }</code> </pre> <br><p>  Setuju, kode seperti itu adalah jalan langsung ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">govnokod.ru</a> , namun demikian, ini berbeda dalam hal apa pun.  Bahkan <code>switch-case</code> tidak ada di sini untuk setidaknya memuliakan aib ini.  Sebenarnya ada kruk lain yang kurang jelas yang memecahkan masalah yang sama: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>], texture_coord); } }</code> </pre> <br><p>  Penghitung siklus, yang bertambah satu, kompiler dapat dihitung sebagai konstanta.  Tapi ini tidak berhasil dengan array tekstur - di Chrome terakhir, muncul kesalahan mengatakan bahwa tidak mungkin untuk melakukan ini dengan array tekstur.  Dengan deretan angka, itu berhasil.  Coba tebak mengapa ia bekerja dengan satu array, tetapi tidak dengan yang lain?  Jika Anda berpikir bahwa sistem tipe casting di JS penuh dengan sihir - bereskan sistem "konstan - tidak konstan" di GLSL.  Yang lucu adalah bahwa hasilnya juga tergantung pada kartu video yang digunakan, sehingga kruk rumit yang bekerja pada kartu grafis NVIDIA mungkin sangat rusak pada AMD. </p><br><blockquote>  Lebih baik untuk menghindari keputusan seperti itu berdasarkan asumsi tentang kompiler.  Mereka cenderung pecah dan sulit untuk diuji. </blockquote><p>  Kesedihan adalah kesedihan.  Tetapi, jika kita ingin melakukan hal-hal menarik, kita perlu mengabstraksi dari semua ini dan melanjutkan. </p><br><p>  Saat ini, kami mendapat mosaik foto.  Tapi ada satu detail: jika poinnya sangat dekat satu sama lain, maka ada transisi cepat dari dua area.  Tidak terlalu cantik.  Anda perlu menambahkan beberapa algoritma yang tidak memungkinkan poin untuk mendekati.  Anda dapat membuat opsi sederhana, di mana jarak antara titik diperiksa dan, jika kurang dari nilai tertentu, maka kami dorong keduanya.  Pilihan ini bukan tanpa kekurangan, khususnya, kadang-kadang mengarah ke sedikit kejang poin, tetapi dalam banyak kasus mungkin cukup, terutama karena tidak ada banyak perhitungan di sini.  Opsi yang lebih maju adalah sistem pemindahan biaya dan "sarang laba-laba" di mana pasangan poin dihubungkan oleh mata air yang tidak terlihat.  Jika Anda tertarik untuk mengimplementasikannya, maka Anda dapat dengan mudah menemukan semua rumus dalam buku referensi fisika untuk sekolah menengah. </p><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let j = i; j &lt; NUMBER_OF_POINTS; j++) { let deltaX = POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] - POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; let deltaY = POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] - POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]; let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) { POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaX); POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaY); POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaX); POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaY); } } }</code> </pre> <br><p>  Masalah utama dengan pendekatan ini, serta yang kami gunakan dalam shader, adalah membandingkan semua poin dengan semua.  Anda tidak perlu menjadi ahli matematika yang hebat untuk memahami bahwa jumlah perhitungan jarak akan luar biasa jika kita tidak melakukan 10 poin, tetapi 1000. Ya, bahkan 100 sudah cukup untuk semuanya memperlambat.  Karena itu, masuk akal untuk menerapkannya hanya untuk sejumlah kecil poin. </p><br><p>  Jika kita ingin membuat mosaik seperti itu untuk sejumlah besar poin, maka kita dapat menggunakan pembagian pesawat yang sudah dikenal menjadi kotak yang identik.  Idenya adalah untuk menempatkan satu titik di setiap kotak, dan kemudian melakukan semua perbandingan hanya dengan poin dari kotak tetangga.  Ide yang bagus, tetapi percobaan telah menunjukkan bahwa dengan sejumlah besar poin, laptop murah dengan kartu video terintegrasi masih belum dapat mengatasinya.  Oleh karena itu, perlu dipikirkan sepuluh kali sebelum memutuskan untuk membuat mosaik di situs Anda dari sejumlah besar fragmen. </p><br><blockquote>  Jangan lobak, periksa kinerja kerajinan Anda tidak hanya di pertanian pertambangan Anda, tetapi juga pada laptop biasa.  Pengguna pada dasarnya akan menjadi orang-orang. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEYN" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="razbienie-ploskosti-na-chasti-po-grafiku-funkcii">  Mempartisi bidang menurut grafik fungsi </h2><br><p>  Mari kita lihat opsi lain untuk membagi pesawat menjadi beberapa bagian.  Ini tidak lagi membutuhkan daya komputasi yang besar.  Gagasan utamanya adalah mengambil beberapa fungsi matematika dan membangun grafiknya.  Garis yang dihasilkan hanya akan membagi pesawat menjadi dua bagian.  Jika kita menggunakan fungsi dari bentuk <code>y = f(x)</code> , kita mendapatkan pembagian dalam bentuk potongan.  Mengganti X dengan Y, kita dapat mengubah bagian horizontal menjadi vertikal.  Jika Anda mengambil fungsi dalam koordinat kutub, maka Anda perlu menerjemahkan semuanya ke dalam Cartesian dan sebaliknya, tetapi esensi dari perhitungan tidak akan berubah.  Dalam hal ini, hasilnya bukan memotong menjadi dua bagian, melainkan memotong lubang.  Tapi kita akan melihat opsi pertama. </p><br><p>  Untuk setiap Y, kami akan menghitung nilai X untuk membuat bagian vertikal.  Kita bisa mengambil gelombang sinus untuk tujuan ini, misalnya, tetapi terlalu membosankan.  Lebih baik mengambil beberapa potong sekaligus dan melipatnya. </p><br><p>  Kami mengambil beberapa sinusoid, yang masing-masing terikat ke koordinat sepanjang Y dan ke waktu, dan menambahkannya.  Fisikawan akan menyebut adisi superposisi ini.  Jelas, mengalikan seluruh hasil dengan beberapa angka, kami mengubah amplitudo.  Keluarkan dalam makro terpisah.  Jika Anda mengalikan koordinat - parameter sinus, maka frekuensinya akan berubah.  Kami telah melihat ini di artikel sebelumnya.  Kami juga menghapus pengubah frekuensi yang umum untuk semua sinusoid dari rumus.  Tidak akan berlebihan untuk bermain dengan waktu, tanda negatif akan memberikan efek memindahkan garis ke arah yang berlawanan. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span> = u_time * SPEED; <span class="hljs-type"><span class="hljs-type">float</span></span> x = (sin(texture_coord.y * FREQUENCY) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.1</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">1.72</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">1.121</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.221</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">0.437</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">3.1122</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">4.269</span></span>)) * AMPLITUDE;</code> </pre> <br><p>  Setelah membuat pengaturan global untuk fungsi kita, kita akan menghadapi masalah mengulangi gerakan yang sama pada interval yang cukup singkat.  Untuk mengatasi masalah ini, kita perlu melipatgandakan semuanya dengan koefisien yang kelipatan terkecilnya sangat besar.  Sesuatu yang serupa juga digunakan dalam generator angka acak, ingat?  Dalam hal ini, kami tidak berpikir dan mengambil angka yang sudah jadi dari beberapa contoh dari Internet, tetapi tidak ada yang mengganggu untuk bereksperimen dengan nilai-nilai kami. </p><br><p>  Tetap hanya untuk memilih salah satu dari dua tekstur untuk poin di atas grafik fungsi kami dan yang kedua untuk poin di bawahnya.  Lebih tepatnya ke kiri dan kanan, kita semua berbalik: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (texture_coord.x - <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> &gt; x) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); }</code> </pre> <br><p>  Apa yang kami terima menyerupai gelombang suara.  Lebih tepatnya, gambar mereka di osiloskop.  Memang, kita bisa bukannya sinusoid kita mengirimkan data dari beberapa jenis file suara.  Tetapi bekerja dengan suara adalah topik untuk artikel terpisah. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEeO" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="maski">  Topeng </h2><br><p>  Contoh sebelumnya harus mengarah pada komentar yang cukup logis: semua ini terlihat seperti karya topeng di SVG (jika Anda belum bekerja dengan mereka, lihat contoh dari artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">topeng SVG dan efek wow</a> ).  Hanya saja di sini kita melakukannya sedikit berbeda.  Dan hasilnya sama - beberapa area dicat dengan satu tekstur, beberapa dengan yang lain.  Hanya transisi yang mulus belum.  Jadi mari kita lakukan satu. </p><br><p>  Kami menghapus semua yang tidak perlu dan mengembalikan koordinat mouse.  Buat gradien radial dengan pusat di lokasi kursor dan gunakan sebagai mask.  Dalam contoh ini, perilaku shader akan lebih mirip dengan logika topeng di SVG daripada di contoh sebelumnya.  Kita membutuhkan fungsi <code>mix</code> dan beberapa fungsi jarak.  Yang pertama akan mencampur nilai-nilai warna piksel dari kedua tekstur, dengan mengambil sebagai parameter ketiga koefisien (dari 0 ke 1) yang menentukan nilai mana yang akan menang sebagai hasilnya.  Kami mengambil modulus sinus sebagai fungsi jarak - itu hanya akan memberikan perubahan halus dalam nilai antara 0 dan 1. </p><br><pre> <code class="hljs lisp">gl_FragColor = mix( <span class="hljs-name"><span class="hljs-name">texture2D</span></span>(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord), texture2D(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord), abs(<span class="hljs-name"><span class="hljs-name">sin</span></span>(<span class="hljs-name"><span class="hljs-name">length</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span> - u_mouse_position / u_canvas_size))))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Itu saja.  Mari kita lihat hasilnya: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/bxBmwB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Keuntungan utama dibandingkan SVG jelas: </p><br><blockquote>  Tidak seperti SVG, di sini kita dapat dengan mudah membuat gradien halus untuk berbagai fungsi matematika, dan tidak mengumpulkannya dari banyak gradien linier. </blockquote><p>  Jika Anda memiliki tugas yang lebih sederhana yang tidak memerlukan transisi mulus atau bentuk rumit yang dihitung dalam proses, maka kemungkinan besar akan lebih mudah untuk diterapkan tanpa menggunakan shader.  Ya, dan kinerja perangkat keras yang lemah cenderung lebih baik.  Pilih alat berdasarkan tugas Anda. </p><br><p>  Untuk tujuan pendidikan, mari kita lihat contoh lain.  Pertama, buat lingkaran di mana teksturnya akan tetap seperti itu: </p><br><pre> <code class="hljs objectivec">gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = distance(texture_coord, u_mouse_position / u_canvas_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dist &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Dan isi sisanya dengan garis-garis diagonal: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = sin((texture_coord.y - texture_coord.x) * <span class="hljs-number"><span class="hljs-number">200.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { gl_FragColor.rgb *= dist; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gl_FragColor.rgb *= dist / <span class="hljs-number"><span class="hljs-number">10.0</span></span>; }</code> </pre> <br><p>  Penerimaannya sama - kami mengalikan parameter untuk sinus untuk meningkatkan frekuensi garis-garis;  bagilah nilai yang diperoleh menjadi dua bagian;  untuk masing-masing bagian, kami mengubah warna piksel dengan cara kami sendiri.  Penting untuk diingat bahwa menggambar garis-garis diagonal biasanya dikaitkan dengan menambahkan koordinat dalam X dan Y. Perhatikan bahwa kami juga menggunakan jarak ke kursor mouse saat mengubah warna, sehingga menciptakan semacam bayangan.  Dengan cara yang sama, Anda dapat menggunakannya dengan transformasi geometris, kita akan segera melihat ini pada contoh pixelation.  Sementara itu, lihat hasil shader ini: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/rZWqyK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Sederhana dan cantik. </p><br><blockquote>  Dan ya, jika Anda sedikit bingung, Anda dapat membuat tekstur bukan dari gambar, tetapi dari bingkai dari video (ada banyak contoh di jaringan, Anda dapat dengan mudah menemukan mereka), dan menerapkan semua efek kami kepada mereka.  Banyak situs direktori seperti Awwwards menggunakan efek ini bersamaan dengan video. </blockquote><p>  Patut diingat satu pikiran lagi: </p><br><blockquote>  Tidak ada yang mengganggu menggunakan salah satu tekstur sebagai topeng.  Kita dapat mengambil gambar dan menggunakan nilai warna pikselnya dalam transformasi kami, apakah itu perubahan warna lain, bergeser ke samping atau sesuatu yang lain yang muncul di pikiran Anda. </blockquote><p>  Namun kembali membagi pesawat menjadi beberapa bagian. </p><br><h2 id="pikselizaciya">  Pixelisasi </h2><br><p>  Efek ini agak jelas, tetapi pada saat yang sama sangat umum sehingga akan salah untuk melewati.  Bagilah bidang kita menjadi bujur sangkar, dengan cara yang sama seperti pada contoh dengan generator derau, dan kemudian untuk semua piksel di dalam setiap kotak kita mengatur warna yang sama.  Itu diperoleh dengan mencampurkan nilai-nilai dari sudut-sudut sebuah bujur sangkar, kami sudah melakukan hal serupa.  Untuk efek ini, kita tidak perlu rumus rumit, jadi tambahkan saja semua nilai dan bagi dengan 4 - jumlah sudut kotak. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin(u_time)) / <span class="hljs-number"><span class="hljs-number">20.0</span></span>; vec2 block_position = floor(texture_coord / block_size) * block_size; gl_FragColor = ( texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) ) / <span class="hljs-number"><span class="hljs-number">4.0</span></span>;</code> </pre> <br><p>  Kami kembali mengikat salah satu parameter ke waktu melalui modul sinus untuk melihat secara visual apa yang terjadi ketika itu berubah. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/eLBPej" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="pikselnye-volny">  Gelombang piksel </h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akhirnya, kita akan sekali lagi menerapkan teknik yang sudah kita ketahui di satu tempat untuk menambahkan gelombang ke contoh piksel. </font></font></p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin( length(texture_coord - u_mouse_position / u_canvas_size) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - u_time)) / <span class="hljs-number"><span class="hljs-number">100.0</span></span> + <span class="hljs-number"><span class="hljs-number">0.001</span></span>;</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakan modul sinus untuk menggerakkan semuanya dari 0 hingga 1; </font><font style="vertical-align: inherit;">tambahkan jarak dari posisi saat ini ke kursor mouse, waktu, dan pilih beberapa koefisien untuk membuat semuanya terlihat indah. </font><font style="vertical-align: inherit;">Kami menambahkan konstanta kecil ke hasil sehingga tidak ada ukuran nol blok.</font></font></p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/EeNdEr" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>    "" ,              ,    -.     .       " ",     ,         .     .      â€”  .       . </p><br><h2 id="itogi">  Ringkasan </h2><br><p>         ,     ,  ,    ,           .                    -.     -       -  .          .          .    ,      ,      ,      . </p><br><hr><br><p> <em>PS:  ,   WebGL (      )          ?     ,   ,   .          ?</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421821/">https://habr.com/ru/post/id421821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421809/index.html">API Java EE Concurrency</a></li>
<li><a href="../id421811/index.html">IETF telah mengusulkan standar baru untuk pengiriman pesan - apa yang perlu Anda ketahui</a></li>
<li><a href="../id421815/index.html">Logam cair di laptop enam bulan kemudian</a></li>
<li><a href="../id421817/index.html">Bekerja dengan formulir di React.js menggunakan alat dasar</a></li>
<li><a href="../id421819/index.html">Stack ELK untuk menyimpan log aplikasi Django</a></li>
<li><a href="../id421823/index.html">Bagaimana kami membawa X-Ray x64</a></li>
<li><a href="../id421827/index.html">Apa yang harus dibaca tentang Java sekarang?</a></li>
<li><a href="../id421829/index.html">Anomali Frango - romansa fantastis dengan orang-orang nyata dari IT</a></li>
<li><a href="../id421833/index.html">Kami menulis program kami yang paling sederhana untuk ARM Cortex-M3</a></li>
<li><a href="../id421835/index.html">Komisi Antarlembaga mengembangkan teknologi baru untuk memblokir Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>