<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📤 🤝 ☪️ Pengindeks dalam C # di bawah tenda: pengindeksan lebih baik dari Dow Jones 🎭 🔱 👩🏼‍🤝‍👨🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari yang baik Dalam artikel ini, saya mengusulkan untuk berkenalan dengan pengindeks dalam berbagai jenis. Mari kita lihat kode bahasa assembler untu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengindeks dalam C # di bawah tenda: pengindeksan lebih baik dari Dow Jones</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450428/">  Hari yang baik  Dalam artikel ini, saya mengusulkan untuk berkenalan dengan pengindeks dalam berbagai jenis.  Mari kita lihat kode bahasa assembler untuk pengindeks ini dan karakteristik masing-masing instruksi dalam kecepatannya.  Saya juga akan menawarkan beberapa kesimpulan yang jelas.  Tetapi apa sebenarnya yang harus digunakan dalam situasi khusus Anda bergantung pada Anda apakah akan mengorbankan kenyamanan untuk kecepatan atau sebaliknya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/22/aw/ng/22awng79cibgcbel1r2v0ahwzc8.png" alt="gambar" width="100%"></div><a name="habracut"></a><br><h3>  Metrik </h3><br>  Kode bahasa assembly diberikan untuk sistem 64 bit.  Metrik berikut dipilih sebagai metrik untuk setiap instruksi: jumlah operasi mikro yang digabungkan, jumlah total operasi mikro, penundaan, throughput, dan, tentu saja, jumlah instruksi.  Saya tidak memberikan angka apa pun secara keseluruhan untuk pengindeks, karena  situasinya dapat bervariasi tergantung pada bagaimana Anda bekerja dengan tipe yang diindeks dan mempengaruhi cache secara berbeda. <br><br>  Di bawah ini adalah ringkasan singkat dari terminologi, tanpa menggali lebih dalam, hanya konsep konseptual.  Tujuan saya adalah menggambarkan segala sesederhana mungkin, untuk pemahaman bersama. <br><br>  <b>Operasi mikro (uop)</b> adalah operasi tertentu yang terdiri dari setiap instruksi.  Konsep operasi mikro digunakan untuk optimisasi seperti penggabungan, caching, dan pemesanan ulang.  Jadi, misalnya, instruksi MOV terdiri dari 1 operasi mikro, sedangkan instruksi XCHG pada dua register terdiri dari 3 operasi mikro (pendekatannya adalah melalui "variabel sementara", yaitu, register internal, terima kasih <i>leotsarev</i> untuk pembaruan), instruksi XCHG atas register dan memori terdiri dari 8 operasi mikro. <br><br>  <b>Operasi mikro gabungan (fusi uops)</b> - sebagaimana disebutkan di atas, menggabungkan operasi mikro adalah salah satu optimisasi.  Ini terdiri dari mengganti dua operasi mikro dengan satu lagi yang kompleks. <br><br>  <b>Latensi</b> adalah jumlah tindakan setelah data yang digunakan dalam instruksi ini akan tersedia untuk digunakan oleh instruksi lain. <br><br>  <b>Throughput (Reciprocal throughput)</b> - jumlah siklus jam yang diperlukan untuk menjalankan satu instruksi, asalkan urutan instruksi yang identik dijalankan dan mereka beroperasi dengan data independen. <br><br>  Berdasarkan indikator-indikator ini, Anda dapat mengevaluasi kinerja seperangkat instruksi tertentu.  Harap perhatikan bahwa kami hanya dapat "mengevaluasi", kinerja sebenarnya tergantung pada banyak faktor, seperti hit atau miss cache, ketergantungan data, dll. <br><br>  Angka-angka ini untuk arsitektur prosesor Intel Skylake-X.  Ini sesuai dengan prosesor Intel Core i7-6700 saya. <br><br>  Perlu diingat juga bahwa fastcall untuk sistem 64 bit menyediakan transfer bukan 2, tetapi 4 parameter dalam register (rcx, rdx, r8, r9). <br><br><h3>  Pengindeks dalam angka </h3><br><h4>  1. Array indexer </h4><br>  Kami akan mempertimbangkan metode berikut sebagai contoh: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] array</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array[index]; }</code> </pre> <br>  Pertimbangkan kode bahasa assembler untuk cuplikan ini. <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r8+8] 2. jae 00007ff9`07288c78 3. movsxd rax,edx 4. mov eax,dword ptr [r8+rax*4+10h]</code> </pre><br>  Baris pertama memeriksa apakah indeks melampaui batas array.  Baris kedua melempar pengecualian jika keluar.  Selanjutnya, kita menghitung posisi elemen dalam array.  Kolom pertama dalam array adalah informasi layanan, jadi kita perlu melewati mereka (tambahan 10 jam = 16 byte). <br><br><div class="spoiler">  <b class="spoiler_title">Informasi tentang instruksi:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Tidak. </th><th>  Uops yang menyatu </th><th>  Jumlah total </th><th>  Latensi </th><th>  Throughput timbal balik </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  4 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br><br><h4>  2. Daftar Favorit &lt;&gt; </h4><br>  Kode Tinta: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; list</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list[index]; }</code> </pre><br><br>  Kode bahasa rakitan: <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r8+10h] 2. jae M00_L00 3. mov rax,qword ptr [r8+8] 4. cmp edx,dword ptr [rax+8] 5. jae 00007ff9`07268f56 6. movsxd rdx,edx 7. mov eax,dword ptr [rax+rdx*4+10h] ret M00_L00 call System.ThrowHelper.ThrowArgumentOutOfRange_IndexException()</code> </pre><br>  Jelas ada lebih banyak instruksi di sini.  Jelas terlihat bahwa sheet indexer membungkus array indexer.  Hal yang menarik adalah bahwa pengecekan untuk melampaui batas array dilakukan dua kali.  Jadi, instruksi pertama memeriksa apakah indeks melampaui batas lembar.  Jika ya, maka kita melompat (instruksi 2) ke panggilan yang sangat jelas, melempar pengecualian jika melampaui batas array.  Pemeriksaan perbatasan ini menggunakan bidang bagian dalam lembar, yang merupakan urutan kedua (offset 10 jam (16) byte dari awal jenis, 8 ke penunjuk ke tabel metode dan 8 ke tautan ke larik internal - bidang pertama).  Pada baris ketiga, kita masukkan rax register ke alamat array internal - field pertama (dengan analogi, offset 8 byte adalah pointer ke tabel metode).  Ini diikuti oleh bagian yang sudah akrab - referensi indeks untuk array (baris 4 - 7).  Di sini, untuk memeriksa batas-batas, bidang internal array digunakan. <br>  Saya mencoba untuk menghapus hal-hal yang tidak terkait langsung dengan pengindeksan, tapi di sini ada baiknya untuk tetap ret sehingga tidak tampak bahwa pada akhir setiap panggilan ke elemen sheet akan ada pengecualian: D <br><br>  Ngomong-ngomong, agar tidak menyiksa Anda dengan spekulasi, harap biasakan diri Anda dengan implementasi lembar <a href="">dengan referensi</a> .  Jenis casting ke int unsigned digunakan untuk mengurangi jumlah perbandingan. <br><br>  Sebagai hasilnya, kami mendapatkan 7 instruksi untuk berhasil mengakses indeks, yaitu 3 lebih banyak dari pada array. <br><br><div class="spoiler">  <b class="spoiler_title">Informasi tentang instruksi:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Tidak. </th><th>  Uops yang menyatu </th><th>  Jumlah total </th><th>  Latensi </th><th>  Throughput timbal balik </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr><tr><td>  4 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  5 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  6 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  7 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br><h4>  Baru - Rentang &lt;&gt; </h4><br>  Disc: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerSpan</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> span[index]; }</code> </pre><br>  Dan dalam bahasa assembly: <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r8+8] 2. jae 00007ff9`07278f69 3. mov rax,qword ptr [r8] 4. movsxd rdx,edx 5. mov eax,dword ptr [rax+rdx*4]</code> </pre><br>  Ketika bentang diumumkan, mereka berjanji kepada kami bahwa mereka dibuat dengan bijak, dengan dukungan runtime.  Dan mereka tidak berbohong harus berkata apa.  Bahkan, ini berbeda dari array klasik hanya dalam satu instruksi, langkah tambahan untuk mengakses alamat.  Dilihat oleh kode ini, alamat lokasi memori disembunyikan di dalam rentang, di mana elemen berada, yang kita dapatkan di baris 3. Ini bisa menjadi alamat ke tempat tertentu dalam array, garis, atau sepotong memori pada tumpukan. <br>  Klik di sini untuk pengantar Span pengindeks untuk bersenang-senang.  Anda mungkin memperhatikan bahwa ada 2 implementasi yang berbeda, tergantung pada variabel lingkungan.  PROJECTN adalah nama kode dari versi pertama .NET Native untuk UWP.  Oleh karena itu, kami lebih tertarik pada versi kedua dari pengindeks.  Dia ditandai <a href=""><i>[Intrinsik]</i></a> .  Selain itu, jika Anda melihat kelas <a href="">Tidak Aman</a> statis yang digunakan dalam implementasi pengindeks ini, Anda dapat menemukan informasi bahwa implementasi sebagian besar metode dalam file ini direpresentasikan sebagai <i>Intrinsik</i> . <br><br>  Metode panggilan atau referensi ke bidang yang ditandai dengan atribut <i>[Intrinsik]</i> mendapat dukungan dari runtime. <br><br>  Dalam <b>CoreCLR</b> , badan metode tersebut digantikan oleh EE (mesin Eksekusi) dengan kode tidak aman (tidak aman).  Jika Anda membutuhkan detail lebih lanjut, Anda bisa mulai menggali dengan metode <a href="">getILIntrinsicImplementationForUnsafe</a> . <br><br>  Informasi tentang bagaimana ini bekerja di <b>CoreRT</b> (yang menarik minat saya sedikit), <br>  Anda dapat mulai melihat <a href="">Internal.IL.Stubs.UnsafeIntrinsics</a> . <br><br>  Dengan dukungan dari raintime, untuk memahami apa yang sebenarnya akan terjadi di balik layar, masuk akal untuk melihat petunjuk dalam bahasa assembler, yang kami lakukan. <br><br><div class="spoiler">  <b class="spoiler_title">Informasi tentang instruksi:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Tidak. </th><th>  Uops yang menyatu </th><th>  Jumlah total </th><th>  Latensi </th><th>  Throughput timbal balik </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr><tr><td>  4 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  5 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br>  Semua pengindeks sangat tergantung pada data: instruksi menggunakan hasil yang sebelumnya.  Tidak ada hasil yang tidak biasa di sini, dan seharusnya tidak ada.  Tetapi sekarang overhead yang muncul dalam kasus ini atau itu sudah jelas.  Beberapa temuan jelas.  Jika algoritma melibatkan akses yang sangat sering dengan indeks, maka masuk akal untuk berpikir tentang mengganti sheet dengan array.  Jika panggilan tidak terlalu sering, maka mungkin lebih nyaman menggunakan sheet yang menyediakan api yang sangat nyaman dan tidak memiliki overhead yang besar (saya ingatkan Anda untuk memantau ekstensi array internal). <br><br>  Sekarang mari kita coba melihat cara-cara berbeda yang dengannya kita dapat menentukan array dua dimensi: array array (array bergerigi) dan array multidimensi (array multidimensi). <br><br><h4>  4. Array multidimensi </h4><br>  Kode Sharp: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerDimensionalArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] demensionalArray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> demensionalArray[index1, index2]; }</code> </pre><br>  Bahasa majelis: <br><br><pre> <code class="plaintext hljs">1. mov eax,edx 2. sub eax,dword ptr [r9+18h] 3. cmp eax,dword ptr [r9+10h] 4. jae 00007ff9`00098fe6 5. mov edx,r8d 6. sub edx,dword ptr [r9+1Ch] 7. cmp edx,dword ptr [r9+14h] 8. jae 00007ff9`00098fe6 9. mov ecx,dword ptr [r9+14h] 10. imul rcx,rax 11. mov rax,rdx 12. add rax,rcx 13. mov eax,dword ptr [r9+rax*4+20h]</code> </pre><br>  Semuanya dapat dimengerti secara prinsip - 2 memeriksa batas array, kemudian menghitung indeks dan membalikkan.  Array ini disimpan dalam memori dalam satu fragmen. <br><br><div class="spoiler">  <b class="spoiler_title">Informasi tentang instruksi:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Tidak. </th><th>  Uops yang menyatu </th><th>  Jumlah total </th><th>  Latensi </th><th>  Throughput timbal balik </th></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td><td>  0-1 </td><td>  0,25 </td></tr><tr><td>  2 </td><td>  1 </td><td>  2 </td><td></td><td>  0,5 </td></tr><tr><td>  3 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  4 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  5 </td><td>  1 </td><td>  1 </td><td>  0-1 </td><td>  0,25 </td></tr><tr><td>  6 </td><td>  1 </td><td>  2 </td><td></td><td>  0,5 </td></tr><tr><td>  7 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  8 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  9 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr><tr><td>  10 </td><td>  1 </td><td>  1 </td><td>  3 </td><td>  1 </td></tr><tr><td>  11 </td><td>  1 </td><td>  1 </td><td>  0-1 </td><td>  0,25 </td></tr><tr><td>  12 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  13 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br><br><h4>  5. Array array (array bergerigi) </h4><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerJaggedArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] jaggedArray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jaggedArray[index][index2]; }</code> </pre><br>  Assembler: <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r9+8] 2. jae 00007ff9`00098f95 3. movsxd rax,edx 4. mov rax,qword ptr [r9+rax*8+10h] 5. cmp r8d,dword ptr [rax+8] 6. jae 00007ff9`00098f95 7. movsxd rdx,r8d 8. mov eax,dword ptr [rax+rdx*4+10h]</code> </pre><br>  Dan yang paling menarik - kami memiliki lebih sedikit instruksi dibandingkan dengan tipe multidimensi yang dibuat khusus. <br><br><div class="spoiler">  <b class="spoiler_title">Informasi tentang instruksi:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Tidak. </th><th>  Uops yang menyatu </th><th>  Jumlah total </th><th>  Latensi </th><th>  Throughput timbal balik </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  4 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr><tr><td>  5 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  6 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  7 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  8 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br>  Tetapi tentang 2 contoh terakhir, saya menyarankan Anda untuk tidak terburu-buru mengambil kesimpulan.  Karena kenyataan bahwa array dua dimensi adalah tipe tunggal, yang diinisialisasi 1 kali, memori untuk seluruh array dialokasikan dalam satu fragmen besar.  Ini akan memberikan cache yang lebih baik, yang secara fundamental dapat mengubah situasi.  Dalam array array, memori untuk setiap array akan dialokasikan secara terpisah, sehingga kemungkinan array akan dialokasikan dalam memori dan dimasukkan di tempat yang paling cocok untuk mereka. <br><br>  Namun, mungkin bagi sebagian orang, perilaku ini akan lebih dapat diterima.  Mungkin dalam beberapa situasi diketahui bahwa masa hidup spesimen ini akan berumur pendek.  Dan agar tidak jatuh ke sekelompok benda besar (yang merupakan semacam generasi kedua untuk pengumpul sampah), di mana ada kesempatan untuk tinggal untuk waktu yang lama, jauh lebih banyak daripada yang kita inginkan.  Atau setelah beberapa waktu kami hanya ingin bekerja dengan garis-garis tertentu, dan segala sesuatu yang lain dapat dihapus.  Plus, ini direncanakan untuk bekerja dengan tipe yang mengacu pada elemen acak yang tidak konsisten, ketika cache tidak dapat bekerja secara normal. <br><br>  Juga, ketika menggunakan array array, lebih cenderung tidak memprovokasi pengumpul sampah untuk dipadatkan, tetapi harus dilakukan dengan sapuan.  Pengingat: saat memecah memori, jumlah total ruang kosong mungkin cukup untuk objek baru, tetapi tidak ada area bebas terus menerus dari jumlah yang diperlukan.  Dalam hal ini, pemadatan dilakukan - menggerakkan objek dengan tujuan defragmentasi.  Jika kita dapat mengambil rentangan terus menerus dari memori bebas untuk objek baru, kita cukup memasukkan objek ke ruang kosong ini.  Ini disebut sapuan. <br><br>  Saya harap informasi ini membantu Anda untuk menarik kesimpulan yang tepat dan mendukung pendapat Anda dalam diskusi tentang apa yang harus digunakan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450428/">https://habr.com/ru/post/id450428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450416/index.html">Bagaimana penyedia VPN shareware menjual data Anda</a></li>
<li><a href="../id450418/index.html">Seni Membuat Model 3D Organik: Subdermal Shaders</a></li>
<li><a href="../id450420/index.html">Mengapa Tim Ilmu Pengetahuan Data Perlu Universal, Bukan Spesialis</a></li>
<li><a href="../id450422/index.html">Keterbatasan algoritma pengenalan gambar</a></li>
<li><a href="../id450426/index.html">2011 vs AM4. Dinosaurus vs Mamalia</a></li>
<li><a href="../id450430/index.html">Apa itu Serangan Debu?</a></li>
<li><a href="../id450432/index.html">Nah, dimana dia?</a></li>
<li><a href="../id450436/index.html">Apa itu bootcamp pengkodean?</a></li>
<li><a href="../id450438/index.html">Mengapa otomatisasi pusat kontak menjadi kegelapan yang mengerikan tanpa CRM?</a></li>
<li><a href="../id450440/index.html">Tentang batu dari langit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>